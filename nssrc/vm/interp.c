/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.99 uuid: 3a15adab-a4d3-49c1-82a1-6ed02b158658
   from
	NewspeakInterpreter VMMaker.oscog-eem.99 uuid: 3a15adab-a4d3-49c1-82a1-6ed02b158658
 */
static char __buildInfo[] = "NewspeakInterpreter VMMaker.oscog-eem.99 uuid: 3a15adab-a4d3-49c1-82a1-6ed02b158658 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include "sq.h"
#include "vmCallback.h"
#include "dispdbg.h"
#include "sqMemoryAccess.h"


void printCallStack(void);

/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline off
void
warning(char *s) { /* Print an error message but don't exit. */
	printf("\n%s\n", s);
}
#pragma auto_inline on

void
invalidCompactClassError(char *s) { /* Print a compact class index error message and exit. */
	static sqInt printingStack = true; /* not running at this point */

	printf("\nClass %s does not have the required compact class index\n", s);
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 */
#if WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif


/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFUL
#define AllButImmutabilityBit 0xDFFFFFFFUL
#define AllButMarkBit 0x7FFFFFFFUL
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFUL
#define AllButTypeMask 0xFFFFFFFCUL
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BaseHeaderSize 4
#define BlockArgumentCountIndex 3
#define Byte0Mask 0xFF
#define Byte1Mask 0xFF00
#define Byte1Shift 8
#define Byte1ShiftNegated -8
#define Byte2Mask 0xFF0000
#define Byte3Mask 0xFF000000UL
#define Byte3Shift 24
#define Byte3ShiftNegated -24
#define Byte4Mask 0x0
#define Byte4Shift 0
#define Byte4ShiftNegated 0
#define Byte5Mask 0x0
#define Byte5Shift 0
#define Byte5ShiftNegated 0
#define Byte6Mask 0x0
#define Byte7Mask 0x0
#define Byte7Shift 0
#define Byte7ShiftNegated 0
#define Bytes3to0Mask 0x0
#define Bytes7to4Mask 0x0
#define BytesPerOop 4
#define BytesPerWord 4
#define CacheProbeMax 3
#define CallerIndex 0
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockContext 11
#define ClassBlockContextCompactIndex 13
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassInteger 5
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 0
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassString 6
#define ClassUnsafeAlien 54
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne -1
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DoAssertionChecks 0
#define Done 4
#define EnclosingMixinIndex 3
#define EnclosingObjectIndex 4
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FailImbalancedPrimitives 0
#define FalseObject 1
#define FirstLinkIndex 0
#define GCTopMarker 3
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#define HomeIndex 5
#define IMMUTABILITY 1
#define ImmutabilityBit 0x20000000
#define InitialIPIndex 4
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define LargeContextBit 0x40000
#define LargeContextSize 252
#define LastLinkIndex 1
#define LiteralStart 1
#define LongSizeMask 0xFFFFFFFCUL
#define MarkBit 0x80000000UL
#define MaxExternalPrimitiveTableSize 1024
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageDictionaryIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrim 4
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MixinIndex 3
#define MyListIndex 3
#define NextLinkIndex 0
#define NilContext 1
#define NilObject 0
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimitiveExternalCallIndex 117
#define PrimNoErr 0
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RecordPrimTrace 0
#define RecordSendTrace 0
#define RemapBufferSize 25
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorAttemptToAssign 50
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SenderIndex 0
#define ShiftForWord 2
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSize 92
#define SpecialSelectors 23
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define StreamArrayIndex 0
#define StreamIndexIndex 1
#define StreamReadLimitIndex 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TempFrameStart 6
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TraceLogSize 256
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define ValueIndex 1
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFUL
#define XIndex 0
#define YIndex 1


/*** Function Prototypes ***/
sqInt interpret(void);
static sqInt accessibleObjectAfter(sqInt oop);
static sqInt activateNewClosureMethod(sqInt blockClosure);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
static sqInt addNewMethodToCache(void);
static sqInt addressCouldBeObjWhileForwarding(sqInt address);
sqInt addressCouldBeObj(sqInt address);
sqInt addressCouldBeOop(sqInt address);
static sqInt addressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize);
static sqInt adjustAllOopsBy(sqInt bytesToShift);
static sqInt allocateOrRecycleContext(sqInt needsLarge);
static sqInt allYoungand(sqInt array1, sqInt array2);
sqInt argumentCountOf(sqInt methodPointer);
void * arrayValueOf(sqInt arrayOop);
static sqInt asciiOfCharacter(sqInt characterObj);
sqInt becomewith(sqInt array1, sqInt array2);
static sqInt becomewithtwoWaycopyHashforceImmutables(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag, sqInt immutablesOk);
void beRootIfOld(sqInt oop);
sqInt booleanValueOf(sqInt obj);
static sqInt byteLengthOf(sqInt oop);
sqInt byteSizeOf(sqInt oop);
static sqInt byteSwapByteObjectsFromto(sqInt startOop, sqInt stopAddr);
sqInt byteSwapped(sqInt w);
static sqInt callExternalPrimitive(void (*functionID)());
static sqInt changeClassOfto(sqInt rcvr, sqInt argClass);
sqInt characterForAscii(sqInt ascii);
sqInt characterTable(void);
sqInt checkedIntegerValueOf(sqInt intOop);
sqInt checkedLongAt(sqInt byteAddress);
static sqInt checkForInterrupts(void);
static sqInt checkHeapIntegrity(void);
sqInt classAlien(void);
sqInt classArray(void);
sqInt classBitmap(void);
sqInt classByteArray(void);
sqInt classCharacter(void);
sqInt classExternalAddress(void);
sqInt classExternalData(void);
sqInt classExternalFunction(void);
sqInt classExternalLibrary(void);
sqInt classExternalStructure(void);
sqInt classFloat(void);
sqInt classLargeNegativeInteger(void);
sqInt classLargePositiveInteger(void);
static sqInt classNameOfIs(sqInt aClass, char *className);
sqInt classPoint(void);
sqInt classSemaphore(void);
sqInt classSmallInteger(void);
sqInt classString(void);
sqInt classUnsafeAlien(void);
static void clearLeakMapAndMapAccessibleObjects(void);
sqInt clone(sqInt oop);
static sqInt commonAtPut(sqInt stringy);
static sqInt commonAt(sqInt stringy);
static sqInt commonVariableatcacheIndex(sqInt rcvr, sqInt index, sqInt atIx);
sqInt compactClassAt(sqInt ccIndex);
sqInt compactClassIndexOfHeader(sqInt header);
static sqInt compare31or32Bitsequal(sqInt obj1, sqInt obj2);
static sqInt containOnlyMutableOopsand(sqInt array1, sqInt array2);
static sqInt containOnlyOops(sqInt array);
static sqInt containOnlyOopsand(sqInt array1, sqInt array2);
static sqInt contexthasSender(sqInt thisCntx, sqInt aContext);
sqInt copyBits(void);
sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
static sqInt cr(void);
static sqInt createActualMessageTo(sqInt aClass);
char * cStringOrNullFor(sqInt oop);
static double dbgFloatValueOf(sqInt oop);
static sqInt displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
sqInt displayObject(void);
static sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt doPrimitiveModby(sqInt rcvr, sqInt arg);
sqInt doSignalSemaphoreWithIndex(sqInt index);
static sqInt dummyReferToProxy(void);
sqInt dumpPrimTraceLog(void);
sqInt dumpSendTraceLog(void);
static sqInt existImmutableReferencesToForwardedInRangeFromto(sqInt memStart, sqInt memEnd);
static sqInt externalQuickPrimitiveResponse(void);
static sqInt extraHeaderBytes(sqInt oopOrChunk);
sqInt failed(void);
static sqInt failUnbalancedPrimitive(void);
sqInt falseObject(void);
void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt fetchClassOfNonInt(sqInt oop);
sqInt fetchClassOf(sqInt oop);
double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static sqInt fetchStackPointerOf(sqInt aContext);
static sqInt fetchWordLengthOf(sqInt objectPointer);
static void finalizeReference(usqInt oop);
static sqInt findApplicationOfTargetMixinstartingAtBehavior(sqInt targetMixin, sqInt aBehavior);
sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static sqInt findHomeForContext(sqInt aContext);
static sqInt findNewMethodInClass(sqInt class);
sqInt findSelectorOfMethodforReceiver(sqInt meth, sqInt rcvr);
void * firstFixedField(sqInt oop);
void * firstIndexableField(sqInt oop);
double floatArg(sqInt index);
sqInt floatObjectOf(double aFloat);
double floatValueOf(sqInt oop);
static sqInt flushExternalPrimitiveOf(sqInt methodPtr);
static sqInt flushExternalPrimitives(void);
sqInt forceInterruptCheck(void);
sqInt formatOfClass(sqInt classPointer);
sqInt fullDisplayUpdate(void);
void fullGC(void);
static sqInt fwdBlockValid(sqInt addr);
static sqInt fwdTableInit(sqInt blkSize);
static sqInt fwdTableSize(sqInt blkSize);
sqInt getCurrentBytecode(void);
sqInt getDeferDisplayUpdates(void);
sqInt getFullScreenFlag(void);
sqInt getInterruptCheckCounter(void);
sqInt getInterruptKeycode(void);
sqInt getInterruptPending(void);
static sqInt getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag);
sqInt getNextWakeupTick(void);
sqInt getSavedWindowSize(void);
EXPORT(sqInt) getStackPointer(void);
sqInt getThisSessionID(void);
sqInt highBit(usqInt anUnsignedValue);
void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
static sqInt imageFormatForwardCompatibilityVersion(void);
static sqInt imageSegmentVersion(void);
static sqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static sqInt incCompMove(sqInt bytesFreed);
sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
void incrementalGC(void);
static sqInt initializeInterpreter(sqInt bytesToShift);
static void initializeMemoryFirstFree(sqInt firstFree);
static void initializeObjectMemory(sqInt bytesToShift);
static sqInt installinAtCacheatstring(sqInt rcvr, sqInt *cache, sqInt atIx, sqInt stringy);
sqInt instanceSizeOf(sqInt classObj);
sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt instantiateContextsizeInBytes(sqInt classPointer, sqInt sizeInBytes);
static sqInt instantiateSmallClasssizeInBytes(sqInt classPointer, sqInt sizeInBytes);
sqInt integerArg(sqInt index);
sqInt integerObjectOf(sqInt value);
sqInt integerValueOf(sqInt objectPointer);
EXPORT(sqInt) internalIsImmutable(sqInt oop);
EXPORT(sqInt) internalIsMutable(sqInt oop);
sqInt ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
sqInt isArray(sqInt oop);
sqInt isBytes(sqInt oop);
static sqInt isClassOfNonImmequalTocompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
sqInt isCompiledMethod(sqInt oop);
sqInt isFloatObject(sqInt oop);
static sqInt isHandlerMarked(sqInt aContext);
static sqInt isImmutableWhileForwarding(sqInt oop);
sqInt isIndexable(sqInt oop);
sqInt isInMemory(sqInt address);
sqInt isIntegerObject(sqInt objectPointer);
sqInt isIntegerValue(sqInt intValue);
sqInt isMarked(sqInt oop);
sqInt isOopCompiledMethod(sqInt oop);
sqInt isPointers(sqInt oop);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
static sqInt isWeakNonInt(sqInt oop);
sqInt isWeak(sqInt oop);
static sqInt isWordsOrBytesNonInt(sqInt oop);
sqInt isWordsOrBytes(sqInt oop);
sqInt isWords(sqInt oop);
sqInt isYoung(sqInt oop);
static sqInt isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
sqInt isKindOfClass(sqInt oop, sqInt aClass);
sqInt isKindOf(sqInt oop, char *className);
sqInt isMemberOf(sqInt oop, char *className);
static sqInt lastPointerOf(sqInt oop);
sqInt lengthOf(sqInt oop);
static sqInt lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
sqInt literalCountOf(sqInt methodPointer);
sqInt literalofMethod(sqInt offset, sqInt methodPointer);
sqInt loadBitBltFrom(sqInt bb);
sqInt loadInitialContext(void);
static sqInt lookupInMethodCacheSelclass(sqInt selector, sqInt class);
static sqInt lookupMethodInClass(sqInt class);
static sqInt lookupMethodInDictionary(sqInt dictionary);
static sqInt lookupMethodNoMNUEtcInClass(sqInt class);
static sqInt lowestFreeAfter(sqInt chunk);
sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static sqInt mapTraceLogs(void);
static sqInt markAndTraceTraceLogs(void);
void markAndTrace(sqInt oop);
static void markPhase(void);
sqInt maybeSplObj(sqInt index);
sqInt methodArgumentCount(void);
sqInt methodArg(sqInt index);
sqInt methodPrimitiveIndex(void);
sqInt methodReturnValue(sqInt oop);
EXPORT(sqInt) moduleUnloaded(char *aModuleName);
sqInt nilObject(void);
static sqInt nonWeakFieldsOf(sqInt oop);
sqInt objectAfter(sqInt oop);
sqInt objectArg(sqInt index);
sqInt objectBefore(sqInt address);
sqInt objectExactlyBefore(sqInt oop);
static sqInt objectIsImmutableAndReferencesForwarded(sqInt oop);
sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt okayOop(sqInt signedOop);
static sqInt oopFromChunk(sqInt chunk);
static sqInt oopHasAcceptableClass(sqInt signedOop);
static sqInt oopHasOkayClass(sqInt signedOop);
sqInt popRemappableOop(void);
static sqInt popStack(void);
sqInt pop(sqInt nItems);
sqInt popthenPush(sqInt nItems, sqInt oop);
sqInt positive32BitIntegerFor(sqInt integerValue);
sqInt positive32BitValueOf(sqInt oop);
sqInt positive64BitIntegerFor(sqLong integerValue);
sqLong positive64BitValueOf(sqInt oop);
unsigned long positiveMachineIntegerValueOf(sqInt oop);
static void possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
static sqInt prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
static sqInt primitiveAdd(void);
static sqInt primitiveAdoptInstance(void);
static sqInt primitiveArctan(void);
static sqInt primitiveArrayBecome(void);
static sqInt primitiveArrayBecomeForceImmutables(void);
static sqInt primitiveArrayBecomeOneWay(void);
static sqInt primitiveArrayBecomeOneWayCopyHash(void);
static sqInt primitiveArrayBecomeOneWayForceImmutables(void);
static sqInt primitiveAsFloat(void);
static sqInt primitiveAsOop(void);
static sqInt primitiveAt(void);
static sqInt primitiveAtEnd(void);
static sqInt primitiveAtPut(void);
static sqInt primitiveBeCursor(void);
static sqInt primitiveBeDisplay(void);
static sqInt primitiveBeep(void);
static sqInt primitiveBitAnd(void);
static sqInt primitiveBitOr(void);
static sqInt primitiveBitShift(void);
static sqInt primitiveBitXor(void);
static sqInt primitiveBlockCopy(void);
EXPORT(sqInt) primitiveByteArrayDoubleAt(void);
EXPORT(sqInt) primitiveByteArrayDoubleAtPut(void);
EXPORT(sqInt) primitiveByteArrayFloatAt(void);
EXPORT(sqInt) primitiveByteArrayFloatAtPut(void);
EXPORT(sqInt) primitiveByteArrayNByteIIntegerAtPut(void);
EXPORT(sqInt) primitiveByteArrayNByteIntegerAt(void);
static sqInt primitiveBytesLeft(void);
static sqInt primitiveCalloutToFFI(void);
static sqInt primitiveChangeClass(void);
static sqInt primitiveClass(void);
static sqInt primitiveClearVMProfile(void);
static sqInt primitiveClipboardText(void);
static sqInt primitiveClone(void);
static sqInt primitiveClosureCopyWithCopiedValues(void);
static sqInt primitiveClosureValue(void);
static sqInt primitiveClosureValueNoContextSwitch(void);
static sqInt primitiveClosureValueWithArgs(void);
static sqInt primitiveConstantFill(void);
static sqInt primitiveControlVMProfiling(void);
static sqInt primitiveCopyObject(void);
static sqInt primitiveDeferDisplayUpdates(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static sqInt primitiveDiv(void);
static sqInt primitiveDivide(void);
static sqInt primitiveDoPrimitiveWithArgs(void);
static sqInt primitiveEqual(void);
static sqInt primitiveEquivalent(void);
sqInt primitiveErrorTable(void);
EXPORT(sqInt) primitiveEventProcessingControl(void);
static sqInt primitiveExecuteMethod(void);
static sqInt primitiveExecuteMethodArgsArray(void);
static sqInt primitiveExitToDebugger(void);
static sqInt primitiveExp(void);
static sqInt primitiveExponent(void);
static sqInt primitiveExternalCall(void);
sqInt primitiveFail(void);
sqInt primitiveFailFor(sqInt reasonCode);
sqInt primitiveFailureCode(void);
static sqInt primitiveFindHandlerContext(void);
static sqInt primitiveFindNextUnwindContext(void);
static sqInt primitiveFloatAdd(void);
static sqInt primitiveFloatDivide(void);
static sqInt primitiveFloatDividebyArg(sqInt rcvrOop, sqInt argOop);
static sqInt primitiveFloatEqual(void);
static sqInt primitiveFloatGreaterOrEqual(void);
static sqInt primitiveFloatGreaterThan(void);
static sqInt primitiveFloatLessOrEqual(void);
static sqInt primitiveFloatLessThan(void);
static sqInt primitiveFloatMultiply(void);
static sqInt primitiveFloatNotEqual(void);
static sqInt primitiveFloatSubtract(void);
static sqInt primitiveFlushCache(void);
static sqInt primitiveFlushCacheByMethod(void);
static sqInt primitiveFlushCacheBySelector(void);
static sqInt primitiveFlushExternalPrimitives(void);
static sqInt primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static sqInt primitiveFormPrint(void);
static sqInt primitiveFractionalPart(void);
static sqInt primitiveFullGC(void);
static sqInt primitiveGetAttribute(void);
static sqInt primitiveGetImmutability(void);
static sqInt primitiveGetNextEvent(void);
static sqInt primitiveGreaterOrEqual(void);
static sqInt primitiveGreaterThan(void);
static sqInt primitiveHeaderWords(void);
static sqInt primitiveImageName(void);
static sqInt primitiveIncrementalGC(void);
static sqInt primitiveIndexOfMethodHeader(sqInt methodHeader);
sqInt primitiveIndexOf(sqInt methodPointer);
static sqInt primitiveInputSemaphore(void);
static sqInt primitiveInputWord(void);
static sqInt primitiveInstVarAt(void);
static sqInt primitiveInstVarAtPut(void);
static sqInt primitiveIntegerAt(void);
static sqInt primitiveIntegerAtPut(void);
static sqInt primitiveInterruptSemaphore(void);
static sqInt primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsYoung(void);
static sqInt primitiveKbdNext(void);
static sqInt primitiveKbdPeek(void);
static sqInt primitiveLessOrEqual(void);
static sqInt primitiveLessThan(void);
static sqInt primitiveListBuiltinModule(void);
static sqInt primitiveListExternalModule(void);
static sqInt primitiveLoadImageSegment(void);
static sqInt primitiveLogN(void);
static sqInt primitiveLowSpaceSemaphore(void);
static sqInt primitiveMakePoint(void);
static sqInt primitiveMarkHandlerMethod(void);
static sqInt primitiveMarkUnwindMethod(void);
sqInt primitiveMethod(void);
static sqInt primitiveMillisecondClock(void);
static sqInt primitiveMod(void);
static sqInt primitiveMouseButtons(void);
static sqInt primitiveMousePoint(void);
static sqInt primitiveMultiply(void);
static sqInt primitiveNew(void);
static sqInt primitiveNewMethod(void);
static sqInt primitiveNewWithArg(void);
static sqInt primitiveNext(void);
static sqInt primitiveNextInstance(void);
static sqInt primitiveNextObject(void);
static sqInt primitiveNextPut(void);
static sqInt primitiveNoop(void);
static sqInt primitiveNotEqual(void);
static sqInt primitiveObjectAt(void);
static sqInt primitiveObjectAtPut(void);
static sqInt primitiveObjectPointsTo(void);
static sqInt primitivePerform(void);
static sqInt primitivePerformAt(sqInt lookupClass);
static sqInt primitivePerformInSuperclass(void);
static sqInt primitivePerformWithArgs(void);
static sqInt primitiveQuit(void);
static sqInt primitiveQuo(void);
static sqInt primitiveRelinquishProcessor(void);
static sqInt primitiveResume(void);
EXPORT(sqInt) primitiveRootTable(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static sqInt primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
static sqInt primitiveScreenSize(void);
static sqInt primitiveSecondsClock(void);
static sqInt primitiveSetDisplayMode(void);
static sqInt primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
EXPORT(sqInt) primitiveSetGCSemaphore(void);
static sqInt primitiveSetImmutability(void);
static sqInt primitiveSetInterruptKey(void);
static sqInt primitiveShortAt(void);
static sqInt primitiveShortAtPut(void);
static sqInt primitiveShowDisplayRect(void);
static sqInt primitiveSignal(void);
static sqInt primitiveSignalAtBytesLeft(void);
static sqInt primitiveSignalAtMilliseconds(void);
static sqInt primitiveSine(void);
static sqInt primitiveSize(void);
static sqInt primitiveSnapshot(void);
static sqInt primitiveSnapshotEmbedded(void);
static sqInt primitiveSomeInstance(void);
static sqInt primitiveSomeObject(void);
static sqInt primitiveSpecialObjectsOop(void);
static sqInt primitiveSquareRoot(void);
static sqInt primitiveStoreImageSegment(void);
static sqInt primitiveStoreStackp(void);
static sqInt primitiveStringAt(void);
static sqInt primitiveStringAtPut(void);
static sqInt primitiveStringReplace(void);
static sqInt primitiveSubtract(void);
static sqInt primitiveSuspend(void);
static sqInt primitiveTerminateTo(void);
static sqInt primitiveTestDisplayDepth(void);
static sqInt primitiveTimesTwoPower(void);
static sqInt primitiveTruncated(void);
static sqInt primitiveUnloadModule(void);
static sqInt primitiveValue(void);
static sqInt primitiveValueWithArgs(void);
static sqInt primitiveVMParameter(void);
static sqInt primitiveVMPath(void);
static sqInt primitiveVMProfileSamplesInto(void);
static sqInt primitiveWait(void);
static sqInt primitiveYield(void);
static sqInt printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
sqInt printAllStacks(void);
void printCallStack(void);
static sqInt printCallStackOf(sqInt aContextOrProcess);
sqInt printChar(sqInt aByte);
static sqInt printContextCallStackOf(sqInt aContext);
sqInt printContext(sqInt aContext);
sqInt printContextWithSP(sqInt aContext, sqInt theSP);
sqInt printHex(sqInt n);
void printInstancesOf(sqInt aClassOop);
void printMethodReferencesTo(sqInt anOop);
static sqInt printNameOfClasscount(sqInt classOop, sqInt cnt);
static sqInt printNum(sqInt n);
sqInt printOop(sqInt oop);
sqInt printProcessStack(sqInt aProcess);
sqInt printProcsOnList(sqInt procList);
void printReferencesTo(sqInt anOop);
static sqInt printStringOf(sqInt oop);
sqInt print(char *s);
sqInt pushBool(sqInt trueOrFalse);
sqInt pushFloat(double  f);
sqInt pushInteger(sqInt integerValue);
void pushRemappableOop(sqInt oop);
sqInt push(sqInt object);
static sqInt putLongtoFile(sqInt aWord, sqImageFile  aFile);
sqInt readableFormat(sqInt imageVersion);
sqInt readImageFromFileHeapSizeStartingAt(sqImageFile  f, usqInt desiredHeapSize, squeakFileOffsetType  imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
sqInt remap(sqInt oop);
static sqInt removeFirstLinkOfList(sqInt aList);
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
static void restoreHeadersAfterBecomingwith(sqInt list1, sqInt list2);
static void restoreHeadersAfterForwardBecome(sqInt copyHashFlag);
static void restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static sqInt resume(sqInt aProcess);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static sqInt rewriteMethodCacheSelclassprimIndex(sqInt selector, sqInt class, sqInt localPrimIndex);
static sqInt rewriteMethodCacheSelclassprimIndexprimFunction(sqInt selector, sqInt class, sqInt localPrimIndex, void *localPrimAddress);
static sqInt safePrintStringOf(sqInt oop);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
sqInt setBreakSelector(char *aString);
sqInt setFullScreenFlag(sqInt value);
sqInt setInterruptCheckCounter(sqInt value);
sqInt setInterruptKeycode(sqInt value);
sqInt setInterruptPending(sqInt value);
sqInt setNextWakeupTick(sqInt value);
sqInt setSavedWindowSize(sqInt value);
sqInt shortPrintContext(sqInt aContext);
static sqInt shortPrintOop(sqInt oop);
sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
sqInt signalNoResume(sqInt aSemaphore);
sqInt signed32BitIntegerFor(int integerValue);
int signed32BitValueOf(sqInt oop);
sqInt signed64BitIntegerFor(sqLong integerValue);
sqLong signed64BitValueOf(sqInt oop);
long signedMachineIntegerValueOf(sqInt oop);
static sqInt sizeBitsOf(sqInt oop);
usqInt sizeOfAlienData(sqInt oop);
sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
sqInt slotSizeOf(sqInt oop);
static sqInt slowPrimitiveResponse(void);
static sqInt snapshot(sqInt embedded);
static sqInt space(void);
sqInt splObj(sqInt index);
double stackFloatValue(sqInt offset);
sqInt stackIntegerValue(sqInt offset);
sqInt stackObjectValue(sqInt offset);
sqInt stackPointerIndexForcontext(sqInt sp, sqInt ctxt);
sqInt stackPositiveMachineIntegerValue(sqInt offset);
sqInt stackSignedMachineIntegerValue(sqInt offset);
sqInt stackValue(sqInt offset);
void * startOfAlienData(sqInt oop);
sqInt stObjectat(sqInt array, sqInt index);
sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
static sqInt storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
sqInt stSizeOf(sqInt oop);
sqInt success(sqInt successBoolean);
static sqInt sufficientSpaceAfterGC(sqInt minFree);
static sqInt sufficientSpaceToAllocate(sqInt bytes);
sqInt superclassOf(sqInt classPointer);
static sqInt sweepPhase(void);
static sqInt synchronousSignal(sqInt aSemaphore);
void tenuringIncrementalGC(void);
sqInt topRemappableOop(void);
sqInt trueObject(void);
static void updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static void updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
sqInt validInstructionPointerinMethod(sqInt anInstrPointer, sqInt aMethod);
static void verifyCleanHeaders(void);
sqInt vmEndianness(void);
static sqInt wakeHighestPriority(void);
static sqInt wordSwapped(sqInt w);
static sqInt writeImageFileIO(sqInt imageBytes);
static sqInt writeImageFile(sqInt imageBytes);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss sqInt stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss sqInt argumentCount;
_iss usqInt youngStart;
_iss sqInt activeContext;
_iss sqInt method;
_iss sqInt nilObj;
_iss sqInt messageSelector;
_iss sqInt rootTableCount;
_iss usqInt freeBlock;
_iss sqInt receiver;
_iss sqInt instructionPointer;
_iss sqInt remapBufferCount;
_iss usqInt endOfMemory;
_iss sqInt newMethod;
_iss sqInt theHomeContext;
_iss sqInt falseObj;
_iss sqInt trueObj;
_iss sqInt lkupClass;
_iss sqInt interruptCheckCounter;
_iss sqInt allocationCount;
_iss sqInt reclaimableContextCount;
_iss usqInt memoryLimit;
_iss sqInt nextPollTick;
_iss sqInt allocationsBetweenGCs;
_iss usqInt fwdTableNext;
_iss unsigned char sendTraceLogIndex;
_iss sqInt freeContexts;
_iss sqInt lastHash;
_iss unsigned char primTraceLogIndex;
_iss sqInt lowSpaceThreshold;
_iss usqInt compStart;
_iss sqInt extraRootCount;
_iss sqInt weakRootCount;
_iss sqInt nextWakeupTick;
_iss sqInt growHeadroom;
_iss sqInt statGrowMemory;
_iss sqInt interruptCheckCounterFeedBackReset;
_iss sqInt signalLowSpace;
_iss usqInt compEnd;
_iss sqInt freeLargeContexts;
_iss sqInt lastTick;
_iss sqInt pendingFinalizationSignals;
_iss sqInt statMarkCount;
_iss sqInt statShrinkMemory;
_iss usqInt fwdTableLast;
_iss sqInt shrinkThreshold;
_iss sqInt statCompMoveCount;
_iss sqInt statMkFwdCount;
_iss sqInt statSweepCount;
_iss sqInt classNameIndex;
_iss sqInt forceTenureFlag;
_iss usqLong gcStartUsecs;
_iss sqInt interruptChecksEveryNms;
_iss sqInt interruptPending;
_iss sqInt metaclassSizeBytes;
_iss usqLong statFullGCUsecs;
_iss sqInt statFullGCs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statIncrGCs;
_iss sqInt statRootTableOverflows;
_iss sqInt statTenures;
_iss sqInt tenuringThreshold;
_iss sqInt totalObjectCount;
_iss sqInt fullScreenFlag;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt globalSessionID;
_iss sqInt interruptKeycode;
_iss sqInt statGCEndTime;
_iss usqLong statIGCDeltaUsecs;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt thisClassIndex;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt gcSemaphoreIndex;
_iss sqInt savedWindowSize;
_iss sqInt statAllocationCount;
_iss sqInt statRootTableCount;
_iss sqInt statSpecialMarkCount;
_iss sqInt statSurvivorCount;
_iss long methodCache[4097];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt atCache[65];
_iss sqInt sendTraceLog[256];
_iss sqInt primTraceLog[256];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss void *externalPrimitiveTable[1025];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss unsigned long byteCount;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
static struct foo * foo = &fum;
#endif
static usqInt memory;
static void (*primitiveFunctionPointer)();
static sqInt imageFormatVersionNumber = 6502;
sqInt inIOProcessEvents;
sqInt deferDisplayUpdates;
sqInt extraVMMemory;
void* showSurfaceFn;
struct VirtualMachine* interpreterProxy;
static const sqInt headerTypeBytes[] = {
8, 4, 0, 0};
static void *primitiveTable[577] = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ (void (*)(void))0,
	/* 21 */ (void (*)(void))0,
	/* 22 */ (void (*)(void))0,
	/* 23 */ (void (*)(void))0,
	/* 24 */ (void (*)(void))0,
	/* 25 */ (void (*)(void))0,
	/* 26 */ (void (*)(void))0,
	/* 27 */ (void (*)(void))0,
	/* 28 */ (void (*)(void))0,
	/* 29 */ (void (*)(void))0,
	/* 30 */ (void (*)(void))0,
	/* 31 */ (void (*)(void))0,
	/* 32 */ (void (*)(void))0,
	/* 33 */ (void (*)(void))0,
	/* 34 */ (void (*)(void))0,
	/* 35 */ (void (*)(void))0,
	/* 36 */ (void (*)(void))0,
	/* 37 */ (void (*)(void))0,
	/* 38 */ primitiveAt,
	/* 39 */ primitiveAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ primitiveNext,
	/* 66 */ primitiveNextPut,
	/* 67 */ primitiveAtEnd,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveAsOop,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ primitiveBlockCopy,
	/* 81 */ primitiveValue,
	/* 82 */ primitiveValueWithArgs,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveEquivalent,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ (void (*)(void))0,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveArrayBecomeOneWayForceImmutables,
	/* 162 */ primitiveArrayBecomeForceImmutables,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ (void (*)(void))0,
	/* 170 */ (void (*)(void))0,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ (void (*)(void))0,
	/* 174 */ (void (*)(void))0,
	/* 175 */ (void (*)(void))0,
	/* 176 */ (void (*)(void))0,
	/* 177 */ (void (*)(void))0,
	/* 178 */ (void (*)(void))0,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ (void (*)(void))0,
	/* 185 */ (void (*)(void))0,
	/* 186 */ (void (*)(void))0,
	/* 187 */ (void (*)(void))0,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ primitiveMarkUnwindMethod,
	/* 199 */ primitiveMarkHandlerMethod,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveAt,
	/* 211 */ primitiveAtPut,
	/* 212 */ primitiveSize,
	/* 213 */ (void (*)(void))0,
	/* 214 */ (void (*)(void))0,
	/* 215 */ (void (*)(void))0,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ (void (*)(void))0,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ primitiveHeaderWords,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ (void (*)(void))0,
	/* 241 */ (void (*)(void))0,
	/* 242 */ (void (*)(void))0,
	/* 243 */ (void (*)(void))0,
	/* 244 */ (void (*)(void))0,
	/* 245 */ (void (*)(void))0,
	/* 246 */ (void (*)(void))0,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ primitiveInvokeObjectAsMethod,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
char * breakSelector;
sqInt breakSelectorLength = -1;
const char *interpreterVersion = "Newspeak Virtual Machine NewspeakInterpreter_VMMaker.oscog-eem.99";
volatile int sendTrace;


/*** Macros ***/
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define memory() memory
#define primTraceLogIndex(aValue) (GIV(primTraceLogIndex) = (aValue))
#define printFloat(f) printf("%g", f)
#define remapBufferCount() GIV(remapBufferCount)
#define sendTraceLogIndex(aValue) (GIV(sendTraceLogIndex) = (aValue))
#define validate() 0



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must
	return control to the browser periodically. This should done only when the
	state of
	the currently running Squeak thread is safely stored in the object heap.
	Since this
	is the case at the moment that a check for interrupts is performed, that
	is when we
	return to the browser if it is time to do so. Interrupt checks happen
	quite frequently. */
/*	should *not* be inlined into sendInvokeCallback:Stack:Registers:Jmpbuf: */
/*	record entry time when running as a browser plug-in */

sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt localHomeContext;
    char* localIP;
    sqInt localReturnContext;
    sqInt localReturnValue;
    char* localSP;

	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localHomeContext = GIV(theHomeContext);
	/* begin fetchNextBytecode */
	currentBytecode = byteAtPointer(++localIP);
	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(0bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(0pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((0 & 15) << ShiftForWord)));
			}
;
			break;
		case 1:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(1pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((1 & 15) << ShiftForWord)));
			}
;
			break;
		case 2:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(2pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((2 & 15) << ShiftForWord)));
			}
;
			break;
		case 3:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(3pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((3 & 15) << ShiftForWord)));
			}
;
			break;
		case 4:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(4pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((4 & 15) << ShiftForWord)));
			}
;
			break;
		case 5:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(5pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((5 & 15) << ShiftForWord)));
			}
;
			break;
		case 6:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(6pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((6 & 15) << ShiftForWord)));
			}
;
			break;
		case 7:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(7pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((7 & 15) << ShiftForWord)));
			}
;
			break;
		case 8:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(8pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((8 & 15) << ShiftForWord)));
			}
;
			break;
		case 9:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(9pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((9 & 15) << ShiftForWord)));
			}
;
			break;
		case 10:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(10pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((10 & 15) << ShiftForWord)));
			}
;
			break;
		case 11:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(11pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((11 & 15) << ShiftForWord)));
			}
;
			break;
		case 12:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(12pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((12 & 15) << ShiftForWord)));
			}
;
			break;
		case 13:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(13pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((13 & 15) << ShiftForWord)));
			}
;
			break;
		case 14:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(14pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((14 & 15) << ShiftForWord)));
			}
;
			break;
		case 15:
			/* pushReceiverVariableBytecode */
			{

				VM_LABEL(15pushReceiverVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + ((15 & 15) << ShiftForWord)));
			}
;
			break;
		case 16:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(0pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((16 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 17:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(1pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((17 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 18:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(2pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((18 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 19:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(3pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((19 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 20:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(4pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((20 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 21:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(5pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((21 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 22:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(6pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((22 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 23:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(7pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((23 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 24:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(8pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((24 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 25:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(9pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((25 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 26:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(10pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((26 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 27:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(11pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((27 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(12pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((28 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(13pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((29 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(14pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((30 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{

				VM_LABEL(15pushTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + (((31 & 15) + TempFrameStart) << ShiftForWord)));
			}
;
			break;
		case 32:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(0pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((32 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 33:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(1pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((33 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 34:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(2pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((34 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 35:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(3pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((35 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 36:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(4pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((36 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 37:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(5pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((37 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 38:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(6pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((38 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 39:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(7pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((39 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 40:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(8pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((40 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 41:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(9pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((41 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 42:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(10pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((42 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 43:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(11pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((43 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 44:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(12pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((44 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 45:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(13pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((45 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 46:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(14pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((46 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 47:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(15pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((47 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 48:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(16pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((48 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 49:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(17pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((49 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 50:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(18pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((50 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 51:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(19pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((51 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 52:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(20pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((52 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 53:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(21pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((53 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 54:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(22pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((54 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 55:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(23pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((55 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 56:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(24pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((56 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 57:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(25pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((57 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 58:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(26pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((58 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 59:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(27pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((59 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 60:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(28pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((60 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 61:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(29pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((61 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 62:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(30pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((62 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 63:
			/* pushLiteralConstantBytecode */
			{

				VM_LABEL(31pushLiteralConstantBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + (((63 & 31) + LiteralStart) << ShiftForWord)));
			}
;
			break;
		case 64:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(0pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((64 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 65:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(1pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((65 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 66:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(2pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((66 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 67:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(3pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((67 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 68:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(4pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((68 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 69:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(5pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((69 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 70:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(6pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((70 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 71:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(7pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((71 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 72:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(8pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((72 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 73:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(9pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((73 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 74:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(10pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((74 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 75:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(11pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((75 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 76:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(12pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((76 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 77:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(13pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((77 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 78:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(14pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((78 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 79:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(15pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((79 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(16pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((80 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(17pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((81 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(18pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((82 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(19pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((83 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(20pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((84 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(21pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((85 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(22pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((86 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(23pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((87 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(24pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((88 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(25pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((89 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(26pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((90 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(27pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((91 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(28pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((92 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(29pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((93 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(30pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((94 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{

				VM_LABEL(31pushLiteralVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushLiteralVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + (((95 & 31) + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
			}
;
			break;
		case 96:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(0storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 96 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((96 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 97:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(1storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 97 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((97 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 98:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(2storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 98 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((98 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 99:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(3storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 99 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((99 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 100:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(4storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 100 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((100 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 101:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(5storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 101 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((101 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 102:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(6storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 102 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((102 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;
				sqInt targetObj;
				sqInt index;

				VM_LABEL(7storeAndPopReceiverVariableBytecode);
				
				/* this bytecode will be expanded so that refs to currentBytecode below will be constant */

				rcvr = GIV(receiver);
				top = longAtPointer(localSP);
				if (((longAt(rcvr)) & ImmutabilityBit) != 0) {
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					/* begin internalCannotAssign:to:withIndex: */
					targetObj = GIV(receiver);
					index = 103 & 7;
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), targetObj);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), top);
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), (((index + 1) << 1) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
					GIV(argumentCount) = 2;
					goto normalSend;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (rcvr < GIV(youngStart)) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((103 & 7) << ShiftForWord), top);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 104:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(0storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((104 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 105:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(1storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((105 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 106:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(2storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((106 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 107:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(3storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((107 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 108:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(4storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((108 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 109:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(5storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((109 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 110:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(6storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((110 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 111:
			/* storeAndPopTemporaryVariableBytecode */
			{

				VM_LABEL(7storeAndPopTemporaryVariableBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtput((localHomeContext + BaseHeaderSize) + (((111 & 7) + TempFrameStart) << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 112:
			/* pushReceiverBytecode */
			{

				VM_LABEL(0pushReceiverBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(receiver));
			}
;
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{

				VM_LABEL(0pushConstantTrueBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(trueObj));
			}
;
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{

				VM_LABEL(0pushConstantFalseBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(falseObj));
			}
;
			break;
		case 115:
			/* pushConstantNilBytecode */
			{

				VM_LABEL(0pushConstantNilBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(nilObj));
			}
;
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{

				VM_LABEL(0pushConstantMinusOneBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), ConstMinusOne);
			}
;
			break;
		case 117:
			/* pushConstantZeroBytecode */
			{

				VM_LABEL(0pushConstantZeroBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), ConstZero);
			}
;
			break;
		case 118:
			/* pushConstantOneBytecode */
			{

				VM_LABEL(0pushConstantOneBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), ConstOne);
			}
;
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{

				VM_LABEL(0pushConstantTwoBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), ConstTwo);
			}
;
			break;
		case 120:
			/* returnReceiver */
			{
				sqInt closureOrNil;
				sqInt context;

				VM_LABEL(0returnReceiver);
								/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + BaseHeaderSize) + (ClosureIndex << ShiftForWord)))) != GIV(nilObj)) {
					context = longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
				}
				localReturnContext = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				localReturnValue = GIV(receiver);
				/* goto commonReturn */
			}
;
			
		commonReturn:
			/* commonReturn */
			{
				sqInt contextOfCaller;
				sqInt localCntx;
				sqInt localVal;
				sqInt nilOop;
				sqInt thisCntx;
				sqInt unwindMarked;
				sqInt header;
				sqInt meth;
				sqInt pIndex;
				sqInt header1;
				sqInt primBits;
				sqInt tmp;

				VM_LABEL(0commonReturn);
				
				/* keep in a register */

				nilOop = GIV(nilObj);
				thisCntx = GIV(activeContext);
				localCntx = localReturnContext;

				/* make sure we can return to the given context */

				localVal = localReturnValue;
				if ((localCntx == nilOop)
				 || ((longAt((localCntx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) == nilOop)) {
					/* begin internalCannotReturn: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), GIV(activeContext));
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), localVal);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l90;
				}

				/* Just possibly a faster test would be to compare the homeContext and activeContext - they are of course different for blocks. Thus we might be able to optimise a touch by having a different returnTo for the blockreteurn (since we know that must return to caller) and then if active ~= home we must be doing a non-local return. I think. Maybe. */

				thisCntx = longAt((GIV(activeContext) + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				while (!(thisCntx == localCntx)) {
					if (thisCntx == nilOop) {
						/* begin internalCannotReturn: */
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), GIV(activeContext));
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), localVal);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << ShiftForWord));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l90;
					}
					/* begin isUnwindMarked: */
					header = longAt(thisCntx);
					if (!(((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
						unwindMarked = 0;
						goto l91;
					}
					meth = longAt((thisCntx + BaseHeaderSize) + (MethodIndex << ShiftForWord));
					/* begin primitiveIndexOf: */
					primBits = (((usqInt) (longAt((meth + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
					pIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
					unwindMarked = pIndex == 198;
				l91:	/* end isUnwindMarked: */;
					if (unwindMarked) {
						/* begin internalAboutToReturn:through: */
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), GIV(activeContext));
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), localVal);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), thisCntx);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAboutToReturn << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l90;
					}
					thisCntx = longAt((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				}
				thisCntx = GIV(activeContext);
				while (!(thisCntx == localCntx)) {

					/* climb up stack to localCntx */
					/* zap exited contexts so any future attempted use will be caught */

					contextOfCaller = longAt((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
					longAtput((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord), nilOop);
					longAtput((thisCntx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), nilOop);
					if (GIV(reclaimableContextCount) > 0) {

						/* try to recycle this context */

						GIV(reclaimableContextCount) -= 1;
						/* begin recycleContextIfPossible: */
						VM_LABEL(0recycleContextIfPossible);
						if ((((usqInt) thisCntx)) >= (((usqInt) GIV(youngStart)))) {

							/* only recycle young contexts (which should be most of them) */

							header1 = longAt(thisCntx);
							if (((((usqInt) header1) >> 12) & 31) == ClassMethodContextCompactIndex) {
								if ((header1 & SizeMask) == SmallContextSize) {
									longAtput((thisCntx + BaseHeaderSize) + (0 << ShiftForWord), GIV(freeContexts));
									GIV(freeContexts) = thisCntx;
								}
								if ((header1 & SizeMask) == LargeContextSize) {
									longAtput((thisCntx + BaseHeaderSize) + (0 << ShiftForWord), GIV(freeLargeContexts));
									GIV(freeLargeContexts) = thisCntx;
								}
							}
						}
					}
					thisCntx = contextOfCaller;
				}
				GIV(activeContext) = thisCntx;
				if (thisCntx < GIV(youngStart)) {
					beRootIfOld(thisCntx);
				}
				/* begin internalFetchContextRegisters: */
				VM_LABEL(0internalFetchContextRegisters);
				tmp = longAt((thisCntx + BaseHeaderSize) + (MethodIndex << ShiftForWord));
				if ((tmp & 1)) {

					/* if the MethodIndex field is an integer, activeCntx is a block context */

					tmp = longAt((thisCntx + BaseHeaderSize) + (HomeIndex << ShiftForWord));
					if (tmp < GIV(youngStart)) {
						beRootIfOld(tmp);
					}
				}
				else {
					tmp = thisCntx;
				}
				localHomeContext = tmp;
				GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

				/* the instruction pointer is a pointer variable equal to
		method oop + ip + BaseHeaderSize
		  -1 for 0-based addressing of fetchByte
		  -1 because it gets incremented BEFORE fetching currentByte */

				GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
				tmp = ((longAt((thisCntx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

				/* the stack pointer is a pointer variable also... */

				localIP = pointerForOop(((GIV(method) + tmp) + BaseHeaderSize) - 2);
				tmp = ((longAt((thisCntx + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
				localSP = pointerForOop((thisCntx + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord));
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), localVal);
			}
;
		l90:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				sqInt closureOrNil;
				sqInt context;

				VM_LABEL(0returnTrue);
								/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + BaseHeaderSize) + (ClosureIndex << ShiftForWord)))) != GIV(nilObj)) {
					context = longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
				}
				localReturnContext = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
;
			break;
		case 122:
			/* returnFalse */
			{
				sqInt closureOrNil;
				sqInt context;

				VM_LABEL(0returnFalse);
								/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + BaseHeaderSize) + (ClosureIndex << ShiftForWord)))) != GIV(nilObj)) {
					context = longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
				}
				localReturnContext = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
;
			break;
		case 123:
			/* returnNil */
			{
				sqInt closureOrNil;
				sqInt context;

				VM_LABEL(0returnNil);
								/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + BaseHeaderSize) + (ClosureIndex << ShiftForWord)))) != GIV(nilObj)) {
					context = longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
				}
				localReturnContext = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
;
			break;
		case 124:
			/* returnTopFromMethod */
			{
				sqInt closureOrNil;
				sqInt context;

				VM_LABEL(0returnTopFromMethod);
								/* begin sender */
				context = localHomeContext;
				while (((closureOrNil = longAt((context + BaseHeaderSize) + (ClosureIndex << ShiftForWord)))) != GIV(nilObj)) {
					context = longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
				}
				localReturnContext = longAt((context + BaseHeaderSize) + (SenderIndex << ShiftForWord));
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
;
			break;
		case 125:
			/* returnTopFromBlock */
			{

				VM_LABEL(0returnTopFromBlock);
				
				/* Note: caller, not sender! */

				localReturnContext = longAt((GIV(activeContext) + BaseHeaderSize) + (CallerIndex << ShiftForWord));
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
;
			break;
		case 126:
			/* dynamicSuperSendBytecode */
			{
				sqInt mClassMixin;
				sqInt mixinApplication;
				sqInt rcvr;
				sqInt literal;

				VM_LABEL(0dynamicSuperSendBytecode);
								GIV(argumentCount) = byteAtPointer(++localIP);
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((byteAtPointer(++localIP)) + LiteralStart) << ShiftForWord));
				rcvr = longAtPointer(localSP - (GIV(argumentCount) * BytesPerWord));
				/* begin methodClassOf: */
				literal = longAt((GIV(method) + BaseHeaderSize) + (((((((usqInt) (longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) - 1) + LiteralStart) << ShiftForWord));
				mClassMixin = (literal == GIV(nilObj)
					? (literal)
					: (longAt((literal + BaseHeaderSize) + (ValueIndex << ShiftForWord))));
				mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(mClassMixin, fetchClassOf(rcvr));
				GIV(lkupClass) = longAt((mixinApplication + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
				goto commonSend;
			}
;
			break;
		case 127:
			/* pushImplicitReceiverBytecode */
			{
				sqInt litIndex;
				sqInt object;
				sqInt mixin;
				sqInt selector;
				sqInt dictionary;
				sqInt found;
				sqInt implicitReceiverOrNil;
				sqInt mixinApplication;
				sqInt theMixin;
				sqInt dictionary1;
				sqInt found1;
				sqInt implicitReceiver;
				sqInt mixinApplication1;
				sqInt targetMixin;
				sqInt theMixin1;
				sqInt aClass;
				sqInt mixinOrMixinApplication;
				sqInt ccIndex;
				sqInt index;
				sqInt length;
				sqInt mask;
				sqInt methodArray;
				sqInt nextSelector;
				sqInt wrapAround;
				sqInt sz;
				sqInt header;
				sqInt literal;
				sqInt index1;
				sqInt length1;
				sqInt mask1;
				sqInt methodArray1;
				sqInt nextSelector1;
				sqInt wrapAround1;
				sqInt sz1;
				sqInt header1;

				VM_LABEL(0pushImplicitReceiverBytecode);
								litIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				/* begin implicitReceiverForMixin:implementing: */
				VM_LABEL(0implicitReceiverForMixinimplementing);
				/* begin methodClassOf: */
				literal = longAt((GIV(method) + BaseHeaderSize) + (((((((usqInt) (longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) - 1) + LiteralStart) << ShiftForWord));
				mixin = (literal == GIV(nilObj)
					? (literal)
					: (longAt((literal + BaseHeaderSize) + (ValueIndex << ShiftForWord))));
				selector = longAt((GIV(method) + BaseHeaderSize) + ((litIndex + LiteralStart) << ShiftForWord));

				/* messageSelector is an implicit parameter of lookupMethodInDictionary: */

				GIV(messageSelector) = selector;
				mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(mixin, fetchClassOf(GIV(receiver)));
				if (mixinApplication == GIV(nilObj)) {
					object = GIV(receiver);
					goto l2;
				}
				dictionary = longAt((mixinApplication + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
				/* begin lookupMethodInDictionary: */
				VM_LABEL(0lookupMethodInDictionary);
				/* begin fetchWordLengthOf: */
				/* begin sizeBitsOf: */
				header1 = longAt(dictionary);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(dictionary - (BytesPerWord * 2))) & LongSizeMask;
					goto l6;
				}
				else {
					sz1 = header1 & SizeMask;
					goto l6;
				}
			l6:	/* end sizeBitsOf: */;
				length1 = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
				mask1 = (length1 - SelectorStart) - 1;
				if ((GIV(messageSelector) & 1)) {
					index1 = (mask1 & ((GIV(messageSelector) >> 1))) + SelectorStart;
				}
				else {
					index1 = (mask1 & ((((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted)) + SelectorStart;
				}
				wrapAround1 = 0;
				while (1) {
					nextSelector1 = longAt((dictionary + BaseHeaderSize) + (index1 << ShiftForWord));
					if (nextSelector1 == GIV(nilObj)) {
						found = 0;
						goto l7;
					}
					if (nextSelector1 == GIV(messageSelector)) {
						methodArray1 = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
						GIV(newMethod) = longAt((methodArray1 + BaseHeaderSize) + ((index1 - SelectorStart) << ShiftForWord));
						found = 1;
						goto l7;
					}
					index1 += 1;
					if (index1 == length1) {
						if (wrapAround1) {
							found = 0;
							goto l7;
						}
						wrapAround1 = 1;
						index1 = SelectorStart;
					}
				}
			l7:	/* end lookupMethodInDictionary: */;
				if (!(found)) {
					theMixin = longAt((mixinApplication + BaseHeaderSize) + (MixinIndex << ShiftForWord));
					/* begin nextImplicitReceiverFor:withMixin: */
					VM_LABEL(0nextImplicitReceiverForwithMixin);
					implicitReceiver = longAt((mixinApplication + BaseHeaderSize) + (EnclosingObjectIndex << ShiftForWord));
					targetMixin = longAt((theMixin + BaseHeaderSize) + (EnclosingMixinIndex << ShiftForWord));
									while (1) {
						if (targetMixin == GIV(nilObj)) {
							implicitReceiverOrNil = GIV(nilObj);
							goto l1;
						}
						/* begin findApplicationOfTargetMixin:startingAtNonMetaClass: */
						/* begin fetchClassOf: */
						if ((implicitReceiver & 1)) {
							aClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
							goto l3;
						}
						if (((ccIndex = (((usqInt) (longAt(implicitReceiver))) >> 12) & 31)) == 0) {
							aClass = (longAt(implicitReceiver - BaseHeaderSize)) & AllButTypeMask;
							goto l3;
						}
						else {
							aClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
							goto l3;
						}
					l3:	/* end fetchClassOf: */;
						mixinOrMixinApplication = aClass;
						while (!((mixinOrMixinApplication == GIV(nilObj))
						 || ((mixinOrMixinApplication == targetMixin)
						 || ((longAt((mixinOrMixinApplication + BaseHeaderSize) + (MixinIndex << ShiftForWord))) == targetMixin)))) {
							mixinOrMixinApplication = longAt((mixinOrMixinApplication + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
						}
						mixinApplication1 = mixinOrMixinApplication;
						if (mixinApplication1 == GIV(nilObj)) {
							implicitReceiverOrNil = GIV(nilObj);
							goto l1;
						}
						dictionary1 = longAt((mixinApplication1 + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
						/* begin lookupMethodInDictionary: */
						VM_LABEL(1lookupMethodInDictionary);
						/* begin fetchWordLengthOf: */
						/* begin sizeBitsOf: */
						header = longAt(dictionary1);
						if ((header & TypeMask) == HeaderTypeSizeAndClass) {
							sz = (longAt(dictionary1 - (BytesPerWord * 2))) & LongSizeMask;
							goto l4;
						}
						else {
							sz = header & SizeMask;
							goto l4;
						}
					l4:	/* end sizeBitsOf: */;
						length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
						mask = (length - SelectorStart) - 1;
						if ((GIV(messageSelector) & 1)) {
							index = (mask & ((GIV(messageSelector) >> 1))) + SelectorStart;
						}
						else {
							index = (mask & ((((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted)) + SelectorStart;
						}
						wrapAround = 0;
						while (1) {
							nextSelector = longAt((dictionary1 + BaseHeaderSize) + (index << ShiftForWord));
							if (nextSelector == GIV(nilObj)) {
								found1 = 0;
								goto l5;
							}
							if (nextSelector == GIV(messageSelector)) {
								methodArray = longAt((dictionary1 + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
								GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << ShiftForWord));
								found1 = 1;
								goto l5;
							}
							index += 1;
							if (index == length) {
								if (wrapAround) {
									found1 = 0;
									goto l5;
								}
								wrapAround = 1;
								index = SelectorStart;
							}
						}
					l5:	/* end lookupMethodInDictionary: */;
						if (found1) break;
						implicitReceiver = longAt((mixinApplication1 + BaseHeaderSize) + (EnclosingObjectIndex << ShiftForWord));
						theMixin1 = longAt((mixinApplication1 + BaseHeaderSize) + (MixinIndex << ShiftForWord));
						if (theMixin1 == GIV(nilObj)) {
							implicitReceiverOrNil = GIV(nilObj);
							goto l1;
						}
						targetMixin = longAt((theMixin1 + BaseHeaderSize) + (EnclosingMixinIndex << ShiftForWord));
					}
					implicitReceiverOrNil = implicitReceiver;
				l1:	/* end nextImplicitReceiverFor:withMixin: */;
					if (implicitReceiverOrNil != GIV(nilObj)) {
						object = implicitReceiverOrNil;
						goto l2;
					}
				}
				object = GIV(receiver);
			l2:	/* end implicitReceiverForMixin:implementing: */;
				longAtPointerput((localSP += BytesPerWord), object);
			}
;
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(0extendedPushBytecode);
								descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + (variableIndex << ShiftForWord)));
					goto l8;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt((localHomeContext + BaseHeaderSize) + ((variableIndex + TempFrameStart) << ShiftForWord)));
					goto l8;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord)));
					goto l8;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
					goto l8;
				}
			}
;
		l8:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt association;
				sqInt descriptor;
				sqInt isPop;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;
				sqInt targetObj;

				VM_LABEL(0extendedStoreBytecode);
				
				/* extendedStoreAndPopBytecode */

				isPop = currentBytecode == 130;
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 2) {
					error("illegal store");
					goto l9;
				}
				value = longAtPointer(localSP);
				if (variableType == 0) {
					if (((longAt(GIV(receiver))) & ImmutabilityBit) != 0) {
						if (isPop) {
							/* begin internalPop: */
							localSP -= 1 * BytesPerWord;
						}
						/* begin undoFetchNextBytecode */
						localIP -= 1;
						/* begin internalCannotAssign:to:withIndex: */
						targetObj = GIV(receiver);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), targetObj);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), value);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), (((variableIndex + 1) << 1) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l9;
					}
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) GIV(receiver))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(GIV(receiver), value);
					}
					longAtput((GIV(receiver) + BaseHeaderSize) + (variableIndex << ShiftForWord), value);
					goto l9;
				}
				if (variableType == 1) {
					longAtput((localHomeContext + BaseHeaderSize) + ((variableIndex + TempFrameStart) << ShiftForWord), value);
					goto l9;
				}
				if (variableType == 3) {
					association = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord));
					if (((longAt(association)) & ImmutabilityBit) != 0) {
						if (isPop) {
							/* begin internalPop: */
							localSP -= 1 * BytesPerWord;
						}
						/* begin undoFetchNextBytecode */
						localIP -= 1;
						/* begin internalCannotAssign:to:withIndex: */
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), association);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), value);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), (((ValueIndex + 1) << 1) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l9;
					}
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) association)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(association, value);
					}
					longAtput((association + BaseHeaderSize) + (ValueIndex << ShiftForWord), value);
					goto l9;
				}
			}
;
		l9:	/* end case */;
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt association;
				sqInt descriptor;
				sqInt isPop;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;
				sqInt targetObj;

				VM_LABEL(0extendedStoreAndPopBytecode);
								/* begin extendedStoreBytecode */
				VM_LABEL(1extendedStoreBytecode);

				/* extendedStoreAndPopBytecode */

				isPop = currentBytecode == 130;
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 63;
				if (variableType == 2) {
					error("illegal store");
					goto l10;
				}
				value = longAtPointer(localSP);
				if (variableType == 0) {
					if (((longAt(GIV(receiver))) & ImmutabilityBit) != 0) {
						if (isPop) {
							/* begin internalPop: */
							localSP -= 1 * BytesPerWord;
						}
						/* begin undoFetchNextBytecode */
						localIP -= 1;
						/* begin internalCannotAssign:to:withIndex: */
						targetObj = GIV(receiver);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), targetObj);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), value);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), (((variableIndex + 1) << 1) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l10;
					}
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) GIV(receiver))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(GIV(receiver), value);
					}
					longAtput((GIV(receiver) + BaseHeaderSize) + (variableIndex << ShiftForWord), value);
					goto l10;
				}
				if (variableType == 1) {
					longAtput((localHomeContext + BaseHeaderSize) + ((variableIndex + TempFrameStart) << ShiftForWord), value);
					goto l10;
				}
				if (variableType == 3) {
					association = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << ShiftForWord));
					if (((longAt(association)) & ImmutabilityBit) != 0) {
						if (isPop) {
							/* begin internalPop: */
							localSP -= 1 * BytesPerWord;
						}
						/* begin undoFetchNextBytecode */
						localIP -= 1;
						/* begin internalCannotAssign:to:withIndex: */
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), association);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), value);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), (((ValueIndex + 1) << 1) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l10;
					}
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) association)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(association, value);
					}
					longAtput((association + BaseHeaderSize) + (ValueIndex << ShiftForWord), value);
					goto l10;
				}
			l10:	/* end extendedStoreBytecode */;
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0singleExtendedSendBytecode);
								descriptor = byteAtPointer(++localIP);
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 31) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
;
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0normalSend);
								rcvr = longAtPointer(localSP - (GIV(argumentCount) * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l92;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l92;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l92;
				}
			l92:	/* end fetchClassOf: */;
				/* goto commonSend */
			}
;
			
		commonSend:
			/* commonSend */
			{
				sqInt ok;
				sqInt hash;
				sqInt probe;
				sqInt succeeded;
				sqInt deltaIfSuccess;
				sqInt nArgs;
				sqInt savedContext;
				sqInt localPrimIndex;
				sqInt argCount2;
				sqInt i;
				sqInt initialIP;
				sqInt methodHeader;
				sqInt needsLarge;
				sqInt newContext;
				sqInt tempCount;
				sqInt where;
				sqInt valuePointer;
				sqInt valuePointer1;
				sqInt tmp;

				VM_LABEL(0commonSend);
								/* begin fastLogSend: */
				if (RecordSendTrace) {
					GIV(sendTraceLog)[GIV(sendTraceLogIndex)] = GIV(messageSelector);
					sendTraceLogIndex(GIV(sendTraceLogIndex) + 1);
				}
				sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), longAtPointer(localSP - (GIV(argumentCount) * BytesPerWord)));
				/* begin internalFindNewMethod */
				VM_LABEL(0internalFindNewMethod);
				/* begin lookupInMethodCacheSel:class: */

				/* shift drops two low-order zeros from addresses */

				hash = GIV(messageSelector) ^ GIV(lkupClass);

				/* first probe */

				probe = hash & MethodCacheMask;
				if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe + MethodCacheClass]) == GIV(lkupClass))) {
					GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l93;
				}

				/* second probe */

				probe = (((usqInt) hash) >> 1) & MethodCacheMask;
				if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe + MethodCacheClass]) == GIV(lkupClass))) {
					GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l93;
				}
				probe = (((usqInt) hash) >> 2) & MethodCacheMask;
				if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe + MethodCacheClass]) == GIV(lkupClass))) {
					GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
					ok = 1;
					goto l93;
				}
				ok = 0;
			l93:	/* end lookupInMethodCacheSel:class: */;
				if (!(ok)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					lookupMethodInClass(GIV(lkupClass));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
					addNewMethodToCache();
				}
				/* begin internalExecuteNewMethod */
				VM_LABEL(0internalExecuteNewMethod);
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						VM_LABEL(0internalQuickPrimitiveResponse);
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 255)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << ShiftForWord)));
							goto l94;
						}
						if (localPrimIndex == 256) {
							goto l94;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l94;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l94;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l94;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
						goto l94;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					/* begin slowPrimitiveResponse */
					VM_LABEL(0slowPrimitiveResponse);
					if (FailImbalancedPrimitives) {
						savedContext = GIV(activeContext);
						nArgs = GIV(argumentCount);
						deltaIfSuccess = (GIV(stackPointer) - (GIV(argumentCount) * BytesPerOop)) - GIV(activeContext);
					}
					/* begin fastLogPrim: */
					if (RecordPrimTrace) {
						GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
						primTraceLogIndex(GIV(primTraceLogIndex) + 1);
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					if (FailImbalancedPrimitives
					 && ((!GIV(primFailCode))
					 && (savedContext == GIV(activeContext)))) {
						if ((GIV(stackPointer) - GIV(activeContext)) != deltaIfSuccess) {
							flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
							warning("failing primitive due to unbalanced stack");
							GIV(stackPointer) = (GIV(activeContext) + deltaIfSuccess) + (nArgs * BytesPerOop);
							failUnbalancedPrimitive();
						}
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l94;
					}
				}
				/* begin internalActivateNewMethod */
				VM_LABEL(0internalActivateNewMethod);
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
				needsLarge = methodHeader & LargeContextBit;
				if ((needsLarge == 0)
				 && (GIV(freeContexts) != NilContext)) {
					newContext = GIV(freeContexts);
					GIV(freeContexts) = longAt((newContext + BaseHeaderSize) + (0 << ShiftForWord));
				}
				else {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					newContext = allocateOrRecycleContext(needsLarge);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
				}
				initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

				/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

				tempCount = (((usqInt) methodHeader) >> 19) & 63;
				where = newContext + BaseHeaderSize;
				longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
				longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
				longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
				longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
				longAtput(where + (ClosureIndex << ShiftForWord), GIV(nilObj));
				argCount2 = GIV(argumentCount);
				for (i = 0; i <= argCount2; i += 1) {
					longAtput(where + ((ReceiverIndex + i) << ShiftForWord), longAtPointer(localSP - ((argCount2 - i) * BytesPerWord)));
				}

				/* needsLarge here used just as faster (register?) temp */

				needsLarge = GIV(nilObj);
				for (i = ((argCount2 + 1) + ReceiverIndex); i <= (tempCount + ReceiverIndex); i += 1) {
					longAtput(where + (i << ShiftForWord), needsLarge);
				}
				if (GIV(primFailCode) > 0) {
					if (((primitiveIndexOfMethodHeader(methodHeader)) > 0)
					 && ((byteAt((GIV(newMethod) + BaseHeaderSize) + (initialIP - 1))) == 129)) {
						needsLarge = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord))) + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
						longAtput(where + ((tempCount + ReceiverIndex) << ShiftForWord), needsLarge);
					}
					GIV(primFailCode) = 0;
				}
				/* begin internalPop: */
				localSP -= (argCount2 + 1) * BytesPerWord;
				GIV(reclaimableContextCount) += 1;
				/* begin internalNewActiveContext: */
				VM_LABEL(0internalNewActiveContext);
				/* begin internalStoreContextRegisters: */
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer = (((((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize)) << 1) | 1);
				longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer1 = (((((((usqInt) ((oopForPointer(localSP)) - (GIV(activeContext) + BaseHeaderSize))) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1);
				longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), valuePointer1);
				if (newContext < GIV(youngStart)) {
					beRootIfOld(newContext);
				}
				GIV(activeContext) = newContext;
				/* begin internalFetchContextRegisters: */
				VM_LABEL(1internalFetchContextRegisters);
				tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
				if ((tmp & 1)) {

					/* if the MethodIndex field is an integer, activeCntx is a block context */

					tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
					if (tmp < GIV(youngStart)) {
						beRootIfOld(tmp);
					}
				}
				else {
					tmp = newContext;
				}
				localHomeContext = tmp;
				GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

				/* the instruction pointer is a pointer variable equal to
		method oop + ip + BaseHeaderSize
		  -1 for 0-based addressing of fetchByte
		  -1 because it gets incremented BEFORE fetching currentByte */

				GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
				tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

				/* the stack pointer is a pointer variable also... */

				localIP = pointerForOop(((GIV(method) + tmp) + BaseHeaderSize) - 2);
				tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
				localSP = pointerForOop((newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord));
				/* begin internalQuickCheckForInterrupts */
				if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					checkForInterrupts();
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
				}
			l94:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				sqInt opType;
				sqInt top;
				sqInt targetObj;
				sqInt targetObj1;

				VM_LABEL(0doubleExtendedDoAnythingBytecode);
								byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					GIV(argumentCount) = byte2 & 31;
					goto normalSend;
					goto l11;
				}
				if (opType == 1) {
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord));
					GIV(argumentCount) = byte2 & 31;
					goto commonSupersend;
					goto l11;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				if (opType == 2) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt((GIV(receiver) + BaseHeaderSize) + (byte3 << ShiftForWord)));
					goto l11;
				}
				if (opType == 3) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord)));
					goto l11;
				}
				if (opType == 4) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP += BytesPerWord), longAt(((longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord)));
					goto l11;
				}
				if (opType == 5) {
					top = longAtPointer(localSP);
					if (((longAt(GIV(receiver))) & ImmutabilityBit) != 0) {
						/* begin undoFetchNextBytecode */
						localIP -= 1;
						/* begin internalCannotAssign:to:withIndex: */
						targetObj = GIV(receiver);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), targetObj);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), top);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), (((byte3 + 1) << 1) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l11;
					}
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) GIV(receiver))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(GIV(receiver), top);
					}
					longAtput((GIV(receiver) + BaseHeaderSize) + (byte3 << ShiftForWord), top);
					goto l11;
				}
				if (opType == 6) {
					top = longAtPointer(localSP);
					/* begin internalPop: */
					localSP -= 1 * BytesPerWord;
					if (((longAt(GIV(receiver))) & ImmutabilityBit) != 0) {
						/* begin undoFetchNextBytecode */
						localIP -= 1;
						/* begin internalCannotAssign:to:withIndex: */
						targetObj1 = GIV(receiver);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), targetObj1);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), top);
						/* begin internalPush: */
						longAtPointerput((localSP += BytesPerWord), (((byte3 + 1) << 1) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAttemptToAssign << ShiftForWord));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l11;
					}
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) GIV(receiver))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(GIV(receiver), top);
					}
					longAtput((GIV(receiver) + BaseHeaderSize) + (byte3 << ShiftForWord), top);
					goto l11;
				}
				if (opType == 7) {
					top = longAtPointer(localSP);
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(0storePointerofObjectwithValue);
					if ((((usqInt) (longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord))))) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord)), top);
					}
					longAtput(((longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord), top);
					goto l11;
				}
			}
;
		l11:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0singleExtendedSuperBytecode);
								descriptor = byteAtPointer(++localIP);
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 31) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto commonSupersend */
			}
;
			
		commonSupersend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt literal;

				VM_LABEL(0superclassSend);
								/* begin superclassOf: */
				/* begin methodClassOf: */
				literal = longAt((GIV(method) + BaseHeaderSize) + (((((((usqInt) (longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) - 1) + LiteralStart) << ShiftForWord));
				classPointer = (literal == GIV(nilObj)
					? (literal)
					: (longAt((literal + BaseHeaderSize) + (ValueIndex << ShiftForWord))));
				GIV(lkupClass) = longAt((classPointer + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
				goto commonSend;
			}
;
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0secondExtendedSendBytecode);
								descriptor = byteAtPointer(++localIP);
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 63) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
;
			break;
		case 135:
			/* popStackBytecode */
			{

				VM_LABEL(0popStackBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 136:
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(0duplicateTopBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP += BytesPerWord), object);
			}
;
			break;
		case 137:
			/* pushActiveContextBytecode */
			{

				VM_LABEL(0pushActiveContextBytecode);
								/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				GIV(reclaimableContextCount) = 0;
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(activeContext));
			}
;
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				sqInt popValues;
				sqInt size;

				VM_LABEL(0pushNewArrayBytecode);
								size = byteAtPointer(++localIP);
				popValues = size > 127;
				size = size & 127;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = oopForPointer(localSP);
				GIV(theHomeContext) = localHomeContext;
				array = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), size);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localHomeContext = GIV(theHomeContext);
				if (popValues) {
					for (i = 0; i <= (size - 1); i += 1) {
						longAtput((array + BaseHeaderSize) + (i << ShiftForWord), longAtPointer(localSP - (((size - i) - 1) * BytesPerWord)));
					}
					/* begin internalPop: */
					localSP -= size * BytesPerWord;
				}
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), array);
			}
;
			break;
		case 139:
			/* pushExplicitOuterSendReceiverBytecode */
			{
				sqInt anInt;
				sqInt litIndex;
				sqInt mClassMixin;
				sqInt n;
				sqInt object;
				sqInt literal;
				sqInt anObject;
				sqInt count;
				sqInt explicitReceiver;
				sqInt mixinApplication;
				sqInt targetMixin;
				sqInt aClass;
				sqInt mixinOrMixinApplication;
				sqInt ccIndex;

				VM_LABEL(0pushExplicitOuterSendReceiverBytecode);
								litIndex = byteAtPointer(++localIP);
				anInt = longAt((GIV(method) + BaseHeaderSize) + ((litIndex + LiteralStart) << ShiftForWord));
				/* begin checkedIntegerValueOf: */
				if ((anInt & 1)) {
					n = (anInt >> 1);
					goto l12;
				}
				else {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
					n = 0;
					goto l12;
				}
			l12:	/* end checkedIntegerValueOf: */;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin methodClassOf: */
				literal = longAt((GIV(method) + BaseHeaderSize) + (((((((usqInt) (longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) - 1) + LiteralStart) << ShiftForWord));
				mClassMixin = (literal == GIV(nilObj)
					? (literal)
					: (longAt((literal + BaseHeaderSize) + (ValueIndex << ShiftForWord))));
				/* begin internalPush: */
				/* begin explicitOuterReceiver:withObject:withMixin: */
				VM_LABEL(0explicitOuterReceiverwithObjectwithMixin);
				anObject = GIV(receiver);
				explicitReceiver = anObject;
				targetMixin = mClassMixin;
				count = 0;
				while (count < n) {
					count += 1;
					if ((targetMixin == GIV(nilObj))
					 || (explicitReceiver == GIV(nilObj))) {
						object = GIV(nilObj);
						goto l13;
					}
					/* begin findApplicationOfTargetMixin:startingAtNonMetaClass: */
					/* begin fetchClassOf: */
					if ((explicitReceiver & 1)) {
						aClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
						goto l14;
					}
					if (((ccIndex = (((usqInt) (longAt(explicitReceiver))) >> 12) & 31)) == 0) {
						aClass = (longAt(explicitReceiver - BaseHeaderSize)) & AllButTypeMask;
						goto l14;
					}
					else {
						aClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
						goto l14;
					}
				l14:	/* end fetchClassOf: */;
					mixinOrMixinApplication = aClass;
					while (!((mixinOrMixinApplication == GIV(nilObj))
					 || ((mixinOrMixinApplication == targetMixin)
					 || ((longAt((mixinOrMixinApplication + BaseHeaderSize) + (MixinIndex << ShiftForWord))) == targetMixin)))) {
						mixinOrMixinApplication = longAt((mixinOrMixinApplication + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
					}
					mixinApplication = mixinOrMixinApplication;
					if (mixinApplication == GIV(nilObj)) {
						object = GIV(nilObj);
						goto l13;
					}
					explicitReceiver = longAt((mixinApplication + BaseHeaderSize) + (EnclosingObjectIndex << ShiftForWord));
					targetMixin = longAt((targetMixin + BaseHeaderSize) + (EnclosingMixinIndex << ShiftForWord));
				}
				object = explicitReceiver;
			l13:	/* end explicitOuterReceiver:withObject:withMixin: */;
				longAtPointerput((localSP += BytesPerWord), object);
			}
;
			break;
		case 140:
			/* pushRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;

				VM_LABEL(0pushRemoteTempLongBytecode);
								remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = longAt((localHomeContext + BaseHeaderSize) + ((tempVectorIndex + TempFrameStart) << ShiftForWord));
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), longAt((tempVector + BaseHeaderSize) + (remoteTempIndex << ShiftForWord)));
			}
;
			break;
		case 141:
			/* storeRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;

				VM_LABEL(0storeRemoteTempLongBytecode);
								remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = longAt((localHomeContext + BaseHeaderSize) + ((tempVectorIndex + TempFrameStart) << ShiftForWord));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) tempVector)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (remoteTempIndex << ShiftForWord), longAtPointer(localSP));
			}
;
			break;
		case 142:
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt remoteTempIndex;
				sqInt tempVectorIndex;
				sqInt tempVector;

				VM_LABEL(0storeAndPopRemoteTempLongBytecode);
								/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = longAt((localHomeContext + BaseHeaderSize) + ((tempVectorIndex + TempFrameStart) << ShiftForWord));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) tempVector)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (remoteTempIndex << ShiftForWord), longAtPointer(localSP));
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			}
;
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt i;
				sqInt newClosure;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				sqInt initialIP;
				sqInt newClosure1;

				VM_LABEL(0pushClosureCopyCopiedValuesBytecode);
								if (BytesPerWord == 4) {
					imageFormatVersionNumber = 6504;
				}
				else {
					imageFormatVersionNumber = 68002;
				}
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */

				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = (byteAtPointer(++localIP)) << 8;
				blockSize += byteAtPointer(++localIP);
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = oopForPointer(localSP);
				GIV(theHomeContext) = localHomeContext;
				/* begin closureNumArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);

				/* Assume: have just allocated a new closure; it must be young. Thus, can use unchecked stores. */

				newClosure1 = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)), (BytesPerWord * (ClosureFirstCopiedValueIndex + numCopied)) + BaseHeaderSize);
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord), ((initialIP << 1) | 1));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord), ((numArgs << 1) | 1));
				newClosure = newClosure1;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localHomeContext = GIV(theHomeContext);
				longAtput((newClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord), GIV(activeContext));

				/* The closure refers to thisContext so it can't be reclaimed. */

				GIV(reclaimableContextCount) = 0;
				if (numCopied > 0) {
					for (i = 0; i <= (numCopied - 1); i += 1) {
						longAtput((newClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord), longAtPointer(localSP - (((numCopied - i) - 1) * BytesPerWord)));
					}
					/* begin internalPop: */
					localSP -= numCopied * BytesPerWord;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), newClosure);
			}
;
			break;
		case 144:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(0shortUnconditionalJump);
								/* begin jump: */
				offset = (144 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 145:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(1shortUnconditionalJump);
								/* begin jump: */
				offset = (145 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 146:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(2shortUnconditionalJump);
								/* begin jump: */
				offset = (146 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 147:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(3shortUnconditionalJump);
								/* begin jump: */
				offset = (147 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 148:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(4shortUnconditionalJump);
								/* begin jump: */
				offset = (148 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 149:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(5shortUnconditionalJump);
								/* begin jump: */
				offset = (149 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 150:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(6shortUnconditionalJump);
								/* begin jump: */
				offset = (150 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 151:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(7shortUnconditionalJump);
								/* begin jump: */
				offset = (151 & 7) + 1;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
;
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJump */
			{
				sqInt offset;
				sqInt boolean;

				VM_LABEL(0shortConditionalJump);
								/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l15;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			l15:	/* end jumplfFalseBy: */;
			}
;
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(0longUnconditionalJump);
								offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				if (offset < 0) {
					/* begin internalQuickCheckForInterrupts */
					if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = oopForPointer(localSP);
						GIV(theHomeContext) = localHomeContext;
						checkForInterrupts();
						browserPluginReturnIfNeeded();
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localHomeContext = GIV(theHomeContext);
					}
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt offset;
				sqInt boolean;

				VM_LABEL(0longJumpIfTrue);
								/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l16;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			l16:	/* end jumplfTrueBy: */;
			}
;
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt offset;
				sqInt boolean;

				VM_LABEL(0longJumpIfFalse);
								/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << ShiftForWord));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l17;
					}
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				/* begin internalPop: */
				localSP -= 1 * BytesPerWord;
			l17:	/* end jumplfFalseBy: */;
			}
;
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double  arg1;
				double  rcvr1;
				sqInt object;
				sqInt sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimAdd);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((result ^ (result << 1)) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP -= (2 - 1) * BytesPerWord), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l18;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					/* begin primitiveFloatAdd:toArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l20;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l19;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l19;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l19:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (!GIV(primFailCode)) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l20:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l22;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l21;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l21;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l21:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (!GIV(primFailCode)) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l22:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop: */
						GIV(stackPointer) -= 2 * BytesPerWord;
						/* begin pushFloat: */
						/* begin push: */
						object = floatObjectOf(rcvr1 + arg1);
						longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l18;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((0 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l18:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double  arg1;
				double  rcvr1;
				sqInt object;
				sqInt sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimSubtract);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((result ^ (result << 1)) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP -= (2 - 1) * BytesPerWord), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l23;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					/* begin primitiveFloatSubtract:fromArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l25;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l24;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l24;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l24:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (!GIV(primFailCode)) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l25:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l27;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l26;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l26;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l26:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (!GIV(primFailCode)) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l27:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop: */
						GIV(stackPointer) -= 2 * BytesPerWord;
						/* begin pushFloat: */
						/* begin push: */
						object = floatObjectOf(rcvr1 - arg1);
						longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l23;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((1 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l23:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimLessThan);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l28;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l30;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l29;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l29;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l29:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l30:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l32;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l31;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l31;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l31:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l32:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l28;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((2 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l28:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(0booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP -= 2 * BytesPerWord;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l95;
					}
					if (bytecode == 172) {
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l95;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */

						offset = ((bytecode - 168) << 8) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);
						goto l95;
					}
				}
				currentBytecode = bytecode;
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(trueObj));
			}
;
		l95:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimGreaterThan);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l33;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l35;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l34;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l34;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l34:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l35:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l37;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l36;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l36;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l36:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l37:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l33;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((3 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l33:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(0booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP -= 2 * BytesPerWord;
				if ((bytecode < 160)
				 && (bytecode > 151)) {
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);
					goto l96;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */

					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
					goto l96;
				}
				currentBytecode = bytecode;
				/* begin internalPush: */
				longAtPointerput((localSP += BytesPerWord), GIV(falseObj));
			}
;
		l96:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimLessOrEqual);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l38;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l40;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l39;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l39;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l39:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l40:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l42;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l41;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l41;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l41:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l42:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l38;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((4 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l38:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimGreaterOrEqual);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l43;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l45;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l44;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l44;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l44:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l45:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l47;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l46;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l46;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l46:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l47:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l43;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((5 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l43:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimEqual);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l48;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l50;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l49;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l49;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l49:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l50:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l52;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l51;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l51;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l51:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l52:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l48;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((6 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l48:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				sqInt rcvr;
				double arg1;
				double rcvr1;
				double result;
				sqInt successBoolean;
				sqInt ccIndex;
				double result1;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimNotEqual);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l53;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l55;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 1)) {
					successBoolean = 0;
					goto l54;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean = ClassFloatCompactIndex == ccIndex;
					goto l54;
				}
				successBoolean = (ccIndex == 0)
				 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l54:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
				}
				rcvr1 = result;
			l55:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l57;
				}
				/* begin assertClassOf:is:compactClassIndex: */
				/* begin success: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 1)) {
					successBoolean1 = 0;
					goto l56;
				}
				ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
				if (ClassFloatCompactIndex != 0) {
					successBoolean1 = ClassFloatCompactIndex == ccIndex1;
					goto l56;
				}
				successBoolean1 = (ccIndex1 == 0)
				 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
			l56:	/* end is:instanceOf:compactClassIndex: */;
				if (!(successBoolean1)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				;
				if (!GIV(primFailCode)) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
				}
				arg1 = result1;
			l57:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l53;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((7 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l53:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;
				double  arg1;
				double  rcvr1;
				sqInt object;
				sqInt sp;
				double result1;
				sqInt successBoolean;
				sqInt ccIndex;
				double result2;
				sqInt successBoolean1;
				sqInt ccIndex1;

				VM_LABEL(0bytecodePrimMultiply);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					result = rcvr * arg;
					if (((arg == 0)
 || ((result / arg) == rcvr))
					 && ((result ^ (result << 1)) >= 0)) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP -= (2 - 1) * BytesPerWord), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l58;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					/* begin primitiveFloatMultiply:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l60;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 1)) {
						successBoolean = 0;
						goto l59;
					}
					ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean = ClassFloatCompactIndex == ccIndex;
						goto l59;
					}
					successBoolean = (ccIndex == 0)
					 && (((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l59:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (!GIV(primFailCode)) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
					}
					rcvr1 = result1;
				l60:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l62;
					}
					/* begin assertClassOf:is:compactClassIndex: */
					/* begin success: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 1)) {
						successBoolean1 = 0;
						goto l61;
					}
					ccIndex1 = (((usqInt) (longAt(arg))) >> 12) & 31;
					if (ClassFloatCompactIndex != 0) {
						successBoolean1 = ClassFloatCompactIndex == ccIndex1;
						goto l61;
					}
					successBoolean1 = (ccIndex1 == 0)
					 && (((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
				l61:	/* end is:instanceOf:compactClassIndex: */;
					if (!(successBoolean1)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					;
					if (!GIV(primFailCode)) {
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
					}
					arg1 = result2;
				l62:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop: */
						GIV(stackPointer) -= 2 * BytesPerWord;
						/* begin pushFloat: */
						/* begin push: */
						object = floatObjectOf(rcvr1 * arg1);
						longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l58;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((8 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l58:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				sqInt rcvr;
				sqInt result;

				VM_LABEL(0bytecodePrimDivide);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */

						result = rcvr / arg;
						if ((result ^ (result << 1)) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (2 - 1) * BytesPerWord), ((result << 1) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							goto l63;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					primitiveFloatDividebyArg(rcvr, arg);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l63;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((9 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l63:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(0bytecodePrimMod);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP - (1 * BytesPerWord)), longAtPointer(localSP - (0 * BytesPerWord)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP -= (2 - 1) * BytesPerWord), ((mod << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l64;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((10 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l64:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				sqInt argument;
				sqInt pt;
				sqInt rcvr;
				sqInt pointResult;
				sqInt pointResult1;
				sqInt valuePointer;
				sqInt pointResult2;
				sqInt valuePointer1;
				sqInt valuePointer2;
				sqInt sp;

				VM_LABEL(0bytecodePrimMakePoint);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = oopForPointer(localSP);
				GIV(theHomeContext) = localHomeContext;
				/* begin primitiveMakePoint */
				VM_LABEL(0primitiveMakePoint);
				argument = longAt(GIV(stackPointer));
				rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
				if ((rcvr & 1)) {
					if ((argument & 1)) {
						/* begin makePointwithxValue:yValue: */
						pointResult = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
						longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
						longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((((argument >> 1)) << 1) | 1));
						pt = pointResult;
					}
					else {
						/* begin makePointwithxValue:yValue: */
						pointResult1 = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
						longAtput((pointResult1 + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
						longAtput((pointResult1 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
						pt = pointResult1;
						/* begin storePointer:ofObject:withValue: */
						valuePointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
						if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
							possibleRootStoreIntovalue(pt, valuePointer);
						}
						longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), valuePointer);
					}
				}
				else {
					if (!(((rcvr & 1) == 0)
						 && ((fetchClassOfNonInt(rcvr)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)))))) {
						/* begin success: */
						if (!(0)) {
							if (!GIV(primFailCode)) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
						goto l66;
					}
					/* begin makePointwithxValue:yValue: */
					pointResult2 = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
					longAtput((pointResult2 + BaseHeaderSize) + (XIndex << ShiftForWord), ((0 << 1) | 1));
					longAtput((pointResult2 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
					pt = pointResult2;
					/* begin storePointer:ofObject:withValue: */
					valuePointer1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
					if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(pt, valuePointer1);
					}
					longAtput((pt + BaseHeaderSize) + (0 << ShiftForWord), valuePointer1);
					/* begin storePointer:ofObject:withValue: */
					valuePointer2 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
					if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(pt, valuePointer2);
					}
					longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), valuePointer2);
				}
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), pt);
				GIV(stackPointer) = sp;
			l66:	/* end primitiveMakePoint */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localHomeContext = GIV(theHomeContext);
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l65;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((11 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l65:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt shifted;
				sqInt object;
				sqInt sp;
				sqInt top;
				sqInt top1;
				sqInt integerPointer;
				sqInt top2;

				VM_LABEL(0bytecodePrimBitShift);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = oopForPointer(localSP);
				GIV(theHomeContext) = localHomeContext;
				/* begin primitiveBitShift */
				VM_LABEL(0primitiveBitShift);
				/* begin popInteger */
				/* begin popStack */
				top2 = longAt(GIV(stackPointer));
				GIV(stackPointer) -= BytesPerWord;
				integerPointer = top2;
				/* begin checkedIntegerValueOf: */
				if ((integerPointer & 1)) {
					integerArgument = (integerPointer >> 1);
					goto l68;
				}
				else {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
					integerArgument = 0;
					goto l68;
				}
			l68:	/* end popInteger */;
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) -= BytesPerWord;
				top = top1;
				integerReceiver = positive32BitValueOf(top);
				if (!GIV(primFailCode)) {
					if (integerArgument >= 0) {
						/* begin success: */
						if (!(integerArgument <= 31)) {
							if (!GIV(primFailCode)) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
						shifted = integerReceiver << integerArgument;
						/* begin success: */
						if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {
							if (!GIV(primFailCode)) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
					}
					else {
						/* begin success: */
						if (!(integerArgument >= -31)) {
							if (!GIV(primFailCode)) {

								/* Don't overwrite an error code that has already been set. */

								GIV(primFailCode) = 1;
							}
						}
						shifted = ((integerArgument < 0) ? ((usqInt) integerReceiver >> -integerArgument) : ((usqInt) integerReceiver << integerArgument));
					}
				}
				if (!GIV(primFailCode)) {
					/* begin push: */
					object = positive32BitIntegerFor(shifted);
					longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) += 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localHomeContext = GIV(theHomeContext);
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l67;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((12 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l67:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(0bytecodePrimDiv);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP - (1 * BytesPerWord)), longAtPointer(localSP - (0 * BytesPerWord)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP -= (2 - 1) * BytesPerWord), ((quotient << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l69;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((13 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l69:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				sqInt sp;
				sqInt top;
				sqInt top1;
				sqInt top2;
				sqInt top11;

				VM_LABEL(0bytecodePrimBitAnd);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = oopForPointer(localSP);
				GIV(theHomeContext) = localHomeContext;
				/* begin primitiveBitAnd */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) -= BytesPerWord;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(GIV(stackPointer));
				GIV(stackPointer) -= BytesPerWord;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (!GIV(primFailCode)) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver & integerArgument);
					longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) += 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localHomeContext = GIV(theHomeContext);
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l70;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((14 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l70:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				sqInt sp;
				sqInt top;
				sqInt top1;
				sqInt top2;
				sqInt top11;

				VM_LABEL(0bytecodePrimBitOr);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = oopForPointer(localSP);
				GIV(theHomeContext) = localHomeContext;
				/* begin primitiveBitOr */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) -= BytesPerWord;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(GIV(stackPointer));
				GIV(stackPointer) -= BytesPerWord;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (!GIV(primFailCode)) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver | integerArgument);
					longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) += 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localHomeContext = GIV(theHomeContext);
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l71;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((15 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l71:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt index;
				sqInt rcvr;
				sqInt result;
				sqInt successBoolean;
				sqInt fixedFields;
				sqInt fmt;
				sqInt result1;
				sqInt stSize;

				VM_LABEL(0bytecodePrimAt);
								index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				/* begin success: */
				successBoolean = (!((rcvr & 1)))
				 && ((index & 1));
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {

					/* Index into atCache = 4N, for N = 0 ... 7 */

					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) == rcvr) {
						/* begin commonVariableInternal:at:cacheIndex: */
						VM_LABEL(0commonVariableInternalatcacheIndex);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if (((((usqInt ) ((index >> 1)))) >= 1)
						 && ((((usqInt ) ((index >> 1)))) <= (((usqInt ) stSize)))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= 4) {
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((((index >> 1)) + fixedFields) - 1) << ShiftForWord));
								goto l73;
							}
							if (fmt < 8) {

								/* Bitmap */

								result1 = long32At((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2));
								/* begin externalizeIPandSP */
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = oopForPointer(localSP);
								GIV(theHomeContext) = localHomeContext;
								result1 = positive32BitIntegerFor(result1);
								/* begin internalizeIPandSP */
								localIP = pointerForOop(GIV(instructionPointer));
								localSP = pointerForOop(GIV(stackPointer));
								localHomeContext = GIV(theHomeContext);
								result = result1;
								goto l73;
							}
							if (fmt >= 16) {
								result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + ((byteAt((rcvr + BaseHeaderSize) + (((index >> 1)) - 1))) << ShiftForWord));
								goto l73;
							}
							else {
								result = (((byteAt((rcvr + BaseHeaderSize) + (((index >> 1)) - 1))) << 1) | 1);
								goto l73;
							}
						}
						/* begin primitiveFailFor: */
						GIV(primFailCode) = PrimErrBadIndex;
					l73:	/* end commonVariableInternal:at:cacheIndex: */;
						if (!GIV(primFailCode)) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (2 - 1) * BytesPerWord), result);
							goto l72;
						}
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
		l72:	/* end case */;
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt index;
				sqInt rcvr;
				sqInt value;
				sqInt successBoolean;
				sqInt fixedFields;
				sqInt fmt;
				sqInt stSize;
				sqInt valToPut;

				VM_LABEL(0bytecodePrimAtPut);
								value = longAtPointer(localSP);
				index = longAtPointer(localSP - (1 * BytesPerWord));
				rcvr = longAtPointer(localSP - (2 * BytesPerWord));
				/* begin success: */
				successBoolean = (!((rcvr & 1)))
				 && (((index & 1))
				 && (((longAt(rcvr)) & ImmutabilityBit) == 0));
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {

					/* Index into atPutCache */

					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) == rcvr) {
						/* begin commonVariable:at:put:cacheIndex: */
						VM_LABEL(0commonVariableatputcacheIndex);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if (((((usqInt ) ((index >> 1)))) >= 1)
						 && ((((usqInt ) ((index >> 1)))) <= (((usqInt ) stSize)))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= 4) {
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
									possibleRootStoreIntovalue(rcvr, value);
								}
								longAtput((rcvr + BaseHeaderSize) + (((((index >> 1)) + fixedFields) - 1) << ShiftForWord), value);
								goto l75;
							}
							if (fmt < 8) {

								/* Bitmap */

								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									long32Atput((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2), valToPut);
									goto l75;
								}
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l75;
							}
							if (fmt >= 16) {

								/* Note fmt >= 16 is an artificial flag for strings */

								valToPut = asciiOfCharacter(value);
								if (!(!GIV(primFailCode))) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l75;
								}
							}
							else {
								valToPut = value;
							}
							if ((valToPut & 1)) {
								valToPut = (valToPut >> 1);
								if (!((valToPut >= 0)
									 && (valToPut <= 255))) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l75;
								}
								byteAtput((rcvr + BaseHeaderSize) + (((index >> 1)) - 1), valToPut);
								goto l75;
							}
							/* begin primitiveFailFor: */
							GIV(primFailCode) = PrimErrInappropriate;
							goto l75;
						}
						/* begin primitiveFailFor: */
						GIV(primFailCode) = PrimErrBadIndex;
					l75:	/* end commonVariable:at:put:cacheIndex: */;
						if (!GIV(primFailCode)) {
							/* begin fetchNextBytecode */
							currentBytecode = byteAtPointer(++localIP);
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP -= (3 - 1) * BytesPerWord), value);
							goto l74;
						}
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
;
		l74:	/* end case */;
			break;
		case 194:
			/* bytecodePrimSize */
			{

				VM_LABEL(0bytecodePrimSize);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((18 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			break;
		case 195:
			/* bytecodePrimNext */
			{

				VM_LABEL(0bytecodePrimNext);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((19 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			break;
		case 196:
			/* bytecodePrimNextPut */
			{

				VM_LABEL(0bytecodePrimNextPut);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((20 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			break;
		case 197:
			/* bytecodePrimAtEnd */
			{

				VM_LABEL(0bytecodePrimAtEnd);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((21 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			break;
		case 198:
			/* bytecodePrimEquivalent */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(0bytecodePrimEquivalent);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				arg = longAtPointer(localSP - (0 * BytesPerWord));
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
;
			break;
		case 199:
			/* bytecodePrimClass */
			{
				sqInt rcvr;
				sqInt oop;
				sqInt ccIndex;

				VM_LABEL(0bytecodePrimClass);
								rcvr = longAtPointer(localSP);
				/* begin internalPop:thenPush: */
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l76;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					oop = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l76;
				}
				else {
					oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l76;
				}
			l76:	/* end fetchClassOf: */;
				longAtPointerput((localSP -= (1 - 1) * BytesPerWord), oop);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
			break;
		case 200:
			/* bytecodePrimBlockCopy */
			{
				sqInt hdr;
				sqInt rcvr;
				sqInt successBoolean;
				sqInt context;
				sqInt contextSize;
				sqInt initialIP;
				sqInt methodContext;
				sqInt newContext;
				sqInt header;
				sqInt oop;
				sqInt sp;

				VM_LABEL(0bytecodePrimBlockCopy);
								rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				hdr = longAt(rcvr);
				/* begin success: */
				successBoolean = (((((usqInt) hdr) >> 12) & 31) == 13)
				 || (((((usqInt) hdr) >> 12) & 31) == 14);
				if (!(successBoolean)) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = oopForPointer(localSP);
					GIV(theHomeContext) = localHomeContext;
					/* begin primitiveBlockCopy */
					VM_LABEL(0primitiveBlockCopy);
					context = longAt(GIV(stackPointer) - (1 * BytesPerWord));
					if (((longAt((context + BaseHeaderSize) + (MethodIndex << ShiftForWord))) & 1)) {

						/* context is a block; get the context of its enclosing method */

						methodContext = longAt((context + BaseHeaderSize) + (HomeIndex << ShiftForWord));
					}
					else {
						methodContext = context;
					}
					/* begin sizeBitsOf: */
					header = longAt(methodContext);
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						contextSize = (longAt(methodContext - (BytesPerWord * 2))) & LongSizeMask;
						goto l78;
					}
					else {
						contextSize = header & SizeMask;
						goto l78;
					}
				l78:	/* end sizeBitsOf: */;

					/* context is no longer needed and is not preserved across allocation */
					/* remap methodContext in case GC happens during allocation */

					context = null;
					/* begin pushRemappableOop: */
					assert(addressCouldBeOop(methodContext));
					GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = methodContext;
					newContext = instantiateContextsizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockContext << ShiftForWord)), contextSize);
					/* begin popRemappableOop */
					oop = GIV(remapBuffer)[GIV(remapBufferCount)];
					GIV(remapBufferCount) -= 1;
					methodContext = oop;

					/* Was instructionPointer + 3, but now it's greater by 1 due to preIncrement */
					/* Assume: have just allocated a new context; it must be young.
	 Thus, can use uncheck stores. See the comment in fetchContextRegisters. */

					initialIP = (((((GIV(instructionPointer) + 1) + 3) - (GIV(method) + BaseHeaderSize)) << 1) | 1);
					longAtput((newContext + BaseHeaderSize) + (InitialIPIndex << ShiftForWord), initialIP);
					longAtput((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), initialIP);
					/* begin storeStackPointerValue:inContext: */
					longAtput((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((0 << 1) | 1));
					longAtput((newContext + BaseHeaderSize) + (BlockArgumentCountIndex << ShiftForWord), longAt(GIV(stackPointer) - (0 * BytesPerWord)));
					longAtput((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord), methodContext);
					longAtput((newContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), newContext);
					GIV(stackPointer) = sp;
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localHomeContext = GIV(theHomeContext);
				}
				if (!(!GIV(primFailCode))) {
					GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((24 * 2) << ShiftForWord));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l77;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l77:	/* end case */;
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt maybeBlock;
				sqInt rcvrClass;
				sqInt ccIndex;

				VM_LABEL(0bytecodePrimValue);
								maybeBlock = longAtPointer(localSP);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				GIV(argumentCount) = 0;
				if ((maybeBlock & 1) == 0) {
					/* begin fetchClassOfNonInt: */
					if (((ccIndex = (((usqInt) (longAt(maybeBlock))) >> 12) & 31)) == 0) {
						rcvrClass = (longAt(maybeBlock - BaseHeaderSize)) & AllButTypeMask;
						goto l80;
					}
					else {
						rcvrClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
						goto l80;
					}
				l80:	/* end fetchClassOfNonInt: */;
					if (rcvrClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)))) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = oopForPointer(localSP);
						GIV(theHomeContext) = localHomeContext;
						primitiveClosureValue();
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localHomeContext = GIV(theHomeContext);
					}
					else {
						if (rcvrClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockContext << ShiftForWord)))) {
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = oopForPointer(localSP);
							GIV(theHomeContext) = localHomeContext;
							primitiveValue();
							/* begin internalizeIPandSP */
							localIP = pointerForOop(GIV(instructionPointer));
							localSP = pointerForOop(GIV(stackPointer));
							localHomeContext = GIV(theHomeContext);
						}
						else {
							/* begin primitiveFail */
							GIV(primFailCode) = 1;
						}
					}
				}
				if (!(!GIV(primFailCode))) {
					GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((25 * 2) << ShiftForWord));
					goto normalSend;
					goto l79;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l79:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt maybeBlock;
				sqInt rcvrClass;
				sqInt ccIndex;

				VM_LABEL(0bytecodePrimValueWithArg);
								maybeBlock = longAtPointer(localSP - (1 * BytesPerWord));
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				GIV(argumentCount) = 1;
				if ((maybeBlock & 1) == 0) {
					/* begin fetchClassOfNonInt: */
					if (((ccIndex = (((usqInt) (longAt(maybeBlock))) >> 12) & 31)) == 0) {
						rcvrClass = (longAt(maybeBlock - BaseHeaderSize)) & AllButTypeMask;
						goto l82;
					}
					else {
						rcvrClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
						goto l82;
					}
				l82:	/* end fetchClassOfNonInt: */;
					if (rcvrClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)))) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = oopForPointer(localSP);
						GIV(theHomeContext) = localHomeContext;
						primitiveClosureValue();
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localHomeContext = GIV(theHomeContext);
					}
					else {
						if (rcvrClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockContext << ShiftForWord)))) {
							/* begin externalizeIPandSP */
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = oopForPointer(localSP);
							GIV(theHomeContext) = localHomeContext;
							primitiveValue();
							/* begin internalizeIPandSP */
							localIP = pointerForOop(GIV(instructionPointer));
							localSP = pointerForOop(GIV(stackPointer));
							localHomeContext = GIV(theHomeContext);
						}
						else {
							/* begin primitiveFail */
							GIV(primFailCode) = 1;
						}
					}
				}
				if (!(!GIV(primFailCode))) {
					GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((26 * 2) << ShiftForWord));
					goto normalSend;
					goto l81;
				}
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
;
		l81:	/* end case */;
			break;
		case 203:
			/* bytecodePrimDo */
			{

				VM_LABEL(0bytecodePrimDo);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((27 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			break;
		case 204:
			/* bytecodePrimNew */
			{

				VM_LABEL(0bytecodePrimNew);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((28 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
			break;
		case 205:
			/* bytecodePrimNewWithArg */
			{

				VM_LABEL(0bytecodePrimNewWithArg);
								GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((29 * 2) << ShiftForWord));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
;
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt rcvr;
				sqInt ccIndex;
				sqInt cl;

				VM_LABEL(0bytecodePrimPointX);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				VM_LABEL(0assertClassOfis);
				if ((rcvr & 1)) {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
					goto l84;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
				}
				else {

					/* look up compact class */

					cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
				}
				/* begin success: */
				if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord))))) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
			l84:	/* end assertClassOf:is: */;
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP -= (1 - 1) * BytesPerWord), longAt((rcvr + BaseHeaderSize) + (XIndex << ShiftForWord)));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l83;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((30 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
		l83:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt rcvr;
				sqInt ccIndex;
				sqInt cl;

				VM_LABEL(0bytecodePrimPointY);
								/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				VM_LABEL(1assertClassOfis);
				if ((rcvr & 1)) {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
					goto l86;
				}
				ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31;
				if (ccIndex == 0) {
					cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
				}
				else {

					/* look up compact class */

					cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
				}
				/* begin success: */
				if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord))))) {
					if (!GIV(primFailCode)) {

						/* Don't overwrite an error code that has already been set. */

						GIV(primFailCode) = 1;
					}
				}
			l86:	/* end assertClassOf:is: */;
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP -= (1 - 1) * BytesPerWord), longAt((rcvr + BaseHeaderSize) + (YIndex << ShiftForWord)));
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l85;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((31 * 2) << ShiftForWord));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
;
		l85:	/* end case */;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 221:
		case 222:
		case 223:
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0sendLiteralSelector0ArgsBytecode);
								GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP - (0 * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l87;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l87;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l87;
				}
			l87:	/* end fetchClassOf: */;
				goto commonSend;
			}
;
			break;
		case 224:
		case 225:
		case 226:
		case 227:
		case 228:
		case 229:
		case 230:
		case 231:
		case 232:
		case 233:
		case 234:
		case 235:
		case 236:
		case 237:
		case 238:
		case 239:
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0sendLiteralSelector1ArgBytecode);
								GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP - (1 * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l88;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l88;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l88;
				}
			l88:	/* end fetchClassOf: */;
				goto commonSend;
			}
;
			break;
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt rcvr;
				sqInt ccIndex;

				VM_LABEL(0sendLiteralSelector2ArgsBytecode);
								GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << ShiftForWord));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP - (2 * BytesPerWord));
				/* begin fetchClassOf: */
				if ((rcvr & 1)) {
					GIV(lkupClass) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
					goto l89;
				}
				if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
					GIV(lkupClass) = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					goto l89;
				}
				else {
					GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
					goto l89;
				}
			l89:	/* end fetchClassOf: */;
				goto commonSend;
			}
;
			break;
		}
	}

	/* undo the pre-increment of IP before returning */

	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = oopForPointer(localSP);
	GIV(theHomeContext) = localHomeContext;
}


/*	Return the accessible object following the given object or 
	free chunk in the heap. Return nil when heap is exhausted. */

static sqInt
accessibleObjectAfter(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt obj;
    sqInt sz;
    sqInt sz1;

	/* begin objectAfter: */
	if (DoAssertionChecks) {
		if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz1 = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header1 = longAt(oop);
		if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			goto l2;
		}
		else {
			sz1 = header1 & SizeMask;
			goto l2;
		}
	l2:	/* end sizeBitsOf: */;
	}
	obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			return obj;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	return null;
}


/*	Similar to activateNewMethod but for Closure and newMethod. */

static sqInt
activateNewClosureMethod(sqInt blockClosure)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureMethod;
    sqInt i;
    sqInt methodHeader;
    sqInt newContext;
    sqInt numCopied;
    sqInt oop;
    sqInt outerContext;
    sqInt theBlockClosure;
    sqInt tmp;
    sqInt where;

	if (DoAssertionChecks) {
		okayOop(blockClosure);
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (DoAssertionChecks) {
		okayOop(outerContext);
	}
	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(blockClosure));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = blockClosure;

	/* All for one, and one for all! */
	/* allocateOrRecycleContext: may cause a GC; restore blockClosure and refetch outerContext et al */

	newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	theBlockClosure = oop;
	outerContext = longAt((theBlockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	numCopied = (fetchWordLengthOf(theBlockClosure)) - ClosureFirstCopiedValueIndex;
	where = newContext + BaseHeaderSize;
	longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
	longAtput(where + (InstructionPointerIndex << ShiftForWord), longAt((theBlockClosure + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord)));
	longAtput(where + (StackPointerIndex << ShiftForWord), (((GIV(argumentCount) + numCopied) << 1) | 1));
	longAtput(where + (MethodIndex << ShiftForWord), longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord)));
	longAtput(where + (ClosureIndex << ShiftForWord), theBlockClosure);
	longAtput(where + (ReceiverIndex << ShiftForWord), longAt((outerContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	for (i = 1; i <= GIV(argumentCount); i += 1) {
		longAtput(where + ((ReceiverIndex + i) << ShiftForWord), longAt(GIV(stackPointer) - ((GIV(argumentCount) - i) * BytesPerWord)));
	}
	where = (newContext + BaseHeaderSize) + (((ReceiverIndex + 1) + GIV(argumentCount)) << ShiftForWord);
	for (i = 0; i <= (numCopied - 1); i += 1) {
		longAtput(where + (i << ShiftForWord), longAt((theBlockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord)));
	}
	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin newActiveContext: */
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if (newContext < GIV(youngStart)) {
		beRootIfOld(newContext);
	}
	GIV(activeContext) = newContext;
	/* begin fetchContextRegisters: */
	VM_LABEL(0fetchContextRegisters);
	tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = newContext;
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
}


/*	Add the given variable location to the extra roots table */

EXPORT(sqInt)
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */

static sqInt
addNewMethodToCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt probe;


	/* drop low-order zeros from addresses */

	hash = GIV(messageSelector) ^ GIV(lkupClass);
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void *) (primitiveTable[primitiveIndex]));
	for (p = 0; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = GIV(lkupClass);
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));
			return null;
		}
	}

	/* first probe */

	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = GIV(lkupClass);
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));
	for (p = 1; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

static sqInt
addressCouldBeObjWhileForwarding(sqInt address)
{
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= memory)
	 && ((((usqInt)address)) < GIV(freeBlock)));
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

sqInt
addressCouldBeObj(sqInt address)
{
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= memory)
	 && (((((usqInt)address)) < GIV(freeBlock))
	 && (((longAt(address)) & TypeMask) != HeaderTypeGC)));
}


/*	Answer if address appears to be that of either a SmallInteger or an
	object. For code disassembly and assertions. */

sqInt
addressCouldBeOop(sqInt address)
{
	return ((address & 1))
	 || (((address & 3) == 0)
	 && (((((usqInt)address)) >= memory)
	 && (((((usqInt)address)) < GIV(freeBlock))
	 && (((longAt(address)) & TypeMask) != HeaderTypeGC))));
}


/*	Return the int of the address of the (byteSize) slot at btyeOffset in
	rcvr. Usde for getting byte/word/int/float/double out of Byte/WordArrays
 */

static sqInt
addressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt rcvrSize;

	if (!(((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) >= 8))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	if (!(byteOffset > 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	rcvrSize = byteSizeOf(rcvr);
	if (!(((byteOffset + byteSize) - 1) <= rcvrSize)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	addr = oopForPointer(firstIndexableField(rcvr));
	addr = (addr + byteOffset) - 1;
	return addr;
}


/*	Adjust all oop references by the given number of bytes. This 
	is done just after reading in an image when the new base 
	address of the object heap is different from the base address 
	in the image. */
/*	di 11/18/2000 - return number of objects found */

static sqInt
adjustAllOopsBy(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt header;
    sqInt newClassOop;
    sqInt oop;
    sqInt sz;
    sqInt totalObjects;

	if (bytesToShift == 0) {
		return 300000;
	}
	totalObjects = 0;
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			totalObjects += 1;
			/* begin adjustFieldsAndClassOf:by: */
			if (bytesToShift == 0) {
				goto l1;
			}
			fieldAddr = oop + (lastPointerOf(oop));
			while ((((usqInt) fieldAddr)) > (((usqInt) oop))) {
				fieldOop = longAt(fieldAddr);
				if (!((fieldOop & 1))) {
					longAtput(fieldAddr, fieldOop + bytesToShift);
				}
				fieldAddr -= BytesPerWord;
			}
			if (((longAt(oop)) & TypeMask) != HeaderTypeShort) {

				/* adjust class header if not a compact class */

				classHeader = longAt(oop - BytesPerWord);
				newClassOop = (classHeader & AllButTypeMask) + bytesToShift;
				longAtput(oop - BytesPerWord, newClassOop | (classHeader & TypeMask));
			}
		l1:	/* end adjustFieldsAndClassOf:by: */;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return totalObjects;
}


/*	Return a recycled context or a newly allocated one if none is available
	for recycling.
 */

static sqInt
allocateOrRecycleContext(sqInt needsLarge)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cntxt;

	if (needsLarge == 0) {
		if (GIV(freeContexts) != NilContext) {
			cntxt = GIV(freeContexts);
			GIV(freeContexts) = longAt((cntxt + BaseHeaderSize) + (0 << ShiftForWord));
			return cntxt;
		}
	}
	else {
		if (GIV(freeLargeContexts) != NilContext) {
			cntxt = GIV(freeLargeContexts);
			GIV(freeLargeContexts) = longAt((cntxt + BaseHeaderSize) + (0 << ShiftForWord));
			return cntxt;
		}
	}
	if (needsLarge == 0) {
		cntxt = instantiateContextsizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMethodContext << ShiftForWord)), SmallContextSize);
	}
	else {
		cntxt = instantiateContextsizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMethodContext << ShiftForWord)), LargeContextSize);
	}
	longAtput((cntxt + BaseHeaderSize) + (4 << ShiftForWord), GIV(nilObj));
	return cntxt;
}


/*	Return true if all the oops in both arrays, and the arrays 
	themselves, are in the young object space. */

static sqInt
allYoungand(sqInt array1, sqInt array2)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt sp;
    sqInt sz;
    sqInt type;

	if ((((usqInt) array1)) < (((usqInt) GIV(youngStart)))) {
		return 0;
	}
	if ((((usqInt) array2)) < (((usqInt) GIV(youngStart)))) {
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if ((((usqInt) (longAt(array1 + fieldOffset)))) < (((usqInt) GIV(youngStart)))) {
			return 0;
		}
		if ((((usqInt) (longAt(array2 + fieldOffset)))) < (((usqInt) GIV(youngStart)))) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}

sqInt
argumentCountOf(sqInt methodPointer)
{
	return (((usqInt) (longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

void *
arrayValueOf(sqInt arrayOop)
{
	if (((arrayOop & 1) == 0)
	 && (((arrayOop & 1) == 0)
	 && (isWordsOrBytesNonInt(arrayOop)))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
}


/*	Returns an integer object */

static sqInt
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;

	/* begin assertClassOf:is: */
	VM_LABEL(2assertClassOfis);
	if ((characterObj & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(characterObj))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(characterObj - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassCharacter << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		return longAt((characterObj + BaseHeaderSize) + (CharacterValueIndex << ShiftForWord));
	}
	else {
		return ConstZero;
	}
}

sqInt
becomewith(sqInt array1, sqInt array2)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin become:with:twoWay:copyHash: */
	VM_LABEL(0becomewithtwoWaycopyHash);
	if (!(((array1 & 1) == 0)
		 && (((((usqInt) (longAt(array1))) >> 8) & 15) == 2))) {
		return 0;
	}
	if (!(((array2 & 1) == 0)
		 && (((((usqInt) (longAt(array2))) >> 8) & 15) == 2))) {
		return 0;
	}
	if (!((lastPointerOf(array1)) == (lastPointerOf(array2)))) {
		return 0;
	}
	if (1
	 || (1)) {
		if (!(containOnlyOopsand(array1, array2))) {
			return 0;
		}
	}
	else {
		if (!(containOnlyOops(array1))) {
			return 0;
		}
	}
	if (!(prepareForwardingTableForBecomingwithtwoWay(array1, array2, 1))) {
		return 0;
	}
	if (allYoungand(array1, array2)) {
		mapPointersInObjectsFromto(GIV(youngStart), GIV(endOfMemory));
	}
	else {
		mapPointersInObjectsFromto(memory, GIV(endOfMemory));
	}
	if (1) {
		restoreHeadersAfterBecomingwith(array1, array2);
	}
	else {
		restoreHeadersAfterForwardBecome(1);
	}
	initializeMemoryFirstFree(GIV(freeBlock));
	/* begin forceInterruptCheck */
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
	return 1;
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced with with pointers to the other. The arguments must be arrays
	of the same length. 
	Returns true if the primitive succeeds.
 */
/*	Implementation: Uses forwarding blocks to update references as done in
	compaction. 
 */

static sqInt
becomewithtwoWaycopyHashforceImmutables(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag, sqInt immutablesOk)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt start;

	if (!(((array1 & 1) == 0)
		 && (((((usqInt) (longAt(array1))) >> 8) & 15) == 2))) {
		return PrimErrBadReceiver;
	}
	if (!((((array2 & 1) == 0)
 && (((((usqInt) (longAt(array2))) >> 8) & 15) == 2))
		 && ((lastPointerOf(array1)) == (lastPointerOf(array2))))) {
		return PrimErrBadArgument;
	}
	if (!(containOnlyOopsand(array1, array2))) {
		PrimErrInappropriate;
	}
	if (!(immutablesOk)) {
		if (!(containOnlyMutableOopsand(array1, array2))) {
			return PrimErrNoModification;
		}
	}
	if (!(prepareForwardingTableForBecomingwithtwoWay(array1, array2, twoWayFlag))) {
		return PrimErrNoMemory;
	}
	if (allYoungand(array1, array2)) {

		/* sweep only the young objects plus the roots */

		start = GIV(youngStart);
	}
	else {

		/* sweep all objects */

		start = memory;
	}
	if (!(immutablesOk)) {
		if (existImmutableReferencesToForwardedInRangeFromto(start, GIV(endOfMemory))) {
			if (twoWayFlag) {
				restoreHeadersAfterBecomingwith(array1, array2);
			}
			else {
				restoreHeadersAfterForwardBecome(copyHashFlag);
			}
			return PrimErrNoModification;
		}
	}
	mapPointersInObjectsFromto(start, GIV(endOfMemory));
	if (twoWayFlag) {
		restoreHeadersAfterBecomingwith(array1, array2);
	}
	else {
		restoreHeadersAfterForwardBecome(copyHashFlag);
	}
	initializeMemoryFirstFree(GIV(freeBlock));
	/* begin forceInterruptCheck */
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
	return PrimNoErr;
}


/*	If this object is old, mark it as a root (because a new object 
	may be stored into it) */

void
beRootIfOld(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
	 && (!((oop & 1)))) {
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if ((header & RootBit) == 0) {
			if (GIV(rootTableCount) < RootTableRedZone) {

				/* record oop as root only if not already recorded */
				/* record root if there is enough room in the roots 
					table  */

				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
			}
			else {
				if (GIV(rootTableCount) < RootTableSize) {

					/* we're getting in the red zone */
					/* but there's still space to record it */

					GIV(rootTableCount) += 1;
					GIV(rootTable)[GIV(rootTableCount)] = oop;
					longAtput(oop, header | RootBit);
					GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
				}
			}
		}
	}
}


/*	convert true and false (Smalltalk) to true or false(C) */

sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	return null;
}


/*	Return the number of indexable bytes in the given object. This is
	basically a special copy of lengthOf: for BitBlt.
 */

static sqInt
byteLengthOf(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? ((longAt(oop - (BytesPerWord * 2))) & AllButTypeMask)
		: (header & SizeMask));
	fmt = (((usqInt) header) >> 8) & 15;
	return (fmt < 8
		? (sz - BaseHeaderSize)
		: ((sz - BaseHeaderSize) - (fmt & 3)));
}

sqInt
byteSizeOf(sqInt oop)
{
    sqInt format;
    sqInt header;
    sqInt size;

	if ((oop & 1)) {
		return 0;
	}
	header = longAt(oop);
	format = (((usqInt) header) >> 8) & 15;
	size = ((header & TypeMask) == HeaderTypeSizeAndClass
		? ((longAt(oop - (BytesPerWord * 2))) & LongSizeMask)
		: (header & SizeMask));
	size -= header & Size4Bit;
	return (format < 8
		? (size - BaseHeaderSize)
		: ((size - BaseHeaderSize) - (format & 3)));
}


/*	Byte-swap the words of all bytes objects in a range of the 
	image, including Strings, ByteArrays, and CompiledMethods. 
	This returns these objects to their original byte ordering 
	after blindly byte-swapping the entire image. For compiled 
	methods, byte-swap only their bytecodes part. */

static sqInt
byteSwapByteObjectsFromto(sqInt startOop, sqInt stopAddr)
{
    sqInt addr;
    sqInt addr1;
    sqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt oop;
    sqInt stopAddr1;
    sqInt stopAddr2;
    sqInt sz;
    sqInt wordAddr;

	oop = startOop;
	while ((((usqInt) oop)) < (((usqInt) stopAddr))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
			if (fmt >= 8) {

				/* oop contains bytes */

				wordAddr = oop + BaseHeaderSize;
				if (fmt >= 12) {

					/* compiled method; start after methodHeader and literals */

					methodHeader = longAt(oop + BaseHeaderSize);
					wordAddr = (wordAddr + BytesPerWord) + (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord);
				}
				/* begin reverseBytesFrom:to: */
				stopAddr1 = oop + (sizeBitsOf(oop));
				flag("Dan");
				addr = wordAddr;
				while ((((usqInt) addr)) < (((usqInt) stopAddr1))) {
					longAtput(addr, byteSwapped(longAt(addr)));
					addr += BytesPerWord;
				}
			}
			if ((fmt == 6)
			 && (BytesPerWord == 8)) {

				/* Object contains 32-bit half-words packed into 64-bit machine words. */

				wordAddr = oop + BaseHeaderSize;
				/* begin reverseWordsFrom:to: */
				stopAddr2 = oop + (sizeBitsOf(oop));
				addr1 = wordAddr;
				while ((((usqInt) addr1)) < (((usqInt) stopAddr2))) {
					longAtput(addr1, wordSwapped(longAt(addr1)));
					addr1 += BytesPerWord;
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	Answer the given integer with its bytes in the reverse order. */

sqInt
byteSwapped(sqInt w)
{
	
#  if BytesPerWord == 4
	return ((((((usqInt) w >> 24)) & Byte0Mask) + ((((usqInt) w >> 8)) & Byte1Mask)) + ((((usqInt) w << 8)) & Byte2Mask)) + ((((usqInt) w << 24)) & Byte3Mask);

#  else /* BytesPerWord == 4 */
	return ((((((((((usqInt) w << 0)) & Byte0Mask) + ((((usqInt) w << 0)) & Byte1Mask)) + ((((usqInt) w >> 24)) & Byte2Mask)) + ((((usqInt) w >> 8)) & Byte3Mask)) + ((((usqInt) w << 8)) & Byte4Mask)) + ((((usqInt) w << 24)) & Byte5Mask)) + ((((usqInt) w << 0)) & Byte6Mask)) + ((((usqInt) w << 0)) & Byte7Mask);

#  endif /* BytesPerWord == 4 */

}


/*	Call the external plugin function identified. In the VM this is an
	address; see NewspeakInterpreterSimulator for its version. */

static sqInt
callExternalPrimitive(void (*functionID)())
{
	dispatchFunctionPointer(functionID);
}


/*	Attempt to change the class of the receiver into the class of the the
	argument given that the
	format of the receiver matches the format of the argument. If successful
	answer 0, otherwise
	answer an error code indicating the reason for failure. Fail if receiver
	or argument are
	SmallIntegers, or the receiver is an instance of a compact class and the
	argument isn't, or when
	the format of the receiver is different from the format of the argument's
	class, or when the
	arguments class is fixed and the receiver's size differs from the size
	that an instance of the
	argument's class should have. */
/*	Check what the format of the class says */

static sqInt
changeClassOfto(sqInt rcvr, sqInt argClass)
{
    sqInt argFormat;
    sqInt byteSize;
    sqInt ccIndex;
    sqInt classHdr;
    sqInt rcvrFormat;
    sqInt rcvrHdr;
    sqInt sizeHiBits;


	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((argClass + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	sizeHiBits = ((usqInt) (classHdr & 393216)) >> 9;
	classHdr = classHdr & 131071;

	/* size in bytes -- low 2 bits are 0 */
	/* Check the receiver's format against that of the class */

	byteSize = (classHdr & SizeMask) + sizeHiBits;
	argFormat = (((usqInt) classHdr) >> 8) & 15;
	rcvrHdr = longAt(rcvr);

	/* If the receiver is a byte object we need to clear the number of odd bytes from the format. */

	rcvrFormat = (((usqInt) rcvrHdr) >> 8) & 15;
	if (rcvrFormat > 8) {
		rcvrFormat = rcvrFormat & 12;
	}
	if (!(argFormat == rcvrFormat)) {
		return PrimErrInappropriate;
	}
	if (argFormat < 2) {
		if ((byteSize - BaseHeaderSize) != (byteSizeOf(rcvr))) {
			return PrimErrBadReceiver;
		}
	}
	else {
		if (argFormat == 3) {
			if ((byteSize - BaseHeaderSize) > (byteSizeOf(rcvr))) {
				return PrimErrBadReceiver;
			}
		}
	}
	if ((rcvrHdr & TypeMask) == HeaderTypeShort) {

		/* Compact classes. Check if the arg's class is compact and exchange ccIndex */

		ccIndex = classHdr & CompactClassMask;
		if (ccIndex == 0) {
			return PrimErrInappropriate;
		}
		
#    if IMMUTABILITY
		if ((rcvrHdr & ImmutabilityBit) != 0) {
			return PrimErrNoModification;
		}

#    endif /* IMMUTABILITY */

		longAtput(rcvr, ((longAt(rcvr)) & (~CompactClassMask)) | ccIndex);
	}
	else {
		
#    if IMMUTABILITY
		if ((rcvrHdr & ImmutabilityBit) != 0) {
			return PrimErrNoModification;
		}

#    endif /* IMMUTABILITY */

		longAtput(rcvr - BaseHeaderSize, argClass | ((longAt(rcvr)) & TypeMask));
		if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(rcvr, argClass);
		}
	}
	return 0;
}


/*	Arg must lie in range 0-255! */

sqInt
characterForAscii(sqInt ascii)
{
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + (ascii << ShiftForWord));
}

sqInt
characterTable(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord));
}


/*	Note: May be called by translated primitive code. */

sqInt
checkedIntegerValueOf(sqInt intOop)
{
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0;
	}
}


/*	Assumes zero-based array indexing. For testing in Smalltalk, this method
	should be overridden in a subclass.
 */

sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkAddress: */
	if ((((usqInt) byteAddress)) < (((usqInt) memory))) {
		error("bad address: negative");
	}
	if ((((usqInt) byteAddress)) >= (((usqInt) GIV(memoryLimit)))) {
		error("bad address: past end of heap");
	}
	/* begin checkAddress: */
	if ((((usqInt) (byteAddress + 3))) < (((usqInt) memory))) {
		error("bad address: negative");
	}
	if ((((usqInt) (byteAddress + 3))) >= (((usqInt) GIV(memoryLimit)))) {
		error("bad address: past end of heap");
	}
	return longAt(byteAddress);
}


/*	Check for possible interrupts and handle one if necessary. */

static sqInt
checkForInterrupts(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt now;
    sqInt sema;
    sqInt thisLastTick;
    sqInt xArray;


	/* Mask so same wrapping as primitiveMillisecondClock */

	now = (ioMSecs()) & MillisecondClockMask;
	thisLastTick = GIV(lastTick);
	if (!(GIV(interruptCheckCounter) < -100)) {
		if ((now - GIV(lastTick)) < GIV(interruptChecksEveryNms)) {

			/* don't play with the feedback if we forced a check. It only makes life difficult */
			/* wrapping is not a concern, it'll get caught quickly  
				enough. This clause is trying to keep a reasonable  
				guess of how many times per 	interruptChecksEveryNms we are calling  
				quickCheckForInterrupts. Not sure how effective it really is. */

			GIV(interruptCheckCounterFeedBackReset) += 10;
		}
		else {
			if (GIV(interruptCheckCounterFeedBackReset) <= 1000) {
				GIV(interruptCheckCounterFeedBackReset) = 1000;
			}
			else {
				GIV(interruptCheckCounterFeedBackReset) -= 12;
			}
		}
	}
	GIV(interruptCheckCounter) = GIV(interruptCheckCounterFeedBackReset);
	if (GIV(signalLowSpace)) {

		/* reset flag */

		GIV(signalLowSpace) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheLowSpaceSemaphore << ShiftForWord));
		if (!(sema == GIV(nilObj))) {
			synchronousSignal(sema);
		}
	}
	if (now < GIV(lastTick)) {

		/* millisecond clock wrapped so correct the nextPollTick */

		GIV(nextPollTick) = (GIV(nextPollTick) - MillisecondClockMask) - 1;
	}
	if (0) {
		if ((now >= GIV(nextPollTick))
		 && (inIOProcessEvents == 0)) {
			inIOProcessEvents += 1;
			ioProcessEvents();
			if (inIOProcessEvents > 0) {
				inIOProcessEvents -= 1;
			}

			/* msecs to wait before next call to ioProcessEvents.  
				Note that strictly speaking we might need to update  
				'now' at this point since ioProcessEvents could take a  
				very long time on some platforms */

			GIV(nextPollTick) = now + 200;
		}
	}
	else {
		if (now >= GIV(nextPollTick)) {
			ioProcessEvents();

			/* msecs to wait before next call to ioProcessEvents.  
				 Note that strictly speaking we might need to update  
				 'now' at this point since ioProcessEvents could take a  
				 very long time on some platforms */

			GIV(nextPollTick) = now + 200;
		}
	}
	if (GIV(interruptPending)) {

		/* reset interrupt flag */

		GIV(interruptPending) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInterruptSemaphore << ShiftForWord));
		if (!(sema == GIV(nilObj))) {
			synchronousSignal(sema);
		}
	}
	if (GIV(nextWakeupTick) != 0) {
		if (now < GIV(lastTick)) {

			/* the clock has wrapped. Subtract the wrap  
					interval from nextWakeupTick - this might just  
					possibly result in 0. Since this is used as a flag  
					value for 'no timer' we do the 0 check above */

			GIV(nextWakeupTick) = (GIV(nextWakeupTick) - MillisecondClockMask) - 1;
		}
		if (now >= GIV(nextWakeupTick)) {

			/* set timer interrupt to 0 for 'no timer' */

			GIV(nextWakeupTick) = 0;
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord));
			if (!(sema == GIV(nilObj))) {
				synchronousSignal(sema);
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheFinalizationSemaphore << ShiftForWord));
		if ((fetchClassOf(sema)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
			synchronousSignal(sema);
		}
		GIV(pendingFinalizationSignals) = 0;
	}
	/* begin signalExternalSemaphores */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ExternalObjectsArray << ShiftForWord));
	doSignalExternalSemaphores(stSizeOf(xArray));
	if (GIV(lastTick) == thisLastTick) {
		GIV(lastTick) = now;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rootTable, remapBuffer and
	extraRootTable checking that every entry is a pointer to a header.
	Check that the number of roots is correct and that all rootTable
	entries have their rootBit set. Answer if all checks pass. */

static sqInt
checkHeapIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fi;
    sqInt fieldOop;
    sqInt fmt;
    sqInt hdr;
    sqInt header;
    sqInt header1;
    sqInt numRootsInHeap;
    sqInt obj;
    sqInt ok;
    sqInt ri;
    sqInt sz;
    sqInt sz1;

	ok = 1;
	numRootsInHeap = 0;
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(freeBlock)))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			hdr = longAt(obj);
			if ((hdr & RootBit) != 0) {
				numRootsInHeap += 1;
			}
			if (((((usqInt) hdr) >> 12) & 31) == 0) {
				fieldOop = (longAt(obj - BaseHeaderSize)) & AllButTypeMask;
				if (((fieldOop & 1))
				 || ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
					print("object leak in ");
					printHex(obj);
					print(" class ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			fmt = (((usqInt) hdr) >> 8) & 15;
			if ((fmt <= 4)
			 || (fmt >= 12)) {
				if (fmt >= 12) {

					/* + 1 = methodHeader slot */

					fi = ((((usqInt) (longAt((obj + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) + 1;
				}
				else {
					if ((fmt == 3)
					 && ((((((usqInt) hdr) >> 12) & 31) == 13)
					 || (((((usqInt) hdr) >> 12) & 31) == 14))) {
						fi = CtxtTempFrameStart + (fetchStackPointerOf(obj));
					}
					else {
						/* begin lengthOf: */
						header = longAt(obj);
						/* begin lengthOf:baseHeader:format: */
						if ((header & TypeMask) == HeaderTypeSizeAndClass) {
							sz1 = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
						}
						else {
							sz1 = header & SizeMask;
						}
						sz1 -= header & Size4Bit;
						if (((((usqInt) header) >> 8) & 15) <= 4) {
							fi = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
							goto l1;
						}
						if (((((usqInt) header) >> 8) & 15) < 8) {
							fi = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
							goto l1;
						}
						else {
							fi = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
							goto l1;
						}
					l1:	/* end lengthOf: */;
					}
				}
				while (((fi -= 1)) >= 0) {
					fieldOop = longAt((obj + BaseHeaderSize) + (fi << ShiftForWord));
					if ((fieldOop & 1) == 0) {
						if ((fieldOop & (BytesPerWord - 1)) != 0) {
							print("misaligned oop in ");
							printHex(obj);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
						else {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(obj);
								print(" @ ");
								printNum(fi);
								/* begin cr */
								printf("\n");
								ok = 0;
							}
						}
					}
				}
			}
			/* begin sizeBitsOf: */
			header1 = longAt(obj);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header1 & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	if (numRootsInHeap != GIV(rootTableCount)) {
		print("root count mismatch. #heap roots ");
		printNum(numRootsInHeap);
		print("; #roots ");
		printNum(GIV(rootTableCount));
		/* begin cr */
		printf("\n");
		ok = 0;
	}
	for (ri = 1; ri <= GIV(rootTableCount); ri += 1) {
		obj = GIV(rootTable)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned oop in rootTable @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in rootTable @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			else {
				hdr = longAt(obj);
				if ((hdr & RootBit) == 0) {
					print("non-root in rootTable @ ");
					printNum(ri);
					print(" = ");
					printHex(obj);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
		}
	}
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	return ok;
}

sqInt
classAlien(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord));
}

sqInt
classArray(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord));
}

sqInt
classBitmap(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBitmap << ShiftForWord));
}

sqInt
classByteArray(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteArray << ShiftForWord));
}

sqInt
classCharacter(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassCharacter << ShiftForWord));
}

sqInt
classExternalAddress(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalAddress << ShiftForWord));
}

sqInt
classExternalData(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalData << ShiftForWord));
}

sqInt
classExternalFunction(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalFunction << ShiftForWord));
}

sqInt
classExternalLibrary(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalLibrary << ShiftForWord));
}

sqInt
classExternalStructure(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassExternalStructure << ShiftForWord));
}

sqInt
classFloat(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord));
}

sqInt
classLargeNegativeInteger(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord));
}

sqInt
classLargePositiveInteger(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord));
}


/*	Check if aClass's name is className */

static sqInt
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOf(aClass)) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord));
	if (!(((name & 1) == 0)
		 && (((((usqInt) (longAt(name))) >> 8) & 15) >= 8))) {
		return 0;
	}
	length = stSizeOf(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i <= (length - 1); i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}

sqInt
classPoint(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord));
}

sqInt
classSemaphore(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord));
}

sqInt
classSmallInteger(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
}

sqInt
classString(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord));
}

sqInt
classUnsafeAlien(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassUnsafeAlien << ShiftForWord));
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

static void
clearLeakMapAndMapAccessibleObjects(void)
{
    sqInt oop;

	clearHeapMap();
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while (!(oop == null)) {
		heapMapAtWordPut(pointerForOop(oop), 1);
		oop = accessibleObjectAfter(oop);
	}
}


/*	Return a shallow copy of the given object. May cause GC */
/*	Assume: Oop is a real object, not a small integer. */

sqInt
clone(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;
    sqInt chunk;
    sqInt currentProc;
    sqInt enoughSpace;
    sqInt extraHdrBytes;
    usqInt fromIndex;
    sqInt hash;
    sqInt header;
    sqInt header1;
    usqInt lastFrom;
    sqInt lastSavedProcess;
    sqInt minFree;
    sqInt newChunk;
    sqInt newChunk1;
    sqInt newFreeSize;
    sqInt newOop;
    sqInt oop1;
    sqInt oop2;
    sqInt remappedOop;
    sqInt toIndex;

	extraHdrBytes = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header1 = longAt(oop);
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		bytes = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		bytes = header1 & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;

	/* allocate space for the copy, remapping oop in case of a GC */

	bytes += extraHdrBytes;
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(sufficientSpaceToAllocate(2500 + bytes))) {
		return 0;
	}
	/* begin allocateChunk: */
	VM_LABEL(0allocateChunk);
	if (GIV(allocationCount) >= GIV(allocationsBetweenGCs)) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */

	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
		enoughSpace = 1;
		goto l2;
	}
	else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l2;
	}
l2:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {

		/* signal that space is running low, but proceed with allocation if possible */

		GIV(signalLowSpace) = 1;

		/* disable additional interrupts until lowSpaceThreshold is reset by image */

		GIV(lowSpaceThreshold) = 0;
		/* begin saveProcessSignalingLowSpace */
		VM_LABEL(0saveProcessSignalingLowSpace);
		lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord));
		if (lastSavedProcess == GIV(nilObj)) {
			currentProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			oop2 = GIV(specialObjectsOop);
			if ((((usqInt) oop2)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop2, currentProc);
			}
			longAtput((oop2 + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord), currentProc);
		}
		/* begin forceInterruptCheck */
		GIV(interruptCheckCounter) = -1000;
		GIV(nextPollTick) = 0;
	}
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) < (((usqInt) (bytes + BaseHeaderSize)))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(GIV(freeBlock))) & AllButTypeMask) - bytes;
	newChunk1 = GIV(freeBlock);

	/* Assume: client will initialize object header of free chunk, so following is not needed: */
	/* self setSizeOfFree: newChunk to: byteSize. */

	GIV(freeBlock) += bytes;
	/* begin setSizeOfFree:to: */
	chunk = GIV(freeBlock);
	longAtput(chunk, (newFreeSize & AllButTypeMask) | HeaderTypeFree);
	GIV(allocationCount) += 1;
	newChunk = newChunk1;
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	remappedOop = oop1;

	/* loop below uses pre-increment */

	toIndex = newChunk - BytesPerWord;
	fromIndex = (remappedOop - extraHdrBytes) - BytesPerWord;
	lastFrom = fromIndex + bytes;
	while (fromIndex < lastFrom) {
		longAtput((toIndex += BytesPerWord), longAt((fromIndex += BytesPerWord)));
	}

	/* convert from chunk to oop */
	/* fix base header: compute new hash and clear Mark and Root bits */

	newOop = newChunk + extraHdrBytes;
	/* begin newObjectHash */
	GIV(lastHash) = (13849 + (27181 * GIV(lastHash))) & 65535;
	hash = GIV(lastHash);

	/* use old ccIndex, format, size, and header-type fields */

	header = (longAt(newOop)) & 131071;
	header = header | ((hash << HashBitsOffset) & HashBits);
	longAtput(newOop, header);
	return newOop;
}


/*	This code is called if the receiver responds primitively to at:Put:.
	If this is so, it will be installed in the atPutCache so that subsequent
	calls of at:
	or next may be handled immediately in bytecode primitive routines. */

static sqInt
commonAtPut(sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atIx;
    sqInt fixedFields;
    sqInt fmt;
    sqInt index;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt valToPut;
    sqInt value;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l1;
	}
	rcvr = oop;
l1:	/* end stackObjectValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	index = positive32BitValueOf(longAt(GIV(stackPointer) - (1 * BytesPerWord)));
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}

	/* NOTE:  The atPut-cache, since it is specific to the non-super response to #at:Put:.
	Therefore we must determine that the message is #at:Put: (not, eg, #basicAt:Put:),
	and that the send is not a super-send, before using the at-cache. */

	value = longAt(GIV(stackPointer));
	if ((GIV(messageSelector) == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord))))
	 && (GIV(lkupClass) == (fetchClassOfNonInt(rcvr)))) {

		/* OK -- look in the at-cache */
		/* Index into atPutCache */

		atIx = (rcvr & AtCacheMask) + AtPutBase;
		if (!((GIV(atCache)[atIx + AtCacheOop]) == rcvr)) {
			installinAtCacheatstring(rcvr, GIV(atCache), atIx, stringy);
		}
		if (!GIV(primFailCode)) {
			/* begin commonVariable:at:put:cacheIndex: */
			VM_LABEL(1commonVariableatputcacheIndex);
			stSize = GIV(atCache)[atIx + AtCacheSize];
			if (((((usqInt ) index)) >= 1)
			 && ((((usqInt ) index)) <= (((usqInt ) stSize)))) {
				fmt = GIV(atCache)[atIx + AtCacheFmt];
				if (fmt <= 4) {
					fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
					/* begin storePointer:ofObject:withValue: */
					if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
						possibleRootStoreIntovalue(rcvr, value);
					}
					longAtput((rcvr + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord), value);
					goto l2;
				}
				if (fmt < 8) {

					/* Bitmap */

					valToPut = positive32BitValueOf(value);
					if (!GIV(primFailCode)) {
						long32Atput((rcvr + BaseHeaderSize) + ((index - 1) << 2), valToPut);
						goto l2;
					}
					/* begin primitiveFailFor: */
					GIV(primFailCode) = PrimErrBadArgument;
					goto l2;
				}
				if (fmt >= 16) {

					/* Note fmt >= 16 is an artificial flag for strings */

					valToPut = asciiOfCharacter(value);
					if (!(!GIV(primFailCode))) {
						/* begin primitiveFailFor: */
						GIV(primFailCode) = PrimErrBadArgument;
						goto l2;
					}
				}
				else {
					valToPut = value;
				}
				if ((valToPut & 1)) {
					valToPut = (valToPut >> 1);
					if (!((valToPut >= 0)
						 && (valToPut <= 255))) {
						/* begin primitiveFailFor: */
						GIV(primFailCode) = PrimErrBadArgument;
						goto l2;
					}
					byteAtput((rcvr + BaseHeaderSize) + (index - 1), valToPut);
					goto l2;
				}
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrInappropriate;
				goto l2;
			}
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
		l2:	/* end commonVariable:at:put:cacheIndex: */;
		}
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
			return null;
		}
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	if (stringy) {
		stObjectatput(rcvr, index, asciiOfCharacter(value));
	}
	else {
		stObjectatput(rcvr, index, value);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp1;
		return null;
	}
}


/*	This code is called if the receiver responds primitively to at:.
	If this is so, it will be installed in the atCache so that subsequent
	calls of at:
	or next may be handled immediately in bytecode primitive routines.
 */

static sqInt
commonAt(sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atIx;
    sqInt index;
    sqInt oop;
    sqInt rcvr;
    sqInt result;
    sqInt sp;
    sqInt sp1;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l1;
	}
	rcvr = oop;
l1:	/* end stackObjectValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	index = positive32BitValueOf(longAt(GIV(stackPointer)));
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	if ((GIV(messageSelector) == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord))))
	 && (GIV(lkupClass) == (fetchClassOfNonInt(rcvr)))) {

		/* OK -- look in the at-cache */
		/* Index into atCache = 4N, for N = 0 ... 7 */

		atIx = rcvr & AtCacheMask;
		if (!((GIV(atCache)[atIx + AtCacheOop]) == rcvr)) {
			installinAtCacheatstring(rcvr, GIV(atCache), atIx, stringy);
		}
		if (!GIV(primFailCode)) {
			result = commonVariableatcacheIndex(rcvr, index, atIx);
		}
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
			GIV(stackPointer) = sp;
			return null;
		}
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	result = stObjectat(rcvr, index);
	if (!GIV(primFailCode)) {
		if (stringy) {
			result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + (((result >> 1)) << ShiftForWord));
		}
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return null;
	}
}


/*	This code assumes the receiver has been identified at location atIx in the
	atCache. 
 */

static sqInt
commonVariableatcacheIndex(sqInt rcvr, sqInt index, sqInt atIx)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fixedFields;
    sqInt fmt;
    sqInt result;
    sqInt stSize;

	stSize = GIV(atCache)[atIx + AtCacheSize];
	if (((((usqInt ) index)) >= 1)
	 && ((((usqInt ) index)) <= (((usqInt ) stSize)))) {
		fmt = GIV(atCache)[atIx + AtCacheFmt];
		if (fmt <= 4) {
			fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
			return longAt((rcvr + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord));
		}
		if (fmt < 8) {

			/* Bitmap */

			result = long32At((rcvr + BaseHeaderSize) + ((index - 1) << 2));
			result = positive32BitIntegerFor(result);
			return result;
		}
		if (fmt >= 16) {
			return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CharacterTable << ShiftForWord))) + BaseHeaderSize) + ((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << ShiftForWord));
		}
		else {
			return (((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 1) | 1);
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadIndex;
}


/*	Index must be between 1 and compactClassArray size. (A zero compact class
	index in the base header indicate that the class is in the class header
	word.) 
 */

sqInt
compactClassAt(sqInt ccIndex)
{
    sqInt classArray;

	classArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord));
	return longAt((classArray + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
}

sqInt
compactClassIndexOfHeader(sqInt header)
{
	return (((usqInt) header) >> 12) & 31;
}


/*	May set success to false */
/*	First compare two ST integers... */

static sqInt
compare31or32Bitsequal(sqInt obj1, sqInt obj2)
{
	if (((obj1 & 1))
	 && ((obj2 & 1))) {
		return obj1 == obj2;
	}
	return (positive32BitValueOf(obj1)) == (positive32BitValueOf(obj2));
}


/*	Return true if neither array contains an immutable.
	You may not be allowed to become: immutables. */

static sqInt
containOnlyMutableOopsand(sqInt array1, sqInt array2)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt sp;
    sqInt sz;
    sqInt type;

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(longAt(array1 + fieldOffset))) & ImmutabilityBit) != 0) {
			return 0;
		}
		if (((longAt(longAt(array2 + fieldOffset))) & ImmutabilityBit) != 0) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}


/*	Return true if the array contains a small integer. You 
	can't become: SmallIntegers! */

static sqInt
containOnlyOops(sqInt array)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt sp;
    sqInt sz;
    sqInt type;

	/* begin lastPointerOf: */
	header = longAt(array);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array + BaseHeaderSize);
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(array + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}


/*	Return true if neither array contains a small integer. You 
	can't become: integers! */

static sqInt
containOnlyOopsand(sqInt array1, sqInt array2)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt sp;
    sqInt sz;
    sqInt type;

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(array1 + fieldOffset)) & 1)) {
			return 0;
		}
		if (((longAt(array2 + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}


/*	Does thisCntx have aContext in its sender chain? */

static sqInt
contexthasSender(sqInt thisCntx, sqInt aContext)
{
    sqInt nilOop;
    sqInt s;

	if (thisCntx == aContext) {
		return 0;
	}
	nilOop = GIV(nilObj);
	s = longAt((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	while (!(s == nilOop)) {
		if (s == aContext) {
			return 1;
		}
		s = longAt((s + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
	return 0;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

sqInt
copyBits(void)
{
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}


/*	Copy this object into the segment beginning at lastSeg.
	Install a forwarding pointer, and save oop and header.
	Fail if out of space. Return the next segmentAddr if successful. */
/*	Copy the object... */

static sqInt
copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr)
{
    sqInt bodySize;
    sqInt extraSize;
    sqInt hdrAddr;
    sqInt header;
    sqInt in;
    sqInt lastIn;
    sqInt out;

	flag("Dan");
	extraSize = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header = longAt(oop);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		bodySize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		bodySize = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	if ((((usqInt) ((lastSeg + extraSize) + bodySize))) >= (((usqInt) stopAddr))) {
		return 0;
	}
	/* begin transfer:from:to: */
	flag("Dan");
	in = (oop - extraSize) - BytesPerWord;
	lastIn = in + ((((sqInt) (extraSize + bodySize) >> 2)) * BytesPerWord);
	out = (lastSeg + BytesPerWord) - BytesPerWord;
	while ((((usqInt) in)) < (((usqInt) lastIn))) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	hdrAddr = (lastSeg + BytesPerWord) + extraSize;
	longAtput(hdrAddr, (longAt(hdrAddr)) & (AllButRootBit - MarkBit));
	/* begin forward:to:savingOopAt:andHeaderAt: */
	longAtput(oopPtr, oop);
	longAtput(hdrPtr, longAt(oop));
	longAtput(oop, (((lastSeg + BytesPerWord) + extraSize) - segmentWordArray) + HeaderTypeFree);
	return (lastSeg + extraSize) + bodySize;
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

static sqInt
cr(void)
{
	printf("\n");
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand:.
 */
/*	remap lookupClass in case GC happens during allocation */

static sqInt
createActualMessageTo(sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt in;
    sqInt lastIn;
    sqInt lookupClass;
    sqInt message;
    sqInt oop;
    sqInt oop1;
    sqInt out;
    sqInt sp;

	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(aClass));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = aClass;

	/* remap argumentArray in case GC happens during allocation */

	argumentArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), GIV(argumentCount));
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(argumentArray));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = argumentArray;
	message = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMessage << ShiftForWord)), 0);
	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	argumentArray = oop;
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	lookupClass = oop1;
	beRootIfOld(argumentArray);
	/* begin transfer:from:to: */
	flag("Dan");
	in = (GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord)) - BytesPerWord;
	lastIn = in + (GIV(argumentCount) * BytesPerWord);
	out = (argumentArray + BaseHeaderSize) - BytesPerWord;
	while ((((usqInt) in)) < (((usqInt) lastIn))) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord)), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
	longAtput((message + BaseHeaderSize) + (MessageSelectorIndex << ShiftForWord), GIV(messageSelector));
	longAtput((message + BaseHeaderSize) + (MessageArgumentsIndex << ShiftForWord), argumentArray);
	longAtput((message + BaseHeaderSize) + (MessageLookupClassIndex << ShiftForWord), lookupClass);
}


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    char *cString;
    sqInt header;
    sqInt isString;
    sqInt len;
    sqInt sz;

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	isString = (ClassByteStringCompactIndex == 0
		? ((ccIndex == 0
	? (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << ShiftForWord))))
	: (0)))
		: (ClassByteStringCompactIndex == ccIndex));
	if (!(isString)) {
		if (oop != GIV(nilObj)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		len = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		len = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		len = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	This version answers the value of a float or nil if not a flat *WITHOUT*
	setting successFlag or any other such nonsense. It is hence safe for use
	in debug printing. Sheesh. */

static double
dbgFloatValueOf(sqInt oop)
{
    double result;

	flag("Dan");
	if (((oop & 1) == 0)
	 && ((fetchClassOfNonInt(oop)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	return null;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

static sqInt
displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt d;
    sqInt dispBits;
    sqInt dispBitsIndex;
    sqInt displayObj;
    sqInt h;
    sqInt left;
    sqInt right;
    sqInt successBoolean;
    sqInt surfaceHandle;
    sqInt top;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
	if (!(aForm == displayObj)) {
		return null;
	}
	/* begin success: */
	successBoolean = (((displayObj & 1) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(displayObj)) >= 4);
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		dispBits = longAt((displayObj + BaseHeaderSize) + (0 << ShiftForWord));
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		d = fetchIntegerofObject(3, displayObj);
	}
	if (l < 0) {
		left = 0;
	}
	else {
		left = l;
	}
	if (r > w) {
		right = w;
	}
	else {
		right = r;
	}
	if (t < 0) {
		top = 0;
	}
	else {
		top = t;
	}
	if (b > h) {
		bottom = h;
	}
	else {
		bottom = b;
	}
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (!GIV(primFailCode)) {
		if ((dispBits & 1)) {
			surfaceHandle = (dispBits >> 1);
			if (showSurfaceFn == 0) {
				showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
				if (showSurfaceFn == 0) {
					/* begin success: */
					if (!(0)) {
						if (!GIV(primFailCode)) {

							/* Don't overwrite an error code that has already been set. */

							GIV(primFailCode) = 1;
						}
					}
					return null;
				}
			}
			((sqInt (*)(sqInt, sqInt, sqInt, sqInt, sqInt))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top);
		}
		else {

			/* index in memory byte array */

			dispBitsIndex = dispBits + BaseHeaderSize;
			ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom);
		}
	}
}

sqInt
displayObject(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
}


/*	Rounds negative results towards negative infinity, rather than zero. */

static sqInt
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	if (!(!GIV(primFailCode))) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */

			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */

			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	if (!((result ^ (result << 1)) >= 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	return result;
}

static sqInt
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	if (!(!GIV(primFailCode))) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */

	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	if (!((integerResult ^ (integerResult << 1)) >= 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    sqInt semaphoreClass;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ExternalObjectsArray << ShiftForWord));
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord));

	/* Note: semaphore indices are 1-based */

	sema = longAt((xArray + BaseHeaderSize) + ((index - 1) << ShiftForWord));
	return ((sema & 1) == 0)
	 && (((fetchClassOfNonInt(sema)) == semaphoreClass)
	 && (synchronousSignal(sema)));
}

static sqInt
dummyReferToProxy(void)
{
	interpreterProxy = interpreterProxy;
}


/*	The prim trace log is a circular buffer of entries. If there is
	an entry at primTraceLogIndex \\ PrimTraceLogSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

sqInt
dumpPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;

	if ((GIV(primTraceLog)[(((remainder = (GIV(primTraceLogIndex) - 1) % TraceLogSize)) < 0
		? (remainder + TraceLogSize)
		: (remainder))]) == 0) {
		return null;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i <= (TraceLogSize - 1); i += 1) {
			safePrintStringOf(GIV(primTraceLog)[i]);
			/* begin cr */
			printf("\n");
		}
	}
	for (i = 0; i <= (GIV(primTraceLogIndex) - 1); i += 1) {
		safePrintStringOf(GIV(primTraceLog)[i]);
		/* begin cr */
		printf("\n");
	}
}


/*	The send trace log is a circular buffer of entries. If there is
	an entry at sendTraceLogIndex \\ PrimTraceLogSize it has entries.
	If there is something at sendTraceLogIndex it has wrapped. */

sqInt
dumpSendTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt remainder;

	if ((GIV(sendTraceLog)[(((remainder = (GIV(sendTraceLogIndex) - 1) % TraceLogSize)) < 0
		? (remainder + TraceLogSize)
		: (remainder))]) == 0) {
		return null;
	}
	if ((GIV(sendTraceLog)[GIV(sendTraceLogIndex)]) != 0) {
		for (i = GIV(sendTraceLogIndex); i <= (TraceLogSize - 1); i += 1) {
			safePrintStringOf(GIV(sendTraceLog)[i]);
			/* begin cr */
			printf("\n");
		}
	}
	for (i = 0; i <= (GIV(sendTraceLogIndex) - 1); i += 1) {
		safePrintStringOf(GIV(sendTraceLog)[i]);
		/* begin cr */
		printf("\n");
	}
}


/*	Answer if any immutable objects refer to any forwarded objects so that the
	become: primitives can fail if a become would update a reference from an
	immutable object.
 */

static sqInt
existImmutableReferencesToForwardedInRangeFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt oop;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		if ((oop < memStart)
		 || (oop >= memEnd)) {
			if (objectIsImmutableAndReferencesForwarded(oop)) {
				return 1;
			}
		}
	}
	oop = memStart + (headerTypeBytes[(longAt(memStart)) & TypeMask]);
	while (oop < memEnd) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if (objectIsImmutableAndReferencesForwarded(oop)) {
				return 1;
			}
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					goto l2;
				}
				else {
					sz1 = header1 & SizeMask;
					goto l2;
				}
			l2:	/* end sizeBitsOf: */;
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlock = (header & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l1:	/* end objectAfterWhileForwarding: */;
	}
	return 0;
}


/*	Called under the assumption that primFunctionPtr has been preloaded */

static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    sqInt sp4;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 255)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		/* begin pop:thenPush: */
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + ((localPrimIndex - 264) << ShiftForWord));
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 256) {
		return 1;
	}
	if (localPrimIndex == 257) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp3 = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput((sp4 = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), (((localPrimIndex - 261) << 1) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}


/*	Return the number of extra bytes used by the given object's header. */
/*	Warning: This method should not be used during marking, when the header
	type bits of an object may be incorrect.
 */
/*	JMM should be an array lookup! */

static sqInt
extraHeaderBytes(sqInt oopOrChunk)
{
	return headerTypeBytes[(longAt(oopOrChunk)) & TypeMask];
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

sqInt
failed(void)
{
	return GIV(primFailCode);
}


/*	not inlined for breakpoint value... */

static sqInt
failUnbalancedPrimitive(void)
{
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}

sqInt
falseObject(void)
{
	return GIV(falseObj);
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	/* begin arrayValueOf: */
	if (((arrayOop & 1) == 0)
	 && (((arrayOop & 1) == 0)
	 && (isWordsOrBytesNonInt(arrayOop)))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	return null;
}

static sqInt
fetchClassOfNonInt(sqInt oop)
{
    sqInt ccIndex;

	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		return (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
}

sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;

	if ((oop & 1)) {
		return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		return (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt floatOop;
    double result;

	floatOop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	/* begin floatValueOf: */
	flag("Dan");
	if (isinstanceOfcompactClassIndex(floatOop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), ClassFloatCompactIndex)) {
		;
		fetchFloatAtinto(floatOop + BaseHeaderSize, result);
		return result;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0.0;
	}
}


/*	Note: May be called by translated primitive code. */

sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt intOop;

	intOop = longAt((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord));
	/* begin checkedIntegerValueOf: */
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0;
	}
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

sqInt
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (fieldIndex << 2));
}


/*	index by word size, and return a pointer as long as the word size */

sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt oop)
{
	return longAt((oop + BaseHeaderSize) + (fieldIndex << ShiftForWord));
}


/*	Return the stackPointer of a Context or BlockContext. */

static sqInt
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	if (!((sp & 1))) {
		return 0;
	}
	return (sp >> 1);
}


/*	NOTE: this gives size appropriate for fetchPointer: n, but not in general
	for, eg, fetchLong32, etc.
 */

static sqInt
fetchWordLengthOf(sqInt objectPointer)
{
    sqInt header;
    sqInt sz;

	/* begin sizeBitsOf: */
	header = longAt(objectPointer);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(objectPointer - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
}


/*	During sweep phase we have encountered a weak reference. 
	Check if its object has gone away (or is about to) and if so, signal a 
	semaphore. */
/*	Do *not* inline this in sweepPhase - it is quite an unlikely 
	case to run into a weak reference */

static void
finalizeReference(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt contextSize;
    sqInt firstField;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt lastField;
    sqInt methodHeader;
    sqInt oopGone;
    sqInt sp;
    sqInt sz;
    sqInt type;
    usqInt weakOop;

	firstField = BaseHeaderSize + ((nonWeakFieldsOf(oop)) << ShiftForWord);
	/* begin lastPointerOf: */
	header = longAt(oop);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(oop);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		lastField = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		lastField = 0;
		goto l2;
	}
	methodHeader = longAt(oop + BaseHeaderSize);
	lastField = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	for (i = firstField; i <= lastField; i += BytesPerWord) {

		/* ar 1/18/2005: Added oop < youngStart test to make sure we're not testing
			objects in non-GCable region. This could lead to a forward reference in
			old space with the oop pointed to not being marked and thus treated as free. */

		weakOop = longAt(oop + i);
		if (!((weakOop == GIV(nilObj))
			 || (((weakOop & 1))
			 || (weakOop < GIV(youngStart))))) {
			if (weakOop < oop) {

				/* Check if the object is being collected. 
					If the weak reference points  
					* backward: check if the weakOops chunk is free
					* forward: check if the weakOoop has been marked by GC */

				chunk = weakOop - (headerTypeBytes[(longAt(weakOop)) & TypeMask]);
				oopGone = ((longAt(chunk)) & TypeMask) == HeaderTypeFree;
			}
			else {
				oopGone = !(((longAt(weakOop)) & MarkBit) != 0);
			}
			if (oopGone) {
				longAtput(oop + i, GIV(nilObj));
				/* begin signalFinalization: */
				/* begin forceInterruptCheck */
				GIV(interruptCheckCounter) = -1000;
				GIV(nextPollTick) = 0;
				GIV(pendingFinalizationSignals) += 1;
			}
		}
	}
}


/*	This is used to implement the innards of the pushImplicitReceiverBytecode,
	used for outer sends in NS2/NS3. Find the MixinApplcation of which
	aBehavior is a subclass that is an application of targetMixin. This is an
	implementation derived from
	
	<ContextPart> findApplicationOfTargetMixin: targetMixin
	startingAtBehavior: aBehavior
	 */

static sqInt
findApplicationOfTargetMixinstartingAtBehavior(sqInt targetMixin, sqInt aBehavior)
{
    sqInt mixin;
    sqInt mixinOrMixinApplication;

	mixinOrMixinApplication = aBehavior;
	while (!((mixinOrMixinApplication == GIV(nilObj))
	 || ((mixinOrMixinApplication == targetMixin)
	 || ((((mixin = longAt((mixinOrMixinApplication + BaseHeaderSize) + (MixinIndex << ShiftForWord)))) == targetMixin)
	 || ((fetchClassOf(mixin)) == targetMixin))))) {
		mixinOrMixinApplication = longAt((mixinOrMixinApplication + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return mixinOrMixinApplication;
}

sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt done;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    sqInt sz;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		currClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		currClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	done = 0;
	while (!(done)) {
		classDict = longAt((currClass + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(classDict - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		methodArray = longAt((classDict + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + BaseHeaderSize) + (i << ShiftForWord)))) {
				return currClass;
			}
			i += 1;
		}
		currClass = longAt((currClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
		done = currClass == GIV(nilObj);
	}
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
	}
	if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		return (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
	}
}

static sqInt
findHomeForContext(sqInt aContext)
{
    sqInt closureOrNil;

	if (!(((aContext & 1) == 0)
		 && (((((usqInt) (longAt(aContext))) >> 12) & 31) == ClassMethodContextCompactIndex))) {
		return longAt((aContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
	}
	closureOrNil = longAt((aContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord)));
}


/*	Find the compiled method to be run when the current 
	messageSelector is sent to the given class, setting the values 
	of 'newMethod' and 'primitiveIndex'. */

static sqInt
findNewMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt ok;
    sqInt probe;

	/* begin lookupInMethodCacheSel:class: */

	/* shift drops two low-order zeros from addresses */

	hash = GIV(messageSelector) ^ class;

	/* first probe */

	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}

	/* second probe */

	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		ok = 1;
		goto l1;
	}
	ok = 0;
l1:	/* end lookupInMethodCacheSel:class: */;
	if (!(ok)) {
		lookupMethodInClass(class);
		GIV(lkupClass) = class;
		addNewMethodToCache();
	}
}

sqInt
findSelectorOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt done;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    sqInt sz;

	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		currClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		currClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	done = 0;
	while (!(done)) {
		classDict = longAt((currClass + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(classDict - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		methodArray = longAt((classDict + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
		i = 0;
		while (i <= (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + BaseHeaderSize) + (i << ShiftForWord)))) {
				return longAt((classDict + BaseHeaderSize) + ((i + SelectorStart) << ShiftForWord));
			}
			i += 1;
		}
		currClass = longAt((currClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
		done = currClass == GIV(nilObj);
	}
	return GIV(nilObj);
}

void *
firstFixedField(sqInt oop)
{
	return pointerForOop(oop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes
 */

void *
firstIndexableField(sqInt oop)
{
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> 8) & 15;
	if (fmt <= 4) {
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (fmt < 8) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			totalLength = (sz - BaseHeaderSize) - (fmt & 3);
			goto l1;
		}
	l1:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l2;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l2;
		}
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
			class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
			goto l3;
		}
		else {
			class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l3;
		}
	l3:	/* end fetchClassOfNonInt: */;
		classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
	l2:	/* end fixedFieldsOf:format:length: */;
		return pointerForOop((oop + BaseHeaderSize) + (fixedFields << ShiftForWord));
	}
	return pointerForOop(oop + BaseHeaderSize);
}


/*	Like #stackFloatValue: but access method arguments left-to-right */

double
floatArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    double result;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	if (isClassOfNonImmequalTocompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), ClassFloatCompactIndex)) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	return 0.0;
}

sqInt
floatObjectOf(double aFloat)
{
    sqInt newFloatObj;

	flag("Dan");
	newFloatObj = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), 8 + BaseHeaderSize);
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that object, or fail if it
	is not a Float. */

double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double result;

	flag("Dan");
	if (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), ClassFloatCompactIndex)) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0.0;
	}
}


/*	methodPtr is a CompiledMethod containing an external primitive. Flush the
	function address and session ID of the CM
 */

static sqInt
flushExternalPrimitiveOf(sqInt methodPtr)
{
    sqInt lit;

	if (!(((((usqInt) (longAt((methodPtr + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) > 0)) {
		return null;
	}
	lit = longAt((methodPtr + BaseHeaderSize) + ((0 + LiteralStart) << ShiftForWord));
	if (!((((lit & 1) == 0)
 && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2))
		 && ((lengthOf(lit)) == 4))) {
		return null;
	}
	longAtput((lit + BaseHeaderSize) + (2 << ShiftForWord), ConstZero);
	longAtput((lit + BaseHeaderSize) + (3 << ShiftForWord), ConstZero);
}


/*	Flush the references to external functions from plugin 
	primitives. This will force a reload of those primitives when 
	accessed next. 
	Note: We must flush the method cache here so that any 
	failed primitives are looked up again. */

static sqInt
flushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt oop;
    sqInt primBits;
    sqInt primIdx;
    sqInt sz;

	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while (oop < GIV(endOfMemory)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
				/* begin primitiveIndexOf: */
				primBits = (((usqInt) (longAt((oop + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
				primIdx = (primBits & 511) + (((usqInt) primBits) >> 19);
				if (primIdx == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(oop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i2 = 0; i2 <= (MaxExternalPrimitiveTableSize - 1); i2 += 1) {
		GIV(externalPrimitiveTable)[i2] = 0;
	}
}


/*	force an interrupt check ASAP - setting interruptCheckCounter to a large
	-ve number is used as a flag to skip messing with the feedback mechanism
	and nextPollTick resetting makes sure that ioProcess gets called as near
	immediately as we can manage
 */

sqInt
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
}


/*	**should be in-lined** */
/*	Note that, in Smalltalk, the instSpec will be equal to the inst spec
	part of the base header of an instance (without hdr type) shifted left 1.
	In this way, apart from the smallInt bit, the bits
	are just where you want them for the first header word. */
/*	Callers (must) expect low 2 bits (header type) to be zero! */

sqInt
formatOfClass(sqInt classPointer)
{
	return (longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

sqInt
fullDisplayUpdate(void)
{
    sqInt displayObj;
    sqInt h;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
	if ((((displayObj & 1) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(displayObj)) >= 4)) {
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, h);
		ioForceDisplayUpdate();
	}
}


/*	Do a mark/sweep garbage collection of the entire object memory. Free
	inaccessible objects but do not move them.
 */

void
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt i;
    sqInt limit;
    sqInt limit1;
    sqInt oop;
    sqInt sz;

	if (DoAssertionChecks) {
		reverseDisplayFromto(0, 7);
		clearLeakMapAndMapAccessibleObjects();
		checkHeapIntegrity();
	}
	/* begin preGCAction: */
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statSweepCount) = (GIV(statMarkCount) = (GIV(statMkFwdCount) = (GIV(statCompMoveCount) = 0)));
	/* begin clearRootsTable */
	for (i = 1; i <= GIV(rootTableCount); i += 1) {

		/* clear root bits of current root table entries */

		oop = GIV(rootTable)[i];
		longAtput(oop, (longAt(oop)) & AllButRootBit);
		GIV(rootTable)[i] = 0;
	}
	GIV(rootTableCount) = 0;

	/* process all of memory */

	GIV(youngStart) = memory;
	markPhase();
	GIV(totalObjectCount) = sweepPhase();
	/* begin fullCompaction */
	VM_LABEL(0fullCompaction);
	GIV(compStart) = lowestFreeAfter(memory);
	if (GIV(compStart) == GIV(freeBlock)) {
		initializeMemoryFirstFree(GIV(freeBlock));
		goto l1;
	}
	if (((sz = fwdTableSize(8))) < GIV(totalObjectCount)) {
		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit1 = sqGrowMemoryBy(GIV(memoryLimit), ((GIV(totalObjectCount) - sz) + 10000) * 8);
		if (!(limit1 == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit1 - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit1 - 24;
			initializeMemoryFirstFree(GIV(freeBlock));
		}
	}
	while (GIV(compStart) < GIV(freeBlock)) {

		/* free chunk returned by incCompBody becomes start of next compaction */

		GIV(compStart) = incCompBody();
	}
l1:	/* end fullCompaction */;
	GIV(allocationCount) = 0;
	GIV(statFullGCs) += 1;
	GIV(statGCEndTime) = ioMicroMSecs();
	GIV(statFullGCUsecs) += (ioUTCMicrosecondsNow()) - GIV(gcStartUsecs);
	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);

	/* reset the young object boundary */

	GIV(youngStart) = GIV(freeBlock);
	/* begin postGCAction */
	if (GIV(activeContext) < GIV(youngStart)) {
		beRootIfOld(GIV(activeContext));
	}
	if (GIV(theHomeContext) < GIV(youngStart)) {
		beRootIfOld(GIV(theHomeContext));
	}
	if (((longAt(GIV(freeBlock))) & AllButTypeMask) > GIV(shrinkThreshold)) {
		/* begin shrinkObjectMemory: */
		delta = ((longAt(GIV(freeBlock))) & AllButTypeMask) - GIV(growHeadroom);
		GIV(statShrinkMemory) += 1;
		limit = sqShrinkMemoryBy(GIV(memoryLimit), delta);
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit - 24;
			initializeMemoryFirstFree(GIV(freeBlock));
		}
	}
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	if (DoAssertionChecks) {
		clearLeakMapAndMapAccessibleObjects();
		checkHeapIntegrity();
		reverseDisplayFromto(0, 7);
	}
}


/*	Answer if the given address is a valid forward table entry. */

static sqInt
fwdBlockValid(sqInt addr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((((usqInt) addr)) > (((usqInt) GIV(endOfMemory))))
	 && (((((usqInt) addr)) <= (((usqInt) GIV(fwdTableNext))))
	 && ((addr & 3) == 0));
}


/*	Set the limits for a table of two- or three-word forwarding blocks above
	the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used
	for compaction of memory and become-ing objects. Returns the number of
	forwarding blocks available.
 */

static sqInt
fwdTableInit(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt chunk1;

	/* begin setSizeOfFree:to: */
	chunk = GIV(freeBlock);
	longAtput(chunk, (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	/* begin setEndOfMemory: */
	assert(((GIV(freeBlock) + BaseHeaderSize) & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = GIV(freeBlock) + BaseHeaderSize;
	/* begin setSizeOfFree:to: */
	chunk1 = GIV(endOfMemory);
	longAtput(chunk1, (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	GIV(fwdTableNext) = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */

	GIV(fwdTableLast) = GIV(memoryLimit) - blkSize;
	return (GIV(fwdTableLast) - GIV(fwdTableNext)) / blkSize;
}


/*	Estimate the number of forwarding blocks available for compaction */

static sqInt
fwdTableSize(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt eom;
    sqInt fwdFirst;
    sqInt fwdLast;


	/* use all memory free between freeBlock and memoryLimit for forwarding table */
	/* Note: Forward blocks must be quadword aligned. */

	eom = GIV(freeBlock) + BaseHeaderSize;
	fwdFirst = ((eom + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */

	fwdLast = GIV(memoryLimit) - blkSize;
	return (fwdLast - fwdFirst) / blkSize;
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. 
 */

sqInt
getCurrentBytecode(void)
{
	return byteAt(GIV(instructionPointer));
}

sqInt
getDeferDisplayUpdates(void)
{
	return deferDisplayUpdates;
}

sqInt
getFullScreenFlag(void)
{
	return GIV(fullScreenFlag);
}

sqInt
getInterruptCheckCounter(void)
{
	return GIV(interruptCheckCounter);
}

sqInt
getInterruptKeycode(void)
{
	return GIV(interruptKeycode);
}

sqInt
getInterruptPending(void)
{
	return GIV(interruptPending);
}


/*	Answer the next word read from aFile, byte-swapped according to the
	swapFlag. 
 */

static sqInt
getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead(&w, sizeof(w), 1, aFile);
	if (swapFlag) {
		return byteSwapped(w);
	}
	else {
		return w;
	}
}

sqInt
getNextWakeupTick(void)
{
	return GIV(nextWakeupTick);
}

sqInt
getSavedWindowSize(void)
{
	return GIV(savedWindowSize);
}


/*	For Newsqueak FFI */

EXPORT(sqInt)
getStackPointer(void)
{
	return GIV(stackPointer);
}


/*	return the global session ID value */

sqInt
getThisSessionID(void)
{
	return GIV(globalSessionID);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize. */

sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;

	shifted = anUnsignedValue;
	bitNo = 0;
	
#  if (BytesPerWord > 4)
	if (!(shifted < (1 << 32))) {
		shifted = ((usqInt) shifted) >> 32;
		bitNo += 32;
	}

#  endif /* (BytesPerWord > 4) */

	if (!(shifted < (1 << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1 << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1 << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1 << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1 << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null.
	This is a noop in the Interpreter VM since the C stack pointers are always
	elsewhere (e.g., in some C function running the interpreter). */

void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{
}


/*	This VM is forwards-compatible with the immediately following closure
	version, and
	will write the new version number in snapshots if the closure creation
	bytecode is used.
 */

static sqInt
imageFormatForwardCompatibilityVersion(void)
{
	if (BytesPerWord == 4) {
		return 6504;
	}
	else {
		return 68002;
	}
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine it came from. Low half of word is 6502. Top byte
	is top byte of #doesNotUnderstand: on this machine. ($d on the Mac or $s
	on the PC)
 */

static sqInt
imageSegmentVersion(void)
{
    sqInt wholeWord;


	/* first data word, 'does'  */

	wholeWord = longAt((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord))) + BaseHeaderSize);
	return imageFormatVersionNumber | (wholeWord & 4278190080UL);
}


/*	Move objects to consolidate free space into one big chunk. Return the
	newly created free chunk.
 */

static sqInt
incCompBody(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesFreed;

	fwdTableInit(BytesPerWord * 2);

	/* update pointers to point at new oops */

	bytesFreed = incCompMakeFwd();
	mapPointersInObjectsFromto(GIV(youngStart), GIV(endOfMemory));
	return incCompMove(bytesFreed);
}


/*	Create and initialize forwarding blocks for all non-free objects 
	following compStart. If the supply of forwarding blocks is exhausted, 
	set compEnd to the first chunk above the area to be 
	compacted; otherwise, set it to endOfMemory. Return the number of 
	bytes to be freed. */

static sqInt
incCompMakeFwd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesFreed;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt header;
    sqInt header1;
    sqInt newOop;
    sqInt oop;
    sqInt originalHeader;
    sqInt originalHeaderType;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;

	bytesFreed = 0;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		GIV(statMkFwdCount) += 1;
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			bytesFreed += (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin fwdBlockGet: */
			GIV(fwdTableNext) += BytesPerWord * 2;
			if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
				fwdBlock = GIV(fwdTableNext);
				goto l1;
			}
			else {
				fwdBlock = null;
				goto l1;
			}
		l1:	/* end fwdBlockGet: */;
			if (fwdBlock == null) {

				/* stop; we have used all available forwarding blocks */

				GIV(compEnd) = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
				return bytesFreed;
			}
			newOop = oop - bytesFreed;
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			originalHeader = longAt(oop);
			assert(fwdBlock != null);
			assert((originalHeader & MarkBit) == 0);
			originalHeaderType = originalHeader & TypeMask;
			longAtput(fwdBlock, newOop);
			longAtput(fwdBlock + BytesPerWord, originalHeader);
			if (0) {
				longAtput(fwdBlock + (BytesPerWord * 2), oop);
			}
			longAtput(oop, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType));
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					goto l3;
				}
				else {
					sz1 = header1 & SizeMask;
					goto l3;
				}
			l3:	/* end sizeBitsOf: */;
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l2;
		}
		fwdBlock1 = (header & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock1));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock1 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l2:	/* end objectAfterWhileForwarding: */;
	}
	GIV(compEnd) = GIV(endOfMemory);
	return bytesFreed;
}


/*	Move all non-free objects between compStart and compEnd to their new 
	locations, restoring their headers in the process. Create a new free 
	block at the end of memory. Return the newly created free chunk. */
/*	Note: The free block used by the allocator always must be the last free 
	block in memory. It may take several compaction passes to make all 
	free space bubble up to the end of memory. */

static sqInt
incCompMove(sqInt bytesFreed)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToMove;
    usqInt firstWord;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt lastWord;
    sqInt newFreeChunk;
    sqInt newOop;
    sqInt next;
    sqInt oop;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt target;
    usqInt w;

	newOop = null;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(compEnd)))) {
		GIV(statCompMoveCount) += 1;
		/* begin objectAfterWhileForwarding: */
		header2 = longAt(oop);
		if ((header2 & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz2 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header3 = longAt(oop);
				if ((header3 & TypeMask) == HeaderTypeSizeAndClass) {
					sz2 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					goto l3;
				}
				else {
					sz2 = header3 & SizeMask;
					goto l3;
				}
			l3:	/* end sizeBitsOf: */;
			}
			next = (oop + sz2) + (headerTypeBytes[(longAt(oop + sz2)) & TypeMask]);
			goto l2;
		}
		fwdBlock1 = (header2 & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock1));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock1 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz1 = realHeader & SizeMask;
		}
		next = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
	l2:	/* end objectAfterWhileForwarding: */;
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {

			/* a moving object; unwind its forwarding block */

			fwdBlock = ((longAt(oop)) & AllButMarkBitAndTypeMask) << 1;
			assert(fwdBlockValid(fwdBlock));
			newOop = longAt(fwdBlock);
			header = longAt(fwdBlock + BytesPerWord);
			longAtput(oop, header);

			/* move the oop (including any extra header words)  */

			bytesToMove = oop - newOop;
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header1 & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
			firstWord = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
			lastWord = (oop + sz) - BaseHeaderSize;
			target = firstWord - bytesToMove;
			for (w = firstWord; w <= lastWord; w += BytesPerWord) {
				longAtput(target, longAt(w));
				target += BytesPerWord;
			}
		}
		oop = next;
	}
	if (newOop == null) {

		/* no objects moved */

		oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
		if ((((longAt(oop)) & TypeMask) == HeaderTypeFree)
		 && ((objectAfter(oop)) == (GIV(compEnd) + (headerTypeBytes[(longAt(GIV(compEnd))) & TypeMask])))) {
			newFreeChunk = oop;
		}
		else {
			newFreeChunk = GIV(freeBlock);
		}
	}
	else {

		/* initialize the newly freed memory chunk */
		/* newOop is the last object moved; free chunk starts 
			right after it */

		newFreeChunk = newOop + (sizeBitsOf(newOop));
		/* begin setSizeOfFree:to: */
		longAtput(newFreeChunk, (bytesFreed & AllButTypeMask) | HeaderTypeFree);
	}
	assert((objectAfter(newFreeChunk)) == (oopFromChunk(GIV(compEnd))));
	if ((objectAfter(newFreeChunk)) == GIV(endOfMemory)) {
		initializeMemoryFirstFree(newFreeChunk);
	}
	else {
		initializeMemoryFirstFree(GIV(freeBlock));
	}
	return newFreeChunk;
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		theClass = longAt((theClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return 0;
}


/*	Do a mark/sweep garbage collection of just the young object 
	area of object memory (i.e., objects above youngStart), using 
	the root table to identify objects containing pointers to 
	young objects from the old object area. */

void
incrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt growSize;
    sqInt growth;
    sqInt i;
    sqInt i1;
    sqInt limit;
    sqInt limit1;
    sqInt oop;
    sqInt survivorCount;
    sqInt weDidGrow;

	if (GIV(rootTableCount) >= RootTableSize) {

		/* root table overflow; cannot do an incremental GC (this should be very rare) */

		GIV(statRootTableOverflows) += 1;
		fullGC(); return;
	}
	if (DoAssertionChecks) {
		reverseDisplayFromto(8, 15);
		checkHeapIntegrity();
		checkInterpreterIntegrity();
		validate();
	}
	/* begin preGCAction: */
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(weakRootCount) = 0;
	GIV(statSweepCount) = (GIV(statMarkCount) = (GIV(statMkFwdCount) = (GIV(statCompMoveCount) = 0)));
	markPhase();
	assert(GIV(weakRootCount) <= WeakRootTableSize);
	for (i = 1; i <= GIV(weakRootCount); i += 1) {
		finalizeReference(GIV(weakRoots)[i]);
	}
	survivorCount = sweepPhase();
	/* begin incrementalCompaction */
	if (GIV(compStart) == GIV(freeBlock)) {
		initializeMemoryFirstFree(GIV(freeBlock));
	}
	else {
		incCompBody();
	}
	GIV(statAllocationCount) = GIV(allocationCount);
	GIV(allocationCount) = 0;
	GIV(statIncrGCs) += 1;
	GIV(statGCEndTime) = ioMicroMSecs();
	GIV(statIGCDeltaUsecs) = (ioUTCMicrosecondsNow()) - GIV(gcStartUsecs);
	GIV(statIncrGCUsecs) += GIV(statIGCDeltaUsecs);
	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);
	/* begin forceInterruptCheck */
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
	GIV(statRootTableCount) = GIV(rootTableCount);
	GIV(statSurvivorCount) = survivorCount;
	weDidGrow = 0;
	if (((survivorCount > GIV(tenuringThreshold))
 || (GIV(rootTableCount) >= RootTableRedZone))
	 || (GIV(forceTenureFlag) == 1)) {

		/* move up the young space boundary if 
			* there are too many survivors: 
			this limits the number of objects that must be 
			processed on future incremental GC's 
			* we're about to overflow the roots table 
			this limits the number of full GCs that may be caused 
			by root table overflows in the near future */

		GIV(forceTenureFlag) = 0;
		GIV(statTenures) += 1;
		/* begin clearRootsTable */
		for (i1 = 1; i1 <= GIV(rootTableCount); i1 += 1) {

			/* clear root bits of current root table entries */

			oop = GIV(rootTable)[i1];
			longAtput(oop, (longAt(oop)) & AllButRootBit);
			GIV(rootTable)[i1] = 0;
		}
		GIV(rootTableCount) = 0;
		if ((((longAt(GIV(freeBlock))) & AllButTypeMask) < GIV(growHeadroom))
		 && (GIV(gcBiasToGrow) > 0)) {
			/* begin biasToGrow */
			growSize = (((sqInt) (GIV(growHeadroom) * 3) >> 1)) - ((longAt(GIV(freeBlock))) & AllButTypeMask);
			/* begin growObjectMemory: */
			GIV(statGrowMemory) += 1;
			limit = sqGrowMemoryBy(GIV(memoryLimit), growSize);
			if (!(limit == GIV(memoryLimit))) {
				/* begin setMemoryLimit: */
				assert(((limit - 24) & (BytesPerWord - 1)) == 0);
				GIV(memoryLimit) = limit - 24;
				initializeMemoryFirstFree(GIV(freeBlock));
			}
			weDidGrow = 1;
		}
		GIV(youngStart) = GIV(freeBlock);
	}
	/* begin postGCAction */
	if (GIV(activeContext) < GIV(youngStart)) {
		beRootIfOld(GIV(activeContext));
	}
	if (GIV(theHomeContext) < GIV(youngStart)) {
		beRootIfOld(GIV(theHomeContext));
	}
	if (((longAt(GIV(freeBlock))) & AllButTypeMask) > GIV(shrinkThreshold)) {
		/* begin shrinkObjectMemory: */
		delta = ((longAt(GIV(freeBlock))) & AllButTypeMask) - GIV(growHeadroom);
		GIV(statShrinkMemory) += 1;
		limit1 = sqShrinkMemoryBy(GIV(memoryLimit), delta);
		if (!(limit1 == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit1 - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit1 - 24;
			initializeMemoryFirstFree(GIV(freeBlock));
		}
	}
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	if (DoAssertionChecks) {
		validate();
		checkHeapIntegrity();
		checkInterpreterIntegrity();
		reverseDisplayFromto(8, 15);
	}
	if (weDidGrow) {
		/* begin biasToGrowCheckGCLimit */
		growth = (GIV(youngStart) - memory) - GIV(gcBiasToGrowThreshold);
		if (growth < 0) {
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - memory;
		}
		if (growth > GIV(gcBiasToGrowGCLimit)) {
			fullGC();
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - memory;
		}
	}
}


/*	Initialize NewspeakInterpreter state before starting execution of a new
	image. 
 */

static sqInt
initializeInterpreter(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt oop;

	interpreterProxy = sqGetInterpreterProxy();
	dummyReferToProxy();
	initializeObjectMemory(bytesToShift);
	/* begin checkAssumedCompactClasses */
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassArrayCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassArrayCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassLargePositiveIntegerCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassLargePositiveIntegerCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassFloatCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassFloatCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassBlockContextCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockContext << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassBlockContextCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("BlockContext");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassMethodContextCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMethodContext << ShiftForWord))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ClassMethodContextCompactIndex - 1) << ShiftForWord))))) {
		invalidCompactClassError("MethodContext");
	}
	GIV(primFailCode) = 0;
	/* begin initializeExtraClassInstVarIndices */
	VM_LABEL(0initializeExtraClassInstVarIndices);

	/* default */

	GIV(classNameIndex) = 6;

	/* default */

	GIV(thisClassIndex) = 5;
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord));
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(classArrayObj))) >> 12) & 31)) == 0) {
		classArrayClass = (longAt(classArrayObj - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		classArrayClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOfNonInt: */;
	/* begin sizeBitsOf: */
	header = longAt(classArrayClass);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		GIV(metaclassSizeBytes) = (longAt(classArrayClass - (BytesPerWord * 2))) & LongSizeMask;
		goto l3;
	}
	else {
		GIV(metaclassSizeBytes) = header & SizeMask;
		goto l3;
	}
l3:	/* end sizeBitsOf: */;
	for (i2 = (InstanceSpecificationIndex + 1); i2 <= (lengthOf(classArrayClass)); i2 += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + (i2 << ShiftForWord))) == classArrayObj) {
			GIV(thisClassIndex) = i2;
		}
	}
	for (i2 = (InstanceSpecificationIndex + 1); i2 <= (lengthOf(classArrayObj)); i2 += 1) {
		oop = longAt((classArrayObj + BaseHeaderSize) + (i2 << ShiftForWord));
		if ((((oop & 1) == 0)
 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8))
		 && (((lengthOf(oop)) == 5)
		 && ((strncmp("Array", firstFixedField(oop), 5)) == 0))) {
			GIV(classNameIndex) = i2;
		}
	}
	GIV(activeContext) = GIV(nilObj);
	GIV(theHomeContext) = GIV(nilObj);
	GIV(method) = GIV(nilObj);
	GIV(receiver) = GIV(nilObj);
	GIV(messageSelector) = GIV(nilObj);
	GIV(newMethod) = GIV(nilObj);
	GIV(lkupClass) = GIV(nilObj);
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	loadInitialContext();
	/* begin initialCleanup */
	if (((longAt(GIV(activeContext))) & RootBit) == 0) {
		goto l1;
	}
	longAtput(GIV(activeContext), (longAt(GIV(activeContext))) & AllButRootBit);
	flushExternalPrimitives();
l1:	/* end initialCleanup */;
	GIV(interruptCheckCounter) = 0;
	GIV(interruptCheckCounterFeedBackReset) = 1000;
	GIV(interruptChecksEveryNms) = 1;
	GIV(nextPollTick) = 0;
	GIV(nextWakeupTick) = 0;
	GIV(lastTick) = 0;

	/* cmd-. as used for Mac but no other OS */

	GIV(interruptKeycode) = 2094;
	GIV(interruptPending) = 0;
	deferDisplayUpdates = 0;
	GIV(pendingFinalizationSignals) = 0;
	GIV(globalSessionID) = 0;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = time(NULL) + ioMSecs();
	}
}


/*	Initialize endOfMemory to the top of oop storage space, reserving some
	space for forwarding blocks, and create the freeBlock from which space is
	allocated. Also create a fake free chunk at endOfMemory to act as a
	sentinal for memory scans.
 */
/*	Note: The amount of space reserved for forwarding blocks should be chosen
	to ensure that incremental compactions can usually be done in a single
	pass. However, there should be enough forwarding blocks so a full
	compaction can be done in a reasonable number of passes, say ten. (A full
	compaction requires N object-moving passes, where N = number of
	non-garbage objects / number of forwarding blocks). 
	di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object
	to be used for forwarding pointers at GC time. Since fwd blocks are 8
	bytes, this means an absolute worst case of 8 passes to compact memory. In
	most cases it will be adequate to do compaction in a single pass.
 */
/*	reserve space for forwarding blocks */

static void
initializeMemoryFirstFree(sqInt firstFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSize;
    sqInt chunk;
    sqInt chunk1;
    sqInt fwdBlockBytes;
    sqInt newEndOfMemory;

	fwdBlockBytes = GIV(totalObjectCount) & ((WordMask - BytesPerWord) + 1);
	if (!((((usqInt) (GIV(memoryLimit) - fwdBlockBytes))) >= (((usqInt) (firstFree + BaseHeaderSize))))) {

		/* reserve enough space for a minimal free block of BaseHeaderSize bytes */

		fwdBlockBytes = GIV(memoryLimit) - (firstFree + BaseHeaderSize);
	}
	/* begin setEndOfMemory: */
	newEndOfMemory = GIV(memoryLimit) - fwdBlockBytes;
	assert((newEndOfMemory & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = newEndOfMemory;
	GIV(freeBlock) = firstFree;
	/* begin setSizeOfFree:to: */
	chunk = GIV(freeBlock);
	byteSize = GIV(endOfMemory) - firstFree;
	longAtput(chunk, (byteSize & AllButTypeMask) | HeaderTypeFree);
	/* begin setSizeOfFree:to: */
	chunk1 = GIV(endOfMemory);
	longAtput(chunk1, (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	if (DoAssertionChecks) {
		if (!((GIV(freeBlock) < GIV(endOfMemory))
			 && (GIV(endOfMemory) < GIV(memoryLimit)))) {
			error("error in free space computation");
		}
		if (!((GIV(endOfMemory) + (extraHeaderBytes(GIV(endOfMemory)))) == GIV(endOfMemory))) {
			error("header format must have changed");
		}
		if (!((objectAfter(GIV(freeBlock))) == GIV(endOfMemory))) {
			error("free block not properly initialized");
		}
	}
}


/*	Initialize object memory variables at startup time. Assume endOfMemory is
	initially set (by the image-reading code) to the end of the last object in
	the image. Initialization redefines endOfMemory to be the end of the
	object allocation area based on the total available memory, but reserving
	some space for forwarding blocks.
 */
/*	Assume: image reader initializes the following variables:
	memory
	endOfMemory
	memoryLimit
	specialObjectsOop
	lastHash
	 */
/*	di 11/18/2000 fix slow full GC */
/*	set the start of the young object space */

static void
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* image may be at a different address; adjust oops for new location */

	GIV(youngStart) = GIV(endOfMemory);
	GIV(totalObjectCount) = adjustAllOopsBy(bytesToShift);
	initializeMemoryFirstFree(GIV(endOfMemory));

	/* heavily used special objects */

	GIV(specialObjectsOop) += bytesToShift;
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (NilObject << ShiftForWord));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (FalseObject << ShiftForWord));
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TrueObject << ShiftForWord));
	GIV(rootTableCount) = 0;
	GIV(freeContexts) = NilContext;
	GIV(freeLargeContexts) = NilContext;
	GIV(allocationCount) = 0;
	GIV(lowSpaceThreshold) = 0;
	GIV(signalLowSpace) = 0;
	GIV(compStart) = 0;
	GIV(compEnd) = 0;
	GIV(fwdTableNext) = 0;
	GIV(fwdTableLast) = 0;
	GIV(remapBufferCount) = 0;

	/* do incremental GC after this many allocations */

	GIV(allocationsBetweenGCs) = 4000;

	/* tenure all suriving objects if count is over this threshold */

	GIV(tenuringThreshold) = 2000;

	/* four megabyte of headroom when growing */

	GIV(growHeadroom) = (4 * 1024) * 1024;

	/* eight megabyte of free space before shrinking */
	/* garbage collection statistics */

	GIV(shrinkThreshold) = (8 * 1024) * 1024;
	GIV(statFullGCs) = 0;
	GIV(statFullGCUsecs) = 0;
	GIV(statIncrGCs) = 0;
	GIV(statIncrGCUsecs) = 0;
	GIV(statTenures) = 0;
	GIV(statRootTableOverflows) = 0;
	GIV(statGrowMemory) = 0;
	GIV(statShrinkMemory) = 0;
	GIV(forceTenureFlag) = 0;
	GIV(gcBiasToGrow) = 0;
	GIV(gcBiasToGrowGCLimit) = 0;
	GIV(extraRootCount) = 0;
	GIV(gcStartUsecs) = 0;
}


/*	Install the oop of this object in the given cache (at or atPut), along
	with its size, format and fixedSize */

static sqInt
installinAtCacheatstring(sqInt rcvr, sqInt *cache, sqInt atIx, sqInt stringy)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	if ((fmt == 3)
	 && ((((((usqInt) hdr) >> 12) & 31) == 13)
	 || (((((usqInt) hdr) >> 12) & 31) == 14))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	cache[atIx + AtCacheOop] = rcvr;
	if (stringy) {
		cache[atIx + AtCacheFmt] = (fmt + 16);
	}
	else {
		cache[atIx + AtCacheFmt] = fmt;
	}
	cache[atIx + AtCacheFixedFields] = fixedFields;
	cache[atIx + AtCacheSize] = (totalLength - fixedFields);
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

sqInt
instanceSizeOf(sqInt classObj)
{
    sqInt byteSize;
    sqInt classHdr;
    sqInt sizeHiBits;

	assert(addressCouldBeObj(classObj));

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */

	classHdr = (longAt((classObj + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	sizeHiBits = (((usqInt) classHdr) >> 9) & 768;

	/* size in bytes -- low 2 bits are 0 */

	byteSize = (classHdr & SizeMask) + sizeHiBits;
	return ((sqInt) (byteSize - BaseHeaderSize) >> 2);
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
 */

sqInt
instantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt cClass;
    sqInt chunk;
    sqInt classFormat;
    sqInt currentProc;
    usqInt end;
    sqInt enoughSpace;
    sqInt fillWord;
    sqInt format;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt i;
    sqInt lastSavedProcess;
    sqInt minFree;
    sqInt newChunk;
    sqInt newFreeSize;
    sqInt newObj;
    sqInt newObj1;
    sqInt oop;
    sqInt oop1;
    sqInt remappedClassOop;
    sqInt sizeHiBits;

	assert(size >= 0);
	/* begin newObjectHash */
	GIV(lastHash) = (13849 + (27181 * GIV(lastHash))) & 65535;
	hash = GIV(lastHash);

	/* Low 2 bits are 0 */

	classFormat = (longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	header1 = (classFormat & 130816) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */

	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
		to 4 bytes per field.  Need another shift for 8 bytes per word... */

	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = byteSize << (ShiftForWord - 2);
	format = (((usqInt) classFormat) >> 8) & 15;
	flag("sizeLowBits");
	if (format < 8) {
		if (format == 6) {

			/* long32 bitmaps */

			bm1 = BytesPerWord - 1;

			/* round up */

			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */

			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */

		bm1 = BytesPerWord - 1;

		/* round up */

		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */

		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */

		header1 = header1 | ((binc & 3) << 8);
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 255) {

		/* requires size header word */

		header3 = byteSize;
		header1 = header1;
	}
	else {
		header1 = header1 | byteSize;
	}
	hdrSize = (header3 > 0
		? (3)
		: ((cClass == 0
	? (2)
	: (1))));
	/* begin allocate:headerSize:h1:h2:h3:doFill:format: */
	VM_LABEL(0allocateheaderSizeh1h2h3doFillformat);
	if (hdrSize > 1) {
		/* begin pushRemappableOop: */
		assert(addressCouldBeOop(header2));
		GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = header2;
	}
	/* begin allocateChunk: */
	VM_LABEL(1allocateChunk);
	if (GIV(allocationCount) >= GIV(allocationsBetweenGCs)) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */

	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + (byteSize + ((hdrSize - 1) * BytesPerWord))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
		enoughSpace = 1;
		goto l1;
	}
	else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {

		/* signal that space is running low, but proceed with allocation if possible */

		GIV(signalLowSpace) = 1;

		/* disable additional interrupts until lowSpaceThreshold is reset by image */

		GIV(lowSpaceThreshold) = 0;
		/* begin saveProcessSignalingLowSpace */
		VM_LABEL(1saveProcessSignalingLowSpace);
		lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord));
		if (lastSavedProcess == GIV(nilObj)) {
			currentProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			oop1 = GIV(specialObjectsOop);
			if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop1, currentProc);
			}
			longAtput((oop1 + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord), currentProc);
		}
		/* begin forceInterruptCheck */
		GIV(interruptCheckCounter) = -1000;
		GIV(nextPollTick) = 0;
	}
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) < (((usqInt) ((byteSize + ((hdrSize - 1) * BytesPerWord)) + BaseHeaderSize)))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(GIV(freeBlock))) & AllButTypeMask) - (byteSize + ((hdrSize - 1) * BytesPerWord));
	newChunk = GIV(freeBlock);

	/* Assume: client will initialize object header of free chunk, so following is not needed: */
	/* self setSizeOfFree: newChunk to: byteSize. */

	GIV(freeBlock) += byteSize + ((hdrSize - 1) * BytesPerWord);
	/* begin setSizeOfFree:to: */
	chunk = GIV(freeBlock);
	longAtput(chunk, (newFreeSize & AllButTypeMask) | HeaderTypeFree);
	GIV(allocationCount) += 1;
	newObj1 = newChunk;
	if (hdrSize > 1) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		remappedClassOop = oop;
	}
	if (hdrSize == 3) {
		longAtput(newObj1, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj1 + BytesPerWord, remappedClassOop | HeaderTypeSizeAndClass);
		longAtput(newObj1 + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj1 += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj1, remappedClassOop | HeaderTypeClass);
		longAtput(newObj1 + BytesPerWord, header1 | HeaderTypeClass);
		newObj1 += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj1, header1 | HeaderTypeShort);
	}
	if (1) {
		fillWord = (format <= 4
			? (GIV(nilObj))
			: (0));
		end = newObj1 + byteSize;
		i = newObj1 + BytesPerWord;
		while (i < end) {
			longAtput(i, fillWord);
			i += BytesPerWord;
		}
	}
	if (DoAssertionChecks) {
		okayOop(newObj1);
		oopHasOkayClass(newObj1);
		if (!((objectAfter(newObj1)) == GIV(freeBlock))) {
			error("allocate bug: did not set header of new oop correctly");
		}
		if (!((objectAfter(GIV(freeBlock))) == GIV(endOfMemory))) {
			error("allocate bug: did not set header of freeBlock correctly");
		}
	}
	newObj = newObj1;
	return newObj;
}


/*	This version of instantiateClass assumes that the total object 
	size is under 256 bytes, the limit for objects with only one or 
	two header words. Note that the size is specified in bytes 
	and should include four bytes for the base header word. */

static sqInt
instantiateContextsizeInBytes(sqInt classPointer, sqInt sizeInBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt currentProc;
    usqInt end;
    sqInt enoughSpace;
    sqInt fillWord;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    usqInt i;
    sqInt lastSavedProcess;
    sqInt minFree;
    sqInt newChunk;
    sqInt newFreeSize;
    sqInt newObj;
    sqInt oop;
    sqInt oop1;
    sqInt remappedClassOop;

	/* begin newObjectHash */
	GIV(lastHash) = (13849 + (27181 * GIV(lastHash))) & 65535;
	hash = GIV(lastHash);
	header1 = ((hash & HashMaskUnshifted) << HashBitsOffset) | ((longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1);
	header2 = classPointer;
	if ((header1 & CompactClassMask) > 0) {

		/* are contexts compact? */

		hdrSize = 1;
	}
	else {
		hdrSize = 2;
	}
	if (sizeInBytes <= SizeMask) {

		/* OR size into header1.  Must not do this if size > SizeMask */

		header1 += sizeInBytes - (header1 & SizeMask);
	}
	else {

		/* Zero the size field of header1 if large */

		hdrSize = 3;
		header1 -= header1 & SizeMask;
	}
	flag("Dan");
	/* begin allocate:headerSize:h1:h2:h3:doFill:format: */
	VM_LABEL(1allocateheaderSizeh1h2h3doFillformat);
	if (hdrSize > 1) {
		/* begin pushRemappableOop: */
		assert(addressCouldBeOop(header2));
		GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = header2;
	}
	/* begin allocateChunk: */
	VM_LABEL(2allocateChunk);
	if (GIV(allocationCount) >= GIV(allocationsBetweenGCs)) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */

	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + (sizeInBytes + ((hdrSize - 1) * BytesPerWord))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
		enoughSpace = 1;
		goto l1;
	}
	else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {

		/* signal that space is running low, but proceed with allocation if possible */

		GIV(signalLowSpace) = 1;

		/* disable additional interrupts until lowSpaceThreshold is reset by image */

		GIV(lowSpaceThreshold) = 0;
		/* begin saveProcessSignalingLowSpace */
		VM_LABEL(2saveProcessSignalingLowSpace);
		lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord));
		if (lastSavedProcess == GIV(nilObj)) {
			currentProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			oop1 = GIV(specialObjectsOop);
			if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop1, currentProc);
			}
			longAtput((oop1 + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord), currentProc);
		}
		/* begin forceInterruptCheck */
		GIV(interruptCheckCounter) = -1000;
		GIV(nextPollTick) = 0;
	}
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) < (((usqInt) ((sizeInBytes + ((hdrSize - 1) * BytesPerWord)) + BaseHeaderSize)))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(GIV(freeBlock))) & AllButTypeMask) - (sizeInBytes + ((hdrSize - 1) * BytesPerWord));
	newChunk = GIV(freeBlock);

	/* Assume: client will initialize object header of free chunk, so following is not needed: */
	/* self setSizeOfFree: newChunk to: byteSize. */

	GIV(freeBlock) += sizeInBytes + ((hdrSize - 1) * BytesPerWord);
	/* begin setSizeOfFree:to: */
	chunk = GIV(freeBlock);
	longAtput(chunk, (newFreeSize & AllButTypeMask) | HeaderTypeFree);
	GIV(allocationCount) += 1;
	newObj = newChunk;
	if (hdrSize > 1) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		remappedClassOop = oop;
	}
	if (hdrSize == 3) {
		longAtput(newObj, LargeContextSize | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, remappedClassOop | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, remappedClassOop | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (0) {
		fillWord = (0 <= 4
			? (GIV(nilObj))
			: (0));
		end = newObj + sizeInBytes;
		i = newObj + BytesPerWord;
		while (i < end) {
			longAtput(i, fillWord);
			i += BytesPerWord;
		}
	}
	if (DoAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((objectAfter(newObj)) == GIV(freeBlock))) {
			error("allocate bug: did not set header of new oop correctly");
		}
		if (!((objectAfter(GIV(freeBlock))) == GIV(endOfMemory))) {
			error("allocate bug: did not set header of freeBlock correctly");
		}
	}
	return newObj;
}


/*	This version of instantiateClass assumes that the total object 
	size is under 256 bytes, the limit for objects with only one or 
	two header words. Note that the size is specified in bytes 
	and should include 4 or 8 bytes for the base header word. 
	NOTE this code will only work for sizes that are an integral number of
	words (like not a 32-bit LargeInteger in a 64-bit system). 
	May cause a GC.
	Note that the created small object IS NOT FILLED and must be completed
	before returning it to Squeak. Since this call is used in routines that do
	jsut that we are safe. Break this rule and die.
 */

static sqInt
instantiateSmallClasssizeInBytes(sqInt classPointer, sqInt sizeInBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt currentProc;
    usqInt end;
    sqInt enoughSpace;
    sqInt fillWord;
    sqInt hash;
    sqInt hdrSize;
    sqInt header1;
    sqInt header2;
    usqInt i;
    sqInt lastSavedProcess;
    sqInt minFree;
    sqInt newChunk;
    sqInt newFreeSize;
    sqInt newObj;
    sqInt oop;
    sqInt oop1;
    sqInt remappedClassOop;

	if (!((sizeInBytes & (BytesPerWord - 1)) == 0)) {
		error("size must be integral number of words");
	}
	/* begin newObjectHash */
	GIV(lastHash) = (13849 + (27181 * GIV(lastHash))) & 65535;
	hash = GIV(lastHash);
	header1 = ((hash & HashMaskUnshifted) << HashBitsOffset) | ((longAt((classPointer + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1);
	header2 = classPointer;
	hdrSize = ((header1 & CompactClassMask) > 0
		? (1)
		: (2));
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));
	/* begin allocate:headerSize:h1:h2:h3:doFill:format: */
	VM_LABEL(2allocateheaderSizeh1h2h3doFillformat);
	if (hdrSize > 1) {
		/* begin pushRemappableOop: */
		assert(addressCouldBeOop(header2));
		GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = header2;
	}
	/* begin allocateChunk: */
	VM_LABEL(3allocateChunk);
	if (GIV(allocationCount) >= GIV(allocationsBetweenGCs)) {
		incrementalGC();
	}
	/* begin sufficientSpaceToAllocate: */

	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + (sizeInBytes + ((hdrSize - 1) * BytesPerWord))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
		enoughSpace = 1;
		goto l1;
	}
	else {
		enoughSpace = sufficientSpaceAfterGC(minFree);
		goto l1;
	}
l1:	/* end sufficientSpaceToAllocate: */;
	if (!(enoughSpace)) {

		/* signal that space is running low, but proceed with allocation if possible */

		GIV(signalLowSpace) = 1;

		/* disable additional interrupts until lowSpaceThreshold is reset by image */

		GIV(lowSpaceThreshold) = 0;
		/* begin saveProcessSignalingLowSpace */
		VM_LABEL(3saveProcessSignalingLowSpace);
		lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord));
		if (lastSavedProcess == GIV(nilObj)) {
			currentProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			oop1 = GIV(specialObjectsOop);
			if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop1, currentProc);
			}
			longAtput((oop1 + BaseHeaderSize) + (ProcessSignalingLowSpace << ShiftForWord), currentProc);
		}
		/* begin forceInterruptCheck */
		GIV(interruptCheckCounter) = -1000;
		GIV(nextPollTick) = 0;
	}
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) < (((usqInt) ((sizeInBytes + ((hdrSize - 1) * BytesPerWord)) + BaseHeaderSize)))) {
		error("out of memory");
	}
	newFreeSize = ((longAt(GIV(freeBlock))) & AllButTypeMask) - (sizeInBytes + ((hdrSize - 1) * BytesPerWord));
	newChunk = GIV(freeBlock);

	/* Assume: client will initialize object header of free chunk, so following is not needed: */
	/* self setSizeOfFree: newChunk to: byteSize. */

	GIV(freeBlock) += sizeInBytes + ((hdrSize - 1) * BytesPerWord);
	/* begin setSizeOfFree:to: */
	chunk = GIV(freeBlock);
	longAtput(chunk, (newFreeSize & AllButTypeMask) | HeaderTypeFree);
	GIV(allocationCount) += 1;
	newObj = newChunk;
	if (hdrSize > 1) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		remappedClassOop = oop;
	}
	if (hdrSize == 3) {
		longAtput(newObj, 0 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, remappedClassOop | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, remappedClassOop | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	if (0) {
		fillWord = (0 <= 4
			? (GIV(nilObj))
			: (0));
		end = newObj + sizeInBytes;
		i = newObj + BytesPerWord;
		while (i < end) {
			longAtput(i, fillWord);
			i += BytesPerWord;
		}
	}
	if (DoAssertionChecks) {
		okayOop(newObj);
		oopHasOkayClass(newObj);
		if (!((objectAfter(newObj)) == GIV(freeBlock))) {
			error("allocate bug: did not set header of new oop correctly");
		}
		if (!((objectAfter(GIV(freeBlock))) == GIV(endOfMemory))) {
			error("allocate bug: did not set header of freeBlock correctly");
		}
	}
	return newObj;
}


/*	Like #stackIntegerValue: but access method arguments left-to-right */

sqInt
integerArg(sqInt index)
{
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	/* begin checkedIntegerValueOf: */
	if ((oop & 1)) {
		return (oop >> 1);
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0;
	}
}

sqInt
integerObjectOf(sqInt value)
{
	return (value << 1) + 1;
}


/*	Translator produces 'objectPointer >> 1' */

sqInt
integerValueOf(sqInt objectPointer)
{
	if ((objectPointer & 2147483648UL) != 0) {
		return ((((usqInt) (objectPointer & 2147483647UL)) >> 1) - 1073741823) - 1;
	}
	else {
		return ((usqInt) objectPointer) >> 1;
	}
}

EXPORT(sqInt)
internalIsImmutable(sqInt oop)
{
	return ((longAt(oop)) & ImmutabilityBit) != 0;
}

EXPORT(sqInt)
internalIsMutable(sqInt oop)
{
	return ((longAt(oop)) & ImmutabilityBit) == 0;
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

sqInt
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

sqInt
isArray(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 2);
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

sqInt
isBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8);
}


/*	Answer if the given (non-immediate) object is an instance of the given
	class that may have a compactClassIndex (if compactClassIndex is
	non-zero). N.B. Inlining and/or compiler optimization should result in
	classOop not being
	accessed if compactClassIndex is non-zero. */

static sqInt
isClassOfNonImmequalTocompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	return (compactClassIndex == 0
		? ((ccIndex == 0
	? (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop)
	: (0)))
		: (compactClassIndex == ccIndex));
}


/*	Answer whether the argument object is of compiled method format */

sqInt
isCompiledMethod(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> 8) & 15) >= 12;
}

sqInt
isFloatObject(sqInt oop)
{
	return ((oop & 1) == 0)
	 && ((fetchClassOfNonInt(oop)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
}


/*	Is this a MethodContext whose meth has a primitive number of 199? */
/*	NB: the use of a primitive number for marking the method is pretty grungy,
	but it is simple to use for a test sytem, not too expensive and we don't
	actually have the two spare method header bits we need. We can probably
	obtain them when the method format is changed.
	NB 2: actually, the jitter will probably implement the prim to actually
	mark the volatile frame by changing the return function pointer.
 */

static sqInt
isHandlerMarked(sqInt aContext)
{
    sqInt header;
    sqInt meth;
    sqInt pIndex;
    sqInt primBits;

	header = longAt(aContext);
	if (!(((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		return 0;
	}
	meth = longAt((aContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((meth + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
	pIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	return pIndex == 199;
}


/*	The given object may have its header word in a forwarding block. Find 
	the value of the isImmutable flag in the object in spite of this obstacle. */

static sqInt
isImmutableWhileForwarding(sqInt oop)
{
    sqInt fwdBlock;
    sqInt header;

	header = longAt(oop);
	if ((header & MarkBit) != 0) {

		/* oop is forwarded; get its real header from its forwarding table entry */

		fwdBlock = (header & AllButMarkBitAndTypeMask) << 1;
		if (DoAssertionChecks) {
			fwdBlockValidate(fwdBlock);
		}
		header = longAt(fwdBlock + BytesPerWord);
	}
	return (header & ImmutabilityBit) != 0;
}

sqInt
isIndexable(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> 8) & 15) >= 2;
}


/*	Return true if the given address is in ST object memory */

sqInt
isInMemory(sqInt address)
{
	return ((((usqInt) address)) >= (((usqInt) memory)))
	 && ((((usqInt) address)) < (((usqInt) GIV(endOfMemory))));
}

sqInt
isIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) > 0;
}


/*	Return true if the given value can be represented as a Smalltalk integer
	value. 
 */
/*	Use a shift and XOR to set the sign bit if and only if the top two bits of
	the given value are the same, then test the sign bit. Note that the top
	two bits are equal for exactly those integers in the range that can be
	represented in 31-bits or 63-bits.
 */

sqInt
isIntegerValue(sqInt intValue)
{
	return (intValue ^ (intValue << 1)) >= 0;
}


/*	Answer if oop's mark bit is set */

sqInt
isMarked(sqInt oop)
{
	return ((longAt(oop)) & MarkBit) != 0;
}


/*	Answer whether the oop is an object of compiled method format */

sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12);
}


/*	Answer true if the argument has only fields that can hold oops. See
	comment in formatOf:
 */

sqInt
isPointers(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

static sqInt
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}


/*	Answer true if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

static sqInt
isWeakNonInt(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> 8) & 15) == 4;
}


/*	Answer true if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

sqInt
isWeak(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 4);
}


/*	Answer true if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

static sqInt
isWordsOrBytesNonInt(sqInt oop)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	return (fmt == 6)
	 || ((fmt >= 8)
	 && (fmt <= 11));
}


/*	Answer true if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

sqInt
isWordsOrBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (isWordsOrBytesNonInt(oop));
}


/*	Answer true if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

sqInt
isWords(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 6);
}

sqInt
isYoung(sqInt oop)
{
	return ((oop & 1) == 0)
	 && ((((usqInt) oop)) >= (((usqInt) GIV(youngStart))));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if compactClassIndex is
	non-zero.  */

static sqInt
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if ((oop & 1)) {
		return 0;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	return (ccIndex == 0)
	 && (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop);
}


/*	Support for external primitives. */

sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oopClass;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oopClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return 0;
}


/*	Support for external primitives. */

sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oopClass;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oopClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return 0;
}


/*	Support for external primitives */

sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oopClass;

	/* begin fetchClassOf: */
	if ((oop & 1)) {
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oopClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	return classNameOfIs(oopClass, className);
}


/*	Return the byte offset of the last pointer field of the given object. 
	Works with CompiledMethods, as well as ordinary objects. 
	Can be used even when the type bits are not correct. */

static sqInt
lastPointerOf(sqInt oop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt sp;
    sqInt sz;
    sqInt type;

	header = longAt(oop);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * BytesPerWord;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(oop);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l2;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l2;
			}
			else {
				type = HeaderTypeShort;
				goto l2;
			}
		}
	l2:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
			goto l3;
		}
		else {
			sz = header1 & SizeMask;
			goto l3;
		}
	l3:	/* end sizeBitsOfSafe: */;
		return sz - BaseHeaderSize;
	}
	if (fmt < 12) {
		return 0;
	}
	methodHeader = longAt(oop + BaseHeaderSize);
	return (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
}


/*	Return the number of indexable bytes or words in the given object. Assume
	the argument is not an integer. For a CompiledMethod, the size of the
	method header (in bytes) should be subtracted from the result.
 */

sqInt
lengthOf(sqInt oop)
{
    sqInt header;
    sqInt sz;

	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	Return the number of indexable bytes or words in the given object. Assume
	the given oop is not an integer. For a CompiledMethod, the size of the
	method header (in bytes) should be subtracted from the result of this
	method. 
 */

static sqInt
lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt)
{
    sqInt sz;

	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (fmt < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (fmt & 3);
	}
}

sqInt
literalCountOf(sqInt methodPointer)
{
	return (((usqInt) (longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255;
}

sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + ((offset + LiteralStart) << ShiftForWord));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

sqInt
loadBitBltFrom(sqInt bb)
{
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

sqInt
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;
    sqInt sched;
    sqInt tmp;

	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord));
	proc = longAt((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	GIV(activeContext) = longAt((proc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	if (GIV(activeContext) < GIV(youngStart)) {
		beRootIfOld(GIV(activeContext));
	}
	/* begin fetchContextRegisters: */
	VM_LABEL(1fetchContextRegisters);
	tmp = longAt((GIV(activeContext) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((GIV(activeContext) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = GIV(activeContext);
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (GIV(activeContext) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	GIV(reclaimableContextCount) = 0;
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and class is found in the cache, set the values of
	'newMethod' and 'primitiveFunctionPointer' and return true. Otherwise,
	return false.
 */
/*	About the re-probe scheme: The hash is the low bits of the XOR of two
	large addresses, minus their useless lowest two bits. If a probe doesn't
	get a hit, the hash is shifted right one bit to compute the next probe,
	introducing a new randomish bit. The cache is probed CacheProbeMax times
	before giving up.
 */
/*	WARNING: Since the hash computation is based on the object addresses of
	the class and selector, we must rehash or flush when compacting storage.
	We've chosen to flush, since that also saves the trouble of updating the
	addresses of the objects in the cache.
 */

static sqInt
lookupInMethodCacheSelclass(sqInt selector, sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;


	/* shift drops two low-order zeros from addresses */

	hash = selector ^ class;

	/* first probe */

	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */

	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

static sqInt
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt oop;
    sqInt oop1;
    sqInt rclass;
    sqInt sz;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
		if (dictionary == GIV(nilObj)) {
			/* begin pushRemappableOop: */
			assert(addressCouldBeOop(currentClass));
			GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = currentClass;
			createActualMessageTo(class);
			/* begin popRemappableOop */
			oop = GIV(remapBuffer)[GIV(remapBufferCount)];
			GIV(remapBufferCount) -= 1;
			currentClass = oop;
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotInterpret << ShiftForWord));
			/* begin fastLogSend: */
			if (RecordSendTrace) {
				GIV(sendTraceLog)[GIV(sendTraceLogIndex)] = GIV(messageSelector);
				sendTraceLogIndex(GIV(sendTraceLogIndex) + 1);
			}
			sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), null);
			return lookupMethodInClass(longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord)));
		}
		/* begin lookupMethodInDictionary: */
		VM_LABEL(2lookupMethodInDictionary);
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(dictionary);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(dictionary - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		mask = (length - SelectorStart) - 1;
		if ((GIV(messageSelector) & 1)) {
			index = (mask & ((GIV(messageSelector) >> 1))) + SelectorStart;
		}
		else {
			index = (mask & ((((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted)) + SelectorStart;
		}
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (index << ShiftForWord));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l2;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
				GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << ShiftForWord));
				found = 1;
				goto l2;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l2;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
	l2:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord)))) {
		error("Recursive not understood error encountered");
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(class));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = class;
	createActualMessageTo(class);
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	rclass = oop1;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord));
	if (RecordSendTrace) {
		/* begin fastLogSend: */
		if (RecordSendTrace) {
			GIV(sendTraceLog)[GIV(sendTraceLogIndex)] = GIV(messageSelector);
			sendTraceLogIndex(GIV(sendTraceLogIndex) + 1);
		}
	}
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), null);
	return lookupMethodInClass(rclass);
}


/*	This method lookup tolerates integers as Dictionary keys to 
	support execution of images in which Symbols have been 
	compacted out */

static sqInt
lookupMethodInDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt sz;
    sqInt wrapAround;

	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(dictionary);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(dictionary - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	mask = (length - SelectorStart) - 1;
	if ((GIV(messageSelector) & 1)) {
		index = (mask & ((GIV(messageSelector) >> 1))) + SelectorStart;
	}
	else {
		index = (mask & ((((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted)) + SelectorStart;
	}
	wrapAround = 0;
	while (1) {
		nextSelector = longAt((dictionary + BaseHeaderSize) + (index << ShiftForWord));
		if (nextSelector == GIV(nilObj)) {
			return 0;
		}
		if (nextSelector == GIV(messageSelector)) {
			methodArray = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
			GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << ShiftForWord));
			return 1;
		}
		index += 1;
		if (index == length) {
			if (wrapAround) {
				return 0;
			}
			wrapAround = 1;
			index = SelectorStart;
		}
	}
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

static sqInt
lookupMethodNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
		if (dictionary == GIV(nilObj)) {
			GIV(lkupClass) = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
			return SelectorCannotInterpret;
		}
		if (lookupMethodInDictionary(dictionary)) {
			addNewMethodToCache();
			return 0;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
	}
	return SelectorDoesNotUnderstand;
}


/*	Return the first free block after the given chunk in memory. */

static sqInt
lowestFreeAfter(sqInt chunk)
{
    sqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;

	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		if (oopHeaderType == HeaderTypeFree) {
			return oop;
		}
		if (oopHeaderType == HeaderTypeSizeAndClass) {
			oopSize = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
		}
		else {
			oopSize = oopHeader & SizeMask;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	error("expected to find at least one free object");
	return null;
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed
 */

sqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{
    sqInt pointResult;

	pointResult = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((xValue << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((yValue << 1) | 1));
	return pointResult;
}


/*	Use the forwarding table to update the pointers of all non-free objects in
	the given range of memory. Also remap pointers in root objects which may
	contains pointers into the given memory range, and don't forget to flush
	the method cache based on the range
 */

static void
mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt oop;
    sqInt oop1;
    sqInt probe;

	/* begin mapInterpreterOops */
	VM_LABEL(0mapInterpreterOops);
	GIV(nilObj) = remap(GIV(nilObj));
	GIV(falseObj) = remap(GIV(falseObj));
	GIV(trueObj) = remap(GIV(trueObj));
	GIV(specialObjectsOop) = remap(GIV(specialObjectsOop));

	/* *rel to active */

	GIV(stackPointer) -= GIV(activeContext);
	GIV(activeContext) = remap(GIV(activeContext));

	/* *rel to active */

	GIV(stackPointer) += GIV(activeContext);
	GIV(theHomeContext) = remap(GIV(theHomeContext));

	/* *rel to method */

	GIV(instructionPointer) -= GIV(method);
	GIV(method) = remap(GIV(method));

	/* *rel to method */

	GIV(instructionPointer) += GIV(method);
	GIV(receiver) = remap(GIV(receiver));
	if (!((GIV(messageSelector) & 1))) {
		GIV(messageSelector) = remap(GIV(messageSelector));
	}
	if (!((GIV(newMethod) & 1))) {
		GIV(newMethod) = remap(GIV(newMethod));
	}
	GIV(lkupClass) = remap(GIV(lkupClass));
	for (i1 = 1; i1 <= GIV(remapBufferCount); i1 += 1) {
		oop1 = GIV(remapBuffer)[i1];
		if (!((oop1 & 1))) {
			GIV(remapBuffer)[i1] = (remap(oop1));
		}
	}
	mapTraceLogs();
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!((oop & 1))) {
			(GIV(extraRoots)[i])[0] = (remap(oop));
		}
	}
	/* begin flushMethodCacheFrom:to: */
	VM_LABEL(0flushMethodCacheFromto);
	probe = 0;
	for (i2 = 1; i2 <= MethodCacheEntries; i2 += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if (((((((usqInt) (GIV(methodCache)[probe + MethodCacheSelector]))) >= (((usqInt) memStart)))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheSelector]))) < (((usqInt) memEnd))))
 || (((((usqInt) (GIV(methodCache)[probe + MethodCacheClass]))) >= (((usqInt) memStart)))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheClass]))) < (((usqInt) memEnd)))))
			 || (((((usqInt) (GIV(methodCache)[probe + MethodCacheMethod]))) >= (((usqInt) memStart)))
			 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheMethod]))) < (((usqInt) memEnd))))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	for (i2 = 1; i2 <= AtCacheTotalSize; i2 += 1) {
		GIV(atCache)[i2] = 0;
	}
	updatePointersInRootObjectsFromto(memStart, memEnd);
	updatePointersInRangeFromto(memStart, memEnd);
}


/*	The prim and send trace logs are circular buffers of selectors. If there
	is an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has
	entries. If there is something at primTraceLogIndex it has wrapped. */

static sqInt
mapTraceLogs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt remainder;
    sqInt remainder1;
    sqInt selector;

	limit = (((remainder = (GIV(primTraceLogIndex) - 1) % TraceLogSize)) < 0
		? (remainder + TraceLogSize)
		: (remainder));
	if ((GIV(primTraceLog)[limit]) == 0) {
		return null;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		limit = TraceLogSize - 1;
	}
	for (i = 0; i <= limit; i += 1) {
		selector = GIV(primTraceLog)[i];
		if (!((selector & 1))) {
			GIV(primTraceLog)[i] = (remap(selector));
		}
	}
	limit = (((remainder1 = (GIV(sendTraceLogIndex) - 1) % TraceLogSize)) < 0
		? (remainder1 + TraceLogSize)
		: (remainder1));
	if ((GIV(sendTraceLog)[limit]) == 0) {
		return null;
	}
	if ((GIV(sendTraceLog)[GIV(sendTraceLogIndex)]) != 0) {
		limit = TraceLogSize - 1;
	}
	for (i = 0; i <= limit; i += 1) {
		selector = GIV(sendTraceLog)[i];
		if (!((selector & 1))) {
			GIV(sendTraceLog)[i] = (remap(selector));
		}
	}
}


/*	The prim and send trace logs are circular buffers of selectors. If there
	is an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has
	entries. If there is something at primTraceLogIndex it has wrapped. */

static sqInt
markAndTraceTraceLogs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt remainder;
    sqInt remainder1;
    sqInt selector;

	if (RecordPrimTrace) {
		limit = (((remainder = (GIV(primTraceLogIndex) - 1) % TraceLogSize)) < 0
			? (remainder + TraceLogSize)
			: (remainder));
		if ((GIV(primTraceLog)[limit]) != 0) {
			if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
				limit = TraceLogSize - 1;
			}
			for (i = 0; i <= limit; i += 1) {
				selector = GIV(primTraceLog)[i];
				if (!((selector & 1))) {
					markAndTrace(selector);
				}
			}
		}
	}
	if (RecordSendTrace) {
		limit = (((remainder1 = (GIV(sendTraceLogIndex) - 1) % TraceLogSize)) < 0
			? (remainder1 + TraceLogSize)
			: (remainder1));
		if ((GIV(sendTraceLog)[limit]) != 0) {
			if ((GIV(sendTraceLog)[GIV(sendTraceLogIndex)]) != 0) {
				limit = TraceLogSize - 1;
			}
			for (i = 0; i <= limit; i += 1) {
				selector = GIV(sendTraceLog)[i];
				if (!((selector & 1))) {
					markAndTrace(selector);
				}
			}
		}
	}
}


/*	Mark all objects reachable from the given one.
	Trace from the given object even if it is old.
	Do not trace if it is already marked.
	Mark it only if it is a young object. */
/*	Tracer state variables:
	child		object being examined
	field		next field of child to examine
	parentField	field where child was stored in its referencing object */

void
markAndTrace(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt action;
    sqInt child;
    sqInt childType;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt field;
    sqInt fmt;
    sqInt fmt1;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header2;
    sqInt header3;
    sqInt header4;
    sqInt lastFieldOffset;
    sqInt lastFieldOffset1;
    sqInt oop1;
    sqInt parentField;
    sqInt sp;
    sqInt sp1;
    sqInt statMarkCountLocal;
    sqInt sz;
    sqInt sz1;
    sqInt type;
    sqInt type1;
    sqInt type2;
    sqInt typeBits;
    usqInt youngStartLocal;

	assert(addressCouldBeObjWhileForwarding(oop));
	header = longAt(oop);
	if (!((header & MarkBit) == 0)) {
		return;
	}
	header = (header & AllButTypeMask) | HeaderTypeGC;
	if ((((usqInt) oop)) >= (((usqInt) GIV(youngStart)))) {
		header = header | MarkBit;
	}
	longAtput(oop, header);
	parentField = GCTopMarker;
	child = oop;
	/* begin lastPointerOf:recordWeakRoot: */
	VM_LABEL(0lastPointerOfrecordWeakRoot);
	header4 = longAt(oop);
	fmt1 = (((usqInt) header4) >> 8) & 15;
	if (fmt1 <= 4) {
		if (fmt1 >= 3) {
			if (fmt1 == 4) {
				if (1) {

					/* And remember as weak root */

					GIV(weakRootCount) += 1;
					assert(GIV(weakRootCount) <= WeakRootTableSize);
					GIV(weakRoots)[GIV(weakRootCount)] = oop;
				}
				lastFieldOffset = (nonWeakFieldsOf(oop)) << ShiftForWord;
				goto l14;
			}
			if ((((((usqInt) header4) >> 12) & 31) == 13)
			 || (((((usqInt) header4) >> 12) & 31) == 14)) {
				/* begin fetchStackPointerOf: */
				sp1 = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
				if (!((sp1 & 1))) {
					contextSize1 = 0;
					goto l11;
				}
				contextSize1 = (sp1 >> 1);
			l11:	/* end fetchStackPointerOf: */;
				lastFieldOffset = (CtxtTempFrameStart + contextSize1) * BytesPerWord;
				goto l14;
			}
		}
		/* begin sizeBitsOfSafe: */
		header12 = longAt(oop);
		/* begin rightType: */
		if ((header12 & SizeMask) == 0) {
			type2 = HeaderTypeSizeAndClass;
			goto l12;
		}
		else {
			if ((header12 & CompactClassMask) == 0) {
				type2 = HeaderTypeClass;
				goto l12;
			}
			else {
				type2 = HeaderTypeShort;
				goto l12;
			}
		}
	l12:	/* end rightType: */;
		if (type2 == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
			goto l13;
		}
		else {
			sz1 = header12 & SizeMask;
			goto l13;
		}
	l13:	/* end sizeBitsOfSafe: */;
		lastFieldOffset = sz1 - BaseHeaderSize;
		goto l14;
	}
	if (fmt1 < 12) {
		lastFieldOffset = 0;
		goto l14;
	}
	lastFieldOffset = (((((usqInt) (longAt((oop + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l14:	/* end lastPointerOf:recordWeakRoot: */;
	field = oop + lastFieldOffset;
	action = StartField;
	youngStartLocal = GIV(youngStart);

	/* run the tracer state machine until all objects reachable from oop are marked */

	statMarkCountLocal = GIV(statMarkCount);
	do {
		if (action == StartField) {
			/* begin startField */
			VM_LABEL(0startField);
					while (1) {
				child = longAt(field);
				if (!((child & 1))) break;
				field -= BytesPerWord;
			}
			typeBits = child & TypeMask;
			if (typeBits == 0) {
				longAtput(field, parentField);
				parentField = field;
				action = StartObj;
				goto l2;
			}
			assert(typeBits == 2);
			if ((child & CompactClassMask) != 0) {

				/* object's class is compact; we're done */
				/* restore the header type bits */

				child = child & AllButTypeMask;
				/* begin rightType: */
				if ((child & SizeMask) == 0) {
					childType = HeaderTypeSizeAndClass;
					goto l1;
				}
				else {
					if ((child & CompactClassMask) == 0) {
						childType = HeaderTypeClass;
						goto l1;
					}
					else {
						childType = HeaderTypeShort;
						goto l1;
					}
				}
			l1:	/* end rightType: */;
				longAtput(field, child | childType);
				action = Upward;
				goto l2;
			}

			/* class word */

			child = longAt(field - BytesPerWord);

			/* clear type bits */

			child = child & AllButTypeMask;
			longAtput(field - BytesPerWord, parentField);

			/* point at class word; mark as working on the class.  */

			parentField = (field - BytesPerWord) | 1;
			action = StartObj;
		l2:	/* end startField */;
		}
		if (action == StartObj) {
			/* begin startObj */
			statMarkCountLocal += 1;
			if (((((usqInt) child)) < (((usqInt) youngStartLocal)))
			 || ((((header1 = longAt(child))) & MarkBit) != 0)) {

				/* already marked; skip it */

				field = child;
				action = Upward;
				goto l3;
			}
			/* begin lastPointerOf:recordWeakRoot: */
			VM_LABEL(1lastPointerOfrecordWeakRoot);
			oop1 = child;
			header3 = longAt(oop1);
			fmt = (((usqInt) header3) >> 8) & 15;
			if (fmt <= 4) {
				if (fmt >= 3) {
					if (fmt == 4) {
						if (0) {

							/* And remember as weak root */

							GIV(weakRootCount) += 1;
							assert(GIV(weakRootCount) <= WeakRootTableSize);
							GIV(weakRoots)[GIV(weakRootCount)] = oop1;
						}
						lastFieldOffset1 = (nonWeakFieldsOf(oop1)) << ShiftForWord;
						goto l10;
					}
					if ((((((usqInt) header3) >> 12) & 31) == 13)
					 || (((((usqInt) header3) >> 12) & 31) == 14)) {
						/* begin fetchStackPointerOf: */
						sp = longAt((oop1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
						if (!((sp & 1))) {
							contextSize = 0;
							goto l7;
						}
						contextSize = (sp >> 1);
					l7:	/* end fetchStackPointerOf: */;
						lastFieldOffset1 = (CtxtTempFrameStart + contextSize) * BytesPerWord;
						goto l10;
					}
				}
				/* begin sizeBitsOfSafe: */
				header11 = longAt(oop1);
				/* begin rightType: */
				if ((header11 & SizeMask) == 0) {
					type1 = HeaderTypeSizeAndClass;
					goto l8;
				}
				else {
					if ((header11 & CompactClassMask) == 0) {
						type1 = HeaderTypeClass;
						goto l8;
					}
					else {
						type1 = HeaderTypeShort;
						goto l8;
					}
				}
			l8:	/* end rightType: */;
				if (type1 == HeaderTypeSizeAndClass) {
					sz = (longAt(oop1 - (BytesPerWord * 2))) & AllButTypeMask;
					goto l9;
				}
				else {
					sz = header11 & SizeMask;
					goto l9;
				}
			l9:	/* end sizeBitsOfSafe: */;
				lastFieldOffset1 = sz - BaseHeaderSize;
				goto l10;
			}
			if (fmt < 12) {
				lastFieldOffset1 = 0;
				goto l10;
			}
			lastFieldOffset1 = (((((usqInt) (longAt((oop1 + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
		l10:	/* end lastPointerOf:recordWeakRoot: */;
			header1 = (header1 & AllButTypeMask) | (MarkBit | HeaderTypeGC);
			longAtput(child, header1);
			field = child + lastFieldOffset1;
			action = StartField;
		l3:	/* end startObj */;
		}
		if (action == Upward) {
			/* begin upward */
			VM_LABEL(0upward);
			do {
				if ((parentField & 1) == 0) {

					/* normal */
					/* who we worked on below */

					child = field;

					/* where to put it */

					field = parentField;
					parentField = longAt(field);
					longAtput(field, child);

					/* point at header */

					field -= BytesPerWord;
					action = StartField;
					goto l6;
				}
				if (parentField == GCTopMarker) {

					/* top of the chain */

					header2 = (longAt(field)) & AllButTypeMask;
					/* begin rightType: */
					if ((header2 & SizeMask) == 0) {
						type = HeaderTypeSizeAndClass;
						goto l4;
					}
					else {
						if ((header2 & CompactClassMask) == 0) {
							type = HeaderTypeClass;
							goto l4;
						}
						else {
							type = HeaderTypeShort;
							goto l4;
						}
					}
				l4:	/* end rightType: */;
					longAtput(field, header2 | type);
					action = Done;
					goto l6;
				}

				/* oop of class */

				child = field;

				/* class word, ** clear the low bit ** */

				field = parentField - 1;
				parentField = longAt(field);

				/* base header word */

				header2 = longAt(field + BytesPerWord);
				/* begin rightType: */
				if ((header2 & SizeMask) == 0) {
					type = HeaderTypeSizeAndClass;
					goto l5;
				}
				else {
					if ((header2 & CompactClassMask) == 0) {
						type = HeaderTypeClass;
						goto l5;
					}
					else {
						type = HeaderTypeShort;
						goto l5;
					}
				}
			l5:	/* end rightType: */;
				longAtput(field, child | type);

				/* point at header */
				/* restore type bits */

				field += BytesPerWord;
				header2 = header2 & AllButTypeMask;
				longAtput(field, header2 | type);
			} while(1);
			action = null;
		l6:	/* end upward */;
		}
	} while(!(action == Done));
	GIV(statMarkCount) = statMarkCountLocal;
}


/*	Mark phase of the mark and sweep garbage collector. Set 
	the mark bits of all reachable objects. Free chunks are 
	untouched by this process. */
/*	Assume: All non-free objects are initially unmarked. Root 
	objects were unmarked when they were made roots. (Make 
	sure this stays true!!). */

static void
markPhase(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt oop;
    sqInt oop1;


	/* clear the recycled context lists */

	GIV(freeContexts) = NilContext;

	/* trace the interpreter's objects, including the active stack 
	and special objects array */

	GIV(freeLargeContexts) = NilContext;
	/* begin markAndTraceInterpreterOops */
	markAndTrace(GIV(specialObjectsOop));
	markAndTrace(GIV(activeContext));
	markAndTrace(GIV(messageSelector));
	markAndTrace(GIV(newMethod));
	markAndTrace(GIV(lkupClass));
	for (i1 = 1; i1 <= GIV(remapBufferCount); i1 += 1) {
		oop1 = GIV(remapBuffer)[i1];
		if (!((oop1 & 1))) {
			markAndTrace(oop1);
		}
	}
	markAndTraceTraceLogs();

	/* trace the roots */

	GIV(statSpecialMarkCount) = GIV(statMarkCount);
	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		markAndTrace(oop);
	}
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
}


/*	Return one of the objects in the SpecialObjectsArray, if in range,
	otherwise ansser nil
 */

sqInt
maybeSplObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (index < (lengthOf(GIV(specialObjectsOop)))
		? (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (index << ShiftForWord)))
		: 0);
}

sqInt
methodArgumentCount(void)
{
	return GIV(argumentCount);
}


/*	Like #stackValue: but access method arguments left-to-right */

sqInt
methodArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((index > GIV(argumentCount)) + 1) {
		fprintf(stderr,"[VM]: Attempt to access method args beyond range\n");
		printCallStack();
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0;
	}
	return longAt(GIV(stackPointer) - ((GIV(argumentCount) - index) * BytesPerWord));
}

sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt primBits;

	if (!((((GIV(newMethod) & 3) == 0)
 && (((((usqInt)GIV(newMethod))) >= memory)
 && (((((usqInt)GIV(newMethod))) < GIV(freeBlock))
 && (((longAt(GIV(newMethod))) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12))) {
		return -1;
	}
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
	return (primBits & 511) + (((usqInt) primBits) >> 19);
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

EXPORT(sqInt)
moduleUnloaded(char *aModuleName)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */

		showSurfaceFn = 0;
	}
}


/*	For access from BitBlt module & Cogit */

sqInt
nilObject(void)
{
	return GIV(nilObj);
}


/*	Return the number of non-weak fields in oop (i.e. the number of fixed
	fields). Note: The following is copied from fixedFieldsOf:format:length:
	since we do know
	the format of the oop (e.g. format = 4) and thus don't need the length.
 */

static sqInt
nonWeakFieldsOf(sqInt oop)
{
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;

	assert(isWeakNonInt(oop));
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	return (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
}


/*	Return the object or free chunk immediately following the 
	given object or free chunk in memory. Return endOfMemory 
	when enumeration is complete. */

sqInt
objectAfter(sqInt oop)
{
    sqInt header;
    sqInt sz;

	if (DoAssertionChecks) {
		if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
			error("no objects after the end of memory");
		}
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
	}
	return (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
}


/*	Like #stackObjectValue: but access method arguments left-to-right */

sqInt
objectArg(sqInt index)
{
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	return oop;
}


/*	Return the object or start of free space immediately preceeding the given
	address, object or free chunk in memory. If none, return 0. This is for
	debugging only. */

sqInt
objectBefore(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = ((((usqInt) address)) > (((usqInt) GIV(youngStart)))
		? (GIV(youngStart))
		: (memory));
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) address))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if ((((usqInt) nextObj)) >= (((usqInt) address))) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	Return the object or start of free space immediately preceeding the given
	object or free chunk in memory. If none, return 0. This is for debugging
	only.  */

sqInt
objectExactlyBefore(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = ((((usqInt) oop)) > (((usqInt) GIV(youngStart)))
		? (GIV(youngStart))
		: (memory));
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) obj))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if (nextObj == oop) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	Answer if an object is immutable and references a forwarded object. Used
	to fail become for immutable referents of becomees. */
/*	Note: The given oop may be forwarded itself, which means that its real
	header is in its forwarding table entry.
 */

static sqInt
objectIsImmutableAndReferencesForwarded(sqInt oop)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt size;
    sqInt sp;

	if (isImmutableWhileForwarding(oop)) {
		/* begin lastPointerWhileForwarding: */
		VM_LABEL(0lastPointerWhileForwarding);
		/* begin headerWhileForwardingOf: */
		header1 = longAt(oop);
		if ((header1 & MarkBit) != 0) {

			/* oop is forwarded; get its real header from its forwarding table entry */

			fwdBlock = (header1 & AllButMarkBitAndTypeMask) << 1;
			assert(fwdBlockValid(fwdBlock));
			header1 = longAt(fwdBlock + BytesPerWord);
		}
		header = header1;
		fmt = (((usqInt) header) >> 8) & 15;
		if (fmt <= 4) {
			if ((fmt == 3)
			 && ((((((usqInt) header) >> 12) & 31) == 13)
			 || (((((usqInt) header) >> 12) & 31) == 14))) {
				/* begin nacFetchStackPointerOf: */
				sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l1;
				}
				contextSize = (sp >> 1);
			l1:	/* end nacFetchStackPointerOf: */;
				assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header, fmt)));
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
				goto l2;
			}
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				size = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
			}
			else {
				size = header & SizeMask;
			}
			fieldOffset = size - BaseHeaderSize;
			goto l2;
		}
		if (fmt < 12) {
			fieldOffset = 0;
			goto l2;
		}
		methodHeader = longAt(oop + BaseHeaderSize);
		fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
	l2:	/* end lastPointerWhileForwarding: */;
		while (fieldOffset >= BaseHeaderSize) {
			fieldOop = longAt(oop + fieldOffset);
			if (((fieldOop & 1) == 0)
			 && (((longAt(fieldOop)) & MarkBit) != 0)) {
				return 1;
			}
			fieldOffset -= BytesPerWord;
		}
	}
	return 0;
}


/*	This message is deprecated but supported for a while via a tweak to
	sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead
	for new code
 */

sqInt
obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (fieldIndex << 2));
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

static sqInt
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    usqInt oop;
    sqInt sz;
    sqInt type;
    sqInt unusedBit;


	/* address and size checks */

	oop = ((usqInt) signedOop);
	if ((oop & 1)) {
		return 1;
	}
	if (!(oop < GIV(endOfMemory))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!((oop % BytesPerWord) == 0)) {
		error("oop is not a word-aligned address");
		return 0;
	}
	/* begin sizeBitsOf: */
	header = longAt(oop);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	if (!((oop + sz) < GIV(endOfMemory))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		error("oop is a free chunk, not an object");
		return 0;
	}
	if (type == HeaderTypeShort) {
		if (((((usqInt) (longAt(oop))) >> 12) & 31) == 0) {
			error("cannot have zero compact class field in a short header");
			return 0;
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= BytesPerWord)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	if (type == HeaderTypeSizeAndClass) {
		if (!((oop >= (BytesPerWord * 2))
			 && ((((longAt(oop - (BytesPerWord * 2))) & TypeMask) == type)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type)))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		error("oop has an unknown format type");
		return 0;
	}
	unusedBit = 536870912;
	if (BytesPerWord == 8) {
		unusedBit = unusedBit << 16;
		unusedBit = unusedBit << 16;
	}
	if (!(((longAt(oop)) & unusedBit) == 0)) {
		error("unused header bit 30 is set; should be zero");
		return 0;
	}
	if ((((longAt(oop)) & RootBit) == 1)
	 && (oop >= GIV(youngStart))) {
		error("root bit is set in a young object");
		return 0;
	}
	return 1;
}


/*	Compute the oop of this chunk by adding its extra header bytes. */

static sqInt
oopFromChunk(sqInt chunk)
{
	return chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
}


/*	Similar to oopHasOkayClass:, except that it only returns true or false. */

static sqInt
oopHasAcceptableClass(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    sqInt formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	if ((signedOop & 1)) {
		return 1;
	}
	oop = ((usqInt) signedOop);
	if (!(oop < GIV(freeBlock))) {
		return 0;
	}
	if (!((oop % BytesPerWord) == 0)) {
		return 0;
	}
	if (!((oop + (sizeBitsOf(oop))) < GIV(freeBlock))) {
		return 0;
	}
	oopClass = ((usqInt) (fetchClassOfNonInt(oop)));
	if ((oopClass & 1)) {
		return 0;
	}
	if (!(oopClass < GIV(freeBlock))) {
		return 0;
	}
	if (!((oopClass % BytesPerWord) == 0)) {
		return 0;
	}
	if (!((oopClass + (sizeBitsOf(oopClass))) < GIV(freeBlock))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oopClass))) >> 8) & 15) <= 4)
		 && ((lengthOf(oopClass)) >= 3))) {
		return 0;
	}
	if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8) {

		/* ignore extra bytes size bits */

		formatMask = 3072;
	}
	else {
		formatMask = 3840;
	}
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given oop has a reasonable behavior. The class
	must be a valid, non-integer oop and must not be nilObj. It must be a
	pointers object with three or more fields. Finally, the instance
	specification field of the behavior must match that of the instance.
 */

static sqInt
oopHasOkayClass(sqInt signedOop)
{
    sqInt behaviorFormatBits;
    sqInt formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	oop = ((usqInt) signedOop);
	okayOop(oop);
	oopClass = ((usqInt) (fetchClassOf(oop)));
	if ((oopClass & 1)) {
		error("a SmallInteger is not a valid class or behavior");
	}
	okayOop(oopClass);
	if (!((((oopClass & 1) == 0)
 && (((((usqInt) (longAt(oopClass))) >> 8) & 15) <= 4))
		 && ((lengthOf(oopClass)) >= 3))) {
		error("a class (behavior) must be a pointers object of size >= 3");
	}
	if (((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> 8) & 15) >= 8)) {

		/* ignore extra bytes size bits */

		formatMask = 3072;
	}
	else {
		formatMask = 3840;
	}
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		error("object and its class (behavior) formats differ");
	}
	return 1;
}


/*	Pop and return the possibly remapped object from the remap buffer. */

sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}

static sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	return top;
}


/*	Note: May be called by translated primitive code. */

sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) -= nItems * BytesPerWord;
}

sqInt
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;

	longAtput((sp = GIV(stackPointer) - ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
	Bitmap>at:, or integer>bitAnd:. */

sqInt
positive32BitIntegerFor(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newLargeInteger;

	if (integerValue >= 0) {
		if ((integerValue ^ (integerValue << 1)) >= 0) {
			return ((integerValue << 1) | 1);
		}
	}
	if (BytesPerWord == 4) {

		/* Faster instantiateSmallClass: currently only works with integral word size. */

		newLargeInteger = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), BaseHeaderSize + 4);
	}
	else {

		/* Cant use instantiateSmallClass: due to integral word requirement. */

		newLargeInteger = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), 4);
	}
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 0, integerValue & 255);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a four-byte
	LargePositiveInteger. 
 */

sqInt
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt header;
    sqInt sz;
    sqInt sz1;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		return value;
	}
	/* begin assertClassOf:is: */
	VM_LABEL(3assertClassOfis);
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l2:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		/* begin lengthOf: */
		header = longAt(oop);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz1 = header & SizeMask;
		}
		sz1 -= header & Size4Bit;
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l1;
		}
	l1:	/* end lengthOf: */;
		if (!(sz == 4)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	if (!GIV(primFailCode)) {
		return (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
	}
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
	Bitmap>at:, or integer>bitAnd:. */

sqInt
positive64BitIntegerFor(sqLong integerValue)
{
    sqInt check;
    sqInt i;
    sqInt newLargeInteger;
    sqInt value;

	if ((sizeof(integerValue)) == 4) {
		return positive32BitIntegerFor(integerValue);
	}
	check = integerValue >> 32;
	if (check == 0) {
		return positive32BitIntegerFor(integerValue);
	}
	newLargeInteger = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), BaseHeaderSize + 8);
	for (i = 0; i <= 7; i += 1) {
		value = ( integerValue >> (i * 8)) & 255;
		byteAtput((newLargeInteger + BaseHeaderSize) + i, value);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a eight-byte
	LargePositiveInteger. 
 */

sqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt header;
    sqInt i;
    sqInt sz;
    sqInt sz1;
    sqInt szsqLong;
    sqLong value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		return value;
	}
	/* begin assertClassOf:is: */
	VM_LABEL(4assertClassOfis);
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l2:	/* end assertClassOf:is: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	szsqLong = sizeof(sqLong);
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf: */;
	if (sz > szsqLong) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + BaseHeaderSize) + i)))) << (i * 8);
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

unsigned long
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? ((ccIndex == 0
	? (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))))
	: (0)))
		: (ClassLargePositiveIntegerCompactIndex == ccIndex));
	if (!(ok
		 && (((bs = lengthOf(oop))) <= (sizeof(unsigned long))))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return (((((((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)) + ((byteAt((oop + BaseHeaderSize) + 4)) << 32)) + ((byteAt((oop + BaseHeaderSize) + 5)) << 40)) + ((byteAt((oop + BaseHeaderSize) + 6)) << 48)) + ((byteAt((oop + BaseHeaderSize) + 7)) << 56);
	}
	return (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
}


/*	oop is an old object. If valueObj is young, mark the object as a root. */

static void
possibleRootStoreIntovalue(sqInt oop, sqInt valueObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if (((((usqInt) valueObj)) >= (((usqInt) GIV(youngStart))))
	 && (!((valueObj & 1)))) {
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if ((header & RootBit) == 0) {
			if (GIV(rootTableCount) < RootTableRedZone) {

				/* record oop as root only if not already recorded */
				/* record root if there is enough room in the roots 
					table  */

				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
			}
			else {
				if (GIV(rootTableCount) < RootTableSize) {

					/* we're getting in the red zone */
					/* but there's still space to record it */

					GIV(rootTableCount) += 1;
					GIV(rootTable)[GIV(rootTableCount)] = oop;
					longAtput(oop, header | RootBit);
					GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
				}
			}
		}
	}
}


/*	Ensure that there are enough forwarding blocks to 
	accomodate this become, then prepare forwarding blocks for 
	the pointer swap. Return true if successful. */
/*	Details: Doing a GC might generate enough space for 
	forwarding blocks if we're short. However, this is an 
	uncommon enough case that it is better handled by primitive 
	fail code at the Smalltalk level. */
/*	Important note on multiple references to same object - since the
	preparation of
	fwdBlocks is NOT idempotent we get VM crashes if the same object is
	referenced more
	than once in such a way as to require multiple fwdBlocks.
	oop1 forwardBecome: oop1 is ok since only a single fwdBlock is needed.
	oop1 become: oop1 would fail because the second fwdBlock woudl not have
	the actual object
	header but rather the mutated ref to the first fwdBlock.
	Further problems can arise with an array1 or array2 that refer multiply to
	the same 
	object. This would notbe expected input for programmer writen code but
	might arise from
	automatic usage such as in ImageSegment loading.
	To avoid the simple and rather common case of oop1 become*: oop1, we skip
	such pairs
	and simply avoid making fwdBlocks - it is redundant anyway
 */

static sqInt
prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt entriesAvailable;
    sqInt entriesNeeded;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt fwdBlkSize;
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt oop1;
    sqInt oop2;
    sqInt originalHeader;
    sqInt originalHeader1;
    sqInt originalHeaderType;
    sqInt originalHeaderType1;
    sqInt sp;
    sqInt sz;
    sqInt type;


	/* need enough entries for all oops */
	/* Note: Forward blocks must be quadword aligned - see fwdTableInit:. */

	entriesNeeded = ((sqInt) (lastPointerOf(array1)) >> 2);
	if (twoWayFlag) {

		/* Double the number of blocks for two-way become */

		entriesNeeded = entriesNeeded * 2;
		fwdBlkSize = BytesPerWord * 2;
	}
	else {

		/* One-way become needs backPointers in fwd blocks. */

		fwdBlkSize = BytesPerWord * 4;
	}
	entriesAvailable = fwdTableInit(fwdBlkSize);
	if (entriesAvailable < entriesNeeded) {
		initializeMemoryFirstFree(GIV(freeBlock));
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l3;
			}
			contextSize = (sp >> 1);
		l3:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l4;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(array1);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l5;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l5;
			}
			else {
				type = HeaderTypeShort;
				goto l5;
			}
		}
	l5:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(array1 - (BytesPerWord * 2))) & AllButTypeMask;
			goto l6;
		}
		else {
			sz = header1 & SizeMask;
			goto l6;
		}
	l6:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - BaseHeaderSize;
		goto l4;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l4;
	}
	methodHeader = longAt(array1 + BaseHeaderSize);
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l4:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(array1 + fieldOffset);

		/* if oop1 == oop2, no need to do any work for this pair.
			May still be other entries in the arrays though so keep looking */

		oop2 = longAt(array2 + fieldOffset);
		if (!(oop1 == oop2)) {
			/* begin fwdBlockGet: */
			GIV(fwdTableNext) += fwdBlkSize;
			if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
				fwdBlock = GIV(fwdTableNext);
				goto l2;
			}
			else {
				fwdBlock = null;
				goto l2;
			}
		l2:	/* end fwdBlockGet: */;
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			originalHeader1 = longAt(oop1);
			assert(fwdBlock != null);
			assert((originalHeader1 & MarkBit) == 0);
			originalHeaderType1 = originalHeader1 & TypeMask;
			longAtput(fwdBlock, oop2);
			longAtput(fwdBlock + BytesPerWord, originalHeader1);
			if (!twoWayFlag) {
				longAtput(fwdBlock + (BytesPerWord * 2), oop1);
			}
			longAtput(oop1, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType1));
			if (twoWayFlag) {
				/* begin fwdBlockGet: */
				GIV(fwdTableNext) += fwdBlkSize;
				if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
					fwdBlock = GIV(fwdTableNext);
					goto l1;
				}
				else {
					fwdBlock = null;
					goto l1;
				}
			l1:	/* end fwdBlockGet: */;
				/* begin initForwardBlock:mapping:to:withBackPtr: */
				originalHeader = longAt(oop2);
				assert(fwdBlock != null);
				assert((originalHeader & MarkBit) == 0);
				originalHeaderType = originalHeader & TypeMask;
				longAtput(fwdBlock, oop1);
				longAtput(fwdBlock + BytesPerWord, originalHeader);
				if (!twoWayFlag) {
					longAtput(fwdBlock + (BytesPerWord * 2), oop2);
				}
				longAtput(oop2, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType));
			}
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}

static sqInt
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    sqInt sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

static sqInt
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = err;
	}
	return null;
}

static sqInt
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  f;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(0popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(5assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = atan(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. This version fails for immutables. */

static sqInt
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHashforceImmutables(rcvr, arg, 1, 1, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. This version succeeds for immutables. */

static sqInt
primitiveArrayBecomeForceImmutables(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHashforceImmutables(rcvr, arg, 1, 1, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. This version fails for immutables. */

static sqInt
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHashforceImmutables(rcvr, arg, 0, 1, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third
	argument whether to copy the receiver's identity hash over
	the argument's identity hash. This version fails for immutables. */

static sqInt
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt copyHash;
    sqInt ec;
    sqInt rcvr;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHash = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		copyHash = 0;
		goto l1;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	copyHash = null;
l1:	/* end booleanValueOf: */;
	arg = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	ec = becomewithtwoWaycopyHashforceImmutables(rcvr, arg, 0, copyHash, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. This version succeeds for immutables. */

static sqInt
primitiveArrayBecomeOneWayForceImmutables(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHashforceImmutables(rcvr, arg, 0, 1, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
}

static sqInt
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    double  f;
    sqInt integerPointer;
    sqInt object;
    sqInt sp;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		arg = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = ((double) arg);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

static sqInt
primitiveAsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	/* begin success: */
	if (!(!((thisReceiver & 1)))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), ((((((usqInt) (longAt(thisReceiver))) >> HashBitsOffset) & HashMaskUnshifted) << 1) | 1));
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveAt(void)
{
	commonAt(0);
}

static sqInt
primitiveAtEnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt limit;
    sqInt sp;
    sqInt sp1;
    sqInt stream;
    sqInt successBoolean;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	stream = top;
	/* begin success: */
	successBoolean = (((stream & 1) == 0)
 && (((((usqInt) (longAt(stream))) >> 8) & 15) <= 4))
	 && ((lengthOf(stream)) >= (StreamReadLimitIndex + 1));
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		index = fetchIntegerofObject(StreamIndexIndex, stream);
		limit = fetchIntegerofObject(StreamReadLimitIndex, stream);
	}
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (index >= limit) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

static sqInt
primitiveAtPut(void)
{
	commonAtPut(0);
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

static sqInt
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt i;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;

	flag("Dan");
	if (BytesPerWord == 8) {
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
		return null;
	}
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) - (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin success: */
	successBoolean7 = (((cursorObj & 1) == 0)
 && (((((usqInt) (longAt(cursorObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(cursorObj)) >= 5);
	if (!(successBoolean7)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0 << ShiftForWord));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4 << ShiftForWord));
	}
	/* begin success: */
	successBoolean8 = (((offsetObj & 1) == 0)
 && (((((usqInt) (longAt(offsetObj))) >> 8) & 15) <= 4))
	 && ((lengthOf(offsetObj)) >= 2);
	if (!(successBoolean8)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		/* begin success: */
		successBoolean = (extentX == 16)
		 && ((extentY == 16)
		 && (depth == 1));
		if (!(successBoolean)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		/* begin success: */
		successBoolean1 = (offsetX >= -16)
		 && (offsetX <= 0);
		if (!(successBoolean1)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		/* begin success: */
		successBoolean2 = (offsetY >= -16)
		 && (offsetY <= 0);
		if (!(successBoolean2)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		/* begin success: */
		successBoolean3 = (((bitsObj & 1) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6))
		 && ((lengthOf(bitsObj)) == 16);
		if (!(successBoolean3)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		cursorBitsIndex = bitsObj + BaseHeaderSize;
		;
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean6 = (((maskObj & 1) == 0)
 && (((((usqInt) (longAt(maskObj))) >> 8) & 15) <= 4))
		 && ((lengthOf(maskObj)) >= 5);
		if (!(successBoolean6)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0 << ShiftForWord));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean4 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!(successBoolean4)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (((bitsObj & 1) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 8) & 15) == 6))
			 && ((lengthOf(bitsObj)) == 16);
			if (!(successBoolean5)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			ioSetCursor(cursorBitsIndex, offsetX, offsetY);
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable. */

static sqInt
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(GIV(stackPointer));
	/* begin success: */
	successBoolean = (((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))
	 && ((lengthOf(rcvr)) >= 4);
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) GIV(specialObjectsOop))) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), rcvr);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord), rcvr);
	}
}


/*	make the basic beep noise */

static sqInt
primitiveBeep(void)
{
	ioBeep();
}

static sqInt
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver & integerArgument);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver | integerArgument);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerReceiver;
    sqInt object;
    sqInt shifted;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top2;

	/* begin popInteger */
	/* begin popStack */
	top2 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top2;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	integerReceiver = positive32BitValueOf(top);
	if (!GIV(primFailCode)) {
		if (integerArgument >= 0) {
			/* begin success: */
			if (!(integerArgument <= 31)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			shifted = integerReceiver << integerArgument;
			/* begin success: */
			if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!(integerArgument >= -31)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			shifted = ((integerArgument < 0) ? ((usqInt) integerReceiver >> -integerArgument) : ((usqInt) integerReceiver << integerArgument));
		}
	}
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(shifted);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver ^ integerArgument);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveBlockCopy(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt contextSize;
    sqInt header;
    sqInt initialIP;
    sqInt methodContext;
    sqInt newContext;
    sqInt oop;
    sqInt sp;

	context = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (((longAt((context + BaseHeaderSize) + (MethodIndex << ShiftForWord))) & 1)) {

		/* context is a block; get the context of its enclosing method */

		methodContext = longAt((context + BaseHeaderSize) + (HomeIndex << ShiftForWord));
	}
	else {
		methodContext = context;
	}
	/* begin sizeBitsOf: */
	header = longAt(methodContext);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		contextSize = (longAt(methodContext - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		contextSize = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;

	/* context is no longer needed and is not preserved across allocation */
	/* remap methodContext in case GC happens during allocation */

	context = null;
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(methodContext));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = methodContext;
	newContext = instantiateContextsizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockContext << ShiftForWord)), contextSize);
	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	methodContext = oop;

	/* Was instructionPointer + 3, but now it's greater by 1 due to preIncrement */
	/* Assume: have just allocated a new context; it must be young.
	 Thus, can use uncheck stores. See the comment in fetchContextRegisters. */

	initialIP = (((((GIV(instructionPointer) + 1) + 3) - (GIV(method) + BaseHeaderSize)) << 1) | 1);
	longAtput((newContext + BaseHeaderSize) + (InitialIPIndex << ShiftForWord), initialIP);
	longAtput((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), initialIP);
	/* begin storeStackPointerValue:inContext: */
	longAtput((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((0 << 1) | 1));
	longAtput((newContext + BaseHeaderSize) + (BlockArgumentCountIndex << ShiftForWord), longAt(GIV(stackPointer) - (0 * BytesPerWord)));
	longAtput((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord), methodContext);
	longAtput((newContext + BaseHeaderSize) + (SenderIndex << ShiftForWord), GIV(nilObj));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), newContext);
	GIV(stackPointer) = sp;
}


/*	Return a double from the given byte offset in a ByteArray. */

EXPORT(sqInt)
primitiveByteArrayDoubleAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt byteOffset;
    double  floatValue;
    sqInt integerPointer;
    sqInt object;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		byteOffset = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteOffset = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l1;
	}
	rcvr = oop;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	addr = addressOfstartingAtsize(rcvr, byteOffset, 8);
	if (GIV(primFailCode)) {
		return 0;
	}
	((int*)(&floatValue))[0] = ((int*)addr)[0];
	((int*)(&floatValue))[1] = ((int*)addr)[1];
	/* begin pop: */
	GIV(stackPointer) -= 2 * BytesPerWord;
	/* begin pushFloat: */
	/* begin push: */
	object = floatObjectOf(floatValue);
	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
	return null;
}


/*	Store a Double at given byte offset in a ByteArray. */

EXPORT(sqInt)
primitiveByteArrayDoubleAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt byteOffset;
    sqInt floatOop;
    double  floatValue;
    sqInt integerPointer;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;

	floatOop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((floatOop & 1)) {
		floatValue = ((double) ((floatOop >> 1)));
	}
	else {
		floatValue = ((double) (floatValueOf(floatOop)));
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		byteOffset = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteOffset = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l1;
	}
	rcvr = oop;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	addr = addressOfstartingAtsize(rcvr, byteOffset, 8);
	if (GIV(primFailCode)) {
		return 0;
	}
	if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	((int*)addr)[0] = ((int*)(&floatValue))[0];
	((int*)addr)[1] = ((int*)(&floatValue))[1];
	/* begin pop: */
	GIV(stackPointer) -= 3 * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), floatOop);
	GIV(stackPointer) = sp;
	return null;
}


/*	Return a Float from the given byte offset in a ByteArray. */

EXPORT(sqInt)
primitiveByteArrayFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt byteOffset;
    float  floatValue;
    sqInt integerPointer;
    sqInt object;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		byteOffset = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteOffset = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l1;
	}
	rcvr = oop;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	addr = addressOfstartingAtsize(rcvr, byteOffset, 4);
	if (GIV(primFailCode)) {
		return 0;
	}
	((int*)(&floatValue))[0] = ((int*)addr)[0];
	/* begin pop: */
	GIV(stackPointer) -= 2 * BytesPerWord;
	/* begin pushFloat: */
	/* begin push: */
	object = floatObjectOf(floatValue);
	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
	return null;
}


/*	Store a Float at the given byteOffset in a ByteArray */

EXPORT(sqInt)
primitiveByteArrayFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt byteOffset;
    sqInt floatOop;
    float  floatValue;
    sqInt integerPointer;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;

	floatOop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((floatOop & 1)) {
		floatValue = ((float) ((floatOop >> 1)));
	}
	else {
		floatValue = ((float) (floatValueOf(floatOop)));
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		byteOffset = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteOffset = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l1;
	}
	rcvr = oop;
l1:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	addr = addressOfstartingAtsize(rcvr, byteOffset, 4);
	if (GIV(primFailCode)) {
		return 0;
	}
	if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	((int*)addr)[0] = ((int*)(&floatValue))[0];
	/* begin pop: */
	GIV(stackPointer) -= 3 * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), floatOop);
	GIV(stackPointer) = sp;
	return null;
}


/*	Store a (signed or unsigned) n byte integer at the given byte offset. */

EXPORT(sqInt)
primitiveByteArrayNByteIIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt isSigned;
    sqInt max;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;
    sqInt value;
    sqInt valueOop;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer) - (0 * BytesPerWord))) == GIV(trueObj)) {
		isSigned = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer) - (0 * BytesPerWord))) == GIV(falseObj)) {
		isSigned = 0;
		goto l1;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	isSigned = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		byteSize = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteSize = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	valueOop = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		byteOffset = (integerPointer1 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteOffset = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (4 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l2;
	}
	rcvr = oop;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	if (!((byteOffset > 0)
		 && ((byteSize == 1)
		 || ((byteSize == 2)
		 || (byteSize == 4))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	addr = addressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (GIV(primFailCode)) {
		return 0;
	}
	if (isSigned) {
		value = signed32BitValueOf(valueOop);
	}
	else {
		value = positive32BitValueOf(valueOop);
	}
	if (GIV(primFailCode)) {
		return 0;
	}
	if (byteSize < 4) {
		if (isSigned) {
			max = 1 << ((8 * byteSize) - 1);
			if (value >= max) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
			if (value < (0 - max)) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
		}
		else {
			if (value >= (1 << (8 * byteSize))) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
		}
		if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoModification;
			return null;
		}
		if (byteSize == 1) {
			byteAtput(addr, value);
		}
		else {
			*((short int *) addr) = value;
		}
	}
	else {
		if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoModification;
			return null;
		}
		longAtput(addr, value);
	}
	/* begin pop: */
	GIV(stackPointer) -= 5 * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), valueOop);
	GIV(stackPointer) = sp;
	return null;
}


/*	Return a (signed or unsigned) n byte integer from the given byte offset. */

EXPORT(sqInt)
primitiveByteArrayNByteIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt isSigned;
    sqInt mask;
    sqInt oop;
    sqInt rcvr;
    sqInt sp;
    sqInt value;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer) - (0 * BytesPerWord))) == GIV(trueObj)) {
		isSigned = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer) - (0 * BytesPerWord))) == GIV(falseObj)) {
		isSigned = 0;
		goto l1;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	isSigned = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		byteSize = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteSize = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		byteOffset = (integerPointer1 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		byteOffset = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l2;
	}
	rcvr = oop;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	if (!((byteOffset > 0)
		 && ((byteSize == 1)
		 || ((byteSize == 2)
		 || (byteSize == 4))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	addr = addressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (GIV(primFailCode)) {
		return 0;
	}
	if (byteSize < 4) {
		if (byteSize == 1) {

			/* short/byte */

			value = byteAt(addr);
		}
		else {
			value = *((unsigned short int *) addr);
		}
		if (isSigned) {

			/* sign extend value */

			mask = 1 << ((byteSize * 8) - 1);
			value = (value & (mask - 1)) - (value & mask);
		}
		value = ((value << 1) | 1);
	}
	else {

		/* general 32 bit integer */

		value = longAt(addr);
		if (isSigned) {
			value = signed32BitIntegerFor(value);
		}
		else {
			value = positive32BitIntegerFor(value);
		}
	}
	/* begin pop: */
	GIV(stackPointer) -= 4 * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), value);
	GIV(stackPointer) = sp;
	return null;
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be preceeded by a full 
	or incremental garbage collection. */

static sqInt
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    sqInt sp;
    sqInt sp1;

	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), ((((longAt(GIV(freeBlock))) & AllButTypeMask) << 1) | 1));
		GIV(stackPointer) = sp;
		return null;
	}
	if (GIV(argumentCount) == 1) {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!(!GIV(primFailCode))) {
			return null;
		}
		/* begin pop:thenPushInteger: */
		integerVal = ((longAt(GIV(freeBlock))) & AllButTypeMask) + (sqMemoryExtraBytesLeft(aBool));
		longAtput((sp1 = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((integerVal << 1) | 1));
		GIV(stackPointer) = sp1;
		return null;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	return null;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

static sqInt
primitiveCalloutToFFI(void)
{
    static void *function = 0;
    static char *functionName = "primitiveCallout";
    static char *moduleName = "SqueakFFIPrims";

	if (function == 0) {
		function = ioLoadExternalFunctionOfLengthFromModuleOfLength(oopForPointer(functionName), 16, oopForPointer(moduleName), 14);
		if (function == 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	return ((sqInt (*)(void))function)();
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if receiver
	or argument are SmallIntegers, or the receiver is an instance of a compact
	class and
	the argument isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

static sqInt
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt ccIndex;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (!(!GIV(primFailCode))) {
		return null;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(arg))) >> 12) & 31)) == 0) {
		argClass = (longAt(arg - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		argClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end fetchClassOfNonInt: */;
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = err;
	}
	return null;
}

static sqInt
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt instance;
    sqInt oop;
    sqInt sp;

	instance = longAt(GIV(stackPointer));
	/* begin pop:thenPush: */
	/* begin fetchClassOf: */
	if ((instance & 1)) {
		oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(instance))) >> 12) & 31)) == 0) {
		oop = (longAt(instance - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Void the VM profile histograms. */

static sqInt
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

static sqInt
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    sqInt sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & 1) == 0)
			 && (((((usqInt) (longAt(s))) >> 8) & 15) >= 8))) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) -= 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		if (!(sufficientSpaceToAllocate(sz))) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Return a shallow copy of the receiver. */

static sqInt
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newCopy;
    sqInt sp;

	newCopy = clone(longAt(GIV(stackPointer)));
	if (newCopy == 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}

static sqInt
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copiedValues;
    sqInt header;
    sqInt i;
    sqInt initialIP;
    sqInt integerPointer;
    sqInt newClosure;
    sqInt newClosure1;
    sqInt numArgs;
    sqInt numCopiedValues;
    sqInt sp;
    sqInt sz;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		numArgs = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		numArgs = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	copiedValues = longAt(GIV(stackPointer));
	if (!((fetchClassOf(copiedValues)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord))))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(copiedValues);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(copiedValues - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	numCopiedValues = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	/* begin closureNumArgs:instructionPointer:numCopiedValues: */
	initialIP = (GIV(instructionPointer) + 2) - (GIV(method) + BaseHeaderSize);

	/* Assume: have just allocated a new closure; it must be young. Thus, can use unchecked stores. */

	newClosure1 = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBlockClosure << ShiftForWord)), (BytesPerWord * (ClosureFirstCopiedValueIndex + numCopiedValues)) + BaseHeaderSize);
	longAtput((newClosure1 + BaseHeaderSize) + (ClosureStartPCIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput((newClosure1 + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord), ((numArgs << 1) | 1));
	newClosure = newClosure1;
	longAtput((newClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord), longAt(GIV(stackPointer) - (2 * BytesPerWord)));
	if (numCopiedValues > 0) {

		/* Allocation may have done a GC and copiedValues may have moved. */

		copiedValues = longAt(GIV(stackPointer));
		for (i = 0; i <= (numCopiedValues - 1); i += 1) {
			longAtput((newClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << ShiftForWord), longAt((copiedValues + BaseHeaderSize) + (i << ShiftForWord)));
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), newClosure);
	GIV(stackPointer) = sp;
}

static sqInt
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockArgumentCount;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt outerContext;

	blockClosure = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	blockArgumentCount = ((longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord))) >> 1);
	if (!(GIV(argumentCount) == blockArgumentCount)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (!(((outerContext & 1) == 0)
		 && ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 13)
		 || (((((usqInt) (longAt(outerContext))) >> 12) & 31) == 14)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	activateNewClosureMethod(blockClosure);
	/* begin quickCheckForInterrupts */
	if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
		checkForInterrupts();
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. */

static sqInt
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockArgumentCount;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt outerContext;

	blockClosure = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	blockArgumentCount = ((longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord))) >> 1);
	if (!(GIV(argumentCount) == blockArgumentCount)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (!(((outerContext & 1) == 0)
		 && ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 13)
		 || (((((usqInt) (longAt(outerContext))) >> 12) & 31) == 14)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	activateNewClosureMethod(blockClosure);
}

static sqInt
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt blockArgumentCount;
    sqInt blockClosure;
    sqInt closureMethod;
    sqInt cntxSize;
    sqInt header;
    sqInt header1;
    sqInt index;
    sqInt outerContext;
    sqInt sp;
    sqInt sz;
    sqInt sz1;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header1 = longAt(GIV(activeContext));
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(GIV(activeContext) - (BytesPerWord * 2))) & LongSizeMask;
		goto l2;
	}
	else {
		sz1 = header1 & SizeMask;
		goto l2;
	}
l2:	/* end sizeBitsOf: */;
	cntxSize = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
	if (!(((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) + arraySize) < cntxSize)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	blockClosure = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	blockArgumentCount = ((longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << ShiftForWord))) >> 1);
	if (!(arraySize == blockArgumentCount)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << ShiftForWord));
	if (!(((outerContext & 1) == 0)
		 && ((((((usqInt) (longAt(outerContext))) >> 12) & 31) == 13)
		 || (((((usqInt) (longAt(outerContext))) >> 12) & 31) == 14)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 8) & 15) >= 12))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	GIV(argumentCount) = arraySize;
	activateNewClosureMethod(blockClosure);
	/* begin quickCheckForInterrupts */
	if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
		checkForInterrupts();
	}
}


/*	Fill the receiver, which must be an indexable bytes or words 
	objects, with the given integer value. */

static sqInt
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt end;
    sqInt fillValue;
    sqInt i;
    sqInt rcvr;
    sqInt rcvrIsBytes;
    sqInt successBoolean;
    sqInt successBoolean1;

	fillValue = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr & 1) == 0)
	 && (isWordsOrBytesNonInt(rcvr));
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	rcvrIsBytes = ((rcvr & 1) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) >= 8);
	if (rcvrIsBytes) {
		/* begin success: */
		successBoolean = (fillValue >= 0)
		 && (fillValue <= 255);
		if (!(successBoolean)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		end = rcvr + (sizeBitsOf(rcvr));
		i = rcvr + BaseHeaderSize;
		if (rcvrIsBytes) {
			while (i < end) {
				byteAtput(i, fillValue);
				i += 1;
			}
		}
		else {
			while (i < end) {
				long32Atput(i, fillValue);
				i += 4;
			}
		}
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

static sqInt
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    sqInt sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (((onOffBar = longAt(GIV(stackPointer) - (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class. 
	Fail if the receiver or argument are non-pointer objects.
	Fail if receiver and argument have different lengths (for indexable
	objects).  */

static sqInt
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt header;
    sqInt i;
    sqInt length;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt sz;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return null;
	}
	if (!(((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!((fetchClassOf(rcvr)) == (fetchClassOf(arg)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		length = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l3;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		length = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l3;
	}
	else {
		length = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	if (!(length == (lengthOf(arg)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	for (i = 0; i <= (length - 1); i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(rcvr, longAt((arg + BaseHeaderSize) + (i << ShiftForWord)));
		}
		longAtput((rcvr + BaseHeaderSize) + (i << ShiftForWord), longAt((arg + BaseHeaderSize) + (i << ShiftForWord)));
	}
	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

static sqInt
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integer = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

static sqInt
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    sqInt sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) - (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((quotient ^ (quotient << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
}

static sqInt
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if (((integerReceiver / integerArgument) ^ ((integerReceiver / integerArgument) << 1)) >= 0) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), (((integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
}

static sqInt
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt cntxSize;
    sqInt deltaIfSuccess;
    sqInt header;
    sqInt header1;
    sqInt index;
    sqInt integerPointer;
    sqInt nArgs;
    sqInt oop;
    sqInt primIdx;
    sqInt savedContext;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt sz1;

	argumentArray = longAt(GIV(stackPointer));
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(argumentArray);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header1 = longAt(GIV(activeContext));
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(GIV(activeContext) - (BytesPerWord * 2))) & LongSizeMask;
		goto l2;
	}
	else {
		sz1 = header1 & SizeMask;
		goto l2;
	}
l2:	/* end sizeBitsOf: */;
	cntxSize = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
	/* begin success: */
	if (!(((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) + arraySize) < cntxSize)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		primIdx = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		primIdx = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void *) (primitiveTable[primIdx]));
	if (primitiveFunctionPointer == 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin pop: */
	GIV(stackPointer) -= 2 * BytesPerWord;
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= GIV(argumentCount)) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(argumentArray));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = argumentArray;

	/* Run the primitive (sets primFailCode) */

	GIV(lkupClass) = GIV(nilObj);
	/* begin slowPrimitiveResponse */
	VM_LABEL(1slowPrimitiveResponse);
	if (FailImbalancedPrimitives) {
		savedContext = GIV(activeContext);
		nArgs = GIV(argumentCount);
		deltaIfSuccess = (GIV(stackPointer) - (GIV(argumentCount) * BytesPerOop)) - GIV(activeContext);
	}
	/* begin fastLogPrim: */
	if (RecordPrimTrace) {
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	if (FailImbalancedPrimitives
	 && ((!GIV(primFailCode))
	 && (savedContext == GIV(activeContext)))) {
		if ((GIV(stackPointer) - GIV(activeContext)) != deltaIfSuccess) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			warning("failing primitive due to unbalanced stack");
			GIV(stackPointer) = (GIV(activeContext) + deltaIfSuccess) + (nArgs * BytesPerOop);
			failUnbalancedPrimitive();
		}
	}
	!GIV(primFailCode);
	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	argumentArray = oop;
	if (!(!GIV(primFailCode))) {
		/* begin pop: */
		GIV(stackPointer) -= arraySize * BytesPerWord;
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), ((primIdx << 1) | 1));
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) + BytesPerWord), argumentArray);
		GIV(stackPointer) = sp2;
		GIV(argumentCount) = 2;
	}
}

static sqInt
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    sqInt sp;
    sqInt sp1;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerReceiver = top1;
	/* begin compare31or32Bits:equal: */
	if (((integerReceiver & 1))
	 && ((integerArgument & 1))) {
		result = integerReceiver == integerArgument;
		goto l1;
	}
	result = (positive32BitValueOf(integerReceiver)) == (positive32BitValueOf(integerArgument));
l1:	/* end compare31or32Bits:equal: */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (result) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}


/*	is the receiver the same object as the argument? */

static sqInt
primitiveEquivalent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    sqInt sp;
    sqInt sp1;
    sqInt thisObject;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	otherObject = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	thisObject = top1;
	/* begin pushBool: */
	if (thisObject == otherObject) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp1;
	}
}

sqInt
primitiveErrorTable(void)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord));
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

EXPORT(sqInt)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt enabled;
    sqInt sp;
    sqInt sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), (enabled
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp;
		return null;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				return null;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), (enabled
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp1;
		return null;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

static sqInt
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt initialIP;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt newContext;
    sqInt nilOop;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt tempCount;
    sqInt tmp;
    sqInt top;
    sqInt where;

	methodArgument = longAt(GIV(stackPointer));
	if (!(((methodArgument & 1) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> 8) & 15) >= 12))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	if (!((GIV(argumentCount) - 1) == ((((usqInt) (longAt((methodArgument + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return null;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	GIV(newMethod) = top;
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void *) (primitiveTable[primitiveIndex]));

	/* We set the messageSelector for executeMethod below since things
	 like the at cache read messageSelector and so it cannot be left stale. */

	GIV(argumentCount) -= 1;
	GIV(messageSelector) = GIV(nilObj);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	VM_LABEL(0activateNewMethod);
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where = newContext + BaseHeaderSize;
	longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
	longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
	longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
	longAtput(where + (ClosureIndex << ShiftForWord), GIV(nilObj));
	for (i = 0; i <= GIV(argumentCount); i += 1) {
		longAtput(where + ((ReceiverIndex + i) << ShiftForWord), longAt(GIV(stackPointer) - ((GIV(argumentCount) - i) * BytesPerWord)));
	}
	nilOop = GIV(nilObj);
	for (i = ((GIV(argumentCount) + 1) + ReceiverIndex); i <= (tempCount + ReceiverIndex); i += 1) {
		longAtput(where + (i << ShiftForWord), nilOop);
	}
	if (GIV(primFailCode) > 0) {
		if (((primitiveIndexOfMethodHeader(methodHeader)) > 0)
		 && ((byteAt((GIV(newMethod) + BaseHeaderSize) + (initialIP - 1))) == 129)) {
			errorCode = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord))) + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
			longAtput(where + ((tempCount + ReceiverIndex) << ShiftForWord), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	GIV(reclaimableContextCount) += 1;
	/* begin newActiveContext: */
	VM_LABEL(0newActiveContext);
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if (newContext < GIV(youngStart)) {
		beRootIfOld(newContext);
	}
	GIV(activeContext) = newContext;
	/* begin fetchContextRegisters: */
	VM_LABEL(2fetchContextRegisters);
	tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = newContext;
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	/* begin quickCheckForInterrupts */
	if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
		checkForInterrupts();
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

static sqInt
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt initialIP;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt newContext;
    sqInt nilOop;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt sp;
    sqInt tempCount;
    sqInt tmp;
    sqInt where;

	methodArgument = longAt(GIV(stackPointer));
	argumentArray = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (!((((methodArgument & 1) == 0)
 && (((((usqInt) (longAt(methodArgument))) >> 8) & 15) >= 12))
		 && (((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	argCnt = (((usqInt) (longAt((methodArgument + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15;
	if (!(argCnt == (fetchWordLengthOf(argumentArray)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return null;
	}
	if (GIV(argumentCount) > 2) {
		if (GIV(argumentCount) > 4) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return null;
		}
		longAtput(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord), longAt(GIV(stackPointer) - (2 * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	for (i = 0; i <= (argCnt - 1); i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (i << ShiftForWord)));
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	/* begin primitiveIndexOf: */
	primBits = (((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
	primitiveIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void *) (primitiveTable[primitiveIndex]));

	/* We set the messageSelector for executeMethod below since things
	 like the at cache read messageSelector and so it cannot be left stale. */

	GIV(argumentCount) = argCnt;
	GIV(messageSelector) = GIV(nilObj);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	VM_LABEL(1activateNewMethod);
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where = newContext + BaseHeaderSize;
	longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
	longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
	longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
	longAtput(where + (ClosureIndex << ShiftForWord), GIV(nilObj));
	for (i1 = 0; i1 <= GIV(argumentCount); i1 += 1) {
		longAtput(where + ((ReceiverIndex + i1) << ShiftForWord), longAt(GIV(stackPointer) - ((GIV(argumentCount) - i1) * BytesPerWord)));
	}
	nilOop = GIV(nilObj);
	for (i1 = ((GIV(argumentCount) + 1) + ReceiverIndex); i1 <= (tempCount + ReceiverIndex); i1 += 1) {
		longAtput(where + (i1 << ShiftForWord), nilOop);
	}
	if (GIV(primFailCode) > 0) {
		if (((primitiveIndexOfMethodHeader(methodHeader)) > 0)
		 && ((byteAt((GIV(newMethod) + BaseHeaderSize) + (initialIP - 1))) == 129)) {
			errorCode = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord))) + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
			longAtput(where + ((tempCount + ReceiverIndex) << ShiftForWord), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	GIV(reclaimableContextCount) += 1;
	/* begin newActiveContext: */
	VM_LABEL(1newActiveContext);
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if (newContext < GIV(youngStart)) {
		beRootIfOld(newContext);
	}
	GIV(activeContext) = newContext;
	/* begin fetchContextRegisters: */
	VM_LABEL(3fetchContextRegisters);
	tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = newContext;
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	/* begin quickCheckForInterrupts */
	if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
		checkForInterrupts();
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}

static sqInt
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power. */

static sqInt
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  f;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(1popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(6assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = exp(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Exponent part of this float. */

static sqInt
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  frac;
    int  pwr;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(2popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(7assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		frac = frexp(rcvr, &pwr);
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), (((pwr - 1) << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Call an external primitive. The external primitive methods 
	contain as first literal an array consisting of: 
	* The module name (String | Symbol) 
	* The function name (String | Symbol) 
	* The session ID (SmallInteger) [OBSOLETE] 
	* The function index (Integer) in the externalPrimitiveTable 
	For fast failures the primitive index of any method where the 
	external prim is not found is rewritten in the method cache 
	with zero. This allows for ultra fast responses as long as the 
	method stays in the cache. 
	The fast failure response relies on lkupClass being properly 
	set. This is done in 
	#addToMethodCacheSel:class:method:primIndex: to 
	compensate for execution of methods that are looked up in a 
	superclass (such as in primitivePerformAt). 
	With the latest modifications (e.g., actually flushing the 
	function addresses from the VM), the session ID is obsolete. 
	But for backward compatibility it is still kept around. Also, a 
	failed lookup is reported specially. If a method has been 
	looked up and not been found, the function address is stored 
	as -1 (e.g., the SmallInteger -1 to distinguish from 
	16rFFFFFFFF which may be returned from the lookup). 
	It is absolutely okay to remove the rewrite if we run into any 
	problems later on. It has an approximate speed difference of 
	30% per failed primitive call which may be noticable but if, 
	for any reasons, we run into problems (like with J3) we can 
	always remove the rewrite. 
	 */

static sqInt
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *addr;
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean2;
    sqInt sz;
    sqInt sz1;

	/* begin success: */
	if (!(((((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) > 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}

	/* Check if it's an array of length 4 */

	lit = longAt((GIV(newMethod) + BaseHeaderSize) + ((0 + LiteralStart) << ShiftForWord));
	/* begin success: */
	successBoolean1 = (((lit & 1) == 0)
 && (((((usqInt) (longAt(lit))) >> 8) & 15) == 2))
	 && ((lengthOf(lit)) == 4);
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}
	index = longAt((lit + BaseHeaderSize) + (3 << ShiftForWord));
	/* begin checkedIntegerValueOf: */
	if ((index & 1)) {
		index = (index >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l3;
	}
l3:	/* end checkedIntegerValueOf: */;
	if (!(!GIV(primFailCode))) {
		return null;
	}
	if (index < 0) {
		rewriteMethodCacheSelclassprimIndex(GIV(messageSelector), GIV(lkupClass), 0);
		/* begin success: */
		if (!(0)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = GIV(externalPrimitiveTable)[index - 1];
		if (addr != 0) {
			rewriteMethodCacheSelclassprimIndexprimFunction(GIV(messageSelector), GIV(lkupClass), 1000 + index, addr);
			callExternalPrimitive(addr);
			return null;
		}
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	longAtput((lit + BaseHeaderSize) + (2 << ShiftForWord), ConstZero);
	longAtput((lit + BaseHeaderSize) + (3 << ShiftForWord), ConstZero);
	moduleName = longAt((lit + BaseHeaderSize) + (0 << ShiftForWord));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		/* begin success: */
		successBoolean = ((moduleName & 1) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8);
		if (!(successBoolean)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		/* begin lengthOf: */
		header = longAt(moduleName);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(moduleName - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			moduleLength = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l1;
		}
	l1:	/* end lengthOf: */;
	}
	functionName = longAt((lit + BaseHeaderSize) + (1 << ShiftForWord));
	/* begin success: */
	successBoolean2 = ((functionName & 1) == 0)
	 && (((((usqInt) (longAt(functionName))) >> 8) & 15) >= 8);
	if (!(successBoolean2)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin lengthOf: */
	header1 = longAt(functionName);
	/* begin lengthOf:baseHeader:format: */
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(functionName - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header1 & SizeMask;
	}
	sz1 -= header1 & Size4Bit;
	if (((((usqInt) header1) >> 8) & 15) <= 4) {
		functionLength = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l4;
	}
	if (((((usqInt) header1) >> 8) & 15) < 8) {
		functionLength = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l4;
	}
	else {
		functionLength = (sz1 - BaseHeaderSize) - (((((usqInt) header1) >> 8) & 15) & 3);
		goto l4;
	}
l4:	/* end lengthOf: */;
	if (!(!GIV(primFailCode))) {
		return null;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		index = -1;
	}
	else {
		/* begin addToExternalPrimitiveTable: */
		for (i = 0; i <= (MaxExternalPrimitiveTableSize - 1); i += 1) {
			if ((GIV(externalPrimitiveTable)[i]) == 0) {
				GIV(externalPrimitiveTable)[i] = addr;
				index = i + 1;
				goto l2;
			}
		}
		index = 0;
	l2:	/* end addToExternalPrimitiveTable: */;
	}
	/* begin success: */
	if (!(index >= 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	longAtput((lit + BaseHeaderSize) + (3 << ShiftForWord), ((index << 1) | 1));
	if ((!GIV(primFailCode))
	 && (addr != 0)) {
		rewriteMethodCacheSelclassprimIndexprimFunction(GIV(messageSelector), GIV(lkupClass), 1000 + index, addr);
		callExternalPrimitive(addr);
	}
	else {
		rewriteMethodCacheSelclassprimIndex(GIV(messageSelector), GIV(lkupClass), 0);
	}
}


/*	Set general (unspecified) primitive failure. */

sqInt
primitiveFail(void)
{
	GIV(primFailCode) = 1;
}


/*	Set specific primitive failure. */

sqInt
primitiveFailFor(sqInt reasonCode)
{
	GIV(primFailCode) = reasonCode;
}

sqInt
primitiveFailureCode(void)
{
	return GIV(primFailCode);
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found
 */

static sqInt
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nilOop;
    sqInt sp;
    sqInt sp1;
    sqInt thisCntx;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	thisCntx = top;
	nilOop = GIV(nilObj);
	do {
		if (isHandlerMarked(thisCntx)) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), thisCntx);
			GIV(stackPointer) = sp;
			return null;
		}
		thisCntx = longAt((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	} while(!(thisCntx == nilOop));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp1;
	return null;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind handling from the receiver up to but not including the
	argument. Return nil if none found.
 */

static sqInt
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt header;
    sqInt meth;
    sqInt nilOop;
    sqInt oop;
    sqInt pIndex;
    sqInt primBits;
    sqInt sp;
    sqInt sp1;
    sqInt thisCntx;
    sqInt top;
    sqInt top1;
    sqInt unwindMarked;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	aContext = top;
	/* begin fetchPointer:ofObject: */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	oop = top1;
	thisCntx = longAt((oop + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	nilOop = GIV(nilObj);
	while (!((thisCntx == aContext)
	 || (thisCntx == nilOop))) {
		/* begin isUnwindMarked: */
		header = longAt(thisCntx);
		if (!(((((usqInt) header) >> 12) & 31) == ClassMethodContextCompactIndex)) {
			unwindMarked = 0;
			goto l1;
		}
		meth = longAt((thisCntx + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		/* begin primitiveIndexOf: */
		primBits = (((usqInt) (longAt((meth + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
		pIndex = (primBits & 511) + (((usqInt) primBits) >> 19);
		unwindMarked = pIndex == 198;
	l1:	/* end isUnwindMarked: */;
		if (unwindMarked) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), thisCntx);
			GIV(stackPointer) = sp;
			return null;
		}
		thisCntx = longAt((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) + BytesPerWord), nilOop);
	GIV(stackPointer) = sp1;
	return null;
}

static sqInt
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double  arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt object;
    double  rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(rcvr + arg);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	return null;
}

static sqInt
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return primitiveFloatDividebyArg(longAt(GIV(stackPointer) - (1 * BytesPerWord)), longAt(GIV(stackPointer)));
}

static sqInt
primitiveFloatDividebyArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double  arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double  f;
    sqInt object;
    double  rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin success: */
		if (!(arg != 0.0)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) -= 2 * BytesPerWord;
			/* begin pushFloat: */
			f = rcvr / arg;
			/* begin push: */
			object = floatObjectOf(f);
			longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
			GIV(stackPointer) = sp;
		}
	}
}

static sqInt
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt sp1;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) - (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) - (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushBool: */
		if (aBool) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}

static sqInt
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) - (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) - (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), (aBool
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatGreater:thanArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) - (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) - (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), (aBool
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatLessOrEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) - (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) - (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), (aBool
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt sp1;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatLess:thanArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) - (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) - (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushBool: */
		if (aBool) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}

static sqInt
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double  arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt object;
    double  rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(rcvr * arg);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	return null;
}

static sqInt
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    double rcvr;
    double result;
    double result1;
    sqInt sp;
    sqInt sp1;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) - (1 * BytesPerWord))) & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(longAt(GIV(stackPointer) - (1 * BytesPerWord))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt((longAt(GIV(stackPointer) - (1 * BytesPerWord))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt((longAt(GIV(stackPointer))) - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto((longAt(GIV(stackPointer))) + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushBool: */
		if (!aBool) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}

static sqInt
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double  arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt object;
    double  rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    sqInt sp;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 1)) {
		successBoolean = 0;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean = ClassFloatCompactIndex == ccIndex;
		goto l1;
	}
	successBoolean = (ccIndex == 0)
	 && (((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
	}
	rcvr = result;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}
	/* begin assertClassOf:is:compactClassIndex: */
	/* begin success: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 1)) {
		successBoolean1 = 0;
		goto l3;
	}
	ccIndex1 = (((usqInt) (longAt(argOop))) >> 12) & 31;
	if (ClassFloatCompactIndex != 0) {
		successBoolean1 = ClassFloatCompactIndex == ccIndex1;
		goto l3;
	}
	successBoolean1 = (ccIndex1 == 0)
	 && (((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (!(successBoolean1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	;
	if (!GIV(primFailCode)) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
	}
	arg = result1;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(rcvr - arg);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	return null;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

static sqInt
primitiveFlushCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;

	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */

static sqInt
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt oldMethod;
    sqInt probe;

	oldMethod = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined.  */

static sqInt
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;
    sqInt selector;

	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((16 * 2) << ShiftForWord))))
	 || (selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << ShiftForWord))) + BaseHeaderSize) + ((17 * 2) << ShiftForWord))))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			GIV(atCache)[i1] = 0;
		}
	}
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

static sqInt
primitiveFlushExternalPrimitives(void)
{
	return flushExternalPrimitives();
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

static sqInt
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	Set force tenure flag to true, this forces a tenure operation on the next
	incremental GC
 */

EXPORT(sqInt)
primitiveForceTenure(void)
{
	GIV(forceTenureFlag) = 1;
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

static sqInt
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt depth;
    sqInt h;
    double  hScale;
    sqInt landscapeFlag;
    sqInt ok;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double result;
    double result1;
    double  vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l1;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	landscapeFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin floatValueOf: */
	flag("Dan");
	if (isinstanceOfcompactClassIndex(longAt(GIV(stackPointer) - (1 * BytesPerWord)), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), ClassFloatCompactIndex)) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) - (1 * BytesPerWord))) + BaseHeaderSize, result);
		vScale = result;
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		vScale = 0.0;
		goto l2;
	}
l2:	/* end floatValueOf: */;
	/* begin floatValueOf: */
	flag("Dan");
	if (isinstanceOfcompactClassIndex(longAt(GIV(stackPointer) - (2 * BytesPerWord)), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)), ClassFloatCompactIndex)) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) - (2 * BytesPerWord))) + BaseHeaderSize, result1);
		hScale = result1;
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		hScale = 0.0;
		goto l3;
	}
l3:	/* end floatValueOf: */;
	rcvr = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin success: */
		if (!(0)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		if (!((((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))
			 && ((lengthOf(rcvr)) >= 4))) {
			/* begin success: */
			if (!(0)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0 << ShiftForWord));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			if (!(0)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if ((!((rcvr & 1)))
		 && (((bitsArray & 1) == 0)
		 && (isWordsOrBytesNonInt(bitsArray)))) {
			bitsArraySize = byteLengthOf(bitsArray);
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!(0)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
		}
	}
	if (!GIV(primFailCode)) {
		if (BytesPerWord == 8) {
			ok = ioFormPrint(bitsArray + 8, w, h, depth, hScale, vScale, landscapeFlag);
		}
		else {
			ok = ioFormPrint(bitsArray + 4, w, h, depth, hScale, vScale, landscapeFlag);
		}
		/* begin success: */
		if (!(ok)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 3 * BytesPerWord;
	}
}

static sqInt
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  frac;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;
    double  trunc;

	/* begin popFloat */
	VM_LABEL(3popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(8assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		frac = modf(rcvr, &trunc);
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(frac);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Do a full garbage collection and return the number of bytes available
	(including swap space if dynamic memory management is supported).
 */

static sqInt
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt sp;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	incrementalGC();
	fullGC();
	/* begin pushInteger: */
	integerValue = ((longAt(GIV(freeBlock))) & AllButTypeMask) + (sqMemoryExtraBytesLeft(1));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), ((integerValue << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

static sqInt
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    sqInt sp;
    sqInt sz;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		attr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		attr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		sz = attributeSize(attr);
	}
	if (!GIV(primFailCode)) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveGetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hdr;
    sqInt rcvr;
    sqInt sp;
    sqInt sp1;

	rcvr = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord)), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TrueObject << ShiftForWord)));
		GIV(stackPointer) = sp;
	}
	else {
		hdr = longAt(rcvr);
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord)), ((hdr & ImmutabilityBit) != 0
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp1;
	}
}


/*	Primitive. Return the next input event from the VM event queue. */

static sqInt
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    int evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqInt oop;
    sqInt value;

	;
	arg = longAt(GIV(stackPointer));
	if (!((((arg & 1) == 0)
 && (((((usqInt) (longAt(arg))) >> 8) & 15) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (!(!GIV(primFailCode))) {
		return null;
	}
	/* begin storeInteger:ofObject:withValue: */
	if (((evtBuf[0]) ^ ((evtBuf[0]) << 1)) >= 0) {
		longAtput((arg + BaseHeaderSize) + (0 << ShiftForWord), (((evtBuf[0]) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((evtBuf[1]) & MillisecondClockMask) ^ (((evtBuf[1]) & MillisecondClockMask) << 1)) >= 0) {
		longAtput((arg + BaseHeaderSize) + (1 << ShiftForWord), ((((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}
	for (i = 2; i <= 7; i += 1) {
		value = evtBuf[i];
		if ((value ^ (value << 1)) >= 0) {
			/* begin storeInteger:ofObject:withValue: */
			if ((value ^ (value << 1)) >= 0) {
				longAtput((arg + BaseHeaderSize) + (i << ShiftForWord), ((value << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
		}
		else {
			/* begin pushRemappableOop: */
			assert(addressCouldBeOop(arg));
			GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = arg;
			value = positive32BitIntegerFor(value);
			/* begin popRemappableOop */
			oop = GIV(remapBuffer)[GIV(remapBufferCount)];
			GIV(remapBufferCount) -= 1;
			arg = oop;
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) arg)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(arg, value);
			}
			longAtput((arg + BaseHeaderSize) + (i << ShiftForWord), value);
		}
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}
	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
}

static sqInt
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt sp;
    sqInt sp1;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (integerReceiver >= integerArgument) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt sp;
    sqInt sp1;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (integerReceiver > integerArgument) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}


/*	Primitive. Answer an Array of the integers representing the header words
	for the argument.
 */

static sqInt
primitiveHeaderWords(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    sqInt result;
    sqInt size;
    sqInt sp;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	obj = longAt(GIV(stackPointer));
	if ((obj & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (((longAt(obj)) & TypeMask) == HeaderTypeShort) {
		size = 1;
	}
	else {
		if (((longAt(obj)) & TypeMask) == HeaderTypeClass) {
			size = 2;
		}
		else {
			size = 3;
		}
	}

	/* can cause GC */

	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), size);
	obj = longAt(GIV(stackPointer));
	/* begin storePointer:ofObject:withValue: */
	valuePointer2 = positive32BitIntegerFor(longAt(obj));
	if ((((usqInt) result)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(result, valuePointer2);
	}
	longAtput((result + BaseHeaderSize) + (0 << ShiftForWord), valuePointer2);
	if (size > 1) {
		/* begin storePointer:ofObject:withValue: */
		valuePointer = positive32BitIntegerFor(longAt(obj - BaseHeaderSize));
		if ((((usqInt) result)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(result, valuePointer);
		}
		longAtput((result + BaseHeaderSize) + (1 << ShiftForWord), valuePointer);
	}
	if (size > 2) {
		/* begin storePointer:ofObject:withValue: */
		valuePointer1 = positive32BitIntegerFor(longAt(obj - (BytesPerWord * 2)));
		if ((((usqInt) result)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(result, valuePointer1);
		}
		longAtput((result + BaseHeaderSize) + (2 << ShiftForWord), valuePointer1);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

static sqInt
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    sqInt sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		If not, assume it's ok */

		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename =  ((sqInt (*)(void))sCRIfn)();
			if (!(okToRename)) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		VM_LABEL(9assertClassOfis);
		if ((s & 1)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			goto l1;
		}
		ccIndex = (((usqInt) (longAt(s))) >> 12) & 31;
		if (ccIndex == 0) {
			cl = (longAt(s - BaseHeaderSize)) & AllButTypeMask;
		}
		else {

			/* look up compact class */

			cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		}
		/* begin success: */
		if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord))))) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	l1:	/* end assertClassOf:is: */;
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) -= 1 * BytesPerWord;
		}
	}
	else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available. (Note: more space may be made available by doing a
	full garbage collection.
 */

static sqInt
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt sp;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	incrementalGC();
	/* begin pushInteger: */
	integerValue = ((longAt(GIV(freeBlock))) & AllButTypeMask) + (sqMemoryExtraBytesLeft(0));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), ((integerValue << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility. The time to unpack is negligible,
	since the reconstituted full index is stored in the method cache. */

static sqInt
primitiveIndexOfMethodHeader(sqInt methodHeader)
{
    sqInt primBits;

	primBits = (((usqInt) methodHeader) >> 1) & 268435967;
	return (primBits & 511) + (((usqInt) primBits) >> 19);
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility. The time to unpack is negligible,
	since the reconstituted full index is stored in the method cache. */

sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt primBits;

	primBits = (((usqInt) (longAt((methodPointer + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 1) & 268435967;
	return (primBits & 511) + (((usqInt) primBits) >> 19);
}


/*	Register the input semaphore. The argument is an index into the
	ExternalObjectsArray part of the specialObjectsArray and must have been
	allocated via 'Smalltalk registerExternalObject: the Semaphore'
 */

static sqInt
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg & 1)) {
		ioSetInputSemaphore((arg >> 1));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) -= 1 * BytesPerWord;
		}
		return null;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

static sqInt
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), ((0 << 1) | 1));
	GIV(stackPointer) = sp;
}

static sqInt
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    sqInt sp;
    sqInt sz;
    sqInt totalLength;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l5;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l5;
	}
l5:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	/* begin subscript:with:format: */
	VM_LABEL(0subscriptwithformat);
	if (fmt <= 4) {
		value = longAt((rcvr + BaseHeaderSize) + ((index - 1) << ShiftForWord));
		goto l3;
	}
	if (fmt < 8) {
		value = positive32BitIntegerFor(long32At((rcvr + BaseHeaderSize) + ((index - 1) << 2)));
		goto l3;
	}
	else {
		value = (((byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 1) | 1);
		goto l3;
	}
l3:	/* end subscript:with:format: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

static sqInt
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt integerPointer;
    sqInt newValue;
    sqInt rcvr;
    sqInt sp;
    sqInt sz;
    sqInt totalLength;
    sqInt valueToStore;

	newValue = longAt(GIV(stackPointer));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	hdr = longAt(rcvr);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l4;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l4;
	}
l4:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	if ((hdr & ImmutabilityBit) != 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	/* begin subscript:with:storing:format: */
	VM_LABEL(0subscriptwithstoringformat);
	if (fmt <= 4) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) rcvr)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(rcvr, newValue);
		}
		longAtput((rcvr + BaseHeaderSize) + ((index - 1) << ShiftForWord), newValue);
	}
	else {
		if (fmt < 8) {

			/* long-word type objects */

			valueToStore = positive32BitValueOf(newValue);
			if (!GIV(primFailCode)) {
				long32Atput((rcvr + BaseHeaderSize) + ((index - 1) << 2), valueToStore);
			}
		}
		else {
			if (!((newValue & 1))) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
			valueToStore = (newValue >> 1);
			if (!((valueToStore >= 0)
				 && (valueToStore <= 255))) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
			if (!GIV(primFailCode)) {
				byteAtput((rcvr + BaseHeaderSize) + (index - 1), valueToStore);
			}
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

static sqInt
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    sqInt object;
    sqInt rcvr;
    sqInt sp;
    sqInt sp1;
    sqInt sz;
    sqInt sz1;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (((rcvr & 1))
	 || (!(((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) == 6)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}

	/* for zero indexing */

	addr = ((rcvr + BaseHeaderSize) - 4) + (index * 4);
	value = intAt(addr);
	/* begin pop: */
	GIV(stackPointer) -= 2 * BytesPerWord;
	if ((value ^ (value << 1)) >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), ((value << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		object = signed32BitIntegerFor(value);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
}


/*	Return the 32bit signed integer contents of a words receiver */

static sqInt
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    sqInt sp;
    sqInt sz;
    sqInt sz1;
    sqInt value;
    sqInt valueOop;

	valueOop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((valueOop & 1)) {
		value = (valueOop >> 1);
	}
	else {
		value = signed32BitValueOf(valueOop);
	}
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	rcvr = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if (((rcvr & 1))
	 || (!(((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) == 6)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}

	/* for zero indexing */

	addr = ((rcvr + BaseHeaderSize) - 4) + (index * 4);
	value = intAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), valueOop);
	GIV(stackPointer) = sp;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

static sqInt
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt oop;
    sqInt oop1;
    sqInt top;
    sqInt valuePointer;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
		/* begin storePointer:ofObject:withValue: */
		oop = GIV(specialObjectsOop);
		if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop, arg);
		}
		longAtput((oop + BaseHeaderSize) + (TheInterruptSemaphore << ShiftForWord), arg);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		oop1 = GIV(specialObjectsOop);
		valuePointer = GIV(nilObj);
		if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop1, valuePointer);
		}
		longAtput((oop1 + BaseHeaderSize) + (TheInterruptSemaphore << ShiftForWord), valuePointer);
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

static sqInt
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt errorCode;
    sqInt i;
    sqInt in;
    sqInt initialIP;
    sqInt lastIn;
    sqInt lookupClass;
    sqInt methodHeader;
    sqInt newContext;
    sqInt newReceiver;
    sqInt nilOop;
    sqInt out;
    sqInt runArgs;
    sqInt runReceiver;
    sqInt runSelector;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    sqInt tempCount;
    sqInt tmp;
    sqInt where;

	runArgs = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), GIV(argumentCount));
	beRootIfOld(runArgs);
	/* begin transfer:from:to: */
	flag("Dan");
	in = (GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord)) - BytesPerWord;
	lastIn = in + (GIV(argumentCount) * BytesPerWord);
	out = (runArgs + BaseHeaderSize) - BytesPerWord;
	while ((((usqInt) in)) < (((usqInt) lastIn))) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	runSelector = GIV(messageSelector);
	runReceiver = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	newReceiver = GIV(newMethod);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorRunWithIn << ShiftForWord));
	GIV(argumentCount) = 3;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), newReceiver);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) + BytesPerWord), runSelector);
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) + BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) + BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	/* begin fetchClassOf: */
	if ((newReceiver & 1)) {
		lookupClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(newReceiver))) >> 12) & 31)) == 0) {
		lookupClass = (longAt(newReceiver - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		lookupClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	findNewMethodInClass(lookupClass);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	VM_LABEL(2activateNewMethod);
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where = newContext + BaseHeaderSize;
	longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
	longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
	longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
	longAtput(where + (ClosureIndex << ShiftForWord), GIV(nilObj));
	for (i = 0; i <= GIV(argumentCount); i += 1) {
		longAtput(where + ((ReceiverIndex + i) << ShiftForWord), longAt(GIV(stackPointer) - ((GIV(argumentCount) - i) * BytesPerWord)));
	}
	nilOop = GIV(nilObj);
	for (i = ((GIV(argumentCount) + 1) + ReceiverIndex); i <= (tempCount + ReceiverIndex); i += 1) {
		longAtput(where + (i << ShiftForWord), nilOop);
	}
	if (GIV(primFailCode) > 0) {
		if (((primitiveIndexOfMethodHeader(methodHeader)) > 0)
		 && ((byteAt((GIV(newMethod) + BaseHeaderSize) + (initialIP - 1))) == 129)) {
			errorCode = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord))) + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
			longAtput(where + ((tempCount + ReceiverIndex) << ShiftForWord), errorCode);
		}
		GIV(primFailCode) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	GIV(reclaimableContextCount) += 1;
	/* begin newActiveContext: */
	VM_LABEL(2newActiveContext);
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if (newContext < GIV(youngStart)) {
		beRootIfOld(newContext);
	}
	GIV(activeContext) = newContext;
	/* begin fetchContextRegisters: */
	VM_LABEL(4fetchContextRegisters);
	tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = newContext;
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	/* begin quickCheckForInterrupts */
	if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
		checkForInterrupts();
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Primitive. Answer whether the argument to the primitive is a root for
	young space
 */

EXPORT(sqInt)
primitiveIsRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    sqInt sp;
    sqInt sp1;

	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
		/* begin pushBool: */
		if ((longAt(oop)) & RootBit) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive. Answer whether the argument to the primitive resides in young
	space. 
 */

EXPORT(sqInt)
primitiveIsYoung(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    sqInt sp;
    sqInt sp1;

	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
		/* begin pushBool: */
		if (oop >= GIV(youngStart)) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

static sqInt
primitiveKbdNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    sqInt sp;
    sqInt sp1;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

static sqInt
primitiveKbdPeek(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    sqInt sp;
    sqInt sp1;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt sp;
    sqInt sp1;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (integerReceiver <= integerArgument) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt sp;
    sqInt sp1;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (integerReceiver < integerArgument) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}


/*	Primitive. Return the n-th builtin module name. */

static sqInt
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    sqInt sp;
    sqInt sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return null;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), length);
	for (i = 0; i <= (length - 1); i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	/* begin forceInterruptCheck */
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

static sqInt
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    sqInt sp;
    sqInt sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return null;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), length);
	for (i = 0; i <= (length - 1); i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	/* begin forceInterruptCheck */
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed. It will return as its
	value the original array of roots, and the erstwhile segmentWordArray will
	have been truncated to a size of zero. If this primitive should fail, the
	segmentWordArray will, sadly, have been reduced to an unrecognizable and
	unusable jumble. But what more could you have done with it anyway?
 */

static sqInt
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt data;
    sqInt doingClass;
    sqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    sqInt fieldPtr;
    sqInt hdrTypeBits;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt lastOut;
    sqInt lastPtr;
    sqInt mapOop;
    sqInt outPointerArray;
    sqInt outPtr;
    sqInt segmentWordArray;
    sqInt segOop;
    sqInt sp;
    sqInt sz;
    sqInt sz1;

	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	outPointerArray = longAt(GIV(stackPointer));
	lastOut = outPointerArray + (lastPointerOf(outPointerArray));
	segmentWordArray = longAt(GIV(stackPointer) - (1 * BytesPerWord));

	/* Essential type checks */

	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BaseHeaderSize;
	if (!((((((usqInt) (longAt(outPointerArray))) >> 8) & 15) == 2)
		 && (((((usqInt) (longAt(segmentWordArray))) >> 8) & 15) == 6))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	data = longAt(segmentWordArray + BaseHeaderSize);
	if (!(((data & 65535) == imageFormatVersionNumber)
		 || ((data & 65535) == (imageFormatForwardCompatibilityVersion())))) {
		/* begin reverseBytesFrom:to: */
		flag("Dan");
		addr1 = segmentWordArray + BaseHeaderSize;
		while ((((usqInt) addr1)) < (((usqInt) (endSeg + BytesPerWord)))) {
			longAtput(addr1, byteSwapped(longAt(addr1)));
			addr1 += BytesPerWord;
		}
		data = longAt(segmentWordArray + BaseHeaderSize);
		if (!(((data & 65535) == imageFormatVersionNumber)
			 || ((data & 65535) == (imageFormatForwardCompatibilityVersion())))) {
			/* begin reverseBytesFrom:to: */
			flag("Dan");
			addr = segmentWordArray + BaseHeaderSize;
			while ((((usqInt) addr)) < (((usqInt) (endSeg + BytesPerWord)))) {
				longAtput(addr, byteSwapped(longAt(addr)));
				addr += BytesPerWord;
			}
			if (DoAssertionChecks) {
				verifyCleanHeaders();
			}
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	if (!(data == (imageSegmentVersion()))) {

		/* Reverse the byte-type objects once */
		/* Oop of first embedded object */

		segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
		byteSwapByteObjectsFromto(segOop, endSeg + BytesPerWord);
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type = 0 or 1) -- start with that. */

			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */

			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */

		lastPtr = segOop + (lastPointerOf(segOop));
		if (lastPtr > endSeg) {
			if (DoAssertionChecks) {
				verifyCleanHeaders();
			}
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = (longAt(fieldPtr)) & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Integer -- nothing to do */

				fieldPtr += BytesPerWord;
			}
			else {
				if (!((fieldOop & 3) == 0)) {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
					return null;
				}
				if ((fieldOop & 2147483648UL) == 0) {

					/* Internal pointer -- add segment offset */

					mapOop = fieldOop + segmentWordArray;
				}
				else {

					/* External pointer -- look it up in outPointers */

					outPtr = outPointerArray + (fieldOop & 2147483647UL);
					if (outPtr > lastOut) {
						/* begin primitiveFail */
						GIV(primFailCode) = 1;
						return null;
					}
					mapOop = longAt(outPtr);
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += 8;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
				if (segOop < GIV(youngStart)) {
					possibleRootStoreIntovalue(segOop, mapOop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(segOop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header1 & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		segOop = (segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask]);
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (!(oopHasAcceptableClass(segOop))) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}

		/* first field */

		fieldPtr = segOop + BaseHeaderSize;

		/* last field */
		/* Go through all oops, remapping them... */

		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (!(oopHasAcceptableClass(fieldOop))) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
			fieldPtr += BytesPerWord;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(segOop);
			if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz1 = header2 & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		segOop = (segOop + sz1) + (headerTypeBytes[(longAt(segOop + sz1)) & TypeMask]);
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	if (extraSize == 8) {
		longAtput(segmentWordArray - extraSize, (BaseHeaderSize + BytesPerWord) + hdrTypeBits);
	}
	else {
		header = longAt(segmentWordArray);
		longAtput(segmentWordArray, ((header - (header & SizeMask)) + BaseHeaderSize) + BytesPerWord);
	}
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]));
	GIV(stackPointer) = sp;
}


/*	Natural log. */

static sqInt
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  f;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(4popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(10assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = log(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

static sqInt
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt oop;
    sqInt oop1;
    sqInt top;
    sqInt valuePointer;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
		/* begin storePointer:ofObject:withValue: */
		oop = GIV(specialObjectsOop);
		if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop, arg);
		}
		longAtput((oop + BaseHeaderSize) + (TheLowSpaceSemaphore << ShiftForWord), arg);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		oop1 = GIV(specialObjectsOop);
		valuePointer = GIV(nilObj);
		if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop1, valuePointer);
		}
		longAtput((oop1 + BaseHeaderSize) + (TheLowSpaceSemaphore << ShiftForWord), valuePointer);
	}
}

static sqInt
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argument;
    sqInt pointResult;
    sqInt pointResult1;
    sqInt pointResult2;
    sqInt pt;
    sqInt rcvr;
    sqInt sp;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	argument = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((rcvr & 1)) {
		if ((argument & 1)) {
			/* begin makePointwithxValue:yValue: */
			pointResult = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
			longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
			longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((((argument >> 1)) << 1) | 1));
			pt = pointResult;
		}
		else {
			/* begin makePointwithxValue:yValue: */
			pointResult1 = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
			longAtput((pointResult1 + BaseHeaderSize) + (XIndex << ShiftForWord), ((((rcvr >> 1)) << 1) | 1));
			longAtput((pointResult1 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
			pt = pointResult1;
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
			if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(pt, valuePointer);
			}
			longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), valuePointer);
		}
	}
	else {
		if (!(((rcvr & 1) == 0)
			 && ((fetchClassOfNonInt(rcvr)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)))))) {
			/* begin success: */
			if (!(0)) {
				if (!GIV(primFailCode)) {

					/* Don't overwrite an error code that has already been set. */

					GIV(primFailCode) = 1;
				}
			}
			return null;
		}
		/* begin makePointwithxValue:yValue: */
		pointResult2 = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
		longAtput((pointResult2 + BaseHeaderSize) + (XIndex << ShiftForWord), ((0 << 1) | 1));
		longAtput((pointResult2 + BaseHeaderSize) + (YIndex << ShiftForWord), ((0 << 1) | 1));
		pt = pointResult2;
		/* begin storePointer:ofObject:withValue: */
		valuePointer1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
		if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(pt, valuePointer1);
		}
		longAtput((pt + BaseHeaderSize) + (0 << ShiftForWord), valuePointer1);
		/* begin storePointer:ofObject:withValue: */
		valuePointer2 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
		if ((((usqInt) pt)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(pt, valuePointer2);
		}
		longAtput((pt + BaseHeaderSize) + (1 << ShiftForWord), valuePointer2);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}


/*	Primitive. Mark the method for exception handling. The primitive must fail
	after marking the context so that the regular code is run.
 */

static sqInt
primitiveMarkHandlerMethod(void)
{
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	return null;
}


/*	Primitive. Mark the method for exception unwinding. The primitive must
	fail after marking the context so that the regular code is run.
 */

static sqInt
primitiveMarkUnwindMethod(void)
{
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	return null;
}


/*	Return the method an external primitive was defined in */

sqInt
primitiveMethod(void)
{
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

static sqInt
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt sp;

	/* begin pop:thenPush: */
	oop = ((((ioMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

static sqInt
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    sqInt sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) - (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((mod ^ (mod << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((mod << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

static sqInt
primitiveMouseButtons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    sqInt sp;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), ((buttonWord << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

static sqInt
primitiveMousePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt pointResult;
    sqInt pointWord;
    sqInt sp;
    sqInt x;
    sqInt y;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 65535) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 65535;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 65535) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 65535) & 32768) == 0) {
		y = pointWord & 65535;
		goto l2;
	}
	else {
		y = (pointWord & 65535) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((x << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), ((y << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
}

static sqInt
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* check for C overflow by seeing if computation is reversible */

		integerResult = integerRcvr * integerArg;
		if ((integerArg == 0)
		 || ((integerResult / integerArg) == integerRcvr)) {
			/* begin pop2AndPushIntegerIfOK: */
			if (!GIV(primFailCode)) {
				if ((integerResult ^ (integerResult << 1)) >= 0) {
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
					GIV(stackPointer) = sp;
				}
				else {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
}


/*	Allocate a new fixed-size instance. Fail if the allocation would leave
	less than lowSpaceThreshold bytes free. May cause a GC
 */

static sqInt
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atomSize;
    sqInt class;
    sqInt format;
    sqInt minFree;
    sqInt object;
    sqInt sp;
    sqInt spaceOkay;


	/* The following may cause GC! */

	class = longAt(GIV(stackPointer));
	/* begin sufficientSpaceToInstantiate:indexableSize: */

	/* fail if attempting to call new: on non-indexable class */

	format = (((usqInt) ((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1)) >> 8) & 15;
	if (((((usqInt ) 0)) > 0)
	 && (format < 2)) {
		spaceOkay = 0;
		goto l1;
	}
	if (format < 8) {

		/* indexable fields are words or pointers */

		atomSize = BytesPerWord;
	}
	else {

		/* indexable fields are bytes */

		atomSize = 1;
	}
	/* begin sufficientSpaceToAllocate: */

	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + (2500 + (0 * atomSize))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
		spaceOkay = 1;
		goto l2;
	}
	else {
		spaceOkay = sufficientSpaceAfterGC(minFree);
		goto l2;
	}
l2:	/* end sufficientSpaceToAllocate: */;
l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	/* begin success: */
	if (!(spaceOkay)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = instantiateClassindexableSize(popStack(), 0);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt header;
    sqInt i;
    sqInt integerPointer;
    sqInt literalCount;
    sqInt size;
    sqInt sp;
    sqInt theMethod;
    sqInt top;
    sqInt top1;
    sqInt top2;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	header = top;
	/* begin popInteger */
	/* begin popStack */
	top2 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top2;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytecodeCount = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		bytecodeCount = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin success: */
	if (!((header & 1))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		return null;
	}
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	class = top1;
	size = ((((((usqInt) header) >> 10) & 255) + 1) * BytesPerWord) + bytecodeCount;
	theMethod = instantiateClassindexableSize(class, size);
	longAtput((theMethod + BaseHeaderSize) + (HeaderIndex << ShiftForWord), header);
	literalCount = (((usqInt) header) >> 10) & 255;
	for (i = 1; i <= literalCount; i += 1) {
		longAtput((theMethod + BaseHeaderSize) + (i << ShiftForWord), GIV(nilObj));
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free.
 */

static sqInt
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt atomSize;
    sqInt class;
    sqInt format;
    sqInt minFree;
    sqInt oop;
    sqInt size;
    sqInt sp;
    sqInt spaceOkay;

	size = positive32BitValueOf(longAt(GIV(stackPointer)));
	class = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin success: */
	if (!(size >= 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin sufficientSpaceToInstantiate:indexableSize: */

		/* fail if attempting to call new: on non-indexable class */

		format = (((usqInt) ((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1)) >> 8) & 15;
		if (((((usqInt ) size)) > 0)
		 && (format < 2)) {
			spaceOkay = 0;
			goto l1;
		}
		if (format < 8) {

			/* indexable fields are words or pointers */

			atomSize = BytesPerWord;
		}
		else {

			/* indexable fields are bytes */

			atomSize = 1;
		}
		/* begin sufficientSpaceToAllocate: */

		/* check for low-space */

		minFree = ((((GIV(lowSpaceThreshold) + (2500 + (size * atomSize))) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
		if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
			spaceOkay = 1;
			goto l2;
		}
		else {
			spaceOkay = sufficientSpaceAfterGC(minFree);
			goto l2;
		}
	l2:	/* end sufficientSpaceToAllocate: */;
	l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
		/* begin success: */
		if (!(spaceOkay)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		class = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = instantiateClassindexableSize(class, size);
		longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	PrimitiveNext will succeed only if the stream's array is in the atCache.
	Otherwise failure will lead to proper message lookup of at: and
	subsequent installation in the cache if appropriate. */

static sqInt
primitiveNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt atIx;
    sqInt index;
    sqInt limit;
    sqInt result;
    sqInt sp;
    sqInt stream;

	stream = longAt(GIV(stackPointer));
	if (!((((stream & 1) == 0)
 && (((((usqInt) (longAt(stream))) >> 8) & 15) <= 4))
		 && ((lengthOf(stream)) >= (StreamReadLimitIndex + 1)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	array = longAt((stream + BaseHeaderSize) + (StreamArrayIndex << ShiftForWord));
	index = fetchIntegerofObject(StreamIndexIndex, stream);
	limit = fetchIntegerofObject(StreamReadLimitIndex, stream);
	atIx = array & AtCacheMask;
	if (!((index < limit)
		 && ((GIV(atCache)[atIx + AtCacheOop]) == array))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	index += 1;

	/* Above may cause GC, so can't use stream, array etc. below it */

	result = commonVariableatcacheIndex(array, index, atIx);
	if (!GIV(primFailCode)) {
		stream = longAt(GIV(stackPointer));
		/* begin storeInteger:ofObject:withValue: */
		if ((index ^ (index << 1)) >= 0) {
			longAtput((stream + BaseHeaderSize) + (StreamIndexIndex << ShiftForWord), ((index << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return null;
	}
}

static sqInt
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classPointer;
    sqInt instance;
    sqInt object;
    sqInt sp;
    sqInt thisClass;
    sqInt thisObj;

	object = longAt(GIV(stackPointer));
	/* begin instanceAfter: */
	/* begin fetchClassOfNonInt: */
	if (((ccIndex1 = (((usqInt) (longAt(object))) >> 12) & 31)) == 0) {
		classPointer = (longAt(object - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		classPointer = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end fetchClassOfNonInt: */;
	thisObj = accessibleObjectAfter(object);
	while (!(thisObj == null)) {
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(thisObj))) >> 12) & 31)) == 0) {
			thisClass = (longAt(thisObj - BaseHeaderSize)) & AllButTypeMask;
			goto l2;
		}
		else {
			thisClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l2;
		}
	l2:	/* end fetchClassOfNonInt: */;
		if (thisClass == classPointer) {
			instance = thisObj;
			goto l1;
		}
		thisObj = accessibleObjectAfter(thisObj);
	}
	instance = GIV(nilObj);
l1:	/* end instanceAfter: */;
	if (instance == GIV(nilObj)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

static sqInt
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    sqInt object;
    sqInt sp;
    sqInt sp1;

	object = longAt(GIV(stackPointer));
	instance = accessibleObjectAfter(object);
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((0 << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp1;
	}
}


/*	PrimitiveNextPut will succeed only if the stream's array is in the
	atPutCache. Otherwise failure will lead to proper message lookup of
	at:put: and
	subsequent installation in the cache if appropriate.
 */

static sqInt
primitiveNextPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt atIx;
    sqInt fixedFields;
    sqInt fmt;
    sqInt index;
    sqInt limit;
    sqInt sp;
    sqInt stream;
    sqInt stSize;
    sqInt valToPut;
    sqInt value;

	value = longAt(GIV(stackPointer));
	stream = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (!((((stream & 1) == 0)
 && (((((usqInt) (longAt(stream))) >> 8) & 15) <= 4))
		 && ((lengthOf(stream)) >= (StreamReadLimitIndex + 1)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	array = longAt((stream + BaseHeaderSize) + (StreamArrayIndex << ShiftForWord));
	index = fetchIntegerofObject(StreamIndexIndex, stream);
	limit = fetchIntegerofObject(StreamReadLimitIndex, stream);
	atIx = (array & AtCacheMask) + AtPutBase;
	if (!((index < limit)
		 && ((GIV(atCache)[atIx + AtCacheOop]) == array))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!((((longAt(stream)) & ImmutabilityBit) == 0)
		 && (((longAt(array)) & ImmutabilityBit) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	index += 1;
	/* begin commonVariable:at:put:cacheIndex: */
	VM_LABEL(2commonVariableatputcacheIndex);
	stSize = GIV(atCache)[atIx + AtCacheSize];
	if (((((usqInt ) index)) >= 1)
	 && ((((usqInt ) index)) <= (((usqInt ) stSize)))) {
		fmt = GIV(atCache)[atIx + AtCacheFmt];
		if (fmt <= 4) {
			fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) array)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(array, value);
			}
			longAtput((array + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord), value);
			goto l1;
		}
		if (fmt < 8) {

			/* Bitmap */

			valToPut = positive32BitValueOf(value);
			if (!GIV(primFailCode)) {
				long32Atput((array + BaseHeaderSize) + ((index - 1) << 2), valToPut);
				goto l1;
			}
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l1;
		}
		if (fmt >= 16) {

			/* Note fmt >= 16 is an artificial flag for strings */

			valToPut = asciiOfCharacter(value);
			if (!(!GIV(primFailCode))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				goto l1;
			}
		}
		else {
			valToPut = value;
		}
		if ((valToPut & 1)) {
			valToPut = (valToPut >> 1);
			if (!((valToPut >= 0)
				 && (valToPut <= 255))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				goto l1;
			}
			byteAtput((array + BaseHeaderSize) + (index - 1), valToPut);
			goto l1;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadIndex;
l1:	/* end commonVariable:at:put:cacheIndex: */;
	if (!GIV(primFailCode)) {
		/* begin storeInteger:ofObject:withValue: */
		if ((index ^ (index << 1)) >= 0) {
			longAtput((stream + BaseHeaderSize) + (StreamIndexIndex << ShiftForWord), ((index << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
		return null;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

static sqInt
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
}

static sqInt
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    sqInt sp;
    sqInt sp1;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerReceiver = top1;
	result = !(compare31or32Bitsequal(integerReceiver, integerArgument));
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		if (result) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}


/*	Defined for CompiledMethods only */

static sqInt
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    sqInt sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	thisReceiver = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= (((((usqInt) (longAt((thisReceiver + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), longAt((thisReceiver + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

static sqInt
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    sqInt newValue;
    sqInt sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	thisReceiver = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if (!((index > 0)
		 && (index <= (((((usqInt) (longAt((thisReceiver + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	if (!(((longAt(thisReceiver)) & ImmutabilityBit) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) thisReceiver)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(thisReceiver, newValue);
	}
	longAtput((thisReceiver + BaseHeaderSize) + ((index - 1) << ShiftForWord), newValue);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}

static sqInt
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt lastField;
    sqInt methodHeader;
    sqInt rcvr;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    sqInt sp4;
    sqInt sp5;
    sqInt sp6;
    sqInt sz;
    sqInt thang;
    sqInt top;
    sqInt top1;
    sqInt type;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	thang = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	rcvr = top1;
	if ((rcvr & 1)) {
		/* begin pushBool: */
		if (0) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
		return null;
	}
	/* begin lastPointerOf: */
	header = longAt(rcvr);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp6 = longAt((rcvr + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp6 & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp6 >> 1);
		l1:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(rcvr);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		lastField = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		lastField = 0;
		goto l2;
	}
	methodHeader = longAt(rcvr + BaseHeaderSize);
	lastField = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	for (i = BaseHeaderSize; i <= lastField; i += BytesPerWord) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pushBool: */
			if (1) {
				/* begin push: */
				longAtput((sp2 = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
				GIV(stackPointer) = sp2;
			}
			else {
				/* begin push: */
				longAtput((sp3 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
				GIV(stackPointer) = sp3;
			}
			return null;
		}
	}
	/* begin pushBool: */
	if (0) {
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp4;
	}
	else {
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp5;
	}
}

static sqInt
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt errorCode;
    sqInt fromIndex;
    sqInt i;
    sqInt i1;
    sqInt initialIP;
    sqInt lastFrom;
    sqInt lookupClass;
    sqInt methodHeader;
    sqInt newContext;
    sqInt newReceiver;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt performMethod;
    sqInt performSelector;
    sqInt selectorIndex;
    sqInt tempCount;
    sqInt tmp;
    sqInt toIndex;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt where;

	performSelector = GIV(messageSelector);
	performMethod = GIV(newMethod);
	GIV(messageSelector) = longAt(GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord));

	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:, so we must adjust argumentCount and slide args now, so that would work. */
	/* Slide arguments down over selector */

	newReceiver = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	selectorIndex = (((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - GIV(argumentCount);
	/* begin transfer:fromIndex:ofObject:toIndex:ofObject: */
	flag("Dan");
	fromIndex = GIV(activeContext) + ((selectorIndex + 1) * BytesPerWord);
	toIndex = GIV(activeContext) + (selectorIndex * BytesPerWord);
	lastFrom = fromIndex + (GIV(argumentCount) * BytesPerWord);
	while ((((usqInt) fromIndex)) < (((usqInt) lastFrom))) {
		fromIndex += BytesPerWord;
		toIndex += BytesPerWord;
		longAtput(toIndex, longAt(fromIndex));
	}
	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	/* begin fetchClassOf: */
	if ((newReceiver & 1)) {
		lookupClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(newReceiver))) >> 12) & 31)) == 0) {
		lookupClass = (longAt(newReceiver - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		lookupClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), newReceiver);
	findNewMethodInClass(lookupClass);
	if (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12) {
		/* begin success: */
		if (!(((((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15) == GIV(argumentCount))) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin executeNewMethod */
		if (primitiveFunctionPointer != 0) {
			if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
				externalQuickPrimitiveResponse();
				goto l1;
			}
			if (slowPrimitiveResponse()) {
				goto l1;
			}
		}
		/* begin activateNewMethod */
		VM_LABEL(3activateNewMethod);
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
		initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

		/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

		tempCount = (((usqInt) methodHeader) >> 19) & 63;
		where = newContext + BaseHeaderSize;
		longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
		longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
		longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
		longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
		longAtput(where + (ClosureIndex << ShiftForWord), GIV(nilObj));
		for (i1 = 0; i1 <= GIV(argumentCount); i1 += 1) {
			longAtput(where + ((ReceiverIndex + i1) << ShiftForWord), longAt(GIV(stackPointer) - ((GIV(argumentCount) - i1) * BytesPerWord)));
		}
		nilOop = GIV(nilObj);
		for (i1 = ((GIV(argumentCount) + 1) + ReceiverIndex); i1 <= (tempCount + ReceiverIndex); i1 += 1) {
			longAtput(where + (i1 << ShiftForWord), nilOop);
		}
		if (GIV(primFailCode) > 0) {
			if (((primitiveIndexOfMethodHeader(methodHeader)) > 0)
			 && ((byteAt((GIV(newMethod) + BaseHeaderSize) + (initialIP - 1))) == 129)) {
				errorCode = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord))) + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
				longAtput(where + ((tempCount + ReceiverIndex) << ShiftForWord), errorCode);
			}
			GIV(primFailCode) = 0;
		}
		/* begin pop: */
		GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
		GIV(reclaimableContextCount) += 1;
		/* begin newActiveContext: */
		VM_LABEL(3newActiveContext);
		/* begin storeContextRegisters: */
		longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
		longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
		if (newContext < GIV(youngStart)) {
			beRootIfOld(newContext);
		}
		GIV(activeContext) = newContext;
		/* begin fetchContextRegisters: */
		VM_LABEL(5fetchContextRegisters);
		tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((tmp & 1)) {

			/* if the MethodIndex field is an integer, activeCntx is a block context */

			tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
			if (tmp < GIV(youngStart)) {
				beRootIfOld(tmp);
			}
		}
		else {

			/* otherwise, it is a method context and is its own home context  */

			tmp = newContext;
		}
		GIV(theHomeContext) = tmp;
		GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

		/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

		GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

		/* the stack pointer is a pointer variable also... */

		GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
		tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
		GIV(stackPointer) = (newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
		/* begin quickCheckForInterrupts */
		if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
			checkForInterrupts();
		}
	l1:	/* end executeNewMethod */;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	else {
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			/* begin storePointer:ofObject:withValue: */
			oop = GIV(activeContext);
			valuePointer = longAt((GIV(activeContext) + BaseHeaderSize) + (((GIV(argumentCount) - i) + selectorIndex) << ShiftForWord));
			if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop, valuePointer);
			}
			longAtput((oop + BaseHeaderSize) + ((((GIV(argumentCount) - i) + 1) + selectorIndex) << ShiftForWord), valuePointer);
		}
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		/* begin storePointer:ofObject:withValue: */
		oop1 = GIV(activeContext);
		valuePointer1 = GIV(messageSelector);
		if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop1, valuePointer1);
		}
		longAtput((oop1 + BaseHeaderSize) + (selectorIndex << ShiftForWord), valuePointer1);
		GIV(argumentCount) += 1;
		GIV(newMethod) = performMethod;
		GIV(messageSelector) = performSelector;
	}
}


/*	Common routine used by perform:withArgs: and
	perform:withArgs:inSuperclass: 
 */
/*	NOTE: The case of doesNotUnderstand: is not a failure to perform.
	The only failures are arg types and consistency of argumentCount. */

static sqInt
primitivePerformAt(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt cntxSize;
    sqInt errorCode;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt index;
    sqInt initialIP;
    sqInt methodHeader;
    sqInt newContext;
    sqInt nilOop;
    sqInt performArgCount;
    sqInt performMethod;
    sqInt performSelector;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt sz1;
    sqInt tempCount;
    sqInt tmp;
    sqInt top;
    sqInt top1;
    sqInt where;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!GIV(primFailCode)) {
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(argumentArray);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		arraySize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header1 = longAt(GIV(activeContext));
		if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(GIV(activeContext) - (BytesPerWord * 2))) & LongSizeMask;
			goto l2;
		}
		else {
			sz1 = header1 & SizeMask;
			goto l2;
		}
	l2:	/* end sizeBitsOf: */;
		cntxSize = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		/* begin success: */
		if (!(((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) + arraySize) < cntxSize)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}
	performSelector = GIV(messageSelector);
	performMethod = GIV(newMethod);

	/* pop the arg array and the selector, then push the args out of the array, as if they were on the stack */

	performArgCount = GIV(argumentCount);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	GIV(messageSelector) = top1;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((index - 1) << ShiftForWord)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	GIV(argumentCount) = arraySize;
	/* begin fastLogSend: */
	if (RecordSendTrace) {
		GIV(sendTraceLog)[GIV(sendTraceLogIndex)] = GIV(messageSelector);
		sendTraceLogIndex(GIV(sendTraceLogIndex) + 1);
	}
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), GIV(receiver));
	findNewMethodInClass(lookupClass);
	if (((((usqInt) (longAt(GIV(newMethod)))) >> 8) & 15) >= 12) {
		/* begin success: */
		if (!(((((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15) == GIV(argumentCount))) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin executeNewMethod */
		if (primitiveFunctionPointer != 0) {
			if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
				externalQuickPrimitiveResponse();
				goto l3;
			}
			if (slowPrimitiveResponse()) {
				goto l3;
			}
		}
		/* begin activateNewMethod */
		VM_LABEL(4activateNewMethod);
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
		newContext = allocateOrRecycleContext(methodHeader & LargeContextBit);
		initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

		/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

		tempCount = (((usqInt) methodHeader) >> 19) & 63;
		where = newContext + BaseHeaderSize;
		longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
		longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
		longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
		longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
		longAtput(where + (ClosureIndex << ShiftForWord), GIV(nilObj));
		for (i = 0; i <= GIV(argumentCount); i += 1) {
			longAtput(where + ((ReceiverIndex + i) << ShiftForWord), longAt(GIV(stackPointer) - ((GIV(argumentCount) - i) * BytesPerWord)));
		}
		nilOop = GIV(nilObj);
		for (i = ((GIV(argumentCount) + 1) + ReceiverIndex); i <= (tempCount + ReceiverIndex); i += 1) {
			longAtput(where + (i << ShiftForWord), nilOop);
		}
		if (GIV(primFailCode) > 0) {
			if (((primitiveIndexOfMethodHeader(methodHeader)) > 0)
			 && ((byteAt((GIV(newMethod) + BaseHeaderSize) + (initialIP - 1))) == 129)) {
				errorCode = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << ShiftForWord))) + BaseHeaderSize) + ((GIV(primFailCode) - 1) << ShiftForWord));
				longAtput(where + ((tempCount + ReceiverIndex) << ShiftForWord), errorCode);
			}
			GIV(primFailCode) = 0;
		}
		/* begin pop: */
		GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
		GIV(reclaimableContextCount) += 1;
		/* begin newActiveContext: */
		VM_LABEL(4newActiveContext);
		/* begin storeContextRegisters: */
		longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
		longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
		if (newContext < GIV(youngStart)) {
			beRootIfOld(newContext);
		}
		GIV(activeContext) = newContext;
		/* begin fetchContextRegisters: */
		VM_LABEL(6fetchContextRegisters);
		tmp = longAt((newContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((tmp & 1)) {

			/* if the MethodIndex field is an integer, activeCntx is a block context */

			tmp = longAt((newContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
			if (tmp < GIV(youngStart)) {
				beRootIfOld(tmp);
			}
		}
		else {

			/* otherwise, it is a method context and is its own home context  */

			tmp = newContext;
		}
		GIV(theHomeContext) = tmp;
		GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

		/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

		GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		tmp = ((longAt((newContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

		/* the stack pointer is a pointer variable also... */

		GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
		tmp = ((longAt((newContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
		GIV(stackPointer) = (newContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
		/* begin quickCheckForInterrupts */
		if (((GIV(interruptCheckCounter) -= 1)) <= 0) {
			checkForInterrupts();
		}
	l3:	/* end executeNewMethod */;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	else {
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(messageSelector));
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) + BytesPerWord), argumentArray);
		GIV(stackPointer) = sp2;
		GIV(messageSelector) = performSelector;
		GIV(newMethod) = performMethod;
		GIV(argumentCount) = performArgCount;
	}
}

static sqInt
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt currentClass;
    sqInt lookupClass;
    sqInt rcvr;
    sqInt sp;
    sqInt top;

	lookupClass = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		currentClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		currentClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		currentClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	while (currentClass != lookupClass) {
		currentClass = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
		if (currentClass == GIV(nilObj)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	primitivePerformAt(lookupClass);
	if (!(!GIV(primFailCode))) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), lookupClass);
		GIV(stackPointer) = sp;
	}
}

static sqInt
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt lookupClass;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	/* begin fetchClassOf: */
	if ((rcvr & 1)) {
		lookupClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l1;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> 12) & 31)) == 0) {
		lookupClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		lookupClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOf: */;
	primitivePerformAt(lookupClass);
}

static sqInt
primitiveQuit(void)
{
	ioExit();
}


/*	Rounds negative results towards zero. */

static sqInt
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		if (integerRcvr > 0) {
			if (integerArg > 0) {
				integerResult = integerRcvr / integerArg;
			}
			else {
				integerResult = 0 - (integerRcvr / (0 - integerArg));
			}
		}
		else {
			if (integerArg > 0) {
				integerResult = 0 - ((0 - integerRcvr) / integerArg);
			}
			else {
				integerResult = (0 - integerRcvr) / (0 - integerArg);
			}
		}
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

static sqInt
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		microSecs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioRelinquishProcessorForMicroseconds(microSecs);
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	put this process on the scheduler's lists thus allowing it to proceed next
	time there is a chance for processes of it's priority level
 */

static sqInt
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;


	/* rcvr */
	/* self success: ((self fetchClassOf: proc) = (self splObj: ClassProcess)). */

	proc = longAt(GIV(stackPointer));
	if (!GIV(primFailCode)) {
		resume(proc);
	}
}


/*	Primitive. Answer a copy (snapshot) element of the root table.
	The primitive can cause GC itself and if so the return value may
	be inaccurate - in this case one should guard the read operation
	by looking at the gc counter statistics. */

EXPORT(sqInt)
primitiveRootTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;
    sqInt sp;
    sqInt sz;

	sz = GIV(rootTableCount);

	/* can cause GC */

	oop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), sz);
	if (sz > GIV(rootTableCount)) {
		sz = GIV(rootTableCount);
	}
	for (i = 1; i <= sz; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oop, GIV(rootTable)[i]);
		}
		longAtput((oop + BaseHeaderSize) + ((i - 1) << ShiftForWord), GIV(rootTable)[i]);
	}
	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the nth element of the root table.
	This primitive avoids the creation of an extra array;
	it is intended for enumerations of the form:
	index := 1.
	[root := Smalltalk rootTableAt: index.
	root == nil] whileFalse:[index := index + 1].
	 */

EXPORT(sqInt)
primitiveRootTableAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    sqInt sp;
    sqInt successBoolean;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin success: */
	successBoolean = (index > 0)
	 && (index <= GIV(rootTableCount));
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(rootTable)[index]);
		GIV(stackPointer) = sp;
	}
}


/*	The character scanner primitive. */

static sqInt
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		kernDelta = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		stops = null;
		goto l1;
	}
	stops = oop;
l1:	/* end stackObjectValue: */;
	if (!(((stops & 1) == 0)
		 && (((((usqInt) (longAt(stops))) >> 8) & 15) == 2))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!((slotSizeOf(stops)) >= 258)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		scanRightX = (integerPointer1 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		scanRightX = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		sourceString = null;
		goto l2;
	}
	sourceString = oop1;
l2:	/* end stackObjectValue: */;
	if (!(((sourceString & 1) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> 8) & 15) >= 8))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) - (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		scanStopIndex = (integerPointer2 >> 1);
		goto l6;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		scanStopIndex = 0;
		goto l6;
	}
l6:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) - (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		scanStartIndex = (integerPointer3 >> 1);
		goto l7;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		scanStartIndex = 0;
		goto l7;
	}
l7:	/* end stackIntegerValue: */;
	if (!((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && (scanStopIndex <= (byteSizeOf(sourceString)))))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin stackObjectValue: */
	oop2 = longAt(GIV(stackPointer) - (6 * BytesPerWord));
	if ((oop2 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		rcvr = null;
		goto l3;
	}
	rcvr = oop2;
l3:	/* end stackObjectValue: */;
	if (!((((rcvr & 1) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 8) & 15) <= 4))
		 && ((slotSizeOf(rcvr)) >= 4))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2 << ShiftForWord));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3 << ShiftForWord));
	if (!((((scanXTable & 1) == 0)
 && (((((usqInt) (longAt(scanXTable))) >> 8) & 15) == 2))
		 && (((scanMap & 1) == 0)
		 && (((((usqInt) (longAt(scanMap))) >> 8) & 15) == 2)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!((slotSizeOf(scanMap)) == 256)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}

	/* Okay, here we go. We have eliminated nearly all failure 
	conditions, to optimize the inner fetches. */

	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */
		/* Known to be okay since stops size >= 258 */

		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (ascii << ShiftForWord)))) == nilOop)) {
			if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanDestX ^ (scanDestX << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (0 << ShiftForWord), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanLastIndex ^ (scanLastIndex << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (1 << ShiftForWord), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
			/* begin pop: */
			GIV(stackPointer) -= 7 * BytesPerWord;
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), stopReason);
			GIV(stackPointer) = sp;
			return null;
		}

		/* fail if the glyphIndex is out of range */

		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */

		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return null;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {
			if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
				return null;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanDestX ^ (scanDestX << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (0 << ShiftForWord), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanLastIndex ^ (scanLastIndex << 1)) >= 0) {
				longAtput((rcvr + BaseHeaderSize) + (1 << ShiftForWord), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
			/* begin pop: */
			GIV(stackPointer) -= 7 * BytesPerWord;
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), longAt((stops + BaseHeaderSize) + ((CrossedX - 1) << ShiftForWord)));
			GIV(stackPointer) = sp1;
			return null;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((scanDestX ^ (scanDestX << 1)) >= 0) {
		longAtput((rcvr + BaseHeaderSize) + (0 << ShiftForWord), ((scanDestX << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((scanStopIndex ^ (scanStopIndex << 1)) >= 0) {
		longAtput((rcvr + BaseHeaderSize) + (1 << ShiftForWord), ((scanStopIndex << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	/* begin pop: */
	GIV(stackPointer) -= 7 * BytesPerWord;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) + BytesPerWord), longAt((stops + BaseHeaderSize) + ((EndOfRun - 1) << ShiftForWord)));
	GIV(stackPointer) = sp2;
	return null;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    sqInt sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), ((depth << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the point is
	encoded into a single 32bit value in the image header. This might well
	become a problem one day
 */

static sqInt
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt pointResult;
    sqInt pointWord;
    sqInt sp;

	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
	pointWord = ioScreenSize();
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	pointResult = instantiateSmallClasssizeInBytes(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << ShiftForWord)), 3 * BytesPerWord);
	longAtput((pointResult + BaseHeaderSize) + (XIndex << ShiftForWord), ((((((usqInt) pointWord) >> 16) & 65535) << 1) | 1));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << ShiftForWord), (((pointWord & 65535) << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

static sqInt
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt sp;

	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(ioSeconds());
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

static sqInt
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    sqInt sp;
    sqInt sp1;
    sqInt w;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		d = (integerPointer2 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		d = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 5 * BytesPerWord;
		/* begin pushBool: */
		if (okay) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

static sqInt
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Indicate if the GC logic should have bias to grow */

EXPORT(sqInt)
primitiveSetGCBiasToGrow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		flag = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		flag = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcBiasToGrow) = flag;
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. If the GC logic has bias to grow, set growth limit */

EXPORT(sqInt)
primitiveSetGCBiasToGrowGCLimit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		value = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcBiasToGrowGCLimit) = value;
		GIV(gcBiasToGrowThreshold) = GIV(youngStart) - (((int) memory));
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

EXPORT(sqInt)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
	}
}

static sqInt
primitiveSetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt boolean;
    sqInt hdr;
    sqInt rcvr;
    sqInt sp;
    sqInt wasImmutable;

	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}
	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		boolean = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		boolean = 0;
		goto l1;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
	boolean = null;
l1:	/* end booleanValueOf: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	hdr = longAt(rcvr);
	wasImmutable = hdr & ImmutabilityBit;
	if (boolean) {
		hdr = hdr | ImmutabilityBit;
	}
	else {
		hdr = hdr & AllButImmutabilityBit;
	}
	longAtput(rcvr, hdr);
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) - ((GIV(argumentCount) - 1) * BytesPerWord)), (wasImmutable != 0
		? (GIV(trueObj))
		: (GIV(falseObj))));
	GIV(stackPointer) = sp;
}


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

static sqInt
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		keycode = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (!GIV(primFailCode)) {
		GIV(interruptKeycode) = keycode;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Return the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

static sqInt
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    sqInt sp;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	rcvr = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	if (((rcvr & 1))
	 || (!(((rcvr & 1) == 0)
 && (isWordsOrBytesNonInt(rcvr))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((sizeBitsOf(rcvr)) - BaseHeaderSize) >> 1);
	if (!((index >= 1)
		 && (index <= sz))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	addr = (rcvr + BaseHeaderSize) + (2 * (index - 1));
	value = shortAt(addr);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value. Note that the index specifies the i-th 16-bit entry, not the
	i-th byte or word.
 */

static sqInt
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt rcvr;
    sqInt sp;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		value = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		index = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!((!GIV(primFailCode))
		 && ((value >= -32768)
		 && (value <= 32767)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return null;
	}
	rcvr = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if (!((!((rcvr & 1)))
		 && (((rcvr & 1) == 0)
		 && (isWordsOrBytesNonInt(rcvr))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return null;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((sizeBitsOf(rcvr)) - BaseHeaderSize) >> 1);
	if (!((index >= 1)
		 && (index <= sz))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return null;
	}
	if (!(((longAt(rcvr)) & ImmutabilityBit) == 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	addr = (rcvr + BaseHeaderSize) + (2 * (index - 1));
	shortAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

static sqInt
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		bottom = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		top = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		top = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		right = (integerPointer2 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		right = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		left = (integerPointer3 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		left = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord)), left, top, right, bottom);
	if (!GIV(primFailCode)) {
		ioForceDisplayUpdate();
		/* begin pop: */
		GIV(stackPointer) -= 4 * BytesPerWord;
	}
}


/*	synchromously signal the semaphore. This may change the active process as
	a result
 */

static sqInt
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt sema;


	/* rcvr */

	sema = longAt(GIV(stackPointer));
	/* begin assertClassOf:is: */
	VM_LABEL(11assertClassOfis);
	if ((sema & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(sema))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(sema - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		synchronousSignal(sema);
	}
}


/*	Set the low-water mark for free space. When the free space 
	falls below this level, the new and new: primitives fail and 
	system attempts to allocate space (e.g., to create a method 
	context) cause the low-space semaphore (if one is 
	registered) to be signalled. */

static sqInt
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytes = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		bytes = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (!GIV(primFailCode)) {
		GIV(lowSpaceThreshold) = bytes;
	}
	else {
		GIV(lowSpaceThreshold) = 0;
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to
	be signalled when the millisecond clock is greater than or
	equal to the given tick value. A tick value of zero turns off
	timer interrupts. */

static sqInt
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt oop;
    sqInt oop1;
    sqInt sema;
    sqInt tick;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		tick = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		tick = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	sema = top1;
	if (!GIV(primFailCode)) {
		if ((fetchClassOf(sema)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord)))) {
			/* begin storePointer:ofObject:withValue: */
			oop = GIV(specialObjectsOop);
			if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop, sema);
			}
			longAtput((oop + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord), sema);
			GIV(nextWakeupTick) = tick;
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			oop1 = GIV(specialObjectsOop);
			valuePointer = GIV(nilObj);
			if ((((usqInt) oop1)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oop1, valuePointer);
			}
			longAtput((oop1 + BaseHeaderSize) + (TheTimerSemaphore << ShiftForWord), valuePointer);
			GIV(nextWakeupTick) = 0;
		}
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  f;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(5popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(12assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sin(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

static sqInt
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt rcvr;
    sqInt sp;
    sqInt sz;

	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (((((usqInt) (longAt(rcvr))) >> 8) & 15) < 2) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	sz = stSizeOf(rcvr);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positive32BitIntegerFor(sz);
		longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	save a normal snapshot under the same name as it was loaded unless it has
	been renamed by the last primitiveImageName
 */

static sqInt
primitiveSnapshot(void)
{
	return snapshot(0);
}


/*	save an embedded snapshot */

static sqInt
primitiveSnapshotEmbedded(void)
{
	return snapshot(1);
}

static sqInt
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt header;
    sqInt instance;
    sqInt obj;
    sqInt sp;
    sqInt sz;
    sqInt thisClass;
    sqInt thisObj;

	class = longAt(GIV(stackPointer));
	/* begin initialInstanceOf: */
	/* begin firstAccessibleObject */
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			thisObj = obj;
			goto l3;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l4;
			}
			else {
				sz = header & SizeMask;
				goto l4;
			}
		l4:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	thisObj = null;
l3:	/* end firstAccessibleObject */;
	while (!(thisObj == null)) {
		/* begin fetchClassOf: */
		if ((thisObj & 1)) {
			thisClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
			goto l2;
		}
		if (((ccIndex = (((usqInt) (longAt(thisObj))) >> 12) & 31)) == 0) {
			thisClass = (longAt(thisObj - BaseHeaderSize)) & AllButTypeMask;
			goto l2;
		}
		else {
			thisClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l2;
		}
	l2:	/* end fetchClassOf: */;
		if (thisClass == class) {
			instance = thisObj;
			goto l1;
		}
		thisObj = accessibleObjectAfter(thisObj);
	}
	instance = GIV(nilObj);
l1:	/* end initialInstanceOf: */;
	if (instance == GIV(nilObj)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

static sqInt
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt obj;
    sqInt object;
    sqInt sp;
    sqInt sz;

	/* begin pop: */
	GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	/* begin firstAccessibleObject */
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			object = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	object = null;
l1:	/* end firstAccessibleObject */;
	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

static sqInt
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}

static sqInt
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  f;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;

	/* begin popFloat */
	VM_LABEL(6popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(13assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	/* begin success: */
	if (!(rcvr >= 0.0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sqrt(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

static sqInt
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) - (1 * BytesPerWord));

	/* Essential type checks */

	arrayOfRoots = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	if (!((((arrayOfRoots & 1) == 0)
 && (((((usqInt) (longAt(arrayOfRoots))) >> 8) & 15) == 2))
		 && ((((outPointerArray & 1) == 0)
 && (((((usqInt) (longAt(outPointerArray))) >> 8) & 15) == 2))
		 && (((segmentWordArray & 1) == 0)
		 && (((((usqInt) (longAt(segmentWordArray))) >> 8) & 15) == 6))))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	if (ecode == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) -= 3 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ecode;
	}
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

static sqInt
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt integerPointer;
    sqInt newStackp;
    sqInt sp;
    sqInt stackp;
    sqInt valuePointer;

	ctxt = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		newStackp = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		newStackp = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(newStackp >= 0)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	/* begin success: */
	if (!(newStackp <= ((((sqInt) (LargeContextSize - BaseHeaderSize) >> 2)) - CtxtTempFrameStart))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	if (!((sp & 1))) {
		stackp = 0;
		goto l1;
	}
	stackp = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
	if (newStackp > stackp) {
		for (i = (stackp + 1); i <= newStackp; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = GIV(nilObj);
			if ((((usqInt) ctxt)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(ctxt, valuePointer);
			}
			longAtput((ctxt + BaseHeaderSize) + (((i + CtxtTempFrameStart) - 1) << ShiftForWord), valuePointer);
		}
	}
	/* begin storeStackPointerValue:inContext: */
	longAtput((ctxt + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((newStackp << 1) | 1));
	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
}

static sqInt
primitiveStringAt(void)
{
	commonAt(1);
}

static sqInt
primitiveStringAtPut(void)
{
	commonAtPut(1);
}


/*	
	<array> primReplaceFrom: start to: stop with: replacement startingAt:
	repStart 
	<primitive: 105>
	 */

static sqInt
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt hdr1;
    sqInt hdr2;
    sqInt i;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    sqInt replStart;
    sqInt srcIndex;
    sqInt start;
    sqInt stop;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;
    sqInt valueWord;
    sqInt valueWord1;

	array = longAt(GIV(stackPointer) - (4 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		start = (integerPointer >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		start = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) - (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		stop = (integerPointer1 >> 1);
		goto l6;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		stop = 0;
		goto l6;
	}
l6:	/* end stackIntegerValue: */;
	repl = longAt(GIV(stackPointer) - (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		replStart = (integerPointer2 >> 1);
		goto l7;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		replStart = 0;
		goto l7;
	}
l7:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if ((repl & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	hdr1 = longAt(array);
	arrayFmt = (((usqInt) hdr1) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr1 & SizeMask;
	}
	sz -= hdr1 & Size4Bit;
	if (arrayFmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (arrayFmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (arrayFmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt > 4)
	 || (arrayFmt == 2)) {
		arrayInstSize = 0;
		goto l2;
	}
	if (arrayFmt < 2) {
		arrayInstSize = totalLength;
		goto l2;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(array))) >> 12) & 31)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
		goto l8;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l8;
	}
l8:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	arrayInstSize = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && ((stop + arrayInstSize) <= totalLength)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	hdr2 = longAt(repl);
	replFmt = (((usqInt) hdr2) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr2 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(repl - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr2 & SizeMask;
	}
	sz1 -= hdr2 & Size4Bit;
	if (replFmt <= 4) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l3;
	}
	if (replFmt < 8) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l3;
	}
	else {
		totalLength = (sz1 - BaseHeaderSize) - (replFmt & 3);
		goto l3;
	}
l3:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((replFmt > 4)
	 || (replFmt == 2)) {
		replInstSize = 0;
		goto l4;
	}
	if (replFmt < 2) {
		replInstSize = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex1 = (((usqInt) (longAt(repl))) >> 12) & 31)) == 0) {
		class1 = (longAt(repl - BaseHeaderSize)) & AllButTypeMask;
		goto l9;
	}
	else {
		class1 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
		goto l9;
	}
l9:	/* end fetchClassOfNonInt: */;
	classFormat1 = (longAt((class1 + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	replInstSize = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 63)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart >= 1)
		 && ((((stop - start) + replStart) + replInstSize) <= totalLength))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (arrayFmt < 8) {
		if (!(arrayFmt == replFmt)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	else {
		if (!((arrayFmt & 12) == (replFmt & 12))) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	if ((hdr1 & ImmutabilityBit) != 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return null;
	}
	if (replStart >= start) {

		/* - 1 for 0-based access */

		srcIndex = (replStart + replInstSize) - 1;
		if (arrayFmt <= 4) {
			for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) array)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(array, longAt((repl + BaseHeaderSize) + (srcIndex << ShiftForWord)));
				}
				longAtput((array + BaseHeaderSize) + (i << ShiftForWord), longAt((repl + BaseHeaderSize) + (srcIndex << ShiftForWord)));
				srcIndex += 1;
			}
		}
		else {
			if (arrayFmt < 8) {
				for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
					/* begin storeLong32:ofObject:withValue: */
					valueWord = long32At((repl + BaseHeaderSize) + (srcIndex << 2));
					long32Atput((array + BaseHeaderSize) + (i << 2), valueWord);
					srcIndex += 1;
				}
			}
			else {
				for (i = ((start + arrayInstSize) - 1); i <= ((stop + arrayInstSize) - 1); i += 1) {
					byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + srcIndex));
					srcIndex += 1;
				}
			}
		}
	}
	else {

		/* - 1 for 0-based access */

		srcIndex = (((replStart + replInstSize) - 1) + stop) - start;
		if (arrayFmt <= 4) {
			for (i = ((stop + arrayInstSize) - 1); i >= ((start + arrayInstSize) - 1); i += -1) {
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) array)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(array, longAt((repl + BaseHeaderSize) + (srcIndex << ShiftForWord)));
				}
				longAtput((array + BaseHeaderSize) + (i << ShiftForWord), longAt((repl + BaseHeaderSize) + (srcIndex << ShiftForWord)));
				srcIndex -= 1;
			}
		}
		else {
			if (arrayFmt < 8) {
				for (i = ((stop + arrayInstSize) - 1); i >= ((start + arrayInstSize) - 1); i += -1) {
					/* begin storeLong32:ofObject:withValue: */
					valueWord1 = long32At((repl + BaseHeaderSize) + (srcIndex << 2));
					long32Atput((array + BaseHeaderSize) + (i << 2), valueWord1);
					srcIndex -= 1;
				}
			}
			else {
				for (i = ((stop + arrayInstSize) - 1); i >= ((start + arrayInstSize) - 1); i += -1) {
					byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + srcIndex));
					srcIndex -= 1;
				}
			}
		}
	}
	/* begin pop: */
	GIV(stackPointer) -= GIV(argumentCount) * BytesPerWord;
}

static sqInt
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    sqInt sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
	}
}

static sqInt
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt aProc;
    sqInt newProc;
    sqInt oldProc;
    sqInt sched;
    sqInt sp;
    sqInt tmp;
    sqInt valuePointer;
    sqInt valuePointer1;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin success: */
	if (!((longAt(GIV(stackPointer))) == activeProc)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
		/* begin transferTo: */
		VM_LABEL(0transferTo);
		aProc = wakeHighestPriority();
		newProc = aProc;
		sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord));
		oldProc = longAt((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) sched)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(sched, newProc);
		}
		longAtput((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord), newProc);
		/* begin storePointer:ofObject:withValue: */
		valuePointer = GIV(activeContext);
		if ((((usqInt) oldProc)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oldProc, valuePointer);
		}
		longAtput((oldProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer);
		/* begin newActiveContext: */
		VM_LABEL(5newActiveContext);
		/* begin storeContextRegisters: */
		longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
		longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
		if ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) < GIV(youngStart)) {
			beRootIfOld(longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord)));
		}
		GIV(activeContext) = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
		/* begin fetchContextRegisters: */
		VM_LABEL(7fetchContextRegisters);
		tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((tmp & 1)) {

			/* if the MethodIndex field is an integer, activeCntx is a block context */

			tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
			if (tmp < GIV(youngStart)) {
				beRootIfOld(tmp);
			}
		}
		else {

			/* otherwise, it is a method context and is its own home context  */

			tmp = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
		}
		GIV(theHomeContext) = tmp;
		GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

		/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

		GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

		/* the stack pointer is a pointer variable also... */

		GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
		tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
		GIV(stackPointer) = ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
		/* begin storePointer:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		if ((((usqInt) newProc)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(newProc, valuePointer1);
		}
		longAtput((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer1);
		GIV(reclaimableContextCount) = 0;
	}
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my sender. This prim has to shadow the code in
	ContextPart>terminateTo: to be correct
 */

static sqInt
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt currentCntx;
    sqInt nextCntx;
    sqInt nilOop;
    sqInt sp;
    sqInt thisCntx;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	aContext = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	thisCntx = top1;
	if (contexthasSender(thisCntx, aContext)) {
		nilOop = GIV(nilObj);
		currentCntx = longAt((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
		while (!(currentCntx == aContext)) {
			nextCntx = longAt((currentCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) currentCntx)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(currentCntx, nilOop);
			}
			longAtput((currentCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord), nilOop);
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) currentCntx)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(currentCntx, nilOop);
			}
			longAtput((currentCntx + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), nilOop);
			currentCntx = nextCntx;
		}
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) thisCntx)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(thisCntx, aContext);
	}
	longAtput((thisCntx + BaseHeaderSize) + (SenderIndex << ShiftForWord), aContext);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), thisCntx);
	GIV(stackPointer) = sp;
	return null;
}


/*	Return true if the host OS does support the given display depth. */

static sqInt
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    sqInt sp;
    sqInt sp1;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) - (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bitsPerPixel = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		bitsPerPixel = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
		/* begin pushBool: */
		if (okay) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
			GIV(stackPointer) = sp1;
		}
	}
}

static sqInt
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt cl;
    double  f;
    sqInt integerPointer;
    sqInt object;
    double  rcvr;
    double  result;
    sqInt sp;
    sqInt top;
    sqInt top1;
    sqInt top2;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		arg = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popFloat */
	VM_LABEL(7popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top2 = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(14assertClassOfis);
	if ((top2 & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l2;
	}
	ccIndex = (((usqInt) (longAt(top2))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top2 - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l2:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top2 + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = ldexp(rcvr, arg);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}

static sqInt
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    double  frac;
    double  rcvr;
    double  result;
    sqInt top;
    sqInt top1;
    double  trunc;

	/* begin popFloat */
	VM_LABEL(8popFloat);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	top = top1;
	/* begin assertClassOf:is: */
	VM_LABEL(15assertClassOfis);
	if ((top & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(top))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(top - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		;
		fetchFloatAtinto(top + BaseHeaderSize, result);
	}
	rcvr = result;
	if (!GIV(primFailCode)) {
		frac = modf(rcvr, &trunc);
		flag("Dan");
		success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0));
	}
	if (!GIV(primFailCode)) {
		pushInteger((sqInt) trunc);
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current
	sessionID. 
 */

static sqInt
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt moduleName;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	moduleName = longAt(GIV(stackPointer));
	if ((moduleName & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!(((moduleName & 1) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> 8) & 15) >= 8))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), byteSizeOf(moduleName)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	flushExternalPrimitives();
	/* begin forceInterruptCheck */
	GIV(interruptCheckCounter) = -1000;
	GIV(nextPollTick) = 0;
	/* begin pop: */
	GIV(stackPointer) -= 1 * BytesPerWord;
}

static sqInt
primitiveValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockArgumentCount;
    sqInt blockContext;
    sqInt fromIndex;
    sqInt initialIP;
    sqInt lastFrom;
    sqInt localArgCount;
    sqInt successBoolean;
    sqInt tmp;
    sqInt toIndex;

	blockContext = longAt(GIV(stackPointer) - (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfBlock: */
	localArgCount = longAt((blockContext + BaseHeaderSize) + (BlockArgumentCountIndex << ShiftForWord));
	/* begin checkedIntegerValueOf: */
	if ((localArgCount & 1)) {
		blockArgumentCount = (localArgCount >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		blockArgumentCount = 0;
		goto l1;
	}
l1:	/* end argumentCountOfBlock: */;
	/* begin success: */
	successBoolean = (GIV(argumentCount) == blockArgumentCount)
	 && ((longAt((blockContext + BaseHeaderSize) + (CallerIndex << ShiftForWord))) == GIV(nilObj));
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin transfer:fromIndex:ofObject:toIndex:ofObject: */
		VM_LABEL(0transferfromIndexofObjecttoIndexofObject);
		flag("Dan");
		fromIndex = GIV(activeContext) + ((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - GIV(argumentCount)) + 1) * BytesPerWord);
		toIndex = blockContext + (TempFrameStart * BytesPerWord);
		lastFrom = fromIndex + (GIV(argumentCount) * BytesPerWord);
		while ((((usqInt) fromIndex)) < (((usqInt) lastFrom))) {
			fromIndex += BytesPerWord;
			toIndex += BytesPerWord;
			longAtput(toIndex, longAt(fromIndex));
		}
		/* begin pop: */
		GIV(stackPointer) -= (GIV(argumentCount) + 1) * BytesPerWord;
		initialIP = longAt((blockContext + BaseHeaderSize) + (InitialIPIndex << ShiftForWord));
		longAtput((blockContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), initialIP);
		/* begin storeStackPointerValue:inContext: */
		longAtput((blockContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((GIV(argumentCount) << 1) | 1));
		longAtput((blockContext + BaseHeaderSize) + (CallerIndex << ShiftForWord), GIV(activeContext));
		/* begin newActiveContext: */
		VM_LABEL(6newActiveContext);
		/* begin storeContextRegisters: */
		longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
		longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
		if (blockContext < GIV(youngStart)) {
			beRootIfOld(blockContext);
		}
		GIV(activeContext) = blockContext;
		/* begin fetchContextRegisters: */
		VM_LABEL(8fetchContextRegisters);
		tmp = longAt((blockContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((tmp & 1)) {

			/* if the MethodIndex field is an integer, activeCntx is a block context */

			tmp = longAt((blockContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
			if (tmp < GIV(youngStart)) {
				beRootIfOld(tmp);
			}
		}
		else {

			/* otherwise, it is a method context and is its own home context  */

			tmp = blockContext;
		}
		GIV(theHomeContext) = tmp;
		GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

		/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

		GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		tmp = ((longAt((blockContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

		/* the stack pointer is a pointer variable also... */

		GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
		tmp = ((longAt((blockContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
		GIV(stackPointer) = (blockContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	}
}

static sqInt
primitiveValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arrayArgumentCount;
    sqInt blockArgumentCount;
    sqInt blockContext;
    sqInt fromIndex;
    sqInt header;
    sqInt initialIP;
    sqInt lastFrom;
    sqInt localArgCount;
    sqInt successBoolean;
    sqInt sz;
    sqInt tmp;
    sqInt toIndex;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	argumentArray = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) -= BytesPerWord;
	blockContext = top1;
	/* begin argumentCountOfBlock: */
	localArgCount = longAt((blockContext + BaseHeaderSize) + (BlockArgumentCountIndex << ShiftForWord));
	/* begin checkedIntegerValueOf: */
	if ((localArgCount & 1)) {
		blockArgumentCount = (localArgCount >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		blockArgumentCount = 0;
		goto l2;
	}
l2:	/* end argumentCountOfBlock: */;
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 8) & 15) == 2))) {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (!GIV(primFailCode)) {
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(argumentArray);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(argumentArray - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		arrayArgumentCount = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		/* begin success: */
		successBoolean = (arrayArgumentCount == blockArgumentCount)
		 && ((longAt((blockContext + BaseHeaderSize) + (CallerIndex << ShiftForWord))) == GIV(nilObj));
		if (!(successBoolean)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin transfer:fromIndex:ofObject:toIndex:ofObject: */
		flag("Dan");
		fromIndex = argumentArray + (0 * BytesPerWord);
		toIndex = blockContext + (TempFrameStart * BytesPerWord);
		lastFrom = fromIndex + (arrayArgumentCount * BytesPerWord);
		while ((((usqInt) fromIndex)) < (((usqInt) lastFrom))) {
			fromIndex += BytesPerWord;
			toIndex += BytesPerWord;
			longAtput(toIndex, longAt(fromIndex));
		}
		initialIP = longAt((blockContext + BaseHeaderSize) + (InitialIPIndex << ShiftForWord));
		longAtput((blockContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), initialIP);
		/* begin storeStackPointerValue:inContext: */
		longAtput((blockContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), ((arrayArgumentCount << 1) | 1));
		longAtput((blockContext + BaseHeaderSize) + (CallerIndex << ShiftForWord), GIV(activeContext));
		/* begin newActiveContext: */
		/* begin storeContextRegisters: */
		longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
		longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
		if (blockContext < GIV(youngStart)) {
			beRootIfOld(blockContext);
		}
		GIV(activeContext) = blockContext;
		/* begin fetchContextRegisters: */
		VM_LABEL(9fetchContextRegisters);
		tmp = longAt((blockContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((tmp & 1)) {

			/* if the MethodIndex field is an integer, activeCntx is a block context */

			tmp = longAt((blockContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
			if (tmp < GIV(youngStart)) {
				beRootIfOld(tmp);
			}
		}
		else {

			/* otherwise, it is a method context and is its own home context  */

			tmp = blockContext;
		}
		GIV(theHomeContext) = tmp;
		GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

		/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

		GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		tmp = ((longAt((blockContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

		/* the stack pointer is a pointer variable also... */

		GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
		tmp = ((longAt((blockContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
		GIV(stackPointer) = (blockContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end of old-space (0-based, read-only)
	2	end of young-space (read-only)
	3	end of memory (read-only)
	4	allocationCount (read-only)
	5	allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs since startup (read-only)
	10	total milliseconds in incremental GCs since startup (read-only)
	11	tenures of surving objects since startup (read-only)
	12-20 specific to the translating VM
	21	root table size (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc.
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26 interruptChecksEveryNms - force an ioProcessEvents every N
	milliseconds, in case the image is not calling getNextEvent often (rw)
	27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	number of allocations done before current IGC/FGC (read-only)
	35	number of survivor objects after current IGC/FGC (read-only)
	36 millisecond clock when current IGC/FGC completed (read-only)
	37 number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38 milliseconds taken by current IGC (read-only)
	39 Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40 BytesPerWord for this image
	41 1 if the VM supports immutability, 0 otherwise
	
	Note: Thanks to Ian Piumarta for this primitive. */

static sqInt
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt i;
    sqInt index;
    sqInt mem;
    sqInt ok;
    sqInt paramsArraySize;
    sqInt result;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;

	mem = memory;
	paramsArraySize = 41;
	if (GIV(argumentCount) == 0) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << ShiftForWord)), paramsArraySize);
		for (i = 0; i <= (paramsArraySize - 1); i += 1) {
			longAtput((result + BaseHeaderSize) + (i << ShiftForWord), ConstZero);
		}
		longAtput((result + BaseHeaderSize) + (0 << ShiftForWord), (((GIV(youngStart) - mem) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (1 << ShiftForWord), (((GIV(freeBlock) - mem) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (2 << ShiftForWord), (((GIV(endOfMemory) - mem) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (3 << ShiftForWord), ((GIV(allocationCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (4 << ShiftForWord), ((GIV(allocationsBetweenGCs) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (5 << ShiftForWord), ((GIV(tenuringThreshold) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (6 << ShiftForWord), ((GIV(statFullGCs) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (7 << ShiftForWord), ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (8 << ShiftForWord), ((GIV(statIncrGCs) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (9 << ShiftForWord), ((((GIV(statIncrGCUsecs) + 500) / 1000) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (10 << ShiftForWord), ((GIV(statTenures) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (20 << ShiftForWord), ((GIV(rootTableCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (21 << ShiftForWord), ((GIV(statRootTableOverflows) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (22 << ShiftForWord), ((extraVMMemory << 1) | 1));
		longAtput((result + BaseHeaderSize) + (23 << ShiftForWord), ((GIV(shrinkThreshold) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (24 << ShiftForWord), ((GIV(growHeadroom) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (25 << ShiftForWord), ((GIV(interruptChecksEveryNms) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (26 << ShiftForWord), ((GIV(statMarkCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (27 << ShiftForWord), ((GIV(statSweepCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (28 << ShiftForWord), ((GIV(statMkFwdCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (29 << ShiftForWord), ((GIV(statCompMoveCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (30 << ShiftForWord), ((GIV(statGrowMemory) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (31 << ShiftForWord), ((GIV(statShrinkMemory) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (32 << ShiftForWord), ((GIV(statRootTableCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (33 << ShiftForWord), ((GIV(statAllocationCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (34 << ShiftForWord), ((GIV(statSurvivorCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (35 << ShiftForWord), ((GIV(statGCEndTime) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (36 << ShiftForWord), ((GIV(statSpecialMarkCount) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (37 << ShiftForWord), ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (38 << ShiftForWord), ((GIV(statPendingFinalizationSignals) << 1) | 1));
		longAtput((result + BaseHeaderSize) + (39 << ShiftForWord), ((BytesPerWord << 1) | 1));
		longAtput((result + BaseHeaderSize) + (40 << ShiftForWord), (((ImmutabilityBit != 0) << 1) | 1));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return null;
	}
	if (GIV(argumentCount) == 1) {
		index = longAt(GIV(stackPointer));
	}
	else {
		if (GIV(argumentCount) == 2) {
			index = longAt(GIV(stackPointer) - (1 * BytesPerWord));
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	if (!((index & 1))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	index = (index >> 1);
	if ((index < 1)
	 || (index > paramsArraySize)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (index == 1) {
		result = GIV(youngStart) - mem;
	}
	if (index == 2) {
		result = GIV(freeBlock) - mem;
	}
	if (index == 3) {
		result = GIV(endOfMemory) - mem;
	}
	if (index == 4) {
		result = GIV(allocationCount);
	}
	if (index == 5) {
		result = GIV(allocationsBetweenGCs);
	}
	if (index == 6) {
		result = GIV(tenuringThreshold);
	}
	if (index == 7) {
		result = GIV(statFullGCs);
	}
	if (index == 8) {
		result = (GIV(statFullGCUsecs) + 500) / 1000;
	}
	if (index == 9) {
		result = GIV(statIncrGCs);
	}
	if (index == 10) {
		result = (GIV(statIncrGCUsecs) + 500) / 1000;
	}
	if (index == 11) {
		result = GIV(statTenures);
	}
	if ((index >= 12)
	 && (index <= 20)) {
		result = 0;
	}
	if (index == 21) {
		result = GIV(rootTableCount);
	}
	if (index == 22) {
		result = GIV(statRootTableOverflows);
	}
	if (index == 23) {
		result = extraVMMemory;
	}
	if (index == 24) {
		result = GIV(shrinkThreshold);
	}
	if (index == 25) {
		result = GIV(growHeadroom);
	}
	if (index == 26) {
		result = GIV(interruptChecksEveryNms);
	}
	if (index == 27) {
		result = GIV(statMarkCount);
	}
	if (index == 28) {
		result = GIV(statSweepCount);
	}
	if (index == 29) {
		result = GIV(statMkFwdCount);
	}
	if (index == 30) {
		result = GIV(statCompMoveCount);
	}
	if (index == 31) {
		result = GIV(statGrowMemory);
	}
	if (index == 32) {
		result = GIV(statShrinkMemory);
	}
	if (index == 33) {
		result = GIV(statRootTableCount);
	}
	if (index == 34) {
		result = GIV(statAllocationCount);
	}
	if (index == 35) {
		result = GIV(statSurvivorCount);
	}
	if (index == 36) {
		result = GIV(statGCEndTime);
	}
	if (index == 37) {
		result = GIV(statSpecialMarkCount);
	}
	if (index == 38) {
		result = (GIV(statIGCDeltaUsecs) + 500) / 1000;
	}
	if (index == 39) {
		result = GIV(statPendingFinalizationSignals);
	}
	if (index == 40) {
		result = BytesPerWord;
	}
	if (index == 41) {
		result = ImmutabilityBit != 0;
	}
	if (GIV(argumentCount) == 1) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) - ((2 - 1) * BytesPerWord)), ((result << 1) | 1));
		GIV(stackPointer) = sp1;
		return null;
	}
	arg = longAt(GIV(stackPointer));
	if (!((arg & 1))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	arg = (arg >> 1);
	ok = 0;
	if (index == 5) {
		GIV(allocationsBetweenGCs) = arg;
		ok = 1;
	}
	if (index == 6) {
		GIV(tenuringThreshold) = arg;
		ok = 1;
	}
	if (index == 23) {
		extraVMMemory = arg;
		ok = 1;
	}
	if ((index == 24)
	 && (arg > 0)) {
		GIV(shrinkThreshold) = arg;
		ok = 1;
	}
	if ((index == 25)
	 && (arg > 0)) {
		GIV(growHeadroom) = arg;
		ok = 1;
	}
	if ((index == 26)
	 && (arg > 1)) {
		GIV(interruptChecksEveryNms) = arg;
		ok = 1;
	}
	if (ok) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) - ((3 - 1) * BytesPerWord)), ((result << 1) | 1));
		GIV(stackPointer) = sp2;
		return null;
	}
	/* begin primitiveFail */
	GIV(primFailCode) = 1;
}


/*	Return a string containing the path name of VM's directory. */

static sqInt
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    sqInt sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassString << ShiftForWord)), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

static sqInt
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt ccIndex;
    sqInt cl;
    sqInt numSamples;
    sqInt oop;
    sqInt running;
    sqInt sampleBuffer;
    unsigned long *sampleBufferAddress;
    sqInt sp;
    sqInt sp1;
    sqInt successBoolean;

	ioNewProfileStatus(&running,&bufferSize);
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) - ((1 - 1) * BytesPerWord)), (running
			? (GIV(trueObj))
			: (GIV(falseObj))));
		GIV(stackPointer) = sp;
		return null;
	}
	/* begin success: */
	if (!(GIV(argumentCount) == 1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin stackObjectValue: */
		oop = longAt(GIV(stackPointer) - (0 * BytesPerWord));
		if ((oop & 1)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			sampleBuffer = null;
			goto l1;
		}
		sampleBuffer = oop;
	l1:	/* end stackObjectValue: */;
		/* begin assertClassOf:is: */
		VM_LABEL(16assertClassOfis);
		if ((sampleBuffer & 1)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			goto l2;
		}
		ccIndex = (((usqInt) (longAt(sampleBuffer))) >> 12) & 31;
		if (ccIndex == 0) {
			cl = (longAt(sampleBuffer - BaseHeaderSize)) & AllButTypeMask;
		}
		else {

			/* look up compact class */

			cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		}
		/* begin success: */
		if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassBitmap << ShiftForWord))))) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	l2:	/* end assertClassOf:is: */;
		/* begin success: */
		successBoolean = (fetchWordLengthOf(sampleBuffer)) >= bufferSize;
		if (!(successBoolean)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
	}
	if (!(!GIV(primFailCode))) {
		return null;
	}
	/* begin firstFixedField: */
	sampleBufferAddress = ((void *) (pointerForOop(sampleBuffer + BaseHeaderSize)));
	numSamples = ioNewProfileSamplesInto(sampleBufferAddress);
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) - (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp1;
}

static sqInt
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt aProc;
    sqInt ccIndex;
    sqInt cl;
    sqInt excessSignals;
    sqInt lastLink;
    sqInt newProc;
    sqInt oldProc;
    sqInt sched;
    sqInt sema;
    sqInt tmp;
    sqInt valuePointer;
    sqInt valuePointer1;


	/* rcvr */

	sema = longAt(GIV(stackPointer));
	/* begin assertClassOf:is: */
	VM_LABEL(17assertClassOfis);
	if ((sema & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		goto l1;
	}
	ccIndex = (((usqInt) (longAt(sema))) >> 12) & 31;
	if (ccIndex == 0) {
		cl = (longAt(sema - BaseHeaderSize)) & AllButTypeMask;
	}
	else {

		/* look up compact class */

		cl = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
	}
	/* begin success: */
	if (!(cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord))))) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
l1:	/* end assertClassOf:is: */;
	if (!GIV(primFailCode)) {
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
		if (excessSignals > 0) {
			/* begin storeInteger:ofObject:withValue: */
			if (((excessSignals - 1) ^ ((excessSignals - 1) << 1)) >= 0) {
				longAtput((sema + BaseHeaderSize) + (ExcessSignalsIndex << ShiftForWord), (((excessSignals - 1) << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				GIV(primFailCode) = 1;
			}
		}
		else {
			activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			/* begin addLastLink:toList: */
			VM_LABEL(0addLastLinktoList);
			if ((longAt((sema + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) sema)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(sema, activeProc);
				}
				longAtput((sema + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), activeProc);
			}
			else {
				lastLink = longAt((sema + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
				/* begin storePointer:ofObject:withValue: */
				if ((((usqInt) lastLink)) < (((usqInt) GIV(youngStart)))) {
					possibleRootStoreIntovalue(lastLink, activeProc);
				}
				longAtput((lastLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), activeProc);
			}
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) sema)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(sema, activeProc);
			}
			longAtput((sema + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), activeProc);
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) activeProc)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(activeProc, sema);
			}
			longAtput((activeProc + BaseHeaderSize) + (MyListIndex << ShiftForWord), sema);
			/* begin transferTo: */
			VM_LABEL(1transferTo);
			aProc = wakeHighestPriority();
			newProc = aProc;
			sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord));
			oldProc = longAt((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) sched)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(sched, newProc);
			}
			longAtput((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord), newProc);
			/* begin storePointer:ofObject:withValue: */
			valuePointer = GIV(activeContext);
			if ((((usqInt) oldProc)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(oldProc, valuePointer);
			}
			longAtput((oldProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer);
			/* begin newActiveContext: */
			VM_LABEL(7newActiveContext);
			/* begin storeContextRegisters: */
			longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
			longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
			if ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) < GIV(youngStart)) {
				beRootIfOld(longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord)));
			}
			GIV(activeContext) = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
			/* begin fetchContextRegisters: */
			VM_LABEL(10fetchContextRegisters);
			tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
			if ((tmp & 1)) {

				/* if the MethodIndex field is an integer, activeCntx is a block context */

				tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
				if (tmp < GIV(youngStart)) {
					beRootIfOld(tmp);
				}
			}
			else {

				/* otherwise, it is a method context and is its own home context  */

				tmp = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
			}
			GIV(theHomeContext) = tmp;
			GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

			/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

			GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
			tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

			/* the stack pointer is a pointer variable also... */

			GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
			tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
			GIV(stackPointer) = ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
			/* begin storePointer:ofObject:withValue: */
			valuePointer1 = GIV(nilObj);
			if ((((usqInt) newProc)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(newProc, valuePointer1);
			}
			longAtput((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer1);
			GIV(reclaimableContextCount) = 0;
		}
	}
}


/*	primitively do the equivalent of Process>yield */

static sqInt
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt aProc;
    sqInt lastLink;
    sqInt newProc;
    sqInt oldProc;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt sched;
    sqInt tmp;
    sqInt valuePointer;
    sqInt valuePointer1;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	priority = ((longAt((activeProc + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1);
	processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	processList = longAt((processLists + BaseHeaderSize) + ((priority - 1) << ShiftForWord));
	if (!((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj))) {
		/* begin addLastLink:toList: */
		VM_LABEL(1addLastLinktoList);
		if ((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(processList, activeProc);
			}
			longAtput((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), activeProc);
		}
		else {
			lastLink = longAt((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) lastLink)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(lastLink, activeProc);
			}
			longAtput((lastLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), activeProc);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(processList, activeProc);
		}
		longAtput((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), activeProc);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) activeProc)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(activeProc, processList);
		}
		longAtput((activeProc + BaseHeaderSize) + (MyListIndex << ShiftForWord), processList);
		/* begin transferTo: */
		VM_LABEL(2transferTo);
		aProc = wakeHighestPriority();
		newProc = aProc;
		sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord));
		oldProc = longAt((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) sched)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(sched, newProc);
		}
		longAtput((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord), newProc);
		/* begin storePointer:ofObject:withValue: */
		valuePointer = GIV(activeContext);
		if ((((usqInt) oldProc)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(oldProc, valuePointer);
		}
		longAtput((oldProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer);
		/* begin newActiveContext: */
		VM_LABEL(8newActiveContext);
		/* begin storeContextRegisters: */
		longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
		longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
		if ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) < GIV(youngStart)) {
			beRootIfOld(longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord)));
		}
		GIV(activeContext) = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
		/* begin fetchContextRegisters: */
		VM_LABEL(11fetchContextRegisters);
		tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		if ((tmp & 1)) {

			/* if the MethodIndex field is an integer, activeCntx is a block context */

			tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
			if (tmp < GIV(youngStart)) {
				beRootIfOld(tmp);
			}
		}
		else {

			/* otherwise, it is a method context and is its own home context  */

			tmp = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
		}
		GIV(theHomeContext) = tmp;
		GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

		/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

		GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
		tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

		/* the stack pointer is a pointer variable also... */

		GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
		tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
		GIV(stackPointer) = ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
		/* begin storePointer:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		if ((((usqInt) newProc)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(newProc, valuePointer1);
		}
		longAtput((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer1);
		GIV(reclaimableContextCount) = 0;
	}
}

static sqInt
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt done;
    sqInt header;
    sqInt i;
    sqInt methClass;
    sqInt methodArray;
    sqInt methodSel;
    sqInt sz;

	if (isBlock) {
		print("[] in ");
	}
	/* begin findClassOfMethod:forReceiver: */
	VM_LABEL(0findClassOfMethodforReceiver);
	/* begin fetchClassOf: */
	if ((anObject & 1)) {
		currClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(anObject))) >> 12) & 31)) == 0) {
		currClass = (longAt(anObject - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		currClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	done = 0;
	while (!(done)) {
		classDict = longAt((currClass + BaseHeaderSize) + (MessageDictionaryIndex << ShiftForWord));
		/* begin fetchWordLengthOf: */
		/* begin sizeBitsOf: */
		header = longAt(classDict);
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(classDict - (BytesPerWord * 2))) & LongSizeMask;
			goto l1;
		}
		else {
			sz = header & SizeMask;
			goto l1;
		}
	l1:	/* end sizeBitsOf: */;
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		methodArray = longAt((classDict + BaseHeaderSize) + (MethodArrayIndex << ShiftForWord));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (aMethod == (longAt((methodArray + BaseHeaderSize) + (i << ShiftForWord)))) {
				methClass = currClass;
				goto l3;
			}
			i += 1;
		}
		currClass = longAt((currClass + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
		done = currClass == GIV(nilObj);
	}
	/* begin fetchClassOf: */
	if ((anObject & 1)) {
		methClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l3;
	}
	if (((ccIndex1 = (((usqInt) (longAt(anObject))) >> 12) & 31)) == 0) {
		methClass = (longAt(anObject - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		methClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex1 - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethodforReceiver(aMethod, anObject);
	if (((anObject & 1))
	 || (((anObject & 3) == 0)
	 && (((((usqInt)anObject)) >= memory)
	 && (((((usqInt)anObject)) < GIV(freeBlock))
	 && (((longAt(anObject)) & TypeMask) != HeaderTypeGC))))) {
		if ((fetchClassOf(anObject)) == methClass) {
			printNameOfClasscount(methClass, 5);
		}
		else {
			printNameOfClasscount(fetchClassOf(anObject), 5);
			print("(");
			printNameOfClasscount(methClass, 5);
			print(")");
		}
	}
	else {
		print("INVALID RECEIVER");
	}
	print(">");
	if (((methodSel & 1))
	 || (((methodSel & 3) == 0)
	 && (((((usqInt)methodSel)) >= memory)
	 && (((((usqInt)methodSel)) < GIV(freeBlock))
	 && (((longAt(methodSel)) & TypeMask) != HeaderTypeGC))))) {
		if (methodSel == GIV(nilObj)) {
			print("?");
		}
		else {
			printStringOf(methodSel);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord))))
	 && ((((maybeMessage & 3) == 0)
 && (((((usqInt)maybeMessage)) >= memory)
 && (((((usqInt)maybeMessage)) < GIV(freeBlock))
 && (((longAt(maybeMessage)) & TypeMask) != HeaderTypeGC))))
	 && ((fetchClassOf(maybeMessage)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMessage << ShiftForWord)))))) {

		/* print arg message selector */

		methodSel = longAt((maybeMessage + BaseHeaderSize) + (MessageSelectorIndex << ShiftForWord));
		print(" ");
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */

sqInt
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classObj;
    sqInt header;
    sqInt oop;
    sqInt pri;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;
    sqInt semaphoreClass;
    sqInt sz;

	proc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	printNameOfClasscount(fetchClassOf(proc), 5);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(proc);
	print(" priority ");
	printNum(((longAt((proc + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1));
	/* begin cr */
	printf("\n");
	printContextCallStackOf(GIV(activeContext));
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << ShiftForWord));
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(freeBlock)))) {
		/* begin fetchClassOfNonInt: */
		if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
			classObj = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
			goto l1;
		}
		else {
			classObj = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
			goto l1;
		}
	l1:	/* end fetchClassOfNonInt: */;
		if (classObj == semaphoreClass) {
			printProcsOnList(oop);
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	schedLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	for (pri = ((fetchWordLengthOf(schedLists)) - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + BaseHeaderSize) + (pri << ShiftForWord));
		if (!((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj))) {
			/* begin cr */
			printf("\n");
			print("processes at priority ");
			printNum(pri + 1);
			printProcsOnList(processList);
		}
	}
}

void
printCallStack(void)
{
	printCallStackOf(GIV(activeContext));
}

static sqInt
printCallStackOf(sqInt aContextOrProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt home;
    sqInt message;
    sqInt methodSel;

	if ((!(((aContextOrProcess & 1) == 0)
 && ((((((usqInt) (longAt(aContextOrProcess))) >> 12) & 31) == 13)
 || (((((usqInt) (longAt(aContextOrProcess))) >> 12) & 31) == 14))))
	 && (((lengthOf(aContextOrProcess)) > MyListIndex)
	 && ((((longAt((aContextOrProcess + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) & 1) == 0)
	 && ((((((usqInt) (longAt(longAt((aContextOrProcess + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))))) >> 12) & 31) == 13)
	 || (((((usqInt) (longAt(longAt((aContextOrProcess + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))))) >> 12) & 31) == 14))))) {
		return printCallStackOf(longAt((aContextOrProcess + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord)));
	}
	ctxt = aContextOrProcess;
	while (!(ctxt == GIV(nilObj))) {
		home = findHomeForContext(ctxt);
		printNum(ctxt);
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		printActivationNameForreceiverisBlockfirstTemporary(longAt((home + BaseHeaderSize) + (MethodIndex << ShiftForWord)), longAt((home + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)), home != ctxt, longAt((home + BaseHeaderSize) + ((0 + CtxtTempFrameStart) << ShiftForWord)));
		methodSel = findSelectorOfMethodforReceiver(longAt((home + BaseHeaderSize) + (MethodIndex << ShiftForWord)), longAt((home + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
		if (methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorDoesNotUnderstand << ShiftForWord)))) {

			/* print arg message selector */

			message = longAt((home + BaseHeaderSize) + ((0 + TempFrameStart) << ShiftForWord));
			methodSel = longAt((message + BaseHeaderSize) + (MessageSelectorIndex << ShiftForWord));
			print(" ");
			printStringOf(methodSel);
		}
		/* begin cr */
		printf("\n");
		ctxt = longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

sqInt
printChar(sqInt aByte)
{
	putchar(aByte);
}


/*	Print the call stack of aContext until it links to a frame. */

static sqInt
printContextCallStackOf(sqInt aContext)
{
    sqInt ctxt;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	}
	return ctxt;
}

sqInt
printContext(sqInt aContext)
{
    sqInt i;
    sqInt ip;
    sqInt na;
    sqInt sender;
    sqInt sp;
    sqInt spc;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	ip = longAt((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
	print("sender   ");
	shortPrintOop(sender);
	print("ip       ");
	printNum(ip);
	print(" (");
	printNum((ip >> 1));
	printHex((ip >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	sp = longAt((aContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
	print("sp       ");
	printNum(sp);
	print(" (");
	printNum((sp >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	if (((aContext & 1) == 0)
	 && (((((usqInt) (longAt(aContext))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		print("method   ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (MethodIndex << ShiftForWord)));
		print("closure  ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord)));
		print("receiver ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	}
	else {
		na = longAt((aContext + BaseHeaderSize) + (BlockArgumentCountIndex << ShiftForWord));
		print("numargs  ");
		printNum(na);
		print(" (");
		printNum((na >> 1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		spc = longAt((aContext + BaseHeaderSize) + (InitialIPIndex << ShiftForWord));
		print("startpc  ");
		printNum(spc);
		print(" (");
		printNum((spc >> 1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("home     ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (HomeIndex << ShiftForWord)));
	}
	sp = (sp >> 1);
	sp = ((sp < ((lengthOf(aContext)) - ReceiverIndex)) ? sp : ((lengthOf(aContext)) - ReceiverIndex));
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord)));
	}
}

sqInt
printContextWithSP(sqInt aContext, sqInt theSP)
{
    sqInt i;
    sqInt ip;
    sqInt na;
    sqInt sender;
    sqInt sp;
    sqInt spc;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	ip = longAt((aContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord));
	sp = ((((((usqInt) ((theSP - aContext) - BaseHeaderSize)) >> ShiftForWord) - ReceiverIndex) << 1) | 1);
	print("sender   ");
	shortPrintOop(sender);
	print("ip       ");
	printNum(ip);
	print(" (");
	printNum((ip >> 1));
	printHex((ip >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	print("sp       ");
	printNum(sp);
	print(" (");
	printNum((sp >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	if (((aContext & 1) == 0)
	 && (((((usqInt) (longAt(aContext))) >> 12) & 31) == ClassMethodContextCompactIndex)) {
		print("method   ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (MethodIndex << ShiftForWord)));
		print("closure  ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (ClosureIndex << ShiftForWord)));
		print("receiver ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)));
	}
	else {
		na = longAt((aContext + BaseHeaderSize) + (BlockArgumentCountIndex << ShiftForWord));
		print("numargs  ");
		printNum(na);
		print(" (");
		printNum((na >> 1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		spc = longAt((aContext + BaseHeaderSize) + (InitialIPIndex << ShiftForWord));
		print("startpc  ");
		printNum(spc);
		print(" (");
		printNum((spc >> 1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("home     ");
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (HomeIndex << ShiftForWord)));
	}
	sp = (sp >> 1);
	sp = ((sp < ((lengthOf(aContext)) - ReceiverIndex)) ? sp : ((lengthOf(aContext)) - ReceiverIndex));
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + ((ReceiverIndex + i) << ShiftForWord)));
	}
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles)  */

sqInt
printHex(sqInt n)
{
    char buf[35];
    sqInt len;

	memset(buf,' ',34);
	len = sprintf(buf + 2 + 2 * BytesPerWord, "0x%lx", (unsigned long)(n));
	printf("%s", buf + len);
	;
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

void
printInstancesOf(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt obj;
    sqInt oop;
    sqInt sz;

	/* begin firstAccessibleObject */
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			oop = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l1:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((fetchClassOfNonInt(oop)) == aClassOop) {
			printHex(oop);
			/* begin cr */
			printf("\n");
		}
		oop = accessibleObjectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    sqInt obj;
    sqInt oop;
    sqInt sz;

	/* begin firstAccessibleObject */
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			oop = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l1:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
			i = ((((usqInt) (longAt((oop + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) - 1;
			while (i >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (i << ShiftForWord)))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					i = 0;
				}
				i -= 1;
			}
		}
		oop = accessibleObjectAfter(oop);
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

static sqInt
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((classOop == 0)
	 || (cnt <= 0)) {
		return print("bad class");
	}
	if (((sizeBitsOf(classOop)) == GIV(metaclassSizeBytes))
	 && (GIV(metaclassSizeBytes) > (GIV(thisClassIndex) * BytesPerWord))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + (GIV(thisClassIndex) << ShiftForWord)), cnt - 1);
		print(" class");
	}
	else {
		printStringOf(longAt((classOop + BaseHeaderSize) + (GIV(classNameIndex) << ShiftForWord)));
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

static sqInt
printNum(sqInt n)
{
	printf("%ld", (long) n);
}

sqInt
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt cls;
    sqInt fmt;
    sqInt header;
    sqInt index;
    sqInt lastIndex;
    sqInt startIP;
    sqInt sz;

	printHex(oop);
	if ((oop & 1)) {
		return printf("=%ld\n", integerValueOf(oop));
	}
	if (!(((oop >= memory) && (oop <= GIV(freeBlock))))) {
		printHex(oop);
		print(" is not on the heap");
		/* begin cr */
		printf("\n");
		return null;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		printHex(oop);
		print(" is misaligned");
		/* begin cr */
		printf("\n");
		return null;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		print(" free chunk of size ");
		printNum((longAt(oop)) & AllButTypeMask);
		/* begin cr */
		printf("\n");
		return null;
	}
	print(": a(n) ");
	printNameOfClasscount((cls = fetchClassOfNonInt(oop)), 5);
	if (cls == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord)))) {
		/* begin cr */
		printf("\n");
		printFloat(dbgFloatValueOf(oop));
		/* begin cr */
		printf("\n");
		return null;
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if (fmt > 4) {
		print(" nbytes ");
		printNum(byteSizeOf(oop));
	}
	/* begin cr */
	printf("\n");
	if ((fmt > 4)
	 && (fmt < 12)) {
		if (((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> 8) & 15) == 6)) {
			lastIndex = ((64 < (((sqInt) (byteSizeOf(oop)) >> 2))) ? 64 : (((sqInt) (byteSizeOf(oop)) >> 2)));
			if (lastIndex > 0) {
				for (index = 1; index <= lastIndex; index += 1) {
					/* begin space */
					/* begin printChar: */
					putchar(' ');
					printHex(long32At((oop + BaseHeaderSize) + ((index - 1) << 2)));
					if ((index % 5) == 0) {
						/* begin cr */
						printf("\n");
					}
				}
				if (!((lastIndex % 5) == 0)) {
					/* begin cr */
					printf("\n");
				}
			}
			return null;
		}
		return (printStringOf(oop),/* begin cr */printf("\n"));
	}
	lastIndex = ((64 < ((startIP = ((sqInt) (lastPointerOf(oop)) >> 2)))) ? 64 : ((startIP = ((sqInt) (lastPointerOf(oop)) >> 2))));
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(fetchPointerofObject(index - 1, oop)); putchar(' ');
			if ((index % 5) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((lastIndex % 5) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf: */
		header = longAt(oop);
		/* begin lengthOf:baseHeader:format: */
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (((((usqInt) header) >> 8) & 15) <= 4) {
			lastIndex = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
			goto l1;
		}
		if (((((usqInt) header) >> 8) & 15) < 8) {
			lastIndex = ((usqInt) (sz - BaseHeaderSize)) >> 2;
			goto l1;
		}
		else {
			lastIndex = (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
			goto l1;
		}
	l1:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 10;
		for (index = startIP; index <= lastIndex; index += 1) {
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", byte,byte);
			if ((((index - startIP) + 1) % bytecodesPerLine) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((((lastIndex - startIP) + 1) % bytecodesPerLine) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}

sqInt
printProcessStack(sqInt aProcess)
{
    sqInt ctx;

	/* begin cr */
	printf("\n");
	printNameOfClasscount(fetchClassOf(aProcess), 5);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(aProcess);
	print(" priority ");
	printNum(((longAt((aProcess + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1));
	/* begin cr */
	printf("\n");
	ctx = longAt((aProcess + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	if (!(ctx == GIV(nilObj))) {
		printContextCallStackOf(ctx);
	}
}

sqInt
printProcsOnList(sqInt procList)
{
    sqInt firstProc;
    sqInt proc;

	proc = (firstProc = longAt((procList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord)));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		proc = longAt((proc + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    sqInt obj;
    sqInt oop;
    sqInt sz;

	/* begin firstAccessibleObject */
	obj = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			oop = obj;
			goto l1;
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) obj)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz = header & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l1:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((oop & 1) == 0)
 && (((((usqInt) (longAt(oop))) >> 8) & 15) <= 4))
		 || (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12)) {
			if (((((usqInt) (longAt(oop))) >> 8) & 15) >= 12) {
				i = ((((usqInt) (longAt((oop + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 10) & 255) - 1;
			}
			else {
				if (((oop & 1) == 0)
				 && ((((((usqInt) (longAt(oop))) >> 12) & 31) == 13)
				 || (((((usqInt) (longAt(oop))) >> 12) & 31) == 14))) {
					i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
				}
				else {
					i = (lengthOf(oop)) - 1;
				}
			}
			while (i >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (i << ShiftForWord)))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					i = 0;
				}
				i -= 1;
			}
		}
		oop = accessibleObjectAfter(oop);
	}
}

static sqInt
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt fmt;
    sqInt i;

	if ((oop & 1)) {
		return null;
	}
	if (!(((oop >= memory) && (oop <= GIV(freeBlock))))) {
		return null;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		return null;
	}
	fmt = (((usqInt) (longAt(oop))) >> 8) & 15;
	if (fmt < 8) {
		return null;
	}
	cnt = ((100 < (lengthOf(oop))) ? 100 : (lengthOf(oop)));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteArray << ShiftForWord)), 0))
	 || ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)), ClassLargePositiveIntegerCompactIndex))
	 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)), ClassLargeNegativeIntegerCompactIndex)))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			/* begin printChar: */
			putchar(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	flush();
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

sqInt
print(char *s)
{
	printf("%s", s);
}

sqInt
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;
    sqInt sp1;

	if (trueOrFalse) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp1;
	}
}

sqInt
pushFloat(double  f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt sp;

	/* begin push: */
	object = floatObjectOf(f);
	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
}

sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) + BytesPerWord), ((integerValue << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that objects in temporary variables are properly
	remapped. 
 */

void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
}

sqInt
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sp;

	longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Append aWord to aFile in this platforms 'natural' byte order. (Bytes will
	be swapped, if
	necessary, when the image is read on a different platform.) Set
	successFlag to false if
	the write fails.
 */

static sqInt
putLongtoFile(sqInt aWord, sqImageFile  aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite(&aWord, sizeof(aWord), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
}


/*	Anwer true if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. In our
	case we can select a newer (closure) image format as well as the existing
	format. 
 */

sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == imageFormatVersionNumber)
	 || (imageVersion == (imageFormatForwardCompatibilityVersion()));
}


/*	Read an image from the given file stream, allocating the given amount of
	memory to its object heap. Fail if the image has an unknown format or
	requires more than the given amount of memory.
 */
/*	Details: This method detects when the image was stored on a machine with
	the opposite byte ordering from this machine and swaps the bytes
	automatically. Furthermore, it allows the header information to start 512
	bytes into the file, since some file transfer programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix area could also be used to store an exec command on
	Unix systems, allowing one to launch Smalltalk by invoking the image name
	as a command.
 */
/*	This code is based on C code by Ian Piumarta and Smalltalk code by Tim
	Rowledge. Many thanks to both of you!!
 */

sqInt
readImageFromFileHeapSizeStartingAt(sqImageFile  f, usqInt desiredHeapSize, squeakFileOffsetType  imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t  dataSize;
    sqInt firstVersion;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt heapSize;
    usqInt memStart;
    sqInt minimumMemory;
    sqInt oldBaseAddr;
    sqInt swapBytes;
    sqInt version;


	/* guess (Metaclass instSize+1 * 4) */

	GIV(metaclassSizeBytes) = 7 * BytesPerWord;
	/* begin checkImageVersionFrom:startingAt: */
	VM_LABEL(0checkImageVersionFromstartingAt);
	sqImageFileSeek(f, imageOffset);
	version = (firstVersion = getLongFromFileswap(f, 0));
	if ((version == imageFormatVersionNumber)
	 || (version == (imageFormatForwardCompatibilityVersion()))) {
		swapBytes = 0;
		goto l1;
	}
	sqImageFileSeek(f, imageOffset);
	version = getLongFromFileswap(f, 1);
	if ((version == imageFormatVersionNumber)
	 || (version == (imageFormatForwardCompatibilityVersion()))) {
		swapBytes = 1;
		goto l1;
	}
	if (imageOffset == 0) {
		sqImageFileSeek(f, 512);
		version = getLongFromFileswap(f, 0);
		if ((version == imageFormatVersionNumber)
		 || (version == (imageFormatForwardCompatibilityVersion()))) {
			swapBytes = 0;
			goto l1;
		}
		sqImageFileSeek(f, 512);
		version = getLongFromFileswap(f, 1);
		if ((version == imageFormatVersionNumber)
		 || (version == (imageFormatForwardCompatibilityVersion()))) {
			swapBytes = 1;
			goto l1;
		}
	}
	print("This interpreter (vers. ");
	printNum(imageFormatVersionNumber);
	print(") cannot read image file (vers. ");
	printNum(firstVersion);
	print(").");
	/* begin cr */
	printf("\n");
	print("Press CR to quit...");
	getchar();
	ioExit();
l1:	/* end checkImageVersionFrom:startingAt: */;

	/* record header start position */

	headerStart = (sqImageFilePosition(f)) - BytesPerWord;
	headerSize = getLongFromFileswap(f, swapBytes);
	dataSize = getLongFromFileswap(f, swapBytes);
	oldBaseAddr = getLongFromFileswap(f, swapBytes);
	GIV(specialObjectsOop) = getLongFromFileswap(f, swapBytes);
	GIV(lastHash) = getLongFromFileswap(f, swapBytes);
	GIV(savedWindowSize) = getLongFromFileswap(f, swapBytes);
	GIV(fullScreenFlag) = getLongFromFileswap(f, swapBytes);
	extraVMMemory = getLongFromFileswap(f, swapBytes);
	if (GIV(lastHash) == 0) {

		/* lastHash wasn't stored (e.g. by the cloner); use 999 as the seed */

		GIV(lastHash) = 999;
	}
	heapSize = reserveExtraCHeapBytes(desiredHeapSize, extraVMMemory);

	/* need at least 100K of breathing room */

	minimumMemory = dataSize + 100000;
	if (heapSize < minimumMemory) {
		insufficientMemorySpecifiedError();
	}
	/* begin allocateMemory:minimum:imageFile:headerSize: */
	memory = ((char *) (allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize)));
	if (memory == null) {
		insufficientMemoryAvailableError();
	}
	memStart = memory;

	/* decrease memoryLimit a tad for safety */

	GIV(memoryLimit) = (memStart + heapSize) - 24;

	/* position file after the header */

	GIV(endOfMemory) = memStart + dataSize;
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = sqImageFileRead(pointerForOop(memory), sizeof(unsigned char), dataSize, f);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	if (swapBytes) {
		/* begin reverseBytesInImage */
		/* begin reverseBytesFrom:to: */
		flag("Dan");
		addr = memory;
		while ((((usqInt) addr)) < (((usqInt) GIV(endOfMemory)))) {
			longAtput(addr, byteSwapped(longAt(addr)));
			addr += BytesPerWord;
		}
		/* begin byteSwapByteObjects */
		byteSwapByteObjectsFromto(memory + (headerTypeBytes[(longAt(memory)) & TypeMask]), GIV(endOfMemory));
	}
	bytesToShift = memStart - oldBaseAddr;
	initializeInterpreter(bytesToShift);
	return dataSize;
}


/*	callbackContext is an activation of
	invokeCallback:stack:registers:jmpbuf:. Its sender
	is the interpreter's state prior to the callback. Reestablish that state. */

EXPORT(sqInt)
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt tmp;

	if ((fetchClassOf(callbackContext)) != (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassMethodContext << ShiftForWord)))) {
		return 0;
	}
	calloutContext = longAt((callbackContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	/* begin newActiveContext: */
	VM_LABEL(9newActiveContext);
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if (calloutContext < GIV(youngStart)) {
		beRootIfOld(calloutContext);
	}
	GIV(activeContext) = calloutContext;
	/* begin fetchContextRegisters: */
	VM_LABEL(12fetchContextRegisters);
	tmp = longAt((calloutContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((calloutContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = calloutContext;
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((calloutContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((calloutContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (calloutContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	return 1;
}


/*	Map the given oop to its new value during a compaction or 
	become: operation. If it has no forwarding table entry, 
	return the oop itself. */

sqInt
remap(sqInt oop)
{
    sqInt fwdBlock;
    sqInt targetObj;

	if (((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0)) {
		/* begin remappedObj: */
		fwdBlock = ((longAt(oop)) & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));
		targetObj = longAt(fwdBlock);
		assert(addressCouldBeObjWhileForwarding(targetObj));
		return targetObj;
	}
	return oop;
}


/*	Remove the first process from the given linked list. */

static sqInt
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	first = longAt((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord));
	last = longAt((aList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
	if (first == last) {
		/* begin storePointer:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, valuePointer);
		}
		longAtput((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), valuePointer);
		/* begin storePointer:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, valuePointer1);
		}
		longAtput((aList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), valuePointer1);
	}
	else {
		next = longAt((first + BaseHeaderSize) + (NextLinkIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aList, next);
		}
		longAtput((aList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), next);
	}
	/* begin storePointer:ofObject:withValue: */
	valuePointer2 = GIV(nilObj);
	if ((((usqInt) first)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(first, valuePointer2);
	}
	longAtput((first + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), valuePointer2);
	return first;
}


/*	Remove the given variable location to the extra roots table */

EXPORT(sqInt)
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt *root;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		root = GIV(extraRoots)[i];
		if (root == varLoc) {
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Restore the headers of all oops in both lists. Exchange their hash bits so
	becoming objects in identity sets and dictionaries doesn't change their
	hash value. */
/*	See also prepareForwardingTableForBecoming:with:woWay: for notes
	regarding the case
	of oop1 = oop2 */

static void
restoreHeadersAfterBecomingwith(sqInt list1, sqInt list2)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdHeader;
    sqInt fwdHeader1;
    sqInt hdr1;
    sqInt hdr2;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt oop1;
    sqInt oop2;
    sqInt sp;
    sqInt sz;
    sqInt type;

	/* begin lastPointerOf: */
	header = longAt(list1);
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt <= 4) {
		if ((fmt == 3)
		 && ((((((usqInt) header) >> 12) & 31) == 13)
		 || (((((usqInt) header) >> 12) & 31) == 14))) {
			/* begin fetchStackPointerOf: */
			sp = longAt((list1 + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
			goto l2;
		}
		/* begin sizeBitsOfSafe: */
		header1 = longAt(list1);
		/* begin rightType: */
		if ((header1 & SizeMask) == 0) {
			type = HeaderTypeSizeAndClass;
			goto l3;
		}
		else {
			if ((header1 & CompactClassMask) == 0) {
				type = HeaderTypeClass;
				goto l3;
			}
			else {
				type = HeaderTypeShort;
				goto l3;
			}
		}
	l3:	/* end rightType: */;
		if (type == HeaderTypeSizeAndClass) {
			sz = (longAt(list1 - (BytesPerWord * 2))) & AllButTypeMask;
			goto l4;
		}
		else {
			sz = header1 & SizeMask;
			goto l4;
		}
	l4:	/* end sizeBitsOfSafe: */;
		fieldOffset = sz - BaseHeaderSize;
		goto l2;
	}
	if (fmt < 12) {
		fieldOffset = 0;
		goto l2;
	}
	methodHeader = longAt(list1 + BaseHeaderSize);
	fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(list1 + fieldOffset);
		oop2 = longAt(list2 + fieldOffset);
		if (!(oop1 == oop2)) {
			/* begin restoreHeaderOf: */
			fwdHeader = longAt(oop1);
			fwdBlock = (fwdHeader & AllButMarkBitAndTypeMask) << 1;
			assert((fwdHeader & MarkBit) != 0);
			assert(fwdBlockValid(fwdBlock));
			longAtput(oop1, longAt(fwdBlock + BytesPerWord));
			/* begin restoreHeaderOf: */
			fwdHeader1 = longAt(oop2);
			fwdBlock1 = (fwdHeader1 & AllButMarkBitAndTypeMask) << 1;
			assert((fwdHeader1 & MarkBit) != 0);
			assert(fwdBlockValid(fwdBlock1));
			longAtput(oop2, longAt(fwdBlock1 + BytesPerWord));
			hdr1 = longAt(oop1);
			hdr2 = longAt(oop2);
			longAtput(oop1, (hdr1 & AllButHashBits) | (hdr2 & HashBits));
			longAtput(oop2, (hdr2 & AllButHashBits) | (hdr1 & HashBits));
		}
		fieldOffset -= BytesPerWord;
	}
}


/*	Forward become leaves us with no original oops in the 
	mutated object list, 
	so we must enumerate the (four-word) forwarding blocks 
	where we have stored backpointers. */
/*	This loop start is copied from fwdTableInit: */

static void
restoreHeadersAfterForwardBecome(sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdHeader;
    sqInt hdr1;
    sqInt hdr2;
    sqInt oop1;
    sqInt oop2;

	fwdBlock = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* fwdBlockGet: did a pre-increment */

	fwdBlock += BytesPerWord * 4;
	while ((((usqInt) fwdBlock)) <= (((usqInt) GIV(fwdTableNext)))) {

		/* Backpointer to mutated object. */

		oop1 = longAt(fwdBlock + (BytesPerWord * 2));
		oop2 = longAt(fwdBlock);
		/* begin restoreHeaderOf: */
		fwdHeader = longAt(oop1);
		fwdBlock1 = (fwdHeader & AllButMarkBitAndTypeMask) << 1;
		assert((fwdHeader & MarkBit) != 0);
		assert(fwdBlockValid(fwdBlock1));
		longAtput(oop1, longAt(fwdBlock1 + BytesPerWord));
		if (copyHashFlag) {

			/* Change the hash of the new oop (oop2) to be that of the old (oop1) 
					so mutated objects in hash structures will be 
					happy after the change. */

			hdr1 = longAt(oop1);
			hdr2 = longAt(oop2);
			longAtput(oop2, (hdr2 & AllButHashBits) | (hdr1 & HashBits));
		}
		fwdBlock += BytesPerWord * 4;
	}
}


/*	Restore headers smashed by forwarding links */

static void
restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt oop;
    sqInt sz;
    sqInt tablePtr;

	tablePtr = firstIn;
	while ((((usqInt) tablePtr)) <= (((usqInt) lastIn))) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseIn + (tablePtr - firstIn));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	tablePtr = firstOut;
	while ((((usqInt) tablePtr)) <= (((usqInt) lastOut))) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseOut + (tablePtr - firstOut));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			longAtput(oop, (longAt(oop)) & AllButMarkBit);
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header1 & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}

static sqInt
resume(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt lastLink;
    sqInt lastLink1;
    sqInt newPriority;
    sqInt newProc;
    sqInt oldProc;
    sqInt priority;
    sqInt priority1;
    sqInt processList;
    sqInt processList1;
    sqInt processLists;
    sqInt processLists1;
    sqInt sched;
    sqInt tmp;
    sqInt valuePointer;
    sqInt valuePointer1;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	activePriority = ((longAt((activeProc + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1);
	newPriority = ((longAt((aProcess + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1);
	if (newPriority <= activePriority) {
		/* begin putToSleep: */
		VM_LABEL(0putToSleep);
		priority = ((longAt((aProcess + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1);
		processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
		processList = longAt((processLists + BaseHeaderSize) + ((priority - 1) << ShiftForWord));
		/* begin addLastLink:toList: */
		VM_LABEL(2addLastLinktoList);
		if ((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(processList, aProcess);
			}
			longAtput((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), aProcess);
		}
		else {
			lastLink = longAt((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) lastLink)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(lastLink, aProcess);
			}
			longAtput((lastLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), aProcess);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(processList, aProcess);
		}
		longAtput((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), aProcess);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aProcess)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aProcess, processList);
		}
		longAtput((aProcess + BaseHeaderSize) + (MyListIndex << ShiftForWord), processList);
		return 0;
	}
	/* begin putToSleep: */
	VM_LABEL(1putToSleep);
	priority1 = ((longAt((activeProc + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1);
	processLists1 = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	processList1 = longAt((processLists1 + BaseHeaderSize) + ((priority1 - 1) << ShiftForWord));
	/* begin addLastLink:toList: */
	VM_LABEL(3addLastLinktoList);
	if ((longAt((processList1 + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList1)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(processList1, activeProc);
		}
		longAtput((processList1 + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), activeProc);
	}
	else {
		lastLink1 = longAt((processList1 + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) lastLink1)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(lastLink1, activeProc);
		}
		longAtput((lastLink1 + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), activeProc);
	}
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) processList1)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(processList1, activeProc);
	}
	longAtput((processList1 + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), activeProc);
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) activeProc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(activeProc, processList1);
	}
	longAtput((activeProc + BaseHeaderSize) + (MyListIndex << ShiftForWord), processList1);
	/* begin transferTo: */
	VM_LABEL(3transferTo);
	newProc = aProcess;
	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord));
	oldProc = longAt((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin storePointer:ofObject:withValue: */
	if ((((usqInt) sched)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(sched, newProc);
	}
	longAtput((sched + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord), newProc);
	/* begin storePointer:ofObject:withValue: */
	valuePointer = GIV(activeContext);
	if ((((usqInt) oldProc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(oldProc, valuePointer);
	}
	longAtput((oldProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer);
	/* begin newActiveContext: */
	VM_LABEL(10newActiveContext);
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) < GIV(youngStart)) {
		beRootIfOld(longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord)));
	}
	GIV(activeContext) = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	/* begin fetchContextRegisters: */
	VM_LABEL(13fetchContextRegisters);
	tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord));
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt(((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = ((longAt((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord))) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	/* begin storePointer:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	if ((((usqInt) newProc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(newProc, valuePointer1);
	}
	longAtput((newProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer1);
	GIV(reclaimableContextCount) = 0;
	return 1;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

EXPORT(sqInt)
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutMethodContext;
    sqInt tmp;

	if (!(((returnTypeOop & 1))
		 && (((callbackMethodContext & 1) == 0)
		 && ((((((usqInt) (longAt(callbackMethodContext))) >> 12) & 31) == 13)
		 || (((((usqInt) (longAt(callbackMethodContext))) >> 12) & 31) == 14))))) {
		return 0;
	}
	calloutMethodContext = longAt((callbackMethodContext + BaseHeaderSize) + (SenderIndex << ShiftForWord));
	if (!(((calloutMethodContext & 1) == 0)
		 && ((((((usqInt) (longAt(calloutMethodContext))) >> 12) & 31) == 13)
		 || (((((usqInt) (longAt(calloutMethodContext))) >> 12) & 31) == 14)))) {
		return 0;
	}
	/* begin newActiveContext: */
	VM_LABEL(11newActiveContext);
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	if (calloutMethodContext < GIV(youngStart)) {
		beRootIfOld(calloutMethodContext);
	}
	GIV(activeContext) = calloutMethodContext;
	/* begin fetchContextRegisters: */
	VM_LABEL(14fetchContextRegisters);
	tmp = longAt((calloutMethodContext + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((calloutMethodContext + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = calloutMethodContext;
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((calloutMethodContext + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((calloutMethodContext + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (calloutMethodContext + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
	return 1;
}


/*	Reverse the given range of Display words (at different bit 
	depths, this will reverse different numbers of pixels). Used to 
	give feedback during VM activities such as garbage 
	collection when debugging. It is assumed that the given 
	word range falls entirely within the first line of the Display. */

static sqInt
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dispBitsPtr;
    sqInt displayObj;
    sqInt ptr;
    sqInt reversed;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << ShiftForWord));
	if (!((((displayObj & 1) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 8) & 15) <= 4))
		 && ((lengthOf(displayObj)) >= 4))) {
		return null;
	}
	w = fetchIntegerofObject(1, displayObj);
	dispBitsPtr = longAt((displayObj + BaseHeaderSize) + (0 << ShiftForWord));
	if ((dispBitsPtr & 1)) {
		return null;
	}
	dispBitsPtr += BaseHeaderSize;
	for (ptr = (dispBitsPtr + (startIndex * 4)); ptr <= (dispBitsPtr + (endIndex * 4)); ptr += 4) {
		reversed = (long32At(ptr)) ^ 4294967295UL;
		longAtput(ptr, reversed);
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, 1);
	ioForceDisplayUpdate();
}


/*	Rewrite the cache entry with the given primitive index and matching
	function pointer
 */

static sqInt
rewriteMethodCacheSelclassprimIndex(sqInt selector, sqInt class, sqInt localPrimIndex)
{
    void *primPtr;

	if (localPrimIndex == 0) {
		primPtr = 0;
	}
	else {
		primPtr = primitiveTable[localPrimIndex];
	}
	rewriteMethodCacheSelclassprimIndexprimFunction(selector, class, localPrimIndex, primPtr);
}


/*	Rewrite an existing entry in the method cache with a new primitive 
	index & function address. Used by primExternalCall to make direct jumps to
	found external prims
 */

static sqInt
rewriteMethodCacheSelclassprimIndexprimFunction(sqInt selector, sqInt class, sqInt localPrimIndex, void *localPrimAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt p;
    sqInt probe;

	hash = selector ^ class;
	for (p = 0; p <= (CacheProbeMax - 1); p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
		 && ((GIV(methodCache)[probe + MethodCacheClass]) == class)) {
			GIV(methodCache)[probe + MethodCachePrim] = localPrimIndex;
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) localPrimAddress));
			return null;
		}
	}
}


/*	Version of printStringOf: that copes with forwarding during garbage
	collection. 
 */

static sqInt
safePrintStringOf(sqInt oop)
{
    sqInt cnt;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt i;

	if ((oop & 1)) {
		return null;
	}
	if (!(((oop >= memory) && (oop <= GIV(freeBlock))))) {
		return null;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		return null;
	}
	/* begin headerWhileForwardingOf: */
	header1 = longAt(oop);
	if ((header1 & MarkBit) != 0) {

		/* oop is forwarded; get its real header from its forwarding table entry */

		fwdBlock = (header1 & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));
		header1 = longAt(fwdBlock + BytesPerWord);
	}
	header = header1;
	fmt = (((usqInt) header) >> 8) & 15;
	if (fmt < 8) {
		return null;
	}
	cnt = ((100 < (lengthOfbaseHeaderformat(oop, header, fmt))) ? 100 : (lengthOfbaseHeaderformat(oop, header, fmt)));
	i = 0;
	while (i < cnt) {
		/* begin printChar: */
		putchar(byteAt((oop + BaseHeaderSize) + i));
		i += 1;
	}
	flush();
	return oop;
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the
	1 arg invokeCallbackContext: or the 4 arg
	invokeCallback:stack:registers:jmpbuf: message, depending on what selector
	is installed in the specialObjectsArray.
	Note that if invoking the legacy invokeCallback:stack:registers:jmpbuf: we
	pass the
	vmCallbackContext as the jmpbuf argument (see
	reestablishContextPriorToCallback:). The arguments are raw C addresses and
	are converted to integer objects on the way. */

EXPORT(sqInt)
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt i;
    sqInt initialIP;
    sqInt methodHeader;
    sqInt needsLarge;
    sqInt newContext;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt object6;
    sqInt object7;
    sqInt relativeSP;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    sqInt sp4;
    sqInt sp5;
    sqInt sp6;
    sqInt sp7;
    sqInt tempCount;
    sqInt tmp;
    sqInt where;

	GIV(receiver) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord));
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(GIV(receiver)))) >> 12) & 31)) == 0) {
		GIV(lkupClass) = (longAt(GIV(receiver) - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorInvokeCallback << ShiftForWord));
	if (!(lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass)))) {
		if ((lookupMethodNoMNUEtcInClass(GIV(lkupClass))) != 0) {
			return 0;
		}
	}
	if (primitiveFunctionPointer != 0) {
		return 0;
	}
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	/* begin justActivateNewMethod */
	VM_LABEL(0justActivateNewMethod);
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	needsLarge = methodHeader & LargeContextBit;
	if ((needsLarge == 0)
	 && (GIV(freeContexts) != NilContext)) {
		newContext = GIV(freeContexts);
		GIV(freeContexts) = longAt((newContext + BaseHeaderSize) + (0 << ShiftForWord));
	}
	else {

		/* Slower call for large contexts or empty free list */

		newContext = allocateOrRecycleContext(needsLarge);
	}
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where = newContext + BaseHeaderSize;
	longAtput(where + (SenderIndex << ShiftForWord), GIV(activeContext));
	longAtput(where + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput(where + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
	longAtput(where + (MethodIndex << ShiftForWord), GIV(newMethod));
	longAtput(where + (ReceiverIndex << ShiftForWord), GIV(receiver));

	/* needsLarge here used just as faster (register?) temp */

	needsLarge = GIV(nilObj);
	for (i = (ReceiverIndex + 1); i <= (tempCount + ReceiverIndex); i += 1) {
		longAtput(where + (i << ShiftForWord), needsLarge);
	}
	GIV(reclaimableContextCount) += 1;
	GIV(activeContext) = newContext;
	if ((((usqInt) newContext)) < (((usqInt) GIV(youngStart)))) {
		beRootIfOld(newContext);
	}
	/* begin fetchContextRegisters: */
	VM_LABEL(15fetchContextRegisters);
	tmp = longAt((GIV(activeContext) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((GIV(activeContext) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = GIV(activeContext);
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (GIV(activeContext) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	relativeSP = GIV(stackPointer) - GIV(activeContext);
	GIV(stackPointer) = (GIV(activeContext) + BaseHeaderSize) + (ReceiverIndex * BytesPerWord);
	
#  if BytesPerWord == 8
	if (((((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15) == 4) {
		/* begin push: */
		object = positive64BitIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput((sp = GIV(stackPointer) + BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin push: */
		object1 = positive64BitIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = positive64BitIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput((sp2 = GIV(stackPointer) + BytesPerWord), object2);
		GIV(stackPointer) = sp2;
	}
	/* begin push: */
	object3 = positive64BitIntegerFor(((usqInt)vmCallbackContext));
	longAtput((sp3 = GIV(stackPointer) + BytesPerWord), object3);
	GIV(stackPointer) = sp3;

#  else /* BytesPerWord == 8 */
	if (((((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15) == 4) {
		/* begin push: */
		object4 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput((sp4 = GIV(stackPointer) + BytesPerWord), object4);
		GIV(stackPointer) = sp4;
		/* begin push: */
		object5 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput((sp5 = GIV(stackPointer) + BytesPerWord), object5);
		GIV(stackPointer) = sp5;
		/* begin push: */
		object6 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput((sp6 = GIV(stackPointer) + BytesPerWord), object6);
		GIV(stackPointer) = sp6;
	}
	/* begin push: */
	object7 = positive32BitIntegerFor(((usqInt)vmCallbackContext));
	longAtput((sp7 = GIV(stackPointer) + BytesPerWord), object7);
	GIV(stackPointer) = sp7;

#  endif /* BytesPerWord == 8 */

	GIV(stackPointer) = GIV(activeContext) + relativeSP;
	assert(validInstructionPointerinMethod(GIV(instructionPointer), GIV(method)));
	interpret();
	return 1;
}


/*	Send the 4 argument callback message
	invokeCallback:stack:registers:jmpbuf: to Alien class with the supplied
	args. The arguments are raw C addresses
	and are converted to integer objects on the way. */

EXPORT(sqInt)
sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt i;
    sqInt initialIP;
    sqInt methodHeader;
    sqInt needsLarge;
    sqInt newContext;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt tempCount;
    sqInt tmp;
    sqInt where;
    sqInt where1;

	/* begin pushRemappableOop: */
	oop = positive32BitIntegerFor(jmpBufPtr);
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	/* begin pushRemappableOop: */
	oop1 = positive32BitIntegerFor(regsPtr);
	assert(addressCouldBeOop(oop1));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop1;
	/* begin pushRemappableOop: */
	oop2 = positive32BitIntegerFor(stackPtr);
	assert(addressCouldBeOop(oop2));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop2;
	/* begin pushRemappableOop: */
	oop3 = positive32BitIntegerFor(thunkPtr);
	assert(addressCouldBeOop(oop3));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop3;
	GIV(receiver) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord));
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(GIV(receiver)))) >> 12) & 31)) == 0) {
		GIV(lkupClass) = (longAt(GIV(receiver) - BaseHeaderSize)) & AllButTypeMask;
		goto l1;
	}
	else {
		GIV(lkupClass) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l1;
	}
l1:	/* end fetchClassOfNonInt: */;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorInvokeCallback << ShiftForWord));
	if (!(lookupInMethodCacheSelclass(GIV(messageSelector), GIV(lkupClass)))) {
		if (!(lookupMethodNoMNUEtcInClass(GIV(lkupClass)))) {
			return 0;
		}
	}
	if (!((((((usqInt) (longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord)))) >> 25) & 15) == 4)
		 && (primitiveFunctionPointer == 0))) {
		return 0;
	}
	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	/* begin justActivateNewMethod */
	VM_LABEL(1justActivateNewMethod);
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << ShiftForWord));
	needsLarge = methodHeader & LargeContextBit;
	if ((needsLarge == 0)
	 && (GIV(freeContexts) != NilContext)) {
		newContext = GIV(freeContexts);
		GIV(freeContexts) = longAt((newContext + BaseHeaderSize) + (0 << ShiftForWord));
	}
	else {

		/* Slower call for large contexts or empty free list */

		newContext = allocateOrRecycleContext(needsLarge);
	}
	initialIP = ((LiteralStart + ((((usqInt) methodHeader) >> 10) & 255)) * BytesPerWord) + 1;

	/* Assume: newContext will be recorded as a root if necessary by the
	 call to newActiveContext: below, so we can use unchecked stores. */

	tempCount = (((usqInt) methodHeader) >> 19) & 63;
	where1 = newContext + BaseHeaderSize;
	longAtput(where1 + (SenderIndex << ShiftForWord), GIV(activeContext));
	longAtput(where1 + (InstructionPointerIndex << ShiftForWord), ((initialIP << 1) | 1));
	longAtput(where1 + (StackPointerIndex << ShiftForWord), ((tempCount << 1) | 1));
	longAtput(where1 + (MethodIndex << ShiftForWord), GIV(newMethod));
	longAtput(where1 + (ReceiverIndex << ShiftForWord), GIV(receiver));

	/* needsLarge here used just as faster (register?) temp */

	needsLarge = GIV(nilObj);
	for (i = (ReceiverIndex + 1); i <= (tempCount + ReceiverIndex); i += 1) {
		longAtput(where1 + (i << ShiftForWord), needsLarge);
	}
	GIV(reclaimableContextCount) += 1;
	GIV(activeContext) = newContext;
	if ((((usqInt) newContext)) < (((usqInt) GIV(youngStart)))) {
		beRootIfOld(newContext);
	}
	/* begin fetchContextRegisters: */
	VM_LABEL(16fetchContextRegisters);
	tmp = longAt((GIV(activeContext) + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	if ((tmp & 1)) {

		/* if the MethodIndex field is an integer, activeCntx is a block context */

		tmp = longAt((GIV(activeContext) + BaseHeaderSize) + (HomeIndex << ShiftForWord));
		if (tmp < GIV(youngStart)) {
			beRootIfOld(tmp);
		}
	}
	else {

		/* otherwise, it is a method context and is its own home context  */

		tmp = GIV(activeContext);
	}
	GIV(theHomeContext) = tmp;
	GIV(receiver) = longAt((tmp + BaseHeaderSize) + (ReceiverIndex << ShiftForWord));

	/* the instruction pointer is a pointer variable equal to 
	method oop + ip + BaseHeaderSize 
	-1 for 0-based addressing of fetchByte 
	-1 because it gets incremented BEFORE fetching currentByte  */

	GIV(method) = longAt((tmp + BaseHeaderSize) + (MethodIndex << ShiftForWord));
	tmp = ((longAt((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord))) >> 1);

	/* the stack pointer is a pointer variable also... */

	GIV(instructionPointer) = ((GIV(method) + tmp) + BaseHeaderSize) - 2;
	tmp = ((longAt((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord))) >> 1);
	GIV(stackPointer) = (GIV(activeContext) + BaseHeaderSize) + (((TempFrameStart + tmp) - 1) * BytesPerWord);
	where = (GIV(activeContext) + BaseHeaderSize) + (ReceiverIndex << ShiftForWord);
	longAtput(where + (1 << ShiftForWord), popRemappableOop());
	longAtput(where + (2 << ShiftForWord), popRemappableOop());
	longAtput(where + (3 << ShiftForWord), popRemappableOop());
	longAtput(where + (4 << ShiftForWord), popRemappableOop());
	interpret();
	return 1;
}

sqInt
setBreakSelector(char *aString)
{
	if (aString == null) {

		/* nil's effective length is zero */

		breakSelectorLength = -1;
		breakSelector = null;
	}
	else {
		breakSelectorLength = strlen(aString);
		breakSelector = aString;
	}
}

sqInt
setFullScreenFlag(sqInt value)
{
	GIV(fullScreenFlag) = value;
}

sqInt
setInterruptCheckCounter(sqInt value)
{
	GIV(interruptCheckCounter) = value;
}

sqInt
setInterruptKeycode(sqInt value)
{
	GIV(interruptKeycode) = value;
}

sqInt
setInterruptPending(sqInt value)
{
	GIV(interruptPending) = value;
}

sqInt
setNextWakeupTick(sqInt value)
{
	GIV(nextWakeupTick) = value;
}

sqInt
setSavedWindowSize(sqInt value)
{
	GIV(savedWindowSize) = value;
}

sqInt
shortPrintContext(sqInt aContext)
{
    sqInt home;

	if (!(((aContext & 1) == 0)
		 && ((((((usqInt) (longAt(aContext))) >> 12) & 31) == 13)
		 || (((((usqInt) (longAt(aContext))) >> 12) & 31) == 14)))) {
		printHex(aContext);
		print(" is not a context");
		/* begin cr */
		printf("\n");
		return null;
	}
	home = findHomeForContext(aContext);
	printNum(aContext);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(longAt((home + BaseHeaderSize) + (MethodIndex << ShiftForWord)), longAt((home + BaseHeaderSize) + (ReceiverIndex << ShiftForWord)), home != aContext, longAt((home + BaseHeaderSize) + ((0 + CtxtTempFrameStart) << ShiftForWord)));
	/* begin cr */
	printf("\n");
}

static sqInt
shortPrintOop(sqInt oop)
{
	printNum(oop);
	if ((oop & 1)) {
		return printf("=%ld\n", integerValueOf(oop));
	}
	if (!(((oop >= memory) && (oop <= GIV(freeBlock))))) {
		printHex(oop);
		print(" is not on the heap");
		/* begin cr */
		printf("\n");
		return null;
	}
	if ((oop & (BytesPerWord - 1)) != 0) {
		printHex(oop);
		print(" is misaligned");
		/* begin cr */
		printf("\n");
		return null;
	}
	print(": a(n) ");
	printNameOfClasscount(fetchClassOf(oop), 5);
	/* begin cr */
	printf("\n");
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{
	if (deferDisplayUpdates) {
		return null;
	}
	displayBitsOfLeftTopRightBottom(aForm, l, t, r, b);
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

sqInt
signalNoResume(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aProcess;
    sqInt empty;
    sqInt lastLink;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	empty = (longAt((aSemaphore + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj);
	if (!(empty)) {
		/* begin putToSleep: */
		VM_LABEL(2putToSleep);
		aProcess = removeFirstLinkOfList(aSemaphore);
		priority = ((longAt((aProcess + BaseHeaderSize) + (PriorityIndex << ShiftForWord))) >> 1);
		processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
		processList = longAt((processLists + BaseHeaderSize) + ((priority - 1) << ShiftForWord));
		/* begin addLastLink:toList: */
		VM_LABEL(4addLastLinktoList);
		if ((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(processList, aProcess);
			}
			longAtput((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord), aProcess);
		}
		else {
			lastLink = longAt((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord));
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) lastLink)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(lastLink, aProcess);
			}
			longAtput((lastLink + BaseHeaderSize) + (NextLinkIndex << ShiftForWord), aProcess);
		}
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) processList)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(processList, aProcess);
		}
		longAtput((processList + BaseHeaderSize) + (LastLinkIndex << ShiftForWord), aProcess);
		/* begin storePointer:ofObject:withValue: */
		if ((((usqInt) aProcess)) < (((usqInt) GIV(youngStart)))) {
			possibleRootStoreIntovalue(aProcess, processList);
		}
		longAtput((aProcess + BaseHeaderSize) + (MyListIndex << ShiftForWord), processList);
	}
	return empty;
}


/*	Return a full 32 bit integer object for the given integer value */

sqInt
signed32BitIntegerFor(int integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt value;

	if ((integerValue ^ (integerValue << 1)) >= 0) {
		return ((integerValue << 1) | 1);
	}
	if (integerValue < 0) {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord));
		value = 0 - integerValue;
	}
	else {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord));
		value = integerValue;
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, 4);
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) value) >> 24) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) value) >> 16) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) value) >> 8) & 255);
	byteAtput((newLargeInteger + BaseHeaderSize) + 0, value & 255);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a four-byte
	LargeInteger. 
 */

int
signed32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt header;
    sqInt largeClass;
    sqInt negative;
    sqInt sz;
    sqInt sz1;
    int value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	if ((lengthOf(oop)) > 4) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		largeClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		largeClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	if (largeClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))) {
		negative = 0;
	}
	else {
		if (largeClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)))) {
			negative = 1;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf: */;
	if (!(sz == 4)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}

	/* Fail if value exceeds range of a 32-bit two's-complement signed integer. */

	value = (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
	if (negative) {
		value = 0 - value;
		if (value >= 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	else {
		if (value < 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	return value;
}


/*	Return a Large Integer object for the given integer value */

sqInt
signed64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt i;
    sqInt intValue;
    sqInt largeClass;
    unsigned sqLong magnitude;
    sqInt newLargeInteger;
    sqInt sz;

	if (integerValue < 0) {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord));
		magnitude = 0 - integerValue;
	}
	else {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord));
		magnitude = integerValue;
	}
	if (magnitude <= 2147483647UL) {
		return signed32BitIntegerFor(integerValue);
	}

	/* shift is coerced to usqInt otherwise */

	highWord = magnitude >> 32;
	if (highWord == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	for (i = 0; i <= (sz - 1); i += 1) {
		intValue = (magnitude >> (i * 8)) & 255;
		byteAtput((newLargeInteger + BaseHeaderSize) + i, intValue);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive ST integer or a eight-byte
	LargeInteger. 
 */

sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt header;
    sqInt i;
    sqInt largeClass;
    sqInt negative;
    sqInt sz;
    sqInt sz1;
    sqInt szsqLong;
    sqLong value;

	if ((oop & 1)) {
		return ((sqLong) ((oop >> 1)));
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		sz = (sz1 - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
		goto l1;
	}
l1:	/* end lengthOf: */;
	if (sz > 8) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	/* begin fetchClassOf: */
	if ((oop & 1)) {
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassInteger << ShiftForWord));
		goto l2;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		largeClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l2;
	}
	else {
		largeClass = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l2;
	}
l2:	/* end fetchClassOf: */;
	if (largeClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord)))) {
		negative = 0;
	}
	else {
		if (largeClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord)))) {
			negative = 1;
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	szsqLong = sizeof(sqLong);
	if (sz > szsqLong) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	value = 0;
	for (i = 0; i <= (sz - 1); i += 1) {
		value += (((sqLong) (byteAt((oop + BaseHeaderSize) + i)))) << (i * 8);
	}
	if (negative) {
		value = 0 - value;
		if (value >= 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	else {
		if (value < 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	return value;
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

long
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt negative;
    sqInt ok;
    long value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex1 = (((usqInt) (longAt(oop))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? ((ccIndex1 == 0
	? (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))))
	: (0)))
		: (ClassLargePositiveIntegerCompactIndex == ccIndex1));
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? ((ccIndex == 0
	? (((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord))))
	: (0)))
			: (ClassLargeNegativeIntegerCompactIndex == ccIndex));
		if (!(ok)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	if (((bs = lengthOf(oop))) > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = (((((((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)) + ((byteAt((oop + BaseHeaderSize) + 4)) << 32)) + ((byteAt((oop + BaseHeaderSize) + 5)) << 40)) + ((byteAt((oop + BaseHeaderSize) + 6)) << 48)) + ((byteAt((oop + BaseHeaderSize) + 7)) << 56);
	}
	else {
		value = (((byteAt((oop + BaseHeaderSize) + 0)) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24);
	}
	null;
	if (value < 0) {
		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	return (negative
		? (0 - value)
		: (value));
}


/*	Answer the number of bytes in the given object, including its base header,
	rounded up to an integral number of words.
 */
/*	Note: byte indexable objects need to have low bits subtracted from this
	size. 
 */

static sqInt
sizeBitsOf(sqInt oop)
{
    sqInt header;

	header = longAt(oop);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		return (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		return header & SizeMask;
	}
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt size;

	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	size = longAt(oop + BaseHeaderSize);
	return abs(size);
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(((oop & 1) == 0)
		 && (isWordsOrBytesNonInt(oop)))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	Returns the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

sqInt
slotSizeOf(sqInt oop)
{
    sqInt header;
    sqInt sz;

	if ((oop & 1)) {
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (((((usqInt) header) >> 8) & 15) <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
	}
	if (((((usqInt) header) >> 8) & 15) < 8) {
		return ((usqInt) (sz - BaseHeaderSize)) >> 2;
	}
	else {
		return (sz - BaseHeaderSize) - (((((usqInt) header) >> 8) & 15) & 3);
	}
}


/*	NB: tpr removed the timer checks here and moved them to the
	primitiveExternalCall method.
	We make the possibly unwarranted assumption that numbered prims are quick
	and external prims are slow.
 */

static sqInt
slowPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaIfSuccess;
    sqInt nArgs;
    sqInt savedContext;

	if (FailImbalancedPrimitives) {
		savedContext = GIV(activeContext);
		nArgs = GIV(argumentCount);
		deltaIfSuccess = (GIV(stackPointer) - (GIV(argumentCount) * BytesPerOop)) - GIV(activeContext);
	}
	/* begin fastLogPrim: */
	if (RecordPrimTrace) {
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(messageSelector);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	if (FailImbalancedPrimitives
	 && ((!GIV(primFailCode))
	 && (savedContext == GIV(activeContext)))) {
		if ((GIV(stackPointer) - GIV(activeContext)) != deltaIfSuccess) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			warning("failing primitive due to unbalanced stack");
			GIV(stackPointer) = (GIV(activeContext) + deltaIfSuccess) + (nArgs * BytesPerOop);
			failUnbalancedPrimitive();
		}
	}
	return !GIV(primFailCode);
}


/*	update state of active context */

static sqInt
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt dataSize;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt i1;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    void *setMacType;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt sz1;
    sqInt top;
    sqInt valuePointer;

	/* begin storeContextRegisters: */
	longAtput((GIV(activeContext) + BaseHeaderSize) + (InstructionPointerIndex << ShiftForWord), ((((GIV(instructionPointer) - GIV(method)) - (BaseHeaderSize - 2)) << 1) | 1));
	longAtput((GIV(activeContext) + BaseHeaderSize) + (StackPointerIndex << ShiftForWord), (((((((usqInt) ((GIV(stackPointer) - GIV(activeContext)) - BaseHeaderSize)) >> ShiftForWord) - TempFrameStart) + 1) << 1) | 1));
	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ActiveProcessIndex << ShiftForWord));
	/* begin storePointer:ofObject:withValue: */
	valuePointer = GIV(activeContext);
	if ((((usqInt) activeProc)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(activeProc, valuePointer);
	}
	longAtput((activeProc + BaseHeaderSize) + (SuspendedContextIndex << ShiftForWord), valuePointer);
	incrementalGC();
	fullGC();
	/* begin snapshotCleanUp */
	VM_LABEL(0snapshotCleanUp);
	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while (oop < GIV(endOfMemory)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			header = longAt(oop);

			/* Clean out context */

			fmt = (((usqInt) header) >> 8) & 15;
			if ((fmt == 3)
			 && ((((((usqInt) header) >> 12) & 31) == 13)
			 || (((((usqInt) header) >> 12) & 31) == 14))) {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					goto l1;
				}
				else {
					sz = header1 & SizeMask;
					goto l1;
				}
			l1:	/* end sizeBitsOf: */;
				for (i = ((lastPointerOf(oop)) + BytesPerWord); i <= (sz - BaseHeaderSize); i += BytesPerWord) {
					longAtput(oop + i, GIV(nilObj));
				}
			}
			if (fmt >= 12) {
				if ((primitiveIndexOf(oop)) == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(oop);
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(oop);
			if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
				sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l2;
			}
			else {
				sz1 = header2 & SizeMask;
				goto l2;
			}
		l2:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
	}
	/* begin clearRootsTable */
	for (i1 = 1; i1 <= GIV(rootTableCount); i1 += 1) {

		/* clear root bits of current root table entries */

		oop1 = GIV(rootTable)[i1];
		longAtput(oop1, (longAt(oop1)) & AllButRootBit);
		GIV(rootTable)[i1] = 0;
	}
	GIV(rootTableCount) = 0;

	/* Assume all objects are below the start of the free block */

	dataSize = GIV(freeBlock) - memory;
	if (!GIV(primFailCode)) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) -= BytesPerWord;
		rcvr = top;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) + BytesPerWord), GIV(trueObj));
		GIV(stackPointer) = sp;
		writeImageFile(dataSize);
		if (!(embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */

			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin pop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
	beRootIfOld(GIV(activeContext));
	if (!GIV(primFailCode)) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) + BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) + BytesPerWord), rcvr);
		GIV(stackPointer) = sp2;
	}
}

static sqInt
space(void)
{
	/* begin printChar: */
	putchar(' ');
}


/*	Return one of the objects in the SpecialObjectsArray */

sqInt
splObj(sqInt index)
{
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (index << ShiftForWord));
}


/*	Note: May be called by translated primitive code. */

double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt floatPointer;
    double  result;

	floatPointer = longAt(GIV(stackPointer) - (offset * BytesPerWord));
	if (!((fetchClassOf(floatPointer)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassFloat << ShiftForWord))))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0.0;
	}
	;
	fetchFloatAtinto(floatPointer + BaseHeaderSize, result);
	return result;
}

sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) - (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return 0;
	}
}


/*	Ensures that the given object is a real object, not a SmallInteger. */

sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) - (offset * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return null;
	}
	return oop;
}


/*	Return the 0-based index rel to the current context.
	(This is what stackPointer used to be before conversion to pointer */

sqInt
stackPointerIndexForcontext(sqInt sp, sqInt ctxt)
{
	return ((usqInt) ((sp - ctxt) - BaseHeaderSize)) >> ShiftForWord;
}

sqInt
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt integerPointer;
    sqInt ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) - (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	VM_LABEL(0positiveMachineIntegerValueOf);
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return ((unsigned long) null);
		}
		return ((unsigned long) value);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((integerPointer & 1)));
	ccIndex = (((usqInt) (longAt(integerPointer))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? ((ccIndex == 0
	? (((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))))
	: (0)))
		: (ClassLargePositiveIntegerCompactIndex == ccIndex));
	if (!(ok
		 && (((bs = lengthOf(integerPointer))) <= (sizeof(unsigned long))))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return ((unsigned long) null);
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return ((unsigned long) ((((((((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24)) + ((byteAt((integerPointer + BaseHeaderSize) + 4)) << 32)) + ((byteAt((integerPointer + BaseHeaderSize) + 5)) << 40)) + ((byteAt((integerPointer + BaseHeaderSize) + 6)) << 48)) + ((byteAt((integerPointer + BaseHeaderSize) + 7)) << 56)));
	}
	return ((unsigned long) ((((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24)));
}

sqInt
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt integerPointer;
    sqInt negative;
    sqInt ok;
    long value;

	integerPointer = longAt(GIV(stackPointer) - (offset * BytesPerWord));
	/* begin signedMachineIntegerValueOf: */
	VM_LABEL(0signedMachineIntegerValueOf);
	if ((integerPointer & 1)) {
		return ((long) ((integerPointer >> 1)));
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((integerPointer & 1)));
	ccIndex1 = (((usqInt) (longAt(integerPointer))) >> 12) & 31;
	ok = (ClassLargePositiveIntegerCompactIndex == 0
		? ((ccIndex1 == 0
	? (((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargePositiveInteger << ShiftForWord))))
	: (0)))
		: (ClassLargePositiveIntegerCompactIndex == ccIndex1));
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((integerPointer & 1)));
		ccIndex = (((usqInt) (longAt(integerPointer))) >> 12) & 31;
		ok = (ClassLargeNegativeIntegerCompactIndex == 0
			? ((ccIndex == 0
	? (((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassLargeNegativeInteger << ShiftForWord))))
	: (0)))
			: (ClassLargeNegativeIntegerCompactIndex == ccIndex));
		if (!(ok)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return ((long) null);
		}
	}
	if (((bs = lengthOf(integerPointer))) > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return ((long) null);
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = (((((((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24)) + ((byteAt((integerPointer + BaseHeaderSize) + 4)) << 32)) + ((byteAt((integerPointer + BaseHeaderSize) + 5)) << 40)) + ((byteAt((integerPointer + BaseHeaderSize) + 6)) << 48)) + ((byteAt((integerPointer + BaseHeaderSize) + 7)) << 56);
	}
	else {
		value = (((byteAt((integerPointer + BaseHeaderSize) + 0)) + ((byteAt((integerPointer + BaseHeaderSize) + 1)) << 8)) + ((byteAt((integerPointer + BaseHeaderSize) + 2)) << 16)) + ((byteAt((integerPointer + BaseHeaderSize) + 3)) << 24);
	}
	null;
	if (value < 0) {
		if (negative
		 && (0 == (value << 1))) {
			return ((long) value);
		}
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
		return ((long) null);
	}
	return ((long) ((negative
	? (0 - value)
	: (value))));
}

sqInt
stackValue(sqInt offset)
{
	return longAt(GIV(stackPointer) - (offset * BytesPerWord));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassAlien << ShiftForWord))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? ((oop + BaseHeaderSize) + BytesPerOop)
	: (longAt((oop + BaseHeaderSize) + BytesPerOop)))));
}


/*	Return what ST would return for <obj> at: index. */

sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sp;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(array);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l2;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l2;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(array))) >> 12) & 31)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
		goto l4;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l4;
	}
l4:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((((((usqInt) hdr) >> 12) & 31) == 13)
	 || (((((usqInt) hdr) >> 12) & 31) == 14))) {
		/* begin fetchStackPointerOf: */
		sp = longAt((array + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		if (!((sp & 1))) {
			stSize = 0;
			goto l1;
		}
		stSize = (sp >> 1);
	l1:	/* end fetchStackPointerOf: */;
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if (((((usqInt ) index)) >= 1)
	 && ((((usqInt ) index)) <= (((usqInt ) stSize)))) {
		/* begin subscript:with:format: */
		VM_LABEL(1subscriptwithformat);
		if (fmt <= 4) {
			return longAt((array + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord));
		}
		if (fmt < 8) {
			return positive32BitIntegerFor(long32At((array + BaseHeaderSize) + (((index + fixedFields) - 1) << 2)));
		}
		else {
			return (((byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
		}
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return 0;
	}
}


/*	Do what ST would return for <obj> at: index put: value. */

sqInt
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sp;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt valueToStore;

	hdr = longAt(array);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l2;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l2;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l2;
	}
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(array))) >> 12) & 31)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
		goto l4;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l4;
	}
l4:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((((((usqInt) hdr) >> 12) & 31) == 13)
	 || (((((usqInt) hdr) >> 12) & 31) == 14))) {
		/* begin fetchStackPointerOf: */
		sp = longAt((array + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		if (!((sp & 1))) {
			stSize = 0;
			goto l1;
		}
		stSize = (sp >> 1);
	l1:	/* end fetchStackPointerOf: */;
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if (((((usqInt ) index)) >= 1)
	 && ((((usqInt ) index)) <= (((usqInt ) stSize)))) {
		/* begin subscript:with:storing:format: */
		VM_LABEL(1subscriptwithstoringformat);
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if ((((usqInt) array)) < (((usqInt) GIV(youngStart)))) {
				possibleRootStoreIntovalue(array, value);
			}
			longAtput((array + BaseHeaderSize) + (((index + fixedFields) - 1) << ShiftForWord), value);
		}
		else {
			if (fmt < 8) {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(value);
				if (!GIV(primFailCode)) {
					long32Atput((array + BaseHeaderSize) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			}
			else {
				if (!((value & 1))) {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
				}
				valueToStore = (value >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 255))) {
					/* begin primitiveFail */
					GIV(primFailCode) = 1;
				}
				if (!GIV(primFailCode)) {
					byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), valueToStore);
				}
			}
		}
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
	}
}


/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

static sqInt
storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    usqInt firstIn;
    usqInt firstOut;
    usqInt hdrBaseIn;
    usqInt hdrBaseOut;
    sqInt hdrTypeBits;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt in;
    sqInt in1;
    sqInt lastAddr;
    sqInt lastAddr1;
    sqInt lastAddr2;
    sqInt lastAddr3;
    usqInt lastIn;
    sqInt lastIn1;
    sqInt lastIn2;
    usqInt lastOut;
    usqInt lastPtr;
    usqInt lastSeg;
    sqInt mapOop;
    sqInt oop;
    sqInt out;
    sqInt out1;
    usqInt savedYoungStart;
    usqInt segOop;
    sqInt sz;
    sqInt versionOffset;

	if (!((((longAt(outPointerArray)) & TypeMask) == HeaderTypeSizeAndClass)
		 && (((longAt(segmentWordArray)) & TypeMask) == HeaderTypeSizeAndClass))) {
		return PrimErrGenericFailure;
	}
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	firstOut = outPointerArray + BaseHeaderSize;
	lastOut = firstOut - BytesPerWord;

	/* top half */

	hdrBaseOut = outPointerArray + (((lastPointerOf(outPointerArray)) / (BytesPerWord * 2)) * BytesPerWord);
	lastSeg = segmentWordArray;

	/* Write a version number for byte order and version check */

	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BytesPerWord;
	versionOffset = BytesPerWord;
	lastSeg += versionOffset;
	if (lastSeg > endSeg) {
		return PrimErrGenericFailure;
	}
	longAtput(lastSeg, imageSegmentVersion());

	/* Take 1/8 of seg */

	firstIn = endSeg - (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 8)) * BytesPerWord);
	lastIn = firstIn - BytesPerWord;

	/* top half of that */
	/* First mark the rootArray and all root objects. */

	hdrBaseIn = firstIn + (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 16)) * BytesPerWord);
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | MarkBit);
	lastPtr = arrayOfRoots + (lastPointerOf(arrayOfRoots));
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) | MarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	savedYoungStart = GIV(youngStart);

	/* process all of memory */

	GIV(youngStart) = memory;
	/* begin markAndTraceInterpreterOops */
	markAndTrace(GIV(specialObjectsOop));
	markAndTrace(GIV(activeContext));
	markAndTrace(GIV(messageSelector));
	markAndTrace(GIV(newMethod));
	markAndTrace(GIV(lkupClass));
	for (i4 = 1; i4 <= GIV(remapBufferCount); i4 += 1) {
		oop = GIV(remapBuffer)[i4];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
	markAndTraceTraceLogs();

	/* Finally unmark the rootArray and all root objects. */

	GIV(youngStart) = savedYoungStart;
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) & AllButMarkBit);
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) & AllButMarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	lastIn += BytesPerWord;
	if ((lastIn >= hdrBaseIn)
	 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(arrayOfRoots, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {
		lastIn -= BytesPerWord;
		restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
		i = outPointerArray + BaseHeaderSize;
		while (i <= lastAddr) {
			longAtput(i, GIV(nilObj));
			i += BytesPerWord;
		}
		if (DoAssertionChecks) {
			verifyCleanHeaders();
		}
		return PrimErrGenericFailure;
	}
	segOop = ((segmentWordArray + versionOffset) + BaseHeaderSize) + (headerTypeBytes[(longAt((segmentWordArray + versionOffset) + BaseHeaderSize)) & TypeMask]);
	while (segOop <= lastSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type=0 or 1) -- start with that. */

			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */

			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */
		/* Go through all oops, remapping them... */

		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */

			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = fieldOop & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Just an integer -- nothing to do */

				fieldPtr += BytesPerWord;
			}
			else {
				header = longAt(fieldOop);
				if ((header & TypeMask) == HeaderTypeFree) {

					/* Has already been forwarded -- this is the link */

					mapOop = header & AllButTypeMask;
				}
				else {
					if (((longAt(fieldOop)) & MarkBit) == 0) {

						/* Points to an unmarked obj -- an internal pointer.
							Copy the object into the segment, and forward its oop. */

						lastIn += BytesPerWord;
						if ((lastIn >= hdrBaseIn)
						 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(fieldOop, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {

							/* Out of space in segment */

							lastIn -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr1 = outPointerArray + (lastPointerOf(outPointerArray));
							i1 = outPointerArray + BaseHeaderSize;
							while (i1 <= lastAddr1) {
								longAtput(i1, GIV(nilObj));
								i1 += BytesPerWord;
							}
							if (DoAssertionChecks) {
								verifyCleanHeaders();
							}
							return PrimErrGenericFailure;
						}
						mapOop = (longAt(fieldOop)) & AllButTypeMask;
					}
					else {

						/* Points to a marked obj -- an external pointer.
							Map it as a tagged index in outPointers, and forward its oop. */

						lastOut += BytesPerWord;
						if (lastOut >= hdrBaseOut) {

							/* Out of space in outPointerArray */

							lastOut -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr2 = outPointerArray + (lastPointerOf(outPointerArray));
							i2 = outPointerArray + BaseHeaderSize;
							while (i2 <= lastAddr2) {
								longAtput(i2, GIV(nilObj));
								i2 += BytesPerWord;
							}
							if (DoAssertionChecks) {
								verifyCleanHeaders();
							}
							return PrimErrGenericFailure;
						}
						mapOop = (lastOut - outPointerArray) | 2147483648UL;
						/* begin forward:to:savingOopAt:andHeaderAt: */
						longAtput(lastOut, fieldOop);
						longAtput(hdrBaseOut + (lastOut - firstOut), longAt(fieldOop));
						longAtput(fieldOop, mapOop + HeaderTypeFree);
					}
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += BytesPerWord * 2;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) segOop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(segOop);
			if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header1 & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		segOop = ((sqInt) ((segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask])));
	}
	restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
	if ((((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) < 12)
	 || ((endSeg - lastSeg) < 12)) {
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr3 = outPointerArray + (lastPointerOf(outPointerArray));
		i3 = outPointerArray + BaseHeaderSize;
		while (i3 <= lastAddr3) {
			longAtput(i3, GIV(nilObj));
			i3 += BytesPerWord;
		}
		if (DoAssertionChecks) {
			verifyCleanHeaders();
		}
		return PrimErrGenericFailure;
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];

	/* Copy the 3-word wordArray header to establish a free chunk. */

	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	/* begin transfer:from:to: */
	flag("Dan");
	in = (segmentWordArray - extraSize) - BytesPerWord;
	lastIn1 = in + (3 * BytesPerWord);
	out = (lastOut + BytesPerWord) - BytesPerWord;
	while ((((usqInt) in)) < (((usqInt) lastIn1))) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	longAtput(lastOut + BytesPerWord, (((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) - extraSize) + hdrTypeBits);
	longAtput(outPointerArray - extraSize, ((lastOut - firstOut) + (BytesPerWord * 2)) + hdrTypeBits);
	beRootIfOld(outPointerArray);
	/* begin transfer:from:to: */
	flag("Dan");
	in1 = (segmentWordArray - extraSize) - BytesPerWord;
	lastIn2 = in1 + (3 * BytesPerWord);
	out1 = (lastSeg + BytesPerWord) - BytesPerWord;
	while ((((usqInt) in1)) < (((usqInt) lastIn2))) {
		longAtput((out1 += BytesPerWord), longAt((in1 += BytesPerWord)));
	}
	longAtput(segmentWordArray - extraSize, ((lastSeg - segmentWordArray) + BaseHeaderSize) + hdrTypeBits);
	longAtput(lastSeg + BytesPerWord, ((endSeg - lastSeg) - extraSize) + hdrTypeBits);
	if (DoAssertionChecks) {
		verifyCleanHeaders();
	}
	return PrimNoErr;
}


/*	Note: May be called by translated primitive code. */

sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{
	if ((integerValue ^ (integerValue << 1)) >= 0) {
		longAtput((objectPointer + BaseHeaderSize) + (fieldIndex << ShiftForWord), ((integerValue << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		GIV(primFailCode) = 1;
	}
}


/*	Like storePointer:ofObject:withValue:, but the caller guarantees that the
	object being stored into is a young object or is already marked as a root. */

sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{
	return longAtput((oop + BaseHeaderSize) + (fieldIndex << ShiftForWord), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{
	if ((((usqInt) oop)) < (((usqInt) GIV(youngStart)))) {
		possibleRootStoreIntovalue(oop, valuePointer);
	}
	return longAtput((oop + BaseHeaderSize) + (fieldIndex << ShiftForWord), valuePointer);
}


/*	Return the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not a SmallInteger! */

sqInt
stSizeOf(sqInt oop)
{
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt sp;
    sqInt sz;
    sqInt totalLength;

	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> 8) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;
		goto l1;
	}
	if (fmt < 8) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> 2;
		goto l1;
	}
	else {
		totalLength = (sz - BaseHeaderSize) - (fmt & 3);
		goto l1;
	}
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	/* begin fetchClassOfNonInt: */
	if (((ccIndex = (((usqInt) (longAt(oop))) >> 12) & 31)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		goto l3;
	}
	else {
		class = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (CompactClasses << ShiftForWord))) + BaseHeaderSize) + ((ccIndex - 1) << ShiftForWord));
		goto l3;
	}
l3:	/* end fetchClassOfNonInt: */;
	classFormat = (longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << ShiftForWord))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 63)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((((((usqInt) hdr) >> 12) & 31) == 13)
	 || (((((usqInt) hdr) >> 12) & 31) == 14))) {
		/* begin fetchStackPointerOf: */
		sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
		if (!((sp & 1))) {
			return 0;
		}
		return (sp >> 1);
	}
	else {
		return totalLength - fixedFields;
	}
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(successBoolean)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
}


/*	Return true if there is enough free space after doing a garbage
	collection. If not, signal that space is low.
 */

static sqInt
sufficientSpaceAfterGC(sqInt minFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt growSize;
    sqInt limit;

	incrementalGC();
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) < (((usqInt) minFree))) {
		if (GIV(signalLowSpace)) {
			return 0;
		}
		fullGC();
		if ((((usqInt ) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= ((((usqInt ) minFree)) + 15000)) {
			return 1;
		}
		growSize = (minFree - ((longAt(GIV(freeBlock))) & AllButTypeMask)) + GIV(growHeadroom);
		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), growSize);
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			assert(((limit - 24) & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = limit - 24;
			initializeMemoryFirstFree(GIV(freeBlock));
		}
		if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) (minFree + 15000)))) {
			return 1;
		}
		return 0;
	}
	return 1;
}


/*	Return true if there is enough space to allocate the given number of
	bytes, perhaps after doing a garbage collection.
 */

static sqInt
sufficientSpaceToAllocate(sqInt bytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt minFree;


	/* check for low-space */

	minFree = ((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) & (~(BytesPerWord - 1));
	if ((((usqInt) ((longAt(GIV(freeBlock))) & AllButTypeMask))) >= (((usqInt) minFree))) {
		return 1;
	}
	else {
		return sufficientSpaceAfterGC(minFree);
	}
}

sqInt
superclassOf(sqInt classPointer)
{
	return longAt((classPointer + BaseHeaderSize) + (SuperclassIndex << ShiftForWord));
}


/*	Sweep memory from youngStart through the end of memory. Free all 
	inaccessible objects and coalesce adjacent free chunks. Clear the mark 
	bits of accessible objects. Compute the starting point for the first pass
	of 
	incremental compaction (compStart). Return the number of surviving 
	objects. */
/*	Details: Each time a non-free object is encountered, decrement the 
	number of available forward table entries. If all entries are spoken for 
	(i.e., entriesAvailable reaches zero), set compStart to the last free 
	chunk before that object or, if there is no free chunk before the given 
	object, the first free chunk after it. Thus, at the end of the sweep 
	phase, compStart through compEnd spans the highest collection of 
	non-free objects that can be accomodated by the forwarding table. This 
	information is used by the first pass of incremental compaction to 
	ensure that space is initially freed at the end of memory. Note that 
	there should always be at least one free chunk--the one at the end of 
	the heap. */

static sqInt
sweepPhase(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endOfMemoryLocal;
    sqInt entriesAvailable;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;
    sqInt survivors;

	entriesAvailable = fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */

	firstFree = null;
	endOfMemoryLocal = GIV(endOfMemory);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < endOfMemoryLocal) {

		/* get oop's header, header type, size, and header size */

		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			else {

				/* free chunk */

				oopSize = oopHeader & LongSizeMask;
			}
		}
		if ((oopHeader & MarkBit) == 0) {
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk != null) {

				/* enlarge current free chunk to include this oop */

				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */
				/* chunk may start 4 or 8 bytes before oop */

				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */

				freeChunkSize = oopSize + (oop - freeChunk);
				if (firstFree == null) {
					firstFree = freeChunk;
				}
			}
		}
		else {
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt) (longAt(oop))) >> 8) & 15) == 4) {
				finalizeReference(oop);
			}
			if (entriesAvailable > 0) {
				entriesAvailable -= 1;
			}
			else {

				/* start compaction at the last free chunk before this object */

				firstFree = freeChunk;
			}
			if (freeChunk != null) {
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk != null) {
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (!(oop == GIV(endOfMemory))) {
		error("sweep failed to find exact end of memory");
	}
	if (firstFree == null) {
		error("expected to find at least one free object");
	}
	else {
		GIV(compStart) = firstFree;
	}
	return survivors;
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted. */

static sqInt
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt excessSignals;

	if ((longAt((aSemaphore + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {

		/* no process is waiting on this semaphore */

		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if (((excessSignals + 1) ^ ((excessSignals + 1) << 1)) >= 0) {
			longAtput((aSemaphore + BaseHeaderSize) + (ExcessSignalsIndex << ShiftForWord), (((excessSignals + 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return resume(removeFirstLinkOfList(aSemaphore));
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

void
tenuringIncrementalGC(void)
{
	GIV(forceTenureFlag) = 1;
	incrementalGC();
}


/*	Returns the top of the remappable oop. Useful when writing loops. */

sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}

sqInt
trueObject(void)
{
	return GIV(trueObj);
}


/*	update pointers in the given memory range */

static void
updatePointersInRangeFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock11;
    sqInt fwdBlock2;
    sqInt fwdBlock3;
    sqInt fwdBlock4;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header13;
    sqInt header2;
    sqInt header21;
    sqInt header3;
    sqInt header4;
    sqInt header5;
    sqInt methodHeader;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    sqInt oop;
    sqInt realHeader;
    sqInt size;
    sqInt sp;
    sqInt sz;
    sqInt sz1;
    sqInt targetObj;
    sqInt targetObj1;

	oop = memStart + (headerTypeBytes[(longAt(memStart)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) memEnd))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			/* begin remapFieldsAndClassOf: */
			VM_LABEL(0remapFieldsAndClassOf);
			/* begin lastPointerWhileForwarding: */
			VM_LABEL(1lastPointerWhileForwarding);
			/* begin headerWhileForwardingOf: */
			header11 = longAt(oop);
			if ((header11 & MarkBit) != 0) {

				/* oop is forwarded; get its real header from its forwarding table entry */

				fwdBlock2 = (header11 & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock2));
				header11 = longAt(fwdBlock2 + BytesPerWord);
			}
			header3 = header11;
			fmt = (((usqInt) header3) >> 8) & 15;
			if (fmt <= 4) {
				if ((fmt == 3)
				 && ((((((usqInt) header3) >> 12) & 31) == 13)
				 || (((((usqInt) header3) >> 12) & 31) == 14))) {
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l4;
					}
					contextSize = (sp >> 1);
				l4:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header3, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
					goto l5;
				}
				if ((header3 & TypeMask) == HeaderTypeSizeAndClass) {
					size = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
				}
				else {
					size = header3 & SizeMask;
				}
				fieldOffset = size - BaseHeaderSize;
				goto l5;
			}
			if (fmt < 12) {
				fieldOffset = 0;
				goto l5;
			}
			methodHeader = longAt(oop + BaseHeaderSize);
			fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
		l5:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {
					/* begin remappedObj: */
					fwdBlock1 = ((longAt(fieldOop)) & AllButMarkBitAndTypeMask) << 1;
					assert(fwdBlockValid(fwdBlock1));
					targetObj = longAt(fwdBlock1);
					assert(addressCouldBeObjWhileForwarding(targetObj));
					newOop = targetObj;
					longAtput(oop + fieldOffset, newOop);
					if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
					 && ((((usqInt) newOop)) >= (((usqInt) GIV(youngStart))))) {
						/* begin beRootWhileForwarding: */
						header5 = longAt(oop);
						if ((header5 & MarkBit) != 0) {

							/* This oop is forwarded */

							fwdBlock4 = (header5 & AllButMarkBitAndTypeMask) << 1;
							assert(fwdBlockValid(fwdBlock4));
							/* begin noteAsRoot:headerLoc: */
							header13 = longAt(fwdBlock4 + BytesPerWord);
							if ((header13 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableRedZone) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots 
					table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(fwdBlock4 + BytesPerWord, header13 | RootBit);
								}
								else {
									if (GIV(rootTableCount) < RootTableSize) {

										/* we're getting in the red zone */
										/* but there's still space to record it */

										GIV(rootTableCount) += 1;
										GIV(rootTable)[GIV(rootTableCount)] = oop;
										longAtput(fwdBlock4 + BytesPerWord, header13 | RootBit);
										GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
									}
								}
							}
						}
						else {
							/* begin noteAsRoot:headerLoc: */
							header2 = longAt(oop);
							if ((header2 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableRedZone) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots 
					table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(oop, header2 | RootBit);
								}
								else {
									if (GIV(rootTableCount) < RootTableSize) {

										/* we're getting in the red zone */
										/* but there's still space to record it */

										GIV(rootTableCount) += 1;
										GIV(rootTable)[GIV(rootTableCount)] = oop;
										longAtput(oop, header2 | RootBit);
										GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
									}
								}
							}
						}
					}
				}
				fieldOffset -= BytesPerWord;
			}
			/* begin remapClassOf: */
			VM_LABEL(0remapClassOf);
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l3;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock11 = ((longAt(classOop)) & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock11));
				targetObj1 = longAt(fwdBlock11);
				assert(addressCouldBeObjWhileForwarding(targetObj1));
				newClassOop = targetObj1;
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
				 && ((((usqInt) newClassOop)) >= (((usqInt) GIV(youngStart))))) {
					/* begin beRootWhileForwarding: */
					header4 = longAt(oop);
					if ((header4 & MarkBit) != 0) {

						/* This oop is forwarded */

						fwdBlock3 = (header4 & AllButMarkBitAndTypeMask) << 1;
						assert(fwdBlockValid(fwdBlock3));
						/* begin noteAsRoot:headerLoc: */
						header12 = longAt(fwdBlock3 + BytesPerWord);
						if ((header12 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableRedZone) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots 
					table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(fwdBlock3 + BytesPerWord, header12 | RootBit);
							}
							else {
								if (GIV(rootTableCount) < RootTableSize) {

									/* we're getting in the red zone */
									/* but there's still space to record it */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(fwdBlock3 + BytesPerWord, header12 | RootBit);
									GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
								}
							}
						}
					}
					else {
						/* begin noteAsRoot:headerLoc: */
						header21 = longAt(oop);
						if ((header21 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableRedZone) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots 
					table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(oop, header21 | RootBit);
							}
							else {
								if (GIV(rootTableCount) < RootTableSize) {

									/* we're getting in the red zone */
									/* but there's still space to record it */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(oop, header21 | RootBit);
									GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
								}
							}
						}
					}
				}
			}
		l3:	/* end remapClassOf: */;
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (DoAssertionChecks) {
				if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
					error("no objects after the end of memory");
				}
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
					sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					goto l2;
				}
				else {
					sz1 = header1 & SizeMask;
					goto l2;
				}
			l2:	/* end sizeBitsOf: */;
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlock = (header & AllButMarkBitAndTypeMask) << 1;
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */

		realHeader = longAt(fwdBlock + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l1:	/* end objectAfterWhileForwarding: */;
	}
}


/*	update pointers in root objects */

static void
updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock11;
    sqInt fwdBlock2;
    sqInt fwdBlock3;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header2;
    sqInt header21;
    sqInt header3;
    sqInt header4;
    sqInt i;
    sqInt methodHeader;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    sqInt oop;
    sqInt size;
    sqInt sp;
    sqInt targetObj;
    sqInt targetObj1;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		if (((((usqInt) oop)) < (((usqInt) memStart)))
		 || ((((usqInt) oop)) >= (((usqInt) memEnd)))) {
			/* begin remapFieldsAndClassOf: */
			VM_LABEL(1remapFieldsAndClassOf);
			/* begin lastPointerWhileForwarding: */
			VM_LABEL(2lastPointerWhileForwarding);
			/* begin headerWhileForwardingOf: */
			header11 = longAt(oop);
			if ((header11 & MarkBit) != 0) {

				/* oop is forwarded; get its real header from its forwarding table entry */

				fwdBlock2 = (header11 & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock2));
				header11 = longAt(fwdBlock2 + BytesPerWord);
			}
			header3 = header11;
			fmt = (((usqInt) header3) >> 8) & 15;
			if (fmt <= 4) {
				if ((fmt == 3)
				 && ((((((usqInt) header3) >> 12) & 31) == 13)
				 || (((((usqInt) header3) >> 12) & 31) == 14))) {
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + (StackPointerIndex << ShiftForWord));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l1;
					}
					contextSize = (sp >> 1);
				l1:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header3, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerWord;
					goto l2;
				}
				if ((header3 & TypeMask) == HeaderTypeSizeAndClass) {
					size = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
				}
				else {
					size = header3 & SizeMask;
				}
				fieldOffset = size - BaseHeaderSize;
				goto l2;
			}
			if (fmt < 12) {
				fieldOffset = 0;
				goto l2;
			}
			methodHeader = longAt(oop + BaseHeaderSize);
			fieldOffset = (((((usqInt) methodHeader) >> 10) & 255) * BytesPerWord) + BaseHeaderSize;
		l2:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {
					/* begin remappedObj: */
					fwdBlock1 = ((longAt(fieldOop)) & AllButMarkBitAndTypeMask) << 1;
					assert(fwdBlockValid(fwdBlock1));
					targetObj = longAt(fwdBlock1);
					assert(addressCouldBeObjWhileForwarding(targetObj));
					newOop = targetObj;
					longAtput(oop + fieldOffset, newOop);
					if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
					 && ((((usqInt) newOop)) >= (((usqInt) GIV(youngStart))))) {
						/* begin beRootWhileForwarding: */
						header = longAt(oop);
						if ((header & MarkBit) != 0) {

							/* This oop is forwarded */

							fwdBlock = (header & AllButMarkBitAndTypeMask) << 1;
							assert(fwdBlockValid(fwdBlock));
							/* begin noteAsRoot:headerLoc: */
							header1 = longAt(fwdBlock + BytesPerWord);
							if ((header1 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableRedZone) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots 
					table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(fwdBlock + BytesPerWord, header1 | RootBit);
								}
								else {
									if (GIV(rootTableCount) < RootTableSize) {

										/* we're getting in the red zone */
										/* but there's still space to record it */

										GIV(rootTableCount) += 1;
										GIV(rootTable)[GIV(rootTableCount)] = oop;
										longAtput(fwdBlock + BytesPerWord, header1 | RootBit);
										GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
									}
								}
							}
						}
						else {
							/* begin noteAsRoot:headerLoc: */
							header2 = longAt(oop);
							if ((header2 & RootBit) == 0) {
								if (GIV(rootTableCount) < RootTableRedZone) {

									/* record oop as root only if not already recorded */
									/* record root if there is enough room in the roots 
					table  */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(oop, header2 | RootBit);
								}
								else {
									if (GIV(rootTableCount) < RootTableSize) {

										/* we're getting in the red zone */
										/* but there's still space to record it */

										GIV(rootTableCount) += 1;
										GIV(rootTable)[GIV(rootTableCount)] = oop;
										longAtput(oop, header2 | RootBit);
										GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
									}
								}
							}
						}
					}
				}
				fieldOffset -= BytesPerWord;
			}
			/* begin remapClassOf: */
			VM_LABEL(1remapClassOf);
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l3;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock11 = ((longAt(classOop)) & AllButMarkBitAndTypeMask) << 1;
				assert(fwdBlockValid(fwdBlock11));
				targetObj1 = longAt(fwdBlock11);
				assert(addressCouldBeObjWhileForwarding(targetObj1));
				newClassOop = targetObj1;
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if (((((usqInt) oop)) < (((usqInt) GIV(youngStart))))
				 && ((((usqInt) newClassOop)) >= (((usqInt) GIV(youngStart))))) {
					/* begin beRootWhileForwarding: */
					header4 = longAt(oop);
					if ((header4 & MarkBit) != 0) {

						/* This oop is forwarded */

						fwdBlock3 = (header4 & AllButMarkBitAndTypeMask) << 1;
						assert(fwdBlockValid(fwdBlock3));
						/* begin noteAsRoot:headerLoc: */
						header12 = longAt(fwdBlock3 + BytesPerWord);
						if ((header12 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableRedZone) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots 
					table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(fwdBlock3 + BytesPerWord, header12 | RootBit);
							}
							else {
								if (GIV(rootTableCount) < RootTableSize) {

									/* we're getting in the red zone */
									/* but there's still space to record it */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(fwdBlock3 + BytesPerWord, header12 | RootBit);
									GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
								}
							}
						}
					}
					else {
						/* begin noteAsRoot:headerLoc: */
						header21 = longAt(oop);
						if ((header21 & RootBit) == 0) {
							if (GIV(rootTableCount) < RootTableRedZone) {

								/* record oop as root only if not already recorded */
								/* record root if there is enough room in the roots 
					table  */

								GIV(rootTableCount) += 1;
								GIV(rootTable)[GIV(rootTableCount)] = oop;
								longAtput(oop, header21 | RootBit);
							}
							else {
								if (GIV(rootTableCount) < RootTableSize) {

									/* we're getting in the red zone */
									/* but there's still space to record it */

									GIV(rootTableCount) += 1;
									GIV(rootTable)[GIV(rootTableCount)] = oop;
									longAtput(oop, header21 | RootBit);
									GIV(allocationCount) = GIV(allocationsBetweenGCs) + 1;
								}
							}
						}
					}
				}
			}
		l3:	/* end remapClassOf: */;
		}
	}
}

sqInt
validInstructionPointerinMethod(sqInt anInstrPointer, sqInt aMethod)
{
	return (anInstrPointer >= ((aMethod + (lastPointerOf(aMethod))) + 1))
	 && (anInstrPointer < (aMethod + (byteLengthOf(aMethod))));
}

static void
verifyCleanHeaders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = memory + (headerTypeBytes[(longAt(memory)) & TypeMask]);
	while ((((usqInt) oop)) < (((usqInt) GIV(endOfMemory)))) {
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			if (!((objectAfter(oop)) == GIV(endOfMemory))) {
				error("Invalid obj with HeaderTypeBits = Free.");
			}
		}
		else {
			if (((longAt(oop)) & MarkBit) != 0) {
				error("Invalid obj with MarkBit set.");
			}
		}
		/* begin objectAfter: */
		if (DoAssertionChecks) {
			if ((((usqInt) oop)) >= (((usqInt) GIV(endOfMemory)))) {
				error("no objects after the end of memory");
			}
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
				goto l1;
			}
			else {
				sz = header & SizeMask;
				goto l1;
			}
		l1:	/* end sizeBitsOf: */;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	return 0 for little endian, 1 for big endian */
/*	?!*#$%! _Terrible_ name. Call it what it is.
	VMBIGENDIAN or VMLITTLEENDIAN. Dont leave us guessing!!!!
	Alas this has to remain for backward compatibility. */

sqInt
vmEndianness(void)
{
	return (VMBIGENDIAN
		? (1)
		: (0));
}


/*	Return the highest priority process that is ready to run. */
/*	Note: It is a fatal VM error if there is no runnable process. */

static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt p;
    sqInt processList;
    sqInt schedLists;
    sqInt sz;

	schedLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << ShiftForWord))) + BaseHeaderSize) + (ValueIndex << ShiftForWord))) + BaseHeaderSize) + (ProcessListsIndex << ShiftForWord));
	/* begin fetchWordLengthOf: */
	/* begin sizeBitsOf: */
	header = longAt(schedLists);
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(schedLists - (BytesPerWord * 2))) & LongSizeMask;
		goto l1;
	}
	else {
		sz = header & SizeMask;
		goto l1;
	}
l1:	/* end sizeBitsOf: */;
	p = ((usqInt) (sz - BaseHeaderSize)) >> ShiftForWord;

	/* index of last indexable field */

	p -= 1;
	processList = longAt((schedLists + BaseHeaderSize) + (p << ShiftForWord));
	while ((longAt((processList + BaseHeaderSize) + (FirstLinkIndex << ShiftForWord))) == GIV(nilObj)) {
		p -= 1;
		if (p < 0) {
			error("scheduler could not find a runnable process");
		}
		processList = longAt((schedLists + BaseHeaderSize) + (p << ShiftForWord));
	}
	return removeFirstLinkOfList(processList);
}


/*	Return the given 64-bit integer with its halves in the reverse order. */

static sqInt
wordSwapped(sqInt w)
{
	if (!(BytesPerWord == 8)) {
		error("This cannot happen.");
	}
	return ((((usqInt) w << 0)) & Bytes3to0Mask) + ((((usqInt) w << 0)) & Bytes7to4Mask);
}

static sqInt
writeImageFileIO(sqInt imageBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt i;
    sqInt okToWrite;
    void *sCWIfn;


	/* If the security plugin can be loaded, use it to check for write permission.
	If not, assume it's ok */

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!(okToWrite)) {
			/* begin primitiveFail */
			GIV(primFailCode) = 1;
			return null;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */

	headerSize = 64;
	f = sqImageFileOpen(imageName, "wb");
	if (f == null) {
		/* begin success: */
		if (!(0)) {
			if (!GIV(primFailCode)) {

				/* Don't overwrite an error code that has already been set. */

				GIV(primFailCode) = 1;
			}
		}
		return null;
	}
	headerStart = sqImageFileStartLocation(f,imageName,headerSize+imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putLongtoFile(imageFormatVersionNumber, f);
	putLongtoFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile(memory, f);
	putLongtoFile(GIV(specialObjectsOop), f);
	putLongtoFile(GIV(lastHash), f);
	putLongtoFile(ioScreenSize(), f);
	putLongtoFile(GIV(fullScreenFlag), f);
	putLongtoFile(extraVMMemory, f);
	for (i = 1; i <= 7; i += 1) {
		putLongtoFile(0, f);
	}
	if (!(!GIV(primFailCode))) {
		sqImageFileClose(f);
		return null;
	}
	sqImageFileSeek(f, headerStart + headerSize);
	bytesWritten = sqImageFileWrite(pointerForOop(memory), sizeof(unsigned char), imageBytes, f);
	/* begin success: */
	if (!(bytesWritten == imageBytes)) {
		if (!GIV(primFailCode)) {

			/* Don't overwrite an error code that has already been set. */

			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f);
}

static sqInt
writeImageFile(sqInt imageBytes)
{
    void *fn;

	writeImageFileIO(imageBytes);
	fn = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
	if (!(fn == 0)) {
		((sqInt (*)(char*, char*, char*))fn)(imageName, "STim", "FAST");
	}
}


void* vm_exports[][3] = {
	{"", "addGCRoot", (void*)addGCRoot},
	{"", "getStackPointer", (void*)getStackPointer},
	{"", "internalIsImmutable", (void*)internalIsImmutable},
	{"", "internalIsMutable", (void*)internalIsMutable},
	{"", "moduleUnloaded", (void*)moduleUnloaded},
	{"", "primitiveByteArrayDoubleAt", (void*)primitiveByteArrayDoubleAt},
	{"", "primitiveByteArrayDoubleAtPut", (void*)primitiveByteArrayDoubleAtPut},
	{"", "primitiveByteArrayFloatAt", (void*)primitiveByteArrayFloatAt},
	{"", "primitiveByteArrayFloatAtPut", (void*)primitiveByteArrayFloatAtPut},
	{"", "primitiveByteArrayNByteIIntegerAtPut", (void*)primitiveByteArrayNByteIIntegerAtPut},
	{"", "primitiveByteArrayNByteIntegerAt", (void*)primitiveByteArrayNByteIntegerAt},
	{"", "primitiveDisablePowerManager", (void*)primitiveDisablePowerManager},
	{"", "primitiveEventProcessingControl", (void*)primitiveEventProcessingControl},
	{"", "primitiveForceTenure", (void*)primitiveForceTenure},
	{"", "primitiveIsRoot", (void*)primitiveIsRoot},
	{"", "primitiveIsYoung", (void*)primitiveIsYoung},
	{"", "primitiveRootTable", (void*)primitiveRootTable},
	{"", "primitiveRootTableAt", (void*)primitiveRootTableAt},
	{"", "primitiveScreenDepth", (void*)primitiveScreenDepth},
	{"", "primitiveSetGCBiasToGrow", (void*)primitiveSetGCBiasToGrow},
	{"", "primitiveSetGCBiasToGrowGCLimit", (void*)primitiveSetGCBiasToGrowGCLimit},
	{"", "primitiveSetGCSemaphore", (void*)primitiveSetGCSemaphore},
	{"", "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{"", "removeGCRoot", (void*)removeGCRoot},
	{"", "returnAsThroughCallbackContext", (void*)returnAsThroughCallbackContext},
	{"", "sendInvokeCallbackContext", (void*)sendInvokeCallbackContext},
	{"", "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{NULL, NULL, NULL}
};
