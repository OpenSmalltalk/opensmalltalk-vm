/* This file has been post-processed for GNU C */


/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.2207 uuid: 8da5de9b-33d7-478b-9081-58591f7da69a
   from
	StackInterpreter VMMaker.oscog-eem.2207 uuid: 8da5de9b-33d7-478b-9081-58591f7da69a
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.2207 uuid: 8da5de9b-33d7-478b-9081-58591f7da69a " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "sqGnu.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

void
invalidCompactClassError(char *s) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 */
#undef sigsetjmp
#undef siglongjmp
#if WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

#define odd(v) ((int)(v)&1)
#define even(v) (!odd(v))

/* end StackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFU
#define AllButMarkBit 0x7FFFFFFF
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFU
#define AllButTypeMask 0xFFFFFFFCU
#define AlternateHeaderHasPrimFlag 0x20000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 234
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BytecodeSetHasExtensions 1
#define CacheProbeMax 3
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 0
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMessageCompactIndex 0
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWeakFinalizer 55
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne 0xFFFFFFFFU
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DoAssertionChecks 0
#define DoExpensiveAssertionChecks 0
#define Done 4
#define DumpStackOnLowSpace 0
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FailImbalancedPrimitives 0
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 4
#define FoxCallerSavedIP 4
#define FoxFrameFlags -8
#define FoxMethod -4
#define FoxReceiver -16
#define FoxSavedFP 0
#define FoxThisContext -12
#define FrameSlots 6
#define FullClosureFirstCopiedValueIndex 4
#define GCCheckPrimCall 64
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GCTopMarker 3
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define ImmutabilityBit 0x20000000
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongSizeMask 0xFFFFFFFCU
#define LongSizeNumBits 30
#define LongStoreBytecode 129
#define LowcodeVM 0
#define MarkBit 0x80000000U
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MULTIPLEBYTECODESETS 0
#define MyListIndex 3
#define NewspeakVM 0
#define NextLinkIndex 0
#define NilObject 0
#define NSMethodCacheSize 4096
#if !defined(PharoVM) /* Allow this to be overridden on the compiler command line */
# define PharoVM 0
#endif
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNoModification 8
#define PrimErrNotFound 11
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimNoErr 0
#define PrimNumberExternalCall 117
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define SistaVM 0
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSlots 22
#define SPURVM 0
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define V3PrimitiveBitsMask 0x200003FE
#define ValueIndex 1
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFU
#define XIndex 0
#define YIndex 1

typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static StackPage * NoDbgRegParms stackPageAt(sqInt index);
static StackPage * NoDbgRegParms stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
#if IMMUTABILITY
static sqInt NoDbgRegParms canBeImmutable(sqInt oop);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop);
static int NoDbgRegParms noInlineSigned32BitValueGutsOf(sqInt oop);
extern unsigned int positive32BitValueOf(sqInt oop);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetenv(void);
#if IMMUTABILITY
static void primitiveGetImmutability(void);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveHashMultiply(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
EXPORT(sqInt) primitiveIsYoung(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
EXPORT(sqInt) primitiveScreenScaleFactor(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
#if IMMUTABILITY
static void primitiveSetImmutability(void);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveUtcAndTimezoneOffset(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
static void primitiveWait(void);
static void primitiveYield(void);
extern sqInt signalNoResume(sqInt aSemaphore);
extern int signed32BitValueOf(sqInt oop);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static sqInt NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static sqInt NoDbgRegParms pageIndexFor(void *pointer);
static sqInt NoDbgRegParms addressCouldBeObjWhileForwarding(sqInt address);
extern sqInt addressCouldBeObj(sqInt address);
static sqInt NoDbgRegParms adjustAllOopsBy(sqInt bytesToShift);
static sqInt NoDbgRegParms allInstancesOf(sqInt aBehavior);
static sqInt allObjectsUnmarked(void);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern sqInt characterValueOf(sqInt oop);
static sqInt checkHeapIntegrity(void);
extern sqInt checkOkayOop(usqInt oop);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name);
static void clearLeakMapAndMapAccessibleObjects(void);
extern sqInt clone(sqInt obj);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
static sqInt defaultEdenBytes(void);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
extern sqInt eeInstantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms eeInstantiateMethodContextSlots(sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
static sqInt NoDbgRegParms eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt oop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
extern void fullGC(void);
static sqInt NoDbgRegParms fwdTableInit(sqInt blkSize);
static sqInt NoDbgRegParms fwdTableSize(sqInt blkSize);
static usqInt imageSegmentVersion(void);
static usqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static usqInt NoDbgRegParms incCompMove(sqInt bytesFreed);
extern void incrementalGC(void);
static void NoDbgRegParms initializeMemoryFirstFree(sqInt firstFree);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader);
extern sqInt isYoungObject(sqInt obj);
extern sqInt lastPointerOf(sqInt objOop);
extern sqInt leakCheckBecome(void);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckNewSpaceGC(void);
extern sqInt literalCountOfMethodHeader(sqInt methodHeader);
static sqInt NoDbgRegParms loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintReferencesTo(sqInt anOop);
static void NoDbgRegParms mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms markPhase(sqInt fullGCFlag);
static sqInt newSpaceBytes(void);
extern sqInt objectAfter(sqInt oop);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
static sqInt NoDbgRegParms oopHasAcceptableClass(sqInt signedOop);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag);
extern void printActivationsOf(sqInt aMethodObj);
extern void printContextReferencesTo(sqInt anOop);
extern void printMemory(void);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printWronglySizedContexts(sqInt printContexts);
static void NoDbgRegParms restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes);
static sqInt NoDbgRegParms safeObjectAfter(sqInt oop);
static sqInt NoDbgRegParms shortentoIndexableSize(sqInt obj, sqInt nSlots);
static sqInt NoDbgRegParms sizeBitsOfSafe(sqInt oop);
static sqInt NoDbgRegParms sizeBitsOf(sqInt oop);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt minFree);
static sqInt NoDbgRegParms sufficientSpaceToAllocate(sqInt bytes);
static sqInt sweepPhase(void);
static sqInt sweepPhaseForFullGC(void);
extern void unpinObject(sqInt objOop);
static void verifyCleanHeaders(void);
EXPORT(sqInt) addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt allObjects(void);
static sqInt NoDbgRegParms allYoungand(sqInt array1, sqInt array2);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms badContextSize(sqInt oop);
extern sqInt becomewith(sqInt array1, sqInt array2);
extern void beRootIfOld(sqInt oop);
static void NoDbgRegParms beRootWhileForwarding(sqInt oop);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern unsigned int byteSwapped32IfBigEndian(unsigned int w);
extern unsigned long long byteSwapped64IfBigEndian(unsigned long long w);
extern sqInt byteSwapped(sqInt w);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass);
extern sqInt characterObjectOf(sqInt characterCode);
extern sqInt characterTable(void);
extern sqInt checkedLongAt(sqInt byteAddress);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
extern sqInt classHeader(sqInt oop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classUnsafeAlien(void);
static void clearRootsTable(void);
extern sqInt compactClassAt(sqInt ccIndex);
extern sqInt compactClassIndexOfClass(sqInt classObj);
extern sqInt compactClassIndexOfHeader(sqInt header);
extern sqInt compactClassIndexOf(sqInt oop);
static sqInt NoDbgRegParms compactIndexOfClass(sqInt aClassOop);
static sqInt NoDbgRegParms containOnlyOops(sqInt array);
static sqInt NoDbgRegParms containOnlyOopsand(sqInt array1, sqInt array2);
static sqInt NoDbgRegParms copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
extern sqInt displayObject(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt oop);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqLong NoDbgRegParms fetchLong64ofObject(sqInt longIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static void NoDbgRegParms finalizeReference(usqInt oop);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt oop);
extern void * firstIndexableField(sqInt oop);
static sqInt firstStringyFakeFormat(void);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms followForwarded(sqInt objOop);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOfHeader(sqInt header);
static sqInt NoDbgRegParms fwdBlockValid(sqInt addr);
#if PharoVM
static float getHeapGrowthToSizeGCRatio(void);
#endif /* PharoVM */
static sqInt NoDbgRegParms goodContextSize(sqInt oop);
static sqInt NoDbgRegParms hasForwardingBlock(sqInt objOop);
static sqInt hasSixtyFourBitImmediates(void);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt objectPointer);
extern sqInt isArrayNonImm(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format);
static sqInt NoDbgRegParms isCompiledMethodHeader(sqInt objHeader);
extern sqInt isCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isContextNonImm(sqInt oop);
static sqInt NoDbgRegParms isContext(sqInt oop);
extern sqInt isImmediate(sqInt anOop);
extern sqInt isIndexable(sqInt oop);
extern sqInt isInMemory(sqInt address);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt isIntegerValue(sqInt intValue);
extern sqInt isMarked(sqInt oop);
extern sqInt isNonImmediate(sqInt anOop);
extern sqInt isNonIntegerObject(sqInt objectPointer);
static sqInt NoDbgRegParms isObjImmutable(sqInt anOop);
extern sqInt isOopCompiledMethod(sqInt oop);
static sqInt NoDbgRegParms isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt anOop);
extern sqInt isOopMutable(sqInt anOop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
static sqInt NoDbgRegParms isWeakNonImm(sqInt oop);
extern sqInt isWeak(sqInt oop);
static sqInt NoDbgRegParms isWordsOrBytesNonImm(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop);
extern sqInt lengthOf(sqInt oop);
static sqInt NoDbgRegParms lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
extern sqInt literalCountOf(sqInt methodPointer);
extern void longPrintInstancesOf(sqInt aClassOop);
static sqInt NoDbgRegParms lowestFreeAfter(sqInt chunk);
extern sqInt markAndTrace(sqInt oop);
extern sqInt maybeSplObj(sqInt index);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj);
extern sqInt nilObject(void);
extern sqInt noShiftCompactClassIndexOfHeader(sqInt header);
extern sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
extern sqInt numSlotsOf(sqInt obj);
extern sqInt objectBefore(sqInt address);
extern sqInt objectExactlyBefore(sqInt oop);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms oopFromChunk(sqInt chunk);
static sqInt NoDbgRegParms oopHasOkayClass(sqInt signedOop);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
extern sqInt primitiveErrorTable(void);
extern void printInstancesOf(sqInt aClassOop);
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
extern void pushRemappableOop(sqInt oop);
static sqInt NoDbgRegParms remapObj(sqInt obj);
extern sqInt remap(sqInt oop);
EXPORT(sqInt) removeGCRoot(sqInt *varLoc);
static sqInt NoDbgRegParms removeYoungRoot(sqInt obj);
extern sqInt shouldRemapObj(sqInt oop);
extern sqInt shouldRemapOop(sqInt oop);
static sqInt sixtyFourBitIndexableFormat(void);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
EXPORT(sqInt) statNumGCs(void);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
extern void tenuringIncrementalGC(void);
extern sqInt topRemappableOop(void);
extern sqInt trueObject(void);
static void NoDbgRegParms updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static void NoDbgRegParms updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
extern sqInt vmEndianness(void);
extern sqInt activeProcess(void);
EXPORT(void) addIdleUsecs(sqInt idleUsecs);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
extern sqInt checkedIntegerValueOf(sqInt intOop);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
static sqInt NoDbgRegParms checkStackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms checkStackPointerIndexForFrame(char *theFP);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer);
extern sqInt copiedValueCountOfFullClosure(sqInt closurePointer);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop);
static void cr(void);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
extern sqInt disownVM(sqInt flags);
static sqInt NoDbgRegParms displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt divorceAllFrames(void);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
EXPORT(sqInt) dumpImage(sqInt fileName);
extern void dumpPrimTraceLog(void);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg);
extern sqInt findSelectorOfMethod(sqInt meth);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage);
extern double floatArg(sqInt index);
static sqInt NoDbgRegParms flushExternalPrimitiveOf(sqInt methodObj);
static void flushMethodCache(void);
extern sqInt forceInterruptCheck(void);
extern void forceInterruptCheckFromHeartbeat(void);
static sqInt NoDbgRegParms frameCallerContext(char *theFP);
static sqInt NoDbgRegParms frameContext(char *theFP);
static sqInt NoDbgRegParms frameHasContext(char *theFP);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms frameMethod(char *theFP);
static sqInt NoDbgRegParms frameNumArgs(char *theFP);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms frameReceiver(char *theFP);
static sqInt NoDbgRegParms frameStackedReceiverOffset(char *theFP);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getCurrentBytecode(void);
static sqInt getDesiredCogCodeSize(void);
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
static void NeverInline handleStackOverflow(void);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern usqInt highBit(usqInt anUnsignedValue);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static usqInt NoDbgRegParms iframeMethod(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
extern sqInt integerArg(sqInt index);
static sqInt NeverInline interpreterAllocationReserveBytes(void);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt NoDbgRegParms isBaseFrame(char *theFP);
extern sqInt isFloatObject(sqInt oop);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
static sqInt NoDbgRegParms isLiveContext(sqInt oop);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext);
static sqInt NoDbgRegParms isStillMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext);
static void NoDbgRegParms makeContextSnapshotSafe(sqInt ctxt);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void NeverInline mapStackPages(void);
static sqInt NoDbgRegParms markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceInterpreterOops(sqInt fullGCFlag);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms maybeLeakCheckExternalPrimCall(sqInt aMethodObj);
static sqInt NoDbgRegParms maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodArg(sqInt index);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static sqInt NoDbgRegParms NeverInline noInlineSigned32BitIntegerGutsFor(sqInt integerValue);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage);
static sqInt numStkPages(void);
extern sqInt objCouldBeClassObj(sqInt objOop);
extern sqInt objectArg(sqInt index);
extern sqInt ownVM(sqInt threadIndexAndFlags);
extern sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
static sqInt NoDbgRegParms positiveMachineIntegerFor(usqIntptr_t value);
EXPORT(void) primitiveEventProcessingControl(void);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printCallStack(void);
static sqInt NoDbgRegParms printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printChar(sqInt aByte);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
extern void printExternalHeadFrame(void);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP);
static void NoDbgRegParms printFrameOopat(char *name, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address);
static void NoDbgRegParms printFrameThingat(char *name, char *address);
extern sqInt printFrame(char *theFP);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
extern void printHexnp(sqInt n);
extern void printHex(sqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printNum(sqInt n);
static void NoDbgRegParms printOopShort(sqInt oop);
extern sqInt printOop(sqInt oop);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static void NoDbgRegParms putLongtoFile(sqInt aLong, sqImageFile aFile);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList);
static sqInt NoDbgRegParms resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static sqInt NoDbgRegParms shortPrintOop(sqInt oop);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static sqInt NoDbgRegParms snapshot(sqInt embedded);
static void space(void);
extern sqInt specialSelector(sqInt index);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static sqInt stackLimitOffset(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt stackPageHeadroom(void);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
static void NoDbgRegParms transferTo(sqInt newProc);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage);
static void NoDbgRegParms voidLongRunningPrimitive(char *reason);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
extern char * whereIs(sqInt anOop);
static usqLong NoDbgRegParms wordSwapped(sqInt w);
static sqInt NeverInline writeImageFileIO(void);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFullGC(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveTerminateTo(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);
static void unmarkAllFrames(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss StackPage * stackPage;
_iss usqInt method;
_iss usqInt freeStart;
_iss char * framePointer;
_iss sqInt argumentCount;
_iss sqInt nilObj;
_iss usqInt newMethod;
_iss usqInt youngStart;
_iss usqInt instructionPointer;
_iss sqInt messageSelector;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss StackPage * pages;
_iss sqInt remapBufferCount;
_iss char * stackMemory;
_iss usqInt reserveStart;
_iss sqInt rootTableCount;
_iss char * stackLimit;
_iss sqInt bytesPerPage;
_iss usqInt memoryLimit;
_iss usqInt endOfMemory;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt scavengeThreshold;
_iss sqInt tempOop;
_iss sqInt numStackPages;
_iss sqInt jmpDepth;
_iss sqInt needGCFlag;
_iss usqInt fwdTableNext;
_iss sqLong nextProfileTick;
_iss sqInt profileProcess;
_iss sqInt profileMethod;
_iss usqInt compStart;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss sqInt tempOop2;
_iss sqInt statGrowMemory;
_iss sqInt weakRootCount;
_iss sqInt classNameIndex;
_iss sqInt profileSemaphore;
_iss sqInt lkupClass;
_iss sqInt preemptionYields;
_iss sqInt tempOop3;
_iss usqLong nextWakeupUsecs;
_iss sqInt statMarkCount;
_iss sqInt highestRunnableProcessPriority;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss usqInt memory;
_iss sqInt metaclassNumSlots;
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss sqInt statSweepCount;
_iss usqInt compEnd;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt lowSpaceThreshold;
_iss sqInt rootTableOverflowed;
_iss sqInt shrinkThreshold;
_iss sqInt statShrinkMemory;
_iss sqInt thisClassIndex;
_iss usqInt fwdTableLast;
_iss usqLong gcStartUsecs;
_iss sqInt newFinalization;
_iss sqInt pendingFinalizationSignals;
_iss sqInt statCompMoveCount;
_iss sqInt statFullGCs;
_iss usqLong statIOProcessEvents;
_iss sqInt statIncrGCs;
_iss sqInt statMkFwdCount;
_iss sqInt tenuringThreshold;
_iss sqInt edenBytes;
_iss sqInt forceTenureFlag;
_iss sqInt imageHeaderFlags;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt signalLowSpace;
_iss usqLong statFullGCUsecs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statRootTableOverflows;
_iss sqInt statSpecialMarkCount;
_iss sqInt statTenures;
_iss sqInt totalObjectCount;
_iss sqInt fullScreenFlag;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqLong nextPollUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIdleUsecs;
_iss sqInt statPendingFinalizationSignals;
_iss usqLong statProcessSwitch;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt gcSemaphoreIndex;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt savedWindowSize;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statNumMaps;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statRootTableCount;
_iss sqInt statSurvivorCount;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt fullGCLock;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss usqInt byteCount;
_iss sqInt extA;
_iss sqInt extB;
_iss sqInt interruptCheckCounter;
_iss sqInt lastHash;
_iss sqInt lowcodeCalloutState;
_iss char * nativeFramePointer;
_iss char * nativeSP;
_iss char * nativeStackPointer;
_iss sqInt nsMethodCache;
_iss sqInt numExtB;
_iss char * shadowCallStack;
_iss sqInt shadowCallStackPointer;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt debugCallbackPath;
sqInt checkAllocFiller;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
sqInt checkForLeaks;
sqInt breakSelectorLength = MinSmallInteger;
sqInt inIOProcessEvents;
void * showSurfaceFn;
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
char * breakSelector;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
static int (*sHEAFn)() = 0;
static const sqInt headerTypeBytes[] = {
		8, 4, 0, 0
	};
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ (void (*)(void))0,
	/* 246 */ (void (*)(void))0,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
sqInt checkedPluginName;
char expensiveAsserts = 0;
const char *interpreterVersion = "Croquet Closure Stack VM [StackInterpreterPrimitives VMMaker.oscog-eem.2207]";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define classFieldOffset() (0 - BaseHeaderSize)
#define compactClassFieldWidth() 5
#define freeStart() GIV(freeStart)
#define instFormatFieldLSB() 8
#define instFormatFieldWidth() 4
#define youngStart() GIV(youngStart)
#define compactClassFieldLSB() 12
#define firstByteFormat() 8
#define firstCompiledMethodFormat() 12
#define firstLongFormat() 6
#define indexablePointersFormat() 3
#define isForwarded(oop) false
#define memory() GIV(memory)
#define remapBufferCount() GIV(remapBufferCount)
#define shiftForWord() 2
#define startOfMemory() GIV(memory)
#define weakArrayFormat() 4
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define checkAllocFiller() GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define printFloat(f) printf("%g", f)
#define remoteIsInstVarAccess() 128
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	register sqInt currentBytecode CB_REG;
    sqInt lkupClassTag;
	register char* localFP FP_REG;
	register char* localIP IP_REG;
    sqInt localReturnValue;
	register char* localSP SP_REG;
    sqInt stackPageBytes;
    usqIntptr_t stackPagesBytes;
    void *theStackMemory;
    JUMP_TABLE;

#if MULTIPLEBYTECODESETS
	if(!asserta((sizeof(jumpTable)/sizeof(jumpTable[0])) >= 512))
		error("bytecode jumpTable too small");
#endif

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		loadInitialContext();
		ioInitHeartbeat();
		interpret();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	/* begin fetchByte */
	currentBytecode = byteAtPointer(++localIP);

	/* begin initExtensions */
	GIV(extA) = (GIV(numExtB) = (GIV(extB) = 0));

	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		CASE(0)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(1)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 4 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(2)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(3)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 12 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(4)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(5)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 20 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(6)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(7)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 28 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(8)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(9)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 36 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(10)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(11)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 44 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(12)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(13)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 52 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(14)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(15)
			/* pushReceiverVariableBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushReceiverVariable: */
				object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 60 /* (currentBytecode bitAnd: 15) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(16)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(17)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(18)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(19)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(20)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(21)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(22)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(23)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(24)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(25)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(26)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(27)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(28)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(29)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(30)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(31)
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushTemporaryVariable: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(32)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(33)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(34)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(35)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(36)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(37)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(38)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(39)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(40)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(41)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(42)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(43)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(44)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(45)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(46)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(47)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(48)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(49)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(50)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(51)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(52)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(53)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(54)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(55)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(56)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(57)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(58)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(59)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(60)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(61)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(62)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(63)
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralConstant: */
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);

				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(64)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(65)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 1 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(66)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 2 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(67)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 3 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(68)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 4 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(69)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 5 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(70)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 6 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(71)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 7 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(72)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 8 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(73)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 9 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(74)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 10 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(75)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 11 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(76)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 12 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(77)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 13 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(78)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 14 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(79)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 15 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(80)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 16 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(81)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 17 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(82)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 18 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(83)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 19 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(84)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 20 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(85)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 21 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(86)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 22 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(87)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 23 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(88)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 24 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(89)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 25 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(90)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 26 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(91)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 27 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(92)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 28 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(93)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 29 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(94)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 30 /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(95)
			/* pushLiteralVariableBytecode */
			{
				sqInt literalIndex;
				sqInt object1;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushLiteralVariable: */
				literalIndex = 0x1F /* currentBytecode bitAnd: 31 */;
				/* begin internalPush: */
				object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((literalIndex + LiteralStart)) << 2)))))) + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object1);

			}
			BREAK;
		CASE(96)
		CASE(97)
		CASE(98)
		CASE(99)
		CASE(100)
		CASE(101)
		CASE(102)
		CASE(103)
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				/* begin receiver */
				rcvr = longAt(localFP + FoxReceiver);
				/* begin internalStackTop */
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord())))), top);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			BREAK;
		CASE(104)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(105)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(106)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(107)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(108)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(109)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(110)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(111)
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin temporary:in:put: */
				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(112)
			/* pushReceiverBytecode */
			{
				sqInt object;

				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAt(localFP + FoxReceiver);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(113)
			/* pushConstantTrueBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(trueObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(114)
			/* pushConstantFalseBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(falseObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(115)
			/* pushConstantNilBytecode */
			{
				sqInt object;

				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = GIV(nilObj);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(116)
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			BREAK;
		CASE(117)
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			BREAK;
		CASE(118)
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			BREAK;
		CASE(119)
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			BREAK;
		CASE(120)
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				/* begin receiver */
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt primBits;
				sqInt primBits1;
				sqInt senderContext;
				sqInt senderOop;
				sqInt senderOop1;
				sqInt senderOop2;
				char *theFP;
				char *theFP1;
				char *theFP2;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethod1;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = 0;
				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l371;
				}
				closure = longAt(localFP + (frameStackedReceiverOffset(localFP)));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */
				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
					closure = longAt((home + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */

				/* Since nothing changes we don't need to internalize. */
				onSamePage = ((((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 && (!(isWidowedContext(home))))
				 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage))) == (pageIndexFor(frameOfMarriedContext(home))));
				theFP2 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP2 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l380;
					}
					if (!((byteAt((theFP2 + FoxFrameFlags) + 3)) != 0)) {
						theMethod1 = longAt(theFP2 + FoxMethod);
						if ((((primBits = (((assert(isCompiledMethod(theMethod1)),
longAt((theMethod1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
						(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == 198) {
							if (theFP2 == theFPAbove) {
								theSP = findSPOfon(theFP2, stackPageFor(theFP2));
							}
							else {
								assert(!(isBaseFrame(theFPAbove)));
								theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;

							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(theFP2)));
								ctxtOrNilOrZero = longAt(theFP2 + FoxThisContext);
								goto l380;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP2, theSP);
							goto l380;
						}
					}
					theFPAbove = theFP2;
					theFP2 = pointerForOop(longAt(theFP2 + FoxSavedFP));
				} while(theFP2 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(((senderContext & 1) == 0)
					 && (((((usqInt) (longAt(senderContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
					/* begin nilObject */
					ctxtOrNilOrZero = GIV(nilObj);
					goto l380;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, home);
			l380:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
					if ((((primBits1 = (((assert(isCompiledMethod(theMethod)),
longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
					(primBits1 & 0x1FF) + ((((usqInt) primBits1) >> 19) & 512))) == 198) {
						unwindContextOrNilOrZero = home;
						goto l391;
					}
					unwindContextOrNilOrZero = 0;
					goto l391;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home)) == GIV(nilObj)) {
						/* begin nilObject */
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l391;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l391:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l372;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l372:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
					GIV(argumentCount) = 1;
					goto normalSend;
					/* return self */
					goto l371;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l383;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l383:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					/* begin splObj: */
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorAboutToReturn) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					/* return self */
					goto l371;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);

					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					if ((((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop1 & 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);

						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(((contextToReturnTo & 1) == 0)
						 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l390;
					}
					if (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */
							frameToReturnTo = 0;
							goto l390;
						}
						/* begin frameOfMarriedContext: */
						senderOop2 = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop2 & 1));
						frameToReturnTo = pointerForOop(senderOop2 - 1);

						goto l390;
					}
					if (!(((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))) {
						frameToReturnTo = 0;
						goto l390;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
				l390:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l375;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l375:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						/* begin splObj: */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						/* return self */
						goto l371;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
							/* begin stackPageFor: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							currentCtx = longAt(theFP1 + FoxCallerContext);
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
							/* begin storePointerUnchecked:ofObject:withValue: */
							valuePointer1 = GIV(nilObj);
							longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((assert(!(isBaseFrame(callerFP))),
(callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord)) - BytesPerWord;
				}
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l371:	/* end case */;
			BREAK;
		CASE(121)
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				/* begin trueObject */
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			BREAK;
		CASE(122)
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				/* begin falseObject */
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			BREAK;
		CASE(123)
			/* returnNil */
			{
				VM_LABEL(returnNil);
				/* begin nilObject */
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			BREAK;
		CASE(124)
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			BREAK;
		CASE(125)
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				/* begin internalStackTop */
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				
				/* TODO: Store/restore the nativeSP more properly, when it exists */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = ((contextToReturnTo & 1) == 0)
					 && (((((usqInt) (longAt(contextToReturnTo))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						theFP = pointerForOop(senderOop - 1);

						/* begin stackPageFor: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l403;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l403;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l403:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1)))) {
							/* begin internalCannotReturn: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l404;
							}
							ourContext = marryFrameSP(localFP, localSP);
						l404:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							/* begin splObj: */
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l400;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* return self */
				l400:	/* end baseFrameReturn */;
					goto l396;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord())))));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				longAtPointerput(localSP, localReturnValue);
			}
		l396:	/* end case */;
			BREAK;
		CASE(126)
		CASE(127)
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (lengthOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorUnknownBytecode) << (shiftForWord())))))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l406;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l406:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			BREAK;
		CASE(128)
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object2;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					object = longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l32;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l32;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object2 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object2);
					goto l32;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object11 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object11);

					goto l32;
				}
			}
		l32:	/* end case */;
			BREAK;
		CASE(129)
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l39;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l39;
				}
				error("illegal store");
			l39:	/* end extendedStoreBytecodePop: */;
			}
			BREAK;
		CASE(130)
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;

				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				if (variableType == 1) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					goto l46;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), value);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l46;
				}
				error("illegal store");
			l46:	/* end extendedStoreBytecodePop: */;
			}
			BREAK;
		CASE(131)
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(normalSend);
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt aValue;
					sqInt errorCode;
					sqInt hash1;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt numTemps;
					sqInt object;
					sqInt probe1;
					sqInt rcvr;
					sqInt succeeded;
					sqInt table;

					VM_LABEL(commonSendOrdinary);
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
					/* begin internalFindNewMethodOrdinary */
					hash1 = GIV(messageSelector) ^ lkupClassTag;

					/* first probe */
					probe1 = hash1 & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l418;
					}

					/* second probe */
					probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l418;
					}
					probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l418;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin classForClassTag: */
					GIV(lkupClass) = lkupClassTag;
					lookupMethodInClass(GIV(lkupClass));

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				l418:	;
				l421:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								aValue = longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));
								longAtPointerput(localSP, aValue);
								goto l425;
							}
							if (localPrimIndex == 256) {
								goto l425;
							}
							if (localPrimIndex == 257) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l425;
							}
							if (localPrimIndex == 258) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l425;
							}
							if (localPrimIndex == 259) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l425;
							}
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 1) | 1));
							goto l425;
						}
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
						/* begin maybeRetryPrimitiveOnFailure */
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller) {
							if (((freeStart()) < GIV(scavengeThreshold))
							 && ((longAt(freeStart())) != (freeStart()))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						/* begin successful */
						succeeded = !GIV(primFailCode);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l425;
						}
					}
					/* begin internalActivateNewMethod */
					assert(isCompiledMethod(GIV(newMethod)));
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

					numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

					/* could new rcvr be set at point of send? */
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr)));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					/* begin setMethod:methodHeader: */
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert((methodHeaderOf(GIV(method))) == methodHeader);
					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
						: ((1 + (((sqInt)((usqInt)(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15)) << 8)))) + (0)) + (0));
					longAtPointerput((localSP -= BytesPerOop), object);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if (methodHeader & V3PrimitiveBitsMask) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
						localIP += 0;
						if (GIV(primFailCode) != 0) {
							if ((byteAt(localIP + 1)) == (LongStoreBytecode)) {
								/* begin getErrorObjectFromPrimFailCode */
								if (GIV(primFailCode) > 0) {
									/* begin splObj: */
									table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
									if (GIV(primFailCode) <= (numSlotsOf(table))) {
										errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
										goto l419;
									}
								}
								errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
							l419:	/* end getErrorObjectFromPrimFailCode */;
								longAtPointerput(localSP, errorCode);
							}
							GIV(primFailCode) = 0;
						}
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
											}
				l425:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
			}
			BREAK;
		CASE(132)
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt index1;
				sqInt litVar1;
				sqInt obj;
				sqInt obj1;
				sqInt object;
				sqInt object1;
				sqInt object11;
				sqInt object3;
				int onCurrentPage;
				sqInt opType;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char * theFP;
				StackPage * thePage;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l55;
				}
				if (opType == 1) {
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin literal:ofMethod: */
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l55;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushMaybeContextReceiverVariable: */
					obj = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj));
						if (!(((longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l58;
						}
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(obj)) {
							object3 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l58;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						spouseFP = pointerForOop(senderOop - 1);

						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								object3 = longAt(spouseFP + FoxCallerContext);
								goto l58;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP)));
								object3 = longAt(callerFP + FoxThisContext);
								goto l58;
							}
							object3 = marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP))),
							(spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord));
							goto l58;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
							object3 = (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l58;
						}
						if (byte3 == InstructionPointerIndex) {
							object3 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l58;
						}
						error("bad index");
						object3 = 0;
					l58:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object3);
					}
					else {
						/* begin internalPush: */
						object11 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
						longAtPointerput((localSP -= BytesPerOop), object11);
					}
					goto l55;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralConstant: */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					longAtPointerput((localSP -= BytesPerOop), object);
					goto l55;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					/* begin pushLiteralVariable: */
					/* begin internalPush: */
					object1 = longAt((((assert(GIV(method) == (iframeMethod(localFP))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord()))))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), object1);

					goto l55;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */

					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */
					assert(GIV(method) == (iframeMethod(localFP)));
					/* begin fetchPointer:ofObject: */
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(litVar1, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar1, top);
					}
					longAtput((litVar1 + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))), top);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l55;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj1 = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((((usqInt) (longAt(obj1))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
				 && ((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 || (0)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj1));
					assert(!((isObjImmutable(obj1))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && (!(isWidowedContext(obj1))))) {
						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(obj1, GIV(youngStart))) {
							possibleRootStoreIntovalue(obj1, top);
						}
						longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
						if (byte3 == StackPointerIndex) {
						}
						goto l70;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((obj1 + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop1 & 1));
					theFP = pointerForOop(senderOop1 - 1);

					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l70;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj1);
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
					if (byte3 == StackPointerIndex) {
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l70:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj1, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj1, top);
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
				}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
		l55:	/* end case */;
			BREAK;
		CASE(133)
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt literal;
				sqInt offset;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				offset = ((assert((((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(GIV(method))),
/* begin fetchPointer:ofObject: */
longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(GIV(method))),
			/* begin fetchPointer:ofObject: */
			longAt((GIV(method) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
				literal = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				if ((literal != GIV(nilObj))
				 && (((literal & 1) == 0)
				 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))) {

					/* filters out fullBlock last literal */
					assert((numSlotsOf(literal)) > ValueIndex);
					classPointer = longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
				}
				else {
					/* begin nilObject */
					classPointer = GIV(nilObj);
				}
				superclass = longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
				/* begin classTagForClass: */
				lkupClassTag = superclass;
				/* begin ensureReceiverUnforwarded */
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(134)
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				/* begin fetchByte */
				descriptor = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x3F) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			BREAK;
		CASE(135)
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(136)
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(137)
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l83;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l83:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			BREAK;
		CASE(138)
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				int popValues;
				sqInt size;
				sqInt valuePointer;
				sqInt valuePointer1;

				VM_LABEL(pushNewArrayBytecode);
				/* begin fetchByte */
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				array = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, 2, size);

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((size - i) - 1) * BytesPerOop));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer1 = GIV(nilObj);
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer1);
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			BREAK;
		CASE(139)
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			BREAK;
		CASE(140)
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				object = longAt((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(141)
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				/* begin fetchByte */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
			}
			BREAK;
		CASE(142)
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				/* begin fetchByte */
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(143)
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt newClosure;
				sqInt newClosure1;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;
				sqInt valuePointer;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				/* begin fetchByte */
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l107;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l107:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				newClosure1 = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer = longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), valuePointer);
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			BREAK;
		CASE(144)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(145)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(146)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(147)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(148)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(149)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(150)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(151)
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);

			}
			BREAK;
		CASE(152)
		CASE(153)
		CASE(154)
		CASE(155)
		CASE(156)
		CASE(157)
		CASE(158)
		CASE(159)
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l110;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l110:	/* end jumplfFalseBy: */;
			}
			BREAK;
		CASE(160)
		CASE(161)
		CASE(162)
		CASE(163)
		CASE(164)
		CASE(165)
		CASE(166)
		CASE(167)
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
									}
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			BREAK;
		CASE(168)
		CASE(169)
		CASE(170)
		CASE(171)
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l115;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l115:	/* end jumplfTrueBy: */;
			}
			BREAK;
		CASE(172)
		CASE(173)
		CASE(174)
		CASE(175)
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				/* begin internalStackTop */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l119;
					}
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l119:	/* end jumplfFalseBy: */;
			}
			BREAK;
		CASE(176)
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l121;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l122;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l125;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l125;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l125;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l125:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l122;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l122:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l126;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l129;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l129;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l129;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l129:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l126;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l126:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l121;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l121:	/* end case */;
			BREAK;
		CASE(177)
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l131;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l132;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l135;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l135;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l135;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l135:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l132;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l132:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l136;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l139;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l139;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l139;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l139:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l136;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l136:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l131;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((1 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l131:	/* end case */;
			BREAK;
		CASE(178)
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l141;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l144;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l149;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l149;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l149;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l149:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l144;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l144:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l147;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l143;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l143;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l143;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l143:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l147;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l147:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l141;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((2 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l141:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l432;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l432;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = (((sqInt)((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);

						goto l432;
					}
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l432:	/* end case */;
			BREAK;
		CASE(179)
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l150;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l153;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l158;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l158;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l158;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l158:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l153;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l153:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l156;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l152;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l152;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l152;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l152:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l156;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l156:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l150;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((3 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l150:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l435;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);

					goto l435;
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l435:	/* end case */;
			BREAK;
		CASE(180)
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l159;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l162;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l167;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l167;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l167;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l167:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l162;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l162:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l165;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l161;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l161;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l161;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l161:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l165;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l165:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l159;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((4 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l159:	/* end case */;
			BREAK;
		CASE(181)
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l168;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l171;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l176;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l176;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l176;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l176:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l171;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l171:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l174;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l170;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l170;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l170;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l170:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l174;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l174:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l168;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((5 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l168:	/* end case */;
			BREAK;
		CASE(182)
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l177;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l180;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l185;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l185;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l185;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l185:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l180;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l180:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l183;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l179;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l179;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l179;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l179:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l183;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l183:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l177;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((6 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l177:	/* end case */;
			BREAK;
		CASE(183)
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l186;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l189;
				}
				/* begin floatValueOf: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isFloat = 0;
					goto l194;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l194;
				}
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l194;

				isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l194:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l189;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l189:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l192;
				}
				/* begin floatValueOf: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
				if ((arg & 1)) {
					isFloat1 = 0;
					goto l188;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((arg & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l188;
				}
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l188;

				isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l188:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l192;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l192:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l186;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((7 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l186:	/* end case */;
			BREAK;
		CASE(184)
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt oop1;
				int overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 1) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), oop);
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l195;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l196;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l199;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l199;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l199;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l199:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l196;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l196:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l200;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l203;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l203;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l203;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l203:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l200;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l200:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l195;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((8 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l195:	/* end case */;
			BREAK;
		CASE(185)
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt oop;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */
						result = rcvr / arg;
						if ((((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)result << 1) | 1));
							/* begin fetchNextBytecode */
							/* begin fetchByte */
							currentBytecode = byteAtPointer(++localIP);

							goto l205;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l206;
					}
					/* begin floatValueOf: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l209;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					/* begin compactClassIndexOf: */
					ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex == 0) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l209;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l209;

					isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l209:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
						rcvr1 = result2;
						goto l206;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l206:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l210;
					}
					/* begin floatValueOf: */
					classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat1 = 0;
						goto l213;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					/* begin compactClassIndexOf: */
					ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F;
					if (ccIndex1 == 0) {
						isFloat1 = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop1;
						goto l213;
					}
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l213;

					isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
				l213:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						fetchFloatAtinto(arg + BaseHeaderSize, result1);
						arg1 = result1;
						goto l210;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l210:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l205;
					}
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((9 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l205:	/* end case */;
			BREAK;
		CASE(186)
			/* bytecodePrimMod */
			{
				sqInt mod;
				sqInt oop;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)mod << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l215;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((10 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l215:	/* end case */;
			BREAK;
		CASE(187)
			/* bytecodePrimMakePoint */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimMakePoint);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveMakePoint();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l218;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((11 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l218:	/* end case */;
			BREAK;
		CASE(188)
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt newLargeInteger;
				sqInt oop;
				sqInt shifted;
				char *sp;
				sqInt valueWord1;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l222;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = positive32BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 1))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 0x1F)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l222;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l222;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-0x1F))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l222;
						}
						shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
					}
					/* begin positive32BitIntegerFor: */
					/* begin maybeInlinePositive32BitIntegerFor: */
					assert(!((hasSixtyFourBitImmediates())));
					if ((((unsigned int) shifted)) <= (MaxSmallInteger)) {
						shifted = (((usqInt)shifted << 1) | 1);
						goto l227;
					}
					newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
					/* begin storeLong32:ofObject:withValue: */
					valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(shifted);
					long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

					shifted = newLargeInteger;
					goto l227;

				l227:	/* end positive32BitIntegerFor: */;

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l222:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l221;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((12 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l221:	/* end case */;
			BREAK;
		CASE(189)
			/* bytecodePrimDiv */
			{
				sqInt oop;
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), (((usqInt)quotient << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l229;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((13 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l229:	/* end case */;
			BREAK;
		CASE(190)
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l232;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l232;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((14 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l232:	/* end case */;
			BREAK;
		CASE(191)
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l236;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l236;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((15 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l236:	/* end case */;
			BREAK;
		CASE(192)
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt class;
				sqInt classFormat;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqInt hdr;
				sqInt hdr1;
				sqInt index;
				sqInt index1;
				sqInt newLargeInteger;
				sqInt oop;
				sqInt oop1;
				sqInt oop11;
				sqInt oop13;
				sqInt oop2;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				usqInt result1;
				sqInt stSize;
				sqInt sz1;
				sqInt sz2;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valueWord1;

				VM_LABEL(bytecodePrimAt);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & 1) == 0)
				 && ((index & 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
							lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
						}
						else {
							/* begin fetchPointer:ofObject: */
							lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
						}
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
						GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((16 * 2)) << (shiftForWord())))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l240;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							/* begin baseHeader: */
							hdr = longAt(rcvr);
							/* begin formatOfHeader: */
							fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
							if ((fmt == (indexablePointersFormat()))
							 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l255;
							}
							/* begin lengthOf:baseHeader:format: */
							if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
								sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
							}
							else {
								sz1 = hdr & SizeMask;
							}
							sz1 -= hdr & Size4Bit;
							if (fmt <= 4) {
								totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
								goto l256;
							}
							totalLength = (fmt < (firstByteFormat())
								? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
								: (sz1 - BaseHeaderSize) - (fmt & 3));
						l256:	/* end lengthOf:baseHeader:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 4)
							 || (fmt == 2)) {
								fixedFields = 0;
								goto l248;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l248;
							}
							if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
								class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
							}
							else {
								/* begin fetchPointer:ofObject: */
								oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
								class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
							}
							classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
							fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
						l248:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
						l255:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								/* begin baseHeader: */
								hdr1 = longAt(rcvr);
								/* begin formatOfHeader: */
								fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
								/* begin lengthOf:baseHeader:format: */
								if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
									sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
								}
								else {
									sz2 = hdr1 & SizeMask;
								}
								sz2 -= hdr1 & Size4Bit;
								if (fmt1 <= 4) {
									totalLength1 = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
									goto l264;
								}
								totalLength1 = (fmt1 < (firstByteFormat())
									? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
									: (sz2 - BaseHeaderSize) - (fmt1 & 3));
							l264:	/* end lengthOf:baseHeader:format: */;
								fixedFields1 = 0;

								/* special flag for strings */
								fmt1 += 16;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
							l250:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l240;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 1);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord())))));
								goto l247;
							}
							if (fmt2 < (firstByteFormat())) {

								/* 64, 32, & 16 bits */
								/* begin fetchLong32:ofObject: */
								result1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))))));
								/* begin positive32BitIntegerFor: */
								/* begin maybeInlinePositive32BitIntegerFor: */
								assert(!((hasSixtyFourBitImmediates())));
								if ((((unsigned int) result1)) <= (MaxSmallInteger)) {
									result = ((result1 << 1) | 1);
									goto l247;
								}
								newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
								/* begin storeLong32:ofObject:withValue: */
								valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(result1);
								long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

								result = newLargeInteger;
								goto l247;

							}
							if (fmt2 >= 16) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString and DoubleByteString */
								/* begin fetchByte:ofObject: */
								result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));

								if (CharacterTable == null) {
									if (((result1 >= 0) && (result1 <= 0xFF))) {
										/* begin fetchPointer:ofObject: */
										oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
										result = longAt((oop2 + BaseHeaderSize) + (result1 << (shiftForWord())));
									}
									else {
										result = GIV(nilObj);
									}
								}
								else {
									/* begin fetchPointer:ofObject: */
									oop13 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
									result = longAt((oop13 + BaseHeaderSize) + (result1 << (shiftForWord())));
								}
								goto l247;
							}
							else {
								if ((fmt2 < (firstCompiledMethodFormat()))
								 || (index1 >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 1) | 1);
									goto l247;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) >= 2
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l247:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l240;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((16 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l240:	/* end case */;
			BREAK;
		CASE(193)
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt ccIndex3;
				sqInt class;
				sqInt classFormat;
				sqInt classOop;
				sqInt correctRcvr;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqInt hdr;
				sqInt hdr1;
				sqInt index;
				sqInt index1;
				sqInt isCharacter;
				sqInt oop;
				sqInt oop1;
				sqInt oop11;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt sz1;
				sqInt sz2;
				sqInt totalLength;
				sqInt totalLength1;
				int valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				
#        if IMMUTABILITY
				/* begin isOopMutable: */
				correctRcvr = (!((rcvr & 1)))
				 && (!(((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0));

#        else /* IMMUTABILITY */
				/* begin isNonImmediate: */
				correctRcvr = (rcvr & 1) == 0;

#        endif /* IMMUTABILITY */

				if (correctRcvr
				 && ((index & 1))) {

					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
							lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
						}
						else {
							/* begin fetchPointer:ofObject: */
							lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
						}
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
						GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((17 * 2)) << (shiftForWord())))));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l270;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							/* begin baseHeader: */
							hdr = longAt(rcvr);
							/* begin formatOfHeader: */
							fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
							if ((fmt == (indexablePointersFormat()))
							 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l299;
							}
							/* begin lengthOf:baseHeader:format: */
							if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
								sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
							}
							else {
								sz1 = hdr & SizeMask;
							}
							sz1 -= hdr & Size4Bit;
							if (fmt <= 4) {
								totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
								goto l287;
							}
							totalLength = (fmt < (firstByteFormat())
								? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
								: (sz1 - BaseHeaderSize) - (fmt & 3));
						l287:	/* end lengthOf:baseHeader:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 4)
							 || (fmt == 2)) {
								fixedFields = 0;
								goto l292;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l292;
							}
							if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
								class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
							}
							else {
								/* begin fetchPointer:ofObject: */
								oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
								class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
							}
							classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
							fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
						l292:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
						l299:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								/* begin baseHeader: */
								hdr1 = longAt(rcvr);
								/* begin formatOfHeader: */
								fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
								/* begin lengthOf:baseHeader:format: */
								if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
									sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
								}
								else {
									sz2 = hdr1 & SizeMask;
								}
								sz2 -= hdr1 & Size4Bit;
								if (fmt1 <= 4) {
									totalLength1 = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
									goto l307;
								}
								totalLength1 = (fmt1 < (firstByteFormat())
									? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
									: (sz2 - BaseHeaderSize) - (fmt1 & 3));
							l307:	/* end lengthOf:baseHeader:format: */;
								fixedFields1 = 0;

								/* special flag for strings */
								fmt1 += 16;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
							l301:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l270;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						index1 = (index >> 1);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								if (oopisLessThan(rcvr, GIV(youngStart))) {
									possibleRootStoreIntovalue(rcvr, value);
								}
								longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index1 + fixedFields2) - 1)) << (shiftForWord())))), value);
								goto l283;
							}
							if (fmt2 < (firstByteFormat())) {

								/* 64, 32, & 16 bits */
								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									/* begin storeLong32:ofObject:withValue: */
									long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index1 - 1)) << 2))), valToPut);
									goto l283;
								}
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l283;
							}
							if (fmt2 >= 16) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* begin is:instanceOf:compactClassIndex: */
								classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassCharacter) << (shiftForWord())))));
								if ((value & 1)) {
									isCharacter = 0;
									goto l289;
								}
								/* begin isClassOfNonImm:equalTo:compactClassIndex: */
								assert(!((value & 1)));
								/* begin compactClassIndexOf: */
								ccIndex3 = (((usqInt) (longAt(value))) >> (compactClassFieldLSB())) & 0x1F;
								if (ccIndex3 == 0) {
									isCharacter = ((longAt(value - BaseHeaderSize)) & AllButTypeMask) == classOop;
									goto l289;
								}
								isCharacter = classOop == (fetchPointerofObject(ccIndex3 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
							l289:	/* end is:instanceOf:compactClassIndex: */;
								if (!isCharacter) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l283;
								}
								valToPut = longAt((value + BaseHeaderSize) + (((int)((usqInt)(CharacterValueIndex) << (shiftForWord())))));
								valToPut = ((valToPut & 1)
									? (valToPut >> 1)
									: -1);

															}
							else {
								if ((fmt2 >= (firstCompiledMethodFormat()))
								 && (index1 < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									/* begin primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadIndex;
									goto l283;
								}
								valToPut = ((value & 1)
									? (value >> 1)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								/* begin primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l283;
							}
							/* begin storeByte:ofObject:withValue: */
							byteAtput((rcvr + BaseHeaderSize) + (index1 - 1), valToPut);
							goto l283;
						}
						/* begin primitiveFailFor: */
						reasonCode = (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) >= 2
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
						/* return self */
					l283:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l270;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)((17 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l270:	/* end case */;
			BREAK;
		CASE(194)
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt classOop;
				sqInt classOop1;
				sqInt fmt;
				sqInt fmt1;
				sqInt header;
				sqInt header1;
				sqInt isArray;
				sqInt isString;
				sqInt oop;
				sqInt rcvr;
				sqInt sz;
				sqInt sz1;
				sqInt sz2;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isString = 0;
					goto l315;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isString = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l315;
				}
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l315;

				isString = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l315:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf: */
					header = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz1 = header & SizeMask;
					}
					sz1 -= header & Size4Bit;
					if (fmt <= 4) {
						sz = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
						goto l317;
					}
					sz = (fmt < (firstByteFormat())
						? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
						: (sz1 - BaseHeaderSize) - (fmt & 3));
				l317:	/* end lengthOf: */;
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l313;
				}
				/* begin is:instanceOf:compactClassIndex: */
				classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isArray = 0;
					goto l318;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex1 == 0) {
					isArray = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop1;
					goto l318;
				}
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l318;

				isArray = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l318:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf: */
					header1 = longAt(rcvr);
					/* begin lengthOf:baseHeader:format: */
					fmt1 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
					if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
						sz2 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz2 = header1 & SizeMask;
					}
					sz2 -= header1 & Size4Bit;
					if (fmt1 <= 4) {
						sz = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
						goto l320;
					}
					sz = (fmt1 < (firstByteFormat())
						? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
						: (sz2 - BaseHeaderSize) - (fmt1 & 3));
				l320:	/* end lengthOf: */;
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l313;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((18 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l313:	/* end case */;
			BREAK;
		CASE(195)
			/* bytecodePrimNext */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNext);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((19 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((19 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(196)
			/* bytecodePrimNextPut */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNextPut);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((20 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((20 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(197)
			/* bytecodePrimAtEnd */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimAtEnd);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((21 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((21 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(198)
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			BREAK;
		CASE(199)
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt ccIndex;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				/* begin internalStackTopPut: */
				if ((rcvr & 1)) {
					/* begin fetchPointer:ofObject: */
					aValue = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						aValue = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						aValue = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				/* begin fetchByte */
				currentBytecode = byteAtPointer(++localIP);

			}
			BREAK;
		CASE(200)
			/* bytecodePrimNotIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin booleanCheat: */
				if (rcvr != arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			BREAK;
		CASE(201)
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l333;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l333;
				}
				isBlock = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l333:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l332;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((25 * 2)) << (shiftForWord())))));
				goto normalSend;
			}
		l332:	/* end case */;
			BREAK;
		CASE(202)
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt oop;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l338;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				/* begin compactClassIndexOf: */
				ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F;
				if (ccIndex == 0) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l338;
				}
				isBlock = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
			l338:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						/* begin fetchByte */
						currentBytecode = byteAtPointer(++localIP);

						goto l337;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((26 * 2)) << (shiftForWord())))));
				goto normalSend;
			}
		l337:	/* end case */;
			BREAK;
		CASE(203)
			/* bytecodePrimDo */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimDo);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((27 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject((27 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			BREAK;
		CASE(204)
			/* bytecodePrimNew */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNew);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((28 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			BREAK;
		CASE(205)
			/* bytecodePrimNewWithArg */
			{
				sqInt oop;

				VM_LABEL(bytecodePrimNewWithArg);
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((29 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			BREAK;
		CASE(206)
			/* bytecodePrimPointX */
			{
				sqInt ccIndex;
				sqInt cl;
				sqInt ok;
				sqInt oop;
				sqInt oop1;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & 1) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord()))))));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l345;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((30 * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l345:	/* end case */;
			BREAK;
		CASE(207)
			/* bytecodePrimPointY */
			{
				sqInt ccIndex;
				sqInt cl;
				sqInt ok;
				sqInt oop;
				sqInt oop1;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & 1) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						cl = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord()))))));
					/* begin fetchNextBytecode */
					/* begin fetchByte */
					currentBytecode = byteAtPointer(++localIP);

					goto l352;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))));
				GIV(messageSelector) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)((0x1F * 2)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l352:	/* end case */;
			BREAK;
		CASE(208)
		CASE(209)
		CASE(210)
		CASE(211)
		CASE(212)
		CASE(213)
		CASE(214)
		CASE(215)
		CASE(216)
		CASE(217)
		CASE(218)
		CASE(219)
		CASE(220)
		CASE(221)
		CASE(222)
		CASE(223)
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 0;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(224)
		CASE(225)
		CASE(226)
		CASE(227)
		CASE(228)
		CASE(229)
		CASE(230)
		CASE(231)
		CASE(232)
		CASE(233)
		CASE(234)
		CASE(235)
		CASE(236)
		CASE(237)
		CASE(238)
		CASE(239)
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 1;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(240)
		CASE(241)
		CASE(242)
		CASE(243)
		CASE(244)
		CASE(245)
		CASE(246)
		CASE(247)
		CASE(248)
		CASE(249)
		CASE(250)
		CASE(251)
		CASE(252)
		CASE(253)
		CASE(254)
		CASE(255)
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				assert(GIV(method) == (iframeMethod(localFP)));
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));

				GIV(argumentCount) = 2;
				/* begin internalStackValue: */
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				if ((rcvr & 1)) {
					/* begin splObj: */
					lkupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						lkupClassTag = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						lkupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		}
	}

	/* undo the pre-increment of IP before returning */
	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static sqInt NoDbgRegParms
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static sqInt NoDbgRegParms
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static void NoDbgRegParms
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static sqInt NoDbgRegParms
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
	return 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static StackPage * NoDbgRegParms
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static StackPage * NoDbgRegParms
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
	return stackPageAtpages(index, GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps);
}

	/* InterpreterPrimitives>>#canBeImmutable: */
#if IMMUTABILITY
static sqInt NoDbgRegParms
canBeImmutable(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;
    sqInt processLists;
    sqInt scheduler;

	assert(isNonImmediate(oop));
	if (((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		return 0;
	}
	if (isEphemeron(oop)) {
		return 0;
	}
	if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
		return 0;
	}
	if (((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	processLists = longAt((scheduler + BaseHeaderSize) + (((int)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	if (oop == scheduler) {
		return 0;
	}
	if (oop == processLists) {
		return 0;
	}
	if ((classIndexOf(longAt((processLists + BaseHeaderSize) + (1U << (shiftForWord()))))) == (classIndexOf(oop))) {
		return 0;
	}
	if ((classIndexOf(longAt((scheduler + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord()))))))) == (classIndexOf(oop))) {
		return 0;
	}
	return 1;
}
#endif /* IMMUTABILITY */


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    char *cString;
    sqInt fmt;
    sqInt header;
    sqInt isString;
    sqInt len;
    sqInt sz;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord())))));
	if ((oop & 1)) {
		isString = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isString = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;

	isString = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (fmt <= 4) {
		len = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l4;
	}
	len = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l4:	/* end lengthOf: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static sqInt NoDbgRegParms
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt ok;
    sqInt smallInt;

	if ((oop & 1)) {
		smallInt = (oop >> 1);
		return smallInt < 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 1;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static sqInt NoDbgRegParms
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    int isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;
    sqLong value1;

	isSmall = (isNegative
		? magnitude <= ((MaxSmallInteger) + 1)
		: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return (((usqInt)smallVal << 1) | 1);
	}
	if (isNegative) {
		/* begin splObj: */
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
	}
	else {
		/* begin splObj: */
		largeClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	}
	if (((highWord = magnitude >> 32)) == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
			if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
				sz += 1;
				if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
					sz += 1;
				}
			}
		}
	}

	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	if (sz > 4) {
		/* begin storeLong64:ofObject:withValue: */
		value1 = SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), value1);
		long32Atput(((newLargeInteger + BaseHeaderSize) + (0U << 3)) + 4, ((unsigned sqLong)value1) >> 32);
	}
	else {
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude));
	}

	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static usqLong NoDbgRegParms
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
		assert(!((oop & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be a four-byte LargeInteger. */

	/* InterpreterPrimitives>>#noInlineSigned32BitValueGutsOf: */
static int NoDbgRegParms
noInlineSigned32BitValueGutsOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    unsigned int magnitude;
    sqInt negative;
    sqInt ok;
    int value;

	assert(!((hasSixtyFourBitImmediates())));
	assert(!(((oop & 1))));
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
		assert(!((oop & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	if ((numBytesOfBytes(oop)) > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	if ((negative
		? magnitude > 0x80000000U
		: magnitude >= 0x80000000U)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive32BitValueOf: */
unsigned int
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    sqInt sz;
    sqInt value;

	/* begin maybeInlinePositive32BitValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	sz = numBytesOfBytes(oop);
	if (sz > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));


}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		if (((oop >> 1)) < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {

		/* ] */
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
usqIntptr_t
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {
		return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ ((((usqInt)integerResult)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((arg & 1))
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & 1))
	 || (!(objCouldBeClassObj(rcvr)))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt delta1;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt result;
    char *sp;

	result = allInstancesOf(longAt(GIV(stackPointer)));
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = ((((headerTypeBytes[HeaderTypeSizeAndClass]) / BytesPerWord) + 1) + ((result >> 1))) * BytesPerOop;
		/* begin growObjectMemory: */
		delta1 = ((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom));
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), delta1);
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		result = allInstancesOf(longAt(GIV(stackPointer)));
		if ((result & 1)) {
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt delta1;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt result;
    char *sp;

	result = allObjects();
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = ((((headerTypeBytes[HeaderTypeSizeAndClass]) / BytesPerWord) + 1) + ((result >> 1))) * BytesPerOop;
		/* begin growObjectMemory: */
		delta1 = ((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom));
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), delta1);
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		result = allObjects();
		if ((result & 1)) {
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(atan(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's element's identity hash over the argument's elementy's
	identity hash.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHash */
static void
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    sqInt oop;
    sqInt oop1;
    sqInt reasonCode;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((characterCode & 1))
		 && (((characterCode = (characterCode >> 1)),
		((characterCode >= 0) && (characterCode <= 0xFF)))))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		GIV(primFailCode) = reasonCode;
		return;
	}
	if (CharacterTable == null) {
		if (((characterCode >= 0) && (characterCode <= 0xFF))) {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
			characterObject = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(characterCode) << (shiftForWord())))));
		}
		else {
			characterObject = GIV(nilObj);
		}
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
		characterObject = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)(characterCode) << (shiftForWord())))));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((rcvr & 1));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(((double) ((rcvr >> 1)) )));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop11;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt valueWord1;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l14;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (isForwarded(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l14;
	}
	index = (index >> 1);
	/* begin stObject:at: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l13;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l13;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l13;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l13;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		result = newLargeInteger;
		goto l13;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l13:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l14:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex1;
    sqInt class1;
    sqInt classFormat1;
    sqInt fixedFields1;
    sqInt fmt1;
    sqInt hdr1;
    sqInt index;
    sqInt oop11;
    sqInt rcvr;
    sqInt reasonCode1;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp11;
    sqInt sp3;
    sqInt stSize1;
    sqInt sz1;
    sqInt totalLength1;
    unsigned int unsignedValueToStore1;
    sqInt value;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l29;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (isForwarded(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l29;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l29;
	}
	index = (index >> 1);
	/* begin stObject:at:put: */
	hdr1 = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr1 & SizeMask;
	}
	sz1 -= hdr1 & Size4Bit;
	if (fmt1 <= 4) {
		totalLength1 = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l24;
	}
	totalLength1 = (fmt1 < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt1 & 3));
l24:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 > 4)
	 || (fmt1 == 2)) {
		fixedFields1 = 0;
		goto l15;
	}
	if (fmt1 < 2) {
		fixedFields1 = totalLength1;
		goto l15;
	}
	if (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class1 = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class1 = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
	}
	classFormat1 = (longAt((class1 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields1 = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 0x3F)) - 1;
l15:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == (indexablePointersFormat()))
	 && (((((usqInt) hdr1) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp3 >> 1))) < (lengthOf(rcvr)));
			stSize1 = sp3;
			goto l16;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp11 & 1))) {
			stSize1 = 0;
			goto l16;
		}
		assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(rcvr)));
		stSize1 = (sp11 >> 1);
	l16:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize1))
		 && ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l28;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize1))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, value);
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))), value);
			goto l27;
		}
		if (fmt1 >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l27;
			}
			signedValueToStore1 = (value >> 1);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l27;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
			goto l27;
		}
		unsignedValueToStore1 = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
		}
	l27:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode1 = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode1;
	}
l28:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l29:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin success: */
		successBoolean = (((cursorObj & 1) == 0)
		 && (((((usqInt) (longAt(cursorObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(cursorObj)) >= 5);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0U << (shiftForWord())));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4U << (shiftForWord())));
		/* begin success: */
		successBoolean1 = (((offsetObj & 1) == 0)
		 && (((((usqInt) (longAt(offsetObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(offsetObj)) >= 2);
		if (!successBoolean1) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */
			/* begin success: */
			successBoolean2 = (extentX > 0)
			 && (extentY > 0);
			if (!successBoolean2) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!successBoolean3) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean4 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!successBoolean4) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (((bitsObj & 1) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
			 && ((lengthOf(bitsObj)) == (extentX * extentY));
			if (!successBoolean5) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
		else {
			/* begin success: */
			successBoolean6 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean6) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!successBoolean7) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean8 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!successBoolean8) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & 1) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
			 && ((lengthOf(bitsObj)) == 16);
			if (!successBoolean9) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean12 = (((maskObj & 1) == 0)
		 && (((((usqInt) (longAt(maskObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(maskObj)) >= 5);
		if (!successBoolean12) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0U << (shiftForWord())));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean10 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean10) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean11 = (((bitsObj & 1) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
			 && ((lengthOf(bitsObj)) == 16);
			if (!successBoolean11) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(GIV(stackPointer));
	/* begin success: */
	successBoolean = (((rcvr & 1) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) <= 4))
	 && ((lengthOf(rcvr)) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin splObj:put: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), rcvr);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord())))), rcvr);
	}
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(void)
{
	ioBeep();
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hashOrError;
    char *sp;

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	hashOrError = (((usqInt) (longAt(longAt(GIV(stackPointer))))) >> HashBitsOffset) & HashMaskUnshifted;
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)hashOrError << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((oop1 & 1)) {
		value = (oop1 >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop1 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	bs = numBytesOfBytes(oop1);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop1)))));
		goto l3;
	}
	else {
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))))));
		goto l3;
	}
l3:	/* end positiveMachineIntegerValueOf: */;
	/* begin positiveMachineIntegerValueOf: */
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop2 & 1)) {
		value1 = (oop2 >> 1);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l6;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop2 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop2))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok1 = ((longAt(oop2 - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l5;

	ok1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	bs1 = numBytesOfBytes(oop2);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop2)))));
		goto l6;
	}
	else {
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize) + (0U << 2))))))));
		goto l6;
	}
l6:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positiveMachineIntegerFor(integerArgumentValue & integerReceiverValue);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((oop1 & 1)) {
		value = (oop1 >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop1 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	bs = numBytesOfBytes(oop1);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = ((usqIntptr_t) 0);
		goto l3;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop1)))));
		goto l3;
	}
	else {
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))))));
		goto l3;
	}
l3:	/* end positiveMachineIntegerValueOf: */;
	/* begin positiveMachineIntegerValueOf: */
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop2 & 1)) {
		value1 = (oop2 >> 1);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l6;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop2 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop2))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok1 = ((longAt(oop2 - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l5;

	ok1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	bs1 = numBytesOfBytes(oop2);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = ((usqIntptr_t) 0);
		goto l6;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop2)))));
		goto l6;
	}
	else {
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize) + (0U << 2))))))));
		goto l6;
	}
l6:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		oop = positiveMachineIntegerFor(integerArgumentValue | integerReceiverValue);
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt newLargeInteger;
    sqInt shifted;
    char *sp;
    sqInt valueWord1;

	integerArgument = longAt(GIV(stackPointer));
	if (!((integerArgument & 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = positive32BitValueOf(integerReceiver);

	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 1))) >= 0) {

			/* Left shift -- must fail bits would be lost */
			if (!(integerArgument <= 0x1F)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
			if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {

			/* Right shift -- OK to lose bits */
			if (!(integerArgument >= (-0x1F))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
		}
		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) shifted)) <= (MaxSmallInteger)) {
			shifted = (((usqInt)shifted << 1) | 1);
			goto l4;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(shifted);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		shifted = newLargeInteger;
		goto l4;

	l4:	/* end positive32BitIntegerFor: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		shift = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */

		/* This is to avoid undue (usqInt) cast */
		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > (result >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = a >> shift;
		}
		if (aIsNegative
		 && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt integerArgument;
    usqInt integerArgumentValue;
    sqInt integerReceiver;
    usqInt integerReceiverValue;
    sqInt ok;
    sqInt ok1;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt value;
    sqInt value1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerArgument & 1))
	 && ((integerReceiver & 1))) {

		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerArgument ^ integerReceiver) + 1);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin positiveMachineIntegerValueOf: */
		if ((integerArgument & 1)) {
			value = (integerArgument >> 1);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerArgumentValue = ((usqIntptr_t) null);
				goto l3;
			}
			integerArgumentValue = ((usqIntptr_t) value);
			goto l3;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
		assert(!((integerArgument & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(integerArgument))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(integerArgument - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) 0);
			goto l3;
		}
		bs = numBytesOfBytes(integerArgument);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) 0);
			goto l3;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerArgument)))));
			goto l3;
		}
		else {
			integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerArgument + BaseHeaderSize) + (0U << 2))))))));
			goto l3;
		}
	l3:	/* end positiveMachineIntegerValueOf: */;
		/* begin positiveMachineIntegerValueOf: */
		if ((integerReceiver & 1)) {
			value1 = (integerReceiver >> 1);
			if (value1 < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerReceiverValue = ((usqIntptr_t) null);
				goto l6;
			}
			integerReceiverValue = ((usqIntptr_t) value1);
			goto l6;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
		assert(!((integerReceiver & 1)));
		/* begin compactClassIndexOf: */
		ccIndex1 = (((usqInt) (longAt(integerReceiver))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex1 == 0) {
			ok1 = ((longAt(integerReceiver - BaseHeaderSize)) & AllButTypeMask) == classOop1;
			goto l5;
		}
		ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
		goto l5;

		ok1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l5:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok1) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) 0);
			goto l6;
		}
		bs1 = numBytesOfBytes(integerReceiver);
		if (bs1 > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) 0);
			goto l6;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs1 > 4)) {
			integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerReceiver)))));
			goto l6;
		}
		else {
			integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerReceiver + BaseHeaderSize) + (0U << 2))))))));
			goto l6;
		}
	l6:	/* end positiveMachineIntegerValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			oop = positiveMachineIntegerFor(integerArgumentValue ^ integerReceiverValue);
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) == 0) {

		/* old behavior - just return the size of free memory */
		/* begin pop:thenPushInteger: */
		integerVal = (oopisLessThan(GIV(freeStart), GIV(reserveStart))
			? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
			: 0);
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* new behaviour -including or excluding swap space depending on aBool */
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushInteger: */
			integerVal1 = ((oopisLessThan(GIV(freeStart), GIV(reserveStart))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(aBool));
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerVal1 << 1) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static void *function = (void *)-1;
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	primitiveCallout = ((void (*)(void)) function);
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt ccIndex;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l2;
	}
	arg = oop;
l2:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop1;
l3:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	if (((ccIndex = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		argClass = (longAt(arg - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		argClass = longAt((oop2 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt instance;
    sqInt oop;
    sqInt oop1;
    char *sp;

	instance = longAt(GIV(stackPointer));
	/* begin pop:thenPush: */
	if ((instance & 1)) {
		/* begin splObj: */
		oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(instance))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			oop = (longAt(instance - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			oop = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;

}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & 1) == 0)
			 && (((((usqInt) (longAt(s))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			sz = numBytesOfBytes(s);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		if (!(sufficientSpaceToAllocate(sz))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);

		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;
    sqInt valueWord1;
    sqInt valueWord11;


	/* bypass type inference which would deduce int */
	midx = 0;
	msecs = 0;
	uidx = 0;
	usecs = 0;
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)runInNOut << 1) | 1));
	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) (((usqInt)usecs)))) <= (MaxSmallInteger)) {
		v1 = (((((usqInt)usecs)) << 1) | 1);
		goto l11;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((((usqInt)usecs)));
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	v1 = newLargeInteger;
	goto l11;

l11:	/* end positive32BitIntegerFor: */;
	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) (((usqInt)msecs)))) <= (MaxSmallInteger)) {
		v2 = (((((usqInt)msecs)) << 1) | 1);
		goto l15;
	}
	newLargeInteger1 = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord11 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((((usqInt)msecs)));
	long32Atput((newLargeInteger1 + BaseHeaderSize) + (0U << 2), valueWord11);

	v2 = newLargeInteger1;
	goto l15;

l15:	/* end positive32BitIntegerFor: */;
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(remapBuffer)[GIV(remapBufferCount)], GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v1);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (1U << (shiftForWord())), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (2U << (shiftForWord())), (((usqInt)uidx << 1) | 1));
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(remapBuffer)[GIV(remapBufferCount)], GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v2);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (3U << (shiftForWord())), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (4U << (shiftForWord())), (((usqInt)midx << 1) | 1));
	/* begin pop:thenPush: */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1U << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1U << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0);
	}
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt sz;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(((outerContext & 1) == 0)
		 && (((((usqInt) (longAt(outerContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(((closureMethod & 1) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1U << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (1U << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp7;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(void)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt i;
    sqInt len1;
    sqInt len2;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & 1) == 0)
		 && (((((usqInt) (longAt(arg1))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && (((arg2 & 1) == 0)
		 && (((((usqInt) (longAt(arg2))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOf: */
	if ((arg1 & 1)) {
		len1 = 0;
		goto l1;
	}
	len1 = numBytesOf(arg1);
l1:	/* end byteSizeOf: */;
	/* begin byteSizeOf: */
	if ((arg2 & 1)) {
		len2 = 0;
		goto l2;
	}
	len2 = numBytesOf(arg2);
l2:	/* end byteSizeOf: */;
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return;
	}
	for (i = 0; i < len1; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	Fill the receiver, which must be an indexable non-pointer
	object, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end1;
     int fillValue1;
    usqInt i1;
    sqInt rcvr1;
    sqInt successBoolean;
    sqInt successBoolean1;

	/* begin primitiveConstantFillV3 */
	fillValue1 = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr1 & 1) == 0)
	 && (isWordsOrBytesNonImm(rcvr1));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (((rcvr1 & 1) == 0)
	 && (((((usqInt) (longAt(rcvr1))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {
		/* begin success: */
		successBoolean = (fillValue1 >= 0)
		 && (fillValue1 <= 0xFF);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		fillValue1 = ((fillValue1 + (((int)((usqInt)(fillValue1) << 8)))) + (((int)((usqInt)(fillValue1) << 16)))) + (((int)((usqInt)(fillValue1) << 24)));
	}
	if (!GIV(primFailCode)) {
		end1 = rcvr1 + (sizeBitsOf(rcvr1));
		i1 = rcvr1 + BaseHeaderSize;
		while (i1 < end1) {
			long32Atput(i1, fillValue1);
			i1 += 4;
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}

}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), (((usqInt)numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt header;
    sqInt i;
    sqInt length;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt sz;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((arg & 1)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) != ((((ccIndex1 = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(arg - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord()))))))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (isWordsOrBytesNonImm(rcvr)) {
		length = numBytesOf(rcvr);
		if (!((((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) == ((((usqInt) (longAt(arg))) >> (instFormatFieldLSB())) & 15))
			 && (length == (numBytesOf(arg))))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr))) {
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		if (!((isAppropriateForCopyObject(arg))
			 && (length == (lengthOf(arg))))) {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		for (i = 0; i < length; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, valuePointer);
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((longAt(GIV(stackPointer))) & 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 1);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)quotient)) ^ ((((usqInt)quotient)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((sqInt)((((usqInt)(integerReceiver / integerArgument))) ^ ((((usqInt)(integerReceiver / integerArgument))) << 1)))) >= 0) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)(integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}

			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */
			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */
				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt oop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin fetchPointer:ofObject: */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(criticalSection, GIV(youngStart))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	addLastLinktoList(activeProc, criticalSection);
	transferTo(wakeHighestPriority());
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver == integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) == (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */
	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	if ((assert(!(isForwarded(criticalSection))),
	(longAt((criticalSection + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {

		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */
		owningProcess = removeFirstLinkOfList(criticalSection);
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields));
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(exp(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	Exponent part of this float.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    int pwr;
    double rcvr;
    double result;

	pwr = 0;
	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */
		frexp(rcvr, (&pwr));
		longAtPointerput(GIV(stackPointer), (((usqInt)(pwr - 1) << 1) | 1));
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    unsigned int integerValue;
    unsigned int integerValue1;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    char *sp;
    char *sp1;
    sqInt valueWord1;
    sqInt valueWord11;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		/* begin positive32BitIntegerFor: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		integerValue = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l5;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		result = newLargeInteger;
		goto l5;

	l5:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin positive32BitIntegerFor: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		integerValue1 = ((sqInt) (long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << 2))))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue1)) <= (MaxSmallInteger)) {
			result = ((integerValue1 << 1) | 1);
			goto l9;
		}
		newLargeInteger1 = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord11 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue1);
		long32Atput((newLargeInteger1 + BaseHeaderSize) + (0U << 2), valueWord11);

		result = newLargeInteger1;
		goto l9;

	l9:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterOrEqual */
static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterThan */
static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatGreater:thanArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessOrEqual */
static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatLessOrEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessThan */
static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatLess:thanArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatMultiply */
static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatNotEqual */
static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatSubtract */
static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l3;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(rcvrOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l6;
	}
	/* begin floatValueOf: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(argOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l5;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

	/* InterpreterPrimitives>>#primitiveFlushCache */
static void
primitiveFlushCache(void)
{
	flushMethodCache();
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

	/* InterpreterPrimitives>>#primitiveFlushExternalPrimitives */
static void
primitiveFlushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt sz;

	/* begin flushExternalPrimitives */
	chunk = startOfMemory();
	oop1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop1)) < GIV(freeStart)) {
		if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt) (longAt(oop1))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				flushExternalPrimitiveOf(oop1);
			}

		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop1);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop1 = (oop1 + sz) + (headerTypeBytes[(longAt(oop1 + sz)) & TypeMask]);
	}
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

	/* InterpreterPrimitives>>#primitiveForceDisplayUpdate */
static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	Set force tenure flag to true, this forces a tenure operation on the next
	incremental GC
 */

	/* InterpreterPrimitives>>#primitiveForceTenure */
EXPORT(sqInt)
primitiveForceTenure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(forceTenureFlag) = 1;
	return 0;
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

	/* InterpreterPrimitives>>#primitiveFormPrint */
static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    sqInt depth;
    sqInt h;
    double hScale;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt landscapeFlag;
    sqInt ok;
    sqInt oop;
    sqInt oop1;
    int pixelsPerWord;
    sqInt rcvr;
    double result;
    double result1;
    double vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l2;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l2;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	landscapeFlag = null;
l2:	/* end booleanValueOf: */;
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l4;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l4;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l4;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		vScale = result;
		goto l5;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	vScale = 0.0;
l5:	/* end floatValueOf: */;
	/* begin floatValueOf: */
	oop1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop1 & 1)) {
		isFloat1 = 0;
		goto l7;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop1 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		isFloat1 = ((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l7;
	}
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l7;

	isFloat1 = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l7:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		fetchFloatAtinto(oop1 + BaseHeaderSize, result1);
		hScale = result1;
		goto l8;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	hScale = 0.0;
l8:	/* end floatValueOf: */;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if (!((((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(rcvr)) >= 4))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if (((bitsArray & 1) == 0)
		 && (isWordsOrBytesNonImm(bitsArray))) {
			bitsArraySize = numBytesOf(bitsArray);
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
	if (!GIV(primFailCode)) {
		ok = ioFormPrint(bitsArray + BaseHeaderSize, w, h, depth, hScale, vScale, landscapeFlag);
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
}


/*	Fractional part of this float.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveFractionalPart */
static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;
    double trunc;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(modf(rcvr, (&trunc)));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

	/* InterpreterPrimitives>>#primitiveGetAttribute */
static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    char *sp;
    sqInt sz;

	sz = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		attr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		attr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		sz = attributeSize(attr);
	}
	if (!GIV(primFailCode)) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Access to environment variables via getenv. No putenv or setenv as yet. */

	/* InterpreterPrimitives>>#primitiveGetenv */
EXPORT(sqInt)
primitiveGetenv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *result;
    char *sp;
    char *var;

	if (sHEAFn != 0) {

		/* secHasEnvironmentAccess */
		if (!(sHEAFn())) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrInappropriate);
		}
	}
	var = cStringOrNullFor(longAt(GIV(stackPointer)));
	if (var == 0) {
		if (!GIV(primFailCode)) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
		return 0;
	}
	result = getenv(var);
	free(var);
	if (result != 0) {
		result = stringForCString(result);
		if (!(result)) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrNoMemory);
		}
	}
	assert(GIV(primFailCode) == 0);
	/* begin pop:thenPush: */
	oop = (result == 0
		? GIV(nilObj)
		: result);
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGetImmutability */
#if IMMUTABILITY
static void
primitiveGetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt trueOrFalse;

	rcvr = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin pop:thenPushBool: */
	trueOrFalse = ((rcvr & 1))
	 || (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Primitive. Answer the VM's current log directory */

	/* InterpreterPrimitives>>#primitiveGetLogDirectory */
EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char*ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), stringOop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Return the next input event from the VM event queue. */

	/* InterpreterPrimitives>>#primitiveGetNextEvent */
static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqIntptr_t eventTypeIs;
    sqIntptr_t evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqIntptr_t value;

	arg = longAt(GIV(stackPointer));
	if (!((((arg & 1) == 0)
		 && (((((usqInt) (longAt(arg))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (GIV(primFailCode)) {
		return;
	}
	eventTypeIs = evtBuf[0];
	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((((usqInt)(evtBuf[0]))) ^ ((((usqInt)(evtBuf[0]))) << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((arg + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)(evtBuf[0]) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	if (eventTypeIs == 6) {

		/* Event is Complex, assume evtBuf is populated correctly and return */
		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(arg, GIV(youngStart))) {
				possibleRootStoreIntovalue(arg, value);
			}
			longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), value);
		}
	}
	else {

		/* Event time stamp */
		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)((((usqInt)((evtBuf[1]) & MillisecondClockMask))) ^ ((((usqInt)((evtBuf[1]) & MillisecondClockMask))) << 1)))) >= 0) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			longAtput((arg + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode)) {
			return;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if ((((sqInt)((((usqInt)value)) ^ ((((usqInt)value)) << 1)))) >= 0) {
				/* begin storeInteger:ofObject:withValue: */
				if ((((sqInt)((((usqInt)value)) ^ ((((usqInt)value)) << 1)))) >= 0) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), (((usqInt)value << 1) | 1));
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
			}
			else {
				value = positiveMachineIntegerFor(value);
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(arg, GIV(youngStart))) {
					possibleRootStoreIntovalue(arg, value);
				}
				longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), value);
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's label */

	/* InterpreterPrimitives>>#primitiveGetWindowLabel */
EXPORT(sqInt)
primitiveGetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt labelOop;
    char*ptr;
    char *sp;
    sqInt sz;

	ptr = ioGetWindowLabel();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	labelOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((labelOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), labelOop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveGetWindowSize */
EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt object;
    sqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)w << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)h << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGreaterOrEqual */
static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterOrEqualLargeIntegers */
EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGreaterThan */
static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterThanLargeIntegers */
EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* InterpreterPrimitives>>#primitiveHashMultiply */
static void
primitiveHashMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    char *sp;
    unsigned int value;

	value = longAt(GIV(stackPointer));
	if ((value & 1)) {
		value = (value >> 1);
	}
	else {
		/* begin is:instanceOf:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
		if ((value & 1)) {
			ok = 0;
			goto l3;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((value & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(value))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(value - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l3;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l3;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l3:	/* end is:instanceOf:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		value = SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((value + BaseHeaderSize) + (0U << 2))));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((((value * HashMultiplyConstant) & 0xFFFFFFF) << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

	/* InterpreterPrimitives>>#primitiveHeartbeatFrequency */
EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    sqInt reset;
    char *sp;
    sqInt valueWord1;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	/* begin pop:thenPush: */
	integerValue = ioHeartbeatFrequency(reset);
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		oop = ((integerValue << 1) | 1);
		goto l4;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	oop = newLargeInteger;
	goto l4;

l4:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Return the value of the high resolution clock if this system has any. The
	exact frequency of the high res clock is undefined specifically so that we
	can use processor dependent instructions (like RDTSC). The only use for
	the high res clock is for profiling where we can allocate time based on
	sub-msec resolution of the high res clock. If no high-resolution counter
	is available, the platform should return zero.
 */

	/* InterpreterPrimitives>>#primitiveHighResClock */
EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin push: */
	object = positive64BitIntegerFor(ioHighResClock());
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveIdentical */
static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject == otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;

}

	/* InterpreterPrimitives>>#primitiveIdentityHash */
static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if (((thisReceiver & 1))
	 || ((GIV(argumentCount) > 0)
	 && (isForwarded(thisReceiver)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		integerVal = (((usqInt) (longAt(thisReceiver))) >> HashBitsOffset) & HashMaskUnshifted;
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integerVal << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer an integer identifying the type of image. The image version number
	may identify the format of the image (e.g. 32 or 64-bit word size) or
	specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveImageFormatVersion */
EXPORT(sqInt)
primitiveImageFormatVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    char *sp;
    sqInt valueWord1;

	/* begin pop:thenPush: */
	integerValue = 6505;
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		oop = ((integerValue << 1) | 1);
		goto l4;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	oop = newLargeInteger;
	goto l4;

l4:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

	/* InterpreterPrimitives>>#primitiveImageName */
static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt cl;
    sqInt ok;
    sqInt okToRename;
    sqInt oop1;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		   If not, assume it's ok */
		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		ok = (s & 1) == 0;
		if (ok) {
			/* begin isClassOfNonImm:equalTo: */
			assert(isNonImmediate(s));
			if (((ccIndex = (((usqInt) (longAt(s))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
				cl = (longAt(s - BaseHeaderSize)) & AllButTypeMask;
			}
			else {
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
				cl = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
			}
			ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))));
		}
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

	/* InterpreterPrimitives>>#primitiveInputSemaphore */
static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt oop;

	arg = longAt(GIV(stackPointer));
	if ((arg & 1)) {

		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */
		ioSetInputSemaphore((arg >> 1));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((arg == GIV(nilObj))
	 || (((arg & 1) == 0)
	 && (((((ccIndex = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(arg - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
		/* begin splObj:put: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheInputSemaphore) << (shiftForWord())))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

	/* InterpreterPrimitives>>#primitiveInputWord */
static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)0 << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

	/* InterpreterPrimitives>>#primitiveIntegerAt */
static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt header;
    sqInt index;
    int intValue;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt sz;
    sqInt sz1;

	index = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 1);
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (fmt <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l6;
	}
	sz = (fmt < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt & 3));
l6:	/* end lengthOf: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* for zero indexing */
	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	intValue = intAt(addr);
	/* begin signed32BitIntegerFor: */
	if ((((sqInt)((((usqInt)intValue)) ^ ((((usqInt)intValue)) << 1)))) >= 0) {
		result = (((usqInt)intValue << 1) | 1);
		goto l4;
	}
	result = noInlineSigned32BitIntegerGutsFor(intValue);
	goto l4;

l4:	/* end signed32BitIntegerFor: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

	/* InterpreterPrimitives>>#primitiveIntegerAtPut */
static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt sz1;
    int value;
    sqInt valueOop;

	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin signed32BitValueOf: */
	if ((valueOop & 1)) {
		value = (valueOop >> 1);
		goto l6;
	}
	value = noInlineSigned32BitValueGutsOf(valueOop);
	goto l6;

l6:	/* end signed32BitValueOf: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	/* begin lengthOf: */
	header = longAt(rcvr);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header & SizeMask;
	}
	sz1 -= header & Size4Bit;
	if (fmt <= 4) {
		sz = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l8;
	}
	sz = (fmt < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt & 3));
l8:	/* end lengthOf: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* for zero indexing */
	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	value = intAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), valueOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

	/* InterpreterPrimitives>>#primitiveInterruptChecksPerMSec */
EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin pop:thenPush: */
	oop = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

	/* InterpreterPrimitives>>#primitiveInterruptSemaphore */
static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt oop;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & 1) == 0)
	 && (((((ccIndex = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(arg - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
		/* begin splObj:put: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheInterruptSemaphore) << (shiftForWord())))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

	/* InterpreterPrimitives>>#primitiveInvokeObjectAsMethod */
static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt oop;
    sqInt rcvr;
    sqInt runArgs;
    sqInt runReceiver;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	runArgs = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), GIV(argumentCount));
	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		longAtput((runArgs + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorRunWithIn) << (shiftForWord())))));
	GIV(argumentCount) = 3;
	if ((GIV(newMethod) & 1)) {
		/* begin fetchPointer:ofObject: */
		lookupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(GIV(newMethod)))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			lookupClassTag = (longAt(GIV(newMethod) - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			lookupClassTag = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	findNewMethodInClassTag(lookupClassTag);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l14;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
		/* begin maybeRetryPrimitiveOnFailure */
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l14;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader1 & 1)),
((((int) methodHeader1)) < 0
		? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader1) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l9;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l9:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l14:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer if running on a big endian machine. */

	/* InterpreterPrimitives>>#primitiveIsBigEnder */
EXPORT(sqInt)
primitiveIsBigEnder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (VMBIGENDIAN
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Answer whether the argument to the primitive is a root for
	young space
 */

	/* InterpreterPrimitives>>#primitiveIsRoot */
EXPORT(sqInt)
primitiveIsRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    char *sp;
    sqInt trueOrFalse;

	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		trueOrFalse = ((longAt(oop)) & RootBit) != 0;
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

	/* InterpreterPrimitives>>#primitiveIsWindowObscured */
EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin pushBool: */
	trueOrFalse = ioIsWindowObscured();
	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Answer whether the argument to the primitive resides in young
	space. 
 */

	/* InterpreterPrimitives>>#primitiveIsYoung */
EXPORT(sqInt)
primitiveIsYoung(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    char *sp;
    sqInt trueOrFalse;


	/* for now... */
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop1 & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oop1;
l1:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		trueOrFalse = oopisGreaterThanOrEqualTo(oop, youngStart());
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdNext */
static void
primitiveKbdNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), (((usqInt)keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdPeek */
static void
primitiveKbdPeek(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), (((usqInt)keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessOrEqual */
static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessOrEqualLargeIntegers */
EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessThan */
static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessThanLargeIntegers */
EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

	/* InterpreterPrimitives>>#primitiveListBuiltinModule */
static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

	/* InterpreterPrimitives>>#primitiveListExternalModule */
static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well
	formed. It will return as its value the original array of roots, and the
	erstwhile segmentWordArray will have been truncated to a size of one word,
	i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to
	an unrecognizable and unusable jumble. But what more could you have done
	with it anyway? */

	/* InterpreterPrimitives>>#primitiveLoadImageSegment */
static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((outPointerArray & 1) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((segmentWordArray & 1) == 0)
		 && (((((usqInt) (longAt(segmentWordArray))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()))))) {

		/* Must be indexable words */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray);
	if (oopisGreaterThan(result, segmentWordArray)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = result;
	}
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

	/* InterpreterPrimitives>>#primitiveLocalMicrosecondClock */
static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicrosecondsNow());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log.
	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017 */

	/* InterpreterPrimitives>>#primitiveLogN */
static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(log(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

	/* InterpreterPrimitives>>#primitiveLowSpaceSemaphore */
static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt oop;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & 1) == 0)
	 && (((((ccIndex = (((usqInt) (longAt(arg))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(arg - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
		/* begin splObj:put: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveMakePoint */
static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt pt;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & 1))
		 || (isinstanceOfcompactClassIndex(rcvr, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord()))))), ClassFloatCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	pt = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
	longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), rcvr);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pt + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), longAt(GIV(stackPointer)));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMaxIdentityHash */
static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)HashMaskUnshifted << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

	/* InterpreterPrimitives>>#primitiveMethod */
usqInt
primitiveMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

	/* InterpreterPrimitives>>#primitiveMillisecondClock */
static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = (((usqInt)((ioMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

	/* InterpreterPrimitives>>#primitiveMillisecondClockMask */
EXPORT(sqInt)
primitiveMillisecondClockMask(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)MillisecondClockMask << 1) | 1));
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveMod */
static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)mod)) ^ ((((usqInt)mod)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)mod << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveModLargeIntegers */
EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Handle remainder of same sign as argument */
	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveMouseButtons */
static void
primitiveMouseButtons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)buttonWord << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveMousePoint */
static void
primitiveMousePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;
    sqInt x;
    sqInt y;

	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 0xFFFF) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 0xFFFF;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 0xFFFF) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 0xFFFF) & 32768) == 0) {
		y = pointWord & 0xFFFF;
		goto l2;
	}
	else {
		y = (pointWord & 0xFFFF) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin pop:thenPush: */
	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)x << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)y << 1) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMultiply */
static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    int overflow;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		overflow = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr > ((MaxSmallInteger) / integerArg)
					: integerArg < ((MinSmallInteger) / integerRcvr))
			: (integerArg > 0
					? integerRcvr < ((MinSmallInteger) / integerArg)
					: (integerRcvr < 0)
						 && (integerArg < ((MaxSmallInteger) / integerRcvr))));
		if (overflow) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		else {
			integerResult = integerRcvr * integerArg;
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveMultiplyLargeIntegers */
EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNew */
static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocSize;
    sqInt bytes;
    sqInt classOop;
    sqInt format;
    sqInt minFree;
    sqInt oop;
    char *sp1;
    sqInt spaceOkay;

	
	/* Allocate a new fixed-size instance. Fail if the allocation would leave
	   less than lowSpaceThreshold bytes free. May cause a GC. */
	/* The following may cause GC! Use var for result to permit inlining. */
	/* begin sufficientSpaceToInstantiate:indexableSize: */
	classOop = longAt(GIV(stackPointer));
	if (((format = instSpecOfClass(classOop))) < (firstByteFormat())) {

		/* indexable fields are words or pointers */
		allocSize = 0 * BytesPerWord;
	}
	else {

		/* indexable fields are bytes */
		/* fail if attempting to allocate over 2 Gb, since this overflows 32-bit arithmetic */
		if ((((usqInt) 0) >> LongSizeNumBits) > 0) {
			spaceOkay = 0;
			goto l4;
		}
		allocSize = 0;
	}
	/* begin sufficientSpaceToAllocate: */
	bytes = 2500 + allocSize;

	/* check for low-space */
	minFree = ((((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		spaceOkay = 1;
		goto l4;
	}
	spaceOkay = sufficientSpaceAfterGC(minFree);
l4:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	if (spaceOkay) {
		/* begin pop:thenPush: */
		oop = instantiateClassindexableSize(longAt(GIV(stackPointer)), 0);
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
	}

}

	/* InterpreterPrimitives>>#primitiveNewMethod */
static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt header;
    sqInt i;
    sqInt literalCount;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	bytecodeCount = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((header & 1))
		 && (((bytecodeCount & 1))
		 && (((bytecodeCount = (bytecodeCount >> 1))) >= 0)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	assert((header & 1));
	literalCount = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	size = ((literalCount + LiteralStart) * BytesPerOop) + bytecodeCount;
	theMethod = instantiateClassindexableSize(class, size);

	longAtput((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))), header);
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(theMethod, GIV(youngStart))) {
			possibleRootStoreIntovalue(theMethod, GIV(nilObj));
		}
		longAtput((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveNewWithArg */
static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocSize;
    sqInt bs;
    sqInt bytes;
    sqInt ccIndex;
    sqInt classOop;
    sqInt classOop1;
    sqInt format;
    sqInt minFree;
    sqInt ok;
    sqInt oop;
    sqInt oop1;
    usqIntptr_t size;
    char *sp1;
    sqInt spaceOkay;
    sqInt value;

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((oop1 & 1)) {
		value = (oop1 >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l9;
		}
		size = value;
		goto l9;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop1 & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(oop1 - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l8;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l8;

	ok = classOop1 == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l8:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l9;
	}
	bs = numBytesOfBytes(oop1);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l9;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop1)));
		goto l9;
	}
	else {
		size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize) + (0U << 2))))));
		goto l9;
	}
l9:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin sufficientSpaceToInstantiate:indexableSize: */
	classOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((format = instSpecOfClass(classOop))) < (firstByteFormat())) {

		/* indexable fields are words or pointers */
		if (size != 0) {

			/* fail if attempting to call new: on non-indexable class */
			if (format < 2) {
				spaceOkay = 0;
				goto l6;
			}
			if ((((usqInt) size) >> (LongSizeNumBits - (shiftForWord()))) > 0) {
				spaceOkay = 0;
				goto l6;
			}
		}
		allocSize = size * BytesPerWord;
	}
	else {

		/* indexable fields are bytes */
		/* fail if attempting to allocate over 2 Gb, since this overflows 32-bit arithmetic */
		if ((((usqInt) size) >> LongSizeNumBits) > 0) {
			spaceOkay = 0;
			goto l6;
		}
		allocSize = size;
	}
	/* begin sufficientSpaceToAllocate: */
	bytes = 2500 + allocSize;

	/* check for low-space */
	minFree = ((((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		spaceOkay = 1;
		goto l6;
	}
	spaceOkay = sufficientSpaceAfterGC(minFree);
l6:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	if (spaceOkay) {
		/* begin pop:thenPush: */
		oop = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size);
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
	}

}

	/* InterpreterPrimitives>>#primitiveNextInstance */
static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classPointer;
    sqInt header;
    sqInt header1;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    char *sp;
    sqInt subsequentObject;
    sqInt subsequentObject1;
    sqInt sz;
    sqInt sz1;

	object = longAt(GIV(stackPointer));
	if (!((object & 1))) {
		/* begin instanceAfter: */
		if (((ccIndex = (((usqInt) (longAt(object))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classPointer = (longAt(object - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			classPointer = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(object, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(object)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(object)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(object);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(object - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		subsequentObject1 = (object + sz1) + (headerTypeBytes[(longAt(object + sz1)) & TypeMask]);
		while (oopisLessThan(subsequentObject1, freeStart())) {
			if ((!(((longAt(subsequentObject1)) & TypeMask) == HeaderTypeFree))
			 && (((((ccIndex1 = (((usqInt) (longAt(subsequentObject1))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(subsequentObject1 - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))))))) == classPointer)) {
				subsequentObject = subsequentObject1;
				goto l7;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(subsequentObject1, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(subsequentObject1)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(subsequentObject1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(subsequentObject1);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(subsequentObject1 - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			subsequentObject1 = (subsequentObject1 + sz) + (headerTypeBytes[(longAt(subsequentObject1 + sz)) & TypeMask]);
		}
		subsequentObject = null;
	l7:	/* end instanceAfter: */;
		if (!(subsequentObject == null)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

	/* InterpreterPrimitives>>#primitiveNextObject */
static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt instance;
    sqInt obj;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt sz;
    sqInt sz1;

	/* begin accessibleObjectAfter: */
	oop = longAt(GIV(stackPointer));
	/* begin objectAfter: */
	if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
		error("no objects after the end of memory");
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz1 = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header1 = longAt(oop);
		sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
			: header1 & SizeMask);
	}
	obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			instance = obj;
			goto l5;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	instance = null;
l5:	/* end accessibleObjectAfter: */;
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)0 << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		assert(isInMemory(instance));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp1;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

	/* InterpreterPrimitives>>#primitiveNoop */
static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveNotEqual */
static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver != integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) != (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveNotEqualLargeIntegers */
EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */

	/* InterpreterPrimitives>>#primitiveNotIdentical */
static void
primitiveNotIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject != otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

	/* InterpreterPrimitives>>#primitiveObjectAt */
static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= (((assert((((assert(isCompiledMethod(thisReceiver)),
longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(thisReceiver)),
longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(thisReceiver)),
longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(thisReceiver)),
			longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), longAt((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
 */

	/* InterpreterPrimitives>>#primitiveObjectAtPut */
static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & 1) == 0)
	 || ((index == ConstOne)
	 && ((newValue & 1) == 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 1);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((longAt(thisReceiver)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (!((index > 0)
		 && (index <= (((assert((((assert(isCompiledMethod(thisReceiver)),
longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(thisReceiver)),
longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(thisReceiver)),
longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(thisReceiver)),
			longAt((thisReceiver + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(thisReceiver, GIV(youngStart))) {
		possibleRootStoreIntovalue(thisReceiver, newValue);
	}
	longAtput((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))), newValue);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	primitivePathTo: anObject using: stack <Array> followWeak: boolean
	Answer a path to anObject from the root that does not pass through
	the current context */

	/* InterpreterPrimitives>>#primitivePathToUsing */
EXPORT(sqInt)
primitivePathToUsing(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aWord;
    sqInt aWord1;
    sqInt aWord2;
    sqInt ccIndex;
    sqInt current;
    sqInt err;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt followWeak;
    usqInt freeStartAtStart;
    sqInt goal;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt index;
    sqInt next;
    sqInt oop;
    sqInt path;
    char *sp;
    sqInt stack;
    sqInt stackp;
    sqInt stackSize;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	err = 0;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(GIV(argumentCount) >= 2)) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (!(((longAt(GIV(stackPointer))) == GIV(trueObj))
		 || ((longAt(GIV(stackPointer))) == GIV(falseObj)))) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	/* begin pathTo:using:followWeak: */
	goal = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	stack = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	followWeak = (longAt(GIV(stackPointer))) == GIV(trueObj);
	if (!(((stack & 1) == 0)
		 && (((((usqInt) (longAt(stack))) >> (instFormatFieldLSB())) & 15) == 2))) {
		err = PrimErrBadArgument;
		goto l18;
	}
	assert(allObjectsUnmarked());

	/* check no allocations during search */
	freeStartAtStart = freeStart();
	beRootIfOld(stack);
	/* begin lengthOf: */
	header1 = longAt(stack);
	/* begin lengthOf:baseHeader:format: */
	fmt1 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(stack - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header1 & SizeMask;
	}
	sz1 -= header1 & Size4Bit;
	if (fmt1 <= 4) {
		stackSize = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l15;
	}
	stackSize = (fmt1 < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt1 & 3));
l15:	/* end lengthOf: */;
	/* begin mark: */
	aWord1 = (longAt(stack)) | MarkBit;
	longAtput(stack, aWord1);
	/* begin specialObjectsOop */
	current = GIV(specialObjectsOop);
	/* begin mark: */
	aWord2 = (longAt(current)) | MarkBit;
	longAtput(current, aWord2);
	/* begin lengthOf: */
	header2 = longAt(current);
	/* begin lengthOf:baseHeader:format: */
	fmt2 = (((usqInt) header2) >> (instFormatFieldLSB())) & 15;
	if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
		sz2 = (longAt(current - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz2 = header2 & SizeMask;
	}
	sz2 -= header2 & Size4Bit;
	if (fmt2 <= 4) {
		index = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
		goto l17;
	}
	index = (fmt2 < (firstByteFormat())
		? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
		: (sz2 - BaseHeaderSize) - (fmt2 & 3));
l17:	/* end lengthOf: */;
	stackp = 0;
	while(1) {
		while (((index -= 1)) >= -1) {
			if ((((((usqInt)current)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)current)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)current)) <= (((usqInt)GIV(pages))))))) {
				if (index >= 0) {
					next = fieldofFrame(index, ((char *) current));
				}
				else {
					/* begin nilObject */
					next = GIV(nilObj);
				}
			}
			else {
				if (index >= 0) {
					if (((((usqInt) (longAt(current))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
						next = fieldOrSenderFPofContext(index, current);
					}
					else {
						next = longAt((current + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					}
				}
				else {
					if (((ccIndex = (((usqInt) (longAt(current))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						next = (longAt(current - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
						next = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
					}
				}
			}
			if ((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))) {
				assert(isFrameonPage(((char *) next), stackPageFor(((char *) next))));
			}
			else {
				assert(checkOkayOop(next));
			}
			if (next == goal) {
				assert(freeStartAtStart == (freeStart()));
				unmarkAfterPathTo();
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(stack, GIV(youngStart))) {
					possibleRootStoreIntovalue(stack, current);
				}
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(stackp) << (shiftForWord())))), current);
				pruneStackstackp(stack, stackp);
				err = 0;
				goto l18;
			}
			if (((next & 1) == 0)
			 && (((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))
				? !(((longAt(next + FoxFrameFlags)) & 2) != 0)
				: (!(((longAt(next)) & MarkBit) != 0))
					 && (((((next & 1) == 0)
					 && (((((usqInt) (longAt(next))) >> (instFormatFieldLSB())) & 15) <= 4))
					 || (((((usqInt) (longAt(next))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
					 && (followWeak
					 || (!(((((usqInt) (longAt(next))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())))))))) {
				if ((stackp + 2) > stackSize) {
					assert(freeStartAtStart == (freeStart()));
					unmarkAfterPathTo();
					/* begin nilFieldsOf: */
					for (i = 0, iLimiT = ((lengthOf(stack)) - 1); i <= iLimiT; i += 1) {
						longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
					}
					err = PrimErrBadIndex;
					goto l18;
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(stackp) << (shiftForWord())))), current);
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp + 1)) << (shiftForWord())))), (((usqInt)index << 1) | 1));
				stackp += 2;
				if ((((((usqInt)(((char *) next)))) & (BytesPerWord - 1)) == 0)
				 && ((((((usqInt)(((char *) next)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) next)))) <= (((usqInt)GIV(pages))))))) {
					/* begin markFrame: */
					longAtput(next + FoxFrameFlags, (longAt(next + FoxFrameFlags)) | 2);
					/* begin fieldsInFrame: */
					index = CtxtTempFrameStart + (stackPointerIndexForFrame(((char *) next)));
				}
				else {
					/* begin mark: */
					aWord = (longAt(next)) | MarkBit;
					longAtput(next, aWord);
					if (((((usqInt) (longAt(next))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
						index = ((assert((((assert(isCompiledMethod(next)),
/* begin fetchPointer:ofObject: */
longAt((next + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(next)),
/* begin fetchPointer:ofObject: */
longAt((next + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(next)),
/* begin fetchPointer:ofObject: */
longAt((next + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(next)),
			/* begin fetchPointer:ofObject: */
			longAt((next + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart;
					}
					else {
						/* begin lengthOf: */
						header = longAt(next);
						/* begin lengthOf:baseHeader:format: */
						fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
						if ((header & TypeMask) == HeaderTypeSizeAndClass) {
							sz = (longAt(next - (BytesPerWord * 2))) & LongSizeMask;
						}
						else {
							sz = header & SizeMask;
						}
						sz -= header & Size4Bit;
						if (fmt <= 4) {
							index = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
							goto l13;
						}
						index = (fmt < (firstByteFormat())
							? ((usqInt) (sz - BaseHeaderSize)) >> 2
							: (sz - BaseHeaderSize) - (fmt & 3));
					l13:	/* end lengthOf: */;
					}
				}
				current = next;
			}
		}
		if (current == GIV(specialObjectsOop)) {
			assert(freeStartAtStart == (freeStart()));
			unmarkAfterPathTo();
			/* begin nilFieldsOf: */
			for (i1 = 0, iLimiT1 = ((lengthOf(stack)) - 1); i1 <= iLimiT1; i1 += 1) {
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), GIV(nilObj));
			}
			err = PrimErrNotFound;
			goto l18;
		}
		index = ((longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp - 1)) << (shiftForWord())))))) >> 1);
		current = longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp - 2)) << (shiftForWord())))));
		stackp -= 2;
	}
l18:	/* end pathTo:using:followWeak: */;
	if (err != 0) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = err);
	}
	path = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), path);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitivePerformInSuperclass */
static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt currentClass;
    sqInt delta;
    sqInt errorCode;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt lookupClass;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt offset;
    sqInt oop;
    sqInt performArgCount;
    sqInt rcvr;
    sqInt rcvr1;
    sqInt selector;
    sqInt selector1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt sz;
    sqInt table;
    sqInt top;

	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	lookupClass = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin splObj: */
		currentClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			currentClass = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			currentClass = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	while (currentClass != lookupClass) {
		currentClass = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		if (currentClass == GIV(nilObj)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	selector = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l23;
	}
	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l23;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */
	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	selector1 = GIV(messageSelector);
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector1), lengthOfMaybeImmediate(selector1), rcvr);
	findNewMethodInClassTag((lookupClass == null
		? ((rcvr & 1)
				? (/* begin splObj: */
					longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
				: (((ccIndex1 = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0
						? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
						: (/* begin fetchPointer:ofObject: */
							longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord()))))))))
		: (/* begin classTagForClass: */
			lookupClass)));
	if ((((GIV(newMethod) & 1) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
			? rcvr
			: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l23;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l19;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
		/* begin maybeRetryPrimitiveOnFailure */
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l19;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader1 & 1)),
((((int) methodHeader1)) < 0
		? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader1) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l12;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l12:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l19:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l23:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePerformWithArgs */
static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualReceiver;
    sqInt argumentArray;
    sqInt arraySize;
    sqInt ccIndex1;
    sqInt delta;
    sqInt errorCode;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    sqInt selector;
    sqInt selector1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt sz;
    sqInt table;
    sqInt top;

	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	actualReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	selector = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l20;
	}
	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l20;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */
	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	selector1 = GIV(messageSelector);
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector1), lengthOfMaybeImmediate(selector1), actualReceiver);
	findNewMethodInClassTag(((actualReceiver & 1)
		? (/* begin splObj: */
			longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
		: (((ccIndex1 = (((usqInt) (longAt(actualReceiver))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(actualReceiver - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))))))));
	if ((((GIV(newMethod) & 1) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
			? actualReceiver
			: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l20;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l19;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
		/* begin maybeRetryPrimitiveOnFailure */
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l19;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader1 & 1)),
((((int) methodHeader1)) < 0
		? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader1) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l12;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l12:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l19:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l20:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

	/* InterpreterPrimitives>>#primitiveProfilePrimitive */
EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
	return 0;
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

	/* InterpreterPrimitives>>#primitiveProfileSample */
EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
	return 0;
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

	/* InterpreterPrimitives>>#primitiveProfileSemaphore */
EXPORT(sqInt)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop;
    sqInt sema;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((sema == GIV(nilObj))
		 || (((sema & 1) == 0)
		 && (((((ccIndex = (((usqInt) (longAt(sema))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(sema - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
				longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	GIV(profileSemaphore) = sema;
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

	/* InterpreterPrimitives>>#primitiveProfileStart */
EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;
    sqInt integerPointer;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		deltaTicks = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		deltaTicks = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(nextProfileTick) = (ioHighResClock()) + deltaTicks;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveQuit */
static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 1)
		: 0));
}


/*	Rounds negative results towards zero. */

	/* InterpreterPrimitives>>#primitiveQuo */
static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	integerResult = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		integerResult = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr / integerArg
					: 0 - (integerRcvr / (0 - integerArg)))
			: (integerArg > 0
					? 0 - ((0 - integerRcvr) / integerArg)
					: (0 - integerRcvr) / (0 - integerArg)));
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ ((((usqInt)integerResult)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveQuoLargeIntegers */
EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

	/* InterpreterPrimitives>>#primitiveRelinquishProcessor */
static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */
		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveRemLargeIntegers */
EXPORT(void)
primitiveRemLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

	/* InterpreterPrimitives>>#primitiveResume */
static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;


	/* rcvr */
	proc = longAt(GIV(stackPointer));
	if (!(isContext(longAt((proc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	resumepreemptedYieldingIf(proc, GIV(preemptionYields));
}


/*	Primitive. Answer the nth element of the root table.
	This primitive avoids the creation of an extra array;
	it is intended for enumerations of the form:
	index := 1.
	[root := Smalltalk rootTableAt: index.
	root == nil] whileFalse:[index := index + 1].
	 */

	/* InterpreterPrimitives>>#primitiveRootTableAt */
EXPORT(sqInt)
primitiveRootTableAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt successBoolean;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	successBoolean = (index > 0)
	 && (index <= GIV(rootTableCount));
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(rootTable)[index]);
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	The character scanner primitive. */

	/* InterpreterPrimitives>>#primitiveScanCharacters */
static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
		goto l10;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
		goto l10;
	}
l10:	/* end stackIntegerValue: */;
	stops = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		scanRightX = (integerPointer1 >> 1);
		goto l11;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
		goto l11;
	}
l11:	/* end stackIntegerValue: */;
	sourceString = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		scanStopIndex = (integerPointer2 >> 1);
		goto l12;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
		goto l12;
	}
l12:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		scanStartIndex = (integerPointer3 >> 1);
		goto l13;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
		goto l13;
	}
l13:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if (GIV(primFailCode)) {
		return;
	}
	if (!((((stops & 1) == 0)
		 && (((((usqInt) (longAt(stops))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((slotSizeOf(stops)) >= 258)
		 && ((((sourceString & 1) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && ((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && ((scanStopIndex <= (byteSizeOf(sourceString)))
		 && ((((rcvr & 1) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((slotSizeOf(rcvr)) >= 4))))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord())));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord())));
	if (!((((scanXTable & 1) == 0)
		 && (((((usqInt) (longAt(scanXTable))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((((scanMap & 1) == 0)
		 && (((((usqInt) (longAt(scanMap))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((slotSizeOf(scanMap)) == 256)
		 && (!GIV(primFailCode)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */
	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */

		/* Known to be okay since stops size >= 258 */
		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)(ascii) << (shiftForWord()))))))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */
			if (!((((sqInt)((((usqInt)scanDestX)) ^ ((((usqInt)scanDestX)) << 1)))) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanDestX)) ^ ((((usqInt)scanDestX)) << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanLastIndex)) ^ ((((usqInt)scanLastIndex)) << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop: */
			GIV(stackPointer) += 7 * BytesPerWord;
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */
		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */
		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */
			if (!((((sqInt)((((usqInt)scanDestX)) ^ ((((usqInt)scanDestX)) << 1)))) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanDestX)) ^ ((((usqInt)scanDestX)) << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanLastIndex)) ^ ((((usqInt)scanLastIndex)) << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((int)((usqInt)((CrossedX - 1)) << (shiftForWord()))))));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((((sqInt)((((usqInt)scanDestX)) ^ ((((usqInt)scanDestX)) << 1)))) >= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((((usqInt)scanDestX)) ^ ((((usqInt)scanDestX)) << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((((usqInt)scanStopIndex)) ^ ((((usqInt)scanStopIndex)) << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanStopIndex << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((int)((usqInt)((EndOfRun - 1)) << (shiftForWord()))))));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

	/* InterpreterPrimitives>>#primitiveScreenDepth */
EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)depth << 1) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer a float indicating the current scale factor for pixels of the
	Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveScreenScaleFactor */
EXPORT(sqInt)
primitiveScreenScaleFactor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double factor;
    sqInt object;
    char *sp;

	factor = ioScreenScaleFactor();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin pushFloat: */
	object = floatObjectOf(factor);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the
	point is encoded into a single 32bit value in the image header.
	This might well become a problem one day */

	/* InterpreterPrimitives>>#primitiveScreenSize */
static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;

	pointWord = ioScreenSize();
	/* begin pop:thenPush: */
	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)((((usqInt) pointWord) >> 16) & 0xFFFF) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)(pointWord & 0xFFFF) << 1) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

	/* InterpreterPrimitives>>#primitiveSecondsClock */
static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    char *sp;
    sqInt valueWord1;

	/* begin pop:thenPush: */
	integerValue = ioSecondsNow();
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		oop = ((integerValue << 1) | 1);
		goto l4;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	oop = newLargeInteger;
	goto l4;

l4:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

	/* InterpreterPrimitives>>#primitiveSetDisplayMode */
static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;

	okay = 0;
	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		d = (integerPointer2 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((5 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

	/* InterpreterPrimitives>>#primitiveSetFullScreen */
static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Indicate if the GC logic should have bias to grow */

	/* InterpreterPrimitives>>#primitiveSetGCBiasToGrow */
EXPORT(sqInt)
primitiveSetGCBiasToGrow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;
    sqInt integerPointer;


	/* for now... */
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		flag = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		flag = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcBiasToGrow) = flag;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Primitive. If the GC logic has bias to grow, set growth limit */

	/* InterpreterPrimitives>>#primitiveSetGCBiasToGrowGCLimit */
EXPORT(sqInt)
primitiveSetGCBiasToGrowGCLimit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt integerPointer;
    sqInt value;


	/* for now... */
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcBiasToGrowGCLimit) = value;
		/* begin gcBiasToGrowThreshold: */
		aValue = (youngStart()) - (((sqInt)(startOfMemory())));
		GIV(gcBiasToGrowThreshold) = aValue;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveSetImmutability */
#if IMMUTABILITY
static void
primitiveSetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt wasImmutable;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	wasImmutable = 
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		if (!(canBeImmutable(rcvr))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			return;
		}
		setIsImmutableOfto(rcvr, 1);
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			setIsImmutableOfto(rcvr, 0);
		}
		else {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (wasImmutable
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

	/* InterpreterPrimitives>>#primitiveSetInterruptKey */
static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

	/* InterpreterPrimitives>>#primitiveSetLogDirectory */
EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(((stringOop & 1) == 0)
		 && (((((usqInt) (longAt(stringOop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin byteSizeOf: */
	if ((stringOop & 1)) {
		sz = 0;
		goto l2;
	}
	sz = numBytesOf(stringOop);
l2:	/* end byteSizeOf: */;
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveSetOrHasIdentityHash */
static void
primitiveSetOrHasIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasHash;
    sqInt hash;
    sqInt integerPointer;
    sqInt isReceiverAClass;
    sqInt oldHash;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt thisReceiver;

	if (GIV(argumentCount) == 0) {
		hasHash = (((longAt(GIV(stackPointer))) & 1) == 0)
		 && (1);
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (hasHash
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 2) {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			isReceiverAClass = 1;
			goto l2;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			isReceiverAClass = 0;
			goto l2;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		isReceiverAClass = null;
	l2:	/* end booleanValueOf: */;
		if (GIV(primFailCode)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
	}
	else {
		isReceiverAClass = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		hash = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		hash = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		thisReceiver = null;
		goto l4;
	}
	thisReceiver = oop;
l4:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		oldHash = (((usqInt) (longAt(thisReceiver))) >> HashBitsOffset) & HashMaskUnshifted;
		/* begin setHashBitsOf:to: */
		longAtput(thisReceiver, ((((longAt(thisReceiver)) | HashBits) - HashBits)) | (((sqInt)((usqInt)((hash & HashMaskUnshifted)) << HashBitsOffset))));
		/* begin pop:thenPushInteger: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)oldHash << 1) | 1));
		GIV(stackPointer) = sp1;
	}
}


/*	Primitive. Set the OS window's label */

	/* InterpreterPrimitives>>#primitiveSetWindowLabel */
EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt labelOop;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(((labelOop & 1) == 0)
		 && (((((usqInt) (longAt(labelOop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin byteSizeOf: */
	if ((labelOop & 1)) {
		sz = 0;
		goto l2;
	}
	sz = numBytesOf(labelOop);
l2:	/* end byteSizeOf: */;
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveSetWindowSize */
EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as
	an array of signed 16-bit values. Answer the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word.  */

	/* InterpreterPrimitives>>#primitiveShortAt */
static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & 1) == 0)
		 && (isWordsOrBytesNonImm(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 1);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr))) >> 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	value = shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

	/* InterpreterPrimitives>>#primitiveShortAtPut */
static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((value & 1))
		 && (((index & 1))
		 && (((value = (value >> 1)),
		(value >= -32768)
			 && (value <= 0x7FFF)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & 1) == 0)
		 && (isWordsOrBytesNonImm(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	index = (index >> 1);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr))) >> 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))), value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), (((usqInt)value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

	/* InterpreterPrimitives>>#primitiveShowDisplayRect */
static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		top = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		right = (integerPointer2 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		left = (integerPointer3 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord()))))), left, top, right, bottom);
	if (!GIV(primFailCode)) {
		ioForceDisplayUpdate();
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveSignal */
static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	synchronousSignal(longAt(GIV(stackPointer)));
}


/*	Set the low-water mark for free space. When the free space falls
	below this level, the new and new: primitives fail and system attempts
	to allocate space (e.g., to create a method context) cause the low-space
	semaphore (if one is registered) to be signalled. */

	/* InterpreterPrimitives>>#primitiveSignalAtBytesLeft */
static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;

	bytes = longAt(GIV(stackPointer));
	if (((bytes & 1))
	 && (((bytes = (bytes >> 1))) >= 0)) {
		GIV(lowSpaceThreshold) = bytes;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveSine */
static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(sin(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
}

	/* InterpreterPrimitives>>#primitiveSize */
static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if (((rcvr & 1))
	 || (((hdr = longAt(rcvr)),
	((fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15)) < 2))) {

		/* This is not an indexable object */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		primitiveContextSize();
		return;
	}
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l2;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(totalLength - fixedFields) << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	save a normal snapshot under the same name as it was loaded unless it has
	been renamed by the last primitiveImageName
 */

	/* InterpreterPrimitives>>#primitiveSnapshot */
static void
primitiveSnapshot(void)
{
	snapshot(0);
}


/*	save an embedded snapshot */

	/* InterpreterPrimitives>>#primitiveSnapshotEmbedded */
static void
primitiveSnapshotEmbedded(void)
{
	snapshot(1);
}

	/* InterpreterPrimitives>>#primitiveSomeInstance */
static void
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt chunk;
    sqInt class;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt instance;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    char *sp;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt thisClass;
    sqInt thisObj;

	class = longAt(GIV(stackPointer));
	/* begin initialInstanceOf: */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			thisObj = obj1;
			goto l11;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	thisObj = null;
l11:	/* end firstAccessibleObject */;
	while (!(thisObj == null)) {
		if ((thisObj & 1)) {
			/* begin fetchPointer:ofObject: */
			thisClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
		}
		else {
			if (((ccIndex = (((usqInt) (longAt(thisObj))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
				thisClass = (longAt(thisObj - BaseHeaderSize)) & AllButTypeMask;
			}
			else {
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
				thisClass = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
			}
		}
		if (thisClass == class) {
			instance = thisObj;
			goto l13;
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(thisObj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(thisObj)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(thisObj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(thisObj);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(thisObj - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (thisObj + sz1) + (headerTypeBytes[(longAt(thisObj + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				thisObj = obj;
				goto l7;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		thisObj = null;
	l7:	/* end accessibleObjectAfter: */;
	}
	instance = null;
l13:	/* end initialInstanceOf: */;
	if (instance == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

	/* InterpreterPrimitives>>#primitiveSomeObject */
static void
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt obj;
    sqInt object;
    char *sp;
    sqInt sz;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			object = obj;
			goto l5;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	object = null;
l5:	/* end firstAccessibleObject */;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

	/* InterpreterPrimitives>>#primitiveSpecialObjectsOop */
static void
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveSquareRoot */
static void
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end stackFloatValue: */;
	if ((!GIV(primFailCode))
	 && (rcvr >= 0.0)) {
		/* begin stackTopPut: */
		aValue = floatObjectOf(sqrt(rcvr));
		longAtPointerput(GIV(stackPointer), aValue);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* InterpreterPrimitives>>#primitiveStoreImageSegment */
static void
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((arrayOfRoots & 1) == 0)
		 && (((((usqInt) (longAt(arrayOfRoots))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((((outPointerArray & 1) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((segmentWordArray & 1) == 0)
		 && (((((usqInt) (longAt(segmentWordArray))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))))) {

		/* Must be indexable words */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	if (ecode == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ecode;
	}
}

	/* InterpreterPrimitives>>#primitiveStringAt */
static void
primitiveStringAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    sqInt oop1;
    sqInt oop11;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt valueWord1;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l14;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (isForwarded(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l14;
	}
	index = (index >> 1);
	/* begin stObject:at: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l13;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l13;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l13;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l13;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		result = newLargeInteger;
		goto l13;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l13:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		if (!(((result >= 0) && (result <= 0xFF)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			goto l14;
		}
		if (CharacterTable == null) {
			if (((((result >> 1)) >= 0) && (((result >> 1)) <= 0xFF))) {
				/* begin fetchPointer:ofObject: */
				oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
				result = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(((result >> 1))) << (shiftForWord())))));
			}
			else {
				result = GIV(nilObj);
			}
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
			result = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)(((result >> 1))) << (shiftForWord())))));
		}

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l14:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveStringAtPut */
static void
primitiveStringAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt oop1;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt signedValueToStore;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;
    sqInt value;
    sqInt value1;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l29;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (isForwarded(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l29;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l29;
	}
	index = (index >> 1);
	/* begin stObject:at:put: */
	value1 = asciiOfCharacter(value);
	/* begin baseHeader: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value1);
			goto l14;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, value1);
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value1);
			goto l13;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((value1 & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			signedValueToStore = (value1 >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l13;
		}
		unsignedValueToStore = positive32BitValueOf(value1);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l13:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
l14:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l29:	/* end commonAtPut: */;
}


/*	<array> primReplaceFrom: start to: stop with: replacement startingAt:
	repStart 
	<primitive: 105> */

	/* InterpreterPrimitives>>#primitiveStringReplace */
static void
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array1;
    sqInt arrayFmt1;
    sqInt arrayInstSize1;
    sqInt ccIndex11;
    sqInt ccIndex2;
    sqInt class11;
    sqInt class2;
    sqInt classFormat11;
    sqInt classFormat2;
    sqInt hdr;
    sqInt i1;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt oop111;
    sqInt oop12;
    sqInt repl1;
    sqInt replFmt1;
    sqInt replInstSize1;
    sqInt replStart1;
    sqInt srcIndex;
    sqInt start1;
    sqInt stop1;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;
    sqInt valuePointer;

	/* begin primitiveV3StringReplace */
	array1 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		start1 = (integerPointer >> 1);
		goto l19;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		start1 = 0;
		goto l19;
	}
l19:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		stop1 = (integerPointer1 >> 1);
		goto l15;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stop1 = 0;
		goto l15;
	}
l15:	/* end stackIntegerValue: */;
	repl1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		replStart1 = (integerPointer2 >> 1);
		goto l22;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		replStart1 = 0;
		goto l22;
	}
l22:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l25;
	}
	if ((repl1 & 1)) {

		/* can happen in LgInt copy */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l25;
	}
	if ((stop1 >= start1)
	 && (
#  if IMMUTABILITY
		((longAt(array1)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l25;
	}
	hdr = longAt(array1);
	arrayFmt1 = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array1 - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (arrayFmt1 <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l21;
	}
	totalLength = (arrayFmt1 < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (arrayFmt1 & 3));
l21:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt1 > 4)
	 || (arrayFmt1 == 2)) {
		arrayInstSize1 = 0;
		goto l24;
	}
	if (arrayFmt1 < 2) {
		arrayInstSize1 = totalLength;
		goto l24;
	}
	if (((ccIndex2 = (((usqInt) (longAt(array1))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class2 = (longAt(array1 - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop12 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class2 = longAt((oop12 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex2 - 1)) << (shiftForWord())))));
	}
	classFormat2 = (longAt((class2 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	arrayInstSize1 = (((((usqInt) classFormat2) >> 11) & 192) + ((((usqInt) classFormat2) >> 2) & 0x3F)) - 1;
l24:	/* end fixedFieldsOf:format:length: */;
	if (!((start1 >= 1)
		 && (((start1 - 1) <= stop1)
		 && ((stop1 + arrayInstSize1) <= totalLength)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l25;
	}
	hdr = longAt(repl1);
	replFmt1 = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(repl1 - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr & SizeMask;
	}
	sz1 -= hdr & Size4Bit;
	if (replFmt1 <= 4) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l20;
	}
	totalLength = (replFmt1 < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (replFmt1 & 3));
l20:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((replFmt1 > 4)
	 || (replFmt1 == 2)) {
		replInstSize1 = 0;
		goto l13;
	}
	if (replFmt1 < 2) {
		replInstSize1 = totalLength;
		goto l13;
	}
	if (((ccIndex11 = (((usqInt) (longAt(repl1))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class11 = (longAt(repl1 - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop111 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class11 = longAt((oop111 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex11 - 1)) << (shiftForWord())))));
	}
	classFormat11 = (longAt((class11 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	replInstSize1 = (((((usqInt) classFormat11) >> 11) & 192) + ((((usqInt) classFormat11) >> 2) & 0x3F)) - 1;
l13:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart1 >= 1)
		 && ((((stop1 - start1) + replStart1) + replInstSize1) <= totalLength))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l25;
	}
	if (arrayFmt1 < (firstByteFormat())) {
		if (!(arrayFmt1 == replFmt1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			goto l25;
		}
	}
	else {
		if (!((arrayFmt1 & 12) == (replFmt1 & 12))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			goto l25;
		}
	}

	/* - 1 for 0-based access */
	srcIndex = (replStart1 + replInstSize1) - 1;
	if (arrayFmt1 <= 4) {
		for (i1 = ((start1 + arrayInstSize1) - 1); i1 < (stop1 + arrayInstSize1); i1 += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((repl1 + BaseHeaderSize) + (((sqInt)((usqInt)(srcIndex) << (shiftForWord())))));
			if (oopisLessThan(array1, GIV(youngStart))) {
				possibleRootStoreIntovalue(array1, valuePointer);
			}
			longAtput((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), valuePointer);
			srcIndex += 1;
		}
	}
	else {
		if (arrayFmt1 < (firstByteFormat())) {

			/* 32-bit-word type objects */
			for (i1 = ((start1 + arrayInstSize1) - 1); i1 < (stop1 + arrayInstSize1); i1 += 1) {
				/* begin storeLong32:ofObject:withValue: */
				long32Atput((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << 2))), long32At((repl1 + BaseHeaderSize) + (((sqInt)((usqInt)(srcIndex) << 2)))));
				srcIndex += 1;
			}
		}
		else {

			/* byte-type objects */
			for (i1 = ((start1 + arrayInstSize1) - 1); i1 < (stop1 + arrayInstSize1); i1 += 1) {
				/* begin storeByte:ofObject:withValue: */
				byteAtput((array1 + BaseHeaderSize) + i1, byteAt((repl1 + BaseHeaderSize) + srcIndex));
				srcIndex += 1;
			}
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
l25:	/* end primitiveV3StringReplace */;

}

	/* InterpreterPrimitives>>#primitiveSubtract */
static void
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ ((((usqInt)integerResult)) << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveSubtractLargeIntegers */
EXPORT(void)
primitiveSubtractLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative != bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Suspend the receiver, aProcess such that it can be executed
	again by sending #resume. If the given process is not currently running,
	take it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
 */

	/* InterpreterPrimitives>>#primitiveSuspend */
static void
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt lastLink;
    sqInt myList;
    sqInt nextLink;
    sqInt process;
    char *sp;
    char *sp1;
    sqInt tempLink;
    sqInt valuePointer;

	process = longAt(GIV(stackPointer));
	if (process == (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord()))))))))) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
		transferTo(wakeHighestPriority());
		return;
	}

	/* XXXX Fixme. We should really check whether myList is a kind of LinkedList or not
	   but we can't easily so just do a quick check for nil which is the most common case. */
	myList = longAt((process + BaseHeaderSize) + (((int)((usqInt)(MyListIndex) << (shiftForWord())))));
	if (myList == GIV(nilObj)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	/* begin removeProcess:fromList: */
	assert(!((isForwarded(process))));
	assert(!((isForwarded(myList))));
	firstLink = longAt((myList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	lastLink = longAt((myList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))));
	assert(!((isForwarded(firstLink))));
	assert(!((isForwarded(lastLink))));
	if (process == firstLink) {
		nextLink = longAt((process + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		assert(!((isForwarded(nextLink))));
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(myList, GIV(youngStart))) {
			possibleRootStoreIntovalue(myList, nextLink);
		}
		longAtput((myList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))), nextLink);
		if (process == lastLink) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = GIV(nilObj);
			longAtput((myList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))), valuePointer);
		}
	}
	else {
		tempLink = firstLink;
		while (1) {
			assert(!((isForwarded(tempLink))));
			if (tempLink == GIV(nilObj)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				goto l9;
			}
			nextLink = longAt((tempLink + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))));
			if (nextLink == process) break;
			tempLink = longAt((tempLink + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		}
		nextLink = longAt((process + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(tempLink, GIV(youngStart))) {
			possibleRootStoreIntovalue(tempLink, nextLink);
		}
		longAtput((tempLink + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))), nextLink);
		if (process == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(myList, GIV(youngStart))) {
				possibleRootStoreIntovalue(myList, tempLink);
			}
			longAtput((myList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))), tempLink);
		}
	}
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(process, GIV(youngStart))) {
		possibleRootStoreIntovalue(process, GIV(nilObj));
	}
	longAtput((process + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))), GIV(nilObj));
l9:	/* end removeProcess:fromList: */;
	if (!GIV(primFailCode)) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(process, GIV(youngStart))) {
			possibleRootStoreIntovalue(process, GIV(nilObj));
		}
		longAtput((process + BaseHeaderSize) + (((int)((usqInt)(MyListIndex) << (shiftForWord())))), GIV(nilObj));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), myList);
		GIV(stackPointer) = sp1;
	}
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveTestAndSetOwnershipOfCriticalSection */
static void
primitiveTestAndSetOwnershipOfCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt oop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin fetchPointer:ofObject: */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(criticalSection, GIV(youngStart))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
	GIV(stackPointer) = sp2;
}


/*	Return true if the host OS does support the given display depth. */

	/* InterpreterPrimitives>>#primitiveTestDisplayDepth */
static void
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	okay = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bitsPerPixel = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Multiply the receiver by the power of the argument. */

	/* InterpreterPrimitives>>#primitiveTimesTwoPower */
static void
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;
    double result1;
    char *sp;

	arg = longAt(GIV(stackPointer));
	if (!((arg & 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	arg = (arg >> 1);
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		rcvr = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
	result = ldexp(rcvr, ((int) arg));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(result));
	GIV(stackPointer) = sp;
}


/*	N.B. IMO we should be able to assume the receiver is a float because this
	primitive is specific to floats. eem 2/13/2017
 */

	/* InterpreterPrimitives>>#primitiveTruncated */
static void
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;
    double trunc;

	/* begin stackFloatValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end stackFloatValue: */;
	if (!GIV(primFailCode)) {
		modf(rcvr, (&trunc));
		if (((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) ))))) {
			longAtPointerput(GIV(stackPointer), (((usqInt)(((sqInt)trunc)) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current
	sessionID. 
 */

	/* InterpreterPrimitives>>#primitiveUnloadModule */
static void
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt i;
    sqInt moduleName;
    sqInt oop;
    sqInt oop1;
    sqInt sz;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = longAt(GIV(stackPointer));
	if ((moduleName & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(((moduleName & 1) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), byteSizeOf(moduleName)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin flushExternalPrimitives */
	chunk = startOfMemory();
	oop1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop1)) < GIV(freeStart)) {
		if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt) (longAt(oop1))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				flushExternalPrimitiveOf(oop1);
			}

		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop1);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop1 = (oop1 + sz) + (headerTypeBytes[(longAt(oop1 + sz)) & TypeMask]);
	}
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	forceInterruptCheck();
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

	/* InterpreterPrimitives>>#primitiveUpdateTimezone */
static void
primitiveUpdateTimezone(void)
{
	ioUpdateVMTimezone();
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

	/* InterpreterPrimitives>>#primitiveUTCMicrosecondClock */
static void
primitiveUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicrosecondsNow());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Smalltalk epoch and the
	current seconds offset from GMT in the local time zone. Any pointer object
	with two or more slots) may be supplied as a parameter. */

	/* InterpreterPrimitives>>#primitiveUtcAndTimezoneOffset */
static void
primitiveUtcAndTimezoneOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((((resultArray & 1) == 0)
			 && (((((usqInt) (longAt(resultArray))) >> (instFormatFieldLSB())) & 15) <= 4))
			 && ((lengthOf(resultArray)) >= 2))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	else {
		resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), 2);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((usqInt)(ioLocalSecondsOffset()) << 1) | 1);
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	valuePointer1 = positive64BitIntegerFor(ioUTCMicroseconds());
	if (oopisLessThan(resultArray, GIV(youngStart))) {
		possibleRootStoreIntovalue(resultArray, valuePointer1);
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Posix epoch and the
	current seconds offset from GMT in the local time zone. An empty two
	element array (or any object with two or more slots) may be supplied
	as a parameter.
	This is a named (not numbered) primitive in the null module (ie the VM) */

	/* InterpreterPrimitives>>#primitiveUtcWithOffset */
EXPORT(sqInt)
primitiveUtcWithOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static usqLong epochDelta = 2177452800000000ULL;
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrBadNumArgs);
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((((resultArray & 1) == 0)
			 && (((((usqInt) (longAt(resultArray))) >> (instFormatFieldLSB())) & 15) <= 4))
			 && ((lengthOf(resultArray)) >= 2))) {
			/* begin primitiveFailFor: */
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
	}
	else {
		resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), 2);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((usqInt)(ioLocalSecondsOffset()) << 1) | 1);
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	valuePointer1 = positive64BitIntegerFor((ioUTCMicroseconds()) - epochDelta);
	if (oopisLessThan(resultArray, GIV(youngStart))) {
		possibleRootStoreIntovalue(resultArray, valuePointer1);
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Return a string containing the path name of VM's directory. */

	/* InterpreterPrimitives>>#primitiveVMPath */
static void
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

	/* InterpreterPrimitives>>#primitiveVMProfileSamplesInto */
static void
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt numSamples;
    sqInt running;
    sqInt sampleBuffer;
    char *sp;
    char *sp1;
    sqInt v;

	bufferSize = 0;
	running = 0;
	v = 0;
	ioNewProfileStatus((&running), (&bufferSize));
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (running
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	sampleBuffer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!(((sampleBuffer & 1) == 0)
		 && ((isPureBitsFormat((((usqInt) (longAt(sampleBuffer))) >> (instFormatFieldLSB())) & 15))
		 && ((numBytesOf(sampleBuffer)) >= (bufferSize * BytesPerWord))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	numSamples = ioNewProfileSamplesInto(firstFixedField(sampleBuffer));
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)numSamples << 1) | 1));
	GIV(stackPointer) = sp1;
}

	/* InterpreterPrimitives>>#primitiveWait */
static void
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    sqInt oop;
    sqInt sema;


	/* rcvr */
	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)((((usqInt)(excessSignals - 1))) ^ ((((usqInt)(excessSignals - 1))) << 1)))) >= 0) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			longAtput((sema + BaseHeaderSize) + (((int)((usqInt)(ExcessSignalsIndex) << (shiftForWord())))), (((usqInt)(excessSignals - 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		addLastLinktoList(activeProc, sema);
		transferTo(wakeHighestPriority());
	}
}


/*	Primitively do the equivalent of Process>yield, avoiding the overhead of a
	fork and a wait in the standard implementation.
 */

	/* InterpreterPrimitives>>#primitiveYield */
static void
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt scheduler;

	/* begin fetchPointer:ofObject: */
	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((scheduler + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((int)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	priority = (oop >> 1);
	processLists = longAt((scheduler + BaseHeaderSize) + (((int)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	processList = longAt((processLists + BaseHeaderSize) + (((sqInt)((usqInt)((priority - 1)) << (shiftForWord())))));
	if (!((assert(!(isForwarded(processList))),
		(longAt((processList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)))) {
		addLastLinktoList(activeProc, processList);
		transferTo(wakeHighestPriority());
	}
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

	/* InterpreterPrimitives>>#signalNoResume: */
sqInt
signalNoResume(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt empty;

	assert(!(isForwarded(aSemaphore)));
	empty = (longAt((aSemaphore + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj);

	if (!empty) {
		putToSleepyieldingIf(removeFirstLinkOfList(aSemaphore), 1);
	}
	return empty;
}


/*	Convert the given object into an integer value.
	The object may be either a SmallInteger or a four-byte LargeInteger. */

	/* InterpreterPrimitives>>#signed32BitValueOf: */
int
signed32BitValueOf(sqInt oop)
{
	if ((oop & 1)) {
		return (oop >> 1);
	}
	return noInlineSigned32BitValueGutsOf(oop);

}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#signed64BitValueOf: */
sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    usqLong magnitude;
    sqInt negative;
    sqInt ok;
    sqInt sz;
    sqLong value;

	if ((oop & 1)) {
		return ((sqLong) ((oop >> 1)));
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
		assert(!((oop & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {

		/* ] */
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	if ((negative
		? magnitude > 0x8000000000000000ULL
		: magnitude >= 0x8000000000000000ULL)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

	/* InterpreterPrimitives>>#signedMachineIntegerValueOf: */
sqIntptr_t
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classOop;
    sqInt classOop1;
    usqIntptr_t limit;
    usqIntptr_t magnitude;
    sqInt negative;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex1 == 0) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop1;
		goto l4;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l4;

	ok = classOop1 == (fetchPointerofObject(ccIndex1 - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l4:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
		assert(!((oop & 1)));
		/* begin compactClassIndexOf: */
		ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
		if (ccIndex == 0) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;

		ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	bs = numBytesOf(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(sqIntptr_t)) == 8)
	 && (bs > 4)) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {

		/* ] */
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize) + (0U << 2))))));
	}
	limit = (((usqIntptr_t)1)) << (((sizeof(sqIntptr_t)) * 8) - 1);
	if ((negative
		? magnitude > limit
		: magnitude >= limit)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt size;

	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	size = longAt(oop + BaseHeaderSize);
	return SQABS(size);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

	/* InterpreterPrimitives>>#success: */
sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return 0;
}


/*	Initialize the stack pages. For testing I want stack addresses to be
	disjoint from
	normal memory addresses so stack addresses are negative. The first address
	is -pageSize bytes. So for example if there are 1024 bytes per page and 3
	pages then the pages are organized as
	
	byte address: -1024 <-> -2047 | -2048 <-> -3071 | -3072 <-> -4096 |
	page 3			page 2			page 1
	mem index: 769 <-> 513 | 512 <-> 257 | 256 <-> 1 |
	
	The byte address is the external address corresponding to a real address
	in the VM.
	mem index is the index in the memory Array holding the stack, an index
	internal to
	the stack pages. The first stack page allocated will be the last page in
	the array of pages
	at the highest effective address. Its base address be -1024 and grow down
	towards -2047. */
/*	The lFoo's are to get around the foo->variable scheme in the C call to
	allocStackPages below.
 */

	/* InterpreterStackPages>>#initializeStack:numSlots:pageSize: */
static sqInt NoDbgRegParms
initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt i;
    sqInt index;
    sqInt numPages;
    StackPage *page;
    char *pageStructBase;
    void *pointer;
    usqIntptr_t structStackPageSize;
    sqInt theIndex;


	/* For initialization in the C code. */
	GIV(stackMemory) = theStackPages;
	structStackPageSize = sizeof(CogStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;

	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	   subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	   push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */
	numPages = GIV(numStackPages);
	pageStructBase = (theStackPages + (numPages * GIV(bytesPerPage))) + BytesPerWord;

	/* Simulation only.  Since addresses are negative the offset is positive.  To make all
	   stack addresses negative we make the offset a page more than it needs to be so the
	   address of the last slot in memory (the highest address in the stack, or its start) is
	   - pageByteSize
	   and the address of the first slot (the lowest address, or its end) is
	   - pageByteSize * (numPages + 1) */
	GIV(pages) = (StackPage *)pageStructBase;
	assert((((stackPageByteSize()) - (stackLimitBytes())) - (stackLimitOffset())) >= (stackPageHeadroom()));
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		(page->lastAddress = (char *)theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = ((page->baseAddress)) - ((((stackPageFrameBytes()) < (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord))))));
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (numPages - 1)
			? 0
			: index + 1)));
		(page->prevPage = stackPageAt((index == 0
			? numPages - 1
			: index - 1)));
	}
	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages));
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		assert((pageIndexFor((page->baseAddress))) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord))) == index);
		assert((stackPageFor((page->baseAddress))) == page);
		assert((stackPageFor((page->stackLimit))) == page);
		/* begin initializePageTraceToInvalid: */
		(page->trace = StackPageTraceInvalid);
	}
	/* begin stackPageAt: */
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages));
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		/* begin pageIndexFor: */
		pointer = (page->baseAddress);
		theIndex = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
		assert((stackPageAt(theIndex)) == page);
		assert((pageIndexFor((page->baseAddress))) == theIndex);
		assert((pageIndexFor((page->stackLimit))) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + BytesPerWord)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == numPages);
	assert(pageListIsWellFormed());
	return 0;
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

	/* InterpreterStackPages>>#pageIndexFor: */
static sqInt NoDbgRegParms
pageIndexFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

	/* NewObjectMemory>>#addressCouldBeObjWhileForwarding: */
static sqInt NoDbgRegParms
addressCouldBeObjWhileForwarding(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= (startOfMemory()))
	 && ((((usqInt)address)) < GIV(freeStart)));
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

	/* NewObjectMemory>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= (startOfMemory()))
	 && (((((usqInt)address)) < GIV(freeStart))
	 && (((longAt(address)) & TypeMask) != HeaderTypeGC)));
}


/*	Adjust all oop references by the given number of bytes. This is
	done just after reading in an image when the new base address
	of the object heap is different from the base address in the image. */
/*	di 11/18/2000 - return number of objects found */

	/* NewObjectMemory>>#adjustAllOopsBy: */
static sqInt NoDbgRegParms
adjustAllOopsBy(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt classHeader;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt header;
    sqInt newClassOop;
    sqInt nextOop;
    sqInt oop;
    sqInt sz;
    sqInt totalObjects;

	if (bytesToShift == 0) {
		return 300000;
	}
	totalObjects = 0;
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(oop, GIV(freeStart))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			totalObjects += 1;
			/* begin adjustFieldsAndClassOf:by: */
			fieldAddr = oop + (lastPointerOf(oop));
			while (oopisGreaterThan(fieldAddr, oop)) {
				fieldOop = longAt(fieldAddr);
				if (!((fieldOop & 1))) {
					longAtput(fieldAddr, fieldOop + bytesToShift);
				}
				fieldAddr -= BytesPerOop;
			}
			if (((longAt(oop)) & TypeMask) != HeaderTypeShort) {

				/* adjust class header if not a compact class */
				classHeader = longAt(oop - BytesPerWord);
				newClassOop = (classHeader & AllButTypeMask) + bytesToShift;
				longAtput(oop - BytesPerWord, newClassOop | (classHeader & TypeMask));
			}
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		nextOop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		assert(oopisLessThan(oop, nextOop));
		oop = nextOop;
	}
	return totalObjects;
}


/*	Attempt to answer all instances of aBehavior, failing if there is not
	enough room.
 */
/*	Allocate a large header Array of sufficient size to require a large
	header. Reset its size later. */

	/* NewObjectMemory>>#allInstancesOf: */
static sqInt NoDbgRegParms
allInstancesOf(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt afterPreAllocatedObject;
    sqInt byteSize;
    sqInt ccIndex;
    sqInt chunk;
    sqInt container;
    sqInt count;
    sqInt fillPointer;
    sqInt header;
    sqInt header1;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    usqInt p;
    usqInt p1;
    usqInt start;
    sqInt sz;
    sqInt sz1;

	container = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), 256);
	/* begin sizeHeader:putBodySize: */
	assert((0 % 4) == 0);
	longAtput(container - (BytesPerWord * 2), ((0 + BytesPerWord) & LongSizeMask) | ((((longAt(container - (BytesPerWord * 2))) | LongSizeMask) - LongSizeMask)));
	afterPreAllocatedObject = GIV(freeStart);
	GIV(freeStart) = (fillPointer = ((sqInt)(firstFixedField(container))));
	count = 0;
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, container)) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			if (((((ccIndex = (((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(obj - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == aBehavior) {
				count += 1;
				if (fillPointer < GIV(reserveStart)) {
					longAtput(fillPointer, obj);
					fillPointer += BytesPerOop;
				}
			}
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(obj);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj1 = (obj + sz1) + (headerTypeBytes[(longAt(obj + sz1)) & TypeMask]);
		while (oopisLessThan(obj1, GIV(freeStart))) {
			if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
				obj = obj1;
				goto l7;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj1);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj1 = (obj1 + sz) + (headerTypeBytes[(longAt(obj1 + sz)) & TypeMask]);
		}
		obj = null;
	l7:	/* end accessibleObjectAfter: */;
	}
	if (fillPointer >= GIV(reserveStart)) {

		/* didn't fit.  refill with allocation check pattern and answer count. */
		/* begin maybeFillWithAllocationCheckFillerFrom:to: */
		start = GIV(freeStart);
		if (checkAllocFiller()) {
			for (p = start; p <= fillPointer; p += BytesPerWord) {
				longAtput(p, p);
			}
		}
		return (((usqInt)count << 1) | 1);
	}
	byteSize = fillPointer - (((sqInt)(firstFixedField(container))));
	/* begin sizeHeader:putBodySize: */
	assert((byteSize % 4) == 0);
	longAtput(container - (BytesPerWord * 2), ((byteSize + BytesPerWord) & LongSizeMask) | ((((longAt(container - (BytesPerWord * 2))) | LongSizeMask) - LongSizeMask)));
	if (fillPointer < afterPreAllocatedObject) {
		/* begin maybeFillWithAllocationCheckFillerFrom:to: */
		if (checkAllocFiller()) {
			for (p1 = fillPointer; p1 <= afterPreAllocatedObject; p1 += BytesPerWord) {
				longAtput(p1, p1);
			}
		}
	}
	GIV(freeStart) = fillPointer;
	return container;
}

	/* NewObjectMemory>>#allObjectsUnmarked */
static sqInt
allObjectsUnmarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt o;
    sqInt oop;
    sqInt sz;

	/* begin allObjectsDo: */
	chunk = startOfMemory();
	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if (((longAt(oop)) & MarkBit) != 0) {
				return 0;
			}

		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return 1;
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced with with pointers to the other. The arguments must be arrays
	of the same length. 
	Returns PrimNoErr if the primitive succeeds.
 */
/*	Implementation: Uses forwarding blocks to update references as done in
	compaction. 
 */

	/* NewObjectMemory>>#become:with:twoWay:copyHash: */
static sqInt NoDbgRegParms
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    usqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock11;
    sqInt fwdBlock2;
    sqInt fwdHeader;
    sqInt fwdHeader1;
    sqInt fwdHeader2;
    sqInt hdr1;
    sqInt hdr11;
    sqInt hdr2;
    sqInt hdr21;
    sqInt header;
    sqInt numLiterals;
    sqInt objHeader;
    sqInt objHeader1;
    sqInt objHeader11;
    sqInt objHeader2;
    sqInt objHeaderBytes;
    sqInt objHeaderType;
    sqInt objSize;
    sqInt oop1;
    sqInt oop11;
    sqInt oop2;
    sqInt oop21;
    sqInt sp;
    usqInt start;

	runLeakCheckerFor(GCModeBecome);
	if (!(((array1 & 1) == 0)
		 && (((((usqInt) (longAt(array1))) >> (instFormatFieldLSB())) & 15) == 2))) {
		return PrimErrBadReceiver;
	}
	if (!((((array2 & 1) == 0)
		 && (((((usqInt) (longAt(array2))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((lastPointerOf(array1)) == (lastPointerOf(array2))))) {
		return PrimErrBadArgument;
	}
	if (twoWayFlag
	 || (copyHashFlag)) {
		if (!(containOnlyOopsand(array1, array2))) {
			return PrimErrInappropriate;
		}
	}
	else {
		if (!(containOnlyOops(array1))) {
			return PrimErrInappropriate;
		}
	}
	if (!(prepareForwardingTableForBecomingwithtwoWay(array1, array2, twoWayFlag))) {
		return PrimErrNoMemory;
	}
	if (allYoungand(array1, array2)) {

		/* sweep only the young objects plus the roots */
		start = GIV(youngStart);
	}
	else {

		/* sweep all objects */
		start = startOfMemory();
	}
	/* begin preBecomeAction */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	mapPointersInObjectsFromto(start, GIV(freeStart));
	if (twoWayFlag) {
		/* begin restoreHeadersAfterBecoming:with: */
		header = longAt(array1);
		fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
		if (fmt <= 4) {
			if ((fmt == (indexablePointersFormat()))
			 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l5;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
				contextSize = (sp >> 1);
			l5:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l4;
			}
			fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
			goto l4;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			fieldOffset = 0;
			goto l4;
		}
		assert(isCompiledMethod(array1));
		header = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin lastPointerOfMethodHeader: */
		assert((header & 1));
		numLiterals = ((((int) header)) < 0
			? (/* begin literalCountOfAlternateHeader: */
				((header >> 1)) & AlternateHeaderNumLiteralsMask)
			: (/* begin literalCountOfOriginalHeader: */
				(((usqInt) header) >> 10) & 0xFF));

		fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
	l4:	/* end lastPointerOf: */;
		while (fieldOffset >= BaseHeaderSize) {
			oop11 = longAt(array1 + fieldOffset);
			oop21 = longAt(array2 + fieldOffset);
			if (!(oop11 == oop21)) {
				/* begin restoreHeaderOf: */
				fwdHeader2 = longAt(oop11);
				fwdBlock2 = ((sqInt)((usqInt)((fwdHeader2 & AllButMarkBitAndTypeMask)) << 1));
				assert((fwdHeader2 & MarkBit) != 0);
				assert(fwdBlockValid(fwdBlock2));
				objHeader2 = longAt(fwdBlock2 + BytesPerWord);
				/* begin restoreHeaderOf:to: */
				longAtput(oop11, objHeader2);
				if (((((usqInt) objHeader2) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					if (!(asserta(!(isStillMarriedContext(oop11))))) {
						error("attempt to become married context");
					}
				}
				/* begin restoreHeaderOf: */
				fwdHeader1 = longAt(oop21);
				fwdBlock11 = ((sqInt)((usqInt)((fwdHeader1 & AllButMarkBitAndTypeMask)) << 1));
				assert((fwdHeader1 & MarkBit) != 0);
				assert(fwdBlockValid(fwdBlock11));
				objHeader11 = longAt(fwdBlock11 + BytesPerWord);
				/* begin restoreHeaderOf:to: */
				longAtput(oop21, objHeader11);
				if (((((usqInt) objHeader11) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					if (!(asserta(!(isStillMarriedContext(oop21))))) {
						error("attempt to become married context");
					}
				}
				hdr11 = longAt(oop11);
				hdr21 = longAt(oop21);
				longAtput(oop11, (hdr11 & AllButHashBits) | (hdr21 & HashBits));
				longAtput(oop21, (hdr21 & AllButHashBits) | (hdr11 & HashBits));
			}
			fieldOffset -= BytesPerWord;
		}
	}
	else {
		/* begin restoreHeadersAfterForwardBecome: */
		fwdBlock = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
		flag("Dan");

		/* fwdBlockGet: did a pre-increment */
		fwdBlock += BytesPerWord * 4;
		while (oopisLessThanOrEqualTo(fwdBlock, GIV(fwdTableNext))) {

			/* Backpointer to mutated object. */
			oop1 = longAt(fwdBlock + (BytesPerWord * 2));
			oop2 = longAt(fwdBlock);
			/* begin restoreHeaderOf: */
			fwdHeader = longAt(oop1);
			fwdBlock1 = ((sqInt)((usqInt)((fwdHeader & AllButMarkBitAndTypeMask)) << 1));
			assert((fwdHeader & MarkBit) != 0);
			assert(fwdBlockValid(fwdBlock1));
			objHeader = longAt(fwdBlock1 + BytesPerWord);
			/* begin restoreHeaderOf:to: */
			longAtput(oop1, objHeader);
			if (((((usqInt) objHeader) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				if (!(asserta(!(isStillMarriedContext(oop1))))) {
					error("attempt to become married context");
				}
			}
			if (copyHashFlag) {

				/* Change the hash of the new oop (oop2) to be that of the old (oop1)
				   so mutated objects in hash structures will be  happy after the change. */
				hdr1 = longAt(oop1);
				hdr2 = longAt(oop2);
				longAtput(oop2, (hdr2 & AllButHashBits) | (hdr1 & HashBits));
			}
			/* begin freeObject: */
			objHeader1 = longAt(oop1);
			/* begin freeObject:header: */
			if (((((usqInt) objHeader1) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				if (!(asserta(!(isStillMarriedContext(oop1))))) {
					error("attempt to free married context");
				}
			}
			if ((objHeader1 & RootBit) != 0) {
				removeYoungRoot(oop1);
			}
			objHeaderType = objHeader1 & TypeMask;
			objHeaderBytes = headerTypeBytes[objHeaderType];
			if ((objHeaderType & 1) == 1) {

				/* HeaderTypeClass or HeaderTypeShort */
				objSize = objHeader1 & SizeMask;
			}
			else {
				if (objHeaderType == HeaderTypeFree) {
					goto l2;
				}
				objSize = (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask;
			}
			assert(((objSize + objHeaderBytes) & AllButTypeMask) == (objSize + objHeaderBytes));
			longAtput(oop1 - objHeaderBytes, (objSize + objHeaderBytes) | HeaderTypeFree);
		l2:	/* end freeObject:header: */;
			fwdBlock += BytesPerWord * 4;
		}
	}
	/* begin postBecomeAction: */
	initializeMemoryFirstFree(GIV(freeStart));
	runLeakCheckerFor(GCModeBecome);
	return PrimNoErr;
}

	/* NewObjectMemory>>#characterValueOf: */
sqInt
characterValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassCharacter) << (shiftForWord()))))), 0))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrUnsupported;
		return -1;
	}
	return ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 1);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rootTable, remapBuffer and
	extraRootTable checking that every entry is a pointer to a header.
	Check that the number of roots is correct and that all rootTable
	entries have their rootBit set. Answer if all checks pass. */

	/* NewObjectMemory>>#checkHeapIntegrity */
static sqInt
checkHeapIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt fi;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt hdr;
    sqInt header;
    sqInt header1;
    sqInt numRootsInHeap;
    sqInt obj;
    sqInt ok;
    sqInt ri;
    sqInt sz;
    sqInt sz1;

	ok = 1;
	numRootsInHeap = 0;
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			hdr = longAt(obj);
			if ((hdr & RootBit) != 0) {
				numRootsInHeap += 1;
			}
			if (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == 0) {
				fieldOop = (longAt(obj - BaseHeaderSize)) & AllButTypeMask;
				if (((fieldOop & 1))
				 || ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
					print("object leak in ");
					printHex(obj);
					print(" class = ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
			fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
			if ((fmt <= 4)
			 || (fmt >= 12)) {
				if (fmt >= 12) {
					fi = ((assert((((assert(isCompiledMethod(obj)),
longAt((obj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(obj)),
longAt((obj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(obj)),
longAt((obj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(obj)),
			longAt((obj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart;
				}
				else {
					if ((fmt == 3)
					 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						fi = CtxtTempFrameStart + (fetchStackPointerOf(obj));
					}
					else {
						/* begin lengthOf: */
						header1 = longAt(obj);
						/* begin lengthOf:baseHeader:format: */
						fmt1 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
						if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
							sz1 = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
						}
						else {
							sz1 = header1 & SizeMask;
						}
						sz1 -= header1 & Size4Bit;
						if (fmt1 <= 4) {
							fi = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
							goto l4;
						}
						fi = (fmt1 < (firstByteFormat())
							? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
							: (sz1 - BaseHeaderSize) - (fmt1 & 3));
					l4:	/* end lengthOf: */;
					}
				}
				while (((fi -= 1)) >= 0) {
					fieldOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					if ((fieldOop & 1) == 0) {
						if ((fieldOop & (BytesPerWord - 1)) != 0) {
							print("misaligned oop in ");
							printHex(obj);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							ok = 0;
						}
						else {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(obj);
								print(" @ ");
								printNum(fi);
								print(" = ");
								printHex(fieldOop);
								/* begin cr */
								printf("\n");
								ok = 0;
							}
						}
					}
				}
			}
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	if (numRootsInHeap != GIV(rootTableCount)) {
		print("root count mismatch. #heap roots ");
		printNum(numRootsInHeap);
		print("; #roots ");
		printNum(GIV(rootTableCount));
		/* begin cr */
		printf("\n");
		ok = GIV(rootTableOverflowed)
		 && (GIV(needGCFlag));
	}
	for (ri = 1; ri <= GIV(rootTableCount); ri += 1) {
		obj = GIV(rootTable)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned oop in rootTable @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in rootTable @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
			else {
				hdr = longAt(obj);
				if (!((hdr & RootBit) != 0)) {
					print("non-root in rootTable @ ");
					printNum(ri);
					print(" = ");
					printHex(obj);
					/* begin cr */
					printf("\n");
					ok = 0;
				}
			}
		}
	}
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */
/*	address and size checks */

	/* NewObjectMemory>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt sz;
    sqInt type;
    sqInt unusedBit;

	if ((oop & 1)) {
		return 1;
	}
	if (!((oopisGreaterThanOrEqualTo(oop, startOfMemory()))
		 && (oopisLessThan(oop, GIV(freeStart))))) {
		print("oop ");
		printHex(oop);
		print(" is not a valid address");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!((oop % BytesPerWord) == 0)) {
		print("oop ");
		printHex(oop);
		print(" is not a word-aligned address");
		/* begin cr */
		printf("\n");
		return 0;
	}
	/* begin sizeBitsOf: */
	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	if (!(oopisLessThanOrEqualTo(oop + sz, GIV(freeStart)))) {
		print("oop ");
		printHex(oop);
		print(" size would make it extend beyond the end of memory");
		/* begin cr */
		printf("\n");
		return 0;
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		print("oop ");
		printHex(oop);
		print(" is a free chunk, not an object");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (type == HeaderTypeShort) {
		if (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == 0) {
			print("oop ");
			printHex(oop);
			print(" cannot have zero compact class field in a short header");
			/* begin cr */
			printf("\n");
			return 0;
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= BytesPerWord)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type))) {
			print("oop ");
			printHex(oop);
			print(" class header word has wrong type");
			/* begin cr */
			printf("\n");
			return 0;
		}
	}
	if (type == HeaderTypeSizeAndClass) {
		if (!((oop >= (BytesPerWord * 2))
			 && ((((longAt(oop - (BytesPerWord * 2))) & TypeMask) == type)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type)))) {
			print("oop ");
			printHex(oop);
			print(" class header word has wrong type");
			/* begin cr */
			printf("\n");
			return 0;
		}
	}
	fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		print("oop ");
		printHex(oop);
		print(" has an unknown format type");
		/* begin cr */
		printf("\n");
		return 0;
	}
	unusedBit = 0x20000000;
	if (!(((longAt(oop)) & unusedBit) == 0)) {
		print("oop ");
		printHex(oop);
		print(" unused header bit 30 is set; should be zero");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if ((((longAt(oop)) & RootBit) != 0)
	 && (oop >= GIV(youngStart))) {
		print("oop ");
		printHex(oop);
		print(" root bit is set in a young object");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* NewObjectMemory>>#checkOopIntegrity:named: */
static sqInt NoDbgRegParms
checkOopIntegritynamed(sqInt obj, char *name)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

	/* NewObjectMemory>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    usqInt nextHeader;
    usqInt obj;
    usqInt sz;

	clearHeapMap();
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			heapMapAtWordPut(pointerForOop(obj), 1);
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((sqInt) (((header & TypeMask) == HeaderTypeSizeAndClass
	? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
	: header & SizeMask)));
		}
		nextHeader = obj + sz;
		obj = nextHeader + (headerTypeBytes[(longAt(nextHeader)) & TypeMask]);
	}
}


/*	Return a shallow copy of the given object. May cause GC.
	Assume: Oop is a real object, not a small integer.
	Override to assert it's not a married context and maybe fix cloned
	methods.  */

	/* NewObjectMemory>>#clone: */
sqInt
clone(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;
    sqInt extraHdrBytes;
    usqInt fromIndex;
    usqInt hash;
    usqInt header;
    sqInt header1;
    usqInt lastFrom;
    sqInt newChunk;
    usqInt newChunk1;
    usqInt newFreeStart;
    sqInt newOop;
    sqInt oop;
    sqInt remappedOop;
    sqInt toIndex;

	assert((!(isContext(obj)))
	 || (!(isMarriedOrWidowedContext(obj))));
	assert(isNonIntegerObject(obj));
	extraHdrBytes = headerTypeBytes[(longAt(obj)) & TypeMask];
	/* begin sizeBitsOf: */
	header1 = longAt(obj);
	bytes = ((header1 & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
		: header1 & SizeMask);

	/* allocate space for the copy, remapping obj in case of a GC */
	bytes += extraHdrBytes;
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(obj));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = obj;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	if (!(sufficientSpaceToAllocate(2500 + bytes))) {
		return 0;
	}
	/* begin allocateChunk: */
	newChunk1 = GIV(freeStart);
	newFreeStart = GIV(freeStart) + bytes;
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newChunk = oopForPointer(newChunk1);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newChunk = oopForPointer(newChunk1);
		goto l1;
	}
	newChunk = 0;
l1:	/* end allocateChunk: */;
	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	remappedOop = oop;

	/* loop below uses pre-increment */
	toIndex = newChunk - BytesPerWord;
	fromIndex = (remappedOop - extraHdrBytes) - BytesPerWord;
	lastFrom = fromIndex + bytes;
	while (fromIndex < lastFrom) {
		longAtput((toIndex += BytesPerWord), longAt((fromIndex += BytesPerWord)));
	}

	/* convert from chunk to oop */
	/* fix base header: compute new hash and clear Mark and Root bits */
	newOop = newChunk + extraHdrBytes;
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());

	/* use old ccIndex, format, size, and header-type fields */
	header = (longAt(newOop)) & 0x1FFFF;
	header = header | ((hash << HashBitsOffset) & HashBits);
	longAtput(newOop, header);
	if (((((usqInt) header) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
	}
	return newOop;
}


/*	Answer the C double precision floating point value of the argument,
	or if it is not, answer 0. */

	/* NewObjectMemory>>#dbgFloatValueOf: */
static double NoDbgRegParms
dbgFloatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double result;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	return 0.0;
}


/*	Return the default amount of memory to allocate before doing a scavenge
	(incremental GC).
	This default suits Qwaq Forums (specifically loading). The actual value
	can be set via
	vmParameterAt: and/or a preference in the ini file. */

	/* NewObjectMemory>>#defaultEdenBytes */
static sqInt
defaultEdenBytes(void)
{
	return (2 * 1024) * 1024;
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* NewObjectMemory>>#eeInstantiateClassIndex:format:numSlots: */
sqInt
eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSize;
    usqInt hash;
    sqInt hdrSize;
    usqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;


	/* cannot have a negative indexable field count */
	header2 = 0;
	header3 = 0;
	assert((numSlots >= 0)
	 && (compactClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(compactClassAt(compactClassIndex))));

	/* Low 2 bits are 0 */
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());
	header1 = ((((sqInt)((usqInt)(objFormat) << (instFormatFieldLSB())))) | (((sqInt)((usqInt)(compactClassIndex) << 12)))) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	assert((((usqInt) ((formatOfClass(compactClassAt(compactClassIndex))) & 393216)) >> 9) == 0);
	flag("sizeLowBits");
	byteSize = (((sqInt)((usqInt)(numSlots) << ((shiftForWord()) + ((shiftForWord()) - 2))))) + BaseHeaderSize;
	if (byteSize > 0xFF) {

		/* requires size header word/full header */
		header3 = byteSize;
		hdrSize = 3;
		/* begin fetchPointer:ofObject: */
		header2 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((compactClassIndex - 1)) << (shiftForWord())))));
	}
	else {
		header1 = header1 | byteSize;
		hdrSize = 1;
	}
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l2;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l2;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l2;
	}
	error("out of memory");
	newObj = null;
l2:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, header2 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	return newObj;
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
	Will *not* cause a GC.
	Note that the instantiated object IS NOT FILLED and must be completed
	before returning it to Smalltalk. Since this call is used in routines that
	do just that we are
	safe. Break this rule and die. */

	/* NewObjectMemory>>#eeInstantiateClass:indexableSize: */
sqInt
eeInstantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt cClass;
    sqInt classFormat;
    sqInt format;
    usqInt hash;
    int hdrSize;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeHiBits;


	/* cannot have a negative indexable field count */
	assert(size >= 0);
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());

	/* Low 2 bits are 0 */
	classFormat = (longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	header1 = (classFormat & 0x1FF00) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */
	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
	   to 4 bytes per field.  Need another shift for 8 bytes per word... */
	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = ((sqInt)((usqInt)(byteSize) << ((shiftForWord()) - 2)));
	format = (((usqInt) classFormat) >> (instFormatFieldLSB())) & 15;
	flag("sizeLowBits");
	if (format < (firstByteFormat())) {
		if (format == (firstLongFormat())) {

			/* long32 bitmaps */
			bm1 = BytesPerWord - 1;

			/* round up */
			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */
			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */
		bm1 = BytesPerWord - 1;

		/* round up */
		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */
		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
		header1 = header1 | (((sqInt)((usqInt)((binc & 3)) << (instFormatFieldLSB()))));
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 0xFF) {

		/* requires size header word */
		header3 = byteSize;
		header1 = header1;
	}
	else {
		header1 = header1 | byteSize;
	}
	hdrSize = (header3 > 0
		? 3
		: (cClass == 0
				? 2
				: 1));
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, header2 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	return newObj;
}


/*	This version of instantiateClass assumes that the total object 
	size is under 256 bytes, the limit for objects with only one or 
	two header words. Note that the size is specified in bytes 
	and should include four bytes for the base header word.
	Will *not* cause a GC. Result is guaranteed to be young. */

	/* NewObjectMemory>>#eeInstantiateMethodContextSlots: */
static sqInt NoDbgRegParms
eeInstantiateMethodContextSlots(sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    usqInt header1;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeInBytes;

	assert((numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots));
	sizeInBytes = (numSlots * BytesPerOop) + BaseHeaderSize;
	assert(sizeInBytes <= SizeMask);
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());
	header1 = ((hash & HashMaskUnshifted) << HashBitsOffset) | ((((int)((usqInt)(ClassMethodContextCompactIndex) << 12))) + (((sqInt)((usqInt)((indexablePointersFormat())) << (instFormatFieldLSB())))));
	assert((header1 & CompactClassMask) > 0);
	assert((header1 & SizeMask) == 0);
	header1 += sizeInBytes;
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes + ((1 - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	longAtput(newObj, header1 | HeaderTypeShort);

	return newObj;
}


/*	This version of instantiateClass assumes that the total object size is
	under 256 bytes, the limit for objects with only one or two header words. 
	NOTE this code will only work for sizes that are an integral number of
	words (hence not a 32-bit LargeInteger in a 64-bit system).
	Note that the created small object IS NOT FILLED and must be completed
	before returning it to Squeak.
	Since this call is used in routines that do just that we are safe. Break
	this rule and die in GC.
	Will *not* cause a GC. Result is guaranteed to be young. */
/*	cannot have a negative indexable field count */

	/* NewObjectMemory>>#eeInstantiateSmallClassIndex:format:numSlots: */
static sqInt NoDbgRegParms
eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    sqInt header1;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeInBytes;

	assert((numSlots >= 0)
	 && (compactClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(compactClassAt(compactClassIndex))));
	sizeInBytes = (((sqInt)((usqInt)(numSlots) << (shiftForWord())))) + BaseHeaderSize;
	assert(sizeInBytes <= 0xFC);
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());
	header1 = ((((sqInt)((usqInt)(objFormat) << (instFormatFieldLSB())))) | (((sqInt)((usqInt)(compactClassIndex) << 12)))) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes + ((1 - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	longAtput(newObj, header1 | HeaderTypeShort);

	return newObj;
}


/*	This version of instantiateClass assumes that the total object size is
	under 256 bytes, the limit for objects with only one or two header words. 
	NOTE this code will only work for sizes that are an integral number of
	words (hence not a 32-bit LargeInteger in a 64-bit system).
	Note that the created small object IS NOT FILLED and must be completed
	before returning it to Squeak.
	Since this call is used in routines that do just that we are safe. Break
	this rule and die in GC.
	Will *not* cause a GC. Result is guaranteed to be young. */

	/* NewObjectMemory>>#eeInstantiateSmallClass:numSlots: */
static sqInt NoDbgRegParms
eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    int hdrSize;
    usqInt header1;
    sqInt header2;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeInBytes;

	sizeInBytes = (((sqInt)((usqInt)(numSlots) << (shiftForWord())))) + BaseHeaderSize;
	assert(sizeInBytes <= 0xFC);
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());
	header1 = ((hash & HashMaskUnshifted) << HashBitsOffset) | ((longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1);
	header2 = classPointer;
	hdrSize = ((header1 & CompactClassMask) > 0
		? 1
		: 2);
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));
	/* begin eeAllocate:headerSize:h1:h2:h3: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (newObj == 0) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, 0 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, header2 | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	return newObj;
}


/*	Compatibility with SpurObjectMemory. In ObjectMemory there is no
	distinction between a
	classTag in the first-level method cache and a class itself. */

	/* NewObjectMemory>>#fetchClassTagOfNonImm: */
static sqInt NoDbgRegParms
fetchClassTagOfNonImm(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;

	return (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))));
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */

	/* NewObjectMemory>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt cssz;
    sqInt header;
    sqInt obj;
    sqInt sz;

	cssz = strlen(aCString);
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			if ((((((usqInt) (longAt(obj))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))
			 && (((lengthOf(obj)) >= cssz)
			 && ((strncmp(aCString, pointerForOop(obj + BaseHeaderSize), cssz)) == 0))) {
				printHex(obj);
				/* begin space */
				putchar(' ');
				printNum(lengthOf(obj));
				/* begin space */
				putchar(' ');
				printOopShort(obj);
				/* begin cr */
				printf("\n");
			}
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* NewObjectMemory>>#findString: */
void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt cssz;
    sqInt header;
    sqInt obj;
    sqInt sz;

	cssz = strlen(aCString);
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			if ((((((usqInt) (longAt(obj))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))
			 && (((lengthOf(obj)) == cssz)
			 && ((strncmp(aCString, pointerForOop(obj + BaseHeaderSize), cssz)) == 0))) {
				printHex(obj);
				/* begin space */
				putchar(' ');
				printOopShort(obj);
				/* begin cr */
				printf("\n");
			}
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
}

	/* NewObjectMemory>>#floatObjectOf: */
sqInt
floatObjectOf(double aFloat)
{
    sqInt newFloatObj;

	newFloatObj = eeInstantiateSmallClassIndexformatnumSlots(ClassFloatCompactIndex, firstLongFormat(), (sizeof(double)) / BytesPerOop);
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* NewObjectMemory>>#floatValueOf: */
double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double result;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Do a mark/sweep garbage collection of the entire object memory.
	Free inaccessible objects but do not move them. */

	/* NewObjectMemory>>#fullGC */
void
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt freeSizeNow;
    sqInt limit;
    sqInt limit1;
    sqInt newMemoryLimit;
    sqInt newMemoryLimit1;
    sqInt sz;

	if (GIV(fullGCLock) > 0) {
		warning("aborting fullGC because fullGCLock > 0");
		return;
	}
	runLeakCheckerFor(GCModeFull);
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statSweepCount) = (GIV(statMarkCount) = (GIV(statMkFwdCount) = (GIV(statCompMoveCount) = 0)));
	clearRootsTable();
	/* begin initWeakTableForIncrementalGC: */
	GIV(weakRootCount) = -1;

	/* process all of memory */
	GIV(youngStart) = startOfMemory();
	markPhase(1);
	GIV(totalObjectCount) = sweepPhaseForFullGC();
	runLeakCheckerFor(GCModeFull);
	/* begin fullCompaction */
	assert(GIV(compStart) == (lowestFreeAfter(startOfMemory())));
	if (GIV(compStart) == GIV(freeStart)) {

		/* memory is already compact; only free chunk is at the end */
		initializeMemoryFirstFree(GIV(freeStart));
		goto l1;
	}
	if (((sz = fwdTableSize(8))) < GIV(totalObjectCount)) {

		/* Try to grow OM to make a single pass full GC */
		/* begin growObjectMemory: */
		delta = ((GIV(totalObjectCount) - sz) + 10000) * 8;
		GIV(statGrowMemory) += 1;
		limit1 = sqGrowMemoryBy(GIV(memoryLimit), delta);
		if (!(limit1 == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit1 = limit1 - 24;
			assert((newMemoryLimit1 & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit1;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}
	while (GIV(compStart) < GIV(freeStart)) {

		/* free chunk returned by incCompBody becomes start of next compaction */
		GIV(compStart) = incCompBody();
	}
l1:	/* end fullCompaction */;
	GIV(statFullGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);

	/* reset the young object boundary */
	GIV(youngStart) = GIV(freeStart);
	/* begin attemptToShrink */
	freeSizeNow = (oopisLessThan(GIV(freeStart), GIV(reserveStart))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {
		/* begin shrinkObjectMemory: */
		GIV(statShrinkMemory) += 1;
		limit = sqShrinkMemoryBy(GIV(memoryLimit), freeSizeNow - GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}
	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	runLeakCheckerFor(GCModeFull);
}


/*	Set the limits for a table of two- or three-word forwarding blocks above
	the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used
	for compaction of memory and become-ing objects. Returns the number of
	forwarding blocks available.
 */
/*	set endOfMemory to just after a minimum-sized free block */

	/* NewObjectMemory>>#fwdTableInit: */
static sqInt NoDbgRegParms
fwdTableInit(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newEndOfMemory;

	/* begin setSizeOfFree:to: */
	longAtput(GIV(freeStart), (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	/* begin setEndOfMemory: */
	newEndOfMemory = GIV(freeStart) + BaseHeaderSize;
	assert((newEndOfMemory & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = newEndOfMemory;
	if (GIV(freeStart) == null) {
		GIV(freeStart) = newEndOfMemory;
	}
	/* begin setSizeOfFree:to: */
	longAtput(GIV(endOfMemory), (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	GIV(fwdTableNext) = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */
	GIV(fwdTableLast) = GIV(memoryLimit) - blkSize;
	return (GIV(fwdTableLast) - GIV(fwdTableNext)) / blkSize;
}


/*	Estimate the number of forwarding blocks available for compaction */

	/* NewObjectMemory>>#fwdTableSize: */
static sqInt NoDbgRegParms
fwdTableSize(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt eom;
    usqInt fwdFirst;
    sqInt fwdLast;


	/* use all memory free between freeStart and memoryLimit for forwarding table */
	/* Note: Forward blocks must be quadword aligned. */
	eom = GIV(freeStart) + BaseHeaderSize;
	fwdFirst = ((eom + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */
	fwdLast = GIV(memoryLimit) - blkSize;
	return (fwdLast - fwdFirst) / blkSize;
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine it came from. Low half of word is 6502. Top byte
	is top byte of #doesNotUnderstand: on this machine. ($d on the Mac or $s
	on the PC)
 */

	/* NewObjectMemory>>#imageSegmentVersion */
static usqInt
imageSegmentVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt wholeWord;


	/* first data word, 'does' */
	wholeWord = longAt((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))) + BaseHeaderSize);
	return (6505) | (wholeWord & 0xFF000000U);
}


/*	Move objects to consolidate free space into one big chunk. Return the
	newly created free chunk.
 */

	/* NewObjectMemory>>#incCompBody */
static usqInt
incCompBody(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToBeFreed;


	/* reserve memory for forwarding table */
	fwdTableInit(BytesPerWord * 2);

	/* update pointers to point at new oops */
	bytesToBeFreed = incCompMakeFwd();
	mapPointersInObjectsFromto(GIV(youngStart), GIV(freeStart));
	return incCompMove(bytesToBeFreed);
}


/*	Create and initialize forwarding blocks for all non-free objects 
	following compStart. If the supply of forwarding blocks is exhausted, 
	set compEnd to the first chunk above the area to be compacted;
	otherwise, set it to endOfMemory. Return the number of bytes to be freed. */

	/* NewObjectMemory>>#incCompMakeFwd */
static sqInt
incCompMakeFwd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToBeFreed;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt header;
    sqInt header1;
    sqInt newOop;
    sqInt oop;
    sqInt originalHeader;
    sqInt originalHeaderType;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;

	bytesToBeFreed = 0;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	assert(oopisGreaterThanandLessThan(oop, startOfMemory(), GIV(freeStart)));
	while (oopisLessThan(oop, GIV(freeStart))) {
		GIV(statMkFwdCount) += 1;
		assert(oopisGreaterThanandLessThan(oop, startOfMemory(), GIV(freeStart)));
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			bytesToBeFreed += (longAt(oop)) & AllButTypeMask;
		}
		else {

			/* create a forwarding block for oop */
			/* begin fwdBlockGet: */
			GIV(fwdTableNext) += BytesPerWord * 2;
			if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
				fwdBlock = GIV(fwdTableNext);
				goto l1;
			}
			else {
				fwdBlock = null;
				goto l1;
			}
		l1:	/* end fwdBlockGet: */;
			if (fwdBlock == null) {

				/* stop; we have used all available forwarding blocks */
				GIV(compEnd) = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
				return bytesToBeFreed;
			}
			newOop = oop - bytesToBeFreed;
			assert(oopisGreaterThanandLessThan(newOop, startOfMemory(), GIV(freeStart)));
			/* begin initForwardBlock:mapping:to:withBackPtr: */
			assert(fwdBlock != null);
			assert(!((hasForwardingBlock(oop))));
			originalHeader = longAt(oop);
			originalHeaderType = originalHeader & TypeMask;
			longAtput(fwdBlock, newOop);
			longAtput(fwdBlock + BytesPerWord, originalHeader);
			longAtput(oop, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType));
		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l3;
		}
		fwdBlock1 = ((sqInt)((usqInt)((header & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock1));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock1 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l3:	/* end objectAfterWhileForwarding: */;
	}
	GIV(compEnd) = GIV(freeStart);
	return bytesToBeFreed;
}


/*	Move all non-free objects between compStart and compEnd to their new 
	locations, restoring their headers in the process. Create a new free 
	block at the end of memory. Return the newly created free chunk. */
/*	Note: The free block used by the allocator always must be the last free 
	block in memory. It may take several compaction passes to make all 
	free space bubble up to the end of memory. */

	/* NewObjectMemory>>#incCompMove: */
static usqInt NoDbgRegParms
incCompMove(sqInt bytesFreed)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToMove;
    usqInt firstWord;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header2;
    sqInt header3;
    usqInt lastWord;
    usqInt newFreeChunk;
    sqInt newOop;
    sqInt next;
    sqInt oop;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt sz3;
    sqInt target;
    usqInt w;

	newOop = null;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	while (oopisLessThan(oop, GIV(compEnd))) {
		GIV(statCompMoveCount) += 1;
		/* begin objectAfterWhileForwarding: */
		header2 = longAt(oop);
		if ((header2 & MarkBit) == 0) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header11 = longAt(oop);
				sz1 = ((header11 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header11 & SizeMask);
			}
			next = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l3;
		}
		fwdBlock1 = ((sqInt)((usqInt)((header2 & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock1));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock1 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz2 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz2 = realHeader & SizeMask;
		}
		next = (oop + sz2) + (headerTypeBytes[(longAt(oop + sz2)) & TypeMask]);
	l3:	/* end objectAfterWhileForwarding: */;
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {

			/* a moving object; unwind its forwarding block */
			fwdBlock = ((sqInt)((usqInt)(((longAt(oop)) & AllButMarkBitAndTypeMask)) << 1));
			assert(fwdBlockValid(fwdBlock));
			newOop = longAt(fwdBlock);
			header = longAt(fwdBlock + BytesPerWord);
			longAtput(oop, header);

			/* move the oop (including any extra header words) */
			bytesToMove = oop - newOop;
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
			firstWord = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
			lastWord = (oop + sz) - BaseHeaderSize;
			target = firstWord - bytesToMove;
			for (w = firstWord; w <= lastWord; w += BytesPerWord) {
				longAtput(target, longAt(w));
				target += BytesPerWord;
			}
		}
		oop = next;
	}
	if (newOop == null) {

		/* no objects moved */
		oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
		if ((((longAt(oop)) & TypeMask) == HeaderTypeFree)
		 && ((objectAfter(oop)) == (GIV(compEnd) + (headerTypeBytes[(longAt(GIV(compEnd))) & TypeMask])))) {
			newFreeChunk = oop;
		}
		else {
			newFreeChunk = GIV(freeStart);
		}
	}
	else {

		/* initialize the newly freed memory chunk */
		/* newOop is the last object moved; free chunk starts right after it */
		newFreeChunk = newOop + (sizeBitsOf(newOop));
		/* begin setSizeOfFree:to: */
		longAtput(newFreeChunk, (bytesFreed & AllButTypeMask) | HeaderTypeFree);
	}
	/* begin safeObjectAfter: */
	if (((longAt(newFreeChunk)) & TypeMask) == HeaderTypeFree) {
		sz3 = (longAt(newFreeChunk)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header3 = longAt(newFreeChunk);
		sz3 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(newFreeChunk - (BytesPerWord * 2))) & LongSizeMask
			: header3 & SizeMask);
	}
	next = ((((usqInt)(newFreeChunk + sz3))) >= GIV(freeStart)
		? ((sqInt)GIV(freeStart))
		: (newFreeChunk + sz3) + (headerTypeBytes[(longAt(newFreeChunk + sz3)) & TypeMask]));
	assert((next == GIV(freeStart))
	 || (next == (oopFromChunk(GIV(compEnd)))));
	if (next == GIV(freeStart)) {
		initializeMemoryFirstFree(newFreeChunk);
	}
	else {

		/* newFreeChunk is not at end of memory; re-install freeStart.
		   This will be the case when a compaction needs more than one pass. */
		initializeMemoryFirstFree(GIV(freeStart));
	}
	return newFreeChunk;
}


/*	Do a mark/sweep garbage collection of just the young object
	area of object memory (i.e., objects above youngStart), using
	the root table to identify objects containing pointers to
	young objects from the old object area. */

	/* NewObjectMemory>>#incrementalGC */
void
incrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt freeSizeNow;
    sqInt growth;
    sqInt i;
    sqInt limit;
    sqInt limit1;
    sqInt newMemoryLimit;
    sqInt newMemoryLimit1;
    sqInt survivorCount;
    sqInt weDidGrow;

	if (GIV(rootTableOverflowed)) {

		/* root table overflow; cannot do an incremental GC because some roots are missing.
		   (this should be very rare) */
		GIV(statRootTableOverflows) += 1;
		fullGC();
		return;
	}
	runLeakCheckerFor(GCModeNewSpace);
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statSweepCount) = (GIV(statMarkCount) = (GIV(statMkFwdCount) = (GIV(statCompMoveCount) = 0)));
	/* begin initWeakTableForIncrementalGC: */
	GIV(weakRootCount) = 0;
	markPhase(0);
	assert(GIV(weakRootCount) <= WeakRootTableSize);
	for (i = 1; i <= GIV(weakRootCount); i += 1) {
		finalizeReference(GIV(weakRoots)[i]);
	}
	survivorCount = sweepPhase();
	runLeakCheckerFor(GCModeNewSpace);
	/* begin incrementalCompaction */
	if (GIV(compStart) == GIV(freeStart)) {

		/* Note: If compStart = freeStart then either the young
		   space is already compact  or there are enough forwarding table entries to do a
		   one-pass incr. compaction. */
		initializeMemoryFirstFree(GIV(freeStart));
	}
	else {
		incCompBody();
	}
	GIV(statIncrGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statIGCDeltaUsecs) = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statIncrGCUsecs) += GIV(statIGCDeltaUsecs);
	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);
	GIV(statRootTableCount) = GIV(rootTableCount);
	GIV(statSurvivorCount) = survivorCount;
	weDidGrow = 0;
	if (((survivorCount > GIV(tenuringThreshold))
	 || (GIV(rootTableCount) >= RootTableRedZone))
	 || (GIV(forceTenureFlag) == 1)) {

		/* move up the young space boundary if
		   * there are too many survivors:
		   this limits the number of objects that must be
		   processed on future incremental GC's
		   * we're about to overflow the roots table:
		   this limits the number of full GCs that may be caused
		   by root table overflows in the near future */
		GIV(forceTenureFlag) = 0;
		GIV(statTenures) += 1;
		clearRootsTable();
		if ((((oopisLessThan(GIV(freeStart), GIV(reserveStart))
			? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
			: 0)) < GIV(growHeadroom))
		 && (GIV(gcBiasToGrow) > 0)) {
			/* begin biasToGrow */
			delta = ((GIV(growHeadroom) * 3) / 2) - ((oopisLessThan(GIV(freeStart), GIV(reserveStart))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0));
			GIV(statGrowMemory) += 1;
			limit1 = sqGrowMemoryBy(GIV(memoryLimit), delta);
			if (!(limit1 == GIV(memoryLimit))) {
				/* begin setMemoryLimit: */
				newMemoryLimit1 = limit1 - 24;
				assert((newMemoryLimit1 & (BytesPerWord - 1)) == 0);
				GIV(memoryLimit) = newMemoryLimit1;
				initializeMemoryFirstFree(GIV(freeStart));
			}
			weDidGrow = 1;
		}
		GIV(youngStart) = GIV(freeStart);
	}
	/* begin attemptToShrink */
	freeSizeNow = (oopisLessThan(GIV(freeStart), GIV(reserveStart))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {
		/* begin shrinkObjectMemory: */
		GIV(statShrinkMemory) += 1;
		limit = sqShrinkMemoryBy(GIV(memoryLimit), freeSizeNow - GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}
	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	runLeakCheckerFor(GCModeNewSpace);
	if (weDidGrow) {
		/* begin biasToGrowCheckGCLimit */
		growth = (GIV(youngStart) - (startOfMemory())) - GIV(gcBiasToGrowThreshold);
		if (growth < 0) {
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - GIV(memory);
		}
		if (growth > GIV(gcBiasToGrowGCLimit)) {
			fullGC();
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - GIV(memory);
		}
	}
}


/*	Initialize endOfMemory to the top of oop storage space, reserving some
	space for forwarding blocks, and set freeStart from which space is
	allocated. 
 */
/*	Note: The amount of space reserved for forwarding blocks should be chosen
	to ensure that incremental compactions can usually be done in a single
	pass. However, there should be enough forwarding blocks so a full
	compaction can be done
	in a reasonable number of passes, say ten. (A full compaction requires N
	object-moving passes, where N = number of non-garbage objects / number of
	forwarding blocks).
	
	di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object
	to be
	used for forwarding pointers at GC time. Since fwd blocks are 8 bytes,
	this means
	an absolute worst case of 8 passes to compact memory. In most cases it
	will be
	adequate to do compaction in a single pass. */
/*	reserve space for forwarding blocks and the interpreter. We can sacrifice
	forwarding block space at the cost of slower compactions but we cannot
	safely sacrifice interpreter allocation headroom. */

	/* NewObjectMemory>>#initializeMemoryFirstFree: */
static void NoDbgRegParms
initializeMemoryFirstFree(sqInt firstFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    sqInt fwdBlockBytes;
    sqInt newEndOfMemory;
    usqInt p;
    usqInt start;
    sqInt totalReserve;

	fwdBlockBytes = GIV(totalObjectCount) & ((WordMask - BytesPerWord) + 1);
	totalReserve = fwdBlockBytes + (interpreterAllocationReserveBytes());
	if (oopisLessThan(GIV(memoryLimit) - totalReserve, firstFree + BaseHeaderSize)) {

		/* reserve enough space for a minimal free block of BaseHeaderSize bytes.
		   We are apparently in an emergency situation here because we have no space
		   for reserve and forwarding blocks.  But a full GC will occur immediately in
		   sufficientSpaceAfterGC: which will grow memory and restore the reserve. */
		fwdBlockBytes = GIV(memoryLimit) - (firstFree + BaseHeaderSize);
	}
	/* begin setEndOfMemory: */
	newEndOfMemory = GIV(memoryLimit) - fwdBlockBytes;
	assert((newEndOfMemory & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = newEndOfMemory;
	if (GIV(freeStart) == null) {
		GIV(freeStart) = newEndOfMemory;
	}
	GIV(reserveStart) = GIV(endOfMemory) - (interpreterAllocationReserveBytes());

	/* bytes available for oops */
	GIV(freeStart) = firstFree;
	GIV(scavengeThreshold) = (((GIV(freeStart) + GIV(edenBytes)) < GIV(reserveStart)) ? (GIV(freeStart) + GIV(edenBytes)) : GIV(reserveStart));
	/* begin maybeFillWithAllocationCheckFillerFrom:to: */
	start = GIV(freeStart);
	end = GIV(scavengeThreshold);
	if (checkAllocFiller()) {
		for (p = start; p <= end; p += BytesPerWord) {
			longAtput(p, p);
		}
	}
	assert(oopisLessThan(GIV(freeStart), GIV(reserveStart)));
	assert(oopisLessThan(GIV(endOfMemory), GIV(memoryLimit)));
}


/*	Initialize object memory variables at startup time. Assume endOfMemory is
	initially set (by the image-reading code) to the end of the last object in
	the image. Initialization redefines endOfMemory to be the end of the
	object allocation area based on the total available memory, but reserving
	some space for forwarding blocks.
 */
/*	Assume: image reader initializes the following variables:
	memory
	endOfMemory
	memoryLimit
	specialObjectsOop
	lastHash
	 */
/*	di 11/18/2000 fix slow full GC */
/*	set the start of the young object space */

	/* NewObjectMemory>>#initializeObjectMemory: */
static void NoDbgRegParms
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* image may be at a different address; adjust oops for new location */
	GIV(youngStart) = (GIV(freeStart) = GIV(endOfMemory));
	GIV(totalObjectCount) = adjustAllOopsBy(bytesToShift);
	initializeMemoryFirstFree(GIV(endOfMemory));

	/* heavily used special objects */
	GIV(specialObjectsOop) += bytesToShift;
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(NilObject) << (shiftForWord())))));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(FalseObject) << (shiftForWord())))));
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TrueObject) << (shiftForWord())))));
	GIV(rootTableCount) = 0;
	GIV(rootTableOverflowed) = 0;
	GIV(lowSpaceThreshold) = 0;
	GIV(signalLowSpace) = 0;
	GIV(compStart) = 0;
	GIV(compEnd) = 0;
	GIV(fwdTableNext) = 0;
	GIV(fwdTableLast) = 0;
	GIV(remapBufferCount) = 0;

	/* tenure all suriving objects if survivor count is over this threshold */
	GIV(tenuringThreshold) = 2000;

	/* four megabytes of headroom when growing */
	GIV(growHeadroom) = (4 * 1024) * 1024;

	/* eight megabytes of free space before shrinking */
	/* garbage collection statistics */
	GIV(shrinkThreshold) = (8 * 1024) * 1024;
	GIV(statFullGCs) = 0;
	GIV(statFullGCUsecs) = 0;
	GIV(statIncrGCs) = 0;
	GIV(statIncrGCUsecs) = 0;
	GIV(statTenures) = 0;
	GIV(statRootTableOverflows) = 0;
	GIV(statGrowMemory) = 0;
	GIV(statShrinkMemory) = 0;
	GIV(forceTenureFlag) = 0;
	GIV(gcBiasToGrow) = 0;
	GIV(gcBiasToGrowGCLimit) = 0;
	GIV(extraRootCount) = 0;
}


/*	c.f. {BlockContext. MethodContext. PseudoContext} collect: [:class| class
	-> class indexIfCompact]
 */

	/* NewObjectMemory>>#isContextHeader: */
static sqInt NoDbgRegParms
isContextHeader(sqInt aHeader)
{
	return ((((usqInt) aHeader) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex;
}


/*	Answer if obj is young. Assume obj is non-immediate. */

	/* NewObjectMemory>>#isYoungObject: */
sqInt
isYoungObject(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(obj));
	return oopisGreaterThanOrEqualTo(obj, GIV(youngStart));
}


/*	Return the byte offset of the last pointer field of the given object. 
	Can be used even when the type bits are not correct.
	Works with CompiledMethods, as well as ordinary objects. */

	/* NewObjectMemory>>#lastPointerOf: */
sqInt
lastPointerOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    sqInt sp;

	header = longAt(objOop);
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * BytesPerOop;
		}
		return (sizeBitsOfSafe(objOop)) - BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	assert(isCompiledMethod(objOop));
	header = longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	return (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* NewObjectMemory>>#leakCheckBecome */
sqInt
leakCheckBecome(void)
{
	return (checkForLeaks & GCModeBecome) != 0;
}

	/* NewObjectMemory>>#leakCheckFullGC */
sqInt
leakCheckFullGC(void)
{
	return (checkForLeaks & GCModeFull) != 0;
}

	/* NewObjectMemory>>#leakCheckNewSpaceGC */
sqInt
leakCheckNewSpaceGC(void)
{
	return (checkForLeaks & 2) != 0;
}

	/* NewObjectMemory>>#literalCountOfMethodHeader: */
sqInt
literalCountOfMethodHeader(sqInt methodHeader)
{
	assert((methodHeader & 1));
	return ((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF);
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed. It will return as its
	value the original array of roots, and the erstwhile segmentWordArray will
	have been truncated to a size of one word, i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to an unrecognizable and unusable jumble. But what more
	could you have done with it anyway?
 */

	/* NewObjectMemory>>#loadImageSegmentFrom:outPointers: */
static sqInt NoDbgRegParms
loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt addr2;
    sqInt data;
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    sqInt fmt;
    sqInt hdrTypeBits;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt header4;
    usqInt lastOut;
    usqInt lastPtr;
    sqInt mapOop;
    sqInt oop;
    sqInt oop1;
    usqInt outPtr;
    usqInt segOop;
    sqInt stopAddr;
    sqInt stopAddr1;
    sqInt stopAddr11;
    sqInt stopAddr2;
    sqInt stopAddr3;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt sz3;
    sqInt temp;
    sqInt temp1;
    sqInt wordAddr;

	hdrTypeBits = 0;
	lastOut = outPointerArray + (lastPointerOf(outPointerArray));

	/* Version check.  Byte order of the WordArray now */
	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BaseHeaderSize;
	data = longAt(segmentWordArray + BaseHeaderSize);
	if (!(((data & 0xFFFF) == (6505))
		 || ((data & 0xFFFF) == ((BytesPerWord == 4
			? 6504
			: 68002))))) {

		/* low 2 bytes */
		/* Not readable -- try again with reversed bytes... */
		/* begin reverseBytesFrom:to: */
		stopAddr1 = endSeg + BytesPerWord;
		addr1 = segmentWordArray + BaseHeaderSize;
		while (oopisLessThan(addr1, stopAddr1)) {
			longAtput(addr1, 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES((longAt(addr1)))
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES((longAt(addr1)))
#      endif /* BytesPerWord == 4 */
				);
			addr1 += BytesPerWord;
		}
		data = longAt(segmentWordArray + BaseHeaderSize);
		if (!(((data & 0xFFFF) == (6505))
			 || ((data & 0xFFFF) == ((BytesPerWord == 4
				? 6504
				: 68002))))) {

			/* low 2 bytes */
			/* Still NG -- put things back and fail */
			/* begin reverseBytesFrom:to: */
			stopAddr = endSeg + BytesPerWord;
			addr = segmentWordArray + BaseHeaderSize;
			while (oopisLessThan(addr, stopAddr)) {
				longAtput(addr, 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES((longAt(addr)))
#        else /* BytesPerWord == 4 */
					SQ_SWAP_8_BYTES((longAt(addr)))
#        endif /* BytesPerWord == 4 */
					);
				addr += BytesPerWord;
			}
			return PrimErrBadArgument;
		}
	}
	if ((((usqInt) data) >> 16) == (((usqInt) (imageSegmentVersion())) >> 16)) {

		/* Need to swap floats if the segment is being loaded into a little-endian VM from a version
		   that keeps Floats in big-endian word order as was the case prior to the 6505 image format. */
		if (!((data & 0xFFFF) >= 6505)) {

			/* low 2 bytes */
			if (((VMBIGENDIAN
				? 1
				: 0)) != 1) {

				/* ~= 1 => little-endian */
				segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
				/* begin wordSwapFloatsFrom:to: */
				stopAddr2 = endSeg + BytesPerWord;
				oop = segOop;
				while (oopisLessThan(oop, stopAddr2)) {
					if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
						if ((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()))
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex)) {
							temp = longAt(oop + BaseHeaderSize);
							longAtput(oop + BaseHeaderSize, longAt((oop + BaseHeaderSize) + 4));
							longAtput((oop + BaseHeaderSize) + 4, temp);
						}
					}
					/* begin objectAfter: */
					if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
						error("no objects after the end of memory");
					}
					if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
						sz = (longAt(oop)) & AllButTypeMask;
					}
					else {
						/* begin sizeBitsOf: */
						header1 = longAt(oop);
						sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
							? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
							: header1 & SizeMask);
					}
					oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
				}
			}
		}
	}
	else {

		/* Reverse the byte-type objects once */

		/* Oop of first embedded object */
		segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
		/* begin byteSwapByteObjectsFrom:to:flipFloatsIf: */
		stopAddr3 = endSeg + BytesPerWord;
		oop1 = segOop;
		while (oopisLessThan(oop1, stopAddr3)) {
			if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
				fmt = (((usqInt) (longAt(oop1))) >> (instFormatFieldLSB())) & 15;
				if (fmt >= (firstByteFormat())) {

					/* oop contains bytes; unswap */
					wordAddr = oop1 + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat())) {

						/* compiled method; start after methodHeader and literals */
						wordAddr += (((assert((((assert(isCompiledMethod(oop1)),
longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(oop1)),
longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(oop1)),
longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(oop1)),
			longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop;
					}
					/* begin reverseBytesFrom:to: */
					stopAddr11 = oop1 + (sizeBitsOf(oop1));
					addr2 = wordAddr;
					while (oopisLessThan(addr2, stopAddr11)) {
						longAtput(addr2, 
#            if BytesPerWord == 4
							SQ_SWAP_4_BYTES((longAt(addr2)))
#            else /* BytesPerWord == 4 */
							SQ_SWAP_8_BYTES((longAt(addr2)))
#            endif /* BytesPerWord == 4 */
							);
						addr2 += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat())) {

					/* Bitmap, Float etc */
					if (((((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex) {
						if ((data & 0xFFFF) >= 6505) {
							temp1 = longAt(oop1 + BaseHeaderSize);
							longAtput(oop1 + BaseHeaderSize, longAt((oop1 + BaseHeaderSize) + 4));
							longAtput((oop1 + BaseHeaderSize) + 4, temp1);
						}
					}
					else {
											}
				}
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop1, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header2 = longAt(oop1);
				sz1 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
					: header2 & SizeMask);
			}
			oop1 = (oop1 + sz1) + (headerTypeBytes[(longAt(oop1 + sz1)) & TypeMask]);
		}
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type = 0 or 1) -- start with that. */
			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */
			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */
		lastPtr = segOop + (lastPointerOf(segOop));
		if (lastPtr > endSeg) {
			return PrimErrBadIndex;
		}
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */
			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = (longAt(fieldPtr)) & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Integer -- nothing to do */
				fieldPtr += BytesPerWord;
			}
			else {
				if (!((fieldOop & 3) == 0)) {
					return PrimErrBadIndex;
				}
				if ((fieldOop & 0x80000000U) == 0) {

					/* Internal pointer -- add segment offset */
					mapOop = fieldOop + segmentWordArray;
				}
				else {

					/* External pointer -- look it up in outPointers */
					outPtr = outPointerArray + (fieldOop & 0x7FFFFFFF);
					if (outPtr > lastOut) {
						return PrimErrBadIndex;
					}
					mapOop = longAt(outPtr);
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += 8;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
				if (segOop < GIV(youngStart)) {
					possibleRootStoreIntovalue(segOop, mapOop);
				}
			}
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(segOop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header3 = longAt(segOop);
			sz2 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask
				: header3 & SizeMask);
		}
		segOop = (segOop + sz2) + (headerTypeBytes[(longAt(segOop + sz2)) & TypeMask]);
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (!(oopHasAcceptableClass(segOop))) {
			return PrimErrInappropriate;
		}

		/* first field */
		fieldPtr = segOop + BaseHeaderSize;

		/* last field */
		/* Go through all oops, remapping them... */
		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */
			fieldOop = longAt(fieldPtr);
			if (!(oopHasAcceptableClass(fieldOop))) {
				return PrimErrInappropriate;
			}
			fieldPtr += BytesPerWord;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(segOop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz3 = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header4 = longAt(segOop);
			sz3 = ((header4 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask
				: header4 & SizeMask);
		}
		segOop = (segOop + sz3) + (headerTypeBytes[(longAt(segOop + sz3)) & TypeMask]);
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	if (extraSize == 8) {
		longAtput(segmentWordArray - extraSize, (BaseHeaderSize + BytesPerWord) + hdrTypeBits);
	}
	else {
		header = longAt(segmentWordArray);
		longAtput(segmentWordArray, ((header - (header & SizeMask)) + BaseHeaderSize) + BytesPerWord);
	}
	return ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */

	/* NewObjectMemory>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt i;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt prntObj;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt sz3;

	prntObj = 0;
	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l11;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz3 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header3 = longAt(obj1);
			sz3 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header3 & SizeMask);
		}
		obj1 = (obj1 + sz3) + (headerTypeBytes[(longAt(obj1 + sz3)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l11:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
		 || (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
			if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
				i = ((assert((((assert(isCompiledMethod(oop)),
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(oop)),
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(oop)),
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(oop)),
			longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart;
			}
			else {
				if (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(oop));
				}
				else {
					/* begin lengthOf: */
					header = longAt(oop);
					/* begin lengthOf:baseHeader:format: */
					fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz = header & SizeMask;
					}
					sz -= header & Size4Bit;
					if (fmt <= 4) {
						i = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
						goto l2;
					}
					i = (fmt < (firstByteFormat())
						? ((usqInt) (sz - BaseHeaderSize)) >> 2
						: (sz - BaseHeaderSize) - (fmt & 3));
				l2:	/* end lengthOf: */;
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(oop);
			}
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l7;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz2 = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header2 = longAt(obj);
				sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header2 & SizeMask);
			}
			obj = (obj + sz2) + (headerTypeBytes[(longAt(obj + sz2)) & TypeMask]);
		}
		oop = null;
	l7:	/* end accessibleObjectAfter: */;
	}
}


/*	Use the forwarding table to update the pointers of all non-free objects in
	the given range of memory.
	Also remap pointers in root objects which may contains pointers into the
	given memory range, and
	don't forget to flush the method cache based on the range. */

	/* NewObjectMemory>>#mapPointersInObjectsFrom:to: */
static void NoDbgRegParms
mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt oop;
    sqInt probe;

	if (((GIV(nilObj) & 1) == 0)
	 && (((longAt(GIV(nilObj))) & MarkBit) != 0)) {
		GIV(nilObj) = remapObj(GIV(nilObj));
	}
	if (((GIV(falseObj) & 1) == 0)
	 && (((longAt(GIV(falseObj))) & MarkBit) != 0)) {
		GIV(falseObj) = remapObj(GIV(falseObj));
	}
	if (((GIV(trueObj) & 1) == 0)
	 && (((longAt(GIV(trueObj))) & MarkBit) != 0)) {
		GIV(trueObj) = remapObj(GIV(trueObj));
	}
	if (((GIV(specialObjectsOop) & 1) == 0)
	 && (((longAt(GIV(specialObjectsOop))) & MarkBit) != 0)) {
		GIV(specialObjectsOop) = remapObj(GIV(specialObjectsOop));
	}
	mapInterpreterOops();
	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if ((((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheSelector], memStart))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheSelector], memEnd)))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheClass], memStart))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheClass], memEnd))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheMethod], memStart))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheMethod], memEnd)))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin remapRemapBufferAndExtraRoots */
	for (i2 = 1; i2 <= GIV(remapBufferCount); i2 += 1) {
		oop = GIV(remapBuffer)[i2];
		if (((oop & 1) == 0)
		 && (((oop & 1) == 0)
		 && (((longAt(oop)) & MarkBit) != 0))) {
			GIV(remapBuffer)[i2] = (remapObj(oop));
		}
	}
	for (i2 = 1; i2 <= GIV(extraRootCount); i2 += 1) {
		oop = (GIV(extraRoots)[i2])[0];
		if (!(((oop & 1))
			 || (((longAt(oop)) & TypeMask) == HeaderTypeFree))) {
			if (((oop & 1) == 0)
			 && (((longAt(oop)) & MarkBit) != 0)) {
				(GIV(extraRoots)[i2])[0] = (remapObj(oop));
			}
		}
	}
	updatePointersInRootObjectsFromto(memStart, memEnd);
	updatePointersInRangeFromto(memStart, memEnd);
}


/*	Mark phase of the mark and sweep garbage collector. Set 
	the mark bits of all reachable objects. Free chunks are 
	untouched by this process. */
/*	Assume: All non-free objects are initially unmarked. Root 
	objects were unmarked when they were made roots.
	(Make sure this stays true!!). */

	/* NewObjectMemory>>#markPhase: */
static void NoDbgRegParms
markPhase(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;
    sqInt statMarkCountPriorToStackPageFreeing;


	/* trace the interpreter's objects, including the active stacks
	   and special objects array */
	markAndTraceInterpreterOops(fullGCFlag);

	/* trace the roots */
	GIV(statSpecialMarkCount) = GIV(statMarkCount);
	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		markAndTrace(oop);
	}
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!(((oop & 1))
			 || (((longAt(oop)) & TypeMask) == HeaderTypeFree))) {
			markAndTrace(oop);
		}
	}

	/* Only safe to free stack pages after all roots have been traced. */
	statMarkCountPriorToStackPageFreeing = GIV(statMarkCount);
	markAndTraceAndMaybeFreeStackPages(fullGCFlag);
	GIV(statSpecialMarkCount) += GIV(statMarkCount) - statMarkCountPriorToStackPageFreeing;
}

	/* NewObjectMemory>>#newSpaceBytes */
static sqInt
newSpaceBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin edenBytes */
	return GIV(edenBytes);
}


/*	Return the object or free chunk immediately following the 
	given object or free chunk in memory. Return endOfMemory 
	when enumeration is complete. */

	/* NewObjectMemory>>#objectAfter: */
sqInt
objectAfter(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt sz;

	if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
		error("no objects after the end of memory");
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
	}
	return (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* NewObjectMemory>>#okayOop: */
static sqInt NoDbgRegParms
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    usqInt oop;
    sqInt sz;
    sqInt type;
    sqInt unusedBit;


	/* address and size checks */
	oop = ((usqInt) signedOop);
	if ((oop & 1)) {
		return 1;
	}
	if (!((oop >= (startOfMemory()))
		 && (oop < GIV(freeStart)))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!((oop % BytesPerWord) == 0)) {
		error("oop is not a word-aligned address");
		return 0;
	}
	/* begin sizeBitsOf: */
	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	if (!((oop + sz) <= GIV(freeStart))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		error("oop is a free chunk, not an object");
		return 0;
	}
	if (type == HeaderTypeShort) {
		if (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == 0) {
			error("cannot have zero compact class field in a short header");
			return 0;
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= BytesPerWord)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	if (type == HeaderTypeSizeAndClass) {
		if (!((oop >= (BytesPerWord * 2))
			 && ((((longAt(oop - (BytesPerWord * 2))) & TypeMask) == type)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type)))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		error("oop has an unknown format type");
		return 0;
	}
	unusedBit = 0x20000000;
	if (!(((longAt(oop)) & unusedBit) == 0)) {
		error("unused header bit 30 is set; should be zero");
		return 0;
	}
	if ((((longAt(oop)) & RootBit) != 0)
	 && (oop >= GIV(youngStart))) {
		error("root bit is set in a young object");
		return 0;
	}
	return 1;
}


/*	Similar to oopHasOkayClass:, except that it only returns true or false. */

	/* NewObjectMemory>>#oopHasAcceptableClass: */
static sqInt NoDbgRegParms
oopHasAcceptableClass(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    sqInt ccIndex;
    int formatMask;
    usqInt oop;
    sqInt oop1;
    usqInt oopClass;
    sqInt oopFormatBits;

	if ((signedOop & 1)) {
		return 1;
	}
	oop = ((usqInt) signedOop);
	if (!(((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		return 0;
	}
	oopClass = ((usqInt) ((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
	? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
	: (/* begin fetchPointer:ofObject: */
		(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
		longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))));
	if (!(((oopClass & 3) == 0)
		 && (((((usqInt)oopClass)) >= (startOfMemory()))
		 && (((((usqInt)oopClass)) < GIV(freeStart))
		 && (((longAt(oopClass)) & TypeMask) != HeaderTypeGC))))) {
		return 0;
	}
	if (!((oopClass + (sizeBitsOf(oopClass))) <= GIV(freeStart))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oopClass))) >> (instFormatFieldLSB())) & 15) <= 4)
		 && ((lengthOf(oopClass)) >= 3))) {
		return 0;
	}
	formatMask = (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())
		? 3072
		: 3840);
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		return 0;
	}
	return 1;
}


/*	For forward-compatibility with Spur. Fail; ObjectMemory does not support
	pinning. 
 */

	/* NewObjectMemory>>#pinObject: */
sqInt
pinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
	return 0;
}


/*	Ensure that there are enough forwarding blocks to 
	accomodate this become, then prepare forwarding blocks for 
	the pointer swap. Return true if successful. */
/*	Details: Doing a GC might generate enough space for 
	forwarding blocks if we're short. However, this is an 
	uncommon enough case that it is better handled by primitive 
	fail code at the Smalltalk level. */
/*	Important note on multiple references to same object - since the
	preparation of
	fwdBlocks is NOT idempotent we get VM crashes if the same object is
	referenced more
	than once in such a way as to require multiple fwdBlocks.
	oop1 forwardBecome: oop1 is ok since only a single fwdBlock is needed.
	oop1 become: oop1 would fail because the second fwdBlock woudl not have
	the actual object
	header but rather the mutated ref to the first fwdBlock.
	Further problems can arise with an array1 or array2 that refer multiply to
	the same 
	object. This would notbe expected input for programmer writen code but
	might arise from
	automatic usage such as in ImageSegment loading.
	To avoid the simple and rather common case of oop1 become*: oop1, we skip
	such pairs
	and simply avoid making fwdBlocks - it is redundant anyway
 */

	/* NewObjectMemory>>#prepareForwardingTableForBecoming:with:twoWay: */
static sqInt NoDbgRegParms
prepareForwardingTableForBecomingwithtwoWay(sqInt array1, sqInt array2, sqInt twoWayFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt entriesAvailable;
    sqInt entriesNeeded;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt fwdBlkSize;
    sqInt fwdBlock;
    sqInt header;
    sqInt numLiterals;
    sqInt oop1;
    sqInt oop2;
    sqInt originalHeader;
    sqInt originalHeader1;
    sqInt originalHeaderType;
    sqInt originalHeaderType1;
    sqInt sp;


	/* need enough entries for all oops */
	/* Note: Forward blocks must be quadword aligned - see fwdTableInit:. */
	entriesNeeded = (lastPointerOf(array1)) / BytesPerWord;
	if (twoWayFlag) {

		/* Double the number of blocks for two-way become */
		entriesNeeded = entriesNeeded * 2;
		fwdBlkSize = BytesPerWord * 2;
	}
	else {

		/* One-way become needs backPointers in fwd blocks. */
		fwdBlkSize = BytesPerWord * 4;
	}
	entriesAvailable = fwdTableInit(fwdBlkSize);
	if (entriesAvailable < entriesNeeded) {
		initializeMemoryFirstFree(GIV(freeStart));
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l5;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
		l5:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l6;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l6;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l6;
	}
	assert(isCompiledMethod(array1));
	header = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l6:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(array1 + fieldOffset);

		/* if oop1 == oop2, no need to do any work for this pair.
		   May still be other entries in the arrays though so keep looking */
		oop2 = longAt(array2 + fieldOffset);
		if (oop1 != oop2) {
			if (!(((longAt(oop1)) & MarkBit) != 0)) {

				/* Don't allocate multiple forwarding entries for duplicates. */
				/* begin fwdBlockGet: */
				GIV(fwdTableNext) += fwdBlkSize;
				if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
					fwdBlock = GIV(fwdTableNext);
					goto l1;
				}
				else {
					fwdBlock = null;
					goto l1;
				}
			l1:	/* end fwdBlockGet: */;
				/* begin initForwardBlock:mapping:to:withBackPtr: */
				assert(fwdBlock != null);
				assert(!((hasForwardingBlock(oop1))));
				originalHeader = longAt(oop1);
				originalHeaderType = originalHeader & TypeMask;
				longAtput(fwdBlock, oop2);
				longAtput(fwdBlock + BytesPerWord, originalHeader);
				if (!twoWayFlag) {
					longAtput(fwdBlock + (BytesPerWord * 2), oop1);
				}
				longAtput(oop1, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType));
			}
			if (twoWayFlag
			 && (!(((longAt(oop2)) & MarkBit) != 0))) {

				/* Again don't get confused by duplicates */
				/* Second block maps oop2 back to oop1 for two-way become */
				/* begin fwdBlockGet: */
				GIV(fwdTableNext) += fwdBlkSize;
				if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
					fwdBlock = GIV(fwdTableNext);
					goto l2;
				}
				else {
					fwdBlock = null;
					goto l2;
				}
			l2:	/* end fwdBlockGet: */;
				/* begin initForwardBlock:mapping:to:withBackPtr: */
				assert(fwdBlock != null);
				assert(!((hasForwardingBlock(oop2))));
				originalHeader1 = longAt(oop2);
				originalHeaderType1 = originalHeader1 & TypeMask;
				longAtput(fwdBlock, oop1);
				longAtput(fwdBlock + BytesPerWord, originalHeader1);
				if (!twoWayFlag) {
					longAtput(fwdBlock + (BytesPerWord * 2), oop2);
				}
				longAtput(oop2, (((usqInt) fwdBlock) >> 1) | (MarkBit | originalHeaderType1));
			}
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */

	/* NewObjectMemory>>#printActivationsOf: */
void
printActivationsOf(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l9;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l9:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
		 && (aMethodObj == (longAt((oop + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))))))) {
			printHex(oop);
			/* begin space */
			putchar(' ');
			printOopShort(oop);
			print(" pc ");
			printHex(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))));
			/* begin cr */
			printf("\n");
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l5;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l5:	/* end accessibleObjectAfter: */;
	}
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */

	/* NewObjectMemory>>#printContextReferencesTo: */
void
printContextReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	i = 0;
	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l9;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l9:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
			i = CtxtTempFrameStart + (fetchStackPointerOf(oop));
		}
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
				printHex(oop);
				print(" @ ");
				printNum(i);
				/* begin space */
				putchar(' ');
				printOopShort(oop);
				print(" pc ");
				printHex(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))));
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l5;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l5:	/* end accessibleObjectAfter: */;
	}
}

	/* NewObjectMemory>>#printMemory */
void
printMemory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt length;
    sqInt length1;
    sqInt length2;
    sqInt length3;
    sqInt length4;
    sqInt length5;
    usqInt memField;
    usqInt memField1;
    usqInt memField2;

	/* begin printMemField:name:size: */
	memField2 = startOfMemory();
	length4 = GIV(youngStart) - (startOfMemory());
	print("memory      ");
	/* begin tab */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(((void *)memField2)));
	/* begin printChar: */
	putchar('/');
	printNum(memField2);
	print(" sz: ");
	printHex(length4);
	if (length4 != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(length4);
	}
	/* begin cr */
	printf("\n");
	/* begin printMemField:name:size: */
	length5 = GIV(freeStart) - GIV(youngStart);
	print("youngStart  ");
	/* begin tab */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(((void *)GIV(youngStart))));
	/* begin printChar: */
	putchar('/');
	printNum(GIV(youngStart));
	print(" sz: ");
	printHex(length5);
	if (length5 != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(length5);
	}
	/* begin cr */
	printf("\n");
	if (GIV(freeStart) <= GIV(scavengeThreshold)) {
		/* begin printMemField:name:size: */
		memField = GIV(freeStart);
		length = GIV(reserveStart) - GIV(freeStart);
		print("freeStart   ");
		/* begin tab */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(((void *)memField)));
		/* begin printChar: */
		putchar('/');
		printNum(memField);
		print(" sz: ");
		printHex(length);
		if (length != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(length);
		}
		/* begin cr */
		printf("\n");
		/* begin printMemField:name:size: */
		length1 = GIV(scavengeThreshold) - GIV(freeStart);
		print("scavenge@   ");
		/* begin tab */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(((void *)GIV(scavengeThreshold))));
		/* begin printChar: */
		putchar('/');
		printNum(GIV(scavengeThreshold));
		print(" sz: ");
		printHex(length1);
		if (length1 != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(length1);
		}
		/* begin cr */
		printf("\n");
	}
	else {
		/* begin printMemField:name:size: */
		length2 = GIV(scavengeThreshold) - GIV(freeStart);
		print("scavenge@   ");
		/* begin tab */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(((void *)GIV(scavengeThreshold))));
		/* begin printChar: */
		putchar('/');
		printNum(GIV(scavengeThreshold));
		print(" sz: ");
		printHex(length2);
		if (length2 != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(length2);
		}
		/* begin cr */
		printf("\n");
		/* begin printMemField:name:size: */
		memField1 = GIV(freeStart);
		length3 = GIV(reserveStart) - GIV(freeStart);
		print("freeStart   ");
		/* begin tab */
		putchar('	');
		/* begin printHexPtr: */
		printHex(oopForPointer(((void *)memField1)));
		/* begin printChar: */
		putchar('/');
		printNum(memField1);
		print(" sz: ");
		printHex(length3);
		if (length3 != 0) {
			/* begin printChar: */
			putchar('/');
			printNum(length3);
		}
		/* begin cr */
		printf("\n");
	}
	/* begin printMemField:name:size: */
	print("reserveStart");
	/* begin tab */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(((void *)GIV(reserveStart))));
	/* begin printChar: */
	putchar('/');
	printNum(GIV(reserveStart));
	print(" sz: ");
	printHex(GIV(endOfMemory) - GIV(reserveStart));
	if ((GIV(endOfMemory) - GIV(reserveStart)) != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(GIV(endOfMemory) - GIV(reserveStart));
	}
	/* begin cr */
	printf("\n");
	/* begin printMemField:name:size: */
	print("endOfMemory ");
	/* begin tab */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(((void *)GIV(endOfMemory))));
	/* begin printChar: */
	putchar('/');
	printNum(GIV(endOfMemory));
	print(" sz: ");
	printHex(GIV(memoryLimit) - GIV(endOfMemory));
	if ((GIV(memoryLimit) - GIV(endOfMemory)) != 0) {
		/* begin printChar: */
		putchar('/');
		printNum(GIV(memoryLimit) - GIV(endOfMemory));
	}
	/* begin cr */
	printf("\n");
	/* begin printMemField:name:size: */
	print("memoryLimit ");
	/* begin tab */
	putchar('	');
	/* begin printHexPtr: */
	printHex(oopForPointer(((void *)GIV(memoryLimit))));
	/* begin printChar: */
	putchar('/');
	printNum(GIV(memoryLimit));
	print(" sz: ");
	printHex(0);
	/* begin cr */
	printf("\n");
}

	/* NewObjectMemory>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = startAddress;
	while (oopisLessThan(oop, endAddress)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			printOop(oop);
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

	/* NewObjectMemory>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt header3;
    sqInt i;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt sz3;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l11;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz3 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header3 = longAt(obj1);
			sz3 = ((header3 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header3 & SizeMask);
		}
		obj1 = (obj1 + sz3) + (headerTypeBytes[(longAt(obj1 + sz3)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l11:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
		 || (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
			if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
				i = ((assert((((assert(isCompiledMethod(oop)),
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(oop)),
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(oop)),
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(oop)),
			longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart;
			}
			else {
				if (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(oop));
				}
				else {
					/* begin lengthOf: */
					header = longAt(oop);
					/* begin lengthOf:baseHeader:format: */
					fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
					if ((header & TypeMask) == HeaderTypeSizeAndClass) {
						sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					}
					else {
						sz = header & SizeMask;
					}
					sz -= header & Size4Bit;
					if (fmt <= 4) {
						i = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
						goto l2;
					}
					i = (fmt < (firstByteFormat())
						? ((usqInt) (sz - BaseHeaderSize)) >> 2
						: (sz - BaseHeaderSize) - (fmt & 3));
				l2:	/* end lengthOf: */;
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin space */
					putchar(' ');
					printOopShort(oop);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l7;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz2 = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header2 = longAt(obj);
				sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header2 & SizeMask);
			}
			obj = (obj + sz2) + (headerTypeBytes[(longAt(obj + sz2)) & TypeMask]);
		}
		oop = null;
	l7:	/* end accessibleObjectAfter: */;
	}
}


/*	Scan the heap printing the oops of any and all contexts whose size is not
	either SmallContextSize or LargeContextSize
 */

	/* NewObjectMemory>>#printWronglySizedContexts: */
void
printWronglySizedContexts(sqInt printContexts)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l9;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l9:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
		 && (badContextSize(oop))) {
			printHex(oop);
			/* begin space */
			putchar(' ');
			printNum(numBytesOf(oop));
			/* begin cr */
			printf("\n");
			if (printContexts) {
				printContext(oop);
			}
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l5;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l5:	/* end accessibleObjectAfter: */;
	}
}


/*	Restore headers smashed by forwarding links */

	/* NewObjectMemory>>#restoreHeadersFrom:to:from:and:to:from: */
static void NoDbgRegParms
restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt oop;
    sqInt sz;
    sqInt tablePtr;

	tablePtr = firstIn;
	while (oopisLessThanOrEqualTo(tablePtr, lastIn)) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseIn + (tablePtr - firstIn));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	tablePtr = firstOut;
	while (oopisLessThanOrEqualTo(tablePtr, lastOut)) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseOut + (tablePtr - firstOut));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(oop, GIV(freeStart))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			longAtput(oop, (longAt(oop)) & AllButMarkBit);
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}

	/* NewObjectMemory>>#runLeakCheckerFor: */
static void NoDbgRegParms
runLeakCheckerFor(sqInt gcModes)
{
	if (gcModes & checkForLeaks) {
		if (gcModes & GCModeFull) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrity());
		assert((checkInterpreterIntegrity()) == 0);
		assert(checkStackIntegrity());
		assert(checkCodeIntegrity(gcModes));
		/* begin validate */
	}
}


/*	Return the object or start of free space immediately following the 
	given object or free chunk in memory. Return freeStart when
	enumeration is complete. This is for assertion checking only. */

	/* NewObjectMemory>>#safeObjectAfter: */
static sqInt NoDbgRegParms
safeObjectAfter(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt sz;

	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
			: header & SizeMask);
	}
	return ((((usqInt)(oop + sz))) >= GIV(freeStart)
		? ((sqInt)GIV(freeStart))
		: (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]));
}


/*	Reduce the number of indexable fields in obj, a pointer object, to nSlots.
	Convert the
	unused residual to a free chunk. Word and byte indexable objects are not
	changed. Answer the number of bytes returned to free memory, which may be
	zero if no change
	was possible.
 */

	/* NewObjectMemory>>#shorten:toIndexableSize: */
static sqInt NoDbgRegParms
shortentoIndexableSize(sqInt obj, sqInt nSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt deltaBytes;
    sqInt desiredLength;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt indexableFields;
    sqInt oop1;
    usqInt p;
    usqInt start;
    sqInt sz;
    sqInt totalLength;

	if (!(((((usqInt) (longAt(obj))) >> (instFormatFieldLSB())) & 15) <= 4)) {
		return 0;
	}
	if (!(nSlots > 0)) {
		return 0;
	}
	hdr = longAt(obj);
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	if (((ccIndex = (((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(obj - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	indexableFields = totalLength - fixedFields;
	if (nSlots >= indexableFields) {
		return 0;
	}
	desiredLength = fixedFields + nSlots;
	deltaBytes = (totalLength - desiredLength) * BytesPerWord;
	if (((obj + BaseHeaderSize) + (totalLength * BytesPerWord)) == GIV(freeStart)) {

		/* Shortening the last object.  Need to reduce freeStart. */
		/* begin maybeFillWithAllocationCheckFillerFrom:to: */
		start = (obj + BaseHeaderSize) + (desiredLength * BytesPerWord);
		if (checkAllocFiller()) {
			for (p = start; p <= GIV(freeStart); p += BytesPerWord) {
				longAtput(p, p);
			}
		}
		GIV(freeStart) = (obj + BaseHeaderSize) + (desiredLength * BytesPerWord);
	}
	else {

		/* Shortening some interior object.  Need to create a free block. */
		/* begin setSizeOfFree:to: */
		longAtput((obj + BaseHeaderSize) + (desiredLength * BytesPerWord), (deltaBytes & AllButTypeMask) | HeaderTypeFree);
	}
	
	switch ((longAt(obj)) & TypeMask) {
	case HeaderTypeSizeAndClass:
		longAtput(obj - (BaseHeaderSize * 2), (longAt(obj - (BytesPerWord * 2))) - deltaBytes);
		break;
	case HeaderTypeClass:
	case HeaderTypeShort:
		longAtput(obj, (((hdr | SizeMask) - SizeMask)) | ((hdr & SizeMask) - deltaBytes));
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return deltaBytes;
}


/*	Compute the size of the given object from the cc and size fields in its
	header. This works even if its type bits are not correct. */

	/* NewObjectMemory>>#sizeBitsOfSafe: */
static sqInt NoDbgRegParms
sizeBitsOfSafe(sqInt oop)
{
    sqInt header;
    sqInt type;

	header = longAt(oop);
	/* begin rightType: */
	type = ((header & SizeMask) == 0
		? HeaderTypeSizeAndClass
		: ((header & CompactClassMask) == 0
				? HeaderTypeClass
				: HeaderTypeShort));
	return (type == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
}


/*	Answer the number of bytes in the given object, including its base header,
	rounded up to an integral number of words.
 */
/*	Note: byte indexable objects need to have low bits subtracted from this
	size. 
 */

	/* NewObjectMemory>>#sizeBitsOf: */
static sqInt NoDbgRegParms
sizeBitsOf(sqInt oop)
{
    sqInt header;

	header = longAt(oop);
	return ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
}


/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* NewObjectMemory>>#storeImageSegmentInto:outPointers:roots: */
static sqInt NoDbgRegParms
storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt doingClass;
    sqInt dst;
    sqInt dst1;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    usqInt firstIn;
    usqInt firstOut;
    usqInt hdrBaseIn;
    usqInt hdrBaseOut;
    sqInt hdrPtr;
    sqInt hdrTypeBits;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt in;
    sqInt in1;
    sqInt lastAddr;
    sqInt lastAddr1;
    sqInt lastAddr2;
    sqInt lastAddr3;
    usqInt lastIn;
    sqInt lastIn1;
    sqInt lastIn2;
    usqInt lastOut;
    usqInt lastPtr;
    usqInt lastSeg;
    unsigned int mapOop;
    sqInt out;
    sqInt out1;
    usqInt savedYoungStart;
    usqInt segOop;
    sqInt sz;
    sqInt versionOffset;

	hdrTypeBits = 0;
	if (!((((longAt(outPointerArray)) & TypeMask) == HeaderTypeSizeAndClass)
		 && (((longAt(segmentWordArray)) & TypeMask) == HeaderTypeSizeAndClass))) {

		/* Must be 3-word header */
		return PrimErrGenericFailure;
	}
	firstOut = outPointerArray + BaseHeaderSize;
	lastOut = firstOut - BytesPerWord;

	/* top half */
	hdrBaseOut = outPointerArray + (((lastPointerOf(outPointerArray)) / (BytesPerWord * 2)) * BytesPerWord);
	lastSeg = segmentWordArray;

	/* Write a version number for byte order and version check */
	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BytesPerWord;
	versionOffset = BytesPerWord;
	lastSeg += versionOffset;
	if (lastSeg > endSeg) {
		return PrimErrGenericFailure;
	}
	longAtput(lastSeg, imageSegmentVersion());

	/* Take 1/8 of seg */
	firstIn = endSeg - (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 8)) * BytesPerWord);
	lastIn = firstIn - BytesPerWord;

	/* top half of that */
	/* First mark the rootArray and all root objects. */
	hdrBaseIn = firstIn + (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 16)) * BytesPerWord);
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | MarkBit);
	lastPtr = arrayOfRoots + (lastPointerOf(arrayOfRoots));
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) | MarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	savedYoungStart = GIV(youngStart);

	/* process all of memory */
	GIV(youngStart) = startOfMemory();
	markAndTraceInterpreterOops(0);

	/* Finally unmark the rootArray and all root objects. */
	GIV(youngStart) = savedYoungStart;
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) & AllButMarkBit);
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) & AllButMarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	lastIn += BytesPerWord;
	if ((lastIn >= hdrBaseIn)
	 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(arrayOfRoots, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {
		lastIn -= BytesPerWord;
		restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
		i = outPointerArray + BaseHeaderSize;
		while (i <= lastAddr) {
			longAtput(i, GIV(nilObj));
			i += BytesPerWord;
		}
		return PrimErrGenericFailure;
	}
	segOop = ((segmentWordArray + versionOffset) + BaseHeaderSize) + (headerTypeBytes[(longAt((segmentWordArray + versionOffset) + BaseHeaderSize)) & TypeMask]);
	while (segOop <= lastSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type=0 or 1) -- start with that. */
			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */
			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */
		/* Go through all oops, remapping them... */
		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */
			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = fieldOop & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Just an integer -- nothing to do */
				fieldPtr += BytesPerWord;
			}
			else {
				header = longAt(fieldOop);
				if ((header & TypeMask) == HeaderTypeFree) {

					/* Has already been forwarded -- this is the link */
					mapOop = header & AllButTypeMask;
				}
				else {
					if (((longAt(fieldOop)) & MarkBit) == 0) {

						/* Points to an unmarked obj -- an internal pointer.
						   Copy the object into the segment, and forward its oop. */
						lastIn += BytesPerWord;
						if ((lastIn >= hdrBaseIn)
						 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(fieldOop, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {

							/* Out of space in segment */
							lastIn -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr1 = outPointerArray + (lastPointerOf(outPointerArray));
							i1 = outPointerArray + BaseHeaderSize;
							while (i1 <= lastAddr1) {
								longAtput(i1, GIV(nilObj));
								i1 += BytesPerWord;
							}
							return PrimErrGenericFailure;
						}
						mapOop = (longAt(fieldOop)) & AllButTypeMask;
					}
					else {

						/* Points to a marked obj -- an external pointer.
						   Map it as a tagged index in outPointers, and forward its oop. */
						lastOut += BytesPerWord;
						if (lastOut >= hdrBaseOut) {

							/* Out of space in outPointerArray */
							lastOut -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr2 = outPointerArray + (lastPointerOf(outPointerArray));
							i2 = outPointerArray + BaseHeaderSize;
							while (i2 <= lastAddr2) {
								longAtput(i2, GIV(nilObj));
								i2 += BytesPerWord;
							}
							return PrimErrGenericFailure;
						}
						mapOop = (lastOut - outPointerArray) | 0x80000000U;
						/* begin forward:to:savingOopAt:andHeaderAt: */
						hdrPtr = hdrBaseOut + (lastOut - firstOut);
						longAtput(lastOut, fieldOop);
						longAtput(hdrPtr, longAt(fieldOop));
						longAtput(fieldOop, mapOop + HeaderTypeFree);
					}
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += BytesPerWord * 2;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
			}
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(segOop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(segOop);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		segOop = (segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask]);
	}
	restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
	if ((((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) < 12)
	 || ((endSeg - lastSeg) < 12)) {

		/* Not enough room to insert simple 3-word headers */
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr3 = outPointerArray + (lastPointerOf(outPointerArray));
		i3 = outPointerArray + BaseHeaderSize;
		while (i3 <= lastAddr3) {
			longAtput(i3, GIV(nilObj));
			i3 += BytesPerWord;
		}
		return PrimErrGenericFailure;
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];

	/* Copy the 3-word wordArray header to establish a free chunk. */
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	/* begin transfer:from:to: */
	dst = lastOut + BytesPerWord;
	in = (segmentWordArray - extraSize) - BytesPerWord;
	lastIn1 = in + (3 * BytesPerWord);
	out = dst - BytesPerWord;
	while (oopisLessThan(in, lastIn1)) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	longAtput(lastOut + BytesPerWord, (((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) - extraSize) + hdrTypeBits);
	longAtput(outPointerArray - extraSize, ((lastOut - firstOut) + (BytesPerWord * 2)) + hdrTypeBits);
	beRootIfOld(outPointerArray);
	/* begin transfer:from:to: */
	dst1 = lastSeg + BytesPerWord;
	in1 = (segmentWordArray - extraSize) - BytesPerWord;
	lastIn2 = in1 + (3 * BytesPerWord);
	out1 = dst1 - BytesPerWord;
	while (oopisLessThan(in1, lastIn2)) {
		longAtput((out1 += BytesPerWord), longAt((in1 += BytesPerWord)));
	}
	longAtput(segmentWordArray - extraSize, ((lastSeg - segmentWordArray) + BaseHeaderSize) + hdrTypeBits);
	longAtput(lastSeg + BytesPerWord, ((endSeg - lastSeg) - extraSize) + hdrTypeBits);
	return PrimNoErr;
}


/*	Return true if there is enough free space after doing a garbage
	collection. If not, signal that space is low.
 */

	/* NewObjectMemory>>#sufficientSpaceAfterGC: */
static sqInt NoDbgRegParms
sufficientSpaceAfterGC(sqInt minFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt limit;
    sqInt newMemoryLimit;
    usqInt oldLimit;

	incrementalGC();
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		return 1;
	}
	if (GIV(signalLowSpace)) {
		return 0;
	}
	fullGC();
	if (oopisLessThan((GIV(freeStart) + minFree) + 15000, GIV(reserveStart))) {
		return 1;
	}
	while (1) {
		oldLimit = GIV(memoryLimit);
		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), (minFree + 15000) + GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			/* begin setMemoryLimit: */
			newMemoryLimit = limit - 24;
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		if (oopisLessThan((GIV(freeStart) + minFree) + 15000, GIV(reserveStart))) break;

		/* If the memoryLimit doesn't change then presumably the platform can't grow anymore. */
		if (oldLimit == GIV(memoryLimit)) {
			return 0;
		}
	}
	return 1;
}


/*	Return true if there is enough space to allocate the given number of
	bytes, perhaps after doing a garbage collection.
 */

	/* NewObjectMemory>>#sufficientSpaceToAllocate: */
static sqInt NoDbgRegParms
sufficientSpaceToAllocate(sqInt bytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt minFree;


	/* check for low-space */
	minFree = ((((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		return 1;
	}
	return sufficientSpaceAfterGC(minFree);
}


/*	Sweep memory from youngStart through the end of memory. Free all 
	inaccessible objects and coalesce adjacent free chunks. Clear the mark 
	bits of accessible objects. Compute the starting point for the first pass
	of 
	incremental compaction (compStart). Return the number of surviving 
	objects. */
/*	Details: Each time a non-free object is encountered, decrement the 
	number of available forward table entries. If all entries are spoken for 
	(i.e., entriesAvailable reaches zero), set compStart to the last free 
	chunk before that object or, if there is no free chunk before the given 
	object, the first free chunk after it. Thus, at the end of the sweep 
	phase, compStart through compEnd spans the highest collection of 
	non-free objects that can be accomodated by the forwarding table. This 
	information is used by the first pass of incremental compaction to 
	ensure that space is initially freed at the end of memory. Note that 
	there should always be at least one free chunk--the one at the end of 
	the heap. */

	/* NewObjectMemory>>#sweepPhase */
static sqInt
sweepPhase(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt entriesAvailable;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    usqInt freeStartLocal;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;
    sqInt survivors;

	freeChunkSize = 0;
	entriesAvailable = fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */
	firstFree = null;
	freeStartLocal = GIV(freeStart);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < freeStartLocal) {

		/* get oop's header, header type, size, and header size */
		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			else {

				/* free chunk */
				oopSize = oopHeader & LongSizeMask;
			}
		}
		if ((oopHeader & MarkBit) == 0) {

			/* object is not marked; free it */
			/* <-- Finalization support: We need to mark each oop chunk as free --> */
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk != null) {

				/* enlarge current free chunk to include this oop */
				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */

				/* chunk may start 4 or 8 bytes before oop */
				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */
				freeChunkSize = oopSize + (oop - freeChunk);
				if (firstFree == null) {
					firstFree = freeChunk;
				}
			}
		}
		else {

			/* object is marked; clear its mark bit and possibly adjust
			   the compaction start */
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
				finalizeReference(oop);
			}
			if (entriesAvailable > 0) {
				entriesAvailable -= 1;
			}
			else {

				/* start compaction at the last free chunk before this object */
				firstFree = freeChunk;
			}
			if (freeChunk != null) {

				/* record the size of the last free chunk */
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		if (oopSize == 0) {
			error("zero sized object encountered in sweep");
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk != null) {

		/* record size of final free chunk */
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (!(oop == GIV(freeStart))) {
		error("sweep failed to find exact end of memory");
	}
	GIV(compStart) = (firstFree == null
		? GIV(freeStart)
		: firstFree);
	return survivors;
}


/*	Sweep memory from youngStart through the end of memory. Free all
	inaccessible objects and coalesce adjacent free chunks. Clear the mark
	bits of accessible objects. Compute the starting point for the first pass
	of incremental compaction (compStart). Return the number of surviving
	objects. Unlike sweepPhase this always leaves compStart pointing at the
	first free chunk. */

	/* NewObjectMemory>>#sweepPhaseForFullGC */
static sqInt
sweepPhaseForFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endOfMemoryLocal;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;
    sqInt survivors;

	freeChunkSize = 0;
	fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */
	firstFree = null;
	endOfMemoryLocal = GIV(endOfMemory);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < endOfMemoryLocal) {

		/* get oop's header, header type, size, and header size */
		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType == HeaderTypeSizeAndClass) {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			else {
				assert((oopHeader & MarkBit) == 0);
				oopSize = oopHeader & LongSizeMask;
			}
		}
		if ((oopHeader & MarkBit) == 0) {

			/* object is not marked; free it */
			/* <-- Finalization support: We need to mark each oop chunk as free --> */
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk != null) {

				/* enlarge current free chunk to include this oop */
				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */

				/* chunk may start 4 or 8 bytes before oop */
				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */
				freeChunkSize = oopSize + (oop - freeChunk);
				if (firstFree == null) {
					firstFree = freeChunk;
				}
			}
		}
		else {

			/* object is marked; clear its mark bit and possibly adjust
			   the compaction start */
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
				finalizeReference(oop);
			}
			if (freeChunk != null) {

				/* record the size of the last free chunk */
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk != null) {

		/* record size of final free chunk */
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (oop == GIV(endOfMemory)) {
		GIV(freeStart) = GIV(endOfMemory);
	}
	else {
		error("sweep failed to find exact end of memory");
	}
	if (firstFree == null) {
		error("expected to find at least one free object");
	}
	else {
		GIV(compStart) = firstFree;
	}
	return survivors;
}


/*	For forward-compatibility with Spur. Fail; ObjectMemory does not support
	pinning. 
 */

	/* NewObjectMemory>>#unpinObject: */
void
unpinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}

	/* NewObjectMemory>>#verifyCleanHeaders */
static void
verifyCleanHeaders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt oop;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = startOfMemory();
	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(oop, GIV(freeStart))) {
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {

			/* There should only be one free block at end of memory. */
			if (!((objectAfter(oop)) == GIV(endOfMemory))) {
				error("Invalid obj with HeaderTypeBits = Free.");
			}
		}
		else {
			if (((longAt(oop)) & MarkBit) != 0) {
				error("Invalid obj with MarkBit set.");
			}
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	Add the given variable location to the extra roots table */

	/* ObjectMemory>>#addGCRoot: */
EXPORT(sqInt)
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}


/*	Answer if address appears to be that of either a SmallInteger or an
	object. For code disassembly and assertions. */

	/* ObjectMemory>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & 1))
	 || (((address & 3) == 0)
	 && (((((usqInt)address)) >= (startOfMemory()))
	 && (((((usqInt)address)) < GIV(freeStart))
	 && (((longAt(address)) & TypeMask) != HeaderTypeGC))));
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of objects as a SmallInteger.
	Since objects are at least 4 bytes big, and the largest SmallInteger
	covers 1/4 of the address space, the count can never overflow. */
/*	Count the currently accessible objects */

	/* ObjectMemory>>#allObjects */
static sqInt
allObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt chunk1;
    sqInt count;
    sqInt header;
    sqInt header1;
    sqInt ign;
    sqInt newCount;
    sqInt obj;
    sqInt oop;
    sqInt resultArray;
    sqInt sz;
    sqInt sz1;

	count = 0;
	/* begin allObjectsDo: */
	chunk1 = startOfMemory();
	oop = chunk1 + (headerTypeBytes[(longAt(chunk1)) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			count += 1;

		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
	}

	/* Store all objects in result array, excluding any reference to the result array itself,
	   as may happen if garbage collection occurred during allocation of the array. No store
	   check is necessary; the result array will be the last object in memory and hence new. */
	resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), count);
	newCount = 0;
	/* begin oopFromChunk: */
	chunk = startOfMemory();
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (obj < resultArray) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			newCount += 1;
			if (!(resultArray == null)) {
				longAtput((resultArray + BaseHeaderSize) + (((sqInt)((usqInt)(newCount) << (shiftForWord())))), obj);
			}
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	if (resultArray == null) {
		return (((usqInt)count << 1) | 1);
	}
	if (newCount < count) {
		shortentoIndexableSize(resultArray, newCount);
	}
	return resultArray;
}


/*	Return true if all the oops in both arrays, and the arrays 
	themselves, are in the young object space. */

	/* ObjectMemory>>#allYoung:and: */
static sqInt NoDbgRegParms
allYoungand(sqInt array1, sqInt array2)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    sqInt sp;

	if (oopisLessThan(array1, GIV(youngStart))) {
		return 0;
	}
	if (oopisLessThan(array2, GIV(youngStart))) {
		return 0;
	}
	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l4;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l4;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l4;
	}
	assert(isCompiledMethod(array1));
	header = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l4:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (oopisLessThan(longAt(array1 + fieldOffset), GIV(youngStart))) {
			return 0;
		}
		if ((oopisLessThan(longAt(array2 + fieldOffset), GIV(youngStart)))
		 && (((longAt(array2 + fieldOffset)) & 1) == 0)) {
			return 0;
		}
		fieldOffset -= BytesPerWord;
	}
	return 1;
}

	/* ObjectMemory>>#arrayFormat */
sqInt
arrayFormat(void)
{
	return 2;
}

	/* ObjectMemory>>#badContextSize: */
static sqInt NoDbgRegParms
badContextSize(sqInt oop)
{
    sqInt header;
    sqInt numSlots;
    sqInt sz;

	/* begin numSlotsOf: */
	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	return (numSlots != SmallContextSlots)
	 && (numSlots != LargeContextSlots);
}

	/* ObjectMemory>>#become:with: */
sqInt
becomewith(sqInt array1, sqInt array2)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	If this object is old, mark it as a root (because a new object 
	may be stored into it) */

	/* ObjectMemory>>#beRootIfOld: */
void
beRootIfOld(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if ((oopisLessThan(oop, GIV(youngStart)))
	 && (!((oop & 1)))) {

		/* Yes, oop is an old object */
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if (!((header & RootBit) != 0)) {

			/* record oop as root only if not already recorded */
			if (GIV(rootTableCount) < RootTableSize) {

				/* record root if there is enough room in the roots table.
				   IMPORTANT: since clearRootsTable is the only thing that clears root bits
				   do *not* set the root bit unless an object is in the root table.  checking
				   routines will complain about the root bit being unset instead of the table
				   being full, but that's life */
				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
				if (GIV(rootTableCount) >= RootTableRedZone) {

					/* if we're now in the red zone force an IGC ASAP */
					/* begin scheduleIncrementalGC */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
			}
			else {

				/* note overflow; will need to do a fullGC instead of an incremental. */
				GIV(rootTableOverflowed) = 1;
			}
		}
	}
}


/*	Record that the given oop in the old object area points to an object in
	the young area when oop may be forwarded.
 */
/*	Warning: No young objects should be recorded as roots. Callers are
	responsible for ensuring this constraint is not violated.
 */
/*	for debugging... */
/*	If labelled, gcc duplicates the label when inlining
	updatePointersInRangeFrom:to: 
 */

	/* ObjectMemory>>#beRootWhileForwarding: */
static void NoDbgRegParms
beRootWhileForwarding(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt headerLoc;

	header = longAt(oop);
	if ((header & MarkBit) != 0) {

		/* This oop is forwarded */
		fwdBlock = ((sqInt)((usqInt)((header & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock));
		headerLoc = fwdBlock + BytesPerWord;
	}
	else {

		/* Normal -- no forwarding */
		headerLoc = oop;
	}
	/* begin noteAsRoot:headerLoc: */
	header1 = longAt(headerLoc);
	if (!((header1 & RootBit) != 0)) {

		/* record oop as root only if not already recorded */
		if (GIV(rootTableCount) < RootTableSize) {

			/* record root if there is enough room in the roots table.
			   IMPORTANT: since clearRootsTable is the only thing that clears root bits
			   do *not* set the root bit unless an object is in the root table.  checking
			   routines will complain about the root bit being unset instead of the table
			   being full, but that's life */
			GIV(rootTableCount) += 1;
			GIV(rootTable)[GIV(rootTableCount)] = oop;
			longAtput(headerLoc, header1 | RootBit);
			if (GIV(rootTableCount) >= RootTableRedZone) {

				/* if we're now in the red zone force an IGC ASAP */
				/* begin scheduleIncrementalGC */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
		}
		else {

			/* note overflow; will need to do a fullGC instead of an incremental. */
			GIV(rootTableOverflowed) = 1;
		}
	}
}

	/* ObjectMemory>>#byteFormatMask */
static sqInt
byteFormatMask(void)
{
	return 12;
}

	/* ObjectMemory>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop)
{
	if ((oop & 1)) {
		return 0;
	}
	return numBytesOf(oop);
}


/*	If the VM is big endian, then swap the bytes of w */

	/* ObjectMemory>>#byteSwapped32IfBigEndian: */
unsigned int
byteSwapped32IfBigEndian(unsigned int w)
{
	
#  if VMBIGENDIAN
	return SQ_SWAP_4_BYTES(w);

#  else /* VMBIGENDIAN */
	return w & 0xFFFFFFFFU;

#  endif /* VMBIGENDIAN */

	return 0;
}


/*	If the VM is big endian, then swap the bytes of w */

	/* ObjectMemory>>#byteSwapped64IfBigEndian: */
unsigned long long
byteSwapped64IfBigEndian(unsigned long long w)
{
	
#  if VMBIGENDIAN
	return SQ_SWAP_8_BYTES(w);

#  else /* VMBIGENDIAN */
	return w & 0xFFFFFFFFFFFFFFFFULL;

#  endif /* VMBIGENDIAN */

	return 0;
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* ObjectMemory>>#byteSwapped: */
sqInt
byteSwapped(sqInt w)
{
	return 
#  if BytesPerWord == 4
		SQ_SWAP_4_BYTES(w)
#  else /* BytesPerWord == 4 */
		SQ_SWAP_8_BYTES(w)
#  endif /* BytesPerWord == 4 */
		;
}


/*	Attempt to change the class of the receiver to the argument given that the
	format of the receiver matches the format of the argument. If successful,
	answer 0, otherwise answer an error code indicating the reason for
	failure. 
	Fail if the receiver is an instance of a compact class and the argument
	isn't, or if the format of the receiver is incompatible with the format of
	the argument,
	or if the argument is a fixed class and the receiver's size differs from
	the size
	that an instance of the argument should have. */
/*	Check what the format of the class says */

	/* ObjectMemory>>#changeClassOf:to: */
static sqInt NoDbgRegParms
changeClassOfto(sqInt rcvr, sqInt argClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argClassInstByteSize;
    sqInt argFormat;
    sqInt ccIndex;
    sqInt classHdr;
    sqInt rcvrFormat;
    sqInt rcvrHdr;
    sqInt sizeHiBits;


	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */
	classHdr = (longAt((argClass + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	sizeHiBits = ((usqInt) (classHdr & 393216)) >> 9;
	classHdr = classHdr & 0x1FFFF;

	/* size in bytes -- low 2 bits are 0 */
	/* Check the receiver's format against that of the class */
	argClassInstByteSize = (classHdr & SizeMask) + sizeHiBits;
	argFormat = (((usqInt) classHdr) >> (instFormatFieldLSB())) & 15;
	/* begin baseHeader: */
	rcvrHdr = longAt(rcvr);

	/* If the receiver is a byte object we need to clear the number of odd bytes from the format. */
	rcvrFormat = (((usqInt) rcvrHdr) >> (instFormatFieldLSB())) & 15;
	if (rcvrFormat > (firstByteFormat())) {
		rcvrFormat = rcvrFormat & 12;
	}
	if (!(argFormat == rcvrFormat)) {
		return PrimErrInappropriate;
	}
	if (argFormat < 2) {
		if ((argClassInstByteSize - BaseHeaderSize) != (numBytesOf(rcvr))) {
			return PrimErrBadReceiver;
		}
	}
	else {
		if (argFormat == (indexablePointersFormat())) {

			/* For indexable plus fixed fields the receiver must be at least big enough. */
			if ((argClassInstByteSize - BaseHeaderSize) > (numBytesOf(rcvr))) {
				return PrimErrBadReceiver;
			}
		}
	}
	if ((rcvrHdr & TypeMask) == HeaderTypeShort) {

		/* Compact classes. Check if the arg's class is compact and exchange ccIndex */
		ccIndex = classHdr & CompactClassMask;
		if (ccIndex == 0) {
			return PrimErrInappropriate;
		}
		
#    if IMMUTABILITY
		if ((rcvrHdr & ImmutabilityBit) != 0) {
			return PrimErrNoModification;
		}

#    endif /* IMMUTABILITY */

		/* begin baseHeader:put: */
		longAtput(rcvr, (((rcvrHdr | CompactClassMask) - CompactClassMask)) | ccIndex);
	}
	else {

		/* Exchange the class pointer, which could make rcvr a root for argClass */
		
#    if IMMUTABILITY
		if ((rcvrHdr & ImmutabilityBit) != 0) {
			return PrimErrNoModification;
		}

#    endif /* IMMUTABILITY */

		if (((((usqInt) rcvrHdr) >> (compactClassFieldLSB())) & 0x1F) != 0) {
			/* begin baseHeader:put: */
			longAtput(rcvr, ((rcvrHdr | CompactClassMask) - CompactClassMask));
		}
		longAtput(rcvr - BaseHeaderSize, argClass | (rcvrHdr & TypeMask));
		if (oopisLessThan(rcvr, GIV(youngStart))) {
			possibleRootStoreIntovalue(rcvr, argClass);
		}
	}
	return 0;
}

	/* ObjectMemory>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((characterCode >= 0) && (characterCode <= 0xFF))
		? (/* begin fetchPointer:ofObject: */
			longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(characterCode) << (shiftForWord()))))))
		: GIV(nilObj));
}

	/* ObjectMemory>>#characterTable */
sqInt
characterTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))));
}


/*	Assumes zero-based array indexing. For testing in Smalltalk, this method
	should be overridden in a subclass.
 */

	/* ObjectMemory>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkAddress: */
	if (oopisLessThan(byteAddress, startOfMemory())) {
		error("bad address: negative");
	}
	if (oopisGreaterThanOrEqualTo(byteAddress, GIV(memoryLimit))) {
		error("bad address: past end of heap");
	}
	/* begin checkAddress: */
	if (oopisLessThan(byteAddress + 3, startOfMemory())) {
		error("bad address: negative");
	}
	if (oopisGreaterThanOrEqualTo(byteAddress + 3, GIV(memoryLimit))) {
		error("bad address: past end of heap");
	}
	return longAt(byteAddress);
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */

	/* ObjectMemory>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    sqInt ccIndex;
    int formatMask;
    usqInt objClass;
    sqInt objFormatBits;
    sqInt oop;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) ((((ccIndex = (((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F)) == 0
	? (longAt(obj - BaseHeaderSize)) & AllButTypeMask
	: (/* begin fetchPointer:ofObject: */
		(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
		longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))));
	if ((objClass & 1)) {
		print("obj ");
		printHex(obj);
		print(" a SmallInteger is not a valid class or behavior");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!(okayOop(objClass))) {
		print("obj ");
		printHex(obj);
		print(" class obj is not ok");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!((((((usqInt) (longAt(objClass))) >> (instFormatFieldLSB())) & 15) <= 4)
		 && ((lengthOf(objClass)) >= 3))) {
		print("obj ");
		printHex(obj);
		print(" a class (behavior) must be a pointers object of size >= 3");
		/* begin cr */
		printf("\n");
		return 0;
	}
	formatMask = (((obj & 1) == 0)
	 && (((((usqInt) (longAt(obj))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))
		? 3072
		: 3840);
	behaviorFormatBits = ((longAt((objClass + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1) & formatMask;
	objFormatBits = (longAt(obj)) & formatMask;
	if (!(behaviorFormatBits == objFormatBits)) {
		print("obj ");
		printHex(obj);
		print(" and its class (behavior) formats differ");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* ObjectMemory>>#checkOopIntegrity:named:index: */
static sqInt NoDbgRegParms
checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak @ ");
	printNum(i);
	print(" = ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* ObjectMemory>>#classAlien */
sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))));
}

	/* ObjectMemory>>#classArray */
sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))));
}

	/* ObjectMemory>>#classBitmap */
sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBitmap) << (shiftForWord())))));
}

	/* ObjectMemory>>#classByteArray */
sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteArray) << (shiftForWord())))));
}

	/* ObjectMemory>>#classCharacter */
sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassCharacter) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalAddress */
sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassExternalAddress) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalData */
sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassExternalData) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalFunction */
sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassExternalFunction) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalLibrary */
sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassExternalLibrary) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalStructure */
sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassExternalStructure) << (shiftForWord())))));
}

	/* ObjectMemory>>#classFloat */
sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
}

	/* ObjectMemory>>#classHeader: */
sqInt
classHeader(sqInt oop)
{
	return longAt(oop - BaseHeaderSize);
}

	/* ObjectMemory>>#classLargeNegativeInteger */
sqInt
classLargeNegativeInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
}

	/* ObjectMemory>>#classLargePositiveInteger */
sqInt
classLargePositiveInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
}

	/* ObjectMemory>>#classPoint */
sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord())))));
}

	/* ObjectMemory>>#classSemaphore */
sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord())))));
}

	/* ObjectMemory>>#classSmallInteger */
sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
}

	/* ObjectMemory>>#classString */
sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord())))));
}

	/* ObjectMemory>>#classUnsafeAlien */
sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassUnsafeAlien) << (shiftForWord())))));
}


/*	Clear the root bits of the current roots, then empty the roots table. */
/*	Caution: This should only be done when the young object space is empty. */
/*	reset the roots table (after this, all objects are old so there are no
	roots) 
 */

	/* ObjectMemory>>#clearRootsTable */
static void
clearRootsTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		longAtput(oop, (longAt(oop)) & AllButRootBit);
		GIV(rootTable)[i] = 0;
	}
	GIV(rootTableCount) = 0;
	GIV(rootTableOverflowed) = 0;
}


/*	Index must be between 1 and compactClassArray size. A zero compact class
	index in the base header indicates that the class is in the class header
	word.  */

	/* ObjectMemory>>#compactClassAt: */
sqInt
compactClassAt(sqInt ccIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
}

	/* ObjectMemory>>#compactClassIndexOfClass: */
sqInt
compactClassIndexOfClass(sqInt classObj)
{
    sqInt header;

	/* begin compactClassIndexOfHeader: */
	header = (longAt((classObj + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	return (((usqInt) header) >> (compactClassFieldLSB())) & 0x1F;
}

	/* ObjectMemory>>#compactClassIndexOfHeader: */
sqInt
compactClassIndexOfHeader(sqInt header)
{
	return (((usqInt) header) >> (compactClassFieldLSB())) & 0x1F;
}

	/* ObjectMemory>>#compactClassIndexOf: */
sqInt
compactClassIndexOf(sqInt oop)
{
	return (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
}


/*	Check that a class the VM assumes is compact has the right index. */

	/* ObjectMemory>>#compactIndexOfClass: */
static sqInt NoDbgRegParms
compactIndexOfClass(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cct;
    sqInt index;

	cct = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
	for (index = ((lengthOf(cct)) - 1); index >= 0; index += -2) {
		if ((longAt((cct + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))))) == aClassOop) {
			return index + 1;
		}
	}
	return 0;
}


/*	Answer if the array does not contain a small integer. You 
	can't become: SmallIntegers! */

	/* ObjectMemory>>#containOnlyOops: */
static sqInt NoDbgRegParms
containOnlyOops(sqInt array)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    sqInt sp;

	/* begin lastPointerOf: */
	header = longAt(array);
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l4;
		}
		fieldOffset = (sizeBitsOfSafe(array)) - BaseHeaderSize;
		goto l4;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l4;
	}
	assert(isCompiledMethod(array));
	header = longAt((array + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l4:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(array + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BytesPerOop;
	}
	return 1;
}


/*	Answer if neither array contains a small integer. You 
	can't become: integers! */

	/* ObjectMemory>>#containOnlyOops:and: */
static sqInt NoDbgRegParms
containOnlyOopsand(sqInt array1, sqInt array2)
{
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    sqInt sp;

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l4;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l4;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l4;
	}
	assert(isCompiledMethod(array1));
	header = longAt((array1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l4:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (((longAt(array1 + fieldOffset)) & 1)) {
			return 0;
		}
		if (((longAt(array2 + fieldOffset)) & 1)) {
			return 0;
		}
		fieldOffset -= BytesPerOop;
	}
	return 1;
}


/*	Copy this object into the segment beginning at lastSeg.
	Install a forwarding pointer, and save oop and header.
	Fail if out of space. Return the next segmentAddr if successful. */
/*	Copy the object... */

	/* ObjectMemory>>#copyObj:toSegment:addr:stopAt:saveOopAt:headerAt: */
static sqInt NoDbgRegParms
copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr)
{
    sqInt bodySize;
    sqInt extraSize;
    sqInt hdrAddr;
    sqInt header;
    sqInt in;
    sqInt lastIn;
    sqInt out;

	flag("Dan");
	extraSize = headerTypeBytes[(longAt(oop)) & TypeMask];
	/* begin sizeBitsOf: */
	header = longAt(oop);
	bodySize = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
		: header & SizeMask);
	if (oopisGreaterThanOrEqualTo((lastSeg + extraSize) + bodySize, stopAddr)) {
		return 0;
	}
	/* begin transfer:from:to: */
	in = (oop - extraSize) - BytesPerWord;
	lastIn = in + (((extraSize + bodySize) / BytesPerWord) * BytesPerWord);
	out = (lastSeg + BytesPerWord) - BytesPerWord;
	while (oopisLessThan(in, lastIn)) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	hdrAddr = (lastSeg + BytesPerWord) + extraSize;
	longAtput(hdrAddr, (longAt(hdrAddr)) & (AllButRootBit - MarkBit));
	/* begin forward:to:savingOopAt:andHeaderAt: */
	longAtput(oopPtr, oop);
	longAtput(hdrPtr, longAt(oop));
	longAtput(oop, (((lastSeg + BytesPerWord) + extraSize) - segmentWordArray) + HeaderTypeFree);
	return (lastSeg + extraSize) + bodySize;
}

	/* ObjectMemory>>#displayObject */
sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord())))));
}

	/* ObjectMemory>>#falseObject */
sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* ObjectMemory>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt oop)
{
	return byteAt((oop + BaseHeaderSize) + byteIndex);
}

	/* ObjectMemory>>#fetchClassOf: */
sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;

	return ((oop & 1)
		? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))))
		: (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord()))))))));
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* ObjectMemory>>#fetchLong32:ofObject: */
sqInt
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
}

	/* ObjectMemory>>#fetchLong64:ofObject: */
static sqLong NoDbgRegParms
fetchLong64ofObject(sqInt longIndex, sqInt oop)
{
	return 
#  if BytesPerWord == 8
		long64At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(longIndex) << 3))))
#  else /* BytesPerWord == 8 */
		
		#  if VMBIGENDIAN
				((((unsigned long long)(long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(longIndex) << 3))))))) << 32) + (((unsigned int) (long32At((oop + BaseHeaderSize) + ((((sqInt)((usqInt)(longIndex) << 3))) + 4)))))
		#  else /* VMBIGENDIAN */
				(((unsigned int) (long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(longIndex) << 3))))))) + ((((unsigned long long)(long32At((oop + BaseHeaderSize) + ((((sqInt)((usqInt)(longIndex) << 3))) + 4))))) << 32)
		#  endif /* VMBIGENDIAN */
				
#  endif /* BytesPerWord == 8 */
		;
}


/*	index by word size, and return a pointer as long as the word size */

	/* ObjectMemory>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt oop)
{
	return longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
}


/*	During sweep phase we have encountered a weak reference. Check if its
	object has gone away (or is about to) and if so, signal a semaphore. Do
	*not* inline
	this in sweepPhase - it is quite an unlikely case to run into a weak
	reference  */

	/* ObjectMemory>>#finalizeReference: */
static void NoDbgRegParms
finalizeReference(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex1;
    sqInt chunk;
    sqInt class;
    sqInt classFormat;
    sqInt contextSize;
    sqInt firstField;
    sqInt fmt;
    sqInt header;
    sqInt i;
    sqInt lastField;
    sqInt numFields;
    sqInt numLiterals;
    sqInt oop11;
    int oopGone;
    sqInt sp;
    usqInt weakOop;

	/* begin nonWeakFieldsOf: */
	assert(isWeakNonImm(oop));
	if (((ccIndex1 = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	numFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
	firstField = BaseHeaderSize + (((sqInt)((usqInt)(numFields) << (shiftForWord()))));
	/* begin lastPointerOf: */
	header = longAt(oop);
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l8;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop)));
			contextSize = (sp >> 1);
		l8:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l10;
		}
		lastField = (sizeBitsOfSafe(oop)) - BaseHeaderSize;
		goto l10;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		lastField = 0;
		goto l10;
	}
	assert(isCompiledMethod(oop));
	header = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header) >> 10) & 0xFF));

	lastField = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l10:	/* end lastPointerOf: */;
	for (i = firstField; i <= lastField; i += BytesPerWord) {

		/* ar 1/18/2005: Added oop < youngStart test to make sure we're not testing
		   objects in non-GCable region. This could lead to a forward reference in
		   old space with the oop pointed to not being marked and thus treated as free. */
		weakOop = longAt(oop + i);
		if (!((weakOop == GIV(nilObj))
			 || (((weakOop & 1))
			 || (weakOop < GIV(youngStart))))) {

			/* Check if the object is being collected.
			   If the weak reference points
			   * backward: check if the weakOops chunk is free
			   * forward: check if the weakOoop has been marked by GC */
			if (weakOop < oop) {
				chunk = weakOop - (headerTypeBytes[(longAt(weakOop)) & TypeMask]);
				oopGone = ((longAt(chunk)) & TypeMask) == HeaderTypeFree;
			}
			else {
				oopGone = !(((longAt(weakOop)) & MarkBit) != 0);
			}
			if (oopGone) {

				/* Store nil in the pointer and signal the  interpreter */
				longAtput(oop + i, GIV(nilObj));
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}
		}
	}
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* ObjectMemory>>#firstFixedFieldOfMaybeImmediate: */
static void * NoDbgRegParms
firstFixedFieldOfMaybeImmediate(sqInt oop)
{
	return ((oop & 1)
		? ((void *)oop)
		: (/* begin firstFixedField: */
			pointerForOop(oop + BaseHeaderSize)));
}

	/* ObjectMemory>>#firstFixedField: */
void *
firstFixedField(sqInt oop)
{
	return pointerForOop(oop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes
 */

	/* ObjectMemory>>#firstIndexableField: */
void *
firstIndexableField(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt oop1;
    sqInt sz;
    sqInt totalLength;

	/* begin baseHeader: */
	hdr = longAt(oop);
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {

		/* pointer; may need to delve into the class format word */
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
			goto l2;
		}
		totalLength = (fmt < (firstByteFormat())
			? ((usqInt) (sz - BaseHeaderSize)) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
	l2:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l4;
		}
		if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
		classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
	l4:	/* end fixedFieldsOf:format:length: */;
		return pointerForOop((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fixedFields) << (shiftForWord())))));
	}
	return pointerForOop(oop + BaseHeaderSize);
}


/*	A fake format for the interpreter used to mark indexable strings in
	the interpreter's at cache. This is larger than any format. */

	/* ObjectMemory>>#firstStringyFakeFormat */
static sqInt
firstStringyFakeFormat(void)
{
	return 16;
}


/*	
	NOTE: This code supports the backward-compatible extension to 8 bits of
	instSize. When we revise the image format, it should become...
	^ (classFormat >> 2 bitAnd: 16rFF) - 
	 */

	/* ObjectMemory>>#fixedFieldsOf:format:length: */
static sqInt NoDbgRegParms
fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt oop1;

	if ((fmt > 4)
	 || (fmt == 2)) {
		return 0;
	}
	if (fmt < 2) {
		return wordLength;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	return (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
}

	/* ObjectMemory>>#followForwarded: */
static sqInt NoDbgRegParms
followForwarded(sqInt objOop)
{
	error("shouldNotImplement");
	return 0;
}


/*	**should be in-lined** */
/*	Note that, in Smalltalk, the instSpec will be equal to the inst spec
	part of the base header of an instance (without hdr type) shifted left 1.
	In this way, apart from the smallInt bit, the bits
	are just where you want them for the first header word. */
/*	Callers (must) expect low 2 bits (header type) to be zero! */

	/* ObjectMemory>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer)
{
	return (longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
}


/*	0 no fields
	1 fixed fields only (all containing pointers)
	2 indexable fields only (all containing pointers)
	3 both fixed and indexable fields (all containing pointers)
	4 both fixed and indexable weak fields (all containing pointers).
	
	5 unused
	6 indexable word fields only (no pointers)
	7 indexable long (64-bit) fields (only in 64-bit images)
	
	8-11 indexable byte fields only (no pointers) (low 2 bits are low 2 bits
	of size)
	12-15 compiled methods:
	# of literal oops specified in method header,
	followed by indexable bytes (same interpretation of low 2 bits as above
	 */

	/* ObjectMemory>>#formatOfHeader: */
static sqInt NoDbgRegParms
formatOfHeader(sqInt header)
{
	return (((usqInt) header) >> (instFormatFieldLSB())) & 15;
}


/*	Answer if the given address is a valid forward table entry. */

	/* ObjectMemory>>#fwdBlockValid: */
static sqInt NoDbgRegParms
fwdBlockValid(sqInt addr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThan(addr, GIV(endOfMemory)))
	 && ((oopisLessThanOrEqualTo(addr, GIV(fwdTableNext)))
	 && ((addr & 3) == 0));
}


/*	For compatibility with spur object memory */

	/* ObjectMemory>>#getHeapGrowthToSizeGCRatio */
#if PharoVM
static float
getHeapGrowthToSizeGCRatio(void)
{
	return 0;
}
#endif /* PharoVM */

	/* ObjectMemory>>#goodContextSize: */
static sqInt NoDbgRegParms
goodContextSize(sqInt oop)
{
    sqInt header;
    sqInt numSlots;
    sqInt sz;

	/* begin numSlotsOf: */
	header = longAt(oop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	return (numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots);
}

	/* ObjectMemory>>#hasForwardingBlock: */
static sqInt NoDbgRegParms
hasForwardingBlock(sqInt objOop)
{
	return ((longAt(objOop)) & MarkBit) != 0;
}


/*	The V3 64-bit memory manager has 64-bit oops, but its SmallIntegers only
	have 31 bits of precision. The Spur 64-bit memory manager has 61-bit
	immediates.  */

	/* ObjectMemory>>#hasSixtyFourBitImmediates */
static sqInt
hasSixtyFourBitImmediates(void)
{
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* ObjectMemory>>#headerIndicatesAlternateBytecodeSet: */
sqInt
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((int) methodHeader)) < 0;
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* ObjectMemory>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj)
{
    sqInt byteSize;
    sqInt classHdr;
    sqInt sizeHiBits;

	assert(addressCouldBeObj(classObj));

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */
	classHdr = (longAt((classObj + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	sizeHiBits = (((usqInt) classHdr) >> 9) & 768;

	/* size in bytes -- low 2 bits are 0 */
	byteSize = (classHdr & SizeMask) + sizeHiBits;
	return (byteSize - BaseHeaderSize) / BytesPerWord;
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
 */

	/* ObjectMemory>>#instantiateClass:indexableSize: */
sqInt
instantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    sqInt byteSize;
    sqInt byteSize1;
    usqInt cClass;
    sqInt classFormat;
    sqInt classOop;
    usqInt end;
    sqInt enoughSpace;
    sqInt fillWord;
    sqInt format;
    usqInt hash;
    sqInt hdrSize;
    usqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt i;
    sqInt minFree;
    usqInt newChunk;
    usqInt newChunk1;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt oop;
    sqInt sizeHiBits;

	classOop = 0;
	header3 = 0;
	assert(size >= 0);
	hash = ((usqInt) GIV(freeStart)) >> (shiftForWord());

	/* Low 2 bits are 0 */
	classFormat = (longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	header1 = (classFormat & 0x1FF00) | ((hash & HashMaskUnshifted) << HashBitsOffset);
	header2 = classPointer;
	sizeHiBits = ((usqInt) (classFormat & 393216)) >> 9;

	/* compact class field from format word */
	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
	   to 4 bytes per field.  Need another shift for 8 bytes per word... */
	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = ((sqInt)((usqInt)(byteSize) << ((shiftForWord()) - 2)));
	/* begin formatOfHeader: */
	format = (((usqInt) classFormat) >> (instFormatFieldLSB())) & 15;
	flag("sizeLowBits");
	if (format < (firstByteFormat())) {
		if (format == (firstLongFormat())) {

			/* long32 bitmaps */
			bm1 = BytesPerWord - 1;

			/* round up */
			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */
			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */
		bm1 = BytesPerWord - 1;

		/* round up */
		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */
		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
		header1 = header1 | (((sqInt)((usqInt)((binc & 3)) << (instFormatFieldLSB()))));
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 0xFF) {

		/* requires size header word/full header */
		header3 = byteSize;
		hdrSize = 3;
	}
	else {
		header1 = header1 | byteSize;
		hdrSize = (cClass == 0
			? 2
			: 1);
	}
	/* begin allocate:headerSize:h1:h2:h3:doFill:format: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l2;
	}
	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l2;
	}
	newObj = 0;
l2:	/* end allocateChunk: */;
	if (newObj == 0) {

		/* remap classOop because GC may move the classOop */
		if (hdrSize > 1) {
			/* begin pushRemappableOop: */
			assert(addressCouldBeOop(header2));
			GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = header2;
			if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
				error("remapBuffer overflow");
			}
		}
		/* begin allocateChunkAfterGC: */
		byteSize1 = byteSize + ((hdrSize - 1) * BytesPerWord);
		/* begin sufficientSpaceToAllocate: */

		/* check for low-space */
		minFree = ((((((GIV(lowSpaceThreshold) + byteSize1) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
		if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
			enoughSpace = 1;
			goto l3;
		}
		enoughSpace = sufficientSpaceAfterGC(minFree);
	l3:	/* end sufficientSpaceToAllocate: */;
		if (!enoughSpace) {

			/* signal that space is running low, but proceed with allocation if possible */
			setSignalLowSpaceFlagAndSaveProcess();
		}
		if (oopisGreaterThan(GIV(freeStart) + byteSize1, GIV(reserveStart))) {
			newObj = 0;
			goto l4;
		}
		newChunk1 = GIV(freeStart);
		GIV(freeStart) += byteSize1;
		newObj = oopForPointer(newChunk1);
	l4:	/* end allocateChunkAfterGC: */;
		if (hdrSize > 1) {
			/* begin popRemappableOop */
			oop = GIV(remapBuffer)[GIV(remapBufferCount)];
			GIV(remapBufferCount) -= 1;
			classOop = oop;
		}
		if (newObj == 0) {
			return newObj;
		}
	}
	else {
		classOop = header2;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3 | HeaderTypeSizeAndClass);
		longAtput(newObj + BytesPerWord, classOop | HeaderTypeSizeAndClass);
		longAtput(newObj + (BytesPerWord * 2), header1 | HeaderTypeSizeAndClass);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, classOop | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	fillWord = (format <= 4
		? GIV(nilObj)
		: 0);
	end = newObj + byteSize;

	/* skip header */
	i = newObj + BytesPerWord;
	while (i < end) {
		longAtput(i, fillWord);
		i += BytesPerWord;
	}
	assert(i == GIV(freeStart));

	return newObj;
}


/*	This field in a class's format inst var corresponds to the 4-bit format
	field stored in every object header
 */

	/* ObjectMemory>>#instSpecOfClass: */
static sqInt NoDbgRegParms
instSpecOfClass(sqInt classPointer)
{
    sqInt header;

	/* begin formatOfHeader: */
	header = (longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	return (((usqInt) header) >> (instFormatFieldLSB())) & 15;
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* ObjectMemory>>#integerObjectOf: */
sqInt
integerObjectOf(sqInt value)
{
	return (((sqInt)((usqInt)(value) << 1))) + 1;
}


/*	Translator produces 'objectPointer >> 1' */

	/* ObjectMemory>>#integerValueOf: */
sqInt
integerValueOf(sqInt objectPointer)
{
	if ((objectPointer & 0x80000000U) != 0) {

		/* negative */
		return ((((usqInt) (objectPointer & 0x7FFFFFFF)) >> 1) - 0x3FFFFFFF) - 1;
	}
	else {

		/* positive */
		return ((usqInt) objectPointer) >> 1;
	}
}


/*	Answer if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* ObjectMemory>>#isArrayNonImm: */
sqInt
isArrayNonImm(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == 2;
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* ObjectMemory>>#isArray: */
sqInt
isArray(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == 2);
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* ObjectMemory>>#isBytes: */
sqInt
isBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()));
}


/*	N.B. Because Slang always inlines is:instanceOf:compactClassIndex:
	(because is:instanceOf:compactClassIndex: has an inline: pragma) the
	phrase (self splObj: ClassCharacter) is expanded in-place
	and is _not_ evaluated if oop has a non-zero CompactClassIndex. */

	/* ObjectMemory>>#isCharacterObject: */
sqInt
isCharacterObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassCharacter) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
}

	/* ObjectMemory>>#isCharacterValue: */
sqInt
isCharacterValue(sqInt anInteger)
{
	return ((anInteger >= 0) && (anInteger <= 0xFF));
}

	/* ObjectMemory>>#isCompiledMethodFormat: */
static sqInt NoDbgRegParms
isCompiledMethodFormat(sqInt format)
{
	return format >= (firstCompiledMethodFormat());
}


/*	Answer whether the argument header has compiled method format */

	/* ObjectMemory>>#isCompiledMethodHeader: */
static sqInt NoDbgRegParms
isCompiledMethodHeader(sqInt objHeader)
{
	return ((((usqInt) objHeader) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat());
}


/*	Answer whether the argument object is of compiled method format */

	/* ObjectMemory>>#isCompiledMethod: */
sqInt
isCompiledMethod(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat());
}

	/* ObjectMemory>>#isContextNonImm: */
static sqInt NoDbgRegParms
isContextNonImm(sqInt oop)
{
	/* begin isContextHeader: */
	return ((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex;
}

	/* ObjectMemory>>#isContext: */
static sqInt NoDbgRegParms
isContext(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
}

	/* ObjectMemory>>#isImmediate: */
sqInt
isImmediate(sqInt anOop)
{
	return (anOop & 1);
}

	/* ObjectMemory>>#isIndexable: */
sqInt
isIndexable(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= 2;
}


/*	Return true if the given address is in ST object memory */

	/* ObjectMemory>>#isInMemory: */
sqInt
isInMemory(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThanOrEqualTo(address, startOfMemory()))
	 && (oopisLessThan(address, GIV(endOfMemory)));
}

	/* ObjectMemory>>#isIntegerObject: */
sqInt
isIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) > 0;
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In C, use a shift and XOR to set the sign bit if and only if the top two
	bits of the given
	value are the same, then test the sign bit. Note that the top two bits are
	equal for
	exactly those integers in the range that can be represented in 31-bits or
	63-bits. 
 */

	/* ObjectMemory>>#isIntegerValue: */
sqInt
isIntegerValue(sqInt intValue)
{
	return (((sqInt)((((usqInt)intValue)) ^ ((((usqInt)intValue)) << 1)))) >= 0;
}


/*	Answer if oop's mark bit is set */

	/* ObjectMemory>>#isMarked: */
sqInt
isMarked(sqInt oop)
{
	return ((longAt(oop)) & MarkBit) != 0;
}

	/* ObjectMemory>>#isNonImmediate: */
sqInt
isNonImmediate(sqInt anOop)
{
	return (anOop & 1) == 0;
}

	/* ObjectMemory>>#isNonIntegerObject: */
sqInt
isNonIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) == 0;
}

	/* ObjectMemory>>#isObjImmutable: */
static sqInt NoDbgRegParms
isObjImmutable(sqInt anOop)
{
	return 
#  if IMMUTABILITY
		((longAt(anOop)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		;
}


/*	Answer whether the oop is an object of compiled method format */

	/* ObjectMemory>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()));
}


/*	Compatibility wth SpurMemoryManager. In ObjectMemory, no forwarding
	pointers are visible to the VM. */

	/* ObjectMemory>>#isOopForwarded: */
static sqInt NoDbgRegParms
isOopForwarded(sqInt oop)
{
	return 0;
}

	/* ObjectMemory>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt anOop)
{
	return ((anOop & 1))
	 || (
#  if IMMUTABILITY
		((longAt(anOop)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		);
}

	/* ObjectMemory>>#isOopMutable: */
sqInt
isOopMutable(sqInt anOop)
{
	return (!((anOop & 1)))
	 && (!(
#  if IMMUTABILITY
		((longAt(anOop)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		));
}


/*	For forward-compatibility with Spur. Answer false; ObjectMemory does not
	support pinning. */

	/* ObjectMemory>>#isPinned: */
sqInt
isPinned(sqInt objOop)
{
	return 0;
}


/*	Answer true if the argument has only fields that can hold oops. See
	comment in formatOf:
 */

	/* ObjectMemory>>#isPointers: */
sqInt
isPointers(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4);
}

	/* ObjectMemory>>#isPureBitsFormat: */
static sqInt NoDbgRegParms
isPureBitsFormat(sqInt format)
{
	return (format >= (firstLongFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWeakNonImm: */
static sqInt NoDbgRegParms
isWeakNonImm(sqInt oop)
{
	return ((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat());
}


/*	Answer true if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWeak: */
sqInt
isWeak(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat()));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* ObjectMemory>>#isWordsOrBytesNonImm: */
static sqInt NoDbgRegParms
isWordsOrBytesNonImm(sqInt oop)
{
    sqInt fmt;

	/* begin formatOf: */
	fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
	return (fmt == (firstLongFormat()))
	 || ((fmt >= (firstByteFormat()))
	 && (fmt < (firstCompiledMethodFormat())));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* ObjectMemory>>#isWordsOrBytes: */
sqInt
isWordsOrBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (isWordsOrBytesNonImm(oop));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWords: */
sqInt
isWords(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()));
}

	/* ObjectMemory>>#isYoung: */
sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & 1) == 0)
	 && (oopisGreaterThanOrEqualTo(oop, GIV(youngStart)));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* ObjectMemory>>#is:instanceOf:compactClassIndex: */
static sqInt NoDbgRegParms
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;

	if ((oop & 1)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	return classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* ObjectMemory>>#lengthOfMaybeImmediate: */
static sqInt NoDbgRegParms
lengthOfMaybeImmediate(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	if ((oop & 1)) {
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Return the number of indexable bytes or words in the given object. Assume
	the argument is not an integer. For a CompiledMethod, the size of the
	method header (in bytes) should be subtracted from the result.
 */

	/* ObjectMemory>>#lengthOf: */
sqInt
lengthOf(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	/* begin baseHeader: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Return the number of fixed and indexable bytes, words, or object pointers
	in the
	given object. Assume the given oop is not an integer. For a
	CompiledMethod, the size
	of the method header (in bytes) should be subtracted from the result of
	this method.
 */

	/* ObjectMemory>>#lengthOf:baseHeader:format: */
static sqInt NoDbgRegParms
lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt)
{
    sqInt sz;

	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
}

	/* ObjectMemory>>#literalCountOf: */
sqInt
literalCountOf(sqInt methodPointer)
{
    sqInt methodHeader;

	/* begin literalCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer));
	/* begin fetchPointer:ofObject: */
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	assert((methodHeader & 1));
	return ((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF);
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

	/* ObjectMemory>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt oop1;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l10;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l10:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if (((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
				longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == aClassOop) {
			longPrintOop(oop);
			/* begin cr */
			printf("\n");
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l6;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l6:	/* end accessibleObjectAfter: */;
	}
}


/*	Return the first free block after the given chunk in memory. */

	/* ObjectMemory>>#lowestFreeAfter: */
static sqInt NoDbgRegParms
lowestFreeAfter(sqInt chunk)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oopHeader;
    sqInt oopHeaderType;
    sqInt oopSize;

	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(oop, GIV(endOfMemory))) {
		/* begin baseHeader: */
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		if (oopHeaderType == HeaderTypeFree) {
			return oop;
		}
		if (oopHeaderType == HeaderTypeSizeAndClass) {
			oopSize = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
		}
		else {
			oopSize = oopHeader & SizeMask;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	error("expected to find at least one free object");
	return null;
}


/*	Mark all objects reachable from the given one.
	Trace from the given object even if it is old.
	Do not trace if it is already marked.
	Mark it only if it is a young object. */
/*	Tracer state variables:
	child		object being examined
	field		next field of child to examine
	parentField	field where child was stored in its referencing object */

	/* ObjectMemory>>#markAndTrace: */
sqInt
markAndTrace(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt action;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt child;
    sqInt childType;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt field;
    sqInt fmt;
    sqInt fmt1;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header2;
    sqInt header21;
    sqInt header3;
    sqInt lastFieldOffset;
    sqInt lastFieldOffset1;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt numOops;
    sqInt numOops1;
    sqInt objOop;
    sqInt oop1;
    sqInt oop11;
    sqInt parentField;
    sqInt sp;
    sqInt sp1;
    sqInt statMarkCountLocal;
    sqInt sz;
    sqInt sz1;
    sqInt type;
    sqInt type1;
    sqInt type2;
    sqInt typeBits;
    usqInt youngStartLocal;

	assert(addressCouldBeObjWhileForwarding(oop));
	header = longAt(oop);
	if (!((header & MarkBit) == 0)) {
		return 0;
	}
	header = (header & AllButTypeMask) | HeaderTypeGC;
	if (oopisGreaterThanOrEqualTo(oop, GIV(youngStart))) {
		header = header | MarkBit;
	}
	longAtput(oop, header);
	parentField = GCTopMarker;
	child = oop;
	/* begin lastPointerOf:recordWeakRoot: */
	header2 = longAt(oop);
	fmt = (((usqInt) header2) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if (fmt >= (indexablePointersFormat())) {
			if (fmt == 4) {
				if (GIV(weakRootCount) >= 0) {

					/* And remember as weak root */
					if (!(((GIV(weakRootCount) += 1)) <= WeakRootTableSize)) {
						error("weakRoots table overflow");
					}
					GIV(weakRoots)[GIV(weakRootCount)] = oop;
				}
				/* begin nonWeakFieldsOf: */
				assert(isWeakNonImm(oop));
				if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
					class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
				}
				else {
					/* begin fetchPointer:ofObject: */
					oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
					class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
				}
				classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
				numOops = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
				lastFieldOffset = numOops * BytesPerWord;
				goto l13;
			}
			if (((((usqInt) header2) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(oop);
				/* begin fetchStackPointerOf: */
				sp = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l10;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop)));
				contextSize = (sp >> 1);
			l10:	/* end fetchStackPointerOf: */;
				assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header2, fmt)));
				lastFieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l13;
			}
		}
		/* begin sizeBitsOfSafe: */
		header11 = longAt(oop);
		/* begin rightType: */
		type1 = ((header11 & SizeMask) == 0
			? HeaderTypeSizeAndClass
			: ((header11 & CompactClassMask) == 0
					? HeaderTypeClass
					: HeaderTypeShort));
		sz = (type1 == HeaderTypeSizeAndClass
			? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
			: header11 & SizeMask);
		lastFieldOffset = sz - BaseHeaderSize;
		goto l13;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		lastFieldOffset = 0;
		goto l13;
	}
	assert(isCompiledMethod(oop));
	header2 = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	assert((header2 & 1));
	numLiterals = ((((int) header2)) < 0
		? (/* begin literalCountOfAlternateHeader: */
			((header2 >> 1)) & AlternateHeaderNumLiteralsMask)
		: (/* begin literalCountOfOriginalHeader: */
			(((usqInt) header2) >> 10) & 0xFF));

	lastFieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l13:	/* end lastPointerOf:recordWeakRoot: */;
	field = oop + lastFieldOffset;
	action = StartField;
	youngStartLocal = GIV(youngStart);

	/* run the tracer state machine until all objects reachable from oop are marked */
	statMarkCountLocal = GIV(statMarkCount);
	do {
		if (action == StartField) {
			/* begin startField */
			while (1) {
				child = longAt(field);
				if (!((child & 1))) break;

				/* field contains a SmallInteger; skip it */
				field -= BytesPerWord;
			}
			typeBits = child & TypeMask;
			if (typeBits == 0) {

				/* normal oop, go down */
				longAtput(field, parentField);
				parentField = field;
				action = StartObj;
				goto l2;
			}
			assert(typeBits == 2);
			if ((child & CompactClassMask) != 0) {

				/* object's class is compact; we're done */
				/* restore the header type bits */
				child = child & AllButTypeMask;
				/* begin rightType: */
				childType = ((child & SizeMask) == 0
					? HeaderTypeSizeAndClass
					: ((child & CompactClassMask) == 0
							? HeaderTypeClass
							: HeaderTypeShort));
				longAtput(field, child | childType);
				action = Upward;
				goto l2;
			}

			/* class word */
			child = longAt(field - BytesPerWord);

			/* clear type bits */
			child = child & AllButTypeMask;
			longAtput(field - BytesPerWord, parentField);

			/* point at class word; mark as working on the class. */
			parentField = (field - BytesPerWord) | 1;
			action = StartObj;
		l2:	/* end startField */;
		}
		if (action == StartObj) {
			/* begin startObj */
			statMarkCountLocal += 1;
			if ((oopisLessThan(child, youngStartLocal))
			 || ((((header3 = longAt(child))) & MarkBit) != 0)) {

				/* already marked; skip it */
				field = child;
				action = Upward;
				goto l22;
			}
			/* begin lastPointerOf:recordWeakRoot: */
			objOop = child;
			header21 = longAt(objOop);
			fmt1 = (((usqInt) header21) >> (instFormatFieldLSB())) & 15;
			if (fmt1 <= 4) {
				if (fmt1 >= (indexablePointersFormat())) {
					if (fmt1 == 4) {
						/* begin nonWeakFieldsOf: */
						assert(isWeakNonImm(objOop));
						if (((ccIndex1 = (((usqInt) (longAt(objOop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
							class1 = (longAt(objOop - BaseHeaderSize)) & AllButTypeMask;
						}
						else {
							/* begin fetchPointer:ofObject: */
							oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
							class1 = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
						}
						classFormat1 = (longAt((class1 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
						numOops1 = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 0x3F)) - 1;
						lastFieldOffset1 = numOops1 * BytesPerWord;
						goto l18;
					}
					if (((((usqInt) header21) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objOop);
						/* begin fetchStackPointerOf: */
						sp1 = longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
						if (!((sp1 & 1))) {
							contextSize1 = 0;
							goto l17;
						}
						assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(objOop)));
						contextSize1 = (sp1 >> 1);
					l17:	/* end fetchStackPointerOf: */;
						assert((ReceiverIndex + contextSize1) < (lengthOfbaseHeaderformat(objOop, header21, fmt1)));
						lastFieldOffset1 = (CtxtTempFrameStart + contextSize1) * BytesPerOop;
						goto l18;
					}
				}
				/* begin sizeBitsOfSafe: */
				header12 = longAt(objOop);
				/* begin rightType: */
				type2 = ((header12 & SizeMask) == 0
					? HeaderTypeSizeAndClass
					: ((header12 & CompactClassMask) == 0
							? HeaderTypeClass
							: HeaderTypeShort));
				sz1 = (type2 == HeaderTypeSizeAndClass
					? (longAt(objOop - (BytesPerWord * 2))) & AllButTypeMask
					: header12 & SizeMask);
				lastFieldOffset1 = sz1 - BaseHeaderSize;
				goto l18;
			}
			if (fmt1 < (firstCompiledMethodFormat())) {
				lastFieldOffset1 = 0;
				goto l18;
			}
			assert(isCompiledMethod(objOop));
			header21 = longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

			/* begin lastPointerOfMethodHeader: */
			assert((header21 & 1));
			numLiterals1 = ((((int) header21)) < 0
				? (/* begin literalCountOfAlternateHeader: */
					((header21 >> 1)) & AlternateHeaderNumLiteralsMask)
				: (/* begin literalCountOfOriginalHeader: */
					(((usqInt) header21) >> 10) & 0xFF));

			lastFieldOffset1 = (((numLiterals1 + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
		l18:	/* end lastPointerOf:recordWeakRoot: */;
			header3 = (header3 & AllButTypeMask) | (MarkBit | HeaderTypeGC);
			longAtput(child, header3);
			field = child + lastFieldOffset1;
			action = StartField;
		l22:	/* end startObj */;
		}
		if (action == Upward) {
			/* begin upward */
			do {
				if ((parentField & 1) == 0) {

					/* normal */

					/* who we worked on below */
					child = field;

					/* where to put it */
					field = parentField;
					parentField = longAt(field);
					longAtput(field, child);

					/* point at header */
					field -= BytesPerWord;
					action = StartField;
					goto l5;
				}
				if (parentField == GCTopMarker) {

					/* top of the chain */
					header1 = (longAt(field)) & AllButTypeMask;
					/* begin rightType: */
					type = ((header1 & SizeMask) == 0
						? HeaderTypeSizeAndClass
						: ((header1 & CompactClassMask) == 0
								? HeaderTypeClass
								: HeaderTypeShort));
					longAtput(field, header1 | type);
					action = Done;
					goto l5;
				}

				/* oop of class */
				child = field;

				/* class word, ** clear the low bit ** */
				field = parentField - 1;
				parentField = longAt(field);

				/* base header word */
				header1 = longAt(field + BytesPerWord);
				/* begin rightType: */
				type = ((header1 & SizeMask) == 0
					? HeaderTypeSizeAndClass
					: ((header1 & CompactClassMask) == 0
							? HeaderTypeClass
							: HeaderTypeShort));
				longAtput(field, child | type);

				/* point at header */
				/* restore type bits */
				field += BytesPerWord;
				header1 = header1 & AllButTypeMask;
				longAtput(field, header1 | type);
			} while(1);
			action = null;
		l5:	/* end upward */;
		}
	} while(!(action == Done));
	GIV(statMarkCount) = statMarkCountLocal;
	return 0;
}


/*	Answer one of the objects in the SpecialObjectsArray, if in range,
	otherwise answer nil.
 */

	/* ObjectMemory>>#maybeSplObj: */
sqInt
maybeSplObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (index < (lengthOf(GIV(specialObjectsOop)))
		? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))))
		: 0);
}


/*	Answer the method header of a CompiledMethod object. */

	/* ObjectMemory>>#methodHeaderOf: */
static sqInt NoDbgRegParms
methodHeaderOf(sqInt methodObj)
{
	assert(isCompiledMethod(methodObj));
	return longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
}


/*	For access from BitBlt module & Cogit */

	/* ObjectMemory>>#nilObject */
sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}

	/* ObjectMemory>>#noShiftCompactClassIndexOfHeader: */
sqInt
noShiftCompactClassIndexOfHeader(sqInt header)
{
	return header & (0x1FU << (compactClassFieldLSB()));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* ObjectMemory>>#numBytesOfBytes: */
sqInt
numBytesOfBytes(sqInt objOop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	/* begin baseHeader: */
	header = longAt(objOop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(objOop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	/* begin formatOfHeader: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	assert(fmt >= (firstByteFormat()));
	return (sz - BaseHeaderSize) - (fmt & 3);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* ObjectMemory>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	/* begin baseHeader: */
	header = longAt(objOop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(objOop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	/* begin formatOfHeader: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	return (fmt < (firstByteFormat())
		? sz - BaseHeaderSize
		: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Answer the number of oop-sized elements in the given object.
	Unlike lengthOf: this does not adjust the length of a context
	by the stackPointer and so can be used e.g. by cloneContext: */

	/* ObjectMemory>>#numSlotsOf: */
sqInt
numSlotsOf(sqInt obj)
{
    sqInt header;
    sqInt sz;

	/* begin baseHeader: */
	header = longAt(obj);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(obj - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	return ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
}


/*	Return the object or start of free space immediately preceding the given
	address, object or free chunk in memory. If none, return 0. This is for
	debugging only. */

	/* ObjectMemory>>#objectBefore: */
sqInt
objectBefore(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = (oopisGreaterThan(address, GIV(youngStart))
		? GIV(youngStart)
		: startOfMemory());
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, address)) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if (oopisGreaterThanOrEqualTo(nextObj, address)) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	Return the object or start of free space immediately preceding the given
	object or free chunk in memory. If none, return 0. This is for debugging
	only.  */

	/* ObjectMemory>>#objectExactlyBefore: */
sqInt
objectExactlyBefore(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    sqInt sz;

	/* begin oopFromChunk: */
	chunk = (oopisGreaterThan(oop, GIV(youngStart))
		? GIV(youngStart)
		: startOfMemory());
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, obj)) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if (nextObj == oop) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	This message is deprecated but supported for a while via a tweak to
	sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead
	for new code
 */

	/* ObjectMemory>>#obsoleteDontUseThisFetchWord:ofObject: */
sqInt
obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop)
{
	/* begin fetchLong32:ofObject: */
	return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
}


/*	Compute the oop of this chunk by adding its extra header bytes. */

	/* ObjectMemory>>#oopFromChunk: */
static sqInt NoDbgRegParms
oopFromChunk(sqInt chunk)
{
	return chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
}


/*	Attempt to verify that the given oop has a reasonable behavior. The class
	must be a valid, non-integer oop and must not be nilObj. It must be a
	pointers object with three or more fields. Finally, the instance
	specification field of the behavior must match that of the instance.
 */

	/* ObjectMemory>>#oopHasOkayClass: */
static sqInt NoDbgRegParms
oopHasOkayClass(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    sqInt ccIndex;
    sqInt formatMask;
    usqInt oop;
    sqInt oop1;
    usqInt oopClass;
    sqInt oopFormatBits;

	oop = ((usqInt) signedOop);
	okayOop(oop);
	oopClass = ((usqInt) (((oop & 1)
	? (/* begin fetchPointer:ofObject: */
		longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
	: (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
				longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord()))))))))));
	if ((oopClass & 1)) {
		error("a SmallInteger is not a valid class or behavior");
		return 0;
	}
	if (!(okayOop(oopClass))) {
		error("class oop is not ok");
		return 0;
	}
	if (!((((((usqInt) (longAt(oopClass))) >> (instFormatFieldLSB())) & 15) <= 4)
		 && ((lengthOf(oopClass)) >= 3))) {
		error("a class (behavior) must be a pointers object of size >= 3");
		return 0;
	}
	if (((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {

		/* ignore extra bytes size bits */
		formatMask = 3072;
	}
	else {
		formatMask = 3840;
	}
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		error("object and its class (behavior) formats differ");
		return 0;
	}
	return 1;
}


/*	Pop and return the possibly remapped object from the remap buffer. */

	/* ObjectMemory>>#popRemappableOop */
sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	oop is an old object. If valueObj is young, mark the object as a root. */

	/* ObjectMemory>>#possibleRootStoreInto:value: */
static void NoDbgRegParms
possibleRootStoreIntovalue(sqInt oop, sqInt valueObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if ((oopisGreaterThanOrEqualTo(valueObj, GIV(youngStart)))
	 && (!((valueObj & 1)))) {

		/* Yes, valueObj is a young object */
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if (!((header & RootBit) != 0)) {

			/* record oop as root only if not already recorded */
			if (GIV(rootTableCount) < RootTableSize) {

				/* record root if there is enough room in the roots table.
				   IMPORTANT: since clearRootsTable is the only thing that clears root bits
				   do *not* set the root bit unless an object is in the root table.  checking
				   routines will complain about the root bit being unset instead of the table
				   being full, but that's life */
				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
				if (GIV(rootTableCount) >= RootTableRedZone) {

					/* if we're now in the red zone force an IGC ASAP */
					/* begin scheduleIncrementalGC */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
			}
			else {

				/* note overflow; will need to do a fullGC instead of an incremental. */
				GIV(rootTableOverflowed) = 1;
			}
		}
	}
}

	/* ObjectMemory>>#primitiveErrorTable */
sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

	/* ObjectMemory>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt oop1;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l10;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l10:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if (((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
				longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == aClassOop) {
			printHex(oop);
			/* begin cr */
			printf("\n");
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l6;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l6:	/* end accessibleObjectAfter: */;
	}
}


/*	Scan the heap printing the oops of any and all methods that implement
	anOop 
 */

	/* ObjectMemory>>#printMethodImplementorsOf: */
void
printMethodImplementorsOf(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt obj;
    sqInt obj1;
    sqInt sz;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			obj = obj1;
			goto l4;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj1);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		obj1 = (obj1 + sz) + (headerTypeBytes[(longAt(obj1 + sz)) & TypeMask]);
	}
	error("heap is empty");
	obj = null;
l4:	/* end firstAccessibleObject */;
	while (!(obj == null)) {
		if ((((((usqInt) (longAt(obj))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
		 && ((maybeSelectorOfMethod(obj)) == anOop)) {
			printHex(obj);
			/* begin space */
			putchar(' ');
			printOopShort(obj);
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

	/* ObjectMemory>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt obj;
    sqInt obj1;
    sqInt oop;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	/* begin firstAccessibleObject */
	chunk = startOfMemory();
	obj1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj1, GIV(freeStart))) {
		if (!(((longAt(obj1)) & TypeMask) == HeaderTypeFree)) {
			oop = obj1;
			goto l10;
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj1, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj1)) & TypeMask) == HeaderTypeFree) {
			sz2 = (longAt(obj1)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header2 = longAt(obj1);
			sz2 = ((header2 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(obj1 - (BytesPerWord * 2))) & LongSizeMask
				: header2 & SizeMask);
		}
		obj1 = (obj1 + sz2) + (headerTypeBytes[(longAt(obj1 + sz2)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l10:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
			i = (((assert((((assert(isCompiledMethod(oop)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(oop)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(oop)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(oop)),
			/* begin fetchPointer:ofObject: */
			longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart) - 1;
			while (i >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					i = 0;
				}
				i -= 1;
			}
		}
		/* begin accessibleObjectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header1 = longAt(oop);
			sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header1 & SizeMask);
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l6;
			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(obj - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
	l6:	/* end accessibleObjectAfter: */;
	}
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that objects in temporary variables are properly
	remapped. 
 */

	/* ObjectMemory>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}


/*	Map the given oop to its new value during a compaction or become:
	operation. 
 */

	/* ObjectMemory>>#remapObj: */
static sqInt NoDbgRegParms
remapObj(sqInt obj)
{
    sqInt fwdBlock;
    sqInt targetObj;

	/* begin remappedObj: */
	fwdBlock = ((sqInt)((usqInt)(((longAt(obj)) & AllButMarkBitAndTypeMask)) << 1));
	assert(fwdBlockValid(fwdBlock));
	targetObj = longAt(fwdBlock);
	assert(addressCouldBeObjWhileForwarding(targetObj));
	return targetObj;
}


/*	Map the given oop to its new value during a compaction or 
	become: operation. If it has no forwarding table entry, 
	return the oop itself. */

	/* ObjectMemory>>#remap: */
sqInt
remap(sqInt oop)
{
    sqInt fwdBlock;
    sqInt targetObj;

	if (((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0)) {
		/* begin remappedObj: */
		fwdBlock = ((sqInt)((usqInt)(((longAt(oop)) & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock));
		targetObj = longAt(fwdBlock);
		assert(addressCouldBeObjWhileForwarding(targetObj));
		return targetObj;
	}
	return oop;
}


/*	Remove the given variable location to the extra roots table */

	/* ObjectMemory>>#removeGCRoot: */
EXPORT(sqInt)
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Remove the given young root from the root table (for freeObject: for
	becomeForward:). 
 */

	/* ObjectMemory>>#removeYoungRoot: */
static sqInt NoDbgRegParms
removeYoungRoot(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(rootTableCount); i++) {
		if (obj == (GIV(rootTable)[i])) {

			/* swap obj with last entry */
			GIV(rootTable)[i] = (GIV(rootTable)[GIV(rootTableCount)]);
			GIV(rootTableCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Answer if the oop should be remapped */

	/* ObjectMemory>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt oop)
{
	/* begin isObjectForwarded: */
	return ((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0);
}


/*	Answer if the oop should be remapped */

	/* ObjectMemory>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0));
}

	/* ObjectMemory>>#sixtyFourBitIndexableFormat */
static sqInt
sixtyFourBitIndexableFormat(void)
{
	return 7;
}


/*	Returns the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

	/* ObjectMemory>>#slotSizeOf: */
sqInt
slotSizeOf(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    sqInt sz;

	if ((oop & 1)) {
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Return one of the objects in the SpecialObjectsArray */

	/* ObjectMemory>>#splObj: */
sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
}


/*	Part of InterpreterProxy's 1.14 API */

	/* ObjectMemory>>#statNumGCs */
EXPORT(sqInt)
statNumGCs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(statIncrGCs) + GIV(statFullGCs);
}


/*	Like storePointer:ofObject:withValue:, but the caller guarantees that the
	object being stored into is a young object or is already marked as a root. */

	/* ObjectMemory>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{
	return longAtput((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

	/* ObjectMemory>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (oopisLessThan(oop, GIV(youngStart))) {
		possibleRootStoreIntovalue(oop, valuePointer);
	}
	return longAtput((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory.
	Caution: This may invoke the garbage collector. */

	/* ObjectMemory>>#stringForCString: */
sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteString) << (shiftForWord()))))), len);
	if (!(newString == null)) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

	/* ObjectMemory>>#tenuringIncrementalGC */
void
tenuringIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(forceTenureFlag) = 1;
	incrementalGC();
}


/*	Returns the top of the remappable oop. Useful when writing loops. */

	/* ObjectMemory>>#topRemappableOop */
sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}

	/* ObjectMemory>>#trueObject */
sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}


/*	update pointers in the given memory range */

	/* ObjectMemory>>#updatePointersInRangeFrom:to: */
static void NoDbgRegParms
updatePointersInRangeFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock2;
    sqInt fwdBlock3;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header2;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    sqInt numLiterals;
    sqInt oop;
    sqInt realHeader;
    sqInt size;
    sqInt sp;
    sqInt sz;
    sqInt sz1;
    sqInt targetObj;
    sqInt targetObj1;

	oop = memStart + (headerTypeBytes[(longAt(memStart)) & TypeMask]);
	while (oopisLessThan(oop, memEnd)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			/* begin remapFieldsAndClassOf: */
			header1 = longAt(oop);
			if ((header1 & MarkBit) != 0) {

				/* oop is forwarded; get its real header from its forwarding table entry */
				fwdBlock2 = ((sqInt)((usqInt)((header1 & AllButMarkBitAndTypeMask)) << 1));
				assert(fwdBlockValid(fwdBlock2));
				header1 = longAt(fwdBlock2 + BytesPerWord);
			}
			header = header1;
			fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
			if (fmt <= 4) {
				if ((fmt == (indexablePointersFormat()))
				 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l7;
					}
					contextSize = (sp >> 1);
				l7:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
					goto l10;
				}
				size = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
					: header & SizeMask);
				fieldOffset = size - BaseHeaderSize;
				goto l10;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				fieldOffset = 0;
				goto l10;
			}
			assert(isCompiledMethodHeader(header));
			header = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
			/* begin lastPointerOfMethodHeader: */
			assert((header & 1));
			numLiterals = ((((int) header)) < 0
				? (/* begin literalCountOfAlternateHeader: */
					((header >> 1)) & AlternateHeaderNumLiteralsMask)
				: (/* begin literalCountOfOriginalHeader: */
					(((usqInt) header) >> 10) & 0xFF));

			fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
		l10:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {

					/* update this oop from its forwarding block */
					/* begin remappedObj: */
					fwdBlock = ((sqInt)((usqInt)(((longAt(fieldOop)) & AllButMarkBitAndTypeMask)) << 1));
					assert(fwdBlockValid(fwdBlock));
					targetObj = longAt(fwdBlock);
					assert(addressCouldBeObjWhileForwarding(targetObj));
					newOop = targetObj;
					longAtput(oop + fieldOffset, newOop);
					if ((oopisLessThan(oop, GIV(youngStart)))
					 && (oopisGreaterThanOrEqualTo(newOop, GIV(youngStart)))) {
						beRootWhileForwarding(oop);
					}
				}
				fieldOffset -= BytesPerWord;
			}
			/* begin remapClassOf: */
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l5;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock1 = ((sqInt)((usqInt)(((longAt(classOop)) & AllButMarkBitAndTypeMask)) << 1));
				assert(fwdBlockValid(fwdBlock1));
				targetObj1 = longAt(fwdBlock1);
				assert(addressCouldBeObjWhileForwarding(targetObj1));
				newClassOop = targetObj1;
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if ((oopisLessThan(oop, GIV(youngStart)))
				 && (oopisGreaterThanOrEqualTo(newClassOop, GIV(youngStart)))) {
					beRootWhileForwarding(oop);
				}
			}
		l5:	/* end remapClassOf: */;
		}
		/* begin objectAfterWhileForwarding: */
		header2 = longAt(oop);
		if ((header2 & MarkBit) == 0) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header11 = longAt(oop);
				sz1 = ((header11 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header11 & SizeMask);
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l12;
		}
		fwdBlock3 = ((sqInt)((usqInt)((header2 & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock3));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock3 + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	l12:	/* end objectAfterWhileForwarding: */;
	}
}


/*	update pointers in root objects */

	/* ObjectMemory>>#updatePointersInRootObjectsFrom:to: */
static void NoDbgRegParms
updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fwdBlock;
    sqInt fwdBlock1;
    sqInt fwdBlock2;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    sqInt numLiterals;
    sqInt oop;
    sqInt size;
    sqInt sp;
    sqInt targetObj;
    sqInt targetObj1;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		if ((oopisLessThan(oop, memStart))
		 || (oopisGreaterThanOrEqualTo(oop, memEnd))) {

			/* Note: must not remap the fields of any object twice! */
			/* remap this oop only if not in the memory range
			   covered below */
			/* begin remapFieldsAndClassOf: */
			header1 = longAt(oop);
			if ((header1 & MarkBit) != 0) {

				/* oop is forwarded; get its real header from its forwarding table entry */
				fwdBlock2 = ((sqInt)((usqInt)((header1 & AllButMarkBitAndTypeMask)) << 1));
				assert(fwdBlockValid(fwdBlock2));
				header1 = longAt(fwdBlock2 + BytesPerWord);
			}
			header = header1;
			fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
			if (fmt <= 4) {
				if ((fmt == (indexablePointersFormat()))
				 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l7;
					}
					contextSize = (sp >> 1);
				l7:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
					goto l10;
				}
				size = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask
					: header & SizeMask);
				fieldOffset = size - BaseHeaderSize;
				goto l10;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				fieldOffset = 0;
				goto l10;
			}
			assert(isCompiledMethodHeader(header));
			header = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
			/* begin lastPointerOfMethodHeader: */
			assert((header & 1));
			numLiterals = ((((int) header)) < 0
				? (/* begin literalCountOfAlternateHeader: */
					((header >> 1)) & AlternateHeaderNumLiteralsMask)
				: (/* begin literalCountOfOriginalHeader: */
					(((usqInt) header) >> 10) & 0xFF));

			fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
		l10:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {

					/* update this oop from its forwarding block */
					/* begin remappedObj: */
					fwdBlock = ((sqInt)((usqInt)(((longAt(fieldOop)) & AllButMarkBitAndTypeMask)) << 1));
					assert(fwdBlockValid(fwdBlock));
					targetObj = longAt(fwdBlock);
					assert(addressCouldBeObjWhileForwarding(targetObj));
					newOop = targetObj;
					longAtput(oop + fieldOffset, newOop);
					if ((oopisLessThan(oop, GIV(youngStart)))
					 && (oopisGreaterThanOrEqualTo(newOop, GIV(youngStart)))) {
						beRootWhileForwarding(oop);
					}
				}
				fieldOffset -= BytesPerWord;
			}
			/* begin remapClassOf: */
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l5;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock1 = ((sqInt)((usqInt)(((longAt(classOop)) & AllButMarkBitAndTypeMask)) << 1));
				assert(fwdBlockValid(fwdBlock1));
				targetObj1 = longAt(fwdBlock1);
				assert(addressCouldBeObjWhileForwarding(targetObj1));
				newClassOop = targetObj1;
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if ((oopisLessThan(oop, GIV(youngStart)))
				 && (oopisGreaterThanOrEqualTo(newClassOop, GIV(youngStart)))) {
					beRootWhileForwarding(oop);
				}
			}
		l5:	/* end remapClassOf: */;
		}
	}
}


/*	return 0 for little endian, 1 for big endian */
/*	?!*#$%! _Terrible_ name. Call it what it is.
	VMBIGENDIAN or VMLITTLEENDIAN. Dont leave us guessing!!!!
	Alas this has to remain for backward compatibility. */

	/* ObjectMemory>>#vmEndianness */
sqInt
vmEndianness(void)
{
	return (VMBIGENDIAN
		? 1
		: 0);
}


/*	Answer the current activeProcess. */
/*	useful for VM debugging */

	/* StackInterpreter>>#activeProcess */
sqInt
activeProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	/* begin fetchPointer:ofObject: */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	return longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
}


/*	The various poll/select calls in the VM should attempt to tally the
	ammount of time spent at idle here, so as to render the uptime value
	meaningful. 
 */

	/* StackInterpreter>>#addIdleUsecs: */
EXPORT(void)
addIdleUsecs(sqInt idleUsecs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(statIdleUsecs) += idleUsecs;
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

	/* StackInterpreter>>#addLastLink:toList: */
static void NoDbgRegParms
addLastLinktoList(sqInt proc, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert(!((isForwarded(proc))));
	assert(!((isForwarded(aList))));
	assert((fetchPointerofObject(NextLinkIndex, proc)) == (nilObject()));
	if ((assert(!(isForwarded(aList))),
	(longAt((aList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aList, GIV(youngStart))) {
			possibleRootStoreIntovalue(aList, proc);
		}
		longAtput((aList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))), proc);
	}
	else {
		lastLink = longAt((aList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))));
		assert(lastLink != proc);
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(lastLink, GIV(youngStart))) {
			possibleRootStoreIntovalue(lastLink, proc);
		}
		longAtput((lastLink + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))), proc);
	}
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(aList, GIV(youngStart))) {
		possibleRootStoreIntovalue(aList, proc);
	}
	longAtput((aList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))), proc);
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(proc, GIV(youngStart))) {
		possibleRootStoreIntovalue(proc, aList);
	}
	longAtput((proc + BaseHeaderSize) + (((int)((usqInt)(MyListIndex) << (shiftForWord())))), aList);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */

	/* StackInterpreter>>#addNewMethodToCache: */
static void NoDbgRegParms
addNewMethodToCache(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt hash;
    sqInt methodHeader;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt probe;

	/* begin methodCacheHashOf:with: */
	classTag = classObj;
	hash = GIV(messageSelector) ^ classTag;
	if (((GIV(newMethod) & 1) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
		/* begin primitiveIndexOfMethod:header: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

		primBits = (methodHeader >> 1);
		primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod)))
		 && (isForwarded(GIV(newMethod)))));
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = classObj;
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));

			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */
	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = classObj;
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */
	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static sqInt NoDbgRegParms
addressCouldBeClassObj(sqInt maybeClassObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((maybeClassObj & 3) == 0)
	 && (((((usqInt)maybeClassObj)) >= (startOfMemory()))
	 && (((((usqInt)maybeClassObj)) < GIV(freeStart))
	 && (((longAt(maybeClassObj)) & TypeMask) != HeaderTypeGC))))
	 && (objCouldBeClassObj(maybeClassObj));
}

	/* StackInterpreter>>#allOnesAsCharStar */
static char *
allOnesAsCharStar(void)
{
	return ((char *) (((usqInt) -1)));
}


/*	for Cogit */

	/* StackInterpreter>>#argumentCountOfClosure: */
sqInt
argumentCountOfClosure(sqInt closurePointer)
{
    sqInt oop;

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((closurePointer + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	return (oop >> 1);
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
sqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
sqInt
argumentCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin argumentCountOfMethodHeader: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#arrayValueOf: */
void *
arrayValueOf(sqInt arrayOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (((arrayOop & 1) == 0)
	 && (isWordsOrBytesNonImm(arrayOop))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Returns an integer object */

	/* StackInterpreter>>#asciiOfCharacter: */
static sqInt NoDbgRegParms
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (isinstanceOfcompactClassIndex(characterObj, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassCharacter) << (shiftForWord()))))), 0)) {
		return (CharacterTable == null
			? integerObjectOfCharacterObject(characterObj)
			: longAt((characterObj + BaseHeaderSize) + (((int)((usqInt)(CharacterValueIndex) << (shiftForWord()))))));
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	return ConstZero;
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s: */
void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp)
{
	assertValidExecutionPointersimbarline(lip, lifp, lisp, !0, __LINE__);
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s:imbar:line: */
static void NoDbgRegParms
assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertl(inInterpreter, ln);
	assertl(GIV(stackPage) == (mostRecentlyUsedPage()), ln);
	/* begin assertValidStackLimits: */
	assertl((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (allOnesAsCharStar())), ln);
	assertl((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (allOnesAsCharStar())), ln);
	assertl(addressIsInPage(GIV(stackPage), lfp), ln);
	assertl(lsp < lfp, ln);
	assertl(lfp > lsp, ln);
	assertl(lsp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())), ln);
	assertl(((lfp - lsp) / BytesPerOop) < LargeContextSlots, ln);
	assertl(validInstructionPointerinFrame(lip, lfp), ln);
	assertl((frameIsBlockActivation(lfp))
	 || ((pushedReceiverOrClosureOfFrame(lfp)) == (frameReceiver(lfp))), ln);
	assertl(GIV(method) == (frameMethod(lfp)), ln);
	}


/*	convert true and false (Smalltalk) to true or false(C) */

	/* StackInterpreter>>#booleanValueOf: */
sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	return null;
}


/*	Re-enter the interpreter for executing a callback */
/*	For now, do not allow a callback unless we're in a primitiveResponse */

	/* StackInterpreter>>#callbackEnter: */
EXPORT(sqInt)
callbackEnter(sqInt *callbackID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt xArray;

	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(asserta(GIV(jmpDepth) < MaxJumpBuf))) {
		return 0;
	}

	/* Suspend the currently active process */
	GIV(jmpDepth) += 1;
	GIV(suspendedCallbacks)[GIV(jmpDepth)] = (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord()))))))));
	GIV(suspendedMethods)[GIV(jmpDepth)] = GIV(newMethod);
	/* begin signalExternalSemaphores */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	doSignalExternalSemaphores(numSlotsOf(xArray));
	if ((GIV(suspendedCallbacks)[GIV(jmpDepth)]) == (fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord()))))))))) {
		transferTo(wakeHighestPriority());
	}
	forceInterruptCheck();
	if ((setjmp(GIV(jmpBuf)[GIV(jmpDepth)])) == 0) {

		/* Fill in callbackID */
		callbackID[0] = GIV(jmpDepth);
		interpret();
	}
	putToSleepyieldingIf(fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord()))))))), GIV(preemptionYields));
	transferTo(GIV(suspendedCallbacks)[GIV(jmpDepth)]);

	/* see comment above */
	GIV(newMethod) = GIV(suspendedMethods)[GIV(jmpDepth)];
	/* begin argumentCountOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	GIV(argumentCount) = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;

	/* clean out the primPops etc since we'll be returning via primitive */
	GIV(jmpDepth) -= 1;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	return 1;
}


/*	Leave from a previous callback */
/*	For now, do not allow a callback return unless we're in a
	primitiveResponse 
 */

	/* StackInterpreter>>#callbackLeave: */
EXPORT(sqInt)
callbackLeave(sqInt cbID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(cbID == GIV(jmpDepth))) {
		return 0;
	}
	if (cbID < 1) {
		return 0;
	}
	longjmp(GIV(jmpBuf)[GIV(jmpDepth)], 1);
	return null;
}


/*	Context switch should not be allowed on every method activation. In
	particular the implementation of ensure: and ifCurtailed: depends on there
	being no
	suspension point on failing primitive 198 (primitiveMarkUnwindMethod).
	slowPrimitiveResponse states
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod. */

	/* StackInterpreter>>#canContextSwitchIfActivating:header: */
sqInt
canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt primBits;
    sqInt primitiveIndex;

	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


	return 
#  if 1
		primitiveIndex != 198
#  else /* 1 */
		(primitiveIndex == 0)
			 || ((((primitiveIndex >= 85) && (primitiveIndex <= 88)))
			 || (primitiveIndex == 167))
#  endif /* 1 */
		;
}


/*	Above ObjectMemory, arg must lie in range 0-255! */

	/* StackInterpreter>>#characterForAscii: */
sqInt
characterForAscii(sqInt ascii)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;

	return (CharacterTable == null
		? (((ascii >= 0) && (ascii <= 0xFF))
				? (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))))),
					longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(ascii) << (shiftForWord()))))))
				: GIV(nilObj))
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CharacterTable) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ascii) << (shiftForWord())))))));
}


/*	Ensure that all accessible objects in the heap are okay. */

	/* StackInterpreter>>#checkAllAccessibleObjectsOkay */
sqInt
checkAllAccessibleObjectsOkay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt ok;
    sqInt oop;
    sqInt oop1;
    sqInt realHeader;
    sqInt sz;
    sqInt sz1;

	ok = 1;
	/* begin allObjectsDoSafely: */
	chunk = startOfMemory();
	oop1 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop1)) < GIV(freeStart)) {
		if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
			ok = ok && (checkOkayFields(oop1));

		}
		/* begin objectAfterWhileForwarding: */
		header = longAt(oop1);
		if ((header & MarkBit) == 0) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop1, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop1);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop1 = (oop1 + sz1) + (headerTypeBytes[(longAt(oop1 + sz1)) & TypeMask]);
			goto l3;
		}
		fwdBlock = ((sqInt)((usqInt)((header & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = realHeader & SizeMask;
		}
		oop1 = (oop1 + sz) + (headerTypeBytes[(longAt(oop1 + sz)) & TypeMask]);
	l3:	/* end objectAfterWhileForwarding: */;
	}
	return ok;
}


/*	This is a no-op in the StackVM */

	/* StackInterpreter>>#checkCodeIntegrity: */
static sqInt NoDbgRegParms
checkCodeIntegrity(sqInt fullGCFlag)
{
	return 1;
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

	/* StackInterpreter>>#checkDeliveryOfLongRunningPrimitiveSignal */
static sqInt
checkDeliveryOfLongRunningPrimitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore) != null)
	 && (GIV(longRunningPrimitiveSignalUndelivered)))) {

		/* but not yet delivered */
		GIV(longRunningPrimitiveSignalUndelivered) = 0;

		/* Signal the LRP check semaphore if it is present */
		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
		 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
			? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
			: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore));
	}
	return 0;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#checkedIntegerValueOf: */
sqInt
checkedIntegerValueOf(sqInt intOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

	/* StackInterpreter>>#checkForEventsMayContextSwitch: */
static sqInt NoDbgRegParms
checkForEventsMayContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt oop;
    sqInt sema;
    sqInt switched;


	/* restore the stackLimit if it has been smashed. */
	GIV(statCheckForEvents) += 1;
	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	ioSynchronousCheckForEvents();
	if (GIV(needGCFlag)) {

		/* sufficientSpaceAfterGC: runs the incremental GC and
		   then, if not enough space is available, the fullGC. */
		if (!(sufficientSpaceAfterGC(0))) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
	}
	if (!mayContextSwitch) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
	 && ((ioHighResClock()) >= GIV(nextProfileTick)))) {

		/* Take a sample (if not already done so) for the profiler if it is active.  This
		   must be done before any of the synchronousSignals below or else we will
		   attribute a pause in ioRelinquishProcessor to the newly activated process. */
		GIV(nextProfileTick) = 0;
		if (GIV(profileProcess) == GIV(nilObj)) {
			/* begin fetchPointer:ofObject: */
			oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
			GIV(profileProcess) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
			/* begin nilObject */
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore)))) {
			switched = 1;
		}
	}
	if (checkDeliveryOfLongRunningPrimitiveSignal()) {
		switched = 1;
	}
	if (GIV(signalLowSpace)) {
		/* begin signalLowSpace: */
		GIV(signalLowSpace) = 0;
		/* begin splObj: */
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (((now = ioUTCMicroseconds())) >= GIV(nextPollUsecs)) {
		GIV(statIOProcessEvents) += 1;
		ioProcessEvents();

		/* msecs to wait before next call to ioProcessEvents.  Note that strictly
		   speaking we might need to update 'now' at this point since
		   ioProcessEvents could take a very long time on some platforms */
		GIV(nextPollUsecs) = now + 20000;
	}

	if (GIV(interruptPending)) {

		/* reset interrupt flag */
		GIV(interruptPending) = 0;
		/* begin splObj: */
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheInterruptSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs) != 0) {
		if (now >= GIV(nextWakeupUsecs)) {

			/* set timer interrupt to 0 for 'no timer' */
			GIV(nextWakeupUsecs) = 0;
			/* begin splObj: */
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheTimerSemaphore) << (shiftForWord())))));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		GIV(pendingFinalizationSignals) = 0;
		/* begin splObj: */
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheFinalizationSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (signalExternalSemaphores()) {
		switched = 1;
	}
	return switched;
}


/*	Read and verify the image file version number and return true if the the
	given image file needs to be byte-swapped. As a side effect, position the
	file stream just after the version number of the image header. This code
	prints a warning and does a hard-exit if it cannot find a valid version
	number. 
 */
/*	This code is based on C code by Ian Piumarta. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt: */
static sqInt NoDbgRegParms
checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset)
{
    sqInt firstVersion;
    sqInt version;
    int w;
    int w1;
    int w2;


	/* check the version number */
	sqImageFileSeek(f, imageOffset);
	version = (firstVersion = getWord32FromFileswap(f, 0));
	if ((version == (6505))
	 || (version == ((BytesPerWord == 4
		? 6504
		: 68002)))) {
		return 0;
	}
	sqImageFileSeek(f, imageOffset);
	/* begin getWord32FromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(int), 1, f);
	version = SQ_SWAP_4_BYTES(w2);
	if ((version == (6505))
	 || (version == ((BytesPerWord == 4
		? 6504
		: 68002)))) {
		return 1;
	}
	if (imageOffset == 0) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 512);
		/* begin getWord32FromFile:swap: */
		w = 0;
		sqImageFileRead((&w), sizeof(int), 1, f);
		version = w;
		if ((version == (6505))
		 || (version == ((BytesPerWord == 4
			? 6504
			: 68002)))) {
			return 0;
		}
		sqImageFileSeek(f, 512);
		/* begin getWord32FromFile:swap: */
		w1 = 0;
		sqImageFileRead((&w1), sizeof(int), 1, f);
		version = SQ_SWAP_4_BYTES(w1);
		if ((version == (6505))
		 || (version == ((BytesPerWord == 4
			? 6504
			: 68002)))) {
			return 1;
		}
	}
	print("This interpreter (vers. ");
	printNum(6505);
	print(") cannot read image file (vers. ");
	printNum(firstVersion);
	print(").");
	/* begin cr */
	printf("\n");
	print("Press CR to quit...");
	getchar();
	ioExitWithErrorCode(1);
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer 0 if all checks pass. */

	/* StackInterpreter>>#checkInterpreterIntegrity */
static sqInt
checkInterpreterIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;

	flags = 0;
	if (!(checkOopIntegritynamed(GIV(specialObjectsOop), "specialObjectsOop"))) {
		flags = 1;
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod"))) {
		flags += 2;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess"))) {
		flags += 4;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod"))) {
		flags += 8;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore"))) {
		flags += 16;
	}
	if (!(GIV(tempOop) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop"))) {
			flags += 32;
		}
	}
	if (!(GIV(tempOop2) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop2), "tempOop2"))) {
			flags += 64;
		}
	}
	if (!(GIV(tempOop3) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop3), "tempOop3"))) {
			flags += 128;
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		if (!(checkOopIntegritynamedindex(GIV(suspendedCallbacks)[i], "suspendedCallbacks", i))) {
			flags += 256;
		}
		if (!(checkOopIntegritynamedindex(GIV(suspendedMethods)[i], "suspendedMethods", i))) {
			flags += 512;
		}
	}
	return flags;
}


/*	Another version of isWidowedContext: for debugging.
	This will not bereave a widowed context. */

	/* StackInterpreter>>#checkIsStillMarriedContext:currentFP: */
static sqInt NoDbgRegParms
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *limitFP;
    char *maybeFP;
    sqInt maybeFrameCtxt;
    sqInt senderOop;
    StackPage *thePage;

	if (!((((aContext & 1) == 0)
		 && (((((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && (((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
		return 0;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	maybeFP = pointerForOop(senderOop - 1);

	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(maybeFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	limitFP = ((thePage == GIV(stackPage))
	 && (currentFP != null)
		? currentFP
		: (thePage->headFP));
	if (!((maybeFP >= limitFP)
		 && ((((((sqInt)(pointerForOop(longAt(maybeFP + FoxSavedFP))))) & 1) == 0)
		 && ((((assert(((oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) & (BytesPerWord - 1)) == 0),
		(oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) + 1)) == (longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))))
		 && ((byteAt((maybeFP + FoxFrameFlags) + 2)) != 0))))) {
		return 0;
	}

	/* On Spur we need to follow the context to check for a match, but since the VM is
	   only speculating about maybeFrame being a frame, and only speculating about
	   maybeContext being a context, we need to be sure before we can safely follow. */
	maybeFrameCtxt = longAt(maybeFP + FoxThisContext);
	return maybeFrameCtxt == aContext;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

	/* StackInterpreter>>#checkOkayFields: */
static sqInt NoDbgRegParms
checkOkayFields(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;
    sqInt i1;
    sqInt oop1;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((oop & 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
		 || (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return 1;
	}
	hasYoung = isYoung((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord()))))))));
	if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		i = (((assert((((assert(isCompiledMethod(oop)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(oop)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(oop)),
/* begin fetchPointer:ofObject: */
longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(oop)),
			/* begin fetchPointer:ofObject: */
			longAt((oop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart) - 1;
	}
	else {
		if (((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOf(oop)) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (!((fieldOop & 1))) {
			hasYoung = hasYoung
			 || (((fieldOop & 1) == 0)
			 && (oopisGreaterThanOrEqualTo(fieldOop, GIV(youngStart))));
			if (!(checkOkayOop(fieldOop))) {
				return 0;
			}
			if (!(checkOopHasOkayClass(fieldOop))) {
				return 0;
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if (oopisGreaterThanOrEqualTo(oop, GIV(youngStart))) {
			return 1;
		}
		if (!(((longAt(oop)) & RootBit) != 0)) {
			print("root bit is not set in ");
			printHex(oop);
			/* begin cr */
			printf("\n");
			return 0;
		}
		for (i1 = 1; i1 <= GIV(rootTableCount); i1 += 1) {
			if (oop == (GIV(rootTable)[i1])) {
				return 1;
			}
		}
		printHex(oop);
		print(" has root bit set but is not in rootTable");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

	/* StackInterpreter>>#checkOkayInterpreterObjects: */
sqInt
checkOkayInterpreterObjects(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt ok;
    sqInt oop;
    sqIntptr_t oopOrZero;

	ok = 1;
	ok = ok && (checkOkayFields(GIV(nilObj)));
	ok = ok && (checkOkayFields(GIV(falseObj)));
	ok = ok && (checkOkayFields(GIV(trueObj)));
	ok = ok && (checkOkayFields(GIV(specialObjectsOop)));
	ok = ok && (checkOkayFields(GIV(messageSelector)));
	ok = ok && (checkOkayFields(GIV(newMethod)));
	ok = ok && (checkOkayFields(GIV(lkupClass)));
	for (i = 0; i < MethodCacheEntries; i += MethodCacheEntrySize) {
		oopOrZero = GIV(methodCache)[i + MethodCacheSelector];
		if (!(oopOrZero == 0)) {
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheSelector]));
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheClass]));

			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheMethod]));
		}
	}
	for (i = 1, iLimiT = (remapBufferCount()); i <= iLimiT; i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & 1))) {
			ok = ok && (checkOkayFields(oop));
		}
	}
	ok = ok && (checkOkayStackZone(writeBack));
	return ok;
}

	/* StackInterpreter>>#checkOkayStackPage: */
static sqInt NoDbgRegParms
checkOkayStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt ok;
    sqInt oop;
    char *theFP;
    char *theSP;

	theSP = (thePage->headSP);
	theFP = (thePage->headFP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	ok = 1;
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				ok = ok && (checkOkayFields(oop));
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			ok = ok && (checkOkayFields(longAt(theFP + FoxThisContext)));
		}
		ok = ok && (checkOkayFields(longAt(theFP + FoxMethod)));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			ok = ok && (checkOkayFields(oop));
		}
		theSP += BytesPerWord;
	}
	return ok;
}


/*	Check that all objects in the stack zone are okay */

	/* StackInterpreter>>#checkOkayStackZone: */
static sqInt NoDbgRegParms
checkOkayStackZone(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;
    StackPage *thePage;

	if (writeBack) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			ok = ok && (checkOkayStackPage(thePage));
		}
	}
	return ok;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

	/* StackInterpreter>>#checkProfileTick: */
static void NoDbgRegParms
checkProfileTick(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock()) >= GIV(nextProfileTick)) {
		/* begin fetchPointer:ofObject: */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		GIV(profileProcess) = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		if (!GIV(primFailCode)) {
			GIV(profileMethod) = aPrimitiveMethod;
		}
		else {
			/* begin nilObject */
			GIV(profileMethod) = GIV(nilObj);
		}
		forceInterruptCheck();
		GIV(nextProfileTick) = 0;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

	/* StackInterpreter>>#checkStackIntegrity */
static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt ok;
    sqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & 1) == 0)
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					oop = longAt(theFP + FoxThisContext);
					if (((oop & 1))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!(((oop & 1) == 0)
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & 1) == 0)
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
						 && (((longAt((oop + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & 1) == 0)
						 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
						 && ((((longAt((oop + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((frameOfMarriedContext(oop)) == theFP)))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext);
						ok = 0;
					}
				}
				oop = longAt(theFP + FoxMethod);
				if (((oop & 1))
				 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame mthd", theFP, theFP + FoxMethod);
					ok = 0;
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 1) == 0)
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}


/*	Version of stackPointerForMaybeMarriedContext: with no side-effects (does
	not widow).
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the stackPointer of a Context. */

	/* StackInterpreter>>#checkStackPointerForMaybeMarriedContext: */
static sqInt NoDbgRegParms
checkStackPointerForMaybeMarriedContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodPointer;
    sqInt sp;
    sqInt sp1;

	if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
		sp = checkStackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
		return sp;
	}
	if (((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		/* begin argumentCountOf: */
		methodPointer = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
		/* begin argumentCountOfMethodHeader: */
		assert(isCompiledMethod(methodPointer));
		header = longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

		return (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	}
	/* begin fetchStackPointerOf: */
	sp1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((sp1 & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(aContext)));
	return (sp1 >> 1);
}


/*	Version of stackPointerIndexForFrame: that does not depend on writing back
	head frame pointers.
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#checkStackPointerIndexForFrame: */
static sqInt NoDbgRegParms
checkStackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    sqInt index;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (theFP == GIV(framePointer)) {
		return (((usqInt) ((theFP + FoxReceiver) - GIV(stackPointer))) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
	}
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage == GIV(stackPage)
		? GIV(framePointer)
		: (thePage->headFP));
	assert(!(isFree(thePage)));
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l2;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l2;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + (frameStackedReceiverOffset(prevFrame))) + BytesPerWord;

			goto l2;
		}
	}
	theSP = null;
l2:	/* end findSPOrNilOf:on:startingFrom: */;
	return (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	Check if aClass's name is className */

	/* StackInterpreter>>#classNameOf:Is: */
static sqInt NoDbgRegParms
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOf(aClass)) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))));
	if (!(((name & 1) == 0)
		 && (((((usqInt) (longAt(name))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		return 0;
	}
	length = stSizeOf(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i < length; i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}


/*	Does thisCntx have aContext in its sender chain?
	Cheapo implementation above extant machinery. */

	/* StackInterpreter>>#context:hasSender: */
static sqInt NoDbgRegParms
contexthasSender(sqInt thisCntx, sqInt aContext)
{
    sqInt handlerOrNilOrZero;

	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCntx, aContext);
	return handlerOrNilOrZero == 0;
}


/*	For asserts. Check that theIP maps back correctly to the context's pc.
	The CallPrimitive bytecode presents a complication. */

	/* StackInterpreter>>#context:hasValidInversePCMappingOf:in: */
static sqInt NoDbgRegParms
contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP)
{
    sqInt encodedip;
    sqInt pc;

	pc = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP + 1, theFP));
	encodedip = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
	return pc == encodedip;
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfClosure: */
sqInt
copiedValueCountOfClosure(sqInt closurePointer)
{
	return (numSlotsOf(closurePointer)) - ClosureFirstCopiedValueIndex;
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfFullClosure: */
sqInt
copiedValueCountOfFullClosure(sqInt closurePointer)
{
	return (numSlotsOf(closurePointer)) - FullClosureFirstCopiedValueIndex;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

	/* StackInterpreter>>#copyBits */
sqInt
copyBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#copyBitsFrom:to:at: */
sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}

	/* StackInterpreter>>#couldBeProcess: */
static sqInt NoDbgRegParms NeverInline
couldBeProcess(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((oop & 3) == 0)
	 && (((((usqInt)oop)) >= (startOfMemory()))
	 && (((((usqInt)oop)) < GIV(freeStart))
	 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))
	 && ((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
	 && ((!(((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)))
	 && (((lengthOf(oop)) > MyListIndex)
	 && (isContext(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord()))))))))));
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#cr */
static void
cr(void)
{
	printf("\n");
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

	/* StackInterpreter>>#createActualMessageTo: */
static void NoDbgRegParms
createActualMessageTo(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt i;
    sqInt message;
    char *sp;


	/* This is a useful break-point */
	assert((isImmediate(GIV(messageSelector)))
	 || (addressCouldBeObj(GIV(messageSelector))));
	/* begin mnuBreakpoint:receiver: */
	mnuBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), null);
	argumentArray = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), GIV(argumentCount));
	message = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassMessage) << (shiftForWord()))))), MessageLookupClassIndex + 1);

	for (i = ((GIV(argumentCount) - 1) * BytesPerOop); i >= 0; i += (-BytesPerOop)) {
		longAtput((argumentArray + BaseHeaderSize) + i, popStack());
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((message + BaseHeaderSize) + (((int)((usqInt)(MessageSelectorIndex) << (shiftForWord())))), GIV(messageSelector));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((message + BaseHeaderSize) + (((int)((usqInt)(MessageArgumentsIndex) << (shiftForWord())))), argumentArray);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((message + BaseHeaderSize) + (((int)((usqInt)(MessageLookupClassIndex) << (shiftForWord())))), lookupClass);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}


/*	Return the default number of stack pages allocate at startup.
	This V3 default suits Qwaq Forums (specifically general rendering).
	The Spur default reflects tuning for GC performance ast Cadence.
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

	/* StackInterpreter>>#defaultNumStackPages */
static sqInt
defaultNumStackPages(void)
{
	return 160;
}


/*	Release the VM to other threads and answer the current thread's index.
	
	This is the entry-point for plugins and primitives that wish to release
	the VM while
	performing some operation that may potentially block, and for callbacks
	returning back to some blocking operation. While this exists for the
	threaded FFI VM we use
	it to reset newMethod and the argumentCount after a callback. */

	/* StackInterpreter>>#disownVM: */
sqInt
disownVM(sqInt flags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	assert(((flags & 1))
	 && (((((flags >> 1)) >= 0) && (((flags >> 1)) <= (argumentCountOfMethodHeader(-1))))));
	assert(GIV(primFailCode) == 0);
	GIV(argumentCount) = (flags >> 1);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;
	assert((isOopCompiledMethod(GIV(newMethod)))
	 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
	return 0;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#displayBitsOf:Left:Top:Right:Bottom: */
static sqInt NoDbgRegParms
displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt d;
    sqInt dispBits;
    sqInt dispBitsIndex;
    sqInt displayObj;
    sqInt h;
    sqInt left;
    sqInt right;
    sqInt successBoolean;
    sqInt surfaceHandle;
    sqInt top;
    sqInt w;

	d = 0;
	dispBits = 0;
	h = 0;
	w = 0;
	/* begin splObj: */
	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord())))));
	if (!(aForm == displayObj)) {
		return null;
	}
	/* begin success: */
	successBoolean = (((displayObj & 1) == 0)
	 && (((((usqInt) (longAt(displayObj))) >> (instFormatFieldLSB())) & 15) <= 4))
	 && ((lengthOf(displayObj)) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		dispBits = longAt((displayObj + BaseHeaderSize) + (0U << (shiftForWord())));
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		d = fetchIntegerofObject(3, displayObj);
	}
	if (l < 0) {
		left = 0;
	}
	else {
		left = l;
	}
	if (r > w) {
		right = w;
	}
	else {
		right = r;
	}
	if (t < 0) {
		top = 0;
	}
	else {
		top = t;
	}
	if (b > h) {
		bottom = h;
	}
	else {
		bottom = b;
	}
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (!GIV(primFailCode)) {
		if ((dispBits & 1)) {
			surfaceHandle = (dispBits >> 1);
			if (showSurfaceFn == 0) {
				showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
				if (showSurfaceFn == 0) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return null;
				}
			}
			((int (*)(sqIntptr_t, int, int, int, int))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top);
		}
		else {
			assert(isNonImmediate(dispBits));

			/* index in memory byte array */
			dispBitsIndex = dispBits + BaseHeaderSize;
			ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom);
		}
	}
	return 0;
}

	/* StackInterpreter>>#divorceAllFrames */
static sqInt
divorceAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;

	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l2;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
l2:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			divorceFramesIn(aPage);
		}
	}
	/* begin zeroStackPage */
	assert((GIV(stackPage) == 0)
	 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
	GIV(stackPage) = 0;
	return activeContext;
}

	/* StackInterpreter>>#divorceFramesIn: */
static void NoDbgRegParms
divorceFramesIn(StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    char *theSP;
    sqInt valuePointer;

	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);

	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			theContext = longAt(theFP + FoxThisContext);
			goto l3;
		}
		theContext = marryFrameSP(theFP, theSP);
	l3:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(validInstructionPointerinFrame(theIP + 1, theFP));
		valuePointer = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);

		longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer);
		assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));
		if (calleeContext != null) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(calleeContext, GIV(youngStart))) {
				possibleRootStoreIntovalue(calleeContext, theContext);
			}
			longAtput((calleeContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;

		/* theSP points at stacked hottest item on frame's stack */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + (frameStackedReceiverOffset(calleeFP))) + BytesPerWord;

	}
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(theContext, GIV(youngStart))) {
		possibleRootStoreIntovalue(theContext, longAt(calleeFP + FoxCallerContext));
	}
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), longAt(calleeFP + FoxCallerContext));
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

	/* StackInterpreter>>#doPrimitiveDiv:by: */
static sqInt NoDbgRegParms
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    int posArg;
    int posRcvr;
    sqInt result;
    sqInt successBoolean;

	integerArg = 0;
	integerRcvr = 0;
	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */
			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */
			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	successBoolean = (((sqInt)((((usqInt)result)) ^ ((((usqInt)result)) << 1)))) >= 0;
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return result;
}

	/* StackInterpreter>>#doPrimitiveMod:by: */
static sqInt NoDbgRegParms
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt successBoolean;

	integerArg = 0;
	integerRcvr = 0;
	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */
	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	successBoolean = (((sqInt)((((usqInt)integerResult)) ^ ((((usqInt)integerResult)) << 1)))) >= 0;
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

	/* StackInterpreter>>#doSignalSemaphoreWithIndex: */
sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop;
    sqInt sema;
    sqInt xArray;

	/* begin splObj: */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	assert(isArray(xArray));

	/* Note: semaphore indices are 1-based */
	sema = longAt((xArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
	assert(!(isOopForwarded(sema)));
	return (((sema & 1) == 0)
	 && (((((ccIndex = (((usqInt) (longAt(sema))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(sema - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))
	 && (synchronousSignal(sema));
}

	/* StackInterpreter>>#dummyReferToProxy */
static void
dummyReferToProxy(void)
{
	interpreterProxy = interpreterProxy;
}


/*	Dump the entire image out to the given file. Intended for debugging only.
	Doesn't work for Spur. */

	/* StackInterpreter>>#dumpImage: */
EXPORT(sqInt)
dumpImage(sqInt fileName)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dataSize;
    sqImageFile f;
    sqInt result;

	f = sqImageFileOpen(pointerForOop(fileName), "wb");
	if (f == null) {
		return -1;
	}
	dataSize = GIV(endOfMemory) - (startOfMemory());
	result = sqImageFileWrite(pointerForOop(memory()), sizeof(unsigned char), dataSize, f);
	sqImageFileClose(f);
	return result;
}


/*	Dummy definition to allow the StackInterpreter to link against the Cog
	run-time. 
 */

	/* StackInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(void)
{
}


/*	Answerr the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

	/* StackInterpreter>>#ensureCallerContext: */
static sqInt NoDbgRegParms
ensureCallerContext(char *theFP)
{
    char *callerFP;

	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		return longAt(theFP + FoxCallerContext);
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP)));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(callerFP, (assert(!(isBaseFrame(theFP))),
	(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord));
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static void NoDbgRegParms
ensureImageFormatIsUpToDate(sqInt swapBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr2;
    sqInt chunk;
    sqInt chunk1;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt methodHeader;
    sqInt obj;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt startAddr;
    sqInt stopAddr;
    int swapFloatWords;
    sqInt sz;
    sqInt sz1;
    int temp;
    sqInt temp1;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		startAddr = startOfMemory();
		addr = startAddr;
		while (oopisLessThan(addr, GIV(freeStart))) {
			longAtput(addr, 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES((longAt(addr)))
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES((longAt(addr)))
#      endif /* BytesPerWord == 4 */
				);
			addr += BytesPerWord;
		}
		/* begin updateObjectsPostByteSwap */
		swapFloatWords = ((VMBIGENDIAN
			? 1
			: 0)) != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		chunk1 = startOfMemory();
		oop1 = chunk1 + (headerTypeBytes[(longAt(chunk1)) & TypeMask]);
		while ((((usqInt)oop1)) < GIV(freeStart)) {
			if (!(((longAt(oop1)) & TypeMask) == HeaderTypeFree)) {
				/* begin formatOf: */
				fmt = (((usqInt) (longAt(oop1))) >> (instFormatFieldLSB())) & 15;
				if (fmt >= (firstByteFormat())) {

					/* oop contains bytes */
					wordAddr = oop1 + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat())) {

						/* compiled method; start after methodHeader and literals */
						methodHeader = longAt(oop1 + BaseHeaderSize);
						wordAddr += (((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop;
					}
					/* begin reverseBytesFrom:to: */
					stopAddr = oop1 + (sizeBitsOf(oop1));
					addr2 = wordAddr;
					while (oopisLessThan(addr2, stopAddr)) {
						longAtput(addr2, 
#            if BytesPerWord == 4
							SQ_SWAP_4_BYTES((longAt(addr2)))
#            else /* BytesPerWord == 4 */
							SQ_SWAP_8_BYTES((longAt(addr2)))
#            endif /* BytesPerWord == 4 */
							);
						addr2 += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat())) {

					/* Bitmap, Float etc */
					if (swapFloatWords
					 && (((((usqInt) (longAt(oop1))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex)) {
						temp1 = longAt(oop1 + BaseHeaderSize);
						longAtput(oop1 + BaseHeaderSize, longAt((oop1 + BaseHeaderSize) + 4));
						longAtput((oop1 + BaseHeaderSize) + 4, temp1);
					}
					else {
											}
				}

			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop1, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop1)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop1)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop1);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop1 = (oop1 + sz1) + (headerTypeBytes[(longAt(oop1 + sz1)) & TypeMask]);
		}
	}
	else {
		/* begin convertFloatsToPlatformOrder */
		if (((VMBIGENDIAN
			? 1
			: 0)) == GIV(imageFloatsBigEndian)) {
			goto l4;
		}
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		chunk = startOfMemory();
		oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
		while ((((usqInt)oop)) < GIV(freeStart)) {
			if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
				if (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex) {
					temp = long32At(oop + BaseHeaderSize);
					long32Atput(oop + BaseHeaderSize, long32At((oop + BaseHeaderSize) + 4));
					long32Atput((oop + BaseHeaderSize) + 4, temp);
				}

			}
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(oop);
				sz = ((header & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
					: header & SizeMask);
			}
			oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		}
	l4:	/* end convertFloatsToPlatformOrder */;
	}
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */

	/* StackInterpreter>>#externalDivorceFrame:andContext: */
static void NoDbgRegParms
externalDivorceFrameandContext(char *theFP, sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    int onCurrent;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    sqInt valuePointer;


	/* stackPage needs to have current head pointers to avoid confusion. */
	assert((GIV(stackPage) == 0)
	 || (GIV(stackPage) == (mostRecentlyUsedPage())));
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	theSP = findSPOfon(theFP, thePage);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		callerCtx = longAt(theFP + FoxCallerContext);
		goto l4;
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1)));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l4;
	}
	callerCtx = marryFrameSP(callerFP1, (assert(!(isBaseFrame(theFP))),
	(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord));
l4:	/* end ensureCallerContext: */;
	if (((frameAbove = findFrameAboveinPage(theFP, thePage))) == 0) {

		/* If we're divorcing the top frame we can simply peel it off. */
		theIP = longAt((thePage->headSP));
	}
	else {

		/* othewise move all frames above to a new stack and then peel the frame off. */
		/* begin newStackPage */
		lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
		if (((lruOrFree->baseFP)) == 0) {
			newPage = lruOrFree;
			goto l1;
		}
		divorceFramesIn(lruOrFree);
		newPage = lruOrFree;
	l1:	/* end newStackPage */;
		theIP = oopForPointer(pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			assert(newPage != 0);
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage);
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (newPage->headSP);
			GIV(framePointer) = (newPage->headFP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage);
		}
		assert((frameCallerContext(frameAbove)) == ctxt);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(validInstructionPointerinFrame(theIP + 1, theFP));
	valuePointer = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);

	longAtput((ctxt + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(ctxt, GIV(youngStart))) {
		possibleRootStoreIntovalue(ctxt, callerCtx);
	}
	longAtput((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), callerCtx);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* theFP is a base frame; it is now alone; free the entire page */
		freeStackPage(thePage);
	}
	else {
		callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
		callerSP = ((assert(!(isBaseFrame(theFP))),
(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord)) - BytesPerWord;
		longAtput(callerSP, callerIP);
		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

	/* StackInterpreter>>#externalEnsureIsBaseFrame: */
static char * NoDbgRegParms
externalEnsureIsBaseFrame(char *aFramePtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    int onCurrent;
    char *theFP;
    StackPage *thePage;

	if ((longAt(aFramePtr + FoxSavedFP)) == 0) {
		return aFramePtr;
	}
	theFP = aFramePtr;
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));

	/* Storing the frame's sender with its caller's context
	   has the side effect of making theFP a base frame. */
	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP));
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	return theFP;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state. */

	/* StackInterpreter>>#externalInstVar:ofContext: */
static sqInt NoDbgRegParms
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isContext(aContext));
	assert(offset <= (ReceiverIndex + (checkStackPointerForMaybeMarriedContext(aContext))));
	if (offset <= StackPointerIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		if ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContext)))) {
			return fetchPointerofMarriedContext(offset, aContext);
		}
	}
	return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
}

	/* StackInterpreter>>#externalInstVar:ofContext:put: */
static sqInt NoDbgRegParms
externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index1;
    int onCurrentPage;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	assert(isContext(maybeMarriedContext));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(!((isObjImmutable(maybeMarriedContext))));
	if (!((((longAt((maybeMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(maybeMarriedContext))))) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(maybeMarriedContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), anOop);
		if (index == StackPointerIndex) {
		}
		return null;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((maybeMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFP = pointerForOop(senderOop - 1);

	/* begin stackPageFor: */
	index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index1, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (index == SenderIndex) {
		storeSenderOfFramewithValue(theFP, anOop);
	}
	else {
		externalDivorceFrameandContext(theFP, maybeMarriedContext);
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(maybeMarriedContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), anOop);
		if (index == StackPointerIndex) {
		}
	}
	if (onCurrentPage) {
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(pageListIsWellFormed());
	assert(validStackPageBaseFrames());
	return 0;
}


/*	Invoke a quick primitive.
	Called under the assumption that primFunctionPtr has been preloaded */

	/* StackInterpreter>>#externalQuickPrimitiveResponse */
static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 0xFF)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		/* begin pop:thenPush: */
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 256) {
		return 1;
	}
	if (localPrimIndex == 257) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp3 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput((sp4 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)(localPrimIndex - 261) << 1) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}


/*	not inlined for breakpoint value... */

	/* StackInterpreter>>#failUnbalancedPrimitive */
static void
failUnbalancedPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchArray:ofObject: */
void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	/* begin arrayValueOf: */
	if (((arrayOop & 1) == 0)
	 && (isWordsOrBytesNonImm(arrayOop))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchFloat:ofObject: */
double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt floatOop;
    sqInt isFloat;
    double result;

	floatOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((floatOop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((floatOop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(floatOop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(floatOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(floatOop + BaseHeaderSize, result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchInteger:ofObject: */
sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	intOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	/* begin checkedIntegerValueOf: */
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Fetch a slot from a married context. Compute the value
	of the relevant inst var from the spouse frame's state.
	
	This method assumes frame pointers have been written back. */

	/* StackInterpreter>>#fetchPointer:ofMarriedContext: */
static sqInt NoDbgRegParms
fetchPointerofMarriedContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;
    sqInt senderOop;
    sqInt senderOop1;
    char *spouseFP;

	assert(isContext(aContext));
	assert((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer)));
	assert(checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer)));
	if (offset <= ReceiverIndex) {
		if (!(offset <= StackPointerIndex)) {
			return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
		}
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		spouseFP = pointerForOop(senderOop - 1);

		if (offset == SenderIndex) {
			/* begin ensureCallerContext: */
			callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
			if (callerFP == 0) {

				/* base frame, context in saved ip slot (or base of stack in Cog) */
				return longAt(spouseFP + FoxCallerContext);
			}
			/* begin ensureFrameIsMarried:SP: */
			if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
				assert(isContext(frameContext(callerFP)));
				return longAt(callerFP + FoxThisContext);
			}
			return marryFrameSP(callerFP, (assert(!(isBaseFrame(spouseFP))),
			(spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord));
		}
		if (offset == StackPointerIndex) {
			return (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 1) | 1);
		}
		if (offset == InstructionPointerIndex) {
			return instructionPointerForFramecurrentFPcurrentIP(spouseFP, GIV(framePointer), GIV(instructionPointer));
		}
	}
	/* begin frameOfMarriedContext: */
	senderOop1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop1 & 1));
	spouseFP = pointerForOop(senderOop1 - 1);

	return ((((offset - ReceiverIndex) >= 1) && ((offset - ReceiverIndex) <= (stackPointerIndexForFrame(spouseFP))))
		? ((offset - (ReceiverIndex + 1)) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
				? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord))
				: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord)))
		: (/* begin nilObject */
			GIV(nilObj)));
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static sqInt NoDbgRegParms
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((sp & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
	return (sp >> 1);
}

	/* StackInterpreter>>#findClassContainingMethod:startingAt: */
static sqInt NoDbgRegParms
findClassContainingMethodstartingAt(sqInt meth, sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    sqInt sz;

	currClass = classObj;

	do {
		assert(!(isForwarded(currClass)));
		if (!(addressCouldBeClassObj(currClass))) {
			/* begin nilObject */
			return GIV(nilObj);
		}
		classDict = longAt((currClass + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		assert(!(isForwarded(classDict)));
		/* begin numSlotsOf: */
		header = longAt(classDict);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(classDict - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		if (classDictSize > MethodArrayIndex) {
			methodArray = longAt((classDict + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
			assert(!(isForwarded(methodArray)));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					return currClass;
				}
				i += 1;
			}
		}
		/* begin noFixupFollowField:ofObject: */
		currClass = longAt((currClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}

	/* StackInterpreter>>#findClassOfMethod:forReceiver: */
sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop;
    sqInt rclass;

	if ((((rcvr & 1))
	 || (((rcvr & 3) == 0)
	 && (((((usqInt)rcvr)) >= (startOfMemory()))
	 && (((((usqInt)rcvr)) < GIV(freeStart))
	 && (((longAt(rcvr)) & TypeMask) != HeaderTypeGC)))))
	 && (!0)) {
		rclass = findClassContainingMethodstartingAt(meth, ((rcvr & 1)
			? (/* begin fetchPointer:ofObject: */
				longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
			: (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0
					? (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask
					: (/* begin fetchPointer:ofObject: */
						(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
						longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))));
		if (rclass != GIV(nilObj)) {
			return rclass;
		}
	}
	if (!((((meth & 3) == 0)
		 && (((((usqInt)meth)) >= (startOfMemory()))
		 && (((((usqInt)meth)) < GIV(freeStart))
		 && (((longAt(meth)) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt) (longAt(meth))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	return findClassContainingMethodstartingAt(meth, safeMethodClassOf(meth));
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

	/* StackInterpreter>>#findFrameAbove:inPage: */
static char * NoDbgRegParms
findFrameAboveinPage(char *theFP, StackPage *thePage)
{
    char *callerFP;
    char *fp;

	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

	/* StackInterpreter>>#findHomeForContext: */
static sqInt NoDbgRegParms
findHomeForContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt closureOrNil;
    sqInt oop;
    sqInt oop1;

	if (!(((aContext & 1) == 0)
		 && (((((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		return null;
	}
	closureOrNil = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	if ((((closureOrNil & 1)
		? (/* begin fetchPointer:ofObject: */
			longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
		: (((ccIndex = (((usqInt) (longAt(closureOrNil))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(closureOrNil - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord()))))))))) != (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))))) {
		if (!((((closureOrNil & 1)
				? (/* begin fetchPointer:ofObject: */
					longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
				: (((ccIndex1 = (((usqInt) (longAt(closureOrNil))) >> (compactClassFieldLSB())) & 0x1F)) == 0
						? (longAt(closureOrNil - BaseHeaderSize)) & AllButTypeMask
						: (/* begin fetchPointer:ofObject: */
							(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
							longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord()))))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFullBlockClosure) << (shiftForWord())))))))) {
			return null;
		}
	}

	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord()))))));
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */
/*	Being mutually-recursive with findMethodWithPrimitive:FromFP:UpToContext:
	gives the author's type inference algorithm headaches. Wimp out by
	declaring the return type.
 */

	/* StackInterpreter>>#findMethodWithPrimitive:FromContext:UpToContext: */
static sqInt NoDbgRegParms
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt primBits;
    sqInt primBits1;
    sqInt senderContext1;
    sqInt senderOop;
    char *startFP;
    sqInt theContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    sqInt theMethod1;
    char *theSP;

	assert((senderContext == (nilObject()))
	 || (isContext(senderContext)));
	assert((homeContext == (nilObject()))
	 || (isContext(homeContext)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((longAt((theContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((longAt((theContext + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))))) != GIV(nilObj)))) {
			theMethod = longAt((theContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
			if ((((primBits = (((assert(isCompiledMethod(theMethod)),
longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == primitive) {
				return theContext;
			}
		}
		theContext = longAt((theContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	if (isWidowedContext(theContext)) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	/* begin findMethodWithPrimitive:FromFP:UpToContext: */
	senderOop = longAt((theContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	startFP = pointerForOop(senderOop - 1);

	theFP = startFP;
	theFPAbove = startFP;
	do {
		if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((byteAt((theFP + FoxFrameFlags) + 3)) != 0))) {
			theMethod1 = longAt(theFP + FoxMethod);
			if ((((primBits1 = (((assert(isCompiledMethod(theMethod1)),
longAt((theMethod1 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
			(primBits1 & 0x1FF) + ((((usqInt) primBits1) >> 19) & 512))) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;

				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(theFP)));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP);
			}
		}
		theFPAbove = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	senderContext1 = longAt(theFPAbove + FoxCallerContext);
	if (!(((senderContext1 & 1) == 0)
		 && (((((usqInt) (longAt(senderContext1))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContext1, homeContext);
}


/*	Find the compiled method to be run when the current 
	messageSelector is sent to the given class, setting the values 
	of 'newMethod' and 'primitiveIndex'. */

	/* StackInterpreter>>#findNewMethodInClassTag: */
static sqInt NoDbgRegParms
findNewMethodInClassTag(sqInt classTagArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt ok;

	ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTagArg);
	if (!ok) {

		/* entry was not found in the cache; look it up the hard way */
		classTag = classTagArg;
		/* begin classForClassTag: */
		GIV(lkupClass) = classTag;
		lookupMethodInClass(GIV(lkupClass));

		addNewMethodToCache(GIV(lkupClass));
	}
	return 0;
}

	/* StackInterpreter>>#findSelectorOfMethod: */
sqInt
findSelectorOfMethod(sqInt meth)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    sqInt classDictSize;
    sqInt classObj;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    sqInt selector;
    sqInt sz;

	if (!(((meth & 3) == 0)
		 && (((((usqInt)meth)) >= (startOfMemory()))
		 && (((((usqInt)meth)) < GIV(freeStart))
		 && (((longAt(meth)) & TypeMask) != HeaderTypeGC))))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	if (!(((meth & 1) == 0)
		 && (((((usqInt) (longAt(meth))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	selector = maybeSelectorOfMethod(meth);
	if (!(selector == null)) {
		return selector;
	}
	classObj = safeMethodClassOf(meth);
	if (addressCouldBeClassObj(classObj)) {
		classDict = longAt((classObj + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		/* begin numSlotsOf: */
		header = longAt(classDict);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(classDict - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		if (classDictSize > MethodArrayIndex) {
			methodArray = longAt((classDict + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					return longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)((i + SelectorStart)) << (shiftForWord())))));
				}
				i += 1;
			}
		}
	}
	/* begin nilObject */
	return GIV(nilObj);
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

	/* StackInterpreter>>#findSPOf:on: */
static char * NoDbgRegParms
findSPOfon(char *theFP, StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    char *theSP;

	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage->headFP);
	assert(!(isFree(thePage)));
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l1;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + (frameStackedReceiverOffset(prevFrame))) + BytesPerWord;

			goto l1;
		}
	}
	theSP = null;
l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (theSP != null) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}


/*	Like #stackFloatValue: but access method arguments left-to-right */

	/* StackInterpreter>>#floatArg: */
double
floatArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double result;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	/* begin floatValueOf: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	methodObj is a CompiledMethod. If it contains an external primitive,
	flush the function address and session ID of the CM. Answer the prim
	index for the benefit of subclass overrides. */

	/* StackInterpreter>>#flushExternalPrimitiveOf: */
static sqInt NoDbgRegParms
flushExternalPrimitiveOf(sqInt methodObj)
{
    sqInt header;
    sqInt lit;
    sqInt primBits;
    sqInt primIdx;

	assert(isCompiledMethod(methodObj));
	header = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	primBits = (header >> 1);
	primIdx = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


	if ((primIdx == PrimNumberExternalCall)
	 && (((assert((header & 1)),
	((((int) header)) < 0
			? ((header >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt) header) >> 10) & 0xFF))) > 0)) {

		/* If not, something's broken */
		/* begin fetchPointer:ofObject: */
		lit = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		if ((((lit & 1) == 0)
		 && (((((usqInt) (longAt(lit))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((numSlotsOf(lit)) == 4)) {

			/* If not, something's broken */
			/* begin storePointerUnchecked:ofObject:withValue: */
			longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord())), ConstZero);
			/* begin storePointerUnchecked:ofObject:withValue: */
			longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord())), ConstZero);
		}
	}
	return primIdx;
}


/*	Flush the method cache. The method cache is flushed on every programming
	change and garbage collect.
 */

	/* StackInterpreter>>#flushMethodCache */
static void
flushMethodCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;

	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

	/* StackInterpreter>>#forceInterruptCheck */
sqInt
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;


	/* Do _not_ set stackLimit until the stack system has been initialized.
	   stackLimit is the initialization flag for the stack system. */
	if (GIV(stackLimit) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	if ((thePage != null)
	 && (thePage != 0)) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	/* begin allOnesAsCharStar */
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence();
	if (((iccFunc = interruptCheckChain)) != null) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
	return 0;
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

	/* StackInterpreter>>#forceInterruptCheckFromHeartbeat */
void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
		if (GIV(longRunningPrimitiveCheckSemaphore) == null) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
	l1:	/* end checkForLongRunningPrimitive */;
		forceInterruptCheck();
	}
}

	/* StackInterpreter>>#frameCallerContext: */
static sqInt NoDbgRegParms
frameCallerContext(char *theFP)
{
	return longAt(theFP + FoxCallerContext);
}

	/* StackInterpreter>>#frameContext: */
static sqInt NoDbgRegParms
frameContext(char *theFP)
{
	return longAt(theFP + FoxThisContext);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameHasContext: */
static sqInt NoDbgRegParms
frameHasContext(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 2)) != 0;
}


/*	<Integer> */

	/* StackInterpreter>>#frameIsBlockActivation: */
static sqInt NoDbgRegParms
frameIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 3)) != 0;
}

	/* StackInterpreter>>#frameMethod: */
static sqInt NoDbgRegParms
frameMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameNumArgs: */
static sqInt NoDbgRegParms
frameNumArgs(char *theFP)
{
	return byteAt((theFP + FoxFrameFlags) + 1);
}

	/* StackInterpreter>>#frameOfMarriedContext: */
static char * NoDbgRegParms
frameOfMarriedContext(sqInt aContext)
{
    sqInt senderOop;

	senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	return (assert((senderOop & 1)),
		pointerForOop(senderOop - 1));
}

	/* StackInterpreter>>#frameReceiver: */
static sqInt NoDbgRegParms
frameReceiver(char *theFP)
{
	return longAt(theFP + FoxReceiver);
}


/*	Answer the offset in bytes from the the frame pointer to its stacked
	receiver. The receiver of a message send or the closure of a block
	activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#frameStackedReceiverOffset: */
static sqInt NoDbgRegParms
frameStackedReceiverOffset(char *theFP)
{
    sqInt numArgs;

	/* begin frameStackedReceiverOffsetNumArgs: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	return (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
}


/*	Free any untraced stack pages. */

	/* StackInterpreter>>#freeUntracedStackPages */
static void
freeUntracedStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((!(isFree(thePage)))
		 && (((thePage->trace)) == StackPageUnreached)) {
			assert(noMarkedContextsOnPage(thePage));
			freeStackPage(thePage);
		}
		assert(((thePage->trace = StackPageTraceInvalid)) != 0);
	}
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

	/* StackInterpreter>>#fullDisplayUpdate */
sqInt
fullDisplayUpdate(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayObj;
    sqInt h;
    sqInt w;

	/* begin splObj: */
	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord())))));
	if ((((displayObj & 1) == 0)
	 && (((((usqInt) (longAt(displayObj))) >> (instFormatFieldLSB())) & 15) <= 4))
	 && ((lengthOf(displayObj)) >= 4)) {
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, h);
		ioForceDisplayUpdate();
	}
	return null;
}


/*	Find an actual function pointer for this primitiveIndex. This is an
	opportunity to specialise the prim for the relevant class (format for
	example). Default for now is simply the entry in the base primitiveTable. */

	/* StackInterpreter>>#functionPointerFor:inClass: */
void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void)

{
	return (primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx]);
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. 
 */

	/* StackInterpreter>>#getCurrentBytecode */
sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return byteAt(GIV(instructionPointer));
}


/*	This is nil in the StackVM */

	/* StackInterpreter>>#getDesiredCogCodeSize */
static sqInt
getDesiredCogCodeSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin nilObject */
	return GIV(nilObj);
}

	/* StackInterpreter>>#getFullScreenFlag */
sqInt
getFullScreenFlag(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(fullScreenFlag);
}

	/* StackInterpreter>>#getInterruptKeycode */
sqInt
getInterruptKeycode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptKeycode);
}

	/* StackInterpreter>>#getInterruptPending */
sqInt
getInterruptPending(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptPending);
}

	/* StackInterpreter>>#getNextWakeupUsecs */
usqLong
getNextWakeupUsecs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nextWakeupUsecs);
}

	/* StackInterpreter>>#getSavedWindowSize */
sqInt
getSavedWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedWindowSize);
}


/*	For Alien FFI */

	/* StackInterpreter>>#getStackPointer */
sqInt *
getStackPointer(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((sqInt *) GIV(stackPointer));
}


/*	return the global session ID value */

	/* StackInterpreter>>#getThisSessionID */
sqInt
getThisSessionID(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(globalSessionID);
}


/*	Answer the next 32 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getWord32FromFile:swap: */
static sqInt NoDbgRegParms
getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    int w;

	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, aFile);
	return (swapFlag
		? SQ_SWAP_4_BYTES(w)
		: w);
}


/*	Check for stack overflow, moving frames to another stack if so.
	This should *only* be sent from checkForStackOverflow. */

	/* StackInterpreter>>#handleStackOverflow */
static void NeverInline
handleStackOverflow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *callerFP1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    char *theFP;

	assert(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)));

	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	   e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	   back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	   more than one frame.  The idea is to record which page has overflowed, and the first
	   time it overflows move one frame, the second time two frames, and so on.  We move no
	   more frames than would leave the page half occupied. */
	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = (GIV(extraFramesToMoveOnOverflow) += 1);
		while ((((overflowCount -= 1)) >= 0)
		 && ((((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) < overflowLimitAddress)
		 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		longAt(theFP + FoxCallerContext);
		goto l2;
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1)));
		longAt(callerFP1 + FoxThisContext);
		goto l2;
	}
	marryFrameSP(callerFP1, (assert(!(isBaseFrame(theFP))),
	(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord));
l2:	/* end ensureCallerContext: */;
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l1:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	
	/* To overflow the stack this must be a new frame, but in Cog base frames are married. */
	assert(!(frameHasContext(GIV(framePointer))));
	assert(validInstructionPointerinMethodframePointer(GIV(instructionPointer) + 1, GIV(method), GIV(framePointer)));

}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for stackOverflow and interrupts anddeal with each
	appropriately. Answer if a context switch occurred. */

	/* StackInterpreter>>#handleStackOverflowOrEventAllowContextSwitch: */
static sqInt NoDbgRegParms
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		return 0;
	}
	return checkForEventsMayContextSwitch(mayContextSwitch);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
usqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */
	shifted = anUnsignedValue;
	bitNo = 0;
	
#  if BytesPerWord > 4
	if (!(shifted < (1ULL << 32))) {
		shifted = ((usqInt) shifted) >> 32;
		bitNo += 32;
	}

#  endif /* BytesPerWord > 4 */

	if (!(shifted < (1U << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1U << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1U << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1U << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1U << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	If thePage is the stackPage and the stackPointer and/or the framePointer
	are pointing within it,
	answer if thePage's heapSP and headFP are equal to the stackPointer and
	framePointer respectively.
 */

	/* StackInterpreter>>#ifCurrentStackPageHasValidHeadPointers: */
static sqInt NoDbgRegParms
ifCurrentStackPageHasValidHeadPointers(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (thePage == GIV(stackPage)) {
		if ((((thePage->lastAddress)) < GIV(framePointer))
		 && (GIV(framePointer) < ((thePage->baseAddress)))) {
			if (((thePage->headFP)) != GIV(framePointer)) {
				return 0;
			}
		}
		if ((((thePage->lastAddress)) < GIV(stackPointer))
		 && (GIV(stackPointer) < ((thePage->baseAddress)))) {
			if (((thePage->headSP)) != GIV(stackPointer)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* StackInterpreter>>#iframeMethod: */
static usqInt NoDbgRegParms
iframeMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null.
	This is a noop in the stack VM since the C stack pointers are always
	elsewhere (e.g., in some C function running the interpreter). */

	/* StackInterpreter>>#ifValidWriteBackStack:Pointers:Save:To: */
void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		/* begin followField:ofObject: */
		theClass = longAt((theClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return 0;
}


/*	Answer the bytecode pc object (i.e. SmallInteger) for an active frame. The
	bytecode pc is derived from the frame's pc. If the frame is the top frame
	on the current stack
	the frame pc is whatever the current instruction pointer is. If the frame
	is the top
	frame on some other stack the frame pc is the value on top of stack.
	Otherwise the
	frame pc is the saved pc of the frame above. Once the frame pc is found it
	must be
	mapped to a bytecode pc. */

	/* StackInterpreter>>#instructionPointerForFrame:currentFP:currentIP: */
static sqInt NoDbgRegParms
instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *fp;
    sqInt index;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;

	if (spouseFP == currentFP) {
		theIP = oopForPointer(instrPtr);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(spouseFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		/* begin findFrameAbove:inPage: */
		fp = (thePage->headFP);
		if (fp == spouseFP) {
			theFPAbove = 0;
			goto l1;
		}
		while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
			if (callerFP == spouseFP) {
				theFPAbove = fp;
				goto l1;
			}
			fp = callerFP;
		}
		error("did not find theFP in stack page");
		theFPAbove = 0;
	l1:	/* end findFrameAbove:inPage: */;
		theIP = (theFPAbove == 0
			? longAt((thePage->headSP))
			: oopForPointer(pointerForOop(longAt(theFPAbove + FoxCallerSavedIP))));
	}
	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP + 1, spouseFP));
	return (((usqInt)(((theIP - (longAt(spouseFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
}


/*	Like #stackIntegerValue: but access method arguments left-to-right */

	/* StackInterpreter>>#integerArg: */
sqInt
integerArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0;
	}
	/* begin checkedIntegerValueOf: */
	if ((oop & 1)) {
		return (oop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

	/* StackInterpreter>>#interpreterAllocationReserveBytes */
static sqInt NeverInline
interpreterAllocationReserveBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;

	maxUsedBytesPerPage = (stackPageFrameBytes()) + ((FrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / FrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

	/* StackInterpreter>>#ioFilename:fromString:ofLength:resolveAliases: */
void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

	/* StackInterpreter>>#isBaseFrame: */
static sqInt NoDbgRegParms
isBaseFrame(char *theFP)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}

	/* StackInterpreter>>#isFloatObject: */
sqInt
isFloatObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassFloatCompactIndex == ccIndex;

	return classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
}

	/* StackInterpreter>>#isFrame:onPage: */
static sqInt NoDbgRegParms
isFrameonPage(char *aFrame, StackPage *aPage)
{
    char *prevFP;
    char *theFP;

	assert(!((isFree(aPage))));
	theFP = (aPage->headFP);
	prevFP = theFP - BytesPerWord;
	while (1) {
		if (theFP == aFrame) {
			return 1;
		}
		if (!((theFP > prevFP)
		 && (theFP < ((aPage->baseFP))))) break;
		prevFP = theFP;
		/* begin frameCallerFP: */
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	}
	return 0;
}


/*	Answer true if the oop is kind of Integer (Small or Large). */

	/* StackInterpreter>>#isKindOfInteger: */
sqInt
isKindOfInteger(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & 1))
	 || ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord()))))), ClassLargePositiveIntegerCompactIndex))
	 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord()))))), ClassLargeNegativeIntegerCompactIndex)));
}

	/* StackInterpreter>>#isLargeIntegerObject: */
sqInt
isLargeIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord()))))), ClassLargePositiveIntegerCompactIndex))
	 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord()))))), ClassLargeNegativeIntegerCompactIndex));
}

	/* StackInterpreter>>#isLargeNegativeIntegerObject: */
sqInt
isLargeNegativeIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassLargeNegativeIntegerCompactIndex == ccIndex;

	return classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
}

	/* StackInterpreter>>#isLargePositiveIntegerObject: */
sqInt
isLargePositiveIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;

	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassLargePositiveIntegerCompactIndex == ccIndex;

	return classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
}


/*	Answer if the argument, which can be any object, is a live context. */

	/* StackInterpreter>>#isLiveContext: */
static sqInt NoDbgRegParms
isLiveContext(sqInt oop)
{
	assert(!((isOopForwarded(oop))));
	if (!(((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (isNonImmediate(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord()))))))) {
		return ((longAt((oop + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1);
	}
	return !(isWidowedContext(oop));
}

	/* StackInterpreter>>#isMarriedOrWidowedContext: */
static sqInt NoDbgRegParms
isMarriedOrWidowedContext(sqInt aContext)
{
	return ((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

	/* StackInterpreter>>#isPrimitiveFunctionPointerAnIndex */
static sqInt
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
sqInt
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 256) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
sqInt
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}

	/* StackInterpreter>>#isSingleContext: */
static sqInt NoDbgRegParms
isSingleContext(sqInt aContext)
{
    sqInt anOop;

	/* begin isNonImmediate: */
	anOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	return (anOop & 1) == 0;
}


/*	Answer if aContext is married or widowed and still married.
	If a context is widowed then turn it into a single dead context. */

	/* StackInterpreter>>#isStillMarriedContext: */
static sqInt NoDbgRegParms
isStillMarriedContext(sqInt aContext)
{
	return (((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContext)));
}


/*	See if the argument is married to a live frame or not. i.e. see if there
	is a matching
	frame whose frameContext field is aOnceMarriedContext, or a forwarder to
	it. If aOnceMarriedContext is not married to a live frame, turn it into a
	bereaved single context.
	This version is for use during scavenging when stack references may be
	forwarded. Following what appear to be references to forwarded objects on
	the stack is dangerous;
	an instruction ponter may be correctly aligned and may point to bytes that
	just happen
	to look like a forwarder. So it is only safe to follow fields that we know
	are frameContext
	fields; hence the stack page is walked to check that aOnceMarriedContext
	is pointing to
	a live frame. This only has to happen during scavenging because after a
	become: all
	frameContext fields have been followed and so there is no need to follow
	forwarders.  */

	/* StackInterpreter>>#isWidowedContextDuringGC: */
static sqInt NoDbgRegParms
isWidowedContextDuringGC(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt index;
    char *maybeFrame;
    sqInt maybeFrameCtxt;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    StackPage *thePage;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	maybeFrame = pointerForOop(senderOop - 1);

	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(maybeFrame, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((isFree(thePage))
		 || (maybeFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		/* begin withoutSmallIntegerTags: */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		assert((anInteger & 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1);
		if (((pointerForOop(longAt(maybeFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((maybeFrame + FoxFrameFlags) + 2)) != 0)) {
			/* begin frameContext: */
			maybeFrameCtxt = longAt(maybeFrame + FoxThisContext);
			if (maybeFrameCtxt == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = GIV(nilObj);
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	return 1;
}


/*	See if the argument is married to a live frame or not.
	If it is not, turn it into a bereaved single context. This version is safe
	for use
	only when no frameContext fields may be forwarded (as maybe the case
	when scavenging). Post become: all frameContext fields are followed, and
	hence nrmally no following of frameCOtext fields is necessary. But during
	a scavenge one must use isWidowedContextDuringGC:. */

	/* StackInterpreter>>#isWidowedContext: */
static sqInt NoDbgRegParms
isWidowedContext(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt index;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFrame = pointerForOop(senderOop - 1);

	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		/* begin withoutSmallIntegerTags: */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		assert((anInteger & 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1);
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((theFrame + FoxFrameFlags) + 2)) != 0)) {
			assert(!(((isFrameonPage(theFrame, thePage))
 && (isForwarded(frameContext(theFrame))))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = GIV(nilObj);
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	return 1;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
sqInt
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;
    sqInt oopClass;

	if ((oop & 1)) {
		/* begin fetchPointer:ofObject: */
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			oopClass = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		/* begin followField:ofObject: */
		oopClass = longAt((oopClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return 0;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOf: */
sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;
    sqInt oopClass;

	if ((oop & 1)) {
		/* begin fetchPointer:ofObject: */
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			oopClass = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		/* begin followField:ofObject: */
		oopClass = longAt((oopClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return 0;
}


/*	Support for external primitives */

	/* StackInterpreter>>#is:MemberOf: */
sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;
    sqInt oopClass;

	if ((oop & 1)) {
		/* begin fetchPointer:ofObject: */
		oopClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			oopClass = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			oopClass = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	return classNameOfIs(oopClass, className);
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static sqInt NoDbgRegParms
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt numSlots;
    sqInt oop;
    sqInt sz;
    sqInt sz1;

	/* begin numSlotsOf: */
	header = longAt(classOop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(classOop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin lengthOf: */
	oop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))));
	/* begin baseHeader: */
	header1 = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header1 & SizeMask;
	}
	sz1 -= header1 & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt & 3));
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#loadBitBltFrom: */
sqInt
loadBitBltFrom(sqInt bb)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

	/* StackInterpreter>>#loadInitialContext */
void
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt oop;

	runLeakCheckerFor(GCModeFull);
	/* begin fetchPointer:ofObject: */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	activeContext = longAt((activeProc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt ccIndex;
    sqInt class;
    sqInt column;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt n1;
    sqInt oop1;
    sqInt startIP;
    sqInt sz;
    sqInt sz1;

	if (((oop & 1))
	 || ((!(((oop & 3) == 0)
	 && (((((usqInt)oop)) >= (startOfMemory()))
	 && (((((usqInt)oop)) < GIV(freeStart))
	 && (((longAt(oop)) & TypeMask) != HeaderTypeGC)))))
	 || (((oop & (BytesPerWord - 1)) != 0)
	 || ((((longAt(oop)) & TypeMask) == HeaderTypeFree)
	 || (isForwarded(oop)))))) {
		printOop(oop);
		return;
	}
	printHex(oop);
	if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	if (class == null) {
		print(" has a nil class!!");
	}
	else {
		print(": a(n) ");
		printNameOfClasscount(class, 5);
		print(" (");
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) class));
		print(")");
	}
	/* begin formatOf: */
	fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
	print(" format ");
	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) fmt));
	if (fmt > 4) {
		print(" nbytes ");
		printNum(numBytesOf(oop));
	}
	else {
		if ((fmt >= 2)
		 && ((fmt <= (weakArrayFormat()))
		 || (fmt >= (firstLongFormat())))) {
			/* begin lengthOf: */
			header = longAt(oop);
			/* begin lengthOf:baseHeader:format: */
			fmt1 = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
			if ((header & TypeMask) == HeaderTypeSizeAndClass) {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			else {
				sz = header & SizeMask;
			}
			sz -= header & Size4Bit;
			if (fmt1 <= 4) {
				len = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
				goto l6;
			}
			len = (fmt1 < (firstByteFormat())
				? ((usqInt) (sz - BaseHeaderSize)) >> 2
				: (sz - BaseHeaderSize) - (fmt1 & 3));
		l6:	/* end lengthOf: */;
			print(" size ");
			printNum(len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}
	/* begin printHeaderTypeOf: */
	
	switch ((longAt(oop)) & TypeMask) {
	case HeaderTypeFree:
		print(" HeaderTypeFree (4 bytes)");
		break;
	case HeaderTypeShort:
		print(" HeaderTypeShort (4 bytes)");
		break;
	case HeaderTypeClass:
		print(" HeaderTypeClass (8 bytes)");
		break;
	case HeaderTypeSizeAndClass:
		print(" HeaderTypeSizeAndClass (12 bytes)");
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	print(" hash ");
	/* begin printHexnp: */
	n1 = (((usqInt) (longAt(oop))) >> HashBitsOffset) & HashMaskUnshifted;
	printf("0x%lx", ((unsigned long) n1));
	/* begin cr */
	printf("\n");
	if (((fmt >= (firstByteFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {
		printStringOf(oop);
		/* begin cr */
		printf("\n");

		return;
	}
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstByteFormat()) - 1)))) {
		for (i = 0, iLimiT = (((((((usqInt) (numBytesOf(oop))) >> 2) < 256) ? (((usqInt) (numBytesOf(oop))) >> 2) : 256)) - 1); i <= iLimiT; i += 1) {
			/* begin fetchLong32:ofObject: */
			fieldOop = long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 2))));
			/* begin space */
			putchar(' ');
			printNum(i);
			/* begin space */
			putchar(' ');
			printHex(fieldOop);
			/* begin space */
			putchar(' ');
			/* begin cr */
			printf("\n");
		}
		return;
	}
	startIP = (((lastPointerOf(oop)) + BytesPerOop) - BaseHeaderSize) / BytesPerOop;
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((i - 1)) << (shiftForWord())))));
			/* begin space */
			putchar(' ');
			printNum(i - 1);
			/* begin space */
			putchar(' ');
			printHex(fieldOop);
			/* begin space */
			putchar(' ');
			if ((i == 1)
			 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
				/* begin printMethodHeaderOop: */
				printOopShort(fieldOop);
				if (fieldOop & V3PrimitiveBitsMask) {
					print(" hasPrim");
				}
				if ((fieldOop & LargeContextBit) != 0) {
					print(" largeFrame");
				}
				if ((0) < 0) {
					print(" altSet");
				}
				print(" nLits ");
				printNum((assert((fieldOop & 1)),
				((((int) fieldOop)) < 0
						? ((fieldOop >> 1)) & AlternateHeaderNumLiteralsMask
						: (((usqInt) fieldOop) >> 10) & 0xFF)));
				print(" nArgs ");
				printNum((((usqInt) fieldOop) >> MethodHeaderArgCountShift) & 15);
				print(" nTemps ");
				printNum((((usqInt) fieldOop) >> MethodHeaderTempCountShift) & 0x3F);
				/* return self */
			}
			else {
				printOopShort(fieldOop);
			}
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf: */
		header1 = longAt(oop);
		/* begin lengthOf:baseHeader:format: */
		fmt2 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
		if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz1 = header1 & SizeMask;
		}
		sz1 -= header1 & Size4Bit;
		if (fmt2 <= 4) {
			lastIndex = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
			goto l10;
		}
		lastIndex = (fmt2 < (firstByteFormat())
			? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
			: (sz1 - BaseHeaderSize) - (fmt2 & 3));
	l10:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08" PRIxSQPTR ": ", (usqIntptr_t)(oop+BaseHeaderSize+index-1));
			}
			/* begin fetchByte:ofObject: */
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", (int)byte,(int)byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > lastIndex) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return LongStoreBytecode;
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and classTag is found in the cache, set the values of
	'newMethod' and
	'primitiveFunctionPointer' and answer true. Otherwise, answer false. */

	/* StackInterpreter>>#lookupInMethodCacheSel:classTag: */
static sqInt NoDbgRegParms
lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;

	/* begin inlineLookupInMethodCacheSel:classTag: */
	hash = selector ^ classTag;

	/* first probe */
	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */
	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

	/* StackInterpreter>>#lookupMethodInClass: */
static sqInt NoDbgRegParms
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt selector;
    sqInt sz;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(class));
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {

			/* MethodDict pointer is nil (hopefully due a swapped out stub)
			   -- raise exception #cannotInterpret:. */
			createActualMessageTo(class);
			/* begin splObj: */
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorCannotInterpret) << (shiftForWord())))));
			/* begin sendBreakpoint:receiver: */
			selector = GIV(messageSelector);
			sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), null);
			return lookupMethodInClass(longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord()))))));
		}
		/* begin lookupMethodInDictionary: */
		header = longAt(dictionary);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (nextSelector == GIV(messageSelector)) {
					methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					found = 1;
					goto l7;
				}
				index += 1;
			}
			found = 0;
			goto l7;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & 1)
	? (GIV(messageSelector) >> 1)
	: (/* begin hashBitsOf: */
		(((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l7;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				found = 1;
				goto l7;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l7;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l7:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		/* begin followField:ofObject: */
		currentClass = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class);
	/* begin splObj: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))));
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), null);
	return lookupMethodInClass(class);
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

	/* StackInterpreter>>#lookupOrdinaryNoMNUEtcInClass: */
static sqInt NoDbgRegParms
lookupOrdinaryNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt sz;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {
			/* begin followField:ofObject: */
			GIV(lkupClass) = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
			return SelectorCannotInterpret;
		}
		/* begin lookupMethodInDictionary: */
		header = longAt(dictionary);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (nextSelector == GIV(messageSelector)) {
					methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					found = 1;
					goto l5;
				}
				index += 1;
			}
			found = 0;
			goto l5;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & 1)
	? (GIV(messageSelector) >> 1)
	: (/* begin hashBitsOf: */
		(((usqInt) (longAt(GIV(messageSelector)))) >> HashBitsOffset) & HashMaskUnshifted))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l5;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				found = 1;
				goto l5;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l5;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l5:	/* end lookupMethodInDictionary: */;
		if (found) {
			addNewMethodToCache(class);
			return 0;
		}

		/* begin followField:ofObject: */
		currentClass = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Lookup selector in class. Answer the method or nil. This is a debugging
	routine. It does /not/ side-effect lookupClass or newMethod. */

	/* StackInterpreter>>#lookupSelector:inClass: */
sqInt
lookupSelectorinClass(sqInt selector, sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt header;
    sqInt index;
    sqInt length;
    sqInt mask;
    sqInt meth;
    sqInt methodArray;
    sqInt nextSelector;
    sqInt sz;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {
			return null;
		}
		/* begin lookupMethodFor:InDictionary: */
		header = longAt(dictionary);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		length = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		mask = (length - SelectorStart) - 1;

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((selector & 1)
	? (selector >> 1)
	: (/* begin hashBitsOf: */
		(((usqInt) (longAt(selector))) >> HashBitsOffset) & HashMaskUnshifted))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				meth = null;
				goto l4;
			}
			if (nextSelector == selector) {
				methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				goto l4;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					meth = null;
					goto l4;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		meth = null;
	l4:	/* end lookupMethodFor:InDictionary: */;
		if (!(meth == null)) {
			return meth;
		}
		/* begin followField:ofObject: */
		currentClass = longAt((currentClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return null;
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. */

	/* StackInterpreter>>#makeBaseFrameFor: */
static StackPage * NoDbgRegParms
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt numArgs;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(isContext(aContext));
	assert(isSingleContext(aContext));
	assert(goodContextSize(aContext));
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		page = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	page = lruOrFree;
l2:	/* end newStackPage */;
	pointer = (page->baseAddress);
	theIP = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	theMethod = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!((theIP & 1))) {
		error("context is not resumable");
	}
	theIP = (theIP >> 1);

	/* If the frame is a closure activation then the closure should be on the stack in
	   the pushed receiver position (closures receive the value[:value:] messages).
	   Otherwise it should be the receiver proper. */
	rcvr = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord())))));
	maybeClosure = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))));
	if (maybeClosure != GIV(nilObj)) {
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
		assert((oop & 1));
		numArgs = (oop >> 1);
		longAtput(pointer, maybeClosure);
	}
	else {
		assert(isCompiledMethod(theMethod));
		header = longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin argumentCountOfMethodHeader: */
		numArgs = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
		if ((header & V3PrimitiveBitsMask)
		 && (theIP == (1 + ((((assert((header & 1)),
((((int) header)) < 0
		? ((header >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) header) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop)))) {
			theIP += 0;
		}
		longAtput(pointer, rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
	longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord()))))));
	longAtput((pointer -= BytesPerWord), 0);
	(page->baseFP = pointer);
	(page->headFP = pointer);
	longAtput((pointer -= BytesPerWord), theMethod);
	longAtput((pointer -= BytesPerWord), (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (1U << ((BytesPerWord * 8) - 16))) + ((maybeClosure != GIV(nilObj)
	? 1U << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (1U << 16)) + ((maybeClosure != GIV(nilObj)
	? 1U << 24
	: 0))));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput((pointer -= BytesPerWord), aContext);
	longAtput((pointer -= BytesPerWord), rcvr);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	stackPtrIndex = (oop1 >> 1);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
	/* begin iframeInstructionPointerForIndex:method: */
	assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod)))));
	theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	value = (page->baseFP);
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer(value)) + 1;
	longAtput((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(0)) + 1;

	longAtput((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	assert(((fetchPointerofObject(SenderIndex, aContext)) & 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page));
	return page;
}


/*	Convert married contexts to widowed contexts, and in the CoInterpreter,
	map any machine code pcs to bytecode pcs, and then nil all slots beyond
	top of stack, so that the context can be resumed on any VM. */

	/* StackInterpreter>>#makeContextSnapshotSafe: */
static void NoDbgRegParms
makeContextSnapshotSafe(sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	assert(isContext(ctxt));
	if (((longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		/* begin markContextAsDead: */
		assert(isContext(ctxt));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer2 = GIV(nilObj);
		longAtput((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer2);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		longAtput((ctxt + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	}
	else {
	}
	for (i = ((fetchStackPointerOf(ctxt)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(ctxt)) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
	}
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed */

	/* StackInterpreter>>#makePointwithxValue:yValue: */
sqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt pointResult;

	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)xValue << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + (((int)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)yValue << 1) | 1));
	return pointResult;
}


/*	Map all oops in the interpreter's state to their new values 
	during garbage collection or a become: operation. */
/*	Assume: All traced variables contain valid oops. */

	/* StackInterpreter>>#mapInterpreterOops */
static void
mapInterpreterOops(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt oop;

	mapStackPages();
	/* begin mapVMRegisters */
	if (shouldRemapObj(GIV(method))) {

		/* *rel to method */
		GIV(instructionPointer) -= GIV(method);
		GIV(method) = remapObj(GIV(method));
		GIV(instructionPointer) += GIV(method);
	}
	if (((GIV(newMethod) & 1) == 0)
	 && (((GIV(newMethod) & 1) == 0)
	 && (((longAt(GIV(newMethod))) & MarkBit) != 0))) {

		/* maybe oop due to object-as-method */
		GIV(newMethod) = remapObj(GIV(newMethod));
	}
	/* begin mapProfileState */
	if (shouldRemapObj(GIV(profileProcess))) {
		GIV(profileProcess) = remapObj(GIV(profileProcess));
	}
	if (shouldRemapObj(GIV(profileMethod))) {
		GIV(profileMethod) = remapObj(GIV(profileMethod));
	}
	if (shouldRemapObj(GIV(profileSemaphore))) {
		GIV(profileSemaphore) = remapObj(GIV(profileSemaphore));
	}
	sqLowLevelMFence();
	if (!(GIV(longRunningPrimitiveCheckMethod) == null)) {
		if (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)) {
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
		}
		else {
			if (shouldRemapObj(GIV(longRunningPrimitiveCheckMethod))) {
				GIV(longRunningPrimitiveCheckMethod) = remapObj(GIV(longRunningPrimitiveCheckMethod));
			}
		}
		sqLowLevelMFence();
	}
	if (!(GIV(longRunningPrimitiveCheckSemaphore) == null)) {
		if (shouldRemapObj(GIV(longRunningPrimitiveCheckSemaphore))) {
			GIV(longRunningPrimitiveCheckSemaphore) = remapObj(GIV(longRunningPrimitiveCheckSemaphore));
		}
	}
	/* begin remapCallbackState */
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		oop = GIV(suspendedCallbacks)[i];
		if (((oop & 1) == 0)
		 && (((oop & 1) == 0)
		 && (((longAt(oop)) & MarkBit) != 0))) {
			GIV(suspendedCallbacks)[i] = (remapObj(oop));
		}
		oop = GIV(suspendedMethods)[i];
		if (shouldRemapObj(oop)) {
			GIV(suspendedMethods)[i] = (remapObj(oop));
		}
	}
	if ((GIV(tempOop) != 0)
	 && (((GIV(tempOop) & 1) == 0)
	 && (((GIV(tempOop) & 1) == 0)
	 && (((longAt(GIV(tempOop))) & MarkBit) != 0)))) {
		GIV(tempOop) = remapObj(GIV(tempOop));
	}
	if ((GIV(tempOop2) != 0)
	 && (((GIV(tempOop2) & 1) == 0)
	 && (((GIV(tempOop2) & 1) == 0)
	 && (((longAt(GIV(tempOop2))) & MarkBit) != 0)))) {
		GIV(tempOop2) = remapObj(GIV(tempOop2));
	}
	if ((GIV(tempOop3) != 0)
	 && (((GIV(tempOop3) & 1) == 0)
	 && (((GIV(tempOop3) & 1) == 0)
	 && (((longAt(GIV(tempOop3))) & MarkBit) != 0)))) {
		GIV(tempOop3) = remapObj(GIV(tempOop3));
	}
}

	/* StackInterpreter>>#mapStackPages */
static void NeverInline
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt numLivePages;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	theIP = 0;
	numLivePages = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			numLivePages += 1;
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = 0;
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & 1) == 0)
					 && (((oop & 1) == 0)
					 && (((longAt(oop)) & MarkBit) != 0))) {
						longAtput(theSP, remapObj(oop));
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if (shouldRemapObj(longAt(theFP + FoxThisContext))) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext)));
					}
									}
				if (shouldRemapObj(longAt(theFP + FoxMethod))) {
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP)));
						theIP = (longAt(theIPPtr)) - (longAt(theFP + FoxMethod));
					}
					longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod)));
					if (theIPPtr != 0) {
						longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerSavedIP */
			theSP = theFP + FoxCallerContext;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 1) == 0)
				 && (((oop & 1) == 0)
				 && (((longAt(oop)) & MarkBit) != 0))) {
					longAtput(theSP, remapObj(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
	/* begin recordLivePagesOnMapping: */
	GIV(statNumMaps) += 1;
	GIV(statPageCountWhenMappingSum) += numLivePages;
	GIV(statMaxPageCountWhenMapping) = ((GIV(statMaxPageCountWhenMapping) < numLivePages) ? numLivePages : GIV(statMaxPageCountWhenMapping));
}


/*	Read markAndTraceStackPages:'s comment. Finish tracing to-be-traced pages.
	Then free any untraced pages. */

	/* StackInterpreter>>#markAndTraceAndMaybeFreeStackPages: */
static sqInt NoDbgRegParms
markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			assert(((thePage->trace = -1)) != 0);
		}
		return null;
	}
	markAndTraceUntracedReachableStackPages();
	freeUntracedStackPages();
	return 0;
}


/*	Mark and trace all oops in the interpreter's state. */
/*	Assume: All traced variables contain valid oops.
	N.B. Don't trace messageSelector and lkupClass; these are ephemeral, live
	only during message lookup and because createActualMessageTo will not
	cause a GC these cannot change during message lookup. */
/*	Must mark stack pages first to initialize the per-page trace
	flags for full garbage collect before any subsequent tracing. */

	/* StackInterpreter>>#markAndTraceInterpreterOops: */
static void NoDbgRegParms
markAndTraceInterpreterOops(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    usqInt oop;

	markAndTraceStackPages(fullGCFlag);
	markAndTrace(GIV(specialObjectsOop));
	if (!((GIV(newMethod) & 1))) {
		markAndTrace(GIV(newMethod));
	}
	/* begin traceProfileState */
	markAndTrace(GIV(profileProcess));
	markAndTrace(GIV(profileMethod));
	markAndTrace(GIV(profileSemaphore));
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		markAndTrace(GIV(longRunningPrimitiveCheckMethod));
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		markAndTrace(GIV(longRunningPrimitiveCheckSemaphore));
	}
	if (!(GIV(tempOop) == 0)) {
		markAndTrace(GIV(tempOop));
	}
	if (!(GIV(tempOop2) == 0)) {
		markAndTrace(GIV(tempOop2));
	}
	if (!(GIV(tempOop3) == 0)) {
		markAndTrace(GIV(tempOop3));
	}
	for (i = 1, iLimiT = (remapBufferCount()); i <= iLimiT; i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		oop = GIV(suspendedCallbacks)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		oop = GIV(suspendedMethods)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

	/* StackInterpreter>>#markAndTraceStackPages: */
static sqInt NoDbgRegParms
markAndTraceStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt i1;
    sqInt index;
    void *pointer;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;

	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i1 = 0; i1 < GIV(numStackPages); i1 += 1) {
		/* begin stackPageAt: */
		thePage1 = stackPageAtpages(i1, GIV(pages));
		(thePage1->trace = StackPageUnreached);
	}

	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(thePage))) {
				markAndTraceStackPage(thePage);
			}
		}
		return null;
	}
	if (GIV(stackPage) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	do {
		markAndTraceStackPage(thePage);
		/* begin frameCallerContext: */
		theFP = (thePage->baseFP);
		context = longAt(theFP + FoxCallerContext);
		if ((((context & 1) == 0)
		 && (((((usqInt) (longAt(context))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && ((((longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && ((((longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(context)))))) {
			/* begin stackPageFor: */
			senderOop = longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			pointer = pointerForOop(senderOop - 1);

			/* begin stackPageAt: */
			index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			assert(!(isFree(thePage)));
		}
	} while(((thePage->trace)) < StackPageTraced);
	return 0;
}

	/* StackInterpreter>>#markAndTraceStackPage: */
static void NoDbgRegParms
markAndTraceStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt oop;
    char *theFP;
    char *theSP;

	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		/* begin frameReceiverLocation: */
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				markAndTrace(oop);
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			markAndTrace(longAt(theFP + FoxThisContext));
		}
		markAndTrace(longAt(theFP + FoxMethod));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		theSP += BytesPerWord;
	}
}


/*	Trace any untraced pages */

	/* StackInterpreter>>#markAndTraceUntracedReachableStackPages */
static void
markAndTraceUntracedReachableStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	do {
		foundToBeTracedPage = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if ((!(isFree(thePage)))
			 && (((thePage->trace)) == StackPageReachedButUntraced)) {
				foundToBeTracedPage = 1;
				markAndTraceStackPage(thePage);
			}
		}
	} while(foundToBeTracedPage);
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the state .
 */

	/* StackInterpreter>>#marriedContext:pointsTo:stackDeltaForCurrentFrame: */
static sqInt NoDbgRegParms
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *rcvrOffset;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	/* begin frameOfMarriedContext: */
	senderOop = longAt((spouseContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFP = pointerForOop(senderOop - 1);

	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		theSP = findSPOfon(theFP, thePage);
	}
	if ((anOop & 1)) {

		/* Check stack and instruction pointer fields. */
		if ((anOop == ((((usqInt)((((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1))) << 1) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext)))) {
			return 1;
		}
	}
	else {

		/* Check method and sender fields, avoiding unnecessarily reifying sender context. */
		if (anOop == (longAt(theFP + FoxMethod))) {
			return 1;
		}
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			if (anOop == (longAt(theFP + FoxCallerContext))) {
				return 1;
			}
		}
		else {
			if (((byteAt(((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxFrameFlags) + 2)) != 0)
			 && (anOop == (longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxThisContext)))) {
				return 1;
			}
		}
	}
	/* begin frameReceiverLocation: */
	rcvrOffset = theFP + FoxReceiver;
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + (frameStackedReceiverOffset(theFP));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Establish aContext at the base of a new stackPage, make the stackPage the
	active one and set-up the interreter registers. This is used to boot the
	system and bring it back after a snapshot. */

	/* StackInterpreter>>#marryContextInNewStackPageAndInitializeInterpreterRegisters: */
static void NoDbgRegParms
marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    StackPage *newPage;
    sqInt top;

	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(aContext);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	/* begin setMethod: */
	aMethodObj = longAt(((GIV(stackPage)->headFP)) + FoxMethod);
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
}


/*	Marry an unmarried frame. This means creating a spouse context
	initialized with a subset of the frame's state (state through the last
	argument) that references the frame. */

	/* StackInterpreter>>#marryFrame:SP: */
static sqInt NoDbgRegParms
marryFrameSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    sqInt i;
    sqInt methodHeader;
    sqInt methodObj;
    sqInt numArgs;
    sqInt numSlots;
    sqInt numStack;
    sqInt theContext;
    char *value;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;
    sqInt valuePointer4;
    sqInt valuePointer5;

	/* begin marryFrame:SP:copyTemps: */
	assert(!(frameHasContext(theFP)));
	assert(addressCouldBeOop(longAt(theSP)));
	/* begin methodHeaderOf: */
	methodObj = longAt(theFP + FoxMethod);
	assert(isCompiledMethod(methodObj));
	methodHeader = longAt((methodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));
	/* begin frameNumArgs: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	numStack = (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
	if ((byteAt((theFP + FoxFrameFlags) + 3)) != 0) {
		closureOrNil = longAt(theFP + (frameStackedReceiverOffset(theFP)));
	}
	else {
		/* begin nilObject */
		closureOrNil = GIV(nilObj);
	}
	numSlots = ((methodHeader & LargeContextBit) != 0
		? LargeContextSlots
		: SmallContextSlots);
	theContext = eeInstantiateMethodContextSlots(numSlots);
	assert((numStack + ReceiverIndex) <= numSlots);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0);
	valuePointer2 = (oopForPointer(theFP)) + 1;

	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	value = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer3 = (oopForPointer(value)) + 1;
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer3);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)numStack << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer4 = longAt(theFP + FoxMethod);
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))), valuePointer4);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord())))), closureOrNil);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer5 = longAt(theFP + FoxReceiver);
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord())))), valuePointer5);
	for (i = 1; i <= numArgs; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), longAt((theFP + FoxCallerSavedIP) + (((numArgs - i) + 1) * BytesPerWord)));
	}
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), valuePointer1);
	}
	/* begin setFrameContext:to: */
	longAtput(theFP + FoxThisContext, theContext);
	/* begin setFrameHasContext: */
	byteAtput((theFP + FoxFrameFlags) + 2, 1);
	assert(frameHasContext(theFP));
	assert((frameOfMarriedContext(theContext)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext)));
	return theContext;
}


/*	Assert-only check for leaks after external prim calls if checkForLeaks
	includes the GCCheckPrimCall flag.
	This is ionly really useful from a low-level C debugger, hence no
	accessors for checkedPluginName.
 */

	/* StackInterpreter>>#maybeLeakCheckExternalPrimCall: */
static sqInt NoDbgRegParms
maybeLeakCheckExternalPrimCall(sqInt aMethodObj)
{
    sqInt primBits;

	if ((checkForLeaks & GCCheckPrimCall)
	 && (((((primBits = (((assert(isCompiledMethod(aMethodObj)),
longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == PrimNumberExternalCall)
	 && (checkedPluginName == (fetchPointerofObject(0, longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)((0 + LiteralStart)) << (shiftForWord())))))))))) {
		runLeakCheckerFor(GCCheckPrimCall);
	}
	return 1;
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence.
	With full blocks as of 9/2016 the last literal of a CompiledBlock is a
	back pointer
	to the enclosing block or compiled method. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
static sqInt NoDbgRegParms
maybeSelectorOfMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt maybeSelector;
    sqInt offset;
    sqInt offset1;
    sqInt penultimateLiteral;
    sqInt ultimateLiteral;

	assert(isOopCompiledMethod(methodObj));
	assert(isOopCompiledMethod(methodObj));
	/* begin literal:ofMethod: */
	offset = (literalCountOf(methodObj)) - 1;
	ultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));

	if (((ultimateLiteral & 1) == 0)
	 && (((((usqInt) (longAt(ultimateLiteral))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
		return maybeSelectorOfMethod(ultimateLiteral);
	}
	assert(isOopCompiledMethod(methodObj));
	/* begin literal:ofMethod: */
	offset1 = (literalCountOf(methodObj)) - 2;
	penultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset1 + LiteralStart)) << (shiftForWord())))));

	if (((penultimateLiteral & 1) == 0)
	 && (isWordsOrBytesNonImm(penultimateLiteral))) {
		return (((((ccIndex = (((usqInt) (longAt(penultimateLiteral))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(penultimateLiteral - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))))
			? penultimateLiteral
			: 0);
	}
	return ((((penultimateLiteral & 1) == 0)
	 && (((((usqInt) (longAt(penultimateLiteral))) >> (instFormatFieldLSB())) & 15) <= 4))
	 && (((numSlotsOf(penultimateLiteral)) >= 2)
	 && (((longAt((penultimateLiteral + BaseHeaderSize) + (0U << (shiftForWord())))) == methodObj)
	 && (((maybeSelector = longAt((penultimateLiteral + BaseHeaderSize) + (1U << (shiftForWord())))),
	(((maybeSelector & 1) == 0)
		 && (isWordsOrBytesNonImm(maybeSelector)))
		 && (((((ccIndex1 = (((usqInt) (longAt(maybeSelector))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(maybeSelector - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))))))) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))))))))))
		? maybeSelector
		: 0);
}

	/* StackInterpreter>>#methodArgumentCount */
sqInt
methodArgumentCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(argumentCount);
}


/*	Like #stackValue: but access method arguments left-to-right */

	/* StackInterpreter>>#methodArg: */
sqInt
methodArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((index > GIV(argumentCount)) + 1) {
		fprintf(stderr,"[VM]: Attempt to access method args beyond range\n");
		printCallStack();
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return longAt(GIV(stackPointer) + ((GIV(argumentCount) - index) * BytesPerWord));
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer)
{
    sqInt offset;

	/* begin literal:ofMethod: */
	offset = ((assert((((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(methodPointer)),
			/* begin fetchPointer:ofObject: */
			longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	Answer the method class of a method which is the value of an Association
	in the last literal,
	or answer nil if there isn't one.
	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line. */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt offset;

	/* begin followLiteral:ofMethod: */
	offset = ((assert((((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(methodPointer)),
			/* begin fetchPointer:ofObject: */
			longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
	literal = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	return ((literal != GIV(nilObj))
	 && (((literal & 1) == 0)
	 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))
		? (assert((numSlotsOf(literal)) > ValueIndex),
			longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord()))))))
		: (/* begin nilObject */
			GIV(nilObj)));
}

	/* StackInterpreter>>#methodPrimitiveIndex */
sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodHeader;
    sqInt primBits;

	if (!((((GIV(newMethod) & 3) == 0)
		 && (((((usqInt)GIV(newMethod))) >= (startOfMemory()))
		 && (((((usqInt)GIV(newMethod))) < GIV(freeStart))
		 && (((longAt(GIV(newMethod))) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return -1;
	}
	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	return ((primBits = (methodHeader >> 1)),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512));
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnValue: */
sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* StackInterpreter>>#methodUsesAlternateBytecodeSet: */
sqInt
methodUsesAlternateBytecodeSet(sqInt aMethodObj)
{
    sqInt methodHeader;

	/* begin headerIndicatesAlternateBytecodeSet: */
	assert(isCompiledMethod(aMethodObj));
	methodHeader = longAt((aMethodObj + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	return (((int) methodHeader)) < 0;
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

	/* StackInterpreter>>#moduleUnloaded: */
EXPORT(void)
moduleUnloaded(char *aModuleName)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */
		showSurfaceFn = 0;
	}
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

	/* StackInterpreter>>#moveFramesIn:through:toPage: */
static char * NoDbgRegParms
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    sqInt callerIP;
    int delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    sqInt numArgs;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    sqInt valuePointer;
    sqInt valuePointer1;

	newSP = ((newPage->baseAddress)) + BytesPerWord;
	/* begin frameStackedReceiverOffset: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = ((newPage->baseAddress)) - stackedReceiverOffset;
	/* begin setHeadFP:andSP:inPage: */
	theFP1 = ((oldPage->headFP)) + delta;
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(!(isBaseFrame(theFP)));
	assert(frameHasContext(callerFP));
	callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
	longAtput(theFP + stackedReceiverOffset, callerIP);
	assert((callerFP < ((oldPage->baseAddress)))
	 && (callerFP > (((oldPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerContext, longAt(callerFP + FoxThisContext));
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		/* begin frameCallerFP: */
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP != 0) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if ((byteAt((fpInNewPage + FoxFrameFlags) + 2)) != 0) {
			/* begin frameContext: */
			theContext = longAt(fpInNewPage + FoxThisContext);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0);
			valuePointer = (oopForPointer(fpInNewPage)) + 1;

			longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0);
			valuePointer1 = (oopForPointer(offsetCallerFP)) + 1;

			longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	return newFP;
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static char * NoDbgRegParms
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    sqInt numSlots;
    sqInt sz;

	/* begin numSlotsOf: */
	header = longAt(classOop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(classOop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord())))));
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClass(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))));
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))))),
		((maybeNameOop & 1) == 0)
			 && (((((usqInt) (longAt(maybeNameOop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop);
}


/*	Answer a full 32 bit integer object for the given integer value which
	is known not to be a SmallInteger value. This serves to share the
	code for creating a four byte LargeInteger in one place. */

	/* StackInterpreter>>#noInlineSigned32BitIntegerGutsFor: */
static sqInt NoDbgRegParms NeverInline
noInlineSigned32BitIntegerGutsFor(sqInt integerValue)
{
    sqInt largeClass;
    unsigned int magnitude;
    sqInt newLargeInteger;
    sqInt valueWord;

	assert(!((hasSixtyFourBitImmediates())));
	assert(!((isIntegerValue(integerValue))));
	if (integerValue < 0) {
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = (((usqInt)0)) - integerValue;
	}
	else {
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(largeClass, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord = SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord);
	return newLargeInteger;
}

	/* StackInterpreter>>#noInlineTemporary:in: */
static sqInt NoDbgRegParms
noInlineTemporaryin(sqInt offset, char *theFP)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord)));
}

	/* StackInterpreter>>#noInlineTemporary:in:put: */
static sqInt NoDbgRegParms
noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAtput((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord), valueOop)
		: longAtput(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord), valueOop));
}


/*	Answer true if there are no marked contexts on thePage. */

	/* StackInterpreter>>#noMarkedContextsOnPage: */
static sqInt NoDbgRegParms
noMarkedContextsOnPage(StackPage *thePage)
{
    char *theFP;

	assert(!(isFree(thePage)));
	theFP = (thePage->headFP);
	do {
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			if (((longAt(longAt(theFP + FoxThisContext))) & MarkBit) != 0) {
				return 0;
			}
		}
	} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
	return 1;
}

	/* StackInterpreter>>#numStkPages */
static sqInt
numStkPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(numStackPages);
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
sqInt
objCouldBeClassObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldOop;

	return (((((usqInt) (longAt(objOop))) >> (instFormatFieldLSB())) & 15) <= 4)
	 && (((numSlotsOf(objOop)) > InstanceSpecificationIndex)
	 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))))),
	((((fieldOop & 3) == 0)
		 && (((((usqInt)fieldOop)) >= (startOfMemory()))
		 && (((((usqInt)fieldOop)) < GIV(freeStart))
		 && (((longAt(fieldOop)) & TypeMask) != HeaderTypeGC))))
		 && ((((((usqInt) (longAt(fieldOop))) >> (instFormatFieldLSB())) & 15) <= 4)
		 || (0)))
		 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))))),
		((((fieldOop & 3) == 0)
			 && (((((usqInt)fieldOop)) >= (startOfMemory()))
			 && (((((usqInt)fieldOop)) < GIV(freeStart))
			 && (((longAt(fieldOop)) & TypeMask) != HeaderTypeGC))))
			 && ((((((usqInt) (longAt(fieldOop))) >> (instFormatFieldLSB())) & 15) <= 4)
			 || (0)))
			 && (((longAt((objOop + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) & 1)))))));
}


/*	Like #stackObjectValue: but access method arguments left-to-right */

	/* StackInterpreter>>#objectArg: */
sqInt
objectArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0;
	}
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	This is the entry-point for plugins and primitives that wish to reacquire
	the VM after having
	released it via disownVM or callbacks that want to acquire it without
	knowing their ownership
	status. While this exists for the threaded FFI VM we use it to reset
	newMethod and the
	argumentCount after a callback.
	
	Answer the argumentCount encoded as a SmallInteger if the current thread
	is the VM thread.
	Answer -1 if the current thread is unknown to the VM and fails to take
	ownership. 
 */

	/* StackInterpreter>>#ownVM: */
sqInt
ownVM(sqInt threadIndexAndFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(amInVMThread())) {
		return -1;
	}
	assert(GIV(primFailCode) == 0);
	assert((isOopCompiledMethod(GIV(newMethod)))
	 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	return (((usqInt)GIV(argumentCount) << 1) | 1);
}

	/* StackInterpreter>>#penultimateLiteralOf: */
sqInt
penultimateLiteralOf(sqInt aMethodOop)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop));
	/* begin literal:ofMethod: */
	offset = ((assert((((assert(isCompiledMethod(aMethodOop)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(aMethodOop)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(aMethodOop)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(aMethodOop)),
			/* begin fetchPointer:ofObject: */
			longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 2;
	return longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#popStack */
sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop: */
sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop:thenPush: */
void
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	integerValue is interpreted as POSITIVE, e.g. as the result of Bitmap>at:.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#positive32BitIntegerFor: */
sqInt
positive32BitIntegerFor(unsigned int integerValue)
{
    sqInt newLargeInteger;
    sqInt valueWord1;

	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		return ((integerValue << 1) | 1);
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	return newLargeInteger;

}


/*	Answer a Large Positive Integer object for the given integer value. N.B.
	will *not* cause a GC. */

	/* StackInterpreter>>#positive64BitIntegerFor: */
sqInt
positive64BitIntegerFor(usqLong integerValue)
{
    unsigned int highWord;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    sqInt sz;
    sqLong value;
    sqInt valueWord1;

	if (((highWord = integerValue >> 32)) == 0) {
		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) (((unsigned int) integerValue)))) <= (MaxSmallInteger)) {
			return (((((unsigned int) integerValue)) << 1) | 1);
		}
		newLargeInteger1 = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) integerValue)));
		long32Atput((newLargeInteger1 + BaseHeaderSize) + (0U << 2), valueWord1);

		return newLargeInteger1;

	}
	sz = 5;
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
			if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
				sz += 1;
			}
		}
	}

	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - sz) & 3), 8 / BytesPerOop);
	/* begin storeLong64:ofObject:withValue: */
	value = SQ_SWAP_8_BYTES_IF_BIGENDIAN(integerValue);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), value);
	long32Atput(((newLargeInteger + BaseHeaderSize) + (0U << 3)) + 4, ((unsigned sqLong)value) >> 32);
	return newLargeInteger;
}

	/* StackInterpreter>>#positiveMachineIntegerFor: */
static sqInt NoDbgRegParms
positiveMachineIntegerFor(usqIntptr_t value)
{
    sqInt newLargeInteger;
    sqInt resultObj;
    sqInt valueWord1;

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) value)) <= (MaxSmallInteger)) {
		resultObj = ((value << 1) | 1);
		goto l4;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
	/* begin storeLong32:ofObject:withValue: */
	valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(value);
	long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

	resultObj = newLargeInteger;
	goto l4;

l4:	/* end positive32BitIntegerFor: */;

	return resultObj;
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

	/* StackInterpreter>>#primitiveEventProcessingControl */
EXPORT(void)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int enabled;
    char *sp;
    char *sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				return;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Note: With the Squeak V3 format we now have 10 bits of primitive index,
	but they are
	in two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the
	Spur format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt primBits;

	return ((primBits = (methodHeader >> 1)),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512));
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt methodHeader;
    sqInt primBits;

	/* begin primitiveIndexOfMethod:header: */
	assert(isCompiledMethod(methodPointer));
	methodHeader = longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	return ((primBits = (methodHeader >> 1)),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512));
}

	/* StackInterpreter>>#printActivationNameForSelector:startClass: */
static void NoDbgRegParms
printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classDict;
    sqInt classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methClass;
    sqInt sz;

	if (((startClass & 3) == 0)
	 && (((((usqInt)startClass)) >= (startOfMemory()))
	 && (((((usqInt)startClass)) < GIV(freeStart))
	 && (((longAt(startClass)) & TypeMask) != HeaderTypeGC)))) {
		/* begin findClassForSelector:lookupClass:do: */
		currClass = startClass;
		do {
			classDict = longAt((currClass + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
			/* begin numSlotsOf: */
			header = longAt(classDict);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(classDict - (BytesPerWord * 2))) & AllButTypeMask
				: header & SizeMask);
			classDictSize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
			i = SelectorStart;
			while (i < classDictSize) {
				if (aSelector == (longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					methClass = currClass;

					goto l4;
				}
				i += 1;
			}
			/* begin followField:ofObject: */
			currClass = longAt((currClass + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		} while(!(currClass == GIV(nilObj)));
		methClass = null;

	l4:	/* end findClassForSelector:lookupClass:do: */;
		if ((methClass == null)
		 || (startClass == methClass)) {
			printNameOfClasscount(methClass, 5);
			/* begin printChar: */
			putchar('>');
			if (!(methClass)) {
				printStringOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))));
				print(" ");
			}
		}
		else {
			printNameOfClasscount(startClass, 5);
			/* begin printChar: */
			putchar('(');
			printNameOfClasscount(methClass, 5);
			/* begin printChar: */
			putchar(')');
			/* begin printChar: */
			putchar('>');
		}
	}
	else {
		print("INVALID CLASS");
	}
	if (((aSelector & 1))
	 || (((aSelector & 3) == 0)
	 && (((((usqInt)aSelector)) >= (startOfMemory()))
	 && (((((usqInt)aSelector)) < GIV(freeStart))
	 && (((longAt(aSelector)) & TypeMask) != HeaderTypeGC))))) {
		if (((aSelector & 1) == 0)
		 && (((((usqInt) (longAt(aSelector))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {
			printStringOf(aSelector);
		}
		else {
			printOopShort(aSelector);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
}

	/* StackInterpreter>>#printActivationNameFor:receiver:isBlock:firstTemporary: */
static void NoDbgRegParms
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt ccIndex2;
    sqInt classObj;
    sqInt methClass;
    sqInt methodSel;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rclass;

	if (isBlock) {
		print("[] in ");
	}
	/* begin findClassOfMethod:forReceiver: */
	if ((((anObject & 1))
	 || (((anObject & 3) == 0)
	 && (((((usqInt)anObject)) >= (startOfMemory()))
	 && (((((usqInt)anObject)) < GIV(freeStart))
	 && (((longAt(anObject)) & TypeMask) != HeaderTypeGC)))))
	 && (!0)) {
		rclass = findClassContainingMethodstartingAt(aMethod, ((anObject & 1)
			? (/* begin fetchPointer:ofObject: */
				longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
			: (((ccIndex2 = (((usqInt) (longAt(anObject))) >> (compactClassFieldLSB())) & 0x1F)) == 0
					? (longAt(anObject - BaseHeaderSize)) & AllButTypeMask
					: (/* begin fetchPointer:ofObject: */
						(oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
						longAt((oop2 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex2 - 1)) << (shiftForWord())))))))));
		if (rclass != GIV(nilObj)) {
			methClass = rclass;
			goto l6;
		}
	}
	if (!((((aMethod & 3) == 0)
		 && (((((usqInt)aMethod)) >= (startOfMemory()))
		 && (((((usqInt)aMethod)) < GIV(freeStart))
		 && (((longAt(aMethod)) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt) (longAt(aMethod))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin nilObject */
		methClass = GIV(nilObj);
		goto l6;
	}
	methClass = findClassContainingMethodstartingAt(aMethod, safeMethodClassOf(aMethod));
l6:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethod(aMethod);
	if ((((anObject & 1))
	 || (((anObject & 3) == 0)
	 && (((((usqInt)anObject)) >= (startOfMemory()))
	 && (((((usqInt)anObject)) < GIV(freeStart))
	 && (((longAt(anObject)) & TypeMask) != HeaderTypeGC)))))
	 && (addressCouldBeClassObj(((anObject & 1)
		? (/* begin fetchPointer:ofObject: */
			(classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))))))
		: (((ccIndex = (((usqInt) (longAt(anObject))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (classObj = (longAt(anObject - BaseHeaderSize)) & AllButTypeMask)
				: (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					(classObj = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))))))) {
		if ((classObj == methClass)
		 || ((methClass == null)
		 || (methClass == GIV(nilObj)))) {
			printNameOfClasscount(classObj, 5);
		}
		else {
			printNameOfClasscount(classObj, 5);
			print("(");
			printNameOfClasscount(methClass, 5);
			print(")");
		}
	}
	else {
		print("INVALID RECEIVER");
	}
	print(">");
	if (((methodSel & 1))
	 || (((methodSel & 3) == 0)
	 && (((((usqInt)methodSel)) >= (startOfMemory()))
	 && (((((usqInt)methodSel)) < GIV(freeStart))
	 && (((longAt(methodSel)) & TypeMask) != HeaderTypeGC))))) {
		if (methodSel == GIV(nilObj)) {
			print("(nil)");
		}
		else {
			printStringOf(methodSel);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))))
	 && ((((maybeMessage & 3) == 0)
	 && (((((usqInt)maybeMessage)) >= (startOfMemory()))
	 && (((((usqInt)maybeMessage)) < GIV(freeStart))
	 && (((longAt(maybeMessage)) & TypeMask) != HeaderTypeGC))))
	 && (((((ccIndex1 = (((usqInt) (longAt(maybeMessage))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(maybeMessage - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassMessage) << (shiftForWord()))))))))) {

		/* print arg message selector */
		methodSel = longAt((maybeMessage + BaseHeaderSize) + (((int)((usqInt)(MessageSelectorIndex) << (shiftForWord())))));
		print(" ");
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */

	/* StackInterpreter>>#printAllStacks */
void
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt chunk;
    sqInt classObj;
    sqInt fwdBlock;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt mutexClass;
    sqInt obj;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    sqInt p;
    sqInt pri;
    sqInt proc;
    sqInt processList;
    sqInt realHeader;
    sqInt schedLists;
    sqInt semaphoreClass;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;

	obj = 0;
	/* begin fetchPointer:ofObject: */
	oop2 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	proc = longAt((oop2 + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	printNameOfClasscount(((proc & 1)
		? (/* begin fetchPointer:ofObject: */
			longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
		: (((ccIndex = (((usqInt) (longAt(proc))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(proc - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))), 5);
	/* begin space */
	putchar(' ');
	printHex(proc);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, proc));
	/* begin cr */
	printf("\n");
	printCallStackFP(GIV(framePointer));
	/* begin fetchPointer:ofObject: */
	oop3 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	schedLists = longAt((oop3 + BaseHeaderSize) + (((int)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	if (GIV(highestRunnableProcessPriority) == 0) {
		/* begin numSlotsOf: */
		header = longAt(schedLists);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(schedLists - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		p = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	else {
		p = GIV(highestRunnableProcessPriority);
	}
	for (pri = (p - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + BaseHeaderSize) + (((sqInt)((usqInt)(pri) << (shiftForWord())))));
		if (!((assert(!(isForwarded(processList))),
			(longAt((processList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)))) {
			/* begin cr */
			printf("\n");
			print("processes at priority ");
			printNum(pri + 1);
			printProcsOnList(processList);
		}
	}
	/* begin cr */
	printf("\n");
	print("suspended processes");
	/* begin fetchPointer:ofObject: */
	semaphoreClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord())))));
	/* begin fetchPointer:ofObject: */
	mutexClass = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassMutex) << (shiftForWord())))));
	/* begin allObjectsDoSafely: */
	chunk = startOfMemory();
	oop4 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop4)) < GIV(freeStart)) {
		if (!(((longAt(oop4)) & TypeMask) == HeaderTypeFree)) {
			if (((ccIndex1 = (((usqInt) (longAt(oop4))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
				classObj = (longAt(oop4 - BaseHeaderSize)) & AllButTypeMask;
			}
			else {
				/* begin fetchPointer:ofObject: */
				oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
				classObj = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
			}
			if ((classObj == semaphoreClass)
			 || (classObj == mutexClass)) {
				printProcsOnList(oop4);
			}

		}
		/* begin objectAfterWhileForwarding: */
		header2 = longAt(oop4);
		if ((header2 & MarkBit) == 0) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop4, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop4)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop4)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header1 = longAt(oop4);
				sz1 = ((header1 & TypeMask) == HeaderTypeSizeAndClass
					? (longAt(oop4 - (BytesPerWord * 2))) & LongSizeMask
					: header1 & SizeMask);
			}
			oop4 = (oop4 + sz1) + (headerTypeBytes[(longAt(oop4 + sz1)) & TypeMask]);
			goto l12;
		}
		fwdBlock = ((sqInt)((usqInt)((header2 & AllButMarkBitAndTypeMask)) << 1));
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock + BytesPerWord);
		if ((realHeader & TypeMask) == HeaderTypeSizeAndClass) {
			sz2 = (longAt(oop4 - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz2 = realHeader & SizeMask;
		}
		oop4 = (oop4 + sz2) + (headerTypeBytes[(longAt(oop4 + sz2)) & TypeMask]);
	l12:	/* end objectAfterWhileForwarding: */;
	}

}

	/* StackInterpreter>>#printCallStack */
void
printCallStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(framePointer) == null) {
		printCallStackOf(fetchPointerofObject(SuspendedContextIndex, fetchPointerofObject(ActiveProcessIndex, fetchPointerofObject(ValueIndex, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))))));
	}
	else {
		printCallStackFP(GIV(framePointer));
	}
}

	/* StackInterpreter>>#printCallStackFP: */
static sqInt NoDbgRegParms
printCallStackFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP);
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
	return 0;
}

	/* StackInterpreter>>#printCallStackOf: */
sqInt
printCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	if ((((((usqInt)aContextOrProcessOrFrame)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)aContextOrProcessOrFrame)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)aContextOrProcessOrFrame)) <= (((usqInt)GIV(pages))))))) {
		return printCallStackFP(((char *) aContextOrProcessOrFrame));
	}
	if (couldBeProcess(aContextOrProcessOrFrame)) {
		return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord()))))));
	}
	context = aContextOrProcessOrFrame;
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
	return 0;
}

	/* StackInterpreter>>#printCallStackOf:currentFP: */
static sqInt NoDbgRegParms
printCallStackOfcurrentFP(sqInt aContext, char *currFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt index;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			theFP = pointerForOop(senderOop - 1);

			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP)) {
				/* begin stackPageFor: */
				index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
				thePage = stackPageAtpages(index, GIV(pages));
				if (isFree(thePage)) {
					/* begin printHexPtr: */
					printHex(oopForPointer(theFP));
					print(" is on a free page?!");
					/* begin cr */
					printf("\n");
					return null;
				}
				shortPrintFrameAndCallers(theFP);
				theFP = (thePage->baseFP);
				/* begin frameCallerContext: */
				ctxt = longAt(theFP + FoxCallerContext);
							}
			else {
				print("widowed caller frame ");
				/* begin printHexPtr: */
				printHex(oopForPointer(theFP));
				/* begin cr */
				printf("\n");
				return null;
			}
		}
		else {
			shortPrintContext(ctxt);
			ctxt = longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		}
	}
	return 0;
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#printChar: */
void
printChar(sqInt aByte)
{
	putchar(aByte);
}


/*	Print the call stack of aContext until it links to a frame. */

	/* StackInterpreter>>#printContextCallStackOf: */
static sqInt NoDbgRegParms
printContextCallStackOf(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
	 || (((longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	return ctxt;
}

	/* StackInterpreter>>#printContext: */
void
printContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ip;
    sqInt sender;
    sqInt sp;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	ip = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	if ((sender & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print("married (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		else {
			print("widowed (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		print("sender   ");
		printNum(sender);
		print(" (");
		/* begin printHexPtr: */
		printHex(oopForPointer((assert((sender & 1)),
		pointerForOop(sender - 1))));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("ip       ");
		printNum(ip);
		print(" (");
		/* begin printHexPtr: */
		printHex(oopForPointer((assert((ip & 1)),
		pointerForOop(ip - 1))));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
	}
	else {
		print("sender   ");
		shortPrintOop(sender);
		print("ip       ");
		if (ip == GIV(nilObj)) {
			shortPrintOop(ip);
		}
		else {
			printNum(ip);
			print(" (");
			printNum((ip >> 1));
			/* begin space */
			putchar(' ');
			printHex((ip >> 1));
			/* begin printChar: */
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
	sp = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	sp = ((sp < ((lengthOf(aContext)) - ReceiverIndex)) ? sp : ((lengthOf(aContext)) - ReceiverIndex));
	print("sp       ");
	printNum(sp);
	print(" (");
	printNum((sp >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	print("method   ");
	/* begin printMethodFieldForPrintContext: */
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord()))))));
	print("closure  ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ClosureIndex) << (shiftForWord()))))));
	print("receiver ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	sp = (sp >> 1);
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);
		/* begin space */
		putchar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
}

	/* StackInterpreter>>#printExternalHeadFrame */
void
printExternalHeadFrame(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer));
}

	/* StackInterpreter>>#printFrameAndCallers:SP:short: */
static sqInt NoDbgRegParms
printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		printFrameAndCallersSPshort(pointerForOop(longAt(theFP + FoxSavedFP)), (assert(!(isBaseFrame(theFP))),
		(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord), printShort);
	}
	if (printShort) {
		shortPrintFrame(theFP);
		return null;
	}
	/* begin cr */
	printf("\n");
	printFrameWithSP(theFP, theSP);
	return 0;
}

	/* StackInterpreter>>#printFrameFlagsForFP: */
static void NoDbgRegParms
printFrameFlagsForFP(char *theFP)
{
    char *address;
    sqInt it;

	address = theFP + FoxFrameFlags;
	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	print(":       flags: ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		printNum(it);
	}
	print("  numArgs: ");
	printNum(byteAt((theFP + FoxFrameFlags) + 1));
	print(((byteAt((theFP + FoxFrameFlags) + 2)) != 0
		? " hasContext"
		: " noContext"));
	print(((byteAt((theFP + FoxFrameFlags) + 3)) != 0
		? " isBlock"
		: " notBlock"));
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrameOop:at: */
static void NoDbgRegParms
printFrameOopat(char *name, char *address)
{
    sqInt i;
    sqInt iLimiT;
    sqInt it;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	for (i = 1, iLimiT = (12 - (strlen(name))); i <= iLimiT; i += 1) {
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	/* begin tab */
	putchar('	');
	/* begin printChar: */
	putchar('=');
	printOopShort(it);
	/* begin cr */
	printf("\n");
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

	/* StackInterpreter>>#printFramesInPage: */
EXPORT(void)
printFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 0);
}

	/* StackInterpreter>>#printFramesOnStackPageListInUse */
EXPORT(void)
printFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			print("page ");
			/* begin printHexPtrnp: */
			printf("0x%lx", ((unsigned long) (oopForPointer(page))));
			/* begin cr */
			printf("\n");
			printFramesInPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printFrameThing:andFrame:at: */
static void NoDbgRegParms
printFrameThingandFrameat(char *name, char *theFP, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	print(" frame: ");
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrameThing:at: */
static void NoDbgRegParms
printFrameThingat(char *name, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printFrame: */
sqInt
printFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *frameAbove;
    sqInt index;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		if (((((((sqInt)theFP)) & 3) == 0)
		 && (((((usqInt)(((sqInt)theFP)))) >= (startOfMemory()))
		 && (((((usqInt)(((sqInt)theFP)))) < GIV(freeStart))
		 && (((longAt(((sqInt)theFP))) & TypeMask) != HeaderTypeGC))))
		 && (((oopisGreaterThanOrEqualTo(((sqInt)theFP), startOfMemory()))
		 && (oopisLessThan(((sqInt)theFP), GIV(endOfMemory))))
		 && ((((((usqInt) (longAt(((sqInt)theFP)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
		 && (checkIsStillMarriedContextcurrentFP(((sqInt)theFP), GIV(framePointer)))))) {
			return printFrame(frameOfMarriedContext(((sqInt)theFP)));
		}
		/* begin printHexPtr: */
		printHex(oopForPointer(theFP));
		print(" is not in the stack zone?!");
		/* begin cr */
		printf("\n");
		return null;
	}
	frameAbove = null;
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (isFree(thePage)) {
			/* begin printHexPtr: */
			printHex(oopForPointer(theFP));
			print(" is on a free page?!");
			/* begin cr */
			printf("\n");
			return null;
		}
		if ((thePage != GIV(stackPage))
		 && (theFP == ((thePage->headFP)))) {
			theSP = (thePage->headSP);
		}
		else {
			/* begin safeFindFrameAbove:on:startingFrom: */
			startFrame = ((thePage == GIV(stackPage))
			 && (((GIV(framePointer) >= ((thePage->realStackLimit))) && (GIV(framePointer) <= ((thePage->baseAddress)))))
				? GIV(framePointer)
				: (thePage->headFP));
			assert(!(isFree(thePage)));
			if (startFrame == theFP) {
				frameAbove = null;
				goto l3;
			}
			aFrame = startFrame;
			while (1) {
				prevFrame = aFrame;
				/* begin frameCallerFP: */
				aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
				if (!(aFrame != 0)) break;
				if (theFP == aFrame) {
					frameAbove = prevFrame;
					goto l3;
				}
			}
			frameAbove = null;
		l3:	/* end safeFindFrameAbove:on:startingFrom: */;
			theSP = (!(frameAbove == null)
				? (assert(!(isBaseFrame(frameAbove))),
					(frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord)
				: 0);
		}
	}
	if (!(theSP)) {
		print("could not find sp; using bogus value");
		/* begin cr */
		printf("\n");
		/* begin frameReceiverLocation: */
		theSP = theFP + FoxReceiver;
	}
	printFrameWithSP(theFP, theSP);
	if (!(frameAbove == null)) {
		printFrameThingat("frame pc", frameAbove + FoxCallerSavedIP);
	}
	return 0;
}

	/* StackInterpreter>>#printFrame:WithSP: */
sqInt
printFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *addr;
    sqInt i;
    sqInt numArgs;
    sqInt theMethod;
    sqInt topThing;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		/* begin printHexPtr: */
		printHex(oopForPointer(theFP));
		print(" is not in the stack zone?!");
		/* begin cr */
		printf("\n");
		return null;
	}
	/* begin frameMethod: */
	theMethod = longAt(theFP + FoxMethod);
	/* begin frameNumArgs: */
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	shortPrintFrame(theFP);
	printFrameOopat("rcvr/clsr", (theFP + FoxCallerSavedIP) + ((numArgs + 1) * BytesPerWord));
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopat("arg", (theFP + FoxCallerSavedIP) + (i * BytesPerWord));
	}
	printFrameThingat("cllr ip/ctxt", theFP + FoxCallerSavedIP);
	printFrameThingat("saved fp", theFP + FoxSavedFP);
	printFrameOopat("method", theFP + FoxMethod);
	printFrameFlagsForFP(theFP);
	printFrameThingat("context", theFP + FoxThisContext);
	printFrameOopat("receiver", theFP + FoxReceiver);
	topThing = longAt(theSP);
	if ((topThing >= theMethod)
	 && (topThing <= (theMethod + (sizeBitsOfSafe(theMethod))))) {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
		printFrameThingat("frame ip", theSP);
	}
	else {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
	}
	return 0;
}


/*	Print n in hex, in the form '0x1234', unpadded */

	/* StackInterpreter>>#printHexnp: */
void
printHexnp(sqInt n)
{
	printf("0x%lx", ((unsigned long) n));
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles)  */

	/* StackInterpreter>>#printHex: */
void
printHex(sqInt n)
{
    char buf[37];
    sqInt len;


	/* large enough for a 64-bit value in hex plus the null plus 16 spaces */
	memset(buf,' ',36);
	len = sprintf(buf + 2 + 2 * BytesPerWord, "0x%" PRIxSQPTR, (usqIntptr_t)(n));
	printf("%s", buf + len);
	}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt chunk;
    sqInt classLookupKey;
    sqInt classOop;
    sqInt header;
    sqInt i;
    sqInt methodClassAssociation;
    sqInt n2;
    char *name;
    sqInt nameLen;
    sqInt obj;
    sqInt offset;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt sz;
    sqInt theClass1;

	/* begin allObjectsDo: */
	chunk = startOfMemory();
	oop3 = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop3)) < GIV(freeStart)) {
		if (!(((longAt(oop3)) & TypeMask) == HeaderTypeFree)) {
			if ((((((usqInt) (longAt(oop3))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
			 && ((maybeSelectorOfMethod(oop3)) == selector)) {

				/* try and print the key of the method class association (the name of the implementing class) */
				/* begin methodClassAssociationOf: */
				offset = ((assert((((assert(isCompiledMethod(oop3)),
/* begin fetchPointer:ofObject: */
longAt((oop3 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(oop3)),
/* begin fetchPointer:ofObject: */
longAt((oop3 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(oop3)),
/* begin fetchPointer:ofObject: */
longAt((oop3 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(oop3)),
			/* begin fetchPointer:ofObject: */
			longAt((oop3 + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
				methodClassAssociation = longAt((oop3 + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) oop3));
				/* begin space */
				putchar(' ');
				/* begin printOopShortInner: */
				oop = ((((methodClassAssociation & 1) == 0)
				 && (((((usqInt) (longAt(methodClassAssociation))) >> (instFormatFieldLSB())) & 15) <= 4))
				 && ((numSlotsOf(methodClassAssociation)) >= 2)
					? longAt((methodClassAssociation + BaseHeaderSize) + (0U << (shiftForWord())))
					: methodClassAssociation);
				if ((oop & 1)) {
					if ((oop & 1)) {
						printNum((oop >> 1));
						/* begin printChar: */
						putchar('(');
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) ((oop >> 1))));
						/* begin printChar: */
						putchar(')');

						goto l19;
					}
					print("unknown immediate ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) oop));

					goto l19;
				}
				if (!(((oop & 3) == 0)
					 && (((((usqInt)oop)) >= (startOfMemory()))
					 && (((((usqInt)oop)) < GIV(freeStart))
					 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
					print(((oop & (BytesPerWord - 1)) != 0
						? " is misaligned"
						: whereIs(oop)));
					goto l19;
				}
				if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
					print(" is a free chunk");
					goto l19;
				}
				if (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord()))))), ClassFloatCompactIndex)) {
					printFloat(dbgFloatValueOf(oop));
					goto l19;
				}
				if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
					classOop = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
				}
				else {
					/* begin fetchPointer:ofObject: */
					oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
					classOop = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
				}
				if (!(((classOop & 3) == 0)
					 && (((((usqInt)classOop)) >= (startOfMemory()))
					 && (((((usqInt)classOop)) < GIV(freeStart))
					 && (((longAt(classOop)) & TypeMask) != HeaderTypeGC))))) {
					print("a ??");
					goto l19;
				}
				if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
					printNameOfClasscount(oop, 5);
					goto l19;
				}
				if (oop == GIV(nilObj)) {
					print("nil");
					goto l19;
				}
				if (oop == GIV(trueObj)) {
					print("true");
					goto l19;
				}
				if (oop == GIV(falseObj)) {
					print("false");
					goto l19;
				}
				nameLen = lengthOfNameOfClass(classOop);
				if (nameLen == 0) {
					print("a ??");
					goto l19;
				}
				name = nameOfClass(classOop);
				if (nameLen == 10) {
					if ((strncmp(name, "ByteString", 10)) == 0) {

						/* strncmp is weird */
						/* begin printChar: */
						putchar('\'');
						printStringOf(oop);
						/* begin printChar: */
						putchar('\'');

						goto l19;
					}
					if ((strncmp(name, "ByteSymbol", 10)) == 0) {

						/* strncmp is weird */
						/* begin printChar: */
						putchar('#');
						printStringOf(oop);
						goto l19;
					}
				}
				if ((nameLen == 9)
				 && ((strncmp(name, "Character", 9)) == 0)) {
					/* begin printChar: */
					putchar('$');
					/* begin printChar: */
					aByte1 = ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 1);
					putchar(aByte1);

					goto l19;
				}
				print("a(n) ");
				for (i = 0; i < nameLen; i += 1) {
					/* begin printChar: */
					putchar(name[i]);
				}
				if ((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
				 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
				 && (isBytes(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(KeyIndex) << (shiftForWord()))))))))) {
					/* begin fetchClassOfNonImm: */
					oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))));
					if (((ccIndex1 = (((usqInt) (longAt(oop2))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
						classLookupKey = (longAt(oop2 - BaseHeaderSize)) & AllButTypeMask;
					}
					else {
						/* begin fetchPointer:ofObject: */
						classLookupKey = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
					}
					while (1) {
						if (classLookupKey == GIV(nilObj)) {
							goto l19;
						}
						if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
						/* begin followField:ofObject: */
						classLookupKey = longAt((classLookupKey + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
					}
					if (classLookupKey == GIV(nilObj)) {
						goto l21;
					}
					theClass1 = classOop;
					while (1) {
						if (theClass1 == classLookupKey) {
							goto l20;
						}
						if (!(theClass1 != GIV(nilObj))) break;
						/* begin followField:ofObject: */
						theClass1 = longAt((theClass1 + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
					}
				l20:	;
					/* begin space */
					putchar(' ');
					printOopShort(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(KeyIndex) << (shiftForWord()))))));
					print(" -> ");
					/* begin printHexnp: */
					n2 = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
					printf("0x%lx", ((unsigned long) n2));
				l21:	;
				}
			l19:	/* end printOopShortInner: */;
				/* begin cr */
				printf("\n");
			}

		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop3, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop3)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop3)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop3);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop3 - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop3 = (oop3 + sz) + (headerTypeBytes[(longAt(oop3 + sz)) & TypeMask]);
	}
}

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(void)
{
	printMethodCacheFor(-1);
}

	/* StackInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    sqInt i;
    sqIntptr_t m;
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;

	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || (m == thing)))))
		 && ((((s & 1))
		 || (((s & 3) == 0)
		 && (((((usqInt)s)) >= (startOfMemory()))
		 && (((((usqInt)s)) < GIV(freeStart))
		 && (((longAt(s)) & TypeMask) != HeaderTypeGC)))))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(c)))))) {
			printNum(i);
			/* begin space */
			putchar(' ');
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) i));
			/* begin cr */
			printf("\n");
			/* begin tab */
			putchar('	');
			if (((((usqInt) (longAt(s))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())) {
				printf("%" PRIxSQPTR " %.*s\n", s, (int)(numBytesOf(s)), (char *)firstIndexableField(s));
			}
			else {
				shortPrintOop(s);
			}
			/* begin tab */
			putchar('	');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				printNum(c);
				/* begin space */
				putchar(' ');
				shortPrintOop(c);
			}
			/* begin tab */
			putchar('	');
			shortPrintOop(m);
			/* begin tab */
			putchar('	');
			if (p > 1024) {
				/* begin printHexnp: */
				printf("0x%lx", ((unsigned long) p));
			}
			else {
				printNum(p);
			}
			/* begin cr */
			printf("\n");
		}
	}
	if (n > 1) {
		printNum(n);
		/* begin cr */
		printf("\n");
	}
}

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dictionary;
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	/* begin printMethodDictionary: */
	dictionary = longAt((behavior + BaseHeaderSize) + (((int)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
	methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(dictionary)) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
			printOopShort(selector);
			print(" => ");
			printOopShort(meth);
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	methodArray = longAt((dictionary + BaseHeaderSize) + (((int)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(dictionary)) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
			printOopShort(selector);
			print(" => ");
			printOopShort(meth);
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static void NoDbgRegParms
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt numSlots;
    sqInt sz;

	if (!(GIV(classNameIndex))) {
		print("??nil cnidx??");
		return;
	}
	if ((classOop == null)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class");
		return;
	}
	/* begin numSlotsOf: */
	header = longAt(classOop);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(classOop - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))), cnt - 1);
		print(" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class");
		}
		else {
			printStringOf(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord()))))));
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#printNum: */
static void NoDbgRegParms
printNum(sqInt n)
{
	printf("%ld", (long) n);
}

	/* StackInterpreter>>#printOopShort: */
static void NoDbgRegParms
printOopShort(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt classLookupKey;
    sqInt classOop;
    sqInt i;
    sqInt n2;
    char *name;
    sqInt nameLen;
    sqInt oop1;
    sqInt oop2;
    sqInt theClass1;

	/* begin printOopShortInner: */
	if ((oop & 1)) {
		if ((oop & 1)) {
			printNum((oop >> 1));
			/* begin printChar: */
			putchar('(');
			/* begin printHexnp: */
			printf("0x%lx", ((unsigned long) ((oop >> 1))));
			/* begin printChar: */
			putchar(')');

			goto l12;
		}
		print("unknown immediate ");
		/* begin printHexnp: */
		printf("0x%lx", ((unsigned long) oop));

		goto l12;
	}
	if (!(((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		print(((oop & (BytesPerWord - 1)) != 0
			? " is misaligned"
			: whereIs(oop)));
		goto l12;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		print(" is a free chunk");
		goto l12;
	}
	if (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord()))))), ClassFloatCompactIndex)) {
		printFloat(dbgFloatValueOf(oop));
		goto l12;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		classOop = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		classOop = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	if (!(((classOop & 3) == 0)
		 && (((((usqInt)classOop)) >= (startOfMemory()))
		 && (((((usqInt)classOop)) < GIV(freeStart))
		 && (((longAt(classOop)) & TypeMask) != HeaderTypeGC))))) {
		print("a ??");
		goto l12;
	}
	if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		goto l12;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		goto l12;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		goto l12;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		goto l12;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (nameLen == 0) {
		print("a ??");
		goto l12;
	}
	name = nameOfClass(classOop);
	if (nameLen == 10) {
		if ((strncmp(name, "ByteString", 10)) == 0) {

			/* strncmp is weird */
			/* begin printChar: */
			putchar('\'');
			printStringOf(oop);
			/* begin printChar: */
			putchar('\'');

			goto l12;
		}
		if ((strncmp(name, "ByteSymbol", 10)) == 0) {

			/* strncmp is weird */
			/* begin printChar: */
			putchar('#');
			printStringOf(oop);
			goto l12;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		/* begin printChar: */
		putchar('$');
		/* begin printChar: */
		aByte1 = ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 1);
		putchar(aByte1);

		goto l12;
	}
	print("a(n) ");
	for (i = 0; i < nameLen; i += 1) {
		/* begin printChar: */
		putchar(name[i]);
	}
	if ((((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)
	 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
	 && (isBytes(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(KeyIndex) << (shiftForWord()))))))))) {
		/* begin fetchClassOfNonImm: */
		oop2 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))));
		if (((ccIndex1 = (((usqInt) (longAt(oop2))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			classLookupKey = (longAt(oop2 - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			classLookupKey = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
		}
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				goto l12;
			}
			if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
			/* begin followField:ofObject: */
			classLookupKey = longAt((classLookupKey + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		}
		if (classLookupKey == GIV(nilObj)) {
			goto l1;
		}
		theClass1 = classOop;
		while (1) {
			if (theClass1 == classLookupKey) {
				goto l2;
			}
			if (!(theClass1 != GIV(nilObj))) break;
			/* begin followField:ofObject: */
			theClass1 = longAt((theClass1 + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		}
	l2:	;
		/* begin space */
		putchar(' ');
		printOopShort(longAt((oop + BaseHeaderSize) + (((int)((usqInt)(KeyIndex) << (shiftForWord()))))));
		print(" -> ");
		/* begin printHexnp: */
		n2 = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		printf("0x%lx", ((unsigned long) n2));
	l1:	;
	}
l12:	/* end printOopShortInner: */;
	flush();
}

	/* StackInterpreter>>#printOop: */
sqInt
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt ccIndex;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt fmt1;
    sqInt header;
    sqInt index;
    sqInt lastIndex;
    sqInt oop1;
    sqInt startIP;
    sqInt sz;

	if ((oop & 1)) {
		return shortPrintOop(oop);
	}
	printHex(oop);
	if (!(((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		return (print(((oop & (BytesPerWord - 1)) != 0
					? " is misaligned"
					: whereIs(oop))),
			/* begin cr */
			printf("\n"));
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		print(" is a free chunk of size ");
		printNum((longAt(oop)) & AllButTypeMask);
		/* begin cr */
		printf("\n");
		return null;
	}
	print(": a(n) ");
	printNameOfClasscount((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (cls = (longAt(oop - BaseHeaderSize)) & AllButTypeMask)
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			(cls = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))), 5);
	if (cls == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord()))))))) {
		return (/* begin cr */
			printf("\n"),
			printFloat(dbgFloatValueOf(oop)),
			/* begin cr */
			printf("\n"));
	}
	/* begin formatOf: */
	fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
	if (fmt > 4) {
		print(" nbytes ");
		printNum(numBytesOf(oop));
	}
	/* begin cr */
	printf("\n");
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord()))))))) {
			print(" datasize ");
			printNum(sizeOfAlienData(oop));
			print(((longAt(oop + BaseHeaderSize)) < 0
				? " indirect @ "
				: ((longAt(oop + BaseHeaderSize)) == 0
						? " pointer @ "
						: " direct @ ")));
			return (printHex(((usqInt)(startOfAlienData(oop)))),
				/* begin cr */
				printf("\n"));
		}
		if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())) {
			lastIndex = ((64 < ((numBytesOf(oop)) / BytesPerWord)) ? 64 : ((numBytesOf(oop)) / BytesPerWord));
			if (lastIndex > 0) {
				for (index = 1; index <= lastIndex; index += 1) {
					/* begin space */
					putchar(' ');
					printHex(long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2)))));
					if ((index % 5) == 0) {
						/* begin cr */
						printf("\n");
					}
				}
				if (!((lastIndex % 5) == 0)) {
					/* begin cr */
					printf("\n");
				}
			}
			return 0;
		}
		return (printStringOf(oop),
			/* begin cr */
			printf("\n"));
	}
	startIP = (((lastPointerOf(oop)) + BytesPerOop) - BaseHeaderSize) / BytesPerOop;
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
			/* begin space */
			putchar(' ');
			if ((index % 5) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((lastIndex % 5) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf: */
		header = longAt(oop);
		/* begin lengthOf:baseHeader:format: */
		fmt1 = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (fmt1 <= 4) {
			lastIndex = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
			goto l5;
		}
		lastIndex = (fmt1 < (firstByteFormat())
			? ((usqInt) (sz - BaseHeaderSize)) >> 2
			: (sz - BaseHeaderSize) - (fmt1 & 3));
	l5:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08" PRIxSQPTR ": ", (usqIntptr_t)(oop+BaseHeaderSize+index-1));
			}
			/* begin fetchByte:ofObject: */
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			printf(" %02x/%-3d", (int)byte,(int)byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
	return 0;
}

	/* StackInterpreter>>#printProcessStack: */
void
printProcessStack(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ctx;
    sqInt oop;

	/* begin cr */
	printf("\n");
	printNameOfClasscount(((aProcess & 1)
		? (/* begin fetchPointer:ofObject: */
			longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord()))))))
		: (((ccIndex = (((usqInt) (longAt(aProcess))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(aProcess - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))), 5);
	/* begin space */
	putchar(' ');
	printHex(aProcess);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, aProcess));
	/* begin cr */
	printf("\n");
	ctx = longAt((aProcess + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer));
	}
}

	/* StackInterpreter>>#printProcsOnList: */
sqInt
printProcsOnList(sqInt procList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstProc;
    sqInt proc;

	proc = (firstProc = longAt((procList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord()))))));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		proc = longAt((proc + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
	return 0;
}

	/* StackInterpreter>>#printStackCallStackOf: */
sqInt
printStackCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    char *theFP;

	if (((aContextOrProcessOrFrame & 3) == 0)
	 && (((((usqInt)aContextOrProcessOrFrame)) >= (startOfMemory()))
	 && (((((usqInt)aContextOrProcessOrFrame)) < GIV(freeStart))
	 && (((longAt(aContextOrProcessOrFrame)) & TypeMask) != HeaderTypeGC)))) {
		if ((((aContextOrProcessOrFrame & 1) == 0)
		 && (((((usqInt) (longAt(aContextOrProcessOrFrame))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && (checkIsStillMarriedContextcurrentFP(aContextOrProcessOrFrame, null))) {
			return printStackCallStackOf(((sqInt)(frameOfMarriedContext(aContextOrProcessOrFrame))));
		}
		if (couldBeProcess(aContextOrProcessOrFrame)) {
			return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord()))))));
		}
		return null;
	}

	theFP = ((void *)aContextOrProcessOrFrame);
	while(1) {
		context = shortReversePrintFrameAndCallers(theFP);
		if (!((((longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (((theFP = frameOfMarriedContext(context)),
			checkIsStillMarriedContextcurrentFP(context, theFP))))) {
			return null;
		}
	}
	return 0;
}

	/* StackInterpreter>>#printStackPageList */
void
printStackPageList(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		/* begin printStackPage: */
		printStackPageuseCount(page, -1);
		/* begin cr */
		printf("\n");
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printStackPageListInUse */
void
printStackPageListInUse(void)
{
    sqInt n;
    StackPage *page;

	page = mostRecentlyUsedPage();
	n = 0;
	do {
		if (!(isFree(page))) {
			printStackPageuseCount(page, (n += 1));
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printStackPages */
void
printStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *page;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin printStackPage: */
		page = stackPageAtpages(i, GIV(pages));
		printStackPageuseCount(page, -1);
		/* begin cr */
		printf("\n");
	}
}

	/* StackInterpreter>>#printStackPagesInUse */
void
printStackPagesInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt n;

	n = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		if (!(isFree(stackPageAt(i)))) {
			printStackPageuseCount(stackPageAt(i), (n += 1));
			/* begin cr */
			printf("\n");
		}
	}
}

	/* StackInterpreter>>#printStackPage:useCount: */
static void NoDbgRegParms
printStackPageuseCount(StackPage *page, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *p;
    void *p1;
    void *p2;
    void *p3;
    void *p4;
    void *p5;
    void *p6;
    void *p7;
    void *p8;

	print("page ");
	/* begin printHexPtr: */
	printHex(oopForPointer(page));
	print(" (");
	printNum(pageIndexFor((page->realStackLimit)));
	if (n >= 0) {
		print(",");
		printNum(n);
	}
	print(")  (trace: ");
	printNum((page->trace));
	/* begin printChar: */
	putchar(')');
	if (isFree(page)) {
		print(" (free)");
	}
	if (page == (mostRecentlyUsedPage())) {
		print(" (MRU)");
	}
	if (((page->prevPage)) == (mostRecentlyUsedPage())) {
		print(" (LRU)");
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	putchar('	');
	print("ba: ");
	/* begin printHexPtr: */
	p3 = (page->baseAddress);
	printHex(oopForPointer(p3));
	print(" - sl: ");
	/* begin printHexPtr: */
	p4 = (page->realStackLimit);
	printHex(oopForPointer(p4));
	print(" - sl-so: ");
	/* begin printHexPtr: */
	p5 = ((page->realStackLimit)) - ((FrameSlots + 64) * BytesPerWord);
	printHex(oopForPointer(p5));
	print(" - la:");
	/* begin printHexPtr: */
	p6 = (page->lastAddress);
	printHex(oopForPointer(p6));
	if (!(isFree(page))) {
		/* begin cr */
		printf("\n");
		/* begin tab */
		putchar('	');
		print("baseFP ");
		/* begin printHexPtr: */
		p = (page->baseFP);
		printHex(oopForPointer(p));
		/* begin tab */
		putchar('	');
		print("headFP ");
		/* begin printHexPtr: */
		p1 = (page->headFP);
		printHex(oopForPointer(p1));
		/* begin tab */
		putchar('	');
		print("headSP ");
		/* begin printHexPtr: */
		p2 = (page->headSP);
		printHex(oopForPointer(p2));
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	putchar('	');
	print("prev ");
	/* begin printHexPtr: */
	p7 = ((void *) (page->prevPage));
	printHex(oopForPointer(p7));
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((((page->prevPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	/* begin printChar: */
	putchar(')');
	/* begin tab */
	putchar('	');
	print("next ");
	/* begin printHexPtr: */
	p8 = ((void *) (page->nextPage));
	printHex(oopForPointer(p8));
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((((page->nextPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
}

	/* StackInterpreter>>#printStackReferencesTo: */
void
printStackReferencesTo(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					if (oop == (longAt(theSP))) {
						print("FP: ");
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) theFP));
						print(" @ ");
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) theSP));
						/* begin cr */
						printf("\n");
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if (oop == (longAt(theFP + FoxThisContext))) {
						print("FP: ");
						/* begin printHexnp: */
						printf("0x%lx", ((unsigned long) theFP));
						print(" CTXT");
						/* begin cr */
						printf("\n");
					}
				}
				if (oop == (longAt(theFP + FoxMethod))) {
					print("FP: ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) theFP));
					print(" MTHD");
					/* begin cr */
					printf("\n");
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerContext */
			theSP = theFP + FoxCallerSavedIP;
			while (theSP <= ((thePage->baseAddress))) {
				if (oop == (longAt(theSP))) {
					print("FP: ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) theFP));
					print(" @ ");
					/* begin printHexnp: */
					printf("0x%lx", ((unsigned long) theSP));
					/* begin cr */
					printf("\n");
				}
				theSP += BytesPerWord;
			}
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static void NoDbgRegParms
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt cnt;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if ((oop & 1)) {
		return;
	}
	if (!(((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		return;
	}
	/* begin formatOf: */
	fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
	if (fmt < (firstByteFormat())) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOf(oop)))) ? ((max = 128)) : ((len = lengthOf(oop))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteArray) << (shiftForWord()))))), GIV(classByteArrayCompactIndex)))
	 || ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord()))))), ClassLargePositiveIntegerCompactIndex))
	 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord()))))), ClassLargeNegativeIntegerCompactIndex)))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			if ((byteAt((oop + BaseHeaderSize) + i)) == 13) {

				/* Character cr asInteger */
				print("<CR>");
				if ((i + 1) < len) {
					print("...");
				}
				return;
			}
			/* begin printChar: */
			aByte = byteAt((oop + BaseHeaderSize) + i);
			putchar(aByte);
			i += 1;
		}
	}
	if (len > max) {
		print("...");
	}
	flush();
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

	/* StackInterpreter>>#print: */
void
print(char *s)
{
	fputs(s, stdout);
}

	/* StackInterpreter>>#pushBool: */
void
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#pushedReceiverOrClosureOfFrame: */
static sqInt NoDbgRegParms
pushedReceiverOrClosureOfFrame(char *theFP)
{
	return longAt(theFP + (frameStackedReceiverOffset(theFP)));
}

	/* StackInterpreter>>#pushFloat: */
void
pushFloat(double f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = floatObjectOf(f);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* StackInterpreter>>#pushInteger: */
sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)integerValue << 1) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#push: */
void
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Append aLong to aFile in this platform's 'natural' byte order. aLong is
	either 32 or 64 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putLong:toFile: */
static void NoDbgRegParms
putLongtoFile(sqInt aLong, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aLong), sizeof(sqInt), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platform's 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putShort:toFile: */
static void NoDbgRegParms
putShorttoFile(short aShort, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aShort), sizeof(short), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

	/* StackInterpreter>>#putToSleep:yieldingIf: */
static void NoDbgRegParms
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt oop;
    sqInt oop1;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + (((int)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	priority = (oop >> 1);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	/* begin fetchPointer:ofObject: */
	oop1 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	processLists = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	processList = longAt((processLists + BaseHeaderSize) + (((sqInt)((usqInt)((priority - 1)) << (shiftForWord())))));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList);
	}
	else {
		/* begin addFirstLink:toList: */
		assert(!(isForwarded(processList)));
		assert((fetchPointerofObject(NextLinkIndex, aProcess)) == (nilObject()));
		firstLink = longAt((processList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
		assert(firstLink != aProcess);
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(processList, GIV(youngStart))) {
			possibleRootStoreIntovalue(processList, aProcess);
		}
		longAtput((processList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))), aProcess);
		if (firstLink == GIV(nilObj)) {

			/* a.k.a. (self isEmptyList: aList) */
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(processList, GIV(youngStart))) {
				possibleRootStoreIntovalue(processList, aProcess);
			}
			longAtput((processList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(aProcess, GIV(youngStart))) {
				possibleRootStoreIntovalue(aProcess, firstLink);
			}
			longAtput((aProcess + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))), firstLink);
		}
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aProcess, GIV(youngStart))) {
			possibleRootStoreIntovalue(aProcess, processList);
		}
		longAtput((aProcess + BaseHeaderSize) + (((int)((usqInt)(MyListIndex) << (shiftForWord())))), processList);
	}
}


/*	Append aWord32 to aFile in this platform's 'natural' byte order. aWord32
	is 32 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putWord32:toFile: */
static void NoDbgRegParms
putWord32toFile(int aWord32, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aWord32), 4, 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Return the integer value of the field without verifying that it is an
	integer value! For use in time-critical places where the integer-ness of
	the field can be guaranteed.
 */

	/* StackInterpreter>>#quickFetchInteger:ofObject: */
static sqInt NoDbgRegParms
quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt oop;

	oop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	assert((oop & 1));
	return (oop >> 1);
}


/*	Anwer true if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == (6505))
	 || (imageVersion == ((BytesPerWord == 4
		? 6504
		: 68002)));
}


/*	Read an image from the given file stream, allocating an amount of memory
	to its object heap.
	
	V3: desiredHeapSize is the total size of the heap. Fail if the image has
	an unknown format or
	requires more than the specified amount of memory.
	
	Spur: desiredHeapSize is ignored; this routine will attempt to provide at
	least extraVMMemory's
	ammount of free space after the image is loaded, taking any free space in
	teh image into account.
	extraVMMemory is stored in the image header and is accessible as
	vmParameterAt: 23. If
	extraVMMemory is 0, the value defaults to the default grow headroom. Fail
	if the image has an
	unknown format or if sufficient memory cannot be allocated.
	
	Details: This method detects when the image was stored on a machine with
	the opposite byte
	ordering from this machine and swaps the bytes automatically. Furthermore,
	it allows the header
	information to start 512 bytes into the file, since some file transfer
	programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix
	area could also be used to store an exec command on Unix systems, allowing
	one to launch
	Smalltalk by invoking the image name as a command. */

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt aValue;
    sqInt aValue1;
    sqInt aValue2;
    sqInt baseOfHeap;
    sqInt bytesRead;
    sqInt bytesToShift;
    sqInt ccIndex;
    sqInt classArrayClass;
    sqInt classArrayObj;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt header;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    usqInt heapSize;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt memEnd;
    sqInt memLimit;
    usqInt minimumMemory;
    sqInt oldBaseAddr;
    sqInt oop;
    sqInt oop1;
    sqInt swapBytes;
    sqInt sz;
    int w1;
    unsigned short w10;
    unsigned short w11;
    sqInt w12;
    sqInt w13;
    sqInt w14;
    sqInt w2;
    sqInt w3;
    sqInt w4;
    sqInt w5;
    int w6;
    unsigned short w7;
    unsigned short w8;
    int w9;


	/* guess Metaclass instSize */
	GIV(metaclassNumSlots) = 6;

	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */
	GIV(classNameIndex) = 6;
	swapBytes = checkImageVersionFromstartingAt(f, imageOffset);

	/* record header start position */
	headerStart = (sqImageFilePosition(f)) - 4;
	/* begin getWord32FromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(int), 1, f);
	headerSize = (swapBytes
		? SQ_SWAP_4_BYTES(w1)
		: w1);
	/* begin getLongFromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(w2), 1, f);
	dataSize = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w2)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w2)
#      endif /* BytesPerWord == 4 */
				
		: w2);
	/* begin getLongFromFile:swap: */
	w3 = 0;
	sqImageFileRead((&w3), sizeof(w3), 1, f);
	oldBaseAddr = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w3)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w3)
#      endif /* BytesPerWord == 4 */
				
		: w3);
	/* begin specialObjectsOop: */
	w13 = 0;
	sqImageFileRead((&w13), sizeof(w13), 1, f);
	anObject = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w13)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w13)
#      endif /* BytesPerWord == 4 */
				
		: w13);
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	w14 = 0;
	sqImageFileRead((&w14), sizeof(w14), 1, f);
	aValue = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w14)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w14)
#      endif /* BytesPerWord == 4 */
				
		: w14);
	GIV(lastHash) = aValue;
	/* begin getLongFromFile:swap: */
	w4 = 0;
	sqImageFileRead((&w4), sizeof(w4), 1, f);
	GIV(savedWindowSize) = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w4)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w4)
#      endif /* BytesPerWord == 4 */
				
		: w4);
	/* begin getLongFromFile:swap: */
	w5 = 0;
	sqImageFileRead((&w5), sizeof(w5), 1, f);
	headerFlags = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w5)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w5)
#      endif /* BytesPerWord == 4 */
				
		: w5);
	/* begin setImageHeaderFlagsFrom: */

	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;
	GIV(imageFloatsBigEndian) = ((headerFlags & 2) == 0
		? 1
		: 0);
	GIV(preemptionYields) = (headerFlags & 16) == 0;
	GIV(newFinalization) = (headerFlags & 64) != 0;
	/* begin getWord32FromFile:swap: */
	w6 = 0;
	sqImageFileRead((&w6), sizeof(int), 1, f);
	extraVMMemory = (swapBytes
		? SQ_SWAP_4_BYTES(w6)
		: w6);
	/* begin getShortFromFile:swap: */
	w7 = 0;
	sqImageFileRead((&w7), sizeof(unsigned short), 1, f);
	hdrNumStackPages = (swapBytes
		? ((((usqInt) w7) >> 8) & 0xFF) | (((int)((usqInt)((w7 & 0xFF)) << 8)))
		: w7);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
				? defaultNumStackPages()
				: hdrNumStackPages));

	/* pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.
	   It is used for the cog code size in Cog.  Preserve it to be polite to other VMs. */
	desiredNumStackPages = hdrNumStackPages;
	/* begin getShortFromFile:swap: */
	w8 = 0;
	sqImageFileRead((&w8), sizeof(unsigned short), 1, f);
	GIV(theUnknownShort) = (swapBytes
		? ((((usqInt) w8) >> 8) & 0xFF) | (((int)((usqInt)((w8 & 0xFF)) << 8)))
		: w8);
	/* begin getWord32FromFile:swap: */
	w9 = 0;
	sqImageFileRead((&w9), sizeof(int), 1, f);
	hdrEdenBytes = (swapBytes
		? SQ_SWAP_4_BYTES(w9)
		: w9);
	/* begin edenBytes: */
	aValue1 = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes()
				: hdrEdenBytes));
	GIV(edenBytes) = aValue1;
	desiredEdenBytes = hdrEdenBytes;
	/* begin getShortFromFile:swap: */
	w10 = 0;
	sqImageFileRead((&w10), sizeof(unsigned short), 1, f);
	hdrMaxExtSemTabSize = (swapBytes
		? ((((usqInt) w10) >> 8) & 0xFF) | (((int)((usqInt)((w10 & 0xFF)) << 8)))
		: w10);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}
	/* begin getShortFromFile:swap: */
	w11 = 0;
	sqImageFileRead((&w11), sizeof(unsigned short), 1, f);
	GIV(the2ndUnknownShort) = (swapBytes
		? ((((usqInt) w11) >> 8) & 0xFF) | (((int)((usqInt)((w11 & 0xFF)) << 8)))
		: w11);
	/* begin getLongFromFile:swap: */
	w12 = 0;
	sqImageFileRead((&w12), sizeof(w12), 1, f);
	firstSegSize = (swapBytes
		? 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(w12)
#      else /* BytesPerWord == 4 */
				SQ_SWAP_8_BYTES(w12)
#      endif /* BytesPerWord == 4 */
				
		: w12);
	allocationReserve = interpreterAllocationReserveBytes();
	minimumMemory = (dataSize + (newSpaceBytes())) + allocationReserve;
	heapSize = (desiredHeapSize + (newSpaceBytes())) + (((desiredHeapSize - dataSize) > allocationReserve
	? 0
	: allocationReserve));
	if (heapSize < minimumMemory) {
		insufficientMemorySpecifiedError();
	}

	/* begin memory: */
	aValue2 = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	GIV(memory) = aValue2;
	if (!(memory())) {
		insufficientMemoryAvailableError();
	}
	/* begin setHeapBase:memoryLimit:endOfMemory: */
	baseOfHeap = memory();
	memLimit = (memory()) + heapSize;
	memEnd = (memory()) + dataSize;
	/* begin setMemoryLimit: */
	assert((memLimit & (BytesPerWord - 1)) == 0);
	GIV(memoryLimit) = memLimit;
	/* begin setEndOfMemory: */
	assert((memEnd & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = memEnd;
	if (GIV(freeStart) == null) {
		GIV(freeStart) = memEnd;
	}
	sqImageFileSeek(f, headerStart + headerSize);
	/* begin readHeapFromImageFile:dataBytes: */
	bytesRead = sqImageFileRead(pointerForOop(GIV(memory)), sizeof(char), dataSize, f);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(memory) - oldBaseAddr;
	/* begin initializeInterpreter: */
	interpreterProxy = sqGetInterpreterProxy();
	dummyReferToProxy();
	initializeObjectMemory(bytesToShift);
	/* begin checkAssumedCompactClasses */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))))) != (fetchPointerofObject(ClassArrayCompactIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))))) != (fetchPointerofObject(ClassLargeNegativeIntegerCompactIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))))) {
		invalidCompactClassError("LargeNegativeInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))))) != (fetchPointerofObject(ClassLargePositiveIntegerCompactIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))))) != (fetchPointerofObject(ClassFloatCompactIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassMethodContext) << (shiftForWord())))))) != (fetchPointerofObject(ClassMethodContextCompactIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))))) {
		invalidCompactClassError("MethodContext");
	}
	GIV(classByteArrayCompactIndex) = compactIndexOfClass(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassByteArray) << (shiftForWord()))))));
	/* begin initializeExtraClassInstVarIndices */
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))));
	if (((ccIndex = (((usqInt) (longAt(classArrayObj))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		classArrayClass = (longAt(classArrayObj - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		classArrayClass = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	/* begin numSlotsOf: */
	header = longAt(classArrayClass);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(classArrayClass - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	GIV(metaclassNumSlots) = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());

	/* default */
	GIV(thisClassIndex) = 5;
	for (i1 = (InstanceSpecificationIndex + 1), iLimiT = (lengthOf(classArrayClass)); i1 <= iLimiT; i1 += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + (((sqInt)((usqInt)((i1 - 1)) << (shiftForWord())))))) == classArrayObj) {
			GIV(thisClassIndex) = i1 - 1;
		}
	}

	/* default */
	GIV(classNameIndex) = 6;
	for (i1 = (InstanceSpecificationIndex + 1), iLimiT = (lengthOf(classArrayObj)); i1 <= iLimiT; i1 += 1) {
		oop = longAt((classArrayObj + BaseHeaderSize) + (((sqInt)((usqInt)((i1 - 1)) << (shiftForWord())))));
		if ((((oop & 1) == 0)
		 && (((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && (((lengthOf(oop)) == 5)
		 && ((strncmp("Array", firstFixedField(oop), 5)) == 0))) {
			GIV(classNameIndex) = i1 - 1;
		}
	}
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	/* begin initialCleanup */
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));

	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = (time(NULL)) + (ioMSecs());
	}
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin");
	return dataSize;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

	/* StackInterpreter>>#reestablishContextPriorToCallback: */
EXPORT(sqInt)
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt index;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer11;
    sqInt valuePointer2;

	flag("obsolete");
	if (!(isLiveContext(callbackContext))) {
		return 0;
	}
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext);
	if (!(isLiveContext(calloutContext))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (isSingleContext(callbackContext)) {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		longAtput((callbackContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		longAtput((callbackContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	}
	else {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1);

		if (GIV(framePointer) == theFP) {

			/* common case */
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				freeStackPage(GIV(stackPage));
			}
			else {

				/* calloutContext is immediately below on the same page.  Make it current. */
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP))));
				GIV(stackPointer) = (GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer)))) + BytesPerWord;
				/* begin frameCallerFP: */
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackContext));
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer2 = GIV(nilObj);
			longAtput((callbackContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer2);
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer11 = GIV(nilObj);
			longAtput((callbackContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer11);
		}
	}
	if ((((longAt((calloutContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(calloutContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop1 & 1));
		theFP = pointerForOop(senderOop1 - 1);

		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		thePage = makeBaseFrameFor(calloutContext);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	return 1;
}


/*	Remove the first process from the given linked list. */

	/* StackInterpreter>>#removeFirstLinkOfList: */
static sqInt NoDbgRegParms
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	assert(!((isForwarded(aList))));
	first = longAt((aList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	last = longAt((aList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))));
	assert(!((isForwarded(first))));
	assert(!((isForwarded(last))));
	if (first == last) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		longAtput((aList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		longAtput((aList + BaseHeaderSize) + (((int)((usqInt)(LastLinkIndex) << (shiftForWord())))), valuePointer1);
	}
	else {
		next = longAt((first + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aList, GIV(youngStart))) {
			possibleRootStoreIntovalue(aList, next);
		}
		longAtput((aList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))), next);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer2 = GIV(nilObj);
	longAtput((first + BaseHeaderSize) + (((int)((usqInt)(NextLinkIndex) << (shiftForWord())))), valuePointer2);
	return first;
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yiled to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect. */

	/* StackInterpreter>>#resume:preemptedYieldingIf: */
static sqInt NoDbgRegParms
resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;

	/* begin fetchPointer:ofObject: */
	oop2 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((oop2 + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((int)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	activePriority = (oop >> 1);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aProcess + BaseHeaderSize) + (((int)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop1 & 1));
	newPriority = (oop1 >> 1);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly);
	transferTo(aProcess);
	return 1;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

	/* StackInterpreter>>#returnAs:ThroughCallback:Context: */
EXPORT(sqInt)
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutMethodContext;
    sqInt index;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer11;
    sqInt valuePointer2;

	assert(GIV(primFailCode) == 0);
	assert((returnTypeOop & 1));
	assert(!(isImmediate(vmCallbackContext)));
	assert((addressCouldBeObj(callbackMethodContext))
	 && (isContext(callbackMethodContext)));
	assert(((debugCallbackPath = 0)) == 0);
	if (!(((returnTypeOop & 1))
		 && (isLiveContext(callbackMethodContext)))) {
		assert(((debugCallbackPath = 1)) == 1);
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext);
	if (!(isLiveContext(calloutMethodContext))) {
		assert(((debugCallbackPath = 2)) == 2);
		return 0;
	}
	assert(((debugCallbackReturns += 1)) > 0);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (isSingleContext(callbackMethodContext)) {
		assert(((debugCallbackPath = debugCallbackPath | 4)) > 0);
		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		longAtput((callbackMethodContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = GIV(nilObj);
		longAtput((callbackMethodContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 8)) > 0);
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackMethodContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1);

		assert((frameReceiver(theFP)) == (splObj(ClassAlien)));
		if (GIV(framePointer) == theFP) {

			/* common case */
			assert(((debugCallbackPath = debugCallbackPath | 16)) > 0);
			if (!((longAt(theFP + FoxSavedFP)) == 0)) {

				/* calloutMethodContext is immediately below on the same page.  Make it current. */
				assert(((debugCallbackPath = debugCallbackPath | 32)) > 0);
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
				GIV(stackPointer) = (theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord;
				/* begin frameCallerFP: */
				GIV(framePointer) = pointerForOop(longAt(theFP + FoxSavedFP));
				/* begin setMethod: */
				GIV(method) = longAt(GIV(framePointer) + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				/* begin assertValidExecutionPointe:r:s: */
				assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__);
				siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
				return 1;
			}
			freeStackPage(GIV(stackPage));
		}
		else {
			assert(((debugCallbackPath = debugCallbackPath | 64)) > 0);
			externalDivorceFrameandContext(theFP, callbackMethodContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext));
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer2 = GIV(nilObj);
			longAtput((callbackMethodContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer2);
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer11 = GIV(nilObj);
			longAtput((callbackMethodContext + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer11);
		}
	}
	if ((((longAt((calloutMethodContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(calloutMethodContext)))) {
		assert(((debugCallbackPath = debugCallbackPath | 128)) > 0);
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutMethodContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop1 & 1));
		theFP = pointerForOop(senderOop1 - 1);

		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (((thePage->headFP)) == theFP
			? (thePage->headSP)
			: (findSPOfon(theFP, thePage)) - BytesPerWord);
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 256)) > 0);
		thePage = makeBaseFrameFor(calloutMethodContext);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setMethod: */
	GIV(method) = longAt((calloutMethodContext + BaseHeaderSize) + (((int)((usqInt)(MethodIndex) << (shiftForWord())))));
	assert(isOopCompiledMethod(GIV(method)));
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);

	/* N.B. siglongjmp is defined as _longjmp on non-win32 platforms.
	   This matches the use of _setjmp in ia32abicc.c. */
	primitiveFunctionPointer = (vmCallbackContext->savedPrimFunctionPointer);
	siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
	return 1;
}


/*	Reverse the given range of Display words (at different bit 
	depths, this will reverse different numbers of pixels). Used to 
	give feedback during VM activities such as garbage 
	collection when debugging. It is assumed that the given 
	word range falls entirely within the first line of the Display. */

	/* StackInterpreter>>#reverseDisplayFrom:to: */
static sqInt NoDbgRegParms
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayBits;
    sqInt displayObj;
    sqInt primFailCodeValue;
    sqInt ptr;
    unsigned int reversed;
    sqInt w;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	/* begin splObj: */
	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheDisplay) << (shiftForWord())))));
	if (!((((displayObj & 1) == 0)
		 && (((((usqInt) (longAt(displayObj))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((lengthOf(displayObj)) >= 4))) {
		return null;
	}
	w = longAt((displayObj + BaseHeaderSize) + (1U << (shiftForWord())));
	displayBits = longAt((displayObj + BaseHeaderSize) + (0U << (shiftForWord())));
	if (((displayBits & 1))
	 || (((w & 1) == 0)
	 || (((((usqInt) (longAt(displayBits))) >> (instFormatFieldLSB())) & 15) <= 4))) {
		return null;
	}
	wordStartIndex = startIndex * 4;
	wordEndIndex = (((endIndex * 4) < (sizeBitsOf(displayBits))) ? (endIndex * 4) : (sizeBitsOf(displayBits)));
	displayBits += BaseHeaderSize;
	for (ptr = (displayBits + wordStartIndex); ptr <= (displayBits + wordEndIndex); ptr += 4) {
		reversed = (long32At(ptr)) ^ 0xFFFFFFFFU;
		long32Atput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	displayBitsOfLeftTopRightBottom(displayObj, 0, 0, (w >> 1), 1);
	ioForceDisplayUpdate();
	GIV(primFailCode) = primFailCodeValue;
	return 0;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims. */

	/* StackInterpreter>>#rewriteMethodCacheEntryForExternalPrimitiveToFunction: */
static void NoDbgRegParms
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((sqIntptr_t) localPrimAddress));
	}
}


/*	Answer if there is room to push n arguments onto the current stack. We
	assume this is called by primitives that check there is enough room in any
	new context, and
	won't actually push the arguments in the current context if the primitive
	fails. With
	this assumption it is safe to answer based on the maximum argument count,
	/not/ the ammount of space in the current frame were it converted to a
	context..  */

	/* StackInterpreter>>#roomToPushNArgs: */
static sqInt NoDbgRegParms
roomToPushNArgs(sqInt n)
{
	
	/* simpler code that simply insists args are <= max arg count */
	return n <= (LargeContextSlots - CtxtTempFrameStart);

}


/*	Safe version of methodClassOf: that deals with malformed compiled methods,
	etc, and does not fixup forwarding pointers.. */

	/* StackInterpreter>>#safeMethodClassOf: */
static sqInt NoDbgRegParms
safeMethodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt maybeClass;
    sqInt offset;

	/* begin literal:ofMethod: */
	offset = ((assert((((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(methodPointer)),
/* begin fetchPointer:ofObject: */
longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(methodPointer)),
			/* begin fetchPointer:ofObject: */
			longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
	literal = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (!((((literal & 1) == 0)
		 && (((((usqInt) (longAt(literal))) >> (instFormatFieldLSB())) & 15) <= 4))
		 && ((numSlotsOf(literal)) > ValueIndex))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	maybeClass = longAt((literal + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	return maybeClass;
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the 1 arg
	invokeCallbackContext: or the 4 arg invokeCallback:stack:registers:jmpbuf:
	message, depending on what selector is installed in the
	specialObjectsArray. Note that if invoking the
	legacy invokeCallback:stack:registers:jmpbuf: we pass the
	vmCallbackContext as the jmpbuf
	argument (see reestablishContextPriorToCallback:). The arguments are raw C
	addresses and
	are converted to integer objects on the way. sendInvokeCallbackContext: &
	returnAs:ThroughCallback:Context: along with ownVM: and disownVM: conspire
	to save and
	restore newMethod, argumentCount and primitiveFunctionPointer around a
	callback. The VM depends on argumentCount being correct to cut-back the
	correct number of
	arguments on primitive return. If a primitive that invokes a callback
	fails after invoking a
	callback (a bad idea, but s**t happens during development) then newMethod
	is required to
	activate the right faling method, and Spur expects
	primitiveFunctionPointer to be valid, so
	asserts will fail misleadingly if not. */

	/* StackInterpreter>>#sendInvokeCallbackContext: */
EXPORT(sqInt)
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classTag;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	(vmCallbackContext->savedPrimFunctionPointer = primitiveFunctionPointer);
	/* begin fetchClassTagOfNonImm: */
	oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))));
	if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		classTag = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		classTag = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	/* begin splObj: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorInvokeCallback) << (shiftForWord())))));
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classTag)) != 0) {
			return 0;
		}
	}
	if (primitiveFunctionPointer != 0) {
		primitiveFunctionPointer = (vmCallbackContext->savedPrimFunctionPointer);
		return 0;
	}
	assert(((debugCallbackInvokes += 1)) > 0);
	/* begin push: */
	object3 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))));
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp3;
	if ((argumentCountOf(GIV(newMethod))) == 4) {
		/* begin push: */
		object = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin push: */
		object1 = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp2;
	}
	/* begin push: */
	object4 = positiveMachineIntegerFor(((usqInt)vmCallbackContext));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp4;
	/* begin justActivateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	/* begin push: */
	object5 = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object5);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l5;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l5:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	assert((frameReceiver(GIV(framePointer))) == (splObj(ClassAlien)));
	/* begin enterSmalltalkExecutiveFromCallback */
	interpret();
	return 1;
}


/*	Send the 4 argument callback message
	invokeCallback:stack:registers:jmpbuf: to Alien class with the supplied
	args. The arguments are raw C addresses
	and are converted to integer objects on the way. */

	/* StackInterpreter>>#sendInvokeCallback:Stack:Registers:Jmpbuf: */
EXPORT(sqInt)
sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classTag;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	/* begin fetchClassTagOfNonImm: */
	oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))));
	if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		classTag = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		classTag = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	/* begin splObj: */
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SelectorInvokeCallback) << (shiftForWord())))));
	GIV(argumentCount) = 4;
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classTag)) != 0) {
			return 0;
		}
	}
	if (!(((argumentCountOf(GIV(newMethod))) == 4)
		 && (primitiveFunctionPointer == 0))) {
		return 0;
	}
	/* begin push: */
	object = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassAlien) << (shiftForWord())))));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	/* begin push: */
	object1 = positiveMachineIntegerFor(thunkPtr);
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object2 = positiveMachineIntegerFor(stackPtr);
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
	GIV(stackPointer) = sp2;
	/* begin push: */
	object3 = positiveMachineIntegerFor(regsPtr);
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object4 = positiveMachineIntegerFor(jmpBufPtr);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp4;
	/* begin justActivateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	/* begin push: */
	object5 = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object5);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l5;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l5:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	/* begin enterSmalltalkExecutiveFromCallback */
	interpret();
	return 1;
}

	/* StackInterpreter>>#setBreakMNUSelector: */
void
setBreakMNUSelector(char *aString)
{
	if (((breakSelector = aString)) == null) {

		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = -(strlen(aString));
	}
}

	/* StackInterpreter>>#setBreakSelector: */
void
setBreakSelector(char *aString)
{
	if (((breakSelector = aString)) == null) {

		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = strlen(aString);
	}
}

	/* StackInterpreter>>#setFullScreenFlag: */
void
setFullScreenFlag(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(fullScreenFlag) = value;
}

	/* StackInterpreter>>#setInterruptCheckChain: */
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))())

{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

	/* StackInterpreter>>#setInterruptKeycode: */
void
setInterruptKeycode(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptKeycode) = value;
}

	/* StackInterpreter>>#setInterruptPending: */
void
setInterruptPending(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	forceInterruptCheck();
	GIV(interruptPending) = value;
}

	/* StackInterpreter>>#setNextWakeupUsecs: */
void
setNextWakeupUsecs(usqLong value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(nextWakeupUsecs) = value;
}

	/* StackInterpreter>>#setSavedWindowSize: */
void
setSavedWindowSize(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

	/* StackInterpreter>>#setSignalLowSpaceFlagAndSaveProcess */
static void
setSignalLowSpaceFlagAndSaveProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;
    sqInt oop;

	/* begin signalLowSpace: */
	GIV(signalLowSpace) = 1;
	/* begin lowSpaceThreshold: */
	GIV(lowSpaceThreshold) = 0;
	/* begin splObj: */
	lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ProcessSignalingLowSpace) << (shiftForWord())))));
	if (lastSavedProcess == GIV(nilObj)) {
		/* begin fetchPointer:ofObject: */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		/* begin splObj:put: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), activeProc);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ProcessSignalingLowSpace) << (shiftForWord())))), activeProc);
	}
	forceInterruptCheck();
}

	/* StackInterpreter>>#setTraceFlagOnContextsFramesPageIfNeeded: */
static void NoDbgRegParms
setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    void *pointer;
    sqInt senderOop;
    StackPage *thePage;

	if ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContextDuringGC(aContext)))) {
		/* begin stackPageFor: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		pointer = pointerForOop(senderOop - 1);

		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(((((thePage->trace)) >= StackPageUnreached) && (((thePage->trace)) <= StackPageTraced)));
		if (((thePage->trace)) == StackPageUnreached) {
			(thePage->trace = StackPageReachedButUntraced);
		}
	}
}

	/* StackInterpreter>>#shortPrintContext: */
static sqInt NoDbgRegParms
shortPrintContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt home;
    sqInt senderOop;
    char *theFP;

	if (!(((aContext & 1) == 0)
		 && (((((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		printHex(aContext);
		print(" is not a context");
		/* begin cr */
		printf("\n");
		return null;
	}
	printHex(aContext);
	if (((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			theFP = pointerForOop(senderOop - 1);

			print(" I (");

			printHex(((usqIntptr_t)theFP));
			print(") ");
		}
		else {
			print(" w ");
		}
	}
	else {
		print(" s ");
	}
	home = findHomeForContext(aContext);
	if (home == null) {
		print(" BOGUS CONTEXT (can't determine home)");
	}
	else {
		printActivationNameForreceiverisBlockfirstTemporary(fetchPointerofObject(MethodIndex, (!(home)
			? aContext
			: home)), (home == null
			? (/* begin nilObject */
				GIV(nilObj))
			: longAt((home + BaseHeaderSize) + (((int)((usqInt)(ReceiverIndex) << (shiftForWord())))))), home != aContext, longAt((home + BaseHeaderSize) + (((int)((usqInt)((0 + CtxtTempFrameStart)) << (shiftForWord()))))));
	}
	/* begin cr */
	printf("\n");
	return 0;
}

	/* StackInterpreter>>#shortPrintFrameAndCallers: */
static sqInt NoDbgRegParms
shortPrintFrameAndCallers(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	shortPrintFrame(theFP);
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		shortPrintFrameAndCallers(pointerForOop(longAt(theFP + FoxSavedFP)));
	}
	return 0;
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

	/* StackInterpreter>>#shortPrintFramesInPage: */
EXPORT(void)
shortPrintFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 1);
}

	/* StackInterpreter>>#shortPrintFramesOnStackPageListInUse */
EXPORT(void)
shortPrintFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			print("page ");
			/* begin printHexPtrnp: */
			printf("0x%lx", ((unsigned long) (oopForPointer(page))));
			/* begin cr */
			printf("\n");
			shortPrintFramesInPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#shortPrintFrame: */
static sqInt NoDbgRegParms
shortPrintFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameNumArgs;
    sqInt rcvr;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		print("invalid frame pointer");
		/* begin cr */
		printf("\n");
		return null;
	}
	/* begin frameReceiver: */
	rcvr = longAt(theFP + FoxReceiver);
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin space */
	putchar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(longAt(theFP + FoxMethod), rcvr, (byteAt((theFP + FoxFrameFlags) + 3)) != 0, (0 < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord))));
	/* begin space */
	putchar(' ');
	shortPrintOop(rcvr);
	return 0;
}

	/* StackInterpreter>>#shortPrintFrame:AndNCallers: */
void
shortPrintFrameAndNCallers(char *theFP, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((n != 0)
	 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		shortPrintFrame(theFP);
		shortPrintFrameAndNCallers(pointerForOop(longAt(theFP + FoxSavedFP)), n - 1);
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static sqInt NoDbgRegParms
shortPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop1;

	/* begin printHexnp: */
	printf("0x%lx", ((unsigned long) oop));
	if ((oop & 1)) {
		if ((oop & 1)) {
			printf("=%ld\n", (long)integerValueOf(oop));
		}
		return 0;
	}
	if (!(((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		return (print(((oop & (BytesPerWord - 1)) != 0
					? " is misaligned"
					: whereIs(oop))),
			/* begin cr */
			printf("\n"));
	}
	if ((((longAt(oop)) & TypeMask) == HeaderTypeFree)
	 || (isForwarded(oop))) {
		return printOop(oop);
	}
	print(": a(n) ");
	printNameOfClasscount((((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0
		? (longAt(oop - BaseHeaderSize)) & AllButTypeMask
		: (/* begin fetchPointer:ofObject: */
			(oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
			longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord()))))))), 5);
	/* begin cr */
	printf("\n");
	return 0;
}

	/* StackInterpreter>>#shortReversePrintFrameAndCallers: */
static sqInt NoDbgRegParms
shortReversePrintFrameAndCallers(char *aFramePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt caller;
    char *callerFP;
    char *theFP;

	if (aFramePointer == 0) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP);
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	/* begin frameCallerContext: */
	caller = longAt(theFP + FoxCallerContext);
	return caller;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#showDisplayBits:Left:Top:Right:Bottom: */
sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{
	if (deferDisplayUpdates) {
		return null;
	}
	displayBitsOfLeftTopRightBottom(aForm, l, t, r, b);
	return 0;
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

	/* StackInterpreter>>#signalExternalSemaphores */
static sqInt
signalExternalSemaphores(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt xArray;

	/* begin splObj: */
	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	return doSignalExternalSemaphores(numSlotsOf(xArray));
}


/*	Answer a full 32 bit integer object for the given integer value.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#signed32BitIntegerFor: */
sqInt
signed32BitIntegerFor(sqInt integerValue)
{
	if ((((sqInt)((((usqInt)integerValue)) ^ ((((usqInt)integerValue)) << 1)))) >= 0) {
		return (((usqInt)integerValue << 1) | 1);
	}
	return noInlineSigned32BitIntegerGutsFor(integerValue);

}


/*	Answer a Large Integer object for the given integer value. N.B. will *not*
	cause a GC. */

	/* StackInterpreter>>#signed64BitIntegerFor: */
sqInt
signed64BitIntegerFor(sqLong integerValue)
{
    usqInt highWord;
    sqInt largeClass;
    usqLong magnitude;
    sqInt newLargeInteger;
    sqInt sz;
    sqLong value1;
    sqInt valueWord;

	if (integerValue < 0) {
		if (integerValue >= (MinSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 1) | 1);
		}
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = 0 - (((usqLong) integerValue));
	}
	else {
		if (integerValue <= (MaxSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 1) | 1);
		}
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	if (((highWord = magnitude >> 32)) == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
			if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
				sz += 1;
				if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
					sz += 1;
				}
			}
		}
	}

	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(largeClass, (firstByteFormat()) + ((4 - sz) & 3), (sz + 3) / BytesPerOop);
	if (sz > 4) {
		/* begin storeLong64:ofObject:withValue: */
		value1 = SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 3), value1);
		long32Atput(((newLargeInteger + BaseHeaderSize) + (0U << 3)) + 4, ((unsigned sqLong)value1) >> 32);
	}
	else {
		/* begin storeLong32:ofObject:withValue: */
		valueWord = SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord);
	}

	return newLargeInteger;
}


/*	Answer if the method starts with a long store temp bytecode, which
	indicates it has a primitive error code.
 */
/*	249		11111001	i i i i i i i i	jjjjjjjj		Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 0;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

	/* StackInterpreter>>#sizeOfSTArrayFromCPrimitive: */
sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt oop;
    sqInt sz;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(((oop & 1) == 0)
		 && (isWordsOrBytesNonImm(oop)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin lengthOf: */
	header = longAt(oop);
	/* begin lengthOf:baseHeader:format: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if ((header & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = header & SizeMask;
	}
	sz -= header & Size4Bit;
	if (fmt <= 4) {
		return ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	update state of active context */

	/* StackInterpreter>>#snapshot: */
static sqInt NoDbgRegParms
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    sqInt rcvr1;
    void *setMacType;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt stackIndex;
    sqInt table;
    sqInt valuePointer;


	/* For now the stack munging below doesn't deal with more than one argument.
	   It can, and should. */
	rcvr = 0;
	if (GIV(argumentCount) != 0) {
		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp2;

	/* update state of active process */
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(1);
	/* begin fetchPointer:ofObject: */
	oop1 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((oop1 + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(activeProc, GIV(youngStart))) {
		possibleRootStoreIntovalue(activeProc, activeContext);
	}
	longAtput((activeProc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);
	GIV(tempOop) = activeContext;
	/* begin garbageCollectForSnapshot */
	incrementalGC();
	fullGC();
	clearRootsTable();
	activeContext = GIV(tempOop);
	GIV(tempOop) = 0;
	if (!GIV(primFailCode)) {

		/* Without contexts or stacks simulate
		   rcvr := self popStack. ''pop rcvr''
		   self push: trueObj.
		   to arrange that the snapshot resumes with true.  N.B. stackIndex is one-relative. */
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		assert((oop & 1));
		stackIndex = (oop >> 1);
		rcvr = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(trueObj);
		longAtput((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())))), valuePointer);
		writeImageFileIO();
		if ((!GIV(primFailCode))
		 && (!embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */
			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((activeContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)(stackIndex - 1) << 1) | 1));
	}
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = GIV(falseObj);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp1;
		/* begin justActivateNewMethod */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

		numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
		/* begin argumentCountOfMethodHeader: */
		numArgs = (((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15;

		/* could new rcvr be set at point of send? */
		rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr1)));
		/* begin push: */
		longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp11;
		/* begin push: */
		longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp21;
		GIV(framePointer) = GIV(stackPointer);
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp3;
		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method)));
		assert((methodHeaderOf(GIV(method))) == methodHeader);
		/* begin push: */
		object1 = (VMBIGENDIAN
			? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
			: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp5;
		/* begin push: */
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
		GIV(stackPointer) = sp6;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp7;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
		if (methodHeader & V3PrimitiveBitsMask) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			GIV(instructionPointer) += 0;
			if (GIV(primFailCode) != 0) {
				if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
					/* begin getErrorObjectFromPrimFailCode */
					if (GIV(primFailCode) > 0) {
						/* begin splObj: */
						table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
						if (GIV(primFailCode) <= (numSlotsOf(table))) {
							errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
							goto l5;
						}
					}
					errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
				l5:	/* end getErrorObjectFromPrimFailCode */;
					longAtPointerput(GIV(stackPointer), errorCode);
				}
				GIV(primFailCode) = 0;
			}
		}
	}
	return 0;
}

	/* StackInterpreter>>#space */
static void
space(void)
{
	/* begin printChar: */
	putchar(' ');
}

	/* StackInterpreter>>#specialSelector: */
sqInt
specialSelector(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((index * 2)) << (shiftForWord())))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackFloatValue: */
double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double result;

	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackIntegerValue: */
sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Answer the actual stackLimit offset in a page. Since stackPageByteSize may
	have chosen to shrink a page
	this may be less than stackPageFrameBytes, but it should be no more than
	stackPageFrameBytes. 
 */

	/* StackInterpreter>>#stackLimitBytes */
static sqInt
stackLimitBytes(void)
{
	return (((stackPageFrameBytes()) < (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord))));
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	method header fields
	context (uninitialized)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

	/* StackInterpreter>>#stackLimitOffset */
static sqInt
stackLimitOffset(void)
{
	return (FrameSlots + 64) * BytesPerWord;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackObjectValue: */
sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer a page size that is a power-of-two and contains a useful number of
	frames. Room for 256 slots for frames gives around 40 frames a page which
	is a
	good compromise between overflow rate and latency in divorcing a page. */

	/* StackInterpreter>>#stackPageByteSize */
static sqInt
stackPageByteSize(void)
{
    int largeSize;
    sqInt pageBytes;
    int smallSize;

	pageBytes = ((stackPageFrameBytes()) + ((FrameSlots + 64) * BytesPerWord));
	if ((pageBytes & (pageBytes - 1)) == 0) {

		/* = 0 => a power of two */
		return pageBytes;
	}
	largeSize = 1U << (highBit(pageBytes));
	smallSize = 1U << ((highBit(pageBytes)) - 1);
	assert((largeSize > pageBytes)
	 && (pageBytes > smallSize));
	return ((pageBytes - smallSize) <= (smallSize / 8)
		? smallSize
		: largeSize);
}


/*	Return a minimum amount of headroom for each stack page (in bytes).
	In a JIT the stack has to have room for interrupt handlers which will run
	on the
	stack. In the interpreter we don't actually need any headroom. */

	/* StackInterpreter>>#stackPageHeadroom */
static sqInt
stackPageHeadroom(void)
{
	return 0;
}


/*	Return the stackPointer of a Context or BlockContext. */

	/* StackInterpreter>>#stackPointerForMaybeMarriedContext: */
static sqInt NoDbgRegParms
stackPointerForMaybeMarriedContext(sqInt aContext)
{
    sqInt sp;
    sqInt sp1;

	if ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContext)))) {
		sp = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
		return sp;
	}
	/* begin fetchStackPointerOf: */
	sp1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((sp1 & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(aContext)));
	return (sp1 >> 1);
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPointerIndexForFrame: */
static sqInt NoDbgRegParms
stackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    StackPage *thePage;
    char *theSP;

	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	theSP = findSPOfon(theFP, thePage);
	return (((usqInt) ((theFP + FoxReceiver) - theSP)) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPositiveMachineIntegerValue: */
usqIntptr_t
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classOop;
    sqInt integerPointer;
    sqInt ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((integerPointer & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(integerPointer))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l2;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	bs = numBytesOfBytes(integerPointer);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerPointer)));
	}
	else {
		return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerPointer + BaseHeaderSize) + (0U << 2))))));
	}
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackSignedMachineIntegerValue: */
sqIntptr_t
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	return signedMachineIntegerValueOf(integerPointer);
}

	/* StackInterpreter>>#stackTop */
sqInt
stackTop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackValue: */
sqInt
stackValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
sqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return (((assert((((assert(isCompiledMethod(aCompiledMethod)),
/* begin fetchPointer:ofObject: */
longAt((aCompiledMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(aCompiledMethod)),
/* begin fetchPointer:ofObject: */
longAt((aCompiledMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(aCompiledMethod)),
/* begin fetchPointer:ofObject: */
longAt((aCompiledMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(aCompiledMethod)),
			/* begin fetchPointer:ofObject: */
			longAt((aCompiledMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop;
}


/*	Return what ST would return for <obj> at: index. */

	/* StackInterpreter>>#stObject:at: */
sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop1;
    sqInt reasonCode;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    sqInt valueWord1;

	/* begin baseHeader: */
	hdr = longAt(array);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(array))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((array + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			stSize = sp;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(array)));
		stSize = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((array + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))))) {
			return noInlineTemporaryin(index - 1, frameOfMarriedContext(array));
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			return longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
		}
		if (fmt >= (firstByteFormat())) {
			return (((usqInt)(byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			return ((integerValue << 1) | 1);
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		return newLargeInteger;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	return 0;
}


/*	Do what ST would return for <obj> at: index put: value. */

	/* StackInterpreter>>#stObject:at:put: */
sqInt
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt oop1;
    sqInt reasonCode;
    sqInt signedValueToStore;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;

	/* begin baseHeader: */
	hdr = longAt(array);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(array))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(array - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((array + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			stSize = sp;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(array)));
		stSize = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((array + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))))) {
			return noInlineTemporaryinput(index - 1, frameOfMarriedContext(array), value);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(array, GIV(youngStart))) {
				possibleRootStoreIntovalue(array, value);
			}
			longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l13;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			signedValueToStore = (value >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l13;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l13;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l13:	/* end subscript:with:storing:format: */;
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
	return value;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#storeInteger:ofObject:withValue: */
sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((sqInt)((((usqInt)integerValue)) ^ ((((usqInt)integerValue)) << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), (((usqInt)integerValue << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

	/* StackInterpreter>>#storeSenderOfFrame:withValue: */
static char * NoDbgRegParms
storeSenderOfFramewithValue(char *theFP, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    int onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;

	if ((longAt(theFP + FoxSavedFP)) == 0) {
		/* begin frameCallerContext:put: */
		longAtput(theFP + FoxCallerContext, anOop);
		return theFP;
	}
	/* begin ensureCallerContext: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		longAt(theFP + FoxCallerContext);
		goto l4;
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP)));
		longAt(callerFP + FoxThisContext);
		goto l4;
	}
	marryFrameSP(callerFP, (assert(!(isBaseFrame(theFP))),
	(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord));
l4:	/* end ensureCallerContext: */;
	/* begin stackPageFor: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (!onCurrentPage) {

		/* Make sure the frame's page isn't divorced when a new page is allocated. */
		markStackPageNextMostRecentlyUsed(thePage);
	}
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l2:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		assert(newPage != 0);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
	}
	else {
		markStackPageMostRecentlyUsed(newPage);
	}
	assert(isBaseFrame(theMovedFP));
	/* begin frameCallerContext:put: */
	longAtput(theMovedFP + FoxCallerContext, anOop);
	return theMovedFP;
}


/*	Return the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not a SmallInteger! */

	/* StackInterpreter>>#stSizeOf: */
sqInt
stSizeOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt oop1;
    sqInt sz;
    sqInt totalLength;

	/* begin baseHeader: */
	hdr = longAt(oop);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l3;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l3:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l5;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l5;
	}
	if (((ccIndex = (((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(oop - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l5:	/* end fixedFieldsOf:format:length: */;
	if (fmt == (indexablePointersFormat())) {
		assert(!(isContextHeader(hdr)));
	}
	return totalLength - fixedFields;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
sqInt
superclassOf(sqInt classPointer)
{
	return longAt((classPointer + BaseHeaderSize) + (((int)((usqInt)(SuperclassIndex) << (shiftForWord())))));
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted. */

	/* StackInterpreter>>#synchronousSignal: */
static sqInt NoDbgRegParms
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt excessSignals;

	if ((assert(!(isForwarded(aSemaphore))),
	(longAt((aSemaphore + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {

		/* no process is waiting on this semaphore */
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)((((usqInt)(excessSignals + 1))) ^ ((((usqInt)(excessSignals + 1))) << 1)))) >= 0) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			longAtput((aSemaphore + BaseHeaderSize) + (((int)((usqInt)(ExcessSignalsIndex) << (shiftForWord())))), (((usqInt)(excessSignals + 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		return 0;
	}
	return resumepreemptedYieldingIf(removeFirstLinkOfList(aSemaphore), GIV(preemptionYields));
}

	/* StackInterpreter>>#tempCountOf: */
sqInt
tempCountOf(sqInt methodPointer)
{
	/* begin temporaryCountOfMethodHeader: */
	return (((usqInt) ((assert(isCompiledMethod(methodPointer)),
	longAt((methodPointer + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
sqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> MethodHeaderTempCountShift) & 0x3F;
}


/*	Record a process to be awoken on the next interpreter cycle. */

	/* StackInterpreter>>#transferTo: */
static void NoDbgRegParms
transferTo(sqInt newProc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt aMethodObj;
    sqInt index;
    StackPage *lastUsedPage;
    usqInt lip;
    StackPage *lruOrFree;
    sqInt newContext;
    StackPage *newPage;
    sqInt oldProc;
    sqInt sched;
    sqInt senderOop;
    char *sp;
    char *theFrame;
    StackPage *thePage;
    sqInt top;
    sqInt valuePointer;
    sqInt valuePointer1;

	GIV(statProcessSwitch) += 1;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin assertValidExecutionPointe:r:s: */
	lip = GIV(instructionPointer) + 1;
	assertValidExecutionPointersimbarline(lip, GIV(framePointer), GIV(stackPointer), !0, __LINE__);
	/* begin fetchPointer:ofObject: */
	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	oldProc = longAt((sched + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(oldProc, GIV(youngStart))) {
		possibleRootStoreIntovalue(oldProc, activeContext);
	}
	longAtput((oldProc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(sched, GIV(youngStart))) {
		possibleRootStoreIntovalue(sched, newProc);
	}
	longAtput((sched + BaseHeaderSize) + (((int)((usqInt)(ActiveProcessIndex) << (shiftForWord())))), newProc);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = GIV(nilObj);
	longAtput((newProc + BaseHeaderSize) + (((int)((usqInt)(MyListIndex) << (shiftForWord())))), valuePointer);
	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	newContext = longAt((newProc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	assert(isContext(newContext));
	if (((longAt((newContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer)));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = GIV(nilObj);
	longAtput((newProc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), valuePointer1);
	if ((((longAt((newContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(newContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((newContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFrame = pointerForOop(senderOop - 1);

		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (theFrame != ((thePage->headFP))) {

			/* explicit assignment of suspendedContext can cause switch to interior frame. */
			/* begin newStackPage */
			lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
			if (((lruOrFree->baseFP)) == 0) {
				newPage = lruOrFree;
				goto l9;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
		l9:	/* end newStackPage */;
			moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFrame, thePage), newPage);
			/* begin markStackPageLeastMostRecentlyUsed: */
			assert(newPage == ((GIV(mostRecentlyUsedPage)->nextPage)));
			lastUsedPage = (newPage->nextPage);
			while (((lastUsedPage->baseFP)) == 0) {
				lastUsedPage = (lastUsedPage->nextPage);
			}
			if (((lastUsedPage->nextPage)) == newPage) {
				goto l11;
			}
			(((newPage->prevPage))->nextPage = (newPage->nextPage));
			(((newPage->nextPage))->prevPage = (newPage->prevPage));
			(((lastUsedPage->prevPage))->nextPage = newPage);
			(newPage->prevPage = (lastUsedPage->prevPage));
			(newPage->nextPage = lastUsedPage);
			(lastUsedPage->prevPage = newPage);
			assert(pageListIsWellFormed());
		l11:	/* end markStackPageLeastMostRecentlyUsed: */;
		}
		assert(((thePage->headFP)) == theFrame);
	}
	else {
		thePage = makeBaseFrameFor(newContext);
		theFrame = (thePage->baseFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin setMethod: */
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__);
}

	/* StackInterpreter>>#ultimateLiteralOf: */
sqInt
ultimateLiteralOf(sqInt aMethodOop)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop));
	/* begin literal:ofMethod: */
	offset = ((assert((((assert(isCompiledMethod(aMethodOop)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
((((int) ((assert(isCompiledMethod(aMethodOop)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
		? ((((assert(isCompiledMethod(aMethodOop)),
/* begin fetchPointer:ofObject: */
longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) ((assert(isCompiledMethod(aMethodOop)),
			/* begin fetchPointer:ofObject: */
			longAt((aMethodOop + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) - 1;
	return longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

	/* StackInterpreter>>#updateStateOfSpouseContextForFrame:WithSP: */
static void NoDbgRegParms
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *pointer;
    sqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP));
	/* begin frameContext: */
	theContext = longAt(theFP + FoxThisContext);
	assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));
	/* begin frameNumArgs: */
	tempIndex = byteAt((theFP + FoxFrameFlags) + 1);
	pointer = theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(tempIndex) << (shiftForWord())))));
	for (i = 1; i <= tempIndex; i += 1) {
		pointer -= BytesPerWord;
		assert(addressCouldBeOop(longAt(pointer)));
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(theContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(theContext, longAt(pointer));
		}
		longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), longAt(pointer));
	}
	pointer = (theFP + FoxReceiver) - BytesPerWord;
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer)));
		tempIndex += 1;
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(theContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(theContext, longAt(pointer));
		}
		longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)((ReceiverIndex + tempIndex)) << (shiftForWord())))), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)tempIndex << 1) | 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */

	/* StackInterpreter>>#validInstructionPointer:inFrame: */
static sqInt NoDbgRegParms
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp)
{
	return (anInstrPointer >= ((((longAt(fp + FoxMethod)) + (lastPointerOf(longAt(fp + FoxMethod)))) + BytesPerOop) - 1))
	 && (anInstrPointer < ((((longAt(fp + FoxMethod)) + (numBytesOfBytes(longAt(fp + FoxMethod)))) + BaseHeaderSize) - 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */
/*	-1 for pre-increment in fetchNextBytecode */

	/* StackInterpreter>>#validInstructionPointer:inMethod:framePointer: */
sqInt
validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp)
{
	return (theInstrPointer >= (((aMethod + (lastPointerOf(aMethod))) + BytesPerOop) - 1))
	 && (theInstrPointer < (((aMethod + (numBytesOfBytes(aMethod))) + BaseHeaderSize) - 1));
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

	/* StackInterpreter>>#validStackPageBaseFrames */
static sqInt
validStackPageBaseFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			if (!(validStackPageBaseFrame(aPage))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Check that the base frame in the stack page has a valid sender context. */

	/* StackInterpreter>>#validStackPageBaseFrame: */
static sqInt NoDbgRegParms
validStackPageBaseFrame(StackPage *aPage)
{
    sqInt senderContextOrNil;
    char *theFP;

	if (!(asserta(isBaseFrame((aPage->baseFP))))) {
		return 0;
	}
	/* begin frameCallerContext: */
	theFP = (aPage->baseFP);
	senderContextOrNil = longAt(theFP + FoxCallerContext);
	if (!(asserta(addressCouldBeObj(senderContextOrNil)))) {
		return 0;
	}
	if (!(asserta((senderContextOrNil == (nilObject()))
		 || (isContext(senderContextOrNil))))) {
		return 0;
	}
	return 1;
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

	/* StackInterpreter>>#voidLongRunningPrimitive: */
static void NoDbgRegParms
voidLongRunningPrimitive(char *reason)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveCheckSequenceNumber) == 0;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence();
}


/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */

	/* StackInterpreter>>#voidVMStateForSnapshotFlushingExternalPrimitivesIf: */
static sqInt NoDbgRegParms
voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt chunk;
    sqInt fmt;
    sqInt header;
    sqInt obj;
    sqInt oop;
    sqInt sz;

	activeContext = divorceAllFrames();
	/* begin bereaveAllMarriedContextsForSnapshotFlushingExternalPrimitivesIf: */
	chunk = startOfMemory();
	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			/* begin formatOf: */
			fmt = (((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15;
			if ((fmt == (indexablePointersFormat()))
			 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
				makeContextSnapshotSafe(oop);
			}
			if (flushExtPrims
			 && (fmt >= (firstCompiledMethodFormat()))) {
				flushExternalPrimitiveOf(oop);
			}

		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return activeContext;
}


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

	/* StackInterpreter>>#wakeHighestPriority */
static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt header;
    sqInt oop;
    sqInt p;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;
    sqInt sz;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin fetchPointer:ofObject: */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((int)((usqInt)(ValueIndex) << (shiftForWord())))));
	schedLists = longAt((oop + BaseHeaderSize) + (((int)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	if (GIV(highestRunnableProcessPriority) == 0) {
		/* begin numSlotsOf: */
		header = longAt(schedLists);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(schedLists - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		p = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	}
	else {
		p = GIV(highestRunnableProcessPriority);
	}
	while (((p -= 1)) >= 0) {
		processList = longAt((schedLists + BaseHeaderSize) + (((sqInt)((usqInt)(p) << (shiftForWord())))));
		while (!((assert(!(isForwarded(processList))),
		(longAt((processList + BaseHeaderSize) + (((int)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)))) {

			/* Only answer processes with a runnable suspendedContext.
			   Discard those that aren't; the VM would crash otherwise. */
			proc = removeFirstLinkOfList(processList);
			ctxt = longAt((proc + BaseHeaderSize) + (((int)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
			if (isLiveContext(ctxt)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			warning("evicted zombie process from run queue");
		}
	}
	error("scheduler could not find a runnable process");
	return null;
}

	/* StackInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *where;

	/* begin whereIsMaybeHeapThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, startOfMemory(), GIV(endOfMemory))) {
		if (oopisLessThan(anOop, GIV(freeStart))) {
			where = " is in old space";
			goto l1;
		}
		if (oopisLessThan(anOop, GIV(reserveStart))) {
			where = " is in new space";
			goto l1;
		}
		where = " is above reserve start";
		goto l1;
	}
	where = null;
l1:	/* end whereIsMaybeHeapThing: */;
	if (!(where == null)) {
		return where;
	}
	/* begin whereIsMaybeStackThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(stackMemory), GIV(pages))) {
		where = " is in the stack zone";
		goto l2;
	}
	where = null;
l2:	/* end whereIsMaybeStackThing: */;
	if (!(where == null)) {
		return where;
	}
	return " is no where obvious";
}


/*	Return the given 64-bit integer with its halves in the reverse order. */

	/* StackInterpreter>>#wordSwapped: */
static usqLong NoDbgRegParms
wordSwapped(sqInt w)
{
	error("This cannot happen.");

	return ((((usqInt) w) >> 32) & 0xFFFFFFFFU) | ((((sqInt)((usqInt)(w) << 32))) & 0xFFFFFFFF00000000ULL);
}


/*	Write the image header and heap contents to imageFile for snapshot. c.f.
	writeImageFileIOSimulation. The game below is to maintain 64-bit alignment
	for all putLong:toFile: occurrences. */

	/* StackInterpreter>>#writeImageFileIO */
static sqInt NeverInline
writeImageFileIO(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    int headerSize;
    squeakFileOffsetType headerStart;
    sqInt imageBytes;
    extern char imageName[];
    sqInt okToWrite;
    void *sCWIfn;

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!okToWrite) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */
	headerSize = 64;
	f = sqImageFileOpen(imageName, "wb");
	if (f == null) {

		/* could not open the image file for writing */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	imageBytes = GIV(freeStart) - (startOfMemory());
	headerStart = sqImageFileStartLocation(f, imageName, headerSize + imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putWord32toFile(6505, f);
	putWord32toFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile(startOfMemory(), f);
	putLongtoFile(GIV(specialObjectsOop), f);
	putLongtoFile(((usqInt) GIV(freeStart)) >> (shiftForWord()), f);
	putLongtoFile(ioScreenSize(), f);
	putLongtoFile((((GIV(fullScreenFlag) + ((VMBIGENDIAN
	? 0
	: 2))) + ((GIV(preemptionYields)
	? 0
	: 16))) + ((GIV(newFinalization)
	? 64
	: 0))) + (((GIV(imageHeaderFlags) | 83) - 83)), f);
	putWord32toFile(extraVMMemory, f);
	putShorttoFile(desiredNumStackPages, f);
	putShorttoFile(GIV(theUnknownShort), f);
	putWord32toFile(desiredEdenBytes, f);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
		? ioGetMaxExtSemTableSize()
		: 0), f);
	putShorttoFile(GIV(the2ndUnknownShort), f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);


	assert((headerStart + headerSize) == (sqImageFilePosition(f)));
	sqImageFileSeek(f, headerStart + headerSize);
	if (GIV(primFailCode)) {

		/* file write or seek failure */
		sqImageFileClose(f);
		return null;
	}
	bytesWritten = sqImageFileWrite(pointerForOop(startOfMemory()), sizeof(char), imageBytes, f);

	/* begin success: */
	if (!(bytesWritten == imageBytes)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f);
	return 0;
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#fieldOrSenderFP:ofContext: */
static sqInt NoDbgRegParms
fieldOrSenderFPofContext(sqInt index, sqInt contextObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderOop;
    char *spouseFP;
    sqInt tempIndex;

	tempIndex = index - CtxtTempFrameStart;
	if (!((((longAt((contextObj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(contextObj))))) {
		return (tempIndex >= (fetchStackPointerOf(contextObj))
			? (/* begin nilObject */
				GIV(nilObj))
			: longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord()))))));
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((contextObj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1);

	if (tempIndex >= (stackPointerIndexForFrame(spouseFP))) {
		/* begin nilObject */
		return GIV(nilObj);
	}
	return fieldofFrame(index, spouseFP);
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#field:ofFrame: */
static sqInt NoDbgRegParms
fieldofFrame(sqInt index, char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;
    sqInt numArgs;

	
	switch (index) {
	case SenderIndex:
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		return (callerFP == 0
			? (/* begin frameCallerContext: */
				longAt(theFP + FoxCallerContext))
			: ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0
					? (assert(checkIsStillMarriedContextcurrentFP(frameContext(callerFP), null)),
						/* begin frameContext: */
						longAt(callerFP + FoxThisContext))
					: ((sqInt)callerFP)));

	case StackPointerIndex:
	case InstructionPointerIndex:
		return ConstZero;

	case MethodIndex:
		/* begin frameMethodObject: */
		return longAt(theFP + FoxMethod);

	case ClosureIndex:
		return ((byteAt((theFP + FoxFrameFlags) + 3)) != 0
			? (/* begin frameStackedReceiver:numArgs: */
				(numArgs = byteAt((theFP + FoxFrameFlags) + 1)),
				longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord())))))))
			: (/* begin nilObject */
				GIV(nilObj)));

	case ReceiverIndex:
		/* begin frameReceiver: */
		return longAt(theFP + FoxReceiver);

	default:
		assert((((index - CtxtTempFrameStart) >= 0) && ((index - CtxtTempFrameStart) <= (stackPointerIndexForFrame(theFP)))));
		/* begin temporary:in: */
		return ((index - CtxtTempFrameStart) < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
			? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord))
			: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord)));

	}
}

	/* StackInterpreterPrimitives>>#isAppropriateForCopyObject: */
static sqInt NoDbgRegParms
isAppropriateForCopyObject(sqInt oop)
{
	if (!(((((usqInt) (longAt(oop))) >> (instFormatFieldLSB())) & 15) <= 4)) {
		return 0;
	}
	if (((oop & 1) == 0)
	 && (((((usqInt) (longAt(oop))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		return !((((longAt((oop + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(oop))));
	}
	return 1;
}


/*	Return a shallow copy of the receiver.
	Special-case non-single contexts (because of context-to-stack mapping).
	Can't fail for contexts cuz of image context instantiation code (sigh). */

	/* StackInterpreterPrimitives>>#primitiveClone */
static void
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cloned;
    sqInt frameNumArgs;
    sqInt header;
    sqInt i;
    sqInt newCopy;
    sqInt rcvr;
    sqInt senderOop;
    char *sp;
    sqInt sp1;
    char *spouseFP;
    sqInt sz;
    sqInt sz1;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	/* begin stackTop */
	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		newCopy = rcvr;
	}
	else {
		if (((((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
			/* begin cloneContext: */
			header = longAt(rcvr);
			sz1 = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask
				: header & SizeMask);
			sz = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
			cloned = eeInstantiateMethodContextSlots(sz);
			if (cloned != 0) {
				for (i = 0; i <= StackPointerIndex; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer = externalInstVarofContext(i, rcvr);
					longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
				}
				for (i = MethodIndex; i <= ReceiverIndex; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					valuePointer1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
					longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer1);
				}
				if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 && (!(isWidowedContext(rcvr)))) {
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					spouseFP = pointerForOop(senderOop - 1);

					sp1 = (stackPointerIndexForFrame(spouseFP)) - 1;
					for (i = 0; i <= sp1; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer2 = (i < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
							? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - i) * BytesPerWord))
							: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - i) * BytesPerWord)));
						longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))), valuePointer2);
					}
				}
				else {
					sp1 = (fetchStackPointerOf(rcvr)) - 1;
					for (i = 0; i <= sp1; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						valuePointer3 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))));
						longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))), valuePointer3);
					}
				}
			}
			newCopy = cloned;
		}
		else {
			if ((GIV(argumentCount) == 0)
			 || (!(isForwarded(rcvr)))) {
				newCopy = clone(rcvr);
			}
			else {
				newCopy = 0;
			}
		}
		if (newCopy == 0) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveClosureCopyWithCopiedValues */
static void
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt copiedValues;
    sqInt header;
    sqInt i;
    sqInt initialIP;
    sqInt integerPointer;
    sqInt newClosure;
    sqInt newClosure1;
    sqInt numArgs;
    sqInt numCopied;
    char *sp;
    sqInt sz;
    sqInt valuePointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		numArgs = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		numArgs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin closureIn:numArgs:instructionPointer:copiedValues: */
	context = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	initialIP = (GIV(instructionPointer) + 2) - (GIV(method) + BaseHeaderSize);
	copiedValues = longAt(GIV(stackPointer));
	/* begin numSlotsOf: */
	header = longAt(copiedValues);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(copiedValues - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	numCopied = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	newClosure1 = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)initialIP << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure1 + BaseHeaderSize) + (((int)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
	for (i = 0; i < numCopied; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = longAt((copiedValues + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), valuePointer);
	}
	newClosure = newClosure1;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newClosure);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveAt for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAt */
static void
primitiveContextAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt frameNumArgs;
    sqInt hdr;
    sqInt hdr1;
    sqInt index;
    unsigned int integerValue;
    unsigned int integerValue1;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    sqInt oop1;
    sqInt oop11;
    sqInt reasonCode;
    sqInt senderOop;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;
    sqInt valueWord1;
    sqInt valueWord11;

	/* begin stackTop */
	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 1);
	/* begin stackValue: */
	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin baseHeader: */
	hdr = longAt(aContext);
	if (!(((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at: */
		hdr1 = longAt(aContext);
		/* begin formatOfHeader: */
		fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz1 = hdr1 & SizeMask;
		}
		sz1 -= hdr1 & Size4Bit;
		if (fmt1 <= 4) {
			totalLength1 = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
			goto l25;
		}
		totalLength1 = (fmt1 < (firstByteFormat())
			? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
			: (sz1 - BaseHeaderSize) - (fmt1 & 3));
	l25:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 > 4)
		 || (fmt1 == 2)) {
			fixedFields1 = 0;
			goto l18;
		}
		if (fmt1 < 2) {
			fixedFields1 = totalLength1;
			goto l18;
		}
		if (((ccIndex1 = (((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			class1 = (longAt(aContext - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			class1 = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
		}
		classFormat1 = (longAt((class1 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields1 = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 0x3F)) - 1;
	l18:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat()))
		 && (((((usqInt) hdr1) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 1))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l19;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp11 & 1))) {
				stSize1 = 0;
				goto l19;
			}
			assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 1);
		l19:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSize1))
			 && ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))))) {
				value = noInlineTemporaryin(index - 1, frameOfMarriedContext(aContext));
				goto l28;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
			? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
		 && (oopisLessThanOrEqualTo(index, stSize1))) {
			/* begin subscript:with:format: */
			if (fmt1 <= 4) {
				value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))));
				goto l28;
			}
			if (fmt1 >= (firstByteFormat())) {
				value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1))) << 1) | 1);
				goto l28;
			}
			/* begin positive32BitIntegerFor: */
			integerValue1 = long32At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))));
			/* begin maybeInlinePositive32BitIntegerFor: */
			assert(!((hasSixtyFourBitImmediates())));
			if ((((unsigned int) integerValue1)) <= (MaxSmallInteger)) {
				value = ((integerValue1 << 1) | 1);
				goto l28;
			}
			newLargeInteger1 = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
			/* begin storeLong32:ofObject:withValue: */
			valueWord11 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue1);
			long32Atput((newLargeInteger1 + BaseHeaderSize) + (0U << 2), valueWord11);

			value = newLargeInteger1;
			goto l28;

		}
		/* begin primitiveFailFor: */
		reasonCode = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
		value = 0;
	l28:	/* end stObject:at: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		/* begin formatOfHeader: */
		fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
			goto l11;
		}
		totalLength = (fmt < (firstByteFormat())
			? ((usqInt) (sz - BaseHeaderSize)) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
	l11:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l13;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l13;
		}
		if (((ccIndex = (((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			class = (longAt(aContext - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
		classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
	l13:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(aContext)));
		stSize = (sp1 >> 1);
	l4:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l17;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l17;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			value = ((integerValue << 1) | 1);
			goto l17;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		value = newLargeInteger;
		goto l17;

	l17:	/* end subscript:with:format: */;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1);

	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin temporary:in: */
	value = ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
		? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord))
		: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)));
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveAtPut for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAtPut */
static void
primitiveContextAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt class;
    sqInt class1;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt frameNumArgs;
    sqInt hdr;
    sqInt hdr1;
    sqInt index;
    sqInt oop1;
    sqInt oop11;
    sqInt reasonCode;
    sqInt senderOop;
    sqInt signedValueToStore;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;
    sqInt totalLength1;
    unsigned int unsignedValueToStore;
    unsigned int unsignedValueToStore1;
    sqInt value;

	/* begin stackTop */
	value = longAt(GIV(stackPointer));
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackValue: */
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin baseHeader: */
	hdr = longAt(aContext);
	index = (index >> 1);
	if (!(((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at:put: */
		hdr1 = longAt(aContext);
		/* begin formatOfHeader: */
		fmt1 = (((usqInt) hdr1) >> (instFormatFieldLSB())) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz1 = hdr1 & SizeMask;
		}
		sz1 -= hdr1 & Size4Bit;
		if (fmt1 <= 4) {
			totalLength1 = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
			goto l30;
		}
		totalLength1 = (fmt1 < (firstByteFormat())
			? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
			: (sz1 - BaseHeaderSize) - (fmt1 & 3));
	l30:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 > 4)
		 || (fmt1 == 2)) {
			fixedFields1 = 0;
			goto l21;
		}
		if (fmt1 < 2) {
			fixedFields1 = totalLength1;
			goto l21;
		}
		if (((ccIndex1 = (((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			class1 = (longAt(aContext - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop11 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			class1 = longAt((oop11 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex1 - 1)) << (shiftForWord())))));
		}
		classFormat1 = (longAt((class1 + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields1 = (((((usqInt) classFormat1) >> 11) & 192) + ((((usqInt) classFormat1) >> 2) & 0x3F)) - 1;
	l21:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat()))
		 && (((((usqInt) hdr1) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 1))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l22;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp11 & 1))) {
				stSize1 = 0;
				goto l22;
			}
			assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 1);
		l22:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSize1))
			 && ((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))))) {
				noInlineTemporaryinput(index - 1, frameOfMarriedContext(aContext), value);
				goto l34;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
			? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
		 && (oopisLessThanOrEqualTo(index, stSize1))) {
			/* begin subscript:with:storing:format: */
			if (fmt1 <= 4) {
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(aContext, GIV(youngStart))) {
					possibleRootStoreIntovalue(aContext, value);
				}
				longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))), value);
				goto l33;
			}
			if (fmt1 >= (firstByteFormat())) {
				if (!((value & 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l33;
				}
				signedValueToStore1 = (value >> 1);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l33;
				}
				/* begin storeByte:ofObject:withValue: */
				byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
				goto l33;
			}
			unsignedValueToStore1 = positive32BitValueOf(value);
			if (!GIV(primFailCode)) {
				/* begin storeLong32:ofObject:withValue: */
				long32Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
			}
		l33:	/* end subscript:with:storing:format: */;
		}
		else {
			/* begin primitiveFailFor: */
			reasonCode = (fmt1 <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
			GIV(primFailCode) = reasonCode;
		}
	l34:	/* end stObject:at:put: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		/* begin formatOfHeader: */
		fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
		/* begin lengthOf:baseHeader:format: */
		if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = hdr & SizeMask;
		}
		sz -= hdr & Size4Bit;
		if (fmt <= 4) {
			totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
			goto l12;
		}
		totalLength = (fmt < (firstByteFormat())
			? ((usqInt) (sz - BaseHeaderSize)) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
	l12:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l14;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l14;
		}
		if (((ccIndex = (((usqInt) (longAt(aContext))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			class = (longAt(aContext - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
			class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
		classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
	l14:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(aContext)));
		stSize = (sp1 >> 1);
	l4:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:storing:format: */
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(aContext, GIV(youngStart))) {
				possibleRootStoreIntovalue(aContext, value);
			}
			longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l20;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l20;
			}
			signedValueToStore = (value >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l20;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l20;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l20:	/* end subscript:with:storing:format: */;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1);

	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin temporary:in:put: */
	if ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))) {
		longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	else {
		longAtput(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveSize for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextSize */
static void
primitiveContextSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt sz1;
    sqInt totalLength;

	/* begin stackTop */
	rcvr = longAt(GIV(stackPointer));
	/* begin baseHeader: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = hdr & SizeMask;
	}
	sz1 -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			sz = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((sp1 & 1))) {
			sz = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		sz = (sp1 >> 1);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)sz << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

	/* StackInterpreterPrimitives>>#primitiveContextXray */
static void
primitiveContextXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    char *sp;

	/* begin stackTop */
	context = longAt(GIV(stackPointer));
	if (((longAt((context + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer))) {
			flags = 3;
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)flags << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

	/* StackInterpreterPrimitives>>#primitiveDeferDisplayUpdates */
static void
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	/* begin stackTop */
	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

	/* StackInterpreterPrimitives>>#primitiveDoNamedPrimitiveWithArgs */
static void
primitiveDoNamedPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    sqInt arraySize;
    sqInt ccIndex;
    sqInt classOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt index;
    sqInt isArray;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt primBits;
    sqInt primRcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt spec;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt sz;
    sqInt sz1;
    sqInt sz2;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	/* begin stackTop */
	argumentArray = longAt(GIV(stackPointer));
	/* begin stackValue: */
	methodArg = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((methodArg & 1) == 0)
		 && (((((usqInt) (longAt(methodArg))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -2);
		return;
	}
	assert(isCompiledMethod(methodArg));
	methodHeader = longAt((methodArg + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	if (!(((assert((methodHeader & 1)),
		((((int) methodHeader)) < 0
				? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt) methodHeader) >> 10) & 0xFF))) > 2)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -3);
		return;
	}

	/* first literal */
	spec = longAt((methodArg + BaseHeaderSize) + (1U << (shiftForWord())));
	/* begin is:instanceOf:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord())))));
	if ((spec & 1)) {
		isArray = 0;
		goto l16;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((spec & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(spec))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		isArray = ((longAt(spec - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l16;
	}
	isArray = ClassArrayCompactIndex == ccIndex;
	goto l16;

	isArray = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l16:	/* end is:instanceOf:compactClassIndex: */;
	if (!(isArray
		 && (((numSlotsOf(spec)) == 4)
		 && ((((primBits = (methodHeader >> 1)),
		(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == PrimNumberExternalCall)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -3);
		return;
	}
	if (!(((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) == arraySize)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -2);
		return;
	}
	moduleName = longAt((spec + BaseHeaderSize) + (0U << (shiftForWord())));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		/* begin success: */
		successBoolean = ((moduleName & 1) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()));
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin lengthOf: */
		header1 = longAt(moduleName);
		/* begin lengthOf:baseHeader:format: */
		fmt = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
		if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
			sz1 = (longAt(moduleName - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz1 = header1 & SizeMask;
		}
		sz1 -= header1 & Size4Bit;
		if (fmt <= 4) {
			moduleLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
			goto l20;
		}
		moduleLength = (fmt < (firstByteFormat())
			? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
			: (sz1 - BaseHeaderSize) - (fmt & 3));
	l20:	/* end lengthOf: */;
	}
	functionName = longAt((spec + BaseHeaderSize) + (1U << (shiftForWord())));
	/* begin success: */
	successBoolean1 = ((functionName & 1) == 0)
	 && (((((usqInt) (longAt(functionName))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin lengthOf: */
	header2 = longAt(functionName);
	/* begin lengthOf:baseHeader:format: */
	fmt1 = (((usqInt) header2) >> (instFormatFieldLSB())) & 15;
	if ((header2 & TypeMask) == HeaderTypeSizeAndClass) {
		sz2 = (longAt(functionName - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz2 = header2 & SizeMask;
	}
	sz2 -= header2 & Size4Bit;
	if (fmt1 <= 4) {
		functionLength = ((usqInt) (sz2 - BaseHeaderSize)) >> (shiftForWord());
		goto l22;
	}
	functionLength = (fmt1 < (firstByteFormat())
		? ((usqInt) (sz2 - BaseHeaderSize)) >> 2
		: (sz2 - BaseHeaderSize) - (fmt1 & 3));
l22:	/* end lengthOf: */;
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -3);
		return;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -1);
		return;
	}
	GIV(tempOop) = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, 2, 4);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (argumentArray = popStack());
	longAtput((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer1 = (primRcvr = popStack());
	longAtput((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer2 = top;
	longAtput((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer3 = top1;
	longAtput((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord())), valuePointer3);
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), primRcvr);
	GIV(stackPointer) = sp5;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		object = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	/* begin callExternalPrimitive: */
	dispatchFunctionPointer(addr);
	/* begin maybeFailForLastObjectOverwrite */
	if (checkAllocFiller) {
		if (((freeStart()) < GIV(scavengeThreshold))
		 && ((longAt(freeStart())) != (freeStart()))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrWritePastObject;
		}
	}

	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin push: */
		object1 = longAt((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord())));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = longAt((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord())));
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp2;
		/* begin push: */
		object3 = longAt((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord())));
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
		GIV(stackPointer) = sp3;
		/* begin push: */
		object4 = longAt((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord())));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
		GIV(stackPointer) = sp4;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(argumentCount) = 3;
		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}


/*	Implement either ProtoObject>>tryPrimitive: primIndex withArgs: argArray
	or Context>>receiver: anObject tryPrimitive: primIndex withArgs: argArray.
	If this primitive fails, arrange that its error code is a negative
	integer, to
	distinguish between this failing and the primitive it invokes failing. */

	/* StackInterpreterPrimitives>>#primitiveDoPrimitiveWithArgs */
static void
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt arraySize;
    sqInt header;
    sqInt index;
    sqInt object;
    sqInt primIdx;
    sqInt rcvr;
    sqInt savedNumArgs;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    sqInt sz;

	if (!(((GIV(argumentCount) >= 2) && (GIV(argumentCount) <= 3)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrUnsupported);
		return;
	}
	/* begin stackTop */
	argumentArray = longAt(GIV(stackPointer));
	/* begin stackValue: */
	primIdx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((primIdx & 1)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrBadArgument);
		return;
	}
	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = ((header & TypeMask) == HeaderTypeSizeAndClass
		? (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask
		: header & SizeMask);
	arraySize = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrLimitExceeded);
		return;
	}
	primIdx = (primIdx >> 1);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIdx])));
	if (primitiveFunctionPointer == 0) {
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = -PrimErrBadIndex);
		return;
	}
	if (((savedNumArgs = GIV(argumentCount))) == 3) {

		/* ...and receiver if the three arg form */
		/* begin stackValue: */
		GIV(tempOop2) = longAt(GIV(stackPointer) + (4 * BytesPerWord));
		/* begin stackValue: */
		rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= GIV(argumentCount)) {
		/* begin push: */
		object = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp1;
		index += 1;
	}
	if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		GIV(tempOop2) = 0;
		return;
	}

	/* prim might alloc/gc */
	/* Run the primitive (sets primFailCode) */
	GIV(tempOop) = argumentArray;
	/* begin slowPrimitiveResponse */
	assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
	assert((remapBufferCount()) == 0);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
	/* begin maybeRetryPrimitiveOnFailure */
	/* begin maybeFailForLastObjectOverwrite */
	if (checkAllocFiller) {
		if (((freeStart()) < GIV(scavengeThreshold))
		 && ((longAt(freeStart())) != (freeStart()))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrWritePastObject;
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	/* begin successful */
	!GIV(primFailCode);

	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		if (savedNumArgs == 3) {
			/* begin stackTop */
			rcvr = longAt(GIV(stackPointer));
			/* begin stackTopPut: */
			longAtPointerput(GIV(stackPointer), GIV(tempOop2));
			/* begin push: */
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
			GIV(stackPointer) = sp2;
		}
		/* begin pushInteger: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), (((usqInt)primIdx << 1) | 1));
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(tempOop));
		GIV(stackPointer) = sp3;
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		GIV(argumentCount) = savedNumArgs;
	}
	GIV(tempOop) = (GIV(tempOop2) = 0);
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethod */
static void
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt table;
    sqInt top;

	/* begin stackTop */
	methodArgument = longAt(GIV(stackPointer));
	if (!(((methodArgument & 1) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (!((GIV(argumentCount) - 1) == (argumentCountOf(methodArgument)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) -= 1;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l15;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
		/* begin maybeRetryPrimitiveOnFailure */
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l15;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader1 & 1)),
((((int) methodHeader1)) < 0
		? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader1) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l9;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l9:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader2 = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2));
	}
l15:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethodArgsArray */
static void
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt errorCode;
    sqInt header;
    sqInt i;
    sqInt i1;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    sqInt rcvr1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	/* begin stackTop */
	methodArgument = longAt(GIV(stackPointer));
	/* begin stackValue: */
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((methodArgument & 1) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
		 && (((argumentArray & 1) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (instFormatFieldLSB())) & 15) == 2)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	/* begin argumentCountOf: */
	assert(isCompiledMethod(methodArgument));
	header = longAt((methodArgument + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	argCnt = (((usqInt) header) >> MethodHeaderArgCountShift) & 15;
	if (!(argCnt == (numSlotsOf(argumentArray)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	if (GIV(argumentCount) > 2) {

		/* CompiledMethod class>>receiver:withArguments:executeMethod:
		   SqueakObjectPrimitives class>>receiver:withArguments:apply:
		   VMMirror>>ifFail:object:with:executeMethod: et al */
		/* begin stackValue: */
		rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		if ((GIV(argumentCount) > 4)
		 || (0)) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	for (i = 0; i < argCnt; i += 1) {
		/* begin push: */
		object = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512);


	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = argCnt;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l19;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
		/* begin maybeRetryPrimitiveOnFailure */
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l19;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	/* begin push: */
	object1 = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader1 & 1)),
((((int) methodHeader1)) < 0
		? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader1) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l12;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l12:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader2 = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader2));
	}
l19:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol)
	* The function name (String | Symbol)
	* The session ID (SmallInteger) [OBSOLETE], or in Spur, the accessorDepth
	(Integer) * The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:.
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */

	/* StackInterpreterPrimitives>>#primitiveExternalCall */
static void
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt header1;
    sqInt i1;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt sz;
    sqInt sz1;


	/* Check for it being a method for primitiveDoPrimitiveWithArgs.
	   Fetch the first literal of the method; check its an Array of length 4.
	   Look at the function index in case it has been loaded before */
	if (!((((GIV(newMethod) & 1) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
		 && ((((assert((((assert(isCompiledMethod(GIV(newMethod))),
/* begin fetchPointer:ofObject: */
longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) & 1)),
		((((int) ((assert(isCompiledMethod(GIV(newMethod))),
/* begin fetchPointer:ofObject: */
longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) < 0
				? ((((assert(isCompiledMethod(GIV(newMethod))),
/* begin fetchPointer:ofObject: */
longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt) ((assert(isCompiledMethod(GIV(newMethod))),
					/* begin fetchPointer:ofObject: */
					longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))))))) >> 10) & 0xFF))) > 0)
		 && (((lit = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)((0 + LiteralStart)) << (shiftForWord())))))),
		(((lit & 1) == 0)
			 && (((((usqInt) (longAt(lit))) >> (instFormatFieldLSB())) & 15) == 2))
			 && (((numSlotsOf(lit)) == 4)
			 && (((index = longAt((lit + BaseHeaderSize) + (3U << (shiftForWord())))),
			(index & 1))))))))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadMethod);
		return;
	}

	/* Check if we have already looked up the function and failed. */
	index = (index >> 1);
	if (index < 0) {

		/* Function address was not found in this session,
		   Void the primitive function. */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNotFound);
		return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = externalPrimitiveTable[index - 1];
		if (addr != 0) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
			/* begin callExternalPrimitive: */
			dispatchFunctionPointer(addr);
			/* begin maybeFailForLastObjectOverwrite */
			if (checkAllocFiller) {
				if (((freeStart()) < GIV(scavengeThreshold))
				 && ((longAt(freeStart())) != (freeStart()))) {
					/* begin primitiveFailFor: */
					GIV(primFailCode) = PrimErrWritePastObject;
				}
			}
			/* begin maybeRetryPrimitiveOnFailure */
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNamedInternal);
		return;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord())), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord())), ConstZero);
	moduleName = longAt((lit + BaseHeaderSize) + (0U << (shiftForWord())));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(((moduleName & 1) == 0)
			 && (((((usqInt) (longAt(moduleName))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadMethod;
		}
		/* begin lengthOf: */
		header = longAt(moduleName);
		/* begin lengthOf:baseHeader:format: */
		fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
		if ((header & TypeMask) == HeaderTypeSizeAndClass) {
			sz = (longAt(moduleName - (BytesPerWord * 2))) & LongSizeMask;
		}
		else {
			sz = header & SizeMask;
		}
		sz -= header & Size4Bit;
		if (fmt <= 4) {
			moduleLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
			goto l14;
		}
		moduleLength = (fmt < (firstByteFormat())
			? ((usqInt) (sz - BaseHeaderSize)) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
	l14:	/* end lengthOf: */;
	}
	functionName = longAt((lit + BaseHeaderSize) + (1U << (shiftForWord())));
	if (!(((functionName & 1) == 0)
		 && (((((usqInt) (longAt(functionName))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadMethod;
	}
	/* begin lengthOf: */
	header1 = longAt(functionName);
	/* begin lengthOf:baseHeader:format: */
	fmt1 = (((usqInt) header1) >> (instFormatFieldLSB())) & 15;
	if ((header1 & TypeMask) == HeaderTypeSizeAndClass) {
		sz1 = (longAt(functionName - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz1 = header1 & SizeMask;
	}
	sz1 -= header1 & Size4Bit;
	if (fmt1 <= 4) {
		functionLength = ((usqInt) (sz1 - BaseHeaderSize)) >> (shiftForWord());
		goto l16;
	}
	functionLength = (fmt1 < (firstByteFormat())
		? ((usqInt) (sz1 - BaseHeaderSize)) >> 2
		: (sz1 - BaseHeaderSize) - (fmt1 & 3));
l16:	/* end lengthOf: */;
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		index = -1;
	}
	else {

		/* add the function to the external primitive table */
		/* begin addToExternalPrimitiveTable: */
		for (i1 = GIV(externalPrimitiveTableFirstFreeIndex); i1 < MaxExternalPrimitiveTableSize; i1 += 1) {
			if ((externalPrimitiveTable[i1]) == 0) {
				externalPrimitiveTable[i1] = (((void *) addr));
				index = (GIV(externalPrimitiveTableFirstFreeIndex) = i1 + 1);
				goto l5;
			}
		}
		index = 0;
	l5:	/* end addToExternalPrimitiveTable: */;
	}

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord())), (((usqInt)index << 1) | 1));
	if (index >= 0) {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
		/* begin callExternalPrimitive: */
		dispatchFunctionPointer(addr);
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		/* begin maybeRetryPrimitiveOnFailure */
			}
	else {

		/* Otherwise void the primitive function and fail */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		assert((fetchPointerofObject(2, lit)) == ConstZero);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNotFound;
	}
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

	/* StackInterpreterPrimitives>>#primitiveFindHandlerContext */
static void
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(199, longAt(GIV(stackPointer)), GIV(nilObj));
	if (handlerOrNilOrZero == 0) {
		/* begin nilObject */
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

	/* StackInterpreterPrimitives>>#primitiveFindNextUnwindContext */
static void
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt handlerOrNilOrZero;
    sqInt primBits;
    sqInt senderContext;
    sqInt senderOop;
    char *sp;
    sqInt startContext;
    char *startFP;
    sqInt stopContext;
    char *theFP;
    char *theFP1;
    char *theFPAbove;
    sqInt theMethod;
    char *theSP;

	/* begin stackTop */
	stopContext = longAt(GIV(stackPointer));
	/* begin stackValue: */
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (((stopContext & 1) == 0)
		 && (((((usqInt) (longAt(stopContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	assert(stopContext != calleeContext);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((calleeContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(calleeContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((calleeContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1);

		if ((longAt(theFP + FoxSavedFP)) == 0) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, longAt(theFP + FoxCallerContext), stopContext);
		}
		else {
			/* begin findMethodWithPrimitive:FromFP:UpToContext: */
			startFP = pointerForOop(longAt(theFP + FoxSavedFP));
			theFP1 = startFP;
			theFPAbove = startFP;
			do {
				if (((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0)
				 && (stopContext == (longAt(theFP1 + FoxThisContext)))) {
					handlerOrNilOrZero = 0;
					goto l7;
				}
				if (!((byteAt((theFP1 + FoxFrameFlags) + 3)) != 0)) {
					theMethod = longAt(theFP1 + FoxMethod);
					if ((((primBits = (((assert(isCompiledMethod(theMethod)),
longAt((theMethod + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord()))))))) >> 1)),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))) == 198) {
						if (theFP1 == theFPAbove) {
							theSP = findSPOfon(theFP1, stackPageFor(theFP1));
						}
						else {
							assert(!(isBaseFrame(theFPAbove)));
							theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;

						}
						/* begin ensureFrameIsMarried:SP: */
						if ((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(theFP1)));
							handlerOrNilOrZero = longAt(theFP1 + FoxThisContext);
							goto l7;
						}
						handlerOrNilOrZero = marryFrameSP(theFP1, theSP);
						goto l7;
					}
				}
				theFPAbove = theFP1;
				theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
			} while(theFP1 != 0);
			senderContext = longAt(theFPAbove + FoxCallerContext);
			if (!(((senderContext & 1) == 0)
				 && (((((usqInt) (longAt(senderContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
				/* begin nilObject */
				handlerOrNilOrZero = GIV(nilObj);
				goto l7;
			}
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, stopContext);
		l7:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
		}
	}
	else {
		startContext = longAt((calleeContext + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		if (((startContext & 1) == 0)
		 && (((((usqInt) (longAt(startContext))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, startContext, stopContext);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (handlerOrNilOrZero == 0) {
		/* begin nilObject */
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheByMethod */
static void
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt oldMethod;
    sqInt probe;

	/* begin stackTop */
	oldMethod = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	flushExternalPrimitiveOf(oldMethod);
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined.  */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheBySelector */
static void
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;
    sqInt selector;

	/* begin stackTop */
	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (fetchPointerofObject(16 * 2, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))))
	 || (selector == (fetchPointerofObject(17 * 2, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(SpecialSelectors) << (shiftForWord()))))))))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			GIV(atCache)[i1] = 0;
		}
	}
}


/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */
/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */

	/* StackInterpreterPrimitives>>#primitiveFullGC */
static void
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal1;
    char *sp1;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(fullGCLock) > 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	incrementalGC();
	fullGC();
	/* begin pop:thenPushInteger: */
	integerVal1 = ((oopisLessThan(GIV(freeStart), GIV(reserveStart))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(1));
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal1 << 1) | 1));
	GIV(stackPointer) = sp1;
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */
/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

	/* StackInterpreterPrimitives>>#primitiveIncrementalGC */
static void
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	incrementalGC();

	/* begin pop:thenPushInteger: */
	integerVal = ((oopisLessThan(GIV(freeStart), GIV(reserveStart))
	? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
	: 0)) + (sqMemoryExtraBytesLeft(0));
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((usqInt)integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAt */
static void
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt totalLength;
    sqInt value;
    sqInt valueWord1;

	/* begin stackTop */
	index = longAt(GIV(stackPointer));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (0))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	index = (index >> 1);
	/* begin baseHeader: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l5;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l5:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l7;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l7;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 4) {
			value = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
			goto l11;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 1) | 1);
			goto l11;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2))));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			value = ((integerValue << 1) | 1);
			goto l11;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
		/* begin storeLong32:ofObject:withValue: */
		valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
		long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

		value = newLargeInteger;
		goto l11;

	l11:	/* end subscript:with:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAtPut */
static void
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt newValue;
    sqInt oop1;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;

	/* begin stackTop */
	newValue = longAt(GIV(stackPointer));
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (0))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else /* IMMUTABILITY */
		0
#  endif /* IMMUTABILITY */
		) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrNoModification);
		return;
	}
	index = (index >> 1);
	/* begin baseHeader: */
	hdr = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) hdr) >> (instFormatFieldLSB())) & 15;
	/* begin lengthOf:baseHeader:format: */
	if ((hdr & TypeMask) == HeaderTypeSizeAndClass) {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	else {
		sz = hdr & SizeMask;
	}
	sz -= hdr & Size4Bit;
	if (fmt <= 4) {
		totalLength = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		goto l6;
	}
	totalLength = (fmt < (firstByteFormat())
		? ((usqInt) (sz - BaseHeaderSize)) >> 2
		: (sz - BaseHeaderSize) - (fmt & 3));
l6:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l8;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l8;
	}
	if (((ccIndex = (((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
		class = (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask;
	}
	else {
		/* begin fetchPointer:ofObject: */
		oop1 = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))));
		class = longAt((oop1 + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
	}
	classFormat = (longAt((class + BaseHeaderSize) + (((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt) classFormat) >> 11) & 192) + ((((usqInt) classFormat) >> 2) & 0x3F)) - 1;
l8:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt) hdr) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		externalInstVarofContextput(index - 1, rcvr, newValue);
	}
	else {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, newValue);
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))), newValue);
			goto l14;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((newValue & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l14;
			}
			signedValueToStore = (newValue >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l14;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + (index - 1), signedValueToStore);
			goto l14;
		}
		unsignedValueToStore = positive32BitValueOf(newValue);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2))), unsignedValueToStore);
		}
	l14:	/* end subscript:with:storing:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. Since the
	longRunningPrimitiveCheckMethod is
	sampled at interrupt time be careful to validate it before returning it. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitive */
EXPORT(sqInt)
primitiveLongRunningPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong gcms;
    sqInt lrpcm;
    sqLong primms;
    sqInt result;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))) != null)
	 && ((((lrpcm & 3) == 0)
	 && (((((usqInt)lrpcm)) >= (startOfMemory()))
	 && (((((usqInt)lrpcm)) < GIV(freeStart))
	 && (((longAt(lrpcm)) & TypeMask) != HeaderTypeGC))))
	 && ((!(((longAt(lrpcm)) & TypeMask) == HeaderTypeFree))
	 && (((((usqInt) (longAt(lrpcm))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))))) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), 3);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(result, GIV(youngStart))) {
			possibleRootStoreIntovalue(result, lrpcm);
		}
		longAtput((result + BaseHeaderSize) + (0U << (shiftForWord())), lrpcm);
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)primms << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (2U << (shiftForWord())), ((gcms << 1) | 1));
	}
	else {
		/* begin nilObject */
		result = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
	voidLongRunningPrimitive("get");
	return 0;
}


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitiveSemaphore */
EXPORT(sqInt)
primitiveLongRunningPrimitiveSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop;
    sqInt sema;

	/* begin stackValue: */
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((sema & 1))
	 || (GIV(argumentCount) != 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (sema == GIV(nilObj)) {
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		if (!(((sema & 1) == 0)
			 && (((((ccIndex = (((usqInt) (longAt(sema))) >> (compactClassFieldLSB())) & 0x1F)) == 0
				? (longAt(sema - BaseHeaderSize)) & AllButTypeMask
				: (/* begin fetchPointer:ofObject: */
					(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
					longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	voidLongRunningPrimitive("install");
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Works forrectly for cogged methods too. */

	/* StackInterpreterPrimitives>>#primitiveObjectPointsTo */
static void
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt methodHeader;
    sqInt numSlots;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt sz;
    sqInt thang;
    sqInt trueOrFalse;

	/* begin stackTop */
	thang = longAt(GIV(stackPointer));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin baseHeader: */
	header = longAt(rcvr);
	/* begin formatOfHeader: */
	fmt = (((usqInt) header) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt) header) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			if (((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				if ((((longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 && (!(isWidowedContext(rcvr)))) {
					/* begin pop:thenPushBool: */
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2);
					longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (trueOrFalse
						? GIV(trueObj)
						: GIV(falseObj)));
					GIV(stackPointer) = sp1;
					return;
				}
			}
			numSlots = CtxtTempFrameStart + (fetchStackPointerOf(rcvr));
		}
		else {
			/* begin numSlotsOf: */
			header1 = longAt(rcvr);
			sz = ((header1 & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask
				: header1 & SizeMask);
			numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		}
	}
	else {
		if (fmt < (firstCompiledMethodFormat())) {

			/* no pointers */
			/* begin pop:thenPushBool: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
		assert(isCompiledMethod(rcvr));
		methodHeader = longAt((rcvr + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp3;
			return;
		}
		numSlots = ((assert((methodHeader & 1)),
((((int) methodHeader)) < 0
		? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader) >> 10) & 0xFF))) + LiteralStart;
	}
	assert((((numSlots - 1) * BytesPerOop) + BaseHeaderSize) == (lastPointerOf(rcvr)));
	for (i = BaseHeaderSize; i <= (((numSlots - 1) * BytesPerOop) + BaseHeaderSize); i += BytesPerOop) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp4 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp4;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp5 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp5;
}

	/* StackInterpreterPrimitives>>#primitivePerform */
static void
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt newReceiver;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    usqInt performMethod;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt table;

	performMethod = GIV(newMethod);
	/* begin stackValue: */
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	/* begin stackValue: */
	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	if ((newReceiver & 1)) {
		/* begin splObj: */
		lookupClassTag = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
	}
	else {
		if (((ccIndex = (((usqInt) (longAt(newReceiver))) >> (compactClassFieldLSB())) & 0x1F)) == 0) {
			lookupClassTag = (longAt(newReceiver - BaseHeaderSize)) & AllButTypeMask;
		}
		else {
			/* begin fetchPointer:ofObject: */
			lookupClassTag = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))));
		}
	}
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), newReceiver);
	findNewMethodInClassTag(lookupClassTag);
	if (!((((GIV(newMethod) & 1) == 0)
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)))) {

		/* Slide the args back up (sigh) and re-insert the selector. */
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(newMethod) = performMethod;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l15;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
		/* begin maybeRetryPrimitiveOnFailure */
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		/* begin successful */
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l15;
		}
	}
	/* begin activateNewMethod */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((int)((usqInt)(HeaderIndex) << (shiftForWord())))));

	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	/* begin argumentCountOfMethodHeader: */
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((assert((methodHeader1 & 1)),
((((int) methodHeader1)) < 0
		? ((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask
		: (((usqInt) methodHeader1) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & V3PrimitiveBitsMask) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (LongStoreBytecode)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					/* begin splObj: */
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(PrimErrTableIndex) << (shiftForWord())))));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
						goto l9;
					}
				}
				errorCode = (((usqInt)GIV(primFailCode) << 1) | 1);
			l9:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l15:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Pin or unpin the receiver, i.e. make it immobile or mobile, based on the
	argument. Answer whether the object was already pinned. N.B. pinning does
	*not* prevent
	an object from being garbage collected. */

	/* StackInterpreterPrimitives>>#primitivePin */
static void
primitivePin(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt boolean;
    sqInt obj;
    char *sp;
    sqInt wasPinned;

	/* begin primitiveFailFor: */
	(GIV(primFailCode) = PrimErrUnsupported);
	return;

	/* begin stackValue: */
	obj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((obj & 1))
	 || (isForwarded(obj))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	/* begin stackTop */
	boolean = longAt(GIV(stackPointer));
	if (!((boolean == GIV(falseObj))
		 || (boolean == GIV(trueObj)))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	/* begin falseObject */
	wasPinned = GIV(falseObj);
	if (boolean == GIV(trueObj)) {
		if ((((obj & 1) == 0)
		 && (((((usqInt) (longAt(obj))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && ((((longAt((obj + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(obj))))) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadReceiver);
			return;
		}
		if ((pinObject(obj)) == 0) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), wasPinned);
	GIV(stackPointer) = sp;
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

	/* StackInterpreterPrimitives>>#primitiveSetGCSemaphore */
EXPORT(void)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtMilliseconds */
static void
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    usqLong deltaMsecs;
    usqInt msecs;
    sqInt msecsObj;
    sqInt oop;
    sqInt sema;

	/* begin stackTop */
	msecsObj = longAt(GIV(stackPointer));
	/* begin stackValue: */
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj);
	if (!GIV(primFailCode)) {
		if (((sema & 1) == 0)
		 && (((((ccIndex = (((usqInt) (longAt(sema))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(sema - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
				longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord())))))))) {
			/* begin splObj:put: */
			if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
				possibleRootStoreIntovalue(GIV(specialObjectsOop), sema);
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), sema);
			deltaMsecs = msecs - ((ioMSecs()) & MillisecondClockMask);
			if (deltaMsecs < 0) {
				deltaMsecs = (deltaMsecs + MillisecondClockMask) + 1;
			}
			GIV(nextWakeupUsecs) = (ioUTCMicroseconds()) + (deltaMsecs * 1000);
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
				possibleRootStoreIntovalue(GIV(specialObjectsOop), GIV(nilObj));
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtUTCMicroseconds */
static void
primitiveSignalAtUTCMicroseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt oop;
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	/* begin stackTop */
	usecsObj = longAt(GIV(stackPointer));
	/* begin stackValue: */
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj);
	if (!GIV(primFailCode)) {
		if (((sema & 1) == 0)
		 && (((((ccIndex = (((usqInt) (longAt(sema))) >> (compactClassFieldLSB())) & 0x1F)) == 0
			? (longAt(sema - BaseHeaderSize)) & AllButTypeMask
			: (/* begin fetchPointer:ofObject: */
				(oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))),
				longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((ccIndex - 1)) << (shiftForWord())))))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassSemaphore) << (shiftForWord())))))))) {
			/* begin splObj:put: */
			if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
				possibleRootStoreIntovalue(GIV(specialObjectsOop), sema);
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), sema);
			GIV(nextWakeupUsecs) = usecs;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
				possibleRootStoreIntovalue(GIV(specialObjectsOop), GIV(nilObj));
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Answer a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive answers the raw integral value
	at each slot. 
	e.g. for Strings it answers the character code, not the Character object
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAt */
static void
primitiveSlotAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt index;
    sqInt integerVal;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt numLiveSlots;
    sqInt numSlots;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp3;
    char *sp4;
    sqInt sz;
    sqInt value;
    sqInt valueWord1;

	/* begin stackTop */
	index = longAt(GIV(stackPointer));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if ((rcvr & 1)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	/* begin formatOf: */
	fmt = (((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15;
	index = ((index >> 1)) - 1;
	if (fmt <= 4) {
		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		if ((((usqInt)index)) < numSlots) {
			if (((((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				numLiveSlots = (stackPointerForMaybeMarriedContext(rcvr)) + CtxtTempFrameStart;
				if ((((usqInt)index)) < numLiveSlots) {
					value = externalInstVarofContext(index, rcvr);
				}
				else {
					/* begin nilObject */
					value = GIV(nilObj);
				}
			}
			else {
				value = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		numSlots = numBytesOfBytes(rcvr);
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			integerVal = byteAt((rcvr + BaseHeaderSize) + index);
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integerVal << 1) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt == 7) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPush: */
			oop = positive64BitIntegerFor(fetchLong64ofObject(index, rcvr));
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp3;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPush: */
			integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))));
			/* begin maybeInlinePositive32BitIntegerFor: */
			assert(!((hasSixtyFourBitImmediates())));
			if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
				oop1 = ((integerValue << 1) | 1);
				goto l10;
			}
			newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - 4) & 3), 1);
			/* begin storeLong32:ofObject:withValue: */
			valueWord1 = SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue);
			long32Atput((newLargeInteger + BaseHeaderSize) + (0U << 2), valueWord1);

			oop1 = newLargeInteger;
			goto l10;

		l10:	/* end positive32BitIntegerFor: */;
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp4;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin primitiveFailFor: */
	(GIV(primFailCode) = PrimErrBadReceiver);
	return;
}


/*	Assign a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive assigns a raw integral value
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAtPut */
static void
primitiveSlotAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt badRcvr;
    sqInt bs;
    sqInt ccIndex;
    sqInt classOop;
    sqInt fmt;
    sqInt header;
    sqInt index;
    sqInt newValue;
    sqInt numSlots;
    sqInt ok;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp4;
    sqInt sz;
    usqIntptr_t value;
    sqInt value1;

	/* begin stackTop */
	newValue = longAt(GIV(stackPointer));
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackValue: */
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	
#  if IMMUTABILITY
	/* begin isOopImmutable: */
	badRcvr = ((rcvr & 1))
	 || (((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0);

#  else /* IMMUTABILITY */
	badRcvr = (rcvr & 1);

#  endif /* IMMUTABILITY */

	if (badRcvr) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	/* begin formatOf: */
	fmt = (((usqInt) (longAt(rcvr))) >> (instFormatFieldLSB())) & 15;
	index = ((index >> 1)) - 1;
	if (fmt <= 4) {
		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = ((header & TypeMask) == HeaderTypeSizeAndClass
			? (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask
			: header & SizeMask);
		numSlots = ((usqInt) (sz - BaseHeaderSize)) >> (shiftForWord());
		if ((((usqInt)index)) < numSlots) {
			if (((((usqInt) (longAt(rcvr))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				externalInstVarofContextput(index, rcvr, newValue);
			}
			else {
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, newValue);
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), newValue);
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin positiveMachineIntegerValueOf: */
	if ((newValue & 1)) {
		value1 = (newValue >> 1);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = null;
			goto l15;
		}
		value = value1;
		goto l15;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	assert(!((newValue & 1)));
	/* begin compactClassIndexOf: */
	ccIndex = (((usqInt) (longAt(newValue))) >> (compactClassFieldLSB())) & 0x1F;
	if (ccIndex == 0) {
		ok = ((longAt(newValue - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l14;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l14;

	ok = classOop == (fetchPointerofObject(ccIndex - 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(CompactClasses) << (shiftForWord())))))));
l14:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l15;
	}
	bs = numBytesOfBytes(newValue);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l15;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, newValue)));
		goto l15;
	}
	else {
		value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((newValue + BaseHeaderSize) + (0U << 2))))));
		goto l15;
	}
l15:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		if ((((usqInt)value)) > 0xFF) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		numSlots = numBytesOfBytes(rcvr);
		if ((((usqInt)index)) < numSlots) {
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + index, value);
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt) (numBytesOf(rcvr))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))), value);
			/* begin pop:thenPush: */
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp4;
			return;
		}
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin primitiveFailFor: */
	(GIV(primFailCode) = PrimErrBadReceiver);
	return;
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

	/* StackInterpreterPrimitives>>#primitiveStoreStackp */
static void
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt newStackp;
    int onCurrentPage;
    sqInt senderOop;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;
    sqInt valuePointer;

	/* begin stackValue: */
	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		newStackp = (integerPointer >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (!((!GIV(primFailCode))
		 && (((newStackp >= 0) && (newStackp <= ((numSlotsOf(ctxt)) - CtxtTempFrameStart)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(ctxt)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1);

		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt);
		if (onCurrentPage) {
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (GIV(stackPage)->headSP);
			GIV(framePointer) = (GIV(stackPage)->headFP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer))));
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((sp & 1))) {
		stackp = 0;
		goto l5;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(ctxt)));
	stackp = (sp >> 1);
l5:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(((i + CtxtTempFrameStart) - 1)) << (shiftForWord())))), valuePointer);
	}
	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((ctxt + BaseHeaderSize) + (((int)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)newStackp << 1) | 1));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
 */

	/* StackInterpreterPrimitives>>#primitiveTerminateTo */
static void
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    char *callerFP;
    char *callerFP1;
    char *callerFP2;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *fp2;
    char *frameAbove;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    sqInt numArgs;
    StackPage *pageToStopOn;
    sqInt senderOop;
    sqInt senderOop1;
    sqInt senderOop2;
    sqInt senderOop3;
    sqInt senderOop4;
    sqInt senderOop5;
    char *source;
    sqInt stackedReceiverOffset;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    sqInt thisCtx;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer11;
    sqInt valuePointer2;

	contextsFP = 0;
	/* begin stackTop */
	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (((aContextOrNil & 1) == 0)
		 && (((((usqInt) (longAt(aContextOrNil))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackValue: */
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((aContextOrNil != GIV(nilObj))
	 && ((((longAt((aContextOrNil + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContextOrNil))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContextOrNil + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		contextsFP = pointerForOop(senderOop - 1);

		/* begin stackPageFor: */
		index = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
		pageToStopOn = stackPageAtpages(index, GIV(pages));
	}
	else {
		pageToStopOn = 0;
	}
	if ((((longAt((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(thisCtx)))) {
		/* begin frameOfMarriedContext: */
		senderOop2 = longAt((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop2 & 1));
		theFP = pointerForOop(senderOop2 - 1);

		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			if ((pointerForOop(longAt(theFP + FoxSavedFP))) != contextsFP) {
				/* begin frameStackedReceiverOffset: */
				numArgs = byteAt((theFP + FoxFrameFlags) + 1);
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
				/* begin findFrameAbove:inPage: */
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l3;
				}
				while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l3;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
			l3:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(pointerForOop(longAt(frameAbove + FoxCallerSavedIP))));
				assert(!(isBaseFrame(frameAbove)));
				newSP = (frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;

				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0);
				valuePointer = (oopForPointer(newFP)) + 1;

				longAtput((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0);
				valuePointer1 = (oopForPointer(contextsFP)) + 1;

				longAtput((thisCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			assert(GIV(stackPage) == (mostRecentlyUsedPage()));
			return;
		}

		/* May cause a GC!! */
		theFP = externalEnsureIsBaseFrame(theFP);
		/* begin frameCallerContext: */
		currentCtx = longAt(theFP + FoxCallerContext);
		if ((aContextOrNil != GIV(nilObj))
		 && ((((longAt((aContextOrNil + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContextOrNil))))) {
			/* begin frameOfMarriedContext: */
			senderOop1 = longAt((aContextOrNil + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop1 & 1));
			contextsFP = pointerForOop(senderOop1 - 1);

			/* begin stackPageFor: */
			index1 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
			pageToStopOn = stackPageAtpages(index1, GIV(pages));
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		currentCtx = longAt((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	if (contexthasSender(thisCtx, aContextOrNil)) {

		/* Need to walk the stack freeing stack pages and nilling contexts. */
		while (!((currentCtx == aContextOrNil)
		 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx));
			if (((longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
				/* begin frameOfMarriedContext: */
				senderOop4 = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
				assert((senderOop4 & 1));
				theFP = pointerForOop(senderOop4 - 1);

				/* begin stackPageFor: */
				index3 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
				thePage = stackPageAtpages(index3, GIV(pages));
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					fp1 = (thePage->headFP);
					if (fp1 == theFP) {
						frameAbove = 0;
						goto l11;
					}
					while (((callerFP1 = pointerForOop(longAt(fp1 + FoxSavedFP)))) != 0) {
						if (callerFP1 == theFP) {
							frameAbove = fp1;
							goto l11;
						}
						fp1 = callerFP1;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
				l11:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);

					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */
					frameAbove = externalEnsureIsBaseFrame(frameAbove);
					if ((aContextOrNil != GIV(nilObj))
					 && ((((longAt((aContextOrNil + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(aContextOrNil))))) {
						/* begin frameOfMarriedContext: */
						senderOop3 = longAt((aContextOrNil + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop3 & 1));
						contextsFP = pointerForOop(senderOop3 - 1);

						/* begin stackPageFor: */
						index2 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
						pageToStopOn = stackPageAtpages(index2, GIV(pages));
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {

						/* We're here.  Cut back the stack to aContextOrNil's frame,
						   push its instructionPointer if it's not already a head frame,
						   and we're done. */
						/* begin findFrameAbove:inPage: */
						fp2 = (thePage->headFP);
						if (fp2 == contextsFP) {
							frameAbove = 0;
							goto l12;
						}
						while (((callerFP2 = pointerForOop(longAt(fp2 + FoxSavedFP)))) != 0) {
							if (callerFP2 == contextsFP) {
								frameAbove = fp2;
								goto l12;
							}
							fp2 = callerFP2;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
					l12:	/* end findFrameAbove:inPage: */;
						if (frameAbove != 0) {
							contextsSP = ((assert(!(isBaseFrame(frameAbove))),
(frameAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord)) - BytesPerWord;
							longAtput(contextsSP, pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {

						/* We can free the entire page without further ado. */
						/* begin frameCallerContext: */
						theFP1 = (thePage->baseFP);
						currentCtx = longAt(theFP1 + FoxCallerContext);
						freeStackPageNoAssert(thePage);
					}
				}
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer2 = GIV(nilObj);
				longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer2);
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer11 = GIV(nilObj);
				longAtput((currentCtx + BaseHeaderSize) + (((int)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer11);
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed());
	if (((longAt((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer)));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx)));
		/* begin frameOfMarriedContext: */
		senderOop5 = longAt((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop5 & 1));
		theFP = pointerForOop(senderOop5 - 1);

		/* begin frameCallerContext:put: */
		longAtput(theFP + FoxCallerContext, aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(thisCtx, GIV(youngStart))) {
			possibleRootStoreIntovalue(thisCtx, aContextOrNil);
		}
		longAtput((thisCtx + BaseHeaderSize) + (((int)((usqInt)(SenderIndex) << (shiftForWord())))), aContextOrNil);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end (v3)/size(Spur) of old-space (0-based, read-only)
	2	end (v3)/size(Spur) of young/new-space (read-only)
	3	end (v3)/size(Spur) of heap (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs (SqueakV3) or scavenges (Spur) since startup (read-only)
	10	total milliseconds in incremental GCs (SqueakV3) or scavenges (Spur)
	since startup (read-only)
	11	tenures of surving objects since startup (read-only)
	12-20 were specific to ikp's JITTER VM, now 12-15 are open for use
	16	total microseconds at idle since start-up (if non-zero)
	17	fraction of the code zone to use (Sista only; used to control code zone
	use to preserve sendAndBranchData on counter tripped callback)
	18	total milliseconds in compaction phase of full GC since start-up (Spur
	only) 19	scavenge threshold, the effective size of eden. When eden fills
	to the threshold a scavenge is scheduled. Newer Spur VMs only.
	20	utc microseconds at VM start-up (actually at time initialization, which
	precedes image load).
	21	root/remembered table size (occupancy) (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored
	in image file header).
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	number of allocations done before current IGC/FGC (read-only)
	35	number of survivor objects after current IGC/FGC (read-only)
	36	millisecond clock when current IGC/FGC completed (read-only)
	37	number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38	milliseconds taken by current IGC (read-only)
	39	Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40	BytesPerOop for this image
	41	imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (stored in image file header; Cog only;
	otherwise nil)
	48	various header flags. See getCogVMFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	50-51 nil; reserved for VM parameters that persist in the image (such as
	eden above)
	52	root/remembered table capacity
	53	number of segments (Spur only; otherwise nil)
	54	total size of free old space (Spur only, otherwise nil)
	55	ratio of growth and image size at or above which a GC will be performed
	post scavenge
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	65	whether the VM supports a certain feature, MULTIPLE_BYTECODE_SETS is
	bit 0, IMMTABILITY is bit 1
	66	the byte size of a stack page
	67	the max allowed size of old space (Spur only; nil otherwise; 0 implies
	no limit except that of the underlying platform)
	68	the average number of live stack pages when scanned by GC (at
	scavenge/gc/become et al)
	69	the maximum number of live stack pages when scanned by GC (at
	scavenge/gc/become et al)
	70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
	71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
	Note: Thanks to Ian Piumarta for this primitive. */

	/* StackInterpreterPrimitives>>#primitiveVMParameter */
static void
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt i;
    sqInt index;
    sqInt paramsArraySize;
    sqInt result;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt valuePointer10;
    sqInt valuePointer11;
    sqInt valuePointer12;
    sqInt valuePointer13;
    sqInt valuePointer14;
    sqInt valuePointer15;
    sqInt valuePointer16;
    sqInt valuePointer17;
    sqInt valuePointer18;
    sqInt valuePointer19;
    sqInt valuePointer20;
    sqInt valuePointer21;
    sqInt valuePointer22;
    sqInt valuePointer23;
    sqInt valuePointer24;
    sqInt valuePointer25;
    sqInt valuePointer26;
    sqInt valuePointer27;
    sqInt valuePointer28;
    sqInt valuePointer29;
    sqInt valuePointer30;
    sqInt valuePointer31;
    sqInt valuePointer32;
    sqInt valuePointer33;
    sqInt valuePointer34;
    sqInt valuePointer35;
    sqInt valuePointer36;
    sqInt valuePointer37;
    sqInt valuePointer38;
    sqInt valuePointer39;
    sqInt valuePointer40;
    sqInt valuePointer41;
    sqInt valuePointer42;
    sqInt valuePointer43;
    sqInt valuePointer44;
    sqInt valuePointer45;
    sqInt valuePointer46;
    sqInt valuePointer47;
    sqInt valuePointer48;
    sqInt valuePointer49;
    sqInt valuePointer50;
    sqInt valuePointer51;
    sqInt valuePointer52;
    sqInt valuePointer53;
    sqInt valuePointer54;
    sqInt valuePointer55;
    sqInt valuePointer7;
    sqInt valuePointer8;
    sqInt valuePointer9;

	result = 0;
	paramsArraySize = 71;
	if (GIV(argumentCount) == 0) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassArray) << (shiftForWord()))))), paramsArraySize);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer7 = positiveMachineIntegerFor(GIV(youngStart) - (startOfMemory()));
		longAtput((result + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer7);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer8 = (((usqInt)(GIV(freeStart) - (startOfMemory())) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer8);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer9 = positiveMachineIntegerFor(GIV(endOfMemory) - (startOfMemory()));
		longAtput((result + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer9);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer10 = (((usqInt)GIV(tenuringThreshold) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (5U << (shiftForWord())), valuePointer10);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer11 = (((usqInt)GIV(statFullGCs) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (6U << (shiftForWord())), valuePointer11);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer12 = ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (7U << (shiftForWord())), valuePointer12);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer13 = (((usqInt)((/* begin statIncrGCs */
GIV(statIncrGCs))) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (8U << (shiftForWord())), valuePointer13);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer14 = ((((((/* begin statIncrGCUsecs */
GIV(statIncrGCUsecs))) + 500) / 1000) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (9U << (shiftForWord())), valuePointer14);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer15 = (((usqInt)GIV(statTenures) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (10U << (shiftForWord())), valuePointer15);
		for (i = 11; i <= 18; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			longAtput((result + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), ConstZero);
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer16 = positive64BitIntegerFor(GIV(statIdleUsecs));
		longAtput((result + BaseHeaderSize) + (15U << (shiftForWord())), valuePointer16);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer17 = positive64BitIntegerFor(ioUTCStartMicroseconds());
		longAtput((result + BaseHeaderSize) + (19U << (shiftForWord())), valuePointer17);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer18 = (((usqInt)GIV(rootTableCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (20U << (shiftForWord())), valuePointer18);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer19 = (((usqInt)GIV(statRootTableOverflows) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (21U << (shiftForWord())), valuePointer19);
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (22U << (shiftForWord())), (((usqInt)extraVMMemory << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer20 = (((usqInt)GIV(shrinkThreshold) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (23U << (shiftForWord())), valuePointer20);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer21 = (((usqInt)GIV(growHeadroom) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (24U << (shiftForWord())), valuePointer21);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer22 = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (25U << (shiftForWord())), valuePointer22);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer23 = (((usqInt)GIV(statMarkCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (26U << (shiftForWord())), valuePointer23);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer24 = (((usqInt)GIV(statSweepCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (27U << (shiftForWord())), valuePointer24);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer25 = (((usqInt)GIV(statMkFwdCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (28U << (shiftForWord())), valuePointer25);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer26 = (((usqInt)GIV(statCompMoveCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (29U << (shiftForWord())), valuePointer26);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer27 = (((usqInt)GIV(statGrowMemory) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (30U << (shiftForWord())), valuePointer27);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer28 = (((usqInt)GIV(statShrinkMemory) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (0x1FU << (shiftForWord())), valuePointer28);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer29 = (((usqInt)GIV(statRootTableCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (32U << (shiftForWord())), valuePointer29);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer30 = (((usqInt)GIV(statSurvivorCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (34U << (shiftForWord())), valuePointer30);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer31 = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (35U << (shiftForWord())), valuePointer31);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer32 = (((usqInt)GIV(statSpecialMarkCount) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (36U << (shiftForWord())), valuePointer32);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer33 = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (37U << (shiftForWord())), valuePointer33);
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (38U << (shiftForWord())), (((usqInt)GIV(statPendingFinalizationSignals) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (39U << (shiftForWord())), (((usqInt)BytesPerWord << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer34 = (((usqInt)(6505) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (40U << (shiftForWord())), valuePointer34);
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (41U << (shiftForWord())), (((usqInt)GIV(numStackPages) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (42U << (shiftForWord())), (((usqInt)desiredNumStackPages << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer35 = (((usqInt)GIV(edenBytes) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (43U << (shiftForWord())), valuePointer35);
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (44U << (shiftForWord())), (((usqInt)desiredEdenBytes << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer36 = GIV(nilObj);
		longAtput((result + BaseHeaderSize) + (45U << (shiftForWord())), valuePointer36);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer37 = GIV(nilObj);
		longAtput((result + BaseHeaderSize) + (46U << (shiftForWord())), valuePointer37);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer38 = (((usqInt)((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | (4 + 16)) - (4 + 16)))) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (47U << (shiftForWord())), valuePointer38);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer39 = (((usqInt)(ioGetMaxExtSemTableSize()) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (48U << (shiftForWord())), valuePointer39);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer40 = (((usqInt)RootTableSize << 1) | 1);
		longAtput((result + BaseHeaderSize) + (51U << (shiftForWord())), valuePointer40);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer41 = positive64BitIntegerFor(GIV(statProcessSwitch));
		longAtput((result + BaseHeaderSize) + (55U << (shiftForWord())), valuePointer41);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer42 = positive64BitIntegerFor(GIV(statIOProcessEvents));
		longAtput((result + BaseHeaderSize) + (56U << (shiftForWord())), valuePointer42);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer43 = positive64BitIntegerFor(GIV(statForceInterruptCheck));
		longAtput((result + BaseHeaderSize) + (57U << (shiftForWord())), valuePointer43);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer44 = positive64BitIntegerFor(GIV(statCheckForEvents));
		longAtput((result + BaseHeaderSize) + (58U << (shiftForWord())), valuePointer44);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer45 = positive64BitIntegerFor(GIV(statStackOverflow));
		longAtput((result + BaseHeaderSize) + (59U << (shiftForWord())), valuePointer45);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer46 = positive64BitIntegerFor(GIV(statStackPageDivorce));
		longAtput((result + BaseHeaderSize) + (60U << (shiftForWord())), valuePointer46);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer47 = GIV(nilObj);
		longAtput((result + BaseHeaderSize) + (61U << (shiftForWord())), valuePointer47);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer48 = GIV(nilObj);
		longAtput((result + BaseHeaderSize) + (0x3EU << (shiftForWord())), valuePointer48);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer49 = ConstZero;
		longAtput((result + BaseHeaderSize) + (0x3FU << (shiftForWord())), valuePointer49);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer50 = (((usqInt)((0) + ((IMMUTABILITY
	? 2
	: 0))) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (64U << (shiftForWord())), valuePointer50);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer51 = (((usqInt)(stackPageByteSize()) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (65U << (shiftForWord())), valuePointer51);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer52 = floatObjectOf(statAverageLivePagesWhenMapping());
		longAtput((result + BaseHeaderSize) + (67U << (shiftForWord())), valuePointer52);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer53 = (((usqInt)(statMaxPageCountWhenMapping()) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (68U << (shiftForWord())), valuePointer53);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer54 = (((usqInt)(VM_PROXY_MAJOR) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (69U << (shiftForWord())), valuePointer54);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer55 = (((usqInt)(VM_PROXY_MINOR) << 1) | 1);
		longAtput((result + BaseHeaderSize) + (70U << (shiftForWord())), valuePointer55);
		assert(paramsArraySize == 71);
		beRootIfOld(result);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin stackTop */
	arg = longAt(GIV(stackPointer));
	if (GIV(argumentCount) == 1) {

		/* read VM parameter */
		if (!((arg & 1))) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		arg = (arg >> 1);
		if ((arg < 1)
		 || (arg > paramsArraySize)) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadIndex);
			return;
		}
		/* begin nilObject */
		result = GIV(nilObj);
		if (arg == 1) {
			result = positiveMachineIntegerFor(GIV(youngStart) - (startOfMemory()));
		}
		if (arg == 2) {
			result = (((usqInt)(GIV(freeStart) - (startOfMemory())) << 1) | 1);
		}
		if (arg == 3) {
			result = positiveMachineIntegerFor(GIV(endOfMemory) - (startOfMemory()));
		}
		if (arg == 4) {
			/* begin nilObject */
			result = GIV(nilObj);
		}
		if (arg == 5) {
			/* begin nilObject */
			result = GIV(nilObj);
		}
		if (arg == 6) {
			result = (((usqInt)GIV(tenuringThreshold) << 1) | 1);
		}
		if (arg == 7) {
			result = (((usqInt)GIV(statFullGCs) << 1) | 1);
		}
		if (arg == 8) {
			result = ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1);
		}
		if (arg == 9) {
			result = (((usqInt)((/* begin statIncrGCs */
GIV(statIncrGCs))) << 1) | 1);
		}
		if (arg == 10) {
			result = ((((((/* begin statIncrGCUsecs */
GIV(statIncrGCUsecs))) + 500) / 1000) << 1) | 1);
		}
		if (arg == 11) {
			result = (((usqInt)GIV(statTenures) << 1) | 1);
		}
		if (((arg >= 12) && (arg <= 15))) {
			result = ConstZero;
		}
		if (arg == 16) {
			result = positive64BitIntegerFor(GIV(statIdleUsecs));
		}
		if (arg == 17) {
			result = ConstZero;
		}
		if (arg == 18) {
			result = ConstZero;
		}
		if (arg == 19) {
			result = ConstZero;
		}
		if (arg == 20) {
			result = positive64BitIntegerFor(ioUTCStartMicroseconds());
		}
		if (arg == 21) {
			result = (((usqInt)GIV(rootTableCount) << 1) | 1);
		}
		if (arg == 22) {
			result = (((usqInt)GIV(statRootTableOverflows) << 1) | 1);
		}
		if (arg == 23) {
			result = (((usqInt)extraVMMemory << 1) | 1);
		}
		if (arg == 24) {
			result = (((usqInt)GIV(shrinkThreshold) << 1) | 1);
		}
		if (arg == 25) {
			result = (((usqInt)GIV(growHeadroom) << 1) | 1);
		}
		if (arg == 26) {
			result = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);
		}
		if (arg == 27) {
			result = (((usqInt)GIV(statMarkCount) << 1) | 1);
		}
		if (arg == 28) {
			result = (((usqInt)GIV(statSweepCount) << 1) | 1);
		}
		if (arg == 29) {
			result = (((usqInt)GIV(statMkFwdCount) << 1) | 1);
		}
		if (arg == 30) {
			result = (((usqInt)GIV(statCompMoveCount) << 1) | 1);
		}
		if (arg == 0x1F) {
			result = (((usqInt)GIV(statGrowMemory) << 1) | 1);
		}
		if (arg == 32) {
			result = (((usqInt)GIV(statShrinkMemory) << 1) | 1);
		}
		if (arg == 33) {
			result = (((usqInt)GIV(statRootTableCount) << 1) | 1);
		}
		if (arg == 34) {
			/* begin nilObject */
			result = GIV(nilObj);
		}
		if (arg == 35) {
			result = (((usqInt)GIV(statSurvivorCount) << 1) | 1);
		}
		if (arg == 36) {
			result = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1);
		}
		if (arg == 37) {
			result = (((usqInt)GIV(statSpecialMarkCount) << 1) | 1);
		}
		if (arg == 38) {
			result = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1);
		}
		if (arg == 39) {
			result = (((usqInt)GIV(statPendingFinalizationSignals) << 1) | 1);
		}
		if (arg == 40) {
			result = (((usqInt)BytesPerWord << 1) | 1);
		}
		if (arg == 41) {
			result = (((usqInt)(6505) << 1) | 1);
		}
		if (arg == 42) {
			result = (((usqInt)GIV(numStackPages) << 1) | 1);
		}
		if (arg == 43) {
			result = (((usqInt)desiredNumStackPages << 1) | 1);
		}
		if (arg == 44) {
			result = (((usqInt)GIV(edenBytes) << 1) | 1);
		}
		if (arg == 45) {
			result = (((usqInt)desiredEdenBytes << 1) | 1);
		}
		if (arg == 46) {
			/* begin getCogCodeSize */
			result = GIV(nilObj);
		}
		if (arg == 47) {
			/* begin getDesiredCogCodeSize */
			result = GIV(nilObj);
		}
		if (arg == 48) {
			/* begin getCogVMFlags */
			result = (((usqInt)((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | (4 + 16)) - (4 + 16)))) << 1) | 1);
		}
		if (arg == 49) {
			result = (((usqInt)(ioGetMaxExtSemTableSize()) << 1) | 1);
		}
		if (arg == 52) {
			result = (((usqInt)RootTableSize << 1) | 1);
		}
		if (arg == 56) {
			result = positive64BitIntegerFor(GIV(statProcessSwitch));
		}
		if (arg == 57) {
			result = positive64BitIntegerFor(GIV(statIOProcessEvents));
		}
		if (arg == 58) {
			result = positive64BitIntegerFor(GIV(statForceInterruptCheck));
		}
		if (arg == 59) {
			result = positive64BitIntegerFor(GIV(statCheckForEvents));
		}
		if (arg == 60) {
			result = positive64BitIntegerFor(GIV(statStackOverflow));
		}
		if (arg == 61) {
			result = positive64BitIntegerFor(GIV(statStackPageDivorce));
		}
		if (arg == 0x3E) {
			/* begin getCodeCompactionCount */
			result = GIV(nilObj);
		}
		if (arg == 0x3F) {
			/* begin getCodeCompactionMSecs */
			result = GIV(nilObj);
		}
		if (arg == 64) {
			/* begin getCogMethodCount */
			result = ConstZero;
		}
		if (arg == 65) {
			/* begin getCogVMFeatureFlags */
			result = (((usqInt)((0) + ((IMMUTABILITY
	? 2
	: 0))) << 1) | 1);
		}
		if (arg == 66) {
			result = (((usqInt)(stackPageByteSize()) << 1) | 1);
		}
		if (arg == 68) {
			result = floatObjectOf(statAverageLivePagesWhenMapping());
		}
		if (arg == 69) {
			result = (((usqInt)(statMaxPageCountWhenMapping()) << 1) | 1);
		}
		if (arg == 70) {
			result = (((usqInt)(VM_PROXY_MAJOR) << 1) | 1);
		}
		if (arg == 71) {
			result = (((usqInt)(VM_PROXY_MINOR) << 1) | 1);
		}
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	if (!(GIV(argumentCount) == 2)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	/* begin stackValue: */
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 1);
	if ((index < 1)
	 || (index > paramsArraySize)) {
		/* begin primitiveFailFor: */
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((index == 17)
	 || (index == 55)) {
		if (!(isinstanceOfcompactClassIndex(arg, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((int)((usqInt)(ClassFloat) << (shiftForWord()))))), ClassFloatCompactIndex))) {
			/* begin primitiveFailFor: */
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}
	else {
		if ((arg & 1)) {
			arg = (arg >> 1);
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	if (index == 5) {

		/* Was:
		   result := allocationsBetweenGCs.
		   allocationsBetweenGCs := arg. */
		/* Ignore for now, because old images won't start up otherwise.
		   See 44 & 45 for eden size setting. */
		/* begin nilObject */
		result = GIV(nilObj);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}

	if (index == 6) {
		result = (((usqInt)GIV(tenuringThreshold) << 1) | 1);
		/* begin tenuringThreshold: */
		GIV(tenuringThreshold) = arg;
		GIV(primFailCode) = 0;
	}
	if (index == 23) {
		result = (((usqInt)extraVMMemory << 1) | 1);
		extraVMMemory = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 24) {
		result = (((usqInt)GIV(shrinkThreshold) << 1) | 1);
		if (arg > 0) {
			/* begin shrinkThreshold: */
			GIV(shrinkThreshold) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 25) {
		result = (((usqInt)GIV(growHeadroom) << 1) | 1);
		if (arg > 0) {
			/* begin growHeadroom: */
			GIV(growHeadroom) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 26) {
		if (arg >= 0) {

			/* 0 turns off the heartbeat */
			result = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);
			ioSetHeartbeatMilliseconds(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 43) {
		if ((arg >= 0)
		 && (arg <= 0xFFFF)) {
			result = (((usqInt)desiredNumStackPages << 1) | 1);
			desiredNumStackPages = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 45) {
		if (arg >= 0) {
			result = (((usqInt)desiredEdenBytes << 1) | 1);
			desiredEdenBytes = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 48) {
		if (arg >= 0) {
			result = (((usqInt)((((usqInt)((((GIV(preemptionYields)
	? 0
	: 4)) + ((GIV(newFinalization)
	? 16
	: 0))) + ((((((usqInt) GIV(imageHeaderFlags)) >> 2) | (4 + 16)) - (4 + 16)))) << 1) | 1)) << 1) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setCogVMFlags: */
			if ((((usqInt)arg)) > 0x1F) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				goto l83;
			}
			GIV(preemptionYields) = (arg & 4) == 0;
			GIV(newFinalization) = (arg & 16) != 0;
		l83:	/* end setCogVMFlags: */;
		}
	}
	if (index == 49) {
		if ((arg >= 0)
		 && (arg <= 0xFFFF)) {
			result = (((usqInt)(ioGetMaxExtSemTableSize()) << 1) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setMaxExtSemSizeTo: */
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrInappropriate;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

	/* StackInterpreterPrimitives>>#primitiveVoidReceiver */
EXPORT(void)
primitiveVoidReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtPointerput(GIV(framePointer) + FoxReceiver, 0);
}


/*	Void all internal VM state in the stack and machine code zones */

	/* StackInterpreterPrimitives>>#primitiveVoidVMState */
static void
primitiveVoidVMState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0);
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}


/*	Prune the stack to contain only the path, removing stacked indices
	and mapping frame pointers to contexts The issue here is that a
	GC can occur during ensureFrameIsMarried:SP:, but frame pointers
	are not valid objects. So first prune back to objects and framePointers
	as integers, and then replace frame pointers as integers by contexts. */

	/* StackInterpreterPrimitives>>#pruneStack:stackp: */
static void NoDbgRegParms
pruneStackstackp(sqInt stack, sqInt stackp)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt finger;
    char *fp;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt objOrFP;
    sqInt oop;
    sqInt oop1;
    char *theFP;
    char *theFPAbove;
    StackPage *thePage;
    char *theSP;
    sqInt theStack;
    sqInt valuePointer;

	finger = 1;
	for (i = 2; i < stackp; i += 2) {
		objOrFP = longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((((((usqInt)(((char *) objOrFP)))) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)(((char *) objOrFP)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) objOrFP)))) <= (((usqInt)GIV(pages))))))) {
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(((char *) objOrFP))) & (BytesPerWord - 1)) == 0);
			objOrFP = (oopForPointer(((char *) objOrFP))) + 1;
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(finger) << (shiftForWord())))), objOrFP);
		finger += 1;
	}
	for (i = finger, iLimiT = ((lengthOf(stack)) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = GIV(nilObj);
		longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
	}
	/* begin pushRemappableOop: */
	oop = (theStack = stack);
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	for (i = 1; i < finger; i += 1) {
		objOrFP = longAt((theStack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((objOrFP & 1)) {
			/* begin withoutSmallIntegerTags: */
			assert((objOrFP & 1));
			theFP = pointerForOop(objOrFP - 1);
			/* begin stackPageFor: */
			index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == theFP) {
				theFPAbove = 0;
				goto l5;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == theFP) {
					theFPAbove = fp;
					goto l5;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
		l5:	/* end findFrameAbove:inPage: */;
			/* begin ensureFrameIsMarried:SP: */
			assert(!(isBaseFrame(theFPAbove)));
			theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)((byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;

			if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
				assert(isContext(frameContext(theFP)));
				objOrFP = longAt(theFP + FoxThisContext);
				goto l6;
			}
			objOrFP = marryFrameSP(theFP, theSP);
		l6:	/* end ensureFrameIsMarried:SP: */;
			/* begin topRemappableOop */
			theStack = GIV(remapBuffer)[GIV(remapBufferCount)];
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(theStack, GIV(youngStart))) {
				possibleRootStoreIntovalue(theStack, objOrFP);
			}
			longAtput((theStack + BaseHeaderSize) + (((sqInt)((usqInt)(finger) << (shiftForWord())))), objOrFP);
		}
	}
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
}

	/* StackInterpreterPrimitives>>#unmarkAfterPathTo */
static void
unmarkAfterPathTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt hdr;
    sqInt header;
    sqInt oop;
    sqInt sz;

	unmarkAllFrames();
	/* begin unmarkAllObjects */
	chunk = startOfMemory();
	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			hdr = longAt(oop);
			if ((hdr & MarkBit) != 0) {
				longAtput(oop, hdr & AllButMarkBit);
			}
		}
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((header & TypeMask) == HeaderTypeSizeAndClass
				? (longAt(oop - (BytesPerWord * 2))) & LongSizeMask
				: header & SizeMask);
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}

	/* StackInterpreterPrimitives>>#unmarkAllFrames */
static void
unmarkAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;
    char *theFP;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			theFP = (thePage->headFP);
			do {
				flags = longAt(theFP + FoxFrameFlags);
				if ((flags & 2) != 0) {
					longAtput(theFP + FoxFrameFlags, flags - 2);
				}
			} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
		}
	}
}


static char _m[] = "";
void* vm_exports[][3] = {
	{(void*)_m, "addGCRoot", (void*)addGCRoot},
	{(void*)_m, "addIdleUsecs", (void*)addIdleUsecs},
	{(void*)_m, "callbackEnter", (void*)callbackEnter},
	{(void*)_m, "callbackLeave", (void*)callbackLeave},
	{(void*)_m, "dumpImage", (void*)dumpImage},
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveAddLargeIntegers", (void*)primitiveAddLargeIntegers},
	{(void*)_m, "primitiveAllInstances", (void*)primitiveAllInstances},
	{(void*)_m, "primitiveAllObjects", (void*)primitiveAllObjects},
	{(void*)_m, "primitiveBitAndLargeIntegers", (void*)primitiveBitAndLargeIntegers},
	{(void*)_m, "primitiveBitOrLargeIntegers", (void*)primitiveBitOrLargeIntegers},
	{(void*)_m, "primitiveBitShiftLargeIntegers", (void*)primitiveBitShiftLargeIntegers},
	{(void*)_m, "primitiveBitXorLargeIntegers", (void*)primitiveBitXorLargeIntegers},
	{(void*)_m, "primitiveClockLogAddresses", (void*)primitiveClockLogAddresses},
	{(void*)_m, "primitiveCompareBytes", (void*)primitiveCompareBytes},
	{(void*)_m, "primitiveCrashVM", (void*)primitiveCrashVM},
	{(void*)_m, "primitiveDisablePowerManager", (void*)primitiveDisablePowerManager},
	{(void*)_m, "primitiveDivideLargeIntegers", (void*)primitiveDivideLargeIntegers},
	{(void*)_m, "primitiveDivLargeIntegers", (void*)primitiveDivLargeIntegers},
	{(void*)_m, "primitiveEqualLargeIntegers", (void*)primitiveEqualLargeIntegers},
	{(void*)_m, "primitiveEventProcessingControl", (void*)primitiveEventProcessingControl},
	{(void*)_m, "primitiveForceTenure", (void*)primitiveForceTenure},
	{(void*)_m, "primitiveGetenv", (void*)primitiveGetenv},
	{(void*)_m, "primitiveGetLogDirectory", (void*)primitiveGetLogDirectory},
	{(void*)_m, "primitiveGetWindowLabel", (void*)primitiveGetWindowLabel},
	{(void*)_m, "primitiveGetWindowSize", (void*)primitiveGetWindowSize},
	{(void*)_m, "primitiveGreaterOrEqualLargeIntegers", (void*)primitiveGreaterOrEqualLargeIntegers},
	{(void*)_m, "primitiveGreaterThanLargeIntegers", (void*)primitiveGreaterThanLargeIntegers},
	{(void*)_m, "primitiveHeartbeatFrequency", (void*)primitiveHeartbeatFrequency},
	{(void*)_m, "primitiveHighResClock", (void*)primitiveHighResClock},
	{(void*)_m, "primitiveImageFormatVersion", (void*)primitiveImageFormatVersion},
	{(void*)_m, "primitiveInterruptChecksPerMSec", (void*)primitiveInterruptChecksPerMSec},
	{(void*)_m, "primitiveIsBigEnder", (void*)primitiveIsBigEnder},
	{(void*)_m, "primitiveIsRoot", (void*)primitiveIsRoot},
	{(void*)_m, "primitiveIsWindowObscured", (void*)primitiveIsWindowObscured},
	{(void*)_m, "primitiveIsYoung", (void*)primitiveIsYoung},
	{(void*)_m, "primitiveLessOrEqualLargeIntegers", (void*)primitiveLessOrEqualLargeIntegers},
	{(void*)_m, "primitiveLessThanLargeIntegers", (void*)primitiveLessThanLargeIntegers},
	{(void*)_m, "primitiveLongRunningPrimitive", (void*)primitiveLongRunningPrimitive},
	{(void*)_m, "primitiveLongRunningPrimitiveSemaphore", (void*)primitiveLongRunningPrimitiveSemaphore},
	{(void*)_m, "primitiveMillisecondClockMask", (void*)primitiveMillisecondClockMask},
	{(void*)_m, "primitiveModLargeIntegers", (void*)primitiveModLargeIntegers},
	{(void*)_m, "primitiveMultiplyLargeIntegers", (void*)primitiveMultiplyLargeIntegers},
	{(void*)_m, "primitiveNotEqualLargeIntegers", (void*)primitiveNotEqualLargeIntegers},
	{(void*)_m, "primitivePathToUsing", (void*)primitivePathToUsing},
	{(void*)_m, "primitiveProfilePrimitive", (void*)primitiveProfilePrimitive},
	{(void*)_m, "primitiveProfileSample", (void*)primitiveProfileSample},
	{(void*)_m, "primitiveProfileSemaphore", (void*)primitiveProfileSemaphore},
	{(void*)_m, "primitiveProfileStart", (void*)primitiveProfileStart},
	{(void*)_m, "primitiveQuoLargeIntegers", (void*)primitiveQuoLargeIntegers},
	{(void*)_m, "primitiveRemLargeIntegers", (void*)primitiveRemLargeIntegers},
	{(void*)_m, "primitiveRootTableAt", (void*)primitiveRootTableAt},
	{(void*)_m, "primitiveScreenDepth", (void*)primitiveScreenDepth},
	{(void*)_m, "primitiveScreenScaleFactor", (void*)primitiveScreenScaleFactor},
	{(void*)_m, "primitiveSetGCBiasToGrow", (void*)primitiveSetGCBiasToGrow},
	{(void*)_m, "primitiveSetGCBiasToGrowGCLimit", (void*)primitiveSetGCBiasToGrowGCLimit},
	{(void*)_m, "primitiveSetGCSemaphore", (void*)primitiveSetGCSemaphore},
	{(void*)_m, "primitiveSetLogDirectory", (void*)primitiveSetLogDirectory},
	{(void*)_m, "primitiveSetWindowLabel", (void*)primitiveSetWindowLabel},
	{(void*)_m, "primitiveSetWindowSize", (void*)primitiveSetWindowSize},
	{(void*)_m, "primitiveSubtractLargeIntegers", (void*)primitiveSubtractLargeIntegers},
	{(void*)_m, "primitiveUtcWithOffset", (void*)primitiveUtcWithOffset},
	{(void*)_m, "primitiveVoidReceiver", (void*)primitiveVoidReceiver},
	{(void*)_m, "printFramesInPage", (void*)printFramesInPage},
	{(void*)_m, "printFramesOnStackPageListInUse", (void*)printFramesOnStackPageListInUse},
	{(void*)_m, "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{(void*)_m, "removeGCRoot", (void*)removeGCRoot},
	{(void*)_m, "returnAsThroughCallbackContext", (void*)returnAsThroughCallbackContext},
	{(void*)_m, "sendInvokeCallbackContext", (void*)sendInvokeCallbackContext},
	{(void*)_m, "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{(void*)_m, "setInterruptCheckChain", (void*)setInterruptCheckChain},
	{(void*)_m, "shortPrintFramesInPage", (void*)shortPrintFramesInPage},
	{(void*)_m, "shortPrintFramesOnStackPageListInUse", (void*)shortPrintFramesOnStackPageListInUse},
	{(void*)_m, "statNumGCs", (void*)statNumGCs},
	{NULL, NULL, NULL}
};

void initGlobalStructure(void) {
#if SQ_USE_GLOBAL_STRUCT_REG
foo = &fum;
#endif
}
