/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.3453 uuid: 6917573f-1029-4681-87bc-5f02f287102b
   from
	IA32ABIPlugin VMMaker.oscog-eem.3453 uuid: 6917573f-1029-4681-87bc-5f02f287102b
 */
static char __buildInfo[] = "IA32ABIPlugin VMMaker.oscog-eem.3453 uuid: 6917573f-1029-4681-87bc-5f02f287102b " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <setjmp.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "vmCallback.h"
#include "ia32abi.h"
#include "sqAssert.h"
#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif

typedef struct {
	int	type;
	int	pad;
	union {
								sqIntptr_t valword;
								struct { int low, high; } valleint64;
								struct { int high, low; } valbeint64;
								double valflt64;
								struct { void *addr; sqIntptr_t size; } valstruct;
							}crvrvs;
 } VMCallbackReturnValue;



/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
static sqInt indexlengthinRange(sqInt byteIndex, sqInt length, sqInt rcvr);
static sqInt isAlien(sqInt oop);
EXPORT(sqInt) primAddressField(void);
EXPORT(sqInt) primAddressFieldPut(void);
EXPORT(sqInt) primAlienCopyInto(void);
EXPORT(sqInt) primAlienReplace(void);
EXPORT(sqInt) primAllocateExecutablePage(void);
EXPORT(sqInt) primBoxedFree(void);
EXPORT(sqInt) primCallOutDoubleReturn(void);
EXPORT(sqInt) primCallOutFloatReturn(void);
EXPORT(sqInt) primCallOutIntegralReturn(void);
EXPORT(sqInt) primCalloc(void);
EXPORT(sqInt) primDoubleAt(void);
EXPORT(sqInt) primDoubleAtPut(void);
EXPORT(sqInt) primDrainOSEventQueue(void);
EXPORT(sqInt) primFloatAt(void);
EXPORT(sqInt) primFloatAtPut(void);
EXPORT(sqInt) primFree(void);
EXPORT(sqInt) primInIOProcessEventsFlagAddress(void);
EXPORT(sqInt) primInLibraryFindSymbol(void);
EXPORT(sqInt) primLoadLibrary(void);
EXPORT(sqInt) primMalloc(void);
EXPORT(sqInt) primMostRecentCallbackContext(void);
EXPORT(sqInt) primOopAt(void);
EXPORT(sqInt) primOopAtPut(void);
EXPORT(sqInt) primReturnAsFromContextThrough(void);
#if OBSOLETE_ALIEN_PRIMITIVES
EXPORT(sqInt) primReturnFromContextThrough(void);
#endif /* OBSOLETE_ALIEN_PRIMITIVES */
EXPORT(sqInt) primSignedByteAt(void);
EXPORT(sqInt) primSignedByteAtPut(void);
EXPORT(sqInt) primSignedLongAt(void);
EXPORT(sqInt) primSignedLongAtPut(void);
EXPORT(sqInt) primSignedLongLongAt(void);
EXPORT(sqInt) primSignedLongLongAtPut(void);
EXPORT(sqInt) primSignedShortAt(void);
EXPORT(sqInt) primSignedShortAtPut(void);
EXPORT(sqInt) primSignedWordAt(void);
EXPORT(sqInt) primSignedWordAtPut(void);
EXPORT(sqInt) primSizeField(void);
EXPORT(sqInt) primSizeFieldPut(void);
EXPORT(sqInt) primStrlenFromStartIndex(void);
EXPORT(sqInt) primStrlenThroughPointerAtIndex(void);
EXPORT(sqInt) primThunkEntryAddress(void);
EXPORT(sqInt) primUnsignedByteAt(void);
EXPORT(sqInt) primUnsignedByteAtPut(void);
EXPORT(sqInt) primUnsignedLongAt(void);
EXPORT(sqInt) primUnsignedLongAtPut(void);
EXPORT(sqInt) primUnsignedLongLongAt(void);
EXPORT(sqInt) primUnsignedLongLongAtPut(void);
EXPORT(sqInt) primUnsignedShortAt(void);
EXPORT(sqInt) primUnsignedShortAtPut(void);
EXPORT(sqInt) primUnsignedWordAt(void);
EXPORT(sqInt) primUnsignedWordAtPut(void);
EXPORT(sqInt) primVarArgsCallOutDoubleReturn(void);
EXPORT(sqInt) primVarArgsCallOutFloatReturn(void);
EXPORT(sqInt) primVarArgsCallOutIntegralReturn(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt sizeField(sqInt alienOop);
static sqInt startOfByteData(sqInt rcvr);
static sqInt startOfData(sqInt alienOop);
static sqInt startOfDatawithSize(sqInt rcvr, sqInt sizeField);


/*** Variables ***/

#if defined(SQUEAK_BUILTIN_PLUGIN)

# define isIntegerObject(oop) ((oop) & 1)
# define integerObjectOf(value) ((((usqInt) value) << NumSmallIntegerTagBits) | 1)
# define integerValueOf(oop) ((oop) >> NumSmallIntegerTagBits)

# if SPURVM
extern sqInt classIndexOf(sqInt);
#	define LargeNegativeIntegerClassIndex 32
#	define LargePositiveIntegerClassIndex 33
#	if BytesPerOop == 4
#	  define isImmediate(oop) ((oop) & 3)
#	else
#	  define isImmediate(oop) ((oop) & 7)
#	endif
#	define isKindOfInteger(oop) (isImmediate(oop) ? isIntegerObject(oop) : (unsigned)(classIndexOf(oop) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeIntegerObject(oop) (!isImmediate(oop) && (unsigned)(classIndexOf(oop) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeNegativeIntegerObject(oop) (!isImmediate(oop) && classIndexOf(oop) == LargeNegativeIntegerClassIndex)
#	define isLargePositiveIntegerObject(oop) (!isImmediate(oop) && classIndexOf(oop) == LargePositiveIntegerClassIndex)
# endif /* SPURVM */
#endif /* defined(SQUEAK_BUILTIN_PLUGIN) */

#if !defined(isKindOfInteger)
# define isLargeNegativeIntegerObject(oop) (fetchClassOf(oop) == classLargeNegativeInteger())
# define isLargePositiveIntegerObject(oop) (fetchClassOf(oop) == classLargePositiveInteger())
# define isLargeIntegerObject(oop) (isLargeNegativeIntegerObject(oop) || isLargePositiveIntegerObject(oop))
# define isKindOfInteger(oop) (isIntegerObject(oop) || isLargeNegativeIntegerObject(oop) || isLargePositiveIntegerObject(oop))
#endif

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*classAlien)(void);
static sqInt (*classArray)(void);
static sqInt (*classLargeNegativeInteger)(void);
static sqInt (*classLargePositiveInteger)(void);
static sqInt (*classSemaphore)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static double (*floatValueOf)(sqInt oop);
static sqInt * (*getStackPointer)(void);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
#if !defined(integerObjectOf)
static sqInt (*integerObjectOf)(sqInt value);
#endif
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static void * (*ioLoadModuleOfLength)(sqInt moduleNameIndex, sqInt moduleLength);
static void * (*ioLoadSymbolOfLengthFromModule)(sqInt functionNameIndex, sqInt functionLength, void *moduleHandle);
static sqInt (*isKindOfClass)(sqInt oop, sqInt aClass);
static sqInt (*isArray)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isInMemory)(sqInt address);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
#if IMMUTABILITY
static sqInt (*isOopImmutable)(sqInt oop);
#endif /* IMMUTABILITY */
static sqInt (*isWordsOrBytes)(sqInt oop);
static sqInt (*methodArgumentCount)(void);
static sqInt (*methodReturnFloat)(double aFloat);
static sqInt (*methodReturnInteger)(sqInt integer);
static sqInt (*methodReturnReceiver)(void);
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*nilObject)(void);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static usqInt (*positive32BitValueOf)(sqInt oop);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static usqLong (*positive64BitValueOf)(sqInt oop);
static usqIntptr_t (*positiveMachineIntegerValueOf)(sqInt oop);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*returnAsThroughCallbackContext)(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt (*signalNoResume)(sqInt aSemaphore);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static int (*signed32BitValueOf)(sqInt oop);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqLong (*signed64BitValueOf)(sqInt oop);
static sqIntptr_t (*signedMachineIntegerValueOf)(sqInt oop);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static usqIntptr_t (*stackPositiveMachineIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt byteSizeOf(sqInt oop);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classSemaphore(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt fetchClassOf(sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern double floatValueOf(sqInt oop);
extern sqInt * getStackPointer(void);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
#if !defined(integerObjectOf)
extern sqInt integerObjectOf(sqInt value);
#endif
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern void * ioLoadModuleOfLength(sqInt moduleNameIndex, sqInt moduleLength);
extern void * ioLoadSymbolOfLengthFromModule(sqInt functionNameIndex, sqInt functionLength, void *moduleHandle);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isInMemory(sqInt address);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
#if IMMUTABILITY
#if IMMUTABILITY
extern sqInt isOopImmutable(sqInt oop);
#endif /* IMMUTABILITY */
#else
# define isOopImmutable(oop) 0
#endif
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt methodArgumentCount(void);
extern sqInt methodReturnFloat(double aFloat);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnReceiver(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt nilObject(void);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern usqInt positive32BitValueOf(sqInt oop);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
extern sqInt signalNoResume(sqInt aSemaphore);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern int signed32BitValueOf(sqInt oop);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "IA32ABI VMMaker.oscog-eem.3453 " INT_EXT;


/*** Methods ***/


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	Answer if the indices byteIndex to byteIndex + length - 1 are valid
	zero-relative indices into the rcvr.
	Beware! There be dragons here. The form below (byteIndex <= (dataSize abs
	- length)) is used
	because byteIndex + length could overflow, whereas (dataSize abs - length)
	can't. We *don't* use the
	obvious optimization
	^dataSize = 0 or: [byteIndex asUnsignedInteger <= (dataSize abs - length)]
	because with C's Usual Arithmetic Conversions
	5. Otherwise, both operands are converted to the unsigned integer type
	corresponding to the type of the operand with signed integer type.
	means that the comparison will be unsigned, and if length > dataSize abs
	then dataSize abs - length is large and positive. */

	/* IA32ABIPlugin>>#index:length:inRange: */
static sqInt
indexlengthinRange(sqInt byteIndex, sqInt length, sqInt rcvr)
{
    sqInt dataSize;

	dataSize = longAt(rcvr + BaseHeaderSize);
	return (dataSize == 0)
	 || ((byteIndex >= 0)
	 && (byteIndex <= ((SQABS(dataSize)) - length)));
}


/*	Answer if oop is an Alien. We could ask if isWordsOrBytes: first, but that
	doesn't help. We still have to do the is:KindOf: walk.
	We're not interested in fast falsehood, but as fast as possible truth, and
	with the current API this is it. */

	/* InterpreterPlugin>>#isAlien: */
static sqInt
isAlien(sqInt oop)
{
	return isKindOfClass(oop, classAlien());
}


/*	Answer the unsigned 32-bit (or 64-bit) integer comprising the address
	field (the second 32-bit or 64-bit field).
 */
/*	<Alien> primAddressField ^<Integer>
	<primitive: 'primAddressField' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primAddressField */
EXPORT(sqInt)
primAddressField(void)
{
    sqInt rcvr;
    sqInt value;

	rcvr = stackValue(0);
	value = longAt((rcvr + BaseHeaderSize) + BytesPerOop);
	return methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(value)
		: positive32BitIntegerFor(value)));
}


/*	Store an unsigned integer into the size field (the second 32/64 bit field;
	little endian).
 */
/*	<Alien> addressFieldPut: value <Integer> ^<Integer>
	<primitive: 'primAddressFieldPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primAddressFieldPut */
EXPORT(sqInt)
primAddressFieldPut(void)
{
    sqInt rcvr;
    usqIntptr_t value;
    sqInt valueOop;

	valueOop = stackValue(0);
	rcvr = stackValue(1);
	value = positiveMachineIntegerValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	longAtput((rcvr + BaseHeaderSize) + BytesPerOop, value);
	return methodReturnValue(valueOop);
}


/*	Copy some number of bytes from the receiver starting at the first index
	into some destination
	object starting at the second index. The destination may be an Aliens or a
	bit-indexable object.
	The primitive will have the following signature:
	<Alien>
	primCopyFrom: start <Integer>
	to: stop <Integer>
	into: destination <Alien | indexableByteSubclass et al>
	startingAt: destStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	 */

	/* IA32ABIPlugin>>#primAlienCopyInto */
EXPORT(sqInt)
primAlienCopyInto(void)
{
    sqInt alien;
    sqInt dest;
    sqInt destAddr;
    sqInt destStart;
    sqInt myLength;
    sqInt src;
    sqInt start;
    sqInt stop;
    sqInt totalLength;


	/* Unchecked! */
	alien = stackValue(4);
	start = stackValue(3);
	stop = stackValue(2);
	dest = stackValue(1);
	destStart = stackValue(0);
	if (!((isIntegerObject(start))
		 && ((isIntegerObject(stop))
		 && ((isIntegerObject(destStart))
		 && (isWordsOrBytes(dest)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	start = integerValueOf(start);
	stop = integerValueOf(stop);
	destStart = integerValueOf(destStart);
	myLength = longAt(alien + BaseHeaderSize);
	src = ((/* begin startOfData:withSize: */
	(myLength > 0
	? (alien + BaseHeaderSize) + BytesPerOop
	: longAt((alien + BaseHeaderSize) + BytesPerOop))) + start) - 1;
	if (isKindOfClass(dest, classAlien())) {
		totalLength = longAt(dest + BaseHeaderSize);
		destAddr = ((/* begin startOfData:withSize: */
	(totalLength > 0
	? (dest + BaseHeaderSize) + BytesPerOop
	: longAt((dest + BaseHeaderSize) + BytesPerOop))) + destStart) - 1;
		if (totalLength == 0) {
			/* no bounds checks for zero-sized (pointer) Aliens */
			totalLength = stop;
		}
		else {
			totalLength = SQABS(totalLength);
		}
	}
	else {
		totalLength = byteSizeOf(dest);
		destAddr = ((dest + BaseHeaderSize) + destStart) - 1;
	}
	if (!(((start >= 1)
		 && (((start - 1) <= stop)
		 && (stop <= (SQABS(myLength)))))
		 && (((stop - start) + 1) <= totalLength))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(dest)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	memmove(((void *)destAddr), ((void *)src), (stop - start) + 1);
	methodReturnReceiver();
	return 0;
}


/*	Copy some number of bytes from some source object starting at the index
	into the receiver destination object from startIndex to stopIndex. The
	source and destination may be Aliens or byte-indexable objects. The
	primitive will have
	either of the following signatures:
	<Alien | indexableByteSubclass | indexableWordSubclass>
	primReplaceFrom: start <Integer>
	to: stop <Integer>
	with: replacement <Alien | indexableByteSubclass | indexableWordSubclass |
	Integer> startingAt: repStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	<Anywhere>
	primReplaceIn: dest <Alien | indexableByteSubclass |
	indexableWordSubclass> from: start <Integer>
	to: stop <Integer>
	with: replacement <Alien | indexableByteSubclass | indexableWordSubclass |
	Integer> startingAt: repStart <Integer> ^<self>
	<primitive: 'primitiveAlienReplace' error: errorCode module: 'IA32ABI'>
	 */

	/* IA32ABIPlugin>>#primAlienReplace */
EXPORT(sqInt)
primAlienReplace(void)
{
    sqInt array;
    sqInt dest;
    sqInt isOnExecutablePage;
    sqInt repl;
    sqInt replStart;
    sqInt src;
    sqInt start;
    sqInt stop;
    sqInt totalLength;


	/* Unchecked! */
	array = stackValue(4);
	start = stackValue(3);
	stop = stackValue(2);
	repl = stackValue(1);
	replStart = stackValue(0);
	if (!((isIntegerObject(start))
		 && ((isIntegerObject(stop))
		 && ((isIntegerObject(replStart))
		 && (isWordsOrBytes(repl)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	start = integerValueOf(start);
	stop = integerValueOf(stop);
	replStart = integerValueOf(replStart);
	if (isKindOfClass(array, classAlien())) {
		totalLength = longAt(array + BaseHeaderSize);
		dest = ((/* begin startOfData:withSize: */
	(totalLength > 0
	? (array + BaseHeaderSize) + BytesPerOop
	: longAt((array + BaseHeaderSize) + BytesPerOop))) + start) - 1;
		if (totalLength == 0) {
			/* no bounds checks for zero-sized (pointer) Aliens */
			totalLength = stop;
		}
		else {
			totalLength = SQABS(totalLength);
		}
	}
	else {
		totalLength = byteSizeOf(array);
		dest = ((array + BaseHeaderSize) + start) - 1;
	}
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && (stop <= totalLength)))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isKindOfInteger(repl)) {
		src = ((positiveMachineIntegerValueOf(repl)) + replStart) - 1;
		if (failed()) {
			return primitiveFailFor(PrimErrBadArgument);
		}
	}
	else {
		if (isKindOfClass(repl, classAlien())) {
			totalLength = longAt(repl + BaseHeaderSize);
			src = ((/* begin startOfData:withSize: */
	(totalLength > 0
	? (repl + BaseHeaderSize) + BytesPerOop
	: longAt((repl + BaseHeaderSize) + BytesPerOop))) + replStart) - 1;
			if (totalLength == 0) {
				/* no bounds checks for zero-sized (pointer) Aliens */
				totalLength = (stop - start) + replStart;
			}
			else {
				totalLength = SQABS(totalLength);
			}
		}
		else {
			if (!(isWordsOrBytes(repl))) {
				return primitiveFailFor(PrimErrBadArgument);
			}
			totalLength = byteSizeOf(repl);
			src = ((repl + BaseHeaderSize) + replStart) - 1;
		}
		if (!((replStart >= 1)
			 && (((stop - start) + replStart) <= totalLength))) {
			return primitiveFailFor(PrimErrBadIndex);
		}
	}
	if (isOopImmutable(array)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	/* Use memmove to allow source and destination to overlap */
	isOnExecutablePage = ifIsWithinExecutablePageMakePageWritable(((void *)dest));
	memmove(((void *)dest), ((void *)src), (stop - start) + 1);
	if (isOnExecutablePage) {
		makePageExecutableAgain(((void *)dest));
	}
	methodReturnReceiver();
	return 0;
}


/*	Answer an executable page; for callback thunks.
	If Alien is installed answer the result as an Alien.
	If not, answer an Array as { address. size }. */
/*	primAllocateExecutablePage ^<Alien|Array>
	<primitive: 'primAllocateExecutablePage' error: errorCode module:
	'IA32ABI'> 
 */

	/* IA32ABIPlugin>>#primAllocateExecutablePage */
EXPORT(sqInt)
primAllocateExecutablePage(void)
{
    sqIntptr_t byteSize;
    void *mem;
    sqInt memInteger;
    sqIntptr_t *ptr;
    sqInt result;
    sqInt theClassAlien;

	byteSize = 0;
	if (((theClassAlien = classAlien())) == (nilObject())) {
		theClassAlien = null;
	}
	mem = allocateExecutablePage((&byteSize));
	if (mem == 0) {
		return primitiveFailFor(PrimErrNoCMemory);
	}
	if (theClassAlien == null) {
		result = instantiateClassindexableSize(classArray(), 2);
		if ((result == null)
		 || (failed())) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		
#if SPURVM
		memInteger = 
		/* begin positiveMachineIntegerFor: */
(BytesPerWord == 8
			? positive64BitIntegerFor(((usqInt)mem))
			: positive32BitIntegerFor(((usqInt)mem)));
#else /* SPURVM */
		pushRemappableOop(result);
		memInteger = 
		/* begin positiveMachineIntegerFor: */
(BytesPerWord == 8
			? positive64BitIntegerFor(((usqInt)mem))
			: positive32BitIntegerFor(((usqInt)mem)));
		result = popRemappableOop();
#endif /* SPURVM */
		if ((memInteger == null)
		 || (failed())) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue(0, result, memInteger);
		storePointerofObjectwithValue(1, result, integerObjectOf(byteSize));
	}
	else {
		result = instantiateClassindexableSize(theClassAlien, 2 * BytesPerWord);
		if ((result == null)
		 || (failed())) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		ptr = ((sqIntptr_t *) (firstIndexableField(result)));
		ptr[0] = (0 - byteSize);
		ptr[1] = (((sqIntptr_t) mem));
	}
	methodReturnValue(result);
	return 0;
}


/*	Free the memory referenced by the receiver, an Alien. */
/*	proxy <Alien> primFree ^<Alien>
	<primitive: 'primBoxedFree' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primBoxedFree */
EXPORT(sqInt)
primBoxedFree(void)
{
    sqIntptr_t addr;
    sqIntptr_t *ptr;
    sqInt rcvr;
    sqIntptr_t sizeField;

	rcvr = stackValue(0);
	if (!((byteSizeOf(rcvr)) >= (2 * BytesPerOop))) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	ptr = ((sqIntptr_t *) (firstIndexableField(rcvr)));
	sizeField = ptr[0];
	/* Don't you dare to free Squeak's memory! */
	addr = ptr[1];
	if ((sizeField >= 0)
	 || ((addr == 0)
	 || (isInMemory(addr)))) {
		return primitiveFailFor(PrimErrInappropriate);
	}
	free(((void *)addr));
	ptr[0] = 0;
	ptr[1] = 0;
	return 0;
}


/*	Call a foreign function that answers a double-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutDoubleReturn' error: errorCode module: 'IA32ABI'>.
	Answer result. If result is an Alien the value answered by the call will
	be assigned to result.
 */

	/* IA32ABIPlugin>>#primCallOutDoubleReturn */
EXPORT(sqInt)
primCallOutDoubleReturn(void)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = methodArgumentCount();
#  if STACKVM
	/* In the STACKVM stacks grow down */
	/* ptr to 0th arg */
	/* nargs negated to imply stack direction */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32DoubleReturn(((getStackPointer()) + mac) - 2, 1 - mac, mac, mac - 1);
#  else // STACKVM
	/* ptr to 0th arg */
	/* nargs */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32DoubleReturn(((getStackPointer()) - mac) + 2, mac - 1, mac, mac - 1);
#  endif // STACKVM

	if (errCode != 0) {
		return primitiveFailFor(errCode);
	}
	result = stackValue(mac - 1);
	popthenPush(mac + 1, result);
	return 0;
}


/*	Call a foreign function that answers a single-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutFloatReturn' error: errorCode module: 'IA32ABI'>.
	Answer result. If result is an Alien the value answered by the call will
	be assigned to result.
 */

	/* IA32ABIPlugin>>#primCallOutFloatReturn */
EXPORT(sqInt)
primCallOutFloatReturn(void)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = methodArgumentCount();
#  if STACKVM
	/* In the STACKVM stacks grow down */
	/* ptr to 0th arg */
	/* nargs negated to imply stack direction */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32FloatReturn(((getStackPointer()) + mac) - 2, 1 - mac, mac, mac - 1);
#  else // STACKVM
	/* ptr to 0th arg */
	/* nargs */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32FloatReturn(((getStackPointer()) - mac) + 2, mac - 1, mac, mac - 1);
#  endif // STACKVM

	if (errCode != 0) {
		return primitiveFailFor(errCode);
	}
	result = stackValue(mac - 1);
	popthenPush(mac + 1, result);
	return 0;
}


/*	Call a foreign function that answers an integral result in %eax (and
	possibly %edx)
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object> with:
	firstArg <Alien | Integer> ... with: lastArg <Alien | Integer> ^<Alien>
	<primitive: 'primCallOutIntegralReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primCallOutIntegralReturn */
EXPORT(sqInt)
primCallOutIntegralReturn(void)
{
    sqInt errCode;
    sqInt mac;
    sqInt result;

	mac = methodArgumentCount();
#  if STACKVM
	/* In the STACKVM stacks grow down */
	/* ptr to 0th arg */
	/* nargs negated to imply stack direction */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32IntegralReturn(((getStackPointer()) + mac) - 2, 1 - mac, mac, mac - 1);
#  else // STACKVM
	/* ptr to 0th arg */
	/* nargs */
	/* funcOffset */
	/* resultOffset */
	errCode = callIA32IntegralReturn(((getStackPointer()) - mac) + 2, mac - 1, mac, mac - 1);
#  endif // STACKVM

	if (errCode != 0) {
		return primitiveFailFor(errCode);
	}
	result = stackValue(mac - 1);
	popthenPush(mac + 1, result);
	return 0;
}


/*	calloc (malloc + zero-fill) arg bytes. */
/*	primCalloc: byteSize <Integer> ^<Integer>
	<primitive: 'primCalloc' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primCalloc */
EXPORT(sqInt)
primCalloc(void)
{
    usqInt addr;
    sqInt byteSize;

	byteSize = stackIntegerValue(0);
	if ((failed())
	 || (byteSize <= 0)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ((usqInt)(calloc(1, byteSize)));
	if (addr == 0) {
		return primitiveFailFor(PrimErrNoCMemory);
	}
	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(addr)
		: positive32BitIntegerFor(addr)));
	return 0;
}


/*	Answer the 64-bit double starting at the given byte offset (little
	endian). 
 */
/*	<Alien> doubleAt: index <Integer> ^<Float>
	<primitive: 'primDoubleAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primDoubleAt */
EXPORT(sqInt)
primDoubleAt(void)
{
    usqIntptr_t byteOffset;
    double floatValue;
    sqInt rcvr;
    sqInt startAddr;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	memcpy((&floatValue), ((void *)(startAddr + byteOffset)), sizeof(floatValue));
	methodReturnFloat(floatValue);
	return 0;
}


/*	Store a double into 64 bits starting at the given byte offset (little
	endian). 
 */
/*	<Alien> doubleAt: index <Integer> put: value <Float | Integer> ^<Float |
	Integer> <primitive: 'primDoubleAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primDoubleAtPut */
EXPORT(sqInt)
primDoubleAtPut(void)
{
    usqIntptr_t byteOffset;
    double floatValue;
    sqInt rcvr;
    sqInt startAddr;
    sqInt valueOop;

	valueOop = stackValue(0);
	if (isIntegerObject(valueOop)) {
		floatValue = ((double) (integerValueOf(valueOop)));
	}
	else {
		floatValue = ((double) (floatValueOf(valueOop)));
	}
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	memcpy(((void *)(startAddr + byteOffset)), (&floatValue), sizeof(floatValue));
	methodReturnValue(valueOop);
	return 0;
}

	/* IA32ABIPlugin>>#primDrainOSEventQueue */
EXPORT(sqInt)
primDrainOSEventQueue(void)
{

#  if NewspeakVM
	ioDrainEventQueue();
#  endif

	return 0;
}


/*	Answer the 32-bit float starting at the given byte offset (little endian). */
/*	<Alien> floatAt: index <Integer> ^<Float>
	<primitive: 'primFloatAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primFloatAt */
EXPORT(sqInt)
primFloatAt(void)
{
    usqIntptr_t byteOffset;
    float floatValue;
    sqInt rcvr;
    sqInt startAddr;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	memcpy((&floatValue), ((void *)(startAddr + byteOffset)), sizeof(floatValue));
	methodReturnFloat(floatValue);
	return 0;
}


/*	Store a float into 32 bits starting at the given byte offset (little
	endian). 
 */
/*	<Alien> floatAt: index <Integer> put: value <Float | Integer> ^<Float |
	Integer> <primitive: 'primFloatAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primFloatAtPut */
EXPORT(sqInt)
primFloatAtPut(void)
{
    usqIntptr_t byteOffset;
    float floatValue;
    sqInt rcvr;
    sqInt startAddr;
    sqInt valueOop;

	valueOop = stackValue(0);
	if (isIntegerObject(valueOop)) {
		floatValue = ((double) (integerValueOf(valueOop)));
	}
	else {
		floatValue = ((double) (floatValueOf(valueOop)));
	}
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	memcpy(((void *)(startAddr + byteOffset)), (&floatValue), sizeof(floatValue));
	methodReturnValue(valueOop);
	return 0;
}


/*	Free the memory referenced by the argument, an integer. */
/*	<Anywhere> primFree: address <Integer>
	<primitive: 'primFree' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primFree */
EXPORT(sqInt)
primFree(void)
{
    usqIntptr_t addr;

	addr = stackPositiveMachineIntegerValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((addr == 0)
	 || (isInMemory(addr))) {
		return primitiveFailFor(PrimErrInappropriate);
	}
	free(((void *)addr));
	pop(1);
	return 0;
}


/*	Answer the address of the int inIOProcessEvents flag. This can be used to
	disable invocation of ioProcessEvents and is for backward-compatibility.
	Please use the core VM primitiveEventProcessingControl in new code. */

	/* IA32ABIPlugin>>#primInIOProcessEventsFlagAddress */
EXPORT(sqInt)
primInIOProcessEventsFlagAddress(void)
{
    extern int inIOProcessEvents;

	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)((&inIOProcessEvents))))
		: positive32BitIntegerFor(((usqInt)((&inIOProcessEvents))))));
	return 0;
}


/*	Attempt to find the address of a symbol in a loaded library.
	The primitive can have a signature either of the form:
	<Anywhere> primInLibrary: libraryHandle <Alien> findSymbol: symbolName
	<String> ^<Integer>
	<primitive: 'primInLibraryFindSymbol' error: errorCode module: 'IA32ABI'>
	or:
	libraryHandle <Alien> primFindSymbol: symbolName <String> ^<Integer>
	<primitive: 'primInLibraryFindSymbol' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primInLibraryFindSymbol */
EXPORT(sqInt)
primInLibraryFindSymbol(void)
{
    void *address;
    sqInt functionName;
    sqInt libraryProxy;

	functionName = stackValue(0);
	libraryProxy = stackValue(1);
	if (!((isKindOfClass(libraryProxy, classAlien()))
		 && (((byteSizeOf(libraryProxy)) >= (2 * BytesPerOop))
		 && (isBytes(functionName))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	address = ioLoadSymbolOfLengthFromModule(((sqInt) (firstIndexableField(functionName))), byteSizeOf(functionName), ((void *)(longAt((libraryProxy + BaseHeaderSize) + BytesPerOop))));
	if ((failed())
	 || (address == 0)) {
		return primitiveFailFor(PrimErrNotFound);
	}
	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)address))
		: positive32BitIntegerFor(((usqInt)address))));
	return 0;
}


/*	Attempt to load a library of the given name. The primitive will have a
	signature of the form:
	<Anywhere> primLoadLibrary: libraryName <String> ^<Integer>
	<primitive: 'primLoadLibrary' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primLoadLibrary */
EXPORT(sqInt)
primLoadLibrary(void)
{
    void *libraryHandle;
    sqInt libraryName;

	libraryName = stackValue(0);
	if (!(isBytes(libraryName))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	libraryHandle = ioLoadModuleOfLength(((sqInt) (firstIndexableField(libraryName))), byteSizeOf(libraryName));
	if (libraryHandle == 0) {
		return primitiveFailFor(PrimErrNotFound);
	}
	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)libraryHandle))
		: positive32BitIntegerFor(((usqInt)libraryHandle))));
	return 0;
}


/*	Malloc arg bytes. */
/*	primMalloc: byteSize <Integer> <^Integer>
	<primitive: 'primMalloc' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primMalloc */
EXPORT(sqInt)
primMalloc(void)
{
    usqInt addr;
    sqInt byteSize;

	byteSize = stackIntegerValue(0);
	if ((failed())
	 || (byteSize <= 0)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ((usqInt)(malloc(byteSize)));
	if (addr == 0) {
		return primitiveFailFor(PrimErrNoCMemory);
	}
	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(addr)
		: positive32BitIntegerFor(addr)));
	return 0;
}


/*	This is here only for debugging; it is really useful in predicting the
	behaviour of primReturnAsFromContextThrough.
 */

	/* IA32ABIPlugin>>#primMostRecentCallbackContext */
EXPORT(sqInt)
primMostRecentCallbackContext(void)
{
	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(((usqInt)(getMostRecentCallbackContext())))
		: positive32BitIntegerFor(((usqInt)(getMostRecentCallbackContext())))));
	return 0;
}


/*	Fetch an oop from 32 or 64 bits starting at the given byte offset (little
	endian). 
 */
/*	THIS IS A HUGE SECURITY HOLE, BUT FULL CALLBACKS DEMAND IT */
/*	<Alien> oopAt: index <Integer> ^<Object>
	<primitive: 'oopAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primOopAt */
EXPORT(sqInt)
primOopAt(void)
{
    sqInt *addr;
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	/* WE SHOULD DO VALIDATION HERE!  FOR NOW WE PUNT, BUT THIS REALLY DOES REQUIRE A GOOD ANSWER!! */
	addr = ((sqInt *) (startAddr + byteOffset));
	return methodReturnValue(addr[0]);
}


/*	Store an oop into 32 or 64 bits starting at the given byte offset (little
	endian). 
 */
/*	THIS IS A HUGE SECURITY HOLE, BUT FULL CALLBACKS DEMAND IT */
/*	<Alien> oopAt: index <Integer> put: value <Object> ^<Object>
	<primitive: 'oopAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primOopAtPut */
EXPORT(sqInt)
primOopAtPut(void)
{
    sqInt *addr;
    usqIntptr_t byteOffset;
    sqInt oop;
    sqInt rcvr;
    sqInt startAddr;

	oop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	addr = ((sqInt *) (startAddr + byteOffset));
	addr[0] = oop;
	return methodReturnValue(oop);
}


/*	Return a result from a callback to the callback's callee. The primitive
	has a signature of either of the forms:
	result <VMCallbackContext32/64>
	primReturnAs: returnTypeCode <Integer>
	FromContext: callbackContext <Context>
	result <VMCallbackContext32/64>
	primSignal: aSemaphore <Semaphore>
	andReturnAs: returnTypeCode <Integer>
	FromContext: callbackContext <Context>
	<primitive: 'primReturnAsFromContextThrough' error: errorCode module:
	'IA32ABI'>. If of the second form answer false if this is not the most
	recent callback, and in any case
	signal aSemaphore (Alien's lifoCallbackSemaphore), releasing all processes
	waiting on it,
	so as to implement LIFO ordering of callbacks. */

	/* IA32ABIPlugin>>#primReturnAsFromContextThrough */
EXPORT(sqInt)
primReturnAsFromContextThrough(void)
{
    sqInt argCount;
    int isMostRecentCallback;
    sqInt lifoCallbackSemaphore;
    VMCallbackContext *vmCallbackContext;

	argCount = methodArgumentCount();
	assert(isWordsOrBytes(stackValue(argCount)));
	vmCallbackContext = ((VMCallbackContext *) (startOfData(stackValue(argCount))));
	isMostRecentCallback = vmCallbackContext == (getMostRecentCallbackContext());
	if (argCount == 3) {
		/* More error checking is done in StackInterpreter>>#returnAs:ThroughCallback:Context: below... */
		lifoCallbackSemaphore = stackValue(2);
		if (!((fetchClassOf(lifoCallbackSemaphore)) == (classSemaphore()))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		signalNoResume(lifoCallbackSemaphore);
		if (!isMostRecentCallback) {
			return methodReturnValue(falseObject());
		}
	}
	else {
		assert((methodArgumentCount()) == 2);
		if (!isMostRecentCallback) {
			return primitiveFailFor(PrimErrInappropriate);
		}
	}
	if (!(returnAsThroughCallbackContext(stackValue(1), vmCallbackContext, stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	return 0;
}


/*	Return a result from a callback to the callback's callee. The primitive
	has a signature of either of the forms:
	result <FFICallbackResult> primReturnFromContext: callbackContext
	<MethodContext> through: jmpBuf <Integer>
	result <FFICallbackResult> primSignal: aSemaphore <Semaphore>
	andReturnFromContext: callbackContext <MethodContext> through: jmpBuf
	<Integer> <primitive: 'primReturnFromContextThrough' error: errorCode
	module: 'IA32ABI'>.
	If of the second form answer true if this is not the most recent callback,
	and signal aSemaphore
	if it is, so as to implement LIFO ordering of callbacks. */

	/* IA32ABIPlugin>>#primReturnFromContextThrough */
#if OBSOLETE_ALIEN_PRIMITIVES
EXPORT(sqInt)
primReturnFromContextThrough(void)
{
    int isMostRecent;
    sqInt mac;
    VMCallbackContext *vmCallbackContext;
    VMCallbackReturnValue *vmCallbackReturnValue;

	vmCallbackContext = ((VMCallbackContext *) (positiveMachineIntegerValueOf(stackValue(0))));
	if ((failed())
	 || (vmCallbackContext == 0)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (((mac = methodArgumentCount())) == 3) {
		isMostRecent = vmCallbackContext == (getMostRecentCallbackContext());
		if (!isMostRecent) {
			methodReturnValue(trueObject());
			return null;
		}
		if (!((fetchClassOf(stackValue(2))) == (classSemaphore()))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		while (!(signalNoResume(stackValue(2)))) {
		}
	}
	vmCallbackReturnValue = ((VMCallbackReturnValue *) (startOfData(stackValue(mac))));
	memcpy((&((vmCallbackContext->rvs))), (&((vmCallbackReturnValue->crvrvs))), sizeof((vmCallbackContext->rvs)));
	if (!(returnAsThroughCallbackContext(integerObjectOf(((vmCallbackReturnValue->type)) + 1), vmCallbackContext, stackValue(1)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	return 0;
}
#endif /* OBSOLETE_ALIEN_PRIMITIVES */


/*	Answer the signed 8-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> unsignedByteAt: index <Integer> ^<Integer>
	<primitive: 'primSignedByteAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedByteAt */
EXPORT(sqInt)
primSignedByteAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    signed char value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = byteAt(startAddr + byteOffset);
	return methodReturnInteger(value);
}


/*	Store a signed integer into 8 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedByteAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedByteAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedByteAtPut */
EXPORT(sqInt)
primSignedByteAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = signed32BitValueOf(valueOop);
	if ((failed())
	 || ((value < -128)
	 || (value > 0x7F))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	byteAtput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Answer the signed 32-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedLongAt: index <Integer> ^<Integer>
	<primitive: 'primSignedLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongAt */
EXPORT(sqInt)
primSignedLongAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = long32At(startAddr + byteOffset);
	return methodReturnValue(signed32BitIntegerFor(value));
}


/*	Store a signed integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedLongAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongAtPut */
EXPORT(sqInt)
primSignedLongAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = signed32BitValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	long32Atput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Answer the signed 64-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedLongLongAt: index <Integer> ^<Integer>
	<primitive: 'primSignedLongLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongLongAt */
EXPORT(sqInt)
primSignedLongLongAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    long long value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = (*((long long *) (startAddr + byteOffset)));
	return methodReturnValue(signed64BitIntegerFor(value));
}


/*	Store a signed integer into 64 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedLongLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedLongLongAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedLongLongAtPut */
EXPORT(sqInt)
primSignedLongLongAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqLong value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = signed64BitValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	(*((long long *) (startAddr + byteOffset)) = value);
	return methodReturnValue(valueOop);
}


/*	Answer the signed 32-bit integer starting at the given byte offset (little
	endian). 
 */
/*	<Alien> signedShortAt: index <Integer> ^<Integer>
	<primitive: 'primSignedShortAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedShortAt */
EXPORT(sqInt)
primSignedShortAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    short value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = shortAt(startAddr + byteOffset);
	return methodReturnInteger(value);
}


/*	Store a signed integer into 16 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedShortAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedShortAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedShortAtPut */
EXPORT(sqInt)
primSignedShortAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = signed32BitValueOf(valueOop);
	if ((failed())
	 || ((value < -32768)
	 || (value > 0x7FFF))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	shortAtput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Answer the signed word starting at the given byte offset (little endian). */
/*	<Alien> signedWordAt: index <Integer> ^<Integer>
	<primitive: 'primSignedWordAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedWordAt */
EXPORT(sqInt)
primSignedWordAt(void)
{
    usqIntptr_t addr;
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;
    sqIntptr_t valueOop;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	addr = startAddr + byteOffset;
	value = longAt(addr);
	valueOop = signedMachineIntegerValueOf(value);
	return methodReturnValue(valueOop);
}


/*	Store a signed integer into the word starting at the given byte offset
	(little endian).
 */
/*	<Alien> signedWordAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primSignedWordAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSignedWordAtPut */
EXPORT(sqInt)
primSignedWordAtPut(void)
{
    usqIntptr_t addr;
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqIntptr_t value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = signedMachineIntegerValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	addr = startAddr + byteOffset;
	longAtput(addr, value);
	return methodReturnValue(valueOop);
}


/*	Answer the signed 32- or 64-bit integer comprising the size field (the
	first 32- or 64-bit field).
 */
/*	<Alien> primSizeField ^<Integer>
	<primitive: 'primSizeField' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSizeField */
EXPORT(sqInt)
primSizeField(void)
{
    sqInt rcvr;
    sqInt valueOop;

	rcvr = stackValue(0);
	valueOop = (BytesPerWord == 8
		? signed64BitIntegerFor(((sqLong) (longAt(rcvr + BaseHeaderSize))))
		: signed32BitIntegerFor(((int) (longAt(rcvr + BaseHeaderSize)))));
	return methodReturnValue(valueOop);
}


/*	Store a signed integer into the size field (the first 32 bit field; little
	endian). 
 */
/*	<Alien> sizeFieldPut: value <Integer> ^<Integer>
	<primitive: 'primSizeFieldPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primSizeFieldPut */
EXPORT(sqInt)
primSizeFieldPut(void)
{
    sqInt rcvr;
    sqIntptr_t value;
    sqInt valueOop;

	valueOop = stackValue(0);
	rcvr = stackValue(1);
	value = signedMachineIntegerValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (BytesPerWord == 8) {
		longAtput(rcvr + BaseHeaderSize, ((usqInt) value));
	}
	else {
		longAtput(rcvr + BaseHeaderSize, ((usqInt) value));
	}
	return methodReturnValue(valueOop);
}


/*	Answer the number of non-null bytes starting at index. If
	there isn't a null byte before the end of the object then the
	result will be the number of bytes from index to the end of
	the object, i.e. the result will be within the bounds of the object. */
/*	<Alien> primStrlenFrom: index <Integer> ^<Integer>
	<primitive: 'primStrlenFromStartIndex' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primStrlenFromStartIndex */
EXPORT(sqInt)
primStrlenFromStartIndex(void)
{
    usqIntptr_t byteOffset;
    sqInt index;
    sqInt limit;
    char *ptr;
    sqInt rcvr;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	limit = longAt(rcvr + BaseHeaderSize);
	ptr = ((char *) ((/* begin startOfData:withSize: */
	(limit > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset));
	if (limit == 0) {
		index = strlen(ptr);
	}
	else {
		limit = SQABS(limit);
		index = 0;
		while ((index < limit)
		 && ((ptr[index]) != 0)) {
			index += 1;
		}
	}
	methodReturnInteger(index);
	return 0;
}


/*	Answer the number of non-null bytes starting at the byte addressed by
	the 4-byte pointer at index. */
/*	<Alien> strlenThroughPointerAt: index <Integer> ^<Integer>
	<primitive: 'primStrlenThroughPointerAtIndex' error: errorCode module:
	'IA32ABI'> 
 */

	/* IA32ABIPlugin>>#primStrlenThroughPointerAtIndex */
EXPORT(sqInt)
primStrlenThroughPointerAtIndex(void)
{
    usqIntptr_t addr;
    usqIntptr_t byteOffset;
    sqInt rcvr;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	addr = (/* begin startOfData: */
	((longAt(rcvr + BaseHeaderSize)) > 0
	? (rcvr + BaseHeaderSize) + BytesPerOop
	: longAt((rcvr + BaseHeaderSize) + BytesPerOop))) + byteOffset;
	return methodReturnInteger(strlen(((char *) (longAt(addr)))));
}


/*	Answer the address of the entry-point for thunk callbacks:
	long thunkEntry(void *thunkp, long *stackp);
	This could be derived via loadModule: findSymbol: etc but that would
	preclude making the plugin internal. */

	/* IA32ABIPlugin>>#primThunkEntryAddress */
EXPORT(sqInt)
primThunkEntryAddress(void)
{
    sqIntptr_t address;

	address = ((sqIntptr_t)thunkEntry);
	methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(address)
		: positive32BitIntegerFor(address)));
	return 0;
}


/*	Answer the unsigned 8-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedByteAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedByteAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedByteAt */
EXPORT(sqInt)
primUnsignedByteAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned char value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = byteAt(startAddr + byteOffset);
	return methodReturnInteger(value);
}


/*	Store an unsigned integer into 8 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedByteAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedByteAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedByteAtPut */
EXPORT(sqInt)
primUnsignedByteAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    usqInt value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = positive32BitValueOf(valueOop);
	if ((failed())
	 || (value > 0xFF)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 1, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	byteAtput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Answer the unsigned 32-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongAt */
EXPORT(sqInt)
primUnsignedLongAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    int value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = long32At(startAddr + byteOffset);
	return methodReturnValue(positive32BitIntegerFor(value));
}


/*	Store an unsigned integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedLongAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongAtPut */
EXPORT(sqInt)
primUnsignedLongAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    usqInt value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = positive32BitValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 4, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	long32Atput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Answer the unsigned 64-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien>unsignedLongLongAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedLongLongAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongLongAt */
EXPORT(sqInt)
primUnsignedLongLongAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned long long value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = (*((unsigned long long *) (startAddr + byteOffset)));
	return methodReturnValue(positive64BitIntegerFor(value));
}


/*	Store a signed integer into 64 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedLongLongAt: index <Integer> put: value <Integer>
	^<Integer> <primitive: 'primUnSignedLongLongAtPut' error: errorCode
	module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedLongLongAtPut */
EXPORT(sqInt)
primUnsignedLongLongAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    usqLong value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = positive64BitValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 8, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	(*((unsigned long long *) (startAddr + byteOffset)) = value);
	return methodReturnValue(valueOop);
}


/*	Answer the unsigned 16-bit integer starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedShortAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedShortAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedShortAt */
EXPORT(sqInt)
primUnsignedShortAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    unsigned short value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = shortAt(startAddr + byteOffset);
	return methodReturnInteger(value);
}


/*	Store an unsigned integer into 16 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedShortAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedShortAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedShortAtPut */
EXPORT(sqInt)
primUnsignedShortAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    usqInt value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = positive32BitValueOf(valueOop);
	if ((failed())
	 || (value > 0xFFFF)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, 2, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	shortAtput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Answer the unsigned word starting at the given byte offset (little
	endian). 
 */
/*	<Alien> unsignedWordAt: index <Integer> ^<Integer>
	<primitive: 'primUnsignedWordAt' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedWordAt */
EXPORT(sqInt)
primUnsignedWordAt(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    sqInt value;

	byteOffset = (stackPositiveMachineIntegerValue(0)) - 1;
	rcvr = stackObjectValue(1);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	value = longAt(startAddr + byteOffset);
	return methodReturnValue(	/* begin positiveMachineIntegerFor: */
		(BytesPerWord == 8
		? positive64BitIntegerFor(value)
		: positive32BitIntegerFor(value)));
}


/*	Store an unsigned integer into 32 bits starting at the given byte offset
	(little endian).
 */
/*	<Alien> unsignedWordAt: index <Integer> put: value <Integer> ^<Integer>
	<primitive: 'primUnsignedWordAtPut' error: errorCode module: 'IA32ABI'> */

	/* IA32ABIPlugin>>#primUnsignedWordAtPut */
EXPORT(sqInt)
primUnsignedWordAtPut(void)
{
    usqIntptr_t byteOffset;
    sqInt rcvr;
    sqInt startAddr;
    usqIntptr_t value;
    sqInt valueOop;

	valueOop = stackValue(0);
	byteOffset = (stackPositiveMachineIntegerValue(1)) - 1;
	rcvr = stackObjectValue(2);
	value = positiveMachineIntegerValueOf(valueOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(indexlengthinRange(byteOffset, BytesPerOop, rcvr))) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	if (isOopImmutable(rcvr)) {
		return primitiveFailFor(PrimErrNoModification);
	}
	if (((startAddr = 
	/* begin startOfData: */
((longAt(rcvr + BaseHeaderSize)) > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop)))) == 0) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	longAtput(startAddr + byteOffset, value);
	return methodReturnValue(valueOop);
}


/*	Call a foreign function that answers a double-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutDoubleReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primVarArgsCallOutDoubleReturn */
EXPORT(sqInt)
primVarArgsCallOutDoubleReturn(void)
{
    sqInt array;
    sqInt errCode;
    sqInt mac;
    sqInt result;

	array = stackValue(0);
	if (!(isArray(array))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	mac = methodArgumentCount();
	/* ptr to 0th arg */
	/* nargs */
	/* func stackValue */
	/* result stackValue */
	errCode = callIA32DoubleReturn(firstIndexableField(array), stSizeOf(array), 2, 1);
	if (errCode != 0) {
		return primitiveFailFor(errCode);
	}
	result = stackValue(1);
	popthenPush(mac + 1, result);
	return 0;
}


/*	Call a foreign function that answers a single-precision floating-point
	result in %f0
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutFloatReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primVarArgsCallOutFloatReturn */
EXPORT(sqInt)
primVarArgsCallOutFloatReturn(void)
{
    sqInt array;
    sqInt errCode;
    sqInt mac;
    sqInt result;

	array = stackValue(0);
	if (!(isArray(array))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	mac = methodArgumentCount();
	/* ptr to 0th arg */
	/* nargs */
	/* func stackValue */
	/* result stackValue */
	errCode = callIA32FloatReturn(firstIndexableField(array), stSizeOf(array), 2, 1);
	if (errCode != 0) {
		return primitiveFailFor(errCode);
	}
	result = stackValue(1);
	popthenPush(mac + 1, result);
	return 0;
}


/*	Call a foreign function that answers an integral result in %eax (and
	possibly %edx)
	according to IA32-ish ABI rules. The primitive will have a signature of
	the form
	functionAddress <Alien> primFFICallResult: result <Alien|Object>
	withArguments: args <Array of: Alien | Integer> ^<Alien>
	<primitive: 'primVarArgsCallOutIntegralReturn' error: errorCode module:
	'IA32ABI'>. Answer result. If result is an Alien the value answered by the
	call will be assigned to result.
 */

	/* IA32ABIPlugin>>#primVarArgsCallOutIntegralReturn */
EXPORT(sqInt)
primVarArgsCallOutIntegralReturn(void)
{
    sqInt array;
    sqInt errCode;
    sqInt mac;
    sqInt result;

	array = stackValue(0);
	if (!(isArray(array))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	mac = methodArgumentCount();
	/* ptr to 0th arg */
	/* nargs */
	/* func stackValue */
	/* result stackValue */
	errCode = callIA32IntegralReturn(firstIndexableField(array), stSizeOf(array), 2, 1);
	if (errCode != 0) {
		return primitiveFailFor(errCode);
	}
	result = stackValue(1);
	popthenPush(mac + 1, result);
	return 0;
}


/*	Note: This is coded so that is can be run from Squeak. */

	/* IA32ABIPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	/* There was no version 0 */
	ok = ((interpreterProxy->majorVersion()) > 1)
	 || ((interpreterProxy->minorVersion()) >= 12);
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		byteSizeOf = interpreterProxy->byteSizeOf;
		classAlien = interpreterProxy->classAlien;
		classArray = interpreterProxy->classArray;
		classLargeNegativeInteger = interpreterProxy->classLargeNegativeInteger;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classSemaphore = interpreterProxy->classSemaphore;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
		getStackPointer = interpreterProxy->getStackPointer;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
#if !defined(integerObjectOf)
		integerObjectOf = interpreterProxy->integerObjectOf;
#endif
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		ioLoadModuleOfLength = interpreterProxy->ioLoadModuleOfLength;
		ioLoadSymbolOfLengthFromModule = interpreterProxy->ioLoadSymbolOfLengthFromModule;
		isKindOfClass = interpreterProxy->isKindOfClass;
		isArray = interpreterProxy->isArray;
		isBytes = interpreterProxy->isBytes;
		isInMemory = interpreterProxy->isInMemory;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
#if IMMUTABILITY
		isOopImmutable = interpreterProxy->isOopImmutable;
#else
#if !defined(isOopImmutable)
		isOopImmutable = 0;
#endif
#endif
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnFloat = interpreterProxy->methodReturnFloat;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnReceiver = interpreterProxy->methodReturnReceiver;
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		positiveMachineIntegerValueOf = interpreterProxy->positiveMachineIntegerValueOf;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		returnAsThroughCallbackContext = interpreterProxy->returnAsThroughCallbackContext;
		signalNoResume = interpreterProxy->signalNoResume;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed32BitValueOf = interpreterProxy->signed32BitValueOf;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		signed64BitValueOf = interpreterProxy->signed64BitValueOf;
		signedMachineIntegerValueOf = interpreterProxy->signedMachineIntegerValueOf;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackPositiveMachineIntegerValue = interpreterProxy->stackPositiveMachineIntegerValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Answer the size field of an alienOop which is assumed to be an Alien of at
	least 8 bytes (32-bits) or 16 bytes (64 bits)
 */

	/* InterpreterPlugin>>#sizeField: */
static sqInt
sizeField(sqInt alienOop)
{
	return longAt(alienOop + BaseHeaderSize);
}


/*	<byte indexable oop> ^<Integer> */
/*	Answer the start of rcvr's data, given that it is not an alien. */

	/* IA32ABIPlugin>>#startOfByteData: */
static sqInt
startOfByteData(sqInt rcvr)
{
	return rcvr + BaseHeaderSize;
}


/*	Answer the start of an Alien's data. For direct aliens this is the address
	of the second field.
	For indirect and pointer aliens it is what the second field points to. */

	/* InterpreterPlugin>>#startOfData: */
static sqInt
startOfData(sqInt alienOop)
{
	return ((longAt(alienOop + BaseHeaderSize)) > 0
		? (alienOop + BaseHeaderSize) + BytesPerOop
		: longAt((alienOop + BaseHeaderSize) + BytesPerOop));
}


/*	<Alien oop> */
/*	<Integer> ^<Integer> */
/*	Answer the start of rcvr's data. For direct aliens this is the address of
	the second field. For indirect and pointer aliens it is what the second
	field points to. */

	/* IA32ABIPlugin>>#startOfData:withSize: */
static sqInt
startOfDatawithSize(sqInt rcvr, sqInt sizeField)
{
	return (sizeField > 0
		? (rcvr + BaseHeaderSize) + BytesPerOop
		: longAt((rcvr + BaseHeaderSize) + BytesPerOop));
}


/*** Exports ***/
#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "IA32ABI";
void* IA32ABI_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primAddressField\000\000\000", (void*)primAddressField},
	{(void*)_m, "primAddressFieldPut\000\000\000", (void*)primAddressFieldPut},
	{(void*)_m, "primAlienCopyInto\000\001\000", (void*)primAlienCopyInto},
	{(void*)_m, "primAlienReplace\000\001\000", (void*)primAlienReplace},
	{(void*)_m, "primAllocateExecutablePage\000\377\000", (void*)primAllocateExecutablePage},
	{(void*)_m, "primBoxedFree\000\001\000", (void*)primBoxedFree},
	{(void*)_m, "primCallOutDoubleReturn\000\000\000", (void*)primCallOutDoubleReturn},
	{(void*)_m, "primCallOutFloatReturn\000\000\000", (void*)primCallOutFloatReturn},
	{(void*)_m, "primCallOutIntegralReturn\000\000\000", (void*)primCallOutIntegralReturn},
	{(void*)_m, "primCalloc\000\000\000", (void*)primCalloc},
	{(void*)_m, "primDoubleAt\000\000\000", (void*)primDoubleAt},
	{(void*)_m, "primDoubleAtPut\000\000\000", (void*)primDoubleAtPut},
	{(void*)_m, "primDrainOSEventQueue\000\377\000", (void*)primDrainOSEventQueue},
	{(void*)_m, "primFloatAt\000\000\000", (void*)primFloatAt},
	{(void*)_m, "primFloatAtPut\000\000\000", (void*)primFloatAtPut},
	{(void*)_m, "primFree\000\000\000", (void*)primFree},
	{(void*)_m, "primInIOProcessEventsFlagAddress\000\377\000", (void*)primInIOProcessEventsFlagAddress},
	{(void*)_m, "primInLibraryFindSymbol\000\001\000", (void*)primInLibraryFindSymbol},
	{(void*)_m, "primLoadLibrary\000\001\000", (void*)primLoadLibrary},
	{(void*)_m, "primMalloc\000\000\000", (void*)primMalloc},
	{(void*)_m, "primMostRecentCallbackContext\000\377\000", (void*)primMostRecentCallbackContext},
	{(void*)_m, "primOopAt\000\000\000", (void*)primOopAt},
	{(void*)_m, "primOopAtPut\000\000\000", (void*)primOopAtPut},
	{(void*)_m, "primReturnAsFromContextThrough\000\001\000", (void*)primReturnAsFromContextThrough},
#if OBSOLETE_ALIEN_PRIMITIVES
	{(void*)_m, "primReturnFromContextThrough\000\000\000", (void*)primReturnFromContextThrough},
#endif /* OBSOLETE_ALIEN_PRIMITIVES */
	{(void*)_m, "primSignedByteAt\000\000\000", (void*)primSignedByteAt},
	{(void*)_m, "primSignedByteAtPut\000\000\000", (void*)primSignedByteAtPut},
	{(void*)_m, "primSignedLongAt\000\000\000", (void*)primSignedLongAt},
	{(void*)_m, "primSignedLongAtPut\000\000\000", (void*)primSignedLongAtPut},
	{(void*)_m, "primSignedLongLongAt\000\000\000", (void*)primSignedLongLongAt},
	{(void*)_m, "primSignedLongLongAtPut\000\000\000", (void*)primSignedLongLongAtPut},
	{(void*)_m, "primSignedShortAt\000\000\000", (void*)primSignedShortAt},
	{(void*)_m, "primSignedShortAtPut\000\000\000", (void*)primSignedShortAtPut},
	{(void*)_m, "primSignedWordAt\000\000\000", (void*)primSignedWordAt},
	{(void*)_m, "primSignedWordAtPut\000\000\000", (void*)primSignedWordAtPut},
	{(void*)_m, "primSizeField\000\000\000", (void*)primSizeField},
	{(void*)_m, "primSizeFieldPut\000\000\000", (void*)primSizeFieldPut},
	{(void*)_m, "primStrlenFromStartIndex\000\000\000", (void*)primStrlenFromStartIndex},
	{(void*)_m, "primStrlenThroughPointerAtIndex\000\000\000", (void*)primStrlenThroughPointerAtIndex},
	{(void*)_m, "primThunkEntryAddress\000\377\000", (void*)primThunkEntryAddress},
	{(void*)_m, "primUnsignedByteAt\000\000\000", (void*)primUnsignedByteAt},
	{(void*)_m, "primUnsignedByteAtPut\000\000\000", (void*)primUnsignedByteAtPut},
	{(void*)_m, "primUnsignedLongAt\000\000\000", (void*)primUnsignedLongAt},
	{(void*)_m, "primUnsignedLongAtPut\000\000\000", (void*)primUnsignedLongAtPut},
	{(void*)_m, "primUnsignedLongLongAt\000\000\000", (void*)primUnsignedLongLongAt},
	{(void*)_m, "primUnsignedLongLongAtPut\000\000\000", (void*)primUnsignedLongLongAtPut},
	{(void*)_m, "primUnsignedShortAt\000\000\000", (void*)primUnsignedShortAt},
	{(void*)_m, "primUnsignedShortAtPut\000\000\000", (void*)primUnsignedShortAtPut},
	{(void*)_m, "primUnsignedWordAt\000\000\000", (void*)primUnsignedWordAt},
	{(void*)_m, "primUnsignedWordAtPut\000\000\000", (void*)primUnsignedWordAtPut},
	{(void*)_m, "primVarArgsCallOutDoubleReturn\000\001\000", (void*)primVarArgsCallOutDoubleReturn},
	{(void*)_m, "primVarArgsCallOutFloatReturn\000\001\000", (void*)primVarArgsCallOutFloatReturn},
	{(void*)_m, "primVarArgsCallOutIntegralReturn\000\001\000", (void*)primVarArgsCallOutIntegralReturn},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primAddressFieldMetadata = 0;
EXPORT(signed short) primAddressFieldPutMetadata = 0;
EXPORT(signed short) primAlienCopyIntoMetadata = 0x100;
EXPORT(signed short) primAlienReplaceMetadata = 0x100;
EXPORT(signed short) primBoxedFreeMetadata = 0x100;
EXPORT(signed short) primCallOutDoubleReturnMetadata = 0;
EXPORT(signed short) primCallOutFloatReturnMetadata = 0;
EXPORT(signed short) primCallOutIntegralReturnMetadata = 0;
EXPORT(signed short) primCallocMetadata = 0;
EXPORT(signed short) primDoubleAtMetadata = 0;
EXPORT(signed short) primDoubleAtPutMetadata = 0;
EXPORT(signed short) primFloatAtMetadata = 0;
EXPORT(signed short) primFloatAtPutMetadata = 0;
EXPORT(signed short) primFreeMetadata = 0;
EXPORT(signed short) primInLibraryFindSymbolMetadata = 0x100;
EXPORT(signed short) primLoadLibraryMetadata = 0x100;
EXPORT(signed short) primMallocMetadata = 0;
EXPORT(signed short) primOopAtMetadata = 0;
EXPORT(signed short) primOopAtPutMetadata = 0;
EXPORT(signed short) primReturnAsFromContextThroughMetadata = 0x100;
#if OBSOLETE_ALIEN_PRIMITIVES
EXPORT(signed short) primReturnFromContextThroughMetadata = 0;
#endif /* OBSOLETE_ALIEN_PRIMITIVES */
EXPORT(signed short) primSignedByteAtMetadata = 0;
EXPORT(signed short) primSignedByteAtPutMetadata = 0;
EXPORT(signed short) primSignedLongAtMetadata = 0;
EXPORT(signed short) primSignedLongAtPutMetadata = 0;
EXPORT(signed short) primSignedLongLongAtMetadata = 0;
EXPORT(signed short) primSignedLongLongAtPutMetadata = 0;
EXPORT(signed short) primSignedShortAtMetadata = 0;
EXPORT(signed short) primSignedShortAtPutMetadata = 0;
EXPORT(signed short) primSignedWordAtMetadata = 0;
EXPORT(signed short) primSignedWordAtPutMetadata = 0;
EXPORT(signed short) primSizeFieldMetadata = 0;
EXPORT(signed short) primSizeFieldPutMetadata = 0;
EXPORT(signed short) primStrlenFromStartIndexMetadata = 0;
EXPORT(signed short) primStrlenThroughPointerAtIndexMetadata = 0;
EXPORT(signed short) primUnsignedByteAtMetadata = 0;
EXPORT(signed short) primUnsignedByteAtPutMetadata = 0;
EXPORT(signed short) primUnsignedLongAtMetadata = 0;
EXPORT(signed short) primUnsignedLongAtPutMetadata = 0;
EXPORT(signed short) primUnsignedLongLongAtMetadata = 0;
EXPORT(signed short) primUnsignedLongLongAtPutMetadata = 0;
EXPORT(signed short) primUnsignedShortAtMetadata = 0;
EXPORT(signed short) primUnsignedShortAtPutMetadata = 0;
EXPORT(signed short) primUnsignedWordAtMetadata = 0;
EXPORT(signed short) primUnsignedWordAtPutMetadata = 0;
EXPORT(signed short) primVarArgsCallOutDoubleReturnMetadata = 0x100;
EXPORT(signed short) primVarArgsCallOutFloatReturnMetadata = 0x100;
EXPORT(signed short) primVarArgsCallOutIntegralReturnMetadata = 0x100;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
