/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.3419 uuid: 70017fea-1b4a-4603-a657-4d77106c4cf0
   from
	ThreadedRiscV64FFIPlugin VMMaker.oscog-eem.3419 uuid: 70017fea-1b4a-4603-a657-4d77106c4cf0
 */
static char __buildInfo[] = "ThreadedRiscV64FFIPlugin VMMaker.oscog-eem.3419 uuid: 70017fea-1b4a-4603-a657-4d77106c4cf0 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/* ThreadedFFIPlugin class>>preambleCCode */

#include "sqAssert.h" /* for assert */
#define ThreadedFFIPlugin 1 /* to filter-out unwanted declarations from sqFFI.h */
#include "sqFFI.h" /* for logging and surface functions */
#include "sqCogStackAlignment.h" /* for STACK_ALIGN_BYTES and getsp() */

#ifdef _MSC_VER
# define alloca _alloca
#endif
#if !defined(setsp) && defined(__GNUC__)
# if defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__)
#	define setsp(spval) asm volatile ("movl %0,%%esp" : : "m"(spval))
# elif defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64)
#	define setsp(spval) asm volatile ("movq %0,%%rsp" : : "m"(spval))
# elif defined(__arm64__) || defined(__aarch64__) || defined(ARM64)
        /* https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Extended-Asm
         * http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.den0024a/index.html
         */
#	define setsp(spval) asm volatile ("mov sp, %0"  : : "r"(spval))
# elif defined(__arm__)
#	define setsp(spval) asm volatile ("ldr %%sp, %0" : : "m"(spval))
# elif defined(__riscv64__) || defined(__rv64g__) || defined(__rv64gcv__)
#    define setsp(spval) asm volatile ("addi sp, %0, 0 " : : "r"(spval) : )
#    define getsp() asm volatile ("addi a0, sp, 0 " )
# endif
#endif
#if !defined(getsp)
# define getsp() 0
#endif 
#if !defined(setsp)
# define setsp(ignored) 0
#endif 

#if !defined(STACK_ALIGN_BYTES)
#  define STACK_ALIGN_BYTES 0
#endif /* !defined(STACK_ALIGN_BYTES) */

/* For ABI that require stack alignment greater than natural word size */
#define MUST_ALIGN_STACK (STACK_ALIGN_BYTES > sizeof(void*))

#if defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__)
/* Both Mac OS X x86 and Win32 x86 return structs of a power of two in size
 * less than or equal to eight bytes in length in registers. Linux never does so.
 */
# if __linux__
#	define WIN32_X86_STRUCT_RETURN 0
# else
#	define WIN32_X86_STRUCT_RETURN 1
# endif
# if _WIN32
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
#elif defined(__amd64__) || defined(__x86_64__) ||  defined(__amd64) || defined(__x86_64)
# if _WIN32 | _WIN64
#	define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 1
# endif
#endif /* defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__) */

#if !defined(ALLOCA_LIES_SO_SETSP_BEFORE_CALL)
# if defined(__MINGW32__) && !defined(__clang__) && (__GNUC__ >= 3) && (defined(_X86_) || defined(i386) || defined(__i386) || defined(__i386__))
    /*
     * cygwin -mno-cygwin (MinGW) gcc 3.4.x's alloca is a library routine that answers
     * %esp + xx, so the outgoing stack is offset by one or more word if uncorrected.
     * Grab the actual stack pointer to correct.
     */
#	define ALLOCA_LIES_SO_SETSP_BEFORE_CALL 1
# else
#	define ALLOCA_LIES_SO_SETSP_BEFORE_CALL 0
# endif
#endif /* !defined(ALLOCA_LIES_SO_SETSP_BEFORE_CALL) */

#if !defined(PLATFORM_API_USES_CALLEE_POPS_CONVENTION)
# define PLATFORM_API_USES_CALLEE_POPS_CONVENTION 0
#endif

/* The dispatchOn:in:with:with: generates an unwanted call on error.  Just squash it. */
#define error(foo) 0

/* sanitize */
#ifdef SQUEAK_BUILTIN_PLUGIN
# define EXTERN 
#else
# define EXTERN extern
#endif

/* end ThreadedFFIPlugin class>>preambleCCode */


/*** Constants ***/
#define DefaultMaxStackSize 16384
#define DisownVMForFFICall 16
#define DisownVMForThreading 32
#define ExternalFunctionArgTypesIndex 2
#define ExternalFunctionFlagsIndex 1
#define ExternalFunctionStackSizeIndex 3
#define FFIAtomicTypeMask 0xF000000
#define FFIAtomicTypeShift 24
#define FFICallFlagThreaded 0x100
#define FFICallTypeApi 1
#define FFICallTypeCDecl 0
#define FFICallTypesMask 0xFF
#define FFIErrorAddressNotFound 13
#define FFIErrorAttemptToPassVoid 14
#define FFIErrorBadAddress 11
#define FFIErrorBadArg 3
#define FFIErrorBadArgs 2
#define FFIErrorBadExternalFunction 17
#define FFIErrorBadExternalLibrary 16
#define FFIErrorBadReturn 10
#define FFIErrorCallFrameTooBig 19
#define FFIErrorCallType 9
#define FFIErrorCoercionFailed 6
#define FFIErrorIntAsPointer 4
#define FFIErrorInvalidPointer 18
#define FFIErrorModuleNotFound 15
#define FFIErrorNoModule 12
#define FFIErrorNotFunction 1
#define FFIErrorStructSize 8
#define FFIErrorWrongType 7
#define FFIFlagAtomic 0x40000
#define FFIFlagPointer 0x20000
#define FFIFlagStructure 0x10000
#define FFINoCalloutAvailable -1
#define FFIStructSizeMask 0xFFFF
#define FFITypeBool 1
#define FFITypeDoubleFloat 13
#define FFITypeSignedChar8 11
#define FFITypeSignedInt16 5
#define FFITypeSignedInt32 7
#define FFITypeSignedInt64 9
#define FFITypeSignedInt8 3
#define FFITypeSingleFloat 12
#define FFITypeUnsignedChar16 14
#define FFITypeUnsignedChar32 15
#define FFITypeUnsignedChar8 10
#define FFITypeUnsignedInt16 4
#define FFITypeUnsignedInt32 6
#define FFITypeUnsignedInt64 8
#define FFITypeUnsignedInt8 2
#define FFITypeVoid 0
#define MaxNumArgs 15
#define NumFloatRegArgs 8
#define NumIntRegArgs 8
#define PluginVersionInfo " VMMaker.oscog-eem.3419"

typedef struct {
	char *argVector;
	char *currentArg;
	char *limit;
	sqInt	structReturnSize;
	sqInt	structReturnType;
	sqInt	callFlags;
	unsigned int *ffiArgSpec;
	sqInt	ffiArgSpecSize;
	sqInt	ffiArgHeader;
	sqInt	ffiRetHeader;
	sqInt	ffiRetSpec;
	sqInt	stringArgIndex;
	char *stringArgs[MaxNumArgs];
	sqInt	integerRegisterIndex;
	sqInt	floatRegisterIndex;
	sqInt		integerRegisters[NumIntRegArgs];
	double		floatRegisters[NumFloatRegArgs];
 } CalloutState;

#define ThreadedFFICalloutStateForRiscV64 CalloutState
#define ThreadedFFICalloutStateForARM64 CalloutState
#define ThreadedFFICalloutState CalloutState


typedef struct { char pad_to_misalignment; char element; } structByte;

typedef struct { char pad_to_misalignment; short element; } structShort;

typedef struct { char pad_to_misalignment; int element; } structInt;

typedef struct { char pad_to_misalignment; long long element; } structLongLong;

typedef struct { char pad_to_misalignment; float element; } structFloat;

typedef struct { char pad_to_misalignment; double element; } structDouble;

typedef struct { char pad_to_misalignment; struct {char c; } element; } structStruct;



typedef struct {
	sqInt	a;
	sqInt	b;
 } SixteenByteReturnII;

#define ThreadedFFI64Bit16ByteReturnII SixteenByteReturnII
#define ThreadedFFIAbstractStructReturnStruct SixteenByteReturnII


typedef struct {
	union {
		struct { float floats[8]; } f;
		struct dprr { double doubles[4]; } d;
	};
 } ThirtyTwoByteReturnDF;

#define ThreadedFFI64Bit32ByteReturnDF ThirtyTwoByteReturnDF
#define ThreadedFFIAbstractStructReturnStruct ThirtyTwoByteReturnDF



/*** Function Prototypes ***/
static sqInt alignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt *indexPtr);
static sqInt checkAlignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex);
static sqInt checkAlignmentOfUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex);
static void cleanupCalloutState(CalloutState *calloutState);
static void * ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize);
static sqInt ffiArgByValuein(sqInt oop, CalloutState *calloutState);
static sqInt ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState);
static sqInt ffiFail(sqInt reason);
static sqLong ffiIntegerValueOf(sqInt oop);
static sqInt ffiLoadCalloutAddressFrom(sqInt oop);
static sqInt ffiLoadCalloutModule(sqInt module);
EXPORT(sqInt) ffiLogCallsTo(char *fileName);
static sqInt ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState);
static sqInt ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState);
static sqInt ffiReturnCStringFrom(sqInt cPointer);
static sqInt ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState);
static sqInt ffiReturnStructofTypein(void *longLongRetPtr, sqInt ffiRetType, CalloutState *calloutState);
static sqInt ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType);
EXPORT(const char *) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt isAlien(sqInt oop);
static sqInt isCharacterAtomicType(sqInt atomicTypeCode);
static sqInt isFloatAtomicType(sqInt atomicTypeCode);
static sqInt isUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex);
static sqInt msg(char *s);
EXPORT(void) primitiveCallout(void);
EXPORT(void) primitiveCalloutWithArgs(void);
EXPORT(sqInt) primitiveCDataModel(void);
EXPORT(sqInt) primitiveCreateManualSurface(void);
EXPORT(sqInt) primitiveDestroyManualSurface(void);
EXPORT(sqInt) primitiveExternalAddressAsInteger(void);
EXPORT(sqInt) primitiveExternalAddressFromInteger(void);
EXPORT(sqInt) primitiveFFIAllocate(void);
EXPORT(sqInt) primitiveFFIDoubleAt(void);
EXPORT(sqInt) primitiveFFIDoubleAtPut(void);
EXPORT(sqInt) primitiveFFIFloatAt(void);
EXPORT(sqInt) primitiveFFIFloatAtPut(void);
EXPORT(sqInt) primitiveFFIFree(void);
EXPORT(sqInt) primitiveFFIGetLastError(void);
EXPORT(sqInt) primitiveFFIIntegerAt(void);
EXPORT(sqInt) primitiveFFIIntegerAtPut(void);
EXPORT(sqInt) primitiveForceLoad(void);
EXPORT(sqInt) primitiveLoadSymbolFromModule(void);
EXPORT(sqInt) primitiveLogCallsTo(void);
EXPORT(sqInt) primitivePluginVersion(void);
EXPORT(sqInt) primitiveSetManualSurfacePointer(void);
EXPORT(sqInt) primitiveSignedInt16At(void);
EXPORT(sqInt) primitiveSignedInt16AtPut(void);
EXPORT(sqInt) primitiveSignedInt32At(void);
EXPORT(sqInt) primitiveSignedInt32AtPut(void);
EXPORT(sqInt) primitiveSignedInt64At(void);
EXPORT(sqInt) primitiveSignedInt64AtPut(void);
EXPORT(sqInt) primitiveSignedInt8At(void);
EXPORT(sqInt) primitiveSignedInt8AtPut(void);
EXPORT(sqInt) primitiveStructureElementAlignment(void);
EXPORT(sqInt) primitiveUnsignedInt16At(void);
EXPORT(sqInt) primitiveUnsignedInt16AtPut(void);
EXPORT(sqInt) primitiveUnsignedInt32At(void);
EXPORT(sqInt) primitiveUnsignedInt32AtPut(void);
EXPORT(sqInt) primitiveUnsignedInt64At(void);
EXPORT(sqInt) primitiveUnsignedInt64AtPut(void);
EXPORT(sqInt) primitiveUnsignedInt8At(void);
EXPORT(sqInt) primitiveUnsignedInt8AtPut(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt setReturnRegisterandCallwithArgsArray(sqLong structAddr, sqLong procAddr, sqLong arrayAddr);
static sqInt sizeField(sqInt alienOop);
static sqInt startOfData(sqInt alienOop);
static sqInt structIsHomogenousFloatArrayOfSizetypeSpecofLength(sqInt structSize, unsigned int *argSpec, sqInt argSpecSize);
static sqInt structIsHomogenousIntegerArrayOfSizetypeSpecofLength(sqInt structSize, unsigned int *argSpec, sqInt argSpecSize);


/*** Variables ***/
static sqInt externalFunctionInstSize;
static sqInt ffiLastError;
static sqInt ffiLogEnabled;

#if defined(SQUEAK_BUILTIN_PLUGIN)

# define isIntegerObject(oop) ((oop) & 1)
# define integerObjectOf(value) ((((usqInt) value) << NumSmallIntegerTagBits) | 1)
# define integerValueOf(oop) ((oop) >> NumSmallIntegerTagBits)

# if SPURVM
extern sqInt classIndexOf(sqInt);
#	define LargeNegativeIntegerClassIndex 32
#	define LargePositiveIntegerClassIndex 33
#	if BytesPerOop == 4
#	  define isImmediate(oop) ((oop) & 3)
#	else
#	  define isImmediate(oop) ((oop) & 7)
#	endif
#	define isKindOfInteger(oop) (isImmediate(oop) ? isIntegerObject(oop) : (unsigned)(classIndexOf(oop) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeIntegerObject(oop) (!isImmediate(oop) && (unsigned)(classIndexOf(oop) - LargeNegativeIntegerClassIndex) <= 1)
#	define isLargeNegativeIntegerObject(oop) (!isImmediate(oop) && classIndexOf(oop) == LargeNegativeIntegerClassIndex)
#	define isLargePositiveIntegerObject(oop) (!isImmediate(oop) && classIndexOf(oop) == LargePositiveIntegerClassIndex)
# endif /* SPURVM */
#endif /* defined(SQUEAK_BUILTIN_PLUGIN) */

#if !defined(isKindOfInteger)
# define isLargeNegativeIntegerObject(oop) (fetchClassOf(oop) == classLargeNegativeInteger())
# define isLargePositiveIntegerObject(oop) (fetchClassOf(oop) == classLargePositiveInteger())
# define isLargeIntegerObject(oop) (isLargeNegativeIntegerObject(oop) || isLargePositiveIntegerObject(oop))
# define isKindOfInteger(oop) (isIntegerObject(oop) || isLargeNegativeIntegerObject(oop) || isLargePositiveIntegerObject(oop))
#endif

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*characterObjectOf)(int characterCode);
static sqInt (*characterValueOf)(sqInt aCharacter);
static sqInt (*classAlien)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classExternalAddress)(void);
static sqInt (*classExternalData)(void);
static sqInt (*classExternalFunction)(void);
static sqInt (*classExternalLibrary)(void);
static sqInt (*classExternalStructure)(void);
static sqInt (*classLargePositiveInteger)(void);
static sqInt (*classString)(void);
static void * (*disownVM)(sqInt flags);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchLong32ofObject)(sqInt fieldIndex, sqInt oop);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static double (*floatValueOf)(sqInt oop);
static sqInt (*includesBehaviorThatOf)(sqInt aClass, sqInt aSuperclass);
static sqInt (*instanceSizeOf)(sqInt classObj);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
#if !defined(integerObjectOf)
static sqInt (*integerObjectOf)(sqInt value);
#endif
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static void * (*ioLoadModuleOfLength)(sqInt moduleNameIndex, sqInt moduleLength);
static void * (*ioLoadSymbolOfLengthFromModule)(sqInt functionNameIndex, sqInt functionLength, void *moduleHandle);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*isKindOfClass)(sqInt oop, sqInt aClass);
static sqInt (*isArray)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isCharacterObject)(sqInt oop);
static sqInt (*isFloatObject)(sqInt oop);
#if !defined(isImmediate)
static sqInt (*isImmediate)(sqInt anObject);
#endif
static sqInt (*isInMemory)(sqInt address);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isPinned)(sqInt anObject);
static sqInt (*isPointers)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*isWordsOrBytes)(sqInt oop);
static sqInt (*isYoung)(sqInt anOop);
static sqInt (*literalofMethod)(sqInt offset, sqInt methodPointer);
static sqInt (*literalCountOf)(sqInt methodPointer);
static sqInt (*methodArgumentCount)(void);
static sqInt (*methodReturnFloat)(double aFloat);
static sqInt (*methodReturnInteger)(sqInt integer);
static sqInt (*methodReturnString)(char *aCString);
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*nilObject)(void);
static sqInt (*ownVM)(void *handle);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static usqInt (*positive32BitValueOf)(sqInt oop);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static usqLong (*positive64BitValueOf)(sqInt oop);
static usqIntptr_t (*positiveMachineIntegerValueOf)(sqInt oop);
static sqInt (*primitiveErrorTable)(void);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*primitiveFailForwithSecondary)(sqInt reasonCode, sqLong extraErrorCode);
static sqInt (*primitiveFailForOSError)(sqLong osErrorCode);
static sqInt (*primitiveMethod)(void);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static int (*signed32BitValueOf)(sqInt oop);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqLong (*signed64BitValueOf)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt byteSizeOf(sqInt oop);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterObjectOf(int characterCode);
#else
# define characterObjectOf(characterCode) 0
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt characterValueOf(sqInt aCharacter);
#else
# define characterValueOf(aCharacter) 0
#endif
extern sqInt classAlien(void);
extern sqInt classByteArray(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classString(void);
extern void * disownVM(sqInt flags);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern double floatValueOf(sqInt oop);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
#if !defined(integerObjectOf)
extern sqInt integerObjectOf(sqInt value);
#endif
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern void * ioLoadModuleOfLength(sqInt moduleNameIndex, sqInt moduleLength);
extern void * ioLoadSymbolOfLengthFromModule(sqInt functionNameIndex, sqInt functionLength, void *moduleHandle);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isCharacterObject(sqInt oop);
#else
# define isCharacterObject(oop) 0
#endif
extern sqInt isFloatObject(sqInt oop);
#if !defined(isImmediate)
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isImmediate(sqInt anObject);
#else
# define isImmediate(anObject) 0
#endif
#endif /* !defined(isImmediate) */
extern sqInt isInMemory(sqInt address);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isPinned(sqInt anObject);
#else
# define isPinned(anObject) 0
#endif
extern sqInt isPointers(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isYoung(sqInt anOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt literalCountOf(sqInt methodPointer);
extern sqInt methodArgumentCount(void);
extern sqInt methodReturnFloat(double aFloat);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnString(char *aCString);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt nilObject(void);
extern sqInt ownVM(void *handle);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern usqInt positive32BitValueOf(sqInt oop);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
extern sqInt primitiveErrorTable(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 14)
extern sqInt primitiveFailForwithSecondary(sqInt reasonCode, sqLong extraErrorCode);
#else
# define primitiveFailForwithSecondary(reasonCode, extraErrorCode) 0
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 14)
extern sqInt primitiveFailForOSError(sqLong osErrorCode);
#else
# define primitiveFailForOSError(osErrorCode) 0
#endif
extern sqInt primitiveMethod(void);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern int signed32BitValueOf(sqInt oop);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "RiscV64FFIPlugin VMMaker.oscog-eem.3419 " INT_EXT;


/*** Macros ***/
#define allocaLiesSoSetSpBeforeCall() ALLOCA_LIES_SO_SETSP_BEFORE_CALL
#define cStackAlignment() STACK_ALIGN_BYTES
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define dispatchFunctionPointerwithwithwithwith(aFunctionPointer, int1, int2, int3, int4) (aFunctionPointer)(int1, int2, int3, int4)
#define dispatchFunctionPointerwithwithwithwithwithwith(aFunctionPointer, int1, int2, int3, int4, int5, int6) (aFunctionPointer)(int1, int2, int3, int4, int5, int6)
#define dispatchFunctionPointerwithwithwithwithwithwithwithwith(aFunctionPointer, int1, int2, int3, int4, int5, int6, int7, int8) (aFunctionPointer)(int1, int2, int3, int4, int5, int6, int7, int8)
#define ffiAlloc(bytes) (usqInt)malloc(bytes)
#define ffiFree(pointer) free((void *)(pointer))
#define isCalleePopsConvention(callType) (PLATFORM_API_USES_CALLEE_POPS_CONVENTION && (callType) == FFICallTypeApi)
#define mustAlignStack() MUST_ALIGN_STACK
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define unalignedLong32At(index) long32At(index)
#define unalignedLong32Atput(index,value) long32Atput(index,value)
#define unalignedLong64At(index) long64At(index)
#define unalignedLong64Atput(index,value) long64Atput(index,value)
#define unalignedShortAt(index) shortAt(index)
#define unalignedShortAtput(index,value) shortAtput(index,value)



/*	Answer with the alignment requirement for a structure/union.
	Note that indexPtr is a pointer so as to be changed on return.
	On input, the index points to the structure header (the one with
	FFIFlagStructure + structSize).
	On output, the index points the the structure trailer (the
	FFIFlagStructure). 
 */

	/* ThreadedFFIPlugin>>#alignmentOfStructSpec:OfLength:StartingAt: */
static sqInt
alignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt *indexPtr)
{
    sqInt byteAlignment;
    unsigned int spec;
    sqInt thisAlignment;

	spec = specs[indexPtr[0]];
	assert((spec & ((FFIFlagPointer + FFIFlagAtomic) + FFIFlagStructure)) == FFIFlagStructure);
	byteAlignment = 1;
	while (1) {
		indexPtr[0] = ((indexPtr[0]) + 1);
		if (!((indexPtr[0]) < specSize)) break;
		spec = specs[indexPtr[0]];
		if (spec == FFIFlagStructure) {
			return byteAlignment;
		}
		thisAlignment = (((spec & FFIFlagPointer) != 0)
			? BytesPerWord
			: (((spec & FFIFlagStructure) != 0)
					? alignmentOfStructSpecOfLengthStartingAt(specs, specSize, indexPtr)
					: spec & FFIStructSizeMask));
		byteAlignment = ((byteAlignment < thisAlignment) ? thisAlignment : byteAlignment);
	}
	assert(0);
	return byteAlignment;
}


/*	Check the alignment of a structure and return true if correctly aligned.
	If computed size = declared size, then the struct is assumed correctly
	aligned. 
 */

	/* ThreadedFFIPlugin>>#checkAlignmentOfStructSpec:OfLength:StartingAt: */
static sqInt
checkAlignmentOfStructSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex)
{
    sqInt computedSize;
    unsigned int declaredSize;
    sqInt fieldAlignment;
    unsigned int fieldSize;
    sqInt index;
    sqInt maxAlignment;
    unsigned int spec;

	index = startIndex;
	spec = specs[index];
	assert((spec & ((FFIFlagPointer + FFIFlagAtomic) + FFIFlagStructure)) == FFIFlagStructure);
	if (isUnionSpecOfLengthStartingAt(specs, specSize, index)) {
		return checkAlignmentOfUnionSpecOfLengthStartingAt(specs, specSize, startIndex);
	}
	declaredSize = spec & FFIStructSizeMask;
	computedSize = 0;
	maxAlignment = 1;
	while (((index += 1)) < specSize) {
		spec = specs[index];
		if (spec == FFIFlagStructure) {
			return (((computedSize - 1) | (maxAlignment - 1)) + 1) == declaredSize;
		}
		if (((spec & FFIFlagPointer) != 0)) {
			fieldSize = BytesPerWord;
			fieldAlignment = fieldSize;
		}
		else {
			fieldSize = spec & FFIStructSizeMask;
			if (((spec & FFIFlagStructure) != 0)) {
				if (!(checkAlignmentOfStructSpecOfLengthStartingAt(specs, specSize, index))) {
					return 0;
				}
				fieldAlignment = alignmentOfStructSpecOfLengthStartingAt(specs, specSize, (&index));
			}
			else {
				fieldAlignment = fieldSize;
			}
		}
		maxAlignment = ((maxAlignment < fieldAlignment) ? fieldAlignment : maxAlignment);
		computedSize = ((computedSize - 1) | (fieldAlignment - 1)) + 1;
		computedSize += fieldSize;
	}
	return (((computedSize - 1) | (maxAlignment - 1)) + 1) == declaredSize;
}


/*	Check the alignment of a union and return true if correctly aligned.
	Union are correctly aligned, but a sub-structure might not. */

	/* ThreadedFFIPlugin>>#checkAlignmentOfUnionSpec:OfLength:StartingAt: */
static sqInt
checkAlignmentOfUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex)
{
    sqInt index;
    unsigned int spec;

	index = startIndex;
	spec = specs[index];
	while (1) {
		index += 1;
		if (!(index < specSize)) break;
		spec = specs[index];
		if (spec == FFIFlagStructure) {
			return 1;
		}
		if (!(((spec & FFIFlagPointer) != 0))) {
			if (((spec & FFIFlagStructure) != 0)) {
				if (!(checkAlignmentOfStructSpecOfLengthStartingAt(specs, specSize, index))) {
					return 0;
				}
			}
		}
	}
	return 1;
}


/*	Free any temporary arg strings. */

	/* ThreadedFFIPlugin>>#cleanupCalloutState: */
static void
cleanupCalloutState(CalloutState *calloutState)
{
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
}


/*	Answer the address of the byte at byteOffset in rcvr. Nominally intended
	for use
	with ExternalAddress objects, this code will work with pure bits arrays as
	well. Answer nil (0) on error. */

	/* ThreadedFFIPlugin>>#ffiAddressOf:startingAt:size: */
static void *
ffiAddressOfstartingAtsize(sqInt rcvr, sqInt byteOffset, sqInt byteSize)
{
    sqInt addr;
    sqInt rcvrSize;

	if (!((byteOffset > 0)
		 && (isWordsOrBytes(rcvr)))) {
		return null;
	}
	rcvrSize = byteSizeOf(rcvr);
	if ((fetchClassOf(rcvr)) == (classExternalAddress())) {
		if (!(rcvrSize == BytesPerWord)) {
			return null;
		}

		/* Hack!! */
		addr = fetchPointerofObject(0, rcvr);
		if (addr == 0) {
			return null;
		}
	}
	else {
		if (!(((byteOffset + byteSize) - 1) <= rcvrSize)) {
			return null;
		}
		addr = firstIndexableField(rcvr);
	}
	return ((void *)((addr + byteOffset) - 1));
}


/*	Support for generic callout. Prepare an argument by value for a callout. */

	/* ThreadedFFIPlugin>>#ffiArgByValue:in: */
static sqInt
ffiArgByValuein(sqInt oop, CalloutState *calloutState)
{
    sqInt atomicType;
    double floatValue;
    usqLong intValue;
    sqInt typeSpec;


	/* Support up to int64_t or uint64_t */
	/* begin atomicTypeOf: */
	typeSpec = (calloutState->ffiArgHeader);
	atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if (!((((usqInt)(atomicType)) >> 1) == 6)) {
		/* begin ffiIntegerValueOf: */
		if (((oop & (BytesPerWord - 1)) != 0)) {
#      if SPURVM
			if (isIntegerObject(oop)) {
				intValue = ((sqLong) (integerValueOf(oop)));
				goto l1;
			}
			if (isCharacterObject(oop)) {

				/* Immediate in Spur */
				intValue = ((sqLong) (characterValueOf(oop)));
				goto l1;
			}
			if (isFloatObject(oop)) {

				/* Immediate in 64-bit Spur */
				intValue = ((sqLong) (floatValueOf(oop)));
				goto l1;
			}
#      else // SPURVM
			intValue = ((sqLong) (integerValueOf(oop)));
			goto l1;
#      endif
		}
		else {
#      if !SPURVM

			/* No non-immediate characters in Spur */
			if (isCharacterObject(oop)) {
				intValue = ((sqLong) (characterValueOf(oop)));
				goto l1;
			}
#      endif // !SPURVM
			if (isFloatObject(oop)) {
				intValue = ((sqLong) (floatValueOf(oop)));
				goto l1;
			}
			if (oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, nilObject(), trueObject())) {

				/* i.e. cheaper than but equivalent to:
				   oop = interpreterProxy nilObject ifTrue: [^0]. @@: should we really allow this????
				   oop = interpreterProxy falseObject ifTrue: [^0].
				   oop = interpreterProxy trueObject ifTrue: [^1]. */
				intValue = ((sqLong) ((oop == (trueObject())
	? 1
	: 0)));
				goto l1;
			}
			if (isLargePositiveIntegerObject(oop)) {
				intValue = ((sqLong) (positive64BitValueOf(oop)));
				goto l1;
			}
		}
		intValue = signed64BitValueOf(oop);
	l1:	/* end ffiIntegerValueOf: */;
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
#    if BytesPerWord == 8
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 2:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 3:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((signed char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 4:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned short) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 5:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((signed short) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 6:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 7:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 8:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 9:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 10:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 11:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((signed char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 12:
		case 13:
			return FFIErrorAttemptToPassVoid;
		case 14:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned short) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 15:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;

		default:
			error("Case not found");
			return -1;
		}
#    else // BytesPerWord == 8
		switch (atomicType) {
		case 0:
			return FFIErrorAttemptToPassVoid;
		case 1:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 2:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 3:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((signed char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 4:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned short) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 5:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((signed short) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 6:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 7:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 8:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 9:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 10:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 11:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((signed char) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 12:
		case 13:
			return FFIErrorAttemptToPassVoid;
		case 14:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ((unsigned short) intValue));
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		case 15:
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), intValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;

		default:
			error("Case not found");
			return -1;
		}
#    endif // BytesPerWord == 8
	}
	/* begin ffiFloatValueOf: */
	if (isFloatObject(oop)) {
		floatValue = floatValueOf(oop);
		goto l3;
	}
	floatValue = ((double) (ffiIntegerValueOf(oop)) );
	l3:	/* end ffiFloatValueOf: */;
	if (failed()) {
		return FFIErrorCoercionFailed;
	}
	if (atomicType == FFITypeSingleFloat) {
		/* begin ffiPushFloat32:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {

			/* Note: this is a 'memcopy', so size is preserved. Casting to #double changes the size */
			(*((long *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))) = -1);
			(*((float *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))) = floatValue);
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
		}
		else {

			/* Use integer register if available */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = -1;
				storeSingleFloatAtPointerfrom((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])), floatValue);
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
		}
		return 0;
	}
	else {
		/* begin ffiPushFloat64:in: */
		if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
			((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
			(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
		}
		else {

			/* Use integer register if available */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				storeFloatAtPointerfrom((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])), floatValue);
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), floatValue);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
		}
		return 0;
	}
}


/*	Callout support. Prepare the given oop as argument.
	argSpec defines the compiled spec for the argument.
	argClass (if non-nil) defines the required (super)class for the argument. */

	/* ThreadedFFIPlugin>>#ffiArgument:Spec:Class:in: */
static sqInt
ffiArgumentSpecClassin(sqInt oop, sqInt argSpec, sqInt argClass, CalloutState *calloutState)
{
    unsigned int *argSpec1;
    unsigned int *argSpec2;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt atomicType2;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    char *copy;
    sqInt err;
    double floatValue;
    usqLong intValue;
    sqInt isAlienObj;
    int isExternalAddress;
    sqInt isStringObj;
    sqInt isStruct;
    sqInt length;
    sqInt misAlignedBytes;
    sqInt misAlignedBytes1;
    sqInt nilOop;
    sqInt oopClass;
    sqInt oopClass1;
    char *pointer;
    void *pointer1;
    void *pointer2;
    void *pointer3;
    void *pointer4;
    void *pointer5;
    void *pointer6;
    void *ptrAddress;
    sqInt ptrClass;
    sqInt ptrType;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt spec;
    sqInt specOop;
    sqInt specType;
    sqInt structSize;
    sqInt structSize1;
    sqInt typeSpec;
    sqInt typeSpec1;
    sqInt typeSpec2;
    sqInt valueOop;
    sqInt valueOop1;


	/* Prefetch class (we'll need it) */
	oopClass = fetchClassOf(oop);

	/* Do the necessary type checks */
	nilOop = nilObject();
	if (!(argClass == nilOop)) {

		/* Type check 1:
		   Is the required class of the argument a general instance of ExternalStructure? */
		if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
			return FFIErrorWrongType;
		}
		if (!((nilOop == oop)
			 || (includesBehaviorThatOf(oopClass, argClass)))) {
			return FFIErrorCoercionFailed;
		}
	}

	/* Check if oopClass is a general instance of ExternalStructure.
	   If this is the case we'll work on its handle and not the actual oop. */
	valueOop = oop;
	isStruct = 0;
	if ((oop != nilOop)
	 && (isPointers(oop))) {

		/* #isPointers: will fail if oop is immediate so don't even attempt to use it */
		if ((isStruct = includesBehaviorThatOf(oopClass, classExternalStructure()))) {
			valueOop = fetchPointerofObject(0, oop);
		}
		else {

			/* Special case for Callback or FFICallback objects.
			   Callback: The first field must be a block closure, but we have no way to tell. The second field must be an Alien.
			   FFICallback: The first field is an ExternalAddress.
			   eem 7/16/2024 11:27
			   I would like to register the class for Callback or FFICallback (preferrably only one) via addGCRoot: and use
			   includesBehavior:ThatOf:, but interpreterProxy does not provide findClassByName: etc.
			   Note that VMMaker.oscog-eem.3403 includes the version that short-cuts directly here to ffiPushPointer:in:.
			   Nicer might be to add a primitive activeCallbackClass: thunkIndex: to this plugin and have Callback install
			   this at startUp:. But plugin unload/reload would break this convention. */
			if ((argClass == nilOop)
			 && ((slotSizeOf(oop)) >= 3)) {
				if (isKindOf(oop, "Callback")) {

					/* thunk instVar */
					valueOop = fetchPointerofObject(1, oop);
				}
				else {
					if (isKindOf(oop, "FFICallback")) {

						/* handle inst var */
						valueOop = fetchPointerofObject(0, oop);
					}
				}
			}
		}
		if (!((argClass == nilOop)
			 || (isStruct))) {
			return FFIErrorCoercionFailed;
		}
	}
	if (!(isWords(argSpec))) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpecSize = (byteSizeOf(argSpec)) / (sizeof(unsigned int)));
	if (((calloutState->ffiArgSpecSize)) == 0) {
		return FFIErrorWrongType;
	}
	(calloutState->ffiArgSpec = ((unsigned int *) (firstIndexableField(argSpec))));
	(calloutState->ffiArgHeader = ((calloutState->ffiArgSpec))[0]);
	if (((((calloutState->ffiArgHeader)) & FFIFlagStructure) != 0)) {

		/* argument must be ExternalStructure */
		if (!isStruct) {
			return FFIErrorCoercionFailed;
		}
		if (((((calloutState->ffiArgHeader)) & FFIFlagAtomic) != 0)) {
			return FFIErrorWrongType;
		}
		/* begin ffiPushStructureContentsOf:in: */
		ptrClass = fetchClassOf(valueOop);
		if (ptrClass == (classExternalAddress())) {

			/* ExternalAddress is bytes */

			/* There is no way we can make sure the structure is valid.
			   But we can at least check for attempts to pass pointers to ST memory. */
			ptrAddress = ((void *)(fetchPointerofObject(0, valueOop)));
			if (isInMemory(((usqIntptr_t)ptrAddress))) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec2 = (calloutState->ffiArgSpec);
			argSpecSize = (calloutState->ffiArgSpecSize);
			if (structIsHomogenousFloatArrayOfSizetypeSpecofLength(structSize, argSpec2, argSpecSize)) {
				availableRegisterSpace = (NumFloatRegArgs - ((calloutState->floatRegisterIndex))) * BytesPerWord;
				if (structSize <= availableRegisterSpace) {

					/* Stage C, step C.2, all in floating-point registers (!!) */
					memcpy(((void *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))), ptrAddress, structSize);
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + ((((usqInt)((structSize + 7))) >> 3)));
					return 0;
				}
				availableRegisterSpace = 0;
				(calloutState->floatRegisterIndex = 8);
			}
			else {
				availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * BytesPerWord;
			}
			if ((structSize <= availableRegisterSpace)
			 && ((structSize <= 16)
			 || (structIsHomogenousIntegerArrayOfSizetypeSpecofLength(structSize, argSpec2, argSpecSize)))) {
				if (structSize <= availableRegisterSpace) {

					/* all in integer registers */
					memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 7))) >> 3)));
					return 0;
				}
			}
			if (structSize <= 16) {
				roundedSize = (((structSize + 7) | 7) - 7);
				if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				/* begin alignCurrentArgOf:to: */
				misAlignedBytes = (((sqInt)((calloutState->currentArg)))) & (BytesPerWord - 1);
				if (misAlignedBytes != 0) {
					(calloutState->currentArg = ((calloutState->currentArg)) + (BytesPerWord - misAlignedBytes));
				}
				memcpy((calloutState->currentArg), ptrAddress, structSize);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
			}
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ptrAddress);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		if (ptrClass == (classByteArray())) {

			/* The following is a somewhat pessimistic test but I like being sure... */
			if (!((byteSizeOf(valueOop)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
				return FFIErrorStructSize;
			}
			ptrAddress = firstIndexableField(valueOop);
			if (!(((((calloutState->ffiArgHeader)) & FFIFlagPointer) != 0))) {

				/* Since this involves passing the address of the first indexable field we need to fail
				   the call if it is threaded and the object is young, since it may move during the call. */
#        if COGMTVM
				if ((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0))
				 && (isYoung(valueOop))) {
					return -PrimErrObjectMayMove;
				}
#        endif // COGMTVM
				/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
				structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
				argSpec1 = (calloutState->ffiArgSpec);
				argSpecSize1 = (calloutState->ffiArgSpecSize);
				if (structIsHomogenousFloatArrayOfSizetypeSpecofLength(structSize1, argSpec1, argSpecSize1)) {
					availableRegisterSpace1 = (NumFloatRegArgs - ((calloutState->floatRegisterIndex))) * BytesPerWord;
					if (structSize1 <= availableRegisterSpace1) {

						/* Stage C, step C.2, all in floating-point registers (!!) */
						memcpy(((void *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))), ptrAddress, structSize1);
						(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + ((((usqInt)((structSize1 + 7))) >> 3)));
						return 0;
					}
					availableRegisterSpace1 = 0;
					(calloutState->floatRegisterIndex = 8);
				}
				else {
					availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * BytesPerWord;
				}
				if ((structSize1 <= availableRegisterSpace1)
				 && ((structSize1 <= 16)
				 || (structIsHomogenousIntegerArrayOfSizetypeSpecofLength(structSize1, argSpec1, argSpecSize1)))) {
					if (structSize1 <= availableRegisterSpace1) {

						/* all in integer registers */
						memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize1);
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 7))) >> 3)));
						return 0;
					}
				}
				if (structSize1 <= 16) {
					roundedSize1 = (((structSize1 + 7) | 7) - 7);
					if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					/* begin alignCurrentArgOf:to: */
					misAlignedBytes1 = (((sqInt)((calloutState->currentArg)))) & (BytesPerWord - 1);
					if (misAlignedBytes1 != 0) {
						(calloutState->currentArg = ((calloutState->currentArg)) + (BytesPerWord - misAlignedBytes1));
					}
					memcpy((calloutState->currentArg), ptrAddress, structSize1);
					(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
				}
				/* begin ffiPushPointer:in: */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ptrAddress);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			}
			if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
				return FFIErrorStructSize;
			}
			ptrAddress = ((void *)(fetchPointerofObject(0, valueOop)));
			if (isInMemory(((usqIntptr_t)ptrAddress))) {
				return FFIErrorInvalidPointer;
			}
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ptrAddress);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		return FFIErrorBadArg;
	}
	if (((((calloutState->ffiArgHeader)) & FFIFlagPointer) != 0)) {

		/* no integers (or characters) for pointers please */
		if (isImmediate(oop)) {
			return FFIErrorIntAsPointer;
		}
		if (oop == nilOop) {
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)null));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), null);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		if (((((calloutState->ffiArgHeader)) & FFIFlagAtomic) != 0)) {
			if (isStruct) {

				/* e.g., ExternalData */
				/* begin ffiAtomicStructByReference:Class:in: */
				if (!(oopClass == (classExternalData()))) {
					return FFIErrorCoercionFailed;
				}
				/* begin atomicTypeOf: */
				typeSpec1 = (calloutState->ffiArgHeader);
				atomicType1 = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if (atomicType1 != FFITypeVoid) {
					/* begin ffiValidateExternalData:AtomicType: */
					ptrType = fetchPointerofObject(1, oop);
					if (!((isPointers(ptrType))
						 && ((slotSizeOf(ptrType)) >= 2))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					specOop = fetchPointerofObject(0, ptrType);
					if (!((isWords(specOop))
						 && ((slotSizeOf(specOop)) > 0))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					spec = fetchPointerofObject(0, specOop);
					if (!(((spec & FFIFlagAtomic) != 0))) {
						err = FFIErrorWrongType;
						goto l3;
					}
					/* begin atomicTypeOf: */
					specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
					if (specType != atomicType1) {

						/* Allow for signed/unsigned conversion but nothing else.
						   See FFIConstants class>>#initializeTypeConstants */
						if (!((atomicType1 >= FFITypeUnsignedInt8)
							 && ((atomicType1 <= FFITypeSignedChar8)
							 && ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(specType)) >> 1))))) {
							err = FFIErrorCoercionFailed;
							goto l3;
						}
					}
					err = 0;
	l3:	/* end ffiValidateExternalData:AtomicType: */;
					if (err != 0) {
						return err;
					}
				}
				valueOop1 = fetchPointerofObject(0, oop);
				return ffiPushPointerContentsOfin(valueOop1, calloutState);
			}
			/* begin ffiAtomicArgByReference:Class:in: */
			oopClass1 = (valueOop == oop
				? oopClass
				: fetchClassOf(valueOop));
			/* begin atomicTypeOf: */
			typeSpec = (calloutState->ffiArgHeader);
			atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
			if (atomicType == FFITypeBool) {

				/* No bools on input */
				return FFIErrorCoercionFailed;
			}
			if ((isExternalAddress = oopClass1 == (classExternalAddress()))) {
				isAlienObj = (isStringObj = 0);
			}
			else {
				if ((isStringObj = includesBehaviorThatOf(oopClass1, classString()))) {
					isAlienObj = 0;
				}
				else {
					isAlienObj = includesBehaviorThatOf(oopClass1, classAlien());
				}
			}
			if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedChar8)) >> 1)) {

				/* string value (char*) */
				/* note: the only types allowed for passing into char* types are
				   ByteArray, String, Symbol, Alien and *no* other byte indexed objects
				   (e.g., CompiledMethod, LargeInteger). We only check for strings
				   here and fall through to the byte* check otherwise. */
				if (isStringObj) {

					/* String/Symbol */
					/* Strings must be allocated by the ffi support code */
					/* begin ffiPushString:OfLength:in: */
					pointer = firstIndexableField(valueOop);
					length = byteSizeOf(valueOop);
					if (((calloutState->stringArgIndex)) >= MaxNumArgs) {
						return -PrimErrBadNumArgs;
					}
					copy = malloc(length + 1);
					if (copy == null) {
						return -PrimErrNoCMemory;
					}
					memcpy(copy, pointer, length);
					copy[length] = 0;
					((calloutState->stringArgs))[(calloutState->stringArgIndex)] = copy;
					(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) + 1);
					/* begin ffiPushPointer:in: */
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)copy));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), copy);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				atomicType = FFITypeUnsignedInt8;
			}
#      if COGMTVM

			/* Since all the following pass the address of the first indexable field we need to fail
			   the call if it is threaded and the object is young, since it may move during the call. */
			if ((!isExternalAddress)
			 && ((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0))
			 && (((!isAlienObj)
			 || ((assert(isAlien(valueOop)),
			(longAt(valueOop + BaseHeaderSize)) > 0)))
			 && (
#      if SPURVM
				!(isPinned(valueOop))
#      else
				isYoung(valueOop)
#      endif
				)))) {
				return -PrimErrObjectMayMove;
			}
#      endif // COGMTVM
			if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedInt8)) >> 1)) {

				/* byte* -- see comment on string above */
				if (isStringObj
				 || (oopClass1 == (classByteArray()))) {

					/* String/Symbol/ByteArray */
					/* begin ffiPushPointer:in: */
					pointer1 = firstIndexableField(valueOop);
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer1));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer1);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				if (isExternalAddress) {
					/* begin ffiPushPointer:in: */
					pointer2 = ((void *) (longAt(valueOop + BaseHeaderSize)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer2));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer2);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				if (isAlienObj) {
					/* begin ffiPushPointer:in: */
					pointer3 = pointerForOop(((longAt(valueOop + BaseHeaderSize)) > 0
						? (valueOop + BaseHeaderSize) + BytesPerOop
						: longAt((valueOop + BaseHeaderSize) + BytesPerOop)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer3));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer3);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				if (!(atomicType == FFITypeVoid)) {
					return FFIErrorCoercionFailed;
				}
			}
			if (atomicType <= FFITypeDoubleFloat) {
				if (isExternalAddress) {
					/* begin ffiPushPointer:in: */
					pointer4 = ((void *) (longAt(valueOop + BaseHeaderSize)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer4));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer4);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				if (isAlienObj) {
					/* begin ffiPushPointer:in: */
					pointer5 = pointerForOop(((longAt(valueOop + BaseHeaderSize)) > 0
						? (valueOop + BaseHeaderSize) + BytesPerOop
						: longAt((valueOop + BaseHeaderSize) + BytesPerOop)));
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer5));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer5);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
				if (isWordsOrBytes(valueOop)) {
					/* begin ffiPushPointer:in: */
					pointer6 = firstIndexableField(valueOop);
					if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
						((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)pointer6));
						(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
					}
					else {
						if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
							return FFIErrorCallFrameTooBig;
						}
						longAtput((calloutState->currentArg), pointer6);
						(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
					}
					return 0;
				}
			}
			return FFIErrorCoercionFailed;
		}
		if (isStruct) {
			return ffiPushPointerContentsOfin(valueOop, calloutState);
		}
		return FFIErrorCoercionFailed;
	}
	if (((((calloutState->ffiArgHeader)) & FFIFlagAtomic) != 0)) {

		/* argument is atomic value */
		/* begin ffiArgByValue:in: */
		
		typeSpec2 = (calloutState->ffiArgHeader);
		atomicType2 = ((usqInt)((typeSpec2 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if (!((((usqInt)(atomicType2)) >> 1) == 6)) {
			/* begin ffiIntegerValueOf: */
			if (((valueOop & (BytesPerWord - 1)) != 0)) {
#        if SPURVM
				if (isIntegerObject(valueOop)) {
					intValue = ((sqLong) (integerValueOf(valueOop)));
					goto l6;
				}
				if (isCharacterObject(valueOop)) {

					/* Immediate in Spur */
					intValue = ((sqLong) (characterValueOf(valueOop)));
					goto l6;
				}
				if (isFloatObject(valueOop)) {

					/* Immediate in 64-bit Spur */
					intValue = ((sqLong) (floatValueOf(valueOop)));
					goto l6;
				}
#        else // SPURVM
				intValue = ((sqLong) (integerValueOf(valueOop)));
				goto l6;
#        endif
			}
			else {
#        if !SPURVM

				/* No non-immediate characters in Spur */
				if (isCharacterObject(valueOop)) {
					intValue = ((sqLong) (characterValueOf(valueOop)));
					goto l6;
				}
#        endif // !SPURVM
				if (isFloatObject(valueOop)) {
					intValue = ((sqLong) (floatValueOf(valueOop)));
					goto l6;
				}
				if (oopisGreaterThanOrEqualToandLessThanOrEqualTo(valueOop, nilObject(), trueObject())) {

					/* i.e. cheaper than but equivalent to:
					   oop = interpreterProxy nilObject ifTrue: [^0]. @@: should we really allow this????
					   oop = interpreterProxy falseObject ifTrue: [^0].
					   oop = interpreterProxy trueObject ifTrue: [^1]. */
					intValue = ((sqLong) ((valueOop == (trueObject())
	? 1
	: 0)));
					goto l6;
				}
				if (isLargePositiveIntegerObject(valueOop)) {
					intValue = ((sqLong) (positive64BitValueOf(valueOop)));
					goto l6;
				}
			}
			intValue = signed64BitValueOf(valueOop);
	l6:	/* end ffiIntegerValueOf: */;
			if (failed()) {
				return FFIErrorCoercionFailed;
			}
#      if BytesPerWord == 8
			switch (atomicType2) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 2:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 3:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((signed char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 4:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned short) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 5:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((signed short) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 6:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 7:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 8:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 9:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 10:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 11:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((signed char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 12:
			case 13:
				return FFIErrorAttemptToPassVoid;
			case 14:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned short) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 15:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;

			default:
				error("Case not found");
				return -1;
			}
#      else // BytesPerWord == 8
			switch (atomicType2) {
			case 0:
				return FFIErrorAttemptToPassVoid;
			case 1:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 2:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 3:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((signed char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 4:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned short) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 5:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed short) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((signed short) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 6:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 7:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 8:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 9:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 10:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 11:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((signed char) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((signed char) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 12:
			case 13:
				return FFIErrorAttemptToPassVoid;
			case 14:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((unsigned short) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), ((unsigned short) intValue));
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;
			case 15:
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((usqLong) intValue));
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), intValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
				return 0;

			default:
				error("Case not found");
				return -1;
			}
#      endif // BytesPerWord == 8
		}
		/* begin ffiFloatValueOf: */
		if (isFloatObject(valueOop)) {
			floatValue = floatValueOf(valueOop);
			goto l5;
		}
		floatValue = ((double) (ffiIntegerValueOf(valueOop)) );
	l5:	/* end ffiFloatValueOf: */;
		if (failed()) {
			return FFIErrorCoercionFailed;
		}
		if (atomicType2 == FFITypeSingleFloat) {
			/* begin ffiPushFloat32:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {

				/* Note: this is a 'memcopy', so size is preserved. Casting to #double changes the size */
				(*((long *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))) = -1);
				(*((float *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))) = floatValue);
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
			else {

				/* Use integer register if available */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = -1;
					storeSingleFloatAtPointerfrom((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])), floatValue);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), floatValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
			}
			return 0;
		}
		else {
			/* begin ffiPushFloat64:in: */
			if (((calloutState->floatRegisterIndex)) < NumFloatRegArgs) {
				((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)] = floatValue;
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + 1);
			}
			else {

				/* Use integer register if available */
				if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
					storeFloatAtPointerfrom((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])), floatValue);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
				}
				else {
					if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
						return FFIErrorCallFrameTooBig;
					}
					longAtput((calloutState->currentArg), floatValue);
					(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
				}
			}
			return 0;
		}
	}
	return FFIErrorWrongType;
}


/*	Map the FFI error code into a primitive error code. If reason is negative
	it encodes one of the
	standard PrimErr... codes, negated to distinguish it from the FFIError
	codes. If it is an FFIError...
	code then add the size of the primitive error table + 2 to disambiguate it
	from the PrimErr... codes.
	For historic reasons the FFIError codes range from -1 on up hence adding
	size + 2 maps them to
	size of table + 1 on up. This OFFSET IS undone by ExternalFunction
	class>>externalCallFailedWith:. Thus we can communicate back both
	PrimErr.. and FFIError codes. Complex but necessary.
	
	If a clonable PrimErrFFIMarshallingError is present in the error table
	then use the new scheme. */

	/* ThreadedFFIPlugin>>#ffiFail: */
static sqInt
ffiFail(sqInt reason)
{
    sqInt errorTable;
    sqInt numErrorTableSlots;

	ffiLastError = reason;
	if (reason >= FFINoCalloutAvailable) {
		errorTable = primitiveErrorTable();
		numErrorTableSlots = slotSizeOf(errorTable);
		if ((numErrorTableSlots >= PrimErrFFIMarshallingError)
		 && (isPointers(errorTable))) {
			return primitiveFailForwithSecondary(PrimErrFFIMarshallingError, reason);
		}
		return primitiveFailFor((reason + 2) + numErrorTableSlots);
	}
	return primitiveFailFor(-reason);
}


/*	Support for generic callout. Answer an integer value that is coerced as C
	would do.
 */
/*	Support up to int64_t or uint64_t, at least intptr_t; type *MUST* be
	signed for e.g. correct float conversion.
 */
/*	Cheat with a tag test */

	/* ThreadedFFIPlugin>>#ffiIntegerValueOf: */
static sqLong
ffiIntegerValueOf(sqInt oop)
{
	if (((oop & (BytesPerWord - 1)) != 0)) {
#    if SPURVM
		if (isIntegerObject(oop)) {
			return integerValueOf(oop);
		}
		if (isCharacterObject(oop)) {

			/* Immediate in Spur */
			return characterValueOf(oop);
		}
		if (isFloatObject(oop)) {

			/* Immediate in 64-bit Spur */
			return floatValueOf(oop);
		}
#    else // SPURVM
		return integerValueOf(oop);
#    endif
	}
	else {
#    if !SPURVM

		/* No non-immediate characters in Spur */
		if (isCharacterObject(oop)) {
			return characterValueOf(oop);
		}
#    endif
		if (isFloatObject(oop)) {
			return floatValueOf(oop);
		}
		if (oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, nilObject(), trueObject())) {

			/* i.e. cheaper than but equivalent to:
			   oop = interpreterProxy nilObject ifTrue: [^0]. @@: should we really allow this????
			   oop = interpreterProxy falseObject ifTrue: [^0].
			   oop = interpreterProxy trueObject ifTrue: [^1]. */
			return (oop == (trueObject())
				? 1
				: 0);
		}
		if (isLargePositiveIntegerObject(oop)) {
			return positive64BitValueOf(oop);
		}
	}
	return signed64BitValueOf(oop);
}


/*	Load the function address for a call out to an external function */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutAddressFrom: */
static sqInt
ffiLoadCalloutAddressFrom(sqInt oop)
{
    sqInt address;
    sqInt functionName;
    sqInt module;
    sqInt moduleHandle;


	/* First find and load the module */
	module = fetchPointerofObject(externalFunctionInstSize + 1, oop);
	moduleHandle = ffiLoadCalloutModule(module);
	if (failed()) {
		return 0;
	}
	functionName = fetchPointerofObject(externalFunctionInstSize, oop);
	if (!(isBytes(functionName))) {
		return ffiFail(FFIErrorBadExternalFunction);
	}
	address = ((sqInt)(ioLoadSymbolOfLengthFromModule(((sqInt)(firstIndexableField(functionName))), byteSizeOf(functionName), ((void *)moduleHandle))));
	if ((failed())
	 || (address == 0)) {
		return ffiFail(FFIErrorAddressNotFound);
	}
	return address;
}


/*	Load the given module and return its handle */

	/* ThreadedFFIPlugin>>#ffiLoadCalloutModule: */
static sqInt
ffiLoadCalloutModule(sqInt module)
{
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt moduleLength;
    sqInt *ptr;
    sqInt rcvr;

	if (isBytes(module)) {

		/* plain module name */
		ffiModuleName = module;
		moduleLength = byteSizeOf(ffiModuleName);
		moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName))), moduleLength)));
		if ((failed())
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound);
		}
		return moduleHandle;
	}
	rcvr = stackValue(methodArgumentCount());
	if (!(isKindOfClass(rcvr, classExternalLibrary()))) {
		return ffiFail(FFIErrorNoModule);
	}
	moduleHandlePtr = fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(moduleHandlePtr))
		 && ((byteSizeOf(moduleHandlePtr)) == (sizeof(sqInt))))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle = fetchPointerofObject(0, moduleHandlePtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		return 0;
	}
	if (moduleHandle == 0) {

		/* need to reload module */
		ffiModuleName = fetchPointerofObject(1, rcvr);
		if (!(isBytes(ffiModuleName))) {
			return ffiFail(FFIErrorBadExternalLibrary);
		}
		moduleLength = byteSizeOf(ffiModuleName);
		moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName))), moduleLength)));
		if ((failed())
		 || (moduleHandle == 0)) {
			return ffiFail(FFIErrorModuleNotFound);
		}
		ptr = firstIndexableField(moduleHandlePtr);
		ptr[0] = moduleHandle;
	}
	return moduleHandle;
}


/*	This is a special entry point exposed such that client code can enable and
	disable logging of FFI calls.
 */

	/* ThreadedFFIPlugin>>#ffiLogCallsTo: */
EXPORT(sqInt)
ffiLogCallsTo(char *fileName)
{
	if (fileName == null) {

		/* disable logging */
		if (!(ffiLogFileNameOfLength(null, 0))) {
			return 0;
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */
		if (!(ffiLogFileNameOfLength(fileName, strlen(fileName)))) {
			return 0;
		}
		ffiLogEnabled = 1;
	}
	return 1;
}


/*	Push the contents of the given external structure */

	/* ThreadedFFIPlugin>>#ffiPushPointerContentsOf:in: */
static sqInt
ffiPushPointerContentsOfin(sqInt oop, CalloutState *calloutState)
{
    void *ptrAddress;
    sqInt ptrClass;

	ptrClass = fetchClassOf(oop);
	if (ptrClass == (classExternalAddress())) {

		/* Don't you dare to pass pointers into object memory */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(((usqIntptr_t)ptrAddress))) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if (ptrClass == (classByteArray())) {

		/* Since this involves passing the address of the first indexable field we need to fail
		   the call if it is threaded and the object is young, since it may move during the call. */
#    if COGMTVM
		if ((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0))
		 && (isYoung(oop))) {
			return -PrimErrObjectMayMove;
		}
#    endif // COGMTVM
		ptrAddress = firstIndexableField(oop);
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if (includesBehaviorThatOf(ptrClass, classAlien())) {
#    if COGMTVM
		if ((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0))
		 && (((assert(isAlien(oop)),
		(longAt(oop + BaseHeaderSize)) > 0))
		 && (isYoung(oop)))) {
			return -PrimErrObjectMayMove;
		}
#    endif // COGMTVM
		ptrAddress = ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorBadArg;
}


/*	Push the contents of the given external structure */

	/* ThreadedFFIPlugin>>#ffiPushStructureContentsOf:in: */
static sqInt
ffiPushStructureContentsOfin(sqInt oop, CalloutState *calloutState)
{
    unsigned int *argSpec;
    unsigned int *argSpec1;
    sqInt argSpecSize;
    sqInt argSpecSize1;
    sqInt availableRegisterSpace;
    sqInt availableRegisterSpace1;
    sqInt misAlignedBytes;
    sqInt misAlignedBytes1;
    void *ptrAddress;
    sqInt ptrClass;
    sqInt roundedSize;
    sqInt roundedSize1;
    sqInt structSize;
    sqInt structSize1;

	ptrClass = fetchClassOf(oop);
	if (ptrClass == (classExternalAddress())) {

		/* ExternalAddress is bytes */

		/* There is no way we can make sure the structure is valid.
		   But we can at least check for attempts to pass pointers to ST memory. */
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(((usqIntptr_t)ptrAddress))) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
		structSize = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
		argSpec = (calloutState->ffiArgSpec);
		argSpecSize = (calloutState->ffiArgSpecSize);
		if (structIsHomogenousFloatArrayOfSizetypeSpecofLength(structSize, argSpec, argSpecSize)) {
			availableRegisterSpace = (NumFloatRegArgs - ((calloutState->floatRegisterIndex))) * BytesPerWord;
			if (structSize <= availableRegisterSpace) {

				/* Stage C, step C.2, all in floating-point registers (!!) */
				memcpy(((void *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))), ptrAddress, structSize);
				(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + ((((usqInt)((structSize + 7))) >> 3)));
				return 0;
			}
			availableRegisterSpace = 0;
			(calloutState->floatRegisterIndex = 8);
		}
		else {
			availableRegisterSpace = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * BytesPerWord;
		}
		if ((structSize <= availableRegisterSpace)
		 && ((structSize <= 16)
		 || (structIsHomogenousIntegerArrayOfSizetypeSpecofLength(structSize, argSpec, argSpecSize)))) {
			if (structSize <= availableRegisterSpace) {

				/* all in integer registers */
				memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize);
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize + 7))) >> 3)));
				return 0;
			}
		}
		if (structSize <= 16) {
			roundedSize = (((structSize + 7) | 7) - 7);
			if ((((calloutState->currentArg)) + roundedSize) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			/* begin alignCurrentArgOf:to: */
			misAlignedBytes = (((sqInt)((calloutState->currentArg)))) & (BytesPerWord - 1);
			if (misAlignedBytes != 0) {
				(calloutState->currentArg = ((calloutState->currentArg)) + (BytesPerWord - misAlignedBytes));
			}
			memcpy((calloutState->currentArg), ptrAddress, structSize);
			(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize);
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	if (ptrClass == (classByteArray())) {

		/* The following is a somewhat pessimistic test but I like being sure... */
		if (!((byteSizeOf(oop)) == (((calloutState->ffiArgHeader)) & FFIStructSizeMask))) {
			return FFIErrorStructSize;
		}
		ptrAddress = firstIndexableField(oop);
		if (!(((((calloutState->ffiArgHeader)) & FFIFlagPointer) != 0))) {

			/* Since this involves passing the address of the first indexable field we need to fail
			   the call if it is threaded and the object is young, since it may move during the call. */
#      if COGMTVM
			if ((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0))
			 && (isYoung(oop))) {
				return -PrimErrObjectMayMove;
			}
#      endif // COGMTVM
			/* begin ffiPushStructure:ofSize:typeSpec:ofLength:in: */
			structSize1 = ((calloutState->ffiArgHeader)) & FFIStructSizeMask;
			argSpec1 = (calloutState->ffiArgSpec);
			argSpecSize1 = (calloutState->ffiArgSpecSize);
			if (structIsHomogenousFloatArrayOfSizetypeSpecofLength(structSize1, argSpec1, argSpecSize1)) {
				availableRegisterSpace1 = (NumFloatRegArgs - ((calloutState->floatRegisterIndex))) * BytesPerWord;
				if (structSize1 <= availableRegisterSpace1) {

					/* Stage C, step C.2, all in floating-point registers (!!) */
					memcpy(((void *) ((&(((calloutState->floatRegisters))[(calloutState->floatRegisterIndex)])))), ptrAddress, structSize1);
					(calloutState->floatRegisterIndex = ((calloutState->floatRegisterIndex)) + ((((usqInt)((structSize1 + 7))) >> 3)));
					return 0;
				}
				availableRegisterSpace1 = 0;
				(calloutState->floatRegisterIndex = 8);
			}
			else {
				availableRegisterSpace1 = (NumIntRegArgs - ((calloutState->integerRegisterIndex))) * BytesPerWord;
			}
			if ((structSize1 <= availableRegisterSpace1)
			 && ((structSize1 <= 16)
			 || (structIsHomogenousIntegerArrayOfSizetypeSpecofLength(structSize1, argSpec1, argSpecSize1)))) {
				if (structSize1 <= availableRegisterSpace1) {

					/* all in integer registers */
					memcpy(((void *) ((&(((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)])))), ptrAddress, structSize1);
					(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + ((((usqInt)((structSize1 + 7))) >> 3)));
					return 0;
				}
			}
			if (structSize1 <= 16) {
				roundedSize1 = (((structSize1 + 7) | 7) - 7);
				if ((((calloutState->currentArg)) + roundedSize1) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				/* begin alignCurrentArgOf:to: */
				misAlignedBytes1 = (((sqInt)((calloutState->currentArg)))) & (BytesPerWord - 1);
				if (misAlignedBytes1 != 0) {
					(calloutState->currentArg = ((calloutState->currentArg)) + (BytesPerWord - misAlignedBytes1));
				}
				memcpy((calloutState->currentArg), ptrAddress, structSize1);
				(calloutState->currentArg = ((calloutState->currentArg)) + roundedSize1);
			}
			/* begin ffiPushPointer:in: */
			if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
				((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
				(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
			}
			else {
				if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
					return FFIErrorCallFrameTooBig;
				}
				longAtput((calloutState->currentArg), ptrAddress);
				(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
			}
			return 0;
		}
		if (!((((calloutState->ffiArgHeader)) & FFIStructSizeMask) == BytesPerWord)) {
			return FFIErrorStructSize;
		}
		ptrAddress = ((void *)(fetchPointerofObject(0, oop)));
		if (isInMemory(((usqIntptr_t)ptrAddress))) {
			return FFIErrorInvalidPointer;
		}
		/* begin ffiPushPointer:in: */
		if (((calloutState->integerRegisterIndex)) < NumIntRegArgs) {
			((calloutState->integerRegisters))[(calloutState->integerRegisterIndex)] = (((sqInt)ptrAddress));
			(calloutState->integerRegisterIndex = ((calloutState->integerRegisterIndex)) + 1);
		}
		else {
			if ((((calloutState->currentArg)) + BytesPerWord) > ((calloutState->limit))) {
				return FFIErrorCallFrameTooBig;
			}
			longAtput((calloutState->currentArg), ptrAddress);
			(calloutState->currentArg = ((calloutState->currentArg)) + BytesPerWord);
		}
		return 0;
	}
	return FFIErrorBadArg;
}


/*	Create a Smalltalk string from a zero terminated C string */

	/* ThreadedFFIPlugin>>#ffiReturnCStringFrom: */
static sqInt
ffiReturnCStringFrom(sqInt cPointer)
{
    char *cString;
    sqInt i;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;

	if (!cPointer) {
		return nilObject();
	}
	cString = ((char *) cPointer);
	strLen = 0;
	while (!((cString[strLen]) == 0)) {
		strLen += 1;
	}
	strOop = instantiateClassindexableSize(classString(), strLen);
	strPtr = firstIndexableField(strOop);
	for (i = 0; i < strLen; i += 1) {
		strPtr[i] = (cString[i]);
	}
	return strOop;
}


/*	Generic callout support. Create a pointer return value from an external
	function call
 */

	/* ThreadedFFIPlugin>>#ffiReturnPointer:ofType:in: */
static sqInt
ffiReturnPointerofTypein(usqLong retVal, sqInt retType, CalloutState *calloutState)
{
    sqInt atomicType;
    sqInt classOop;
    char *cString;
    sqInt i;
    sqInt oop;
    sqInt *ptr;
    sqInt retClass;
    sqInt retOop;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqInt typeSpec;

	retClass = fetchPointerofObject(1, retType);
	if (retClass == (nilObject())) {

		/* Create ExternalData upon return */
		/* begin atomicTypeOf: */
		typeSpec = (calloutState->ffiRetHeader);
		atomicType = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
		if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedChar8)) >> 1)) {

			/* String return */
			/* begin ffiReturnCStringFrom: */
			if (!(((usqInt) retVal))) {
				retOop = nilObject();
				goto l1;
			}
			cString = ((char *) (((usqInt) retVal)));
			strLen = 0;
			while (!((cString[strLen]) == 0)) {
				strLen += 1;
			}
			strOop = instantiateClassindexableSize(classString(), strLen);
			strPtr = firstIndexableField(strOop);
			for (i = 0; i < strLen; i += 1) {
				strPtr[i] = (cString[i]);
			}
			retOop = strOop;
	l1:	/* end ffiReturnCStringFrom: */;
			return retOop;
		}
		
#if SPURVM
		oop = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
		ptr = firstIndexableField(oop);
		ptr[0] = (((sqInt) retVal));
		retOop = instantiateClassindexableSize(classExternalData(), 0);
		storePointerofObjectwithValue(0, retOop, oop);
#else /* SPURVM */
		pushRemappableOop(retType);
		oop = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
		ptr = firstIndexableField(oop);
		ptr[0] = (((sqInt) retVal));
				pushRemappableOop(oop);
		retOop = instantiateClassindexableSize(classExternalData(), 0);
		oop = popRemappableOop();
		storePointerofObjectwithValue(0, retOop, oop);
		retType = popRemappableOop();
#endif /* SPURVM */
		storePointerofObjectwithValue(1, retOop, retType);
		return retOop;
	}
	classOop = (((((calloutState->ffiRetHeader)) & FFIFlagStructure) != 0)
		? classByteArray()
		: classExternalAddress());
	
#if SPURVM
	oop = instantiateClassindexableSize(classOop, BytesPerWord);
#else /* SPURVM */
	pushRemappableOop(retClass);
	oop = instantiateClassindexableSize(classOop, BytesPerWord);
	retClass = popRemappableOop();
#endif /* SPURVM */
	ptr = firstIndexableField(oop);
	ptr[0] = (((sqInt) retVal));
	
#if SPURVM
	retOop = instantiateClassindexableSize(retClass, 0);
#else /* SPURVM */
	pushRemappableOop(oop);
	retOop = instantiateClassindexableSize(retClass, 0);
	oop = popRemappableOop();
#endif /* SPURVM */
	storePointerofObjectwithValue(0, retOop, oop);
	return retOop;
}


/*	Create a structure return value from an external function call. The value
	has been stored in
	alloca'ed space pointed to by the calloutState or in the integer
	registers. 
 */

	/* ThreadedARM64FFIPlugin>>#ffiReturnStruct:ofType:in: */
static sqInt
ffiReturnStructofTypein(void *longLongRetPtr, sqInt ffiRetType, CalloutState *calloutState)
{
    sqInt oop;
    sqInt retClass;
    sqInt retOop;

	retClass = fetchPointerofObject(1, ffiRetType);
	retOop = instantiateClassindexableSize(retClass, 0);
	
#if SPURVM
	oop = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
#else /* SPURVM */
	pushRemappableOop(retOop);
	oop = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
	retOop = popRemappableOop();
#endif /* SPURVM */
	memcpy(firstIndexableField(oop), longLongRetPtr, (calloutState->structReturnSize));
	storePointerofObjectwithValue(0, retOop, oop);
	return retOop;
}


/*	Validate if the given oop (an instance of ExternalData) can be passed as a
	pointer to the given atomic type.
 */

	/* ThreadedFFIPlugin>>#ffiValidateExternalData:AtomicType: */
static sqInt
ffiValidateExternalDataAtomicType(sqInt oop, sqInt atomicType)
{
    sqInt ptrType;
    sqInt spec;
    sqInt specOop;
    sqInt specType;

	ptrType = fetchPointerofObject(1, oop);
	if (!((isPointers(ptrType))
		 && ((slotSizeOf(ptrType)) >= 2))) {
		return FFIErrorWrongType;
	}
	specOop = fetchPointerofObject(0, ptrType);
	if (!((isWords(specOop))
		 && ((slotSizeOf(specOop)) > 0))) {
		return FFIErrorWrongType;
	}
	spec = fetchPointerofObject(0, specOop);
	if (!(((spec & FFIFlagAtomic) != 0))) {
		return FFIErrorWrongType;
	}
	/* begin atomicTypeOf: */
	specType = ((usqInt)((spec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if (specType != atomicType) {

		/* Allow for signed/unsigned conversion but nothing else.
		   See FFIConstants class>>#initializeTypeConstants */
		if (!((atomicType >= FFITypeUnsignedInt8)
			 && ((atomicType <= FFITypeSignedChar8)
			 && ((((usqInt)(atomicType)) >> 1) == (((usqInt)(specType)) >> 1))))) {
			return FFIErrorCoercionFailed;
		}
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* ThreadedFFIPlugin>>#getModuleName */
EXPORT(const char *)
getModuleName(void)
{
	return "SqueakFFIPrims" PluginVersionInfo;
}

	/* ThreadedFFIPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{

	/* By default, disable logging */
	ffiLastError = 0;

	/* Get the instSize of ExternalFunction to know whether it contains a cache of the stackSize,
	   and what the offset of ExternalLibraryFunction's functionName and moduleName slots are. */
	ffiLogEnabled = 0;
	externalFunctionInstSize = instanceSizeOf(classExternalFunction());
	initSurfacePluginFunctionPointers();
	return 1;
}


/*	Answer if oop is an Alien. We could ask if isWordsOrBytes: first, but that
	doesn't help. We still have to do the is:KindOf: walk.
	We're not interested in fast falsehood, but as fast as possible truth, and
	with the current API this is it. */

	/* InterpreterPlugin>>#isAlien: */
static sqInt
isAlien(sqInt oop)
{
	return isKindOfClass(oop, classAlien());
}

	/* ThreadedFFIPlugin>>#isCharacterAtomicType: */
static sqInt
isCharacterAtomicType(sqInt atomicTypeCode)
{
	return (atomicTypeCode >= FFITypeUnsignedChar8)
	 && (!((((usqInt)(atomicTypeCode)) >> 1) == 6));
}


/*	this is used in asserts; so not #always */
/*	(atomicTypeCode >> 1) = (FFITypeSingleFloat >> 1) */

	/* ThreadedFFIPlugin>>#isFloatAtomicType: */
static sqInt
isFloatAtomicType(sqInt atomicTypeCode)
{
	return (((usqInt)(atomicTypeCode)) >> 1) == 6;
}


/*	We can't easily distinguish union from structures with available flags.
	But we have a trick: a union should have one field size equal to its own
	size. 
 */

	/* ThreadedFFIPlugin>>#isUnionSpec:OfLength:StartingAt: */
static sqInt
isUnionSpecOfLengthStartingAt(unsigned int *specs, sqInt specSize, sqInt startIndex)
{
    sqInt index;
    unsigned int spec;
    unsigned int thisSize;
    unsigned int unionSize;

	index = startIndex;
	spec = specs[index];
	assert((spec & ((FFIFlagPointer + FFIFlagAtomic) + FFIFlagStructure)) == FFIFlagStructure);
	unionSize = spec & FFIStructSizeMask;
	while (1) {
		index += 1;
		if (!(index < specSize)) break;
		spec = specs[index];
		if (spec == FFIFlagStructure) {
			return 0;
		}
		thisSize = spec & FFIStructSizeMask;
		if (thisSize == unionSize) {
			return 1;
		}
		if ((spec & (FFIFlagPointer + FFIFlagStructure)) == FFIFlagStructure) {

			/* Asking for alignment is a trick for skipping this sub structure/union */
			alignmentOfStructSpecOfLengthStartingAt(specs, specSize, (&index));
		}
	}
	return 0;
}

	/* ThreadedFFIPlugin>>#msg: */
static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", getModuleName(), s);
	return 0;
}


/*	IMPORTANT: IF YOU CHANGE THE NAME OF THIS METHOD YOU MUST CHANGE
	Interpreter>>primitiveCalloutToFFI
	TO REFLECT THE CHANGE. */
/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec. */

	/* ThreadedFFIPlugin>>#primitiveCallout */
EXPORT(void)
primitiveCallout(void)
{
    sqInt address;
    sqInt address1;
    sqInt addressPtr;
    char *allocation;
    sqInt argClass;
    sqInt argSpec;
    sqInt argType;
    sqInt argTypeArray;
    sqInt argTypes;
    sqInt argTypes1;
    sqLong arrayAddr;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt byteSize;
    extern void callAndReturnWithStructAddr(sqLong structAddr,sqLong procAddr,sqLong arrayAddr);
    CalloutState *calloutState;
    sqInt classOop;
    char *cString;
    double doubleRet;
    sqInt err;
    sqInt externalFunction;
    sqInt ffiRetType;
    sqInt flags;
    ThirtyTwoByteReturnDF floatRet;
    sqInt i;
    sqInt i1;
    usqLong intRet;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double);
    void *longLongRetPtr;
    void *longLongRetPtr1;
    usqLong mask;
    sqInt meth;
    sqInt nArgs;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt primNumArgs;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt requiredStackSize;
    sqInt result;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass2;
    sqInt retOop;
    sqInt retOop1;
    sqInt retOop2;
    sqInt returnType;
    sqInt shift;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specSize;
    sqInt stackSize;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqLong structAddr;
    SixteenByteReturnII structRet;
    CalloutState theCalloutState;
    sqInt typeSpec;
    sqInt typeSpec1;
    usqLong value;
    void *vmHandle;

	meth = primitiveMethod();
	if (!((literalCountOf(meth)) > 0)) {
		primitiveFailFor(PrimErrBadMethod);
		return;
	}
	externalFunction = literalofMethod(0, meth);
	/* begin ffiCall:ArgArrayOrNil:NumArgs: */
	nArgs = methodArgumentCount();
	primNumArgs = methodArgumentCount();
	if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
		ffiFail(FFIErrorNotFunction);
		goto l10;
	}
	flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
	if (failed()) {
		ffiFail(FFIErrorBadArgs);
		goto l10;
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr = fetchPointerofObject(0, externalFunction);
	
	if (!((isBytes(addressPtr))
		 && ((byteSizeOf(addressPtr)) == (sizeof(sqInt))))) {
		address1 = ffiFail(FFIErrorBadAddress);
		goto l2;
	}
	address1 = fetchPointerofObject(0, addressPtr);
	l2:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		address = 0;
		goto l3;
	}
	if (address1 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, -1);
		}
		if ((slotSizeOf(externalFunction)) < 5) {
			address = ffiFail(FFIErrorNoModule);
			goto l3;
		}
		address1 = ffiLoadCalloutAddressFrom(externalFunction);
		if (failed()) {
			address = 0;
			goto l3;
		}
		ptr = firstIndexableField(addressPtr);
		ptr[0] = address1;
	}
	address = address1;
	l3:	/* end ffiLoadCalloutAddress: */;
	if (failed()) {
		goto l10;
	}

	/* must be array of arg types */
	argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
	if (!((isArray(argTypeArray))
		 && ((slotSizeOf(argTypeArray)) == (nArgs + 1)))) {
		ffiFail(FFIErrorBadArgs);
		goto l10;
	}
#  if COGMTVM
	if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l10;
	}
#  else // COGMTVM

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags == FFICallTypeCDecl)
		 || (flags == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l10;
	}
#  endif // COGMTVM
	requiredStackSize = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
		? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction)
		: -1);
	if (failed()) {
		primitiveFailFor(PrimErrBadMethod);
		goto l10;
	}
	stackSize = (requiredStackSize < 0
		? DefaultMaxStackSize
		: requiredStackSize);
	calloutState = (&theCalloutState);
	memset(calloutState, 0, sizeof(CalloutState));
	(calloutState->callFlags = flags);
	argType = fetchPointerofObject(0, argTypeArray);
	argSpec = fetchPointerofObject(0, argType);

	/* Witten this way to allow Slang to inline ffiCheckReturn:With:in: */
	argClass = fetchPointerofObject(1, argType);
	/* begin ffiCheckReturn:With:in: */
	if (!(argClass == (nilObject()))) {
		if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
			err = FFIErrorBadReturn;
			goto l4;
		}
	}
	if (!((isWords(argSpec))
		 && ((slotSizeOf(argSpec)) > 0))) {
		err = FFIErrorWrongType;
		goto l4;
	}
	(calloutState->ffiRetSpec = argSpec);
	(calloutState->ffiRetHeader = fetchLong32ofObject(0, argSpec));
	if (!(((((calloutState->ffiRetHeader)) & FFIFlagAtomic) != 0))) {
		if (argClass == (nilObject())) {
			err = FFIErrorBadReturn;
			goto l4;
		}
	}
	if ((((calloutState->ffiRetHeader)) & (FFIFlagPointer | FFIFlagStructure)) == FFIFlagStructure) {
		(calloutState->structReturnSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask);
		/* begin encodeStructReturnTypeIn: */
		(calloutState->structReturnType = ((calloutState->structReturnSize)) <= (2 * BytesPerWord));
	}
	err = 0;
	l4:	/* end ffiCheckReturn:With:in: */;
	if (err != 0) {
		ffiFail(err);
		goto l10;
	}
	allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState->argVector = allocation);
	(calloutState->currentArg = allocation);
	(calloutState->limit = allocation + stackSize);
	for (i = 1; i <= nArgs; i += 1) {
		argType = fetchPointerofObject(i, argTypeArray);
		argSpec = fetchPointerofObject(0, argType);
		argClass = fetchPointerofObject(1, argType);
		oop = stackValue(nArgs - i);
		err = ffiArgumentSpecClassin(oop, argSpec, argClass, calloutState);
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
#      if COGMTVM
			if (err == (-PrimErrObjectMayMove)) {
				goto l10;
			}
#      endif
			ffiFail(err);
			goto l10;
		}
	}
	assert(!(failed()));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		doFFILogCallout(externalFunction);
	}
	if ((requiredStackSize < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	vmHandle = disownVM((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0)
		? DisownVMForFFICall + DisownVMForThreading
		: DisownVMForFFICall));
	if (((calloutState->floatRegisterIndex)) > 0) {
		loadFloatRegs(((calloutState->floatRegisters))[0], ((calloutState->floatRegisters))[1], ((calloutState->floatRegisters))[2], ((calloutState->floatRegisters))[3], ((calloutState->floatRegisters))[4], ((calloutState->floatRegisters))[5], ((calloutState->floatRegisters))[6], ((calloutState->floatRegisters))[7]);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec1 = (calloutState->ffiRetHeader);
	atomicType = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
		if (atomicType == FFITypeDoubleFloat) {
			doubleRet = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]);
		}
		else {
			doubleRet = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]);
		}
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(vmHandle);
		result = floatObjectOf(doubleRet);
		goto l9;
	}
	if (((((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) == FFIFlagStructure)
	 && (structIsHomogenousFloatArrayOfSizetypeSpecofLength(((calloutState->ffiRetHeader)) & FFIStructSizeMask, ((unsigned int *) (firstIndexableField((calloutState->ffiRetSpec)))), ((specSize = byteSizeOf((calloutState->ffiRetSpec)))) / (sizeof(unsigned int))))) {
		(floatRet.d = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((struct dprr (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]));
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(vmHandle);
		if (specSize > ((calloutState->structReturnSize))) {
			((((floatRet.f)).floats))[1] = (((((floatRet.f)).floats))[2]);
			((((floatRet.f)).floats))[2] = (((((floatRet.f)).floats))[4]);
			((((floatRet.f)).floats))[3] = (((((floatRet.f)).floats))[6]);
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr = (&floatRet);
		specLiteral1 = literalofMethod(0, primitiveMethod());
		argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
		ffiRetType = fetchPointerofObject(0, argTypes1);
		retClass = fetchPointerofObject(1, ffiRetType);
		retOop = instantiateClassindexableSize(retClass, 0);
		
#if SPURVM
		oop3 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
#else /* SPURVM */
		pushRemappableOop(retOop);
		oop3 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
		retOop = popRemappableOop();
#endif /* SPURVM */
		memcpy(firstIndexableField(oop3), longLongRetPtr, (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop, oop3);
		result = retOop;
		goto l9;
	}
	if (((calloutState->structReturnSize)) > (2 * BytesPerWord)) {
		intRet = 0;
		/* begin setReturnRegister:andCall:withArgsArray: */
		structAddr = ((sqLong) ((calloutState->limit)));
		arrayAddr = ((sqLong) ((&((calloutState->integerRegisters)))));
		callAndReturnWithStructAddr(structAddr, ((sqLong) (((void *) address))), arrayAddr);
	}
	else {
		structRet = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((SixteenByteReturnII (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]);
		intRet = (structRet.a);
	}
	if (isCalleePopsConvention((calloutState->callFlags))) {
		setsp((calloutState->argVector));
	}
	ownVM(vmHandle);
	if (((((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) != 0)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		/* begin ffiReturnType: */
		specLiteral = literalofMethod(0, primitiveMethod());
		argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
		returnType = fetchPointerofObject(0, argTypes);
		if (((((calloutState->ffiRetHeader)) & FFIFlagPointer) != 0)) {
			/* begin ffiReturnPointer:ofType:in: */
			retClass1 = fetchPointerofObject(1, returnType);
			if (retClass1 == (nilObject())) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec = (calloutState->ffiRetHeader);
				atomicType1 = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedChar8)) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					if (!(((usqInt) intRet))) {
						retOop1 = nilObject();
						goto l6;
					}
					cString = ((char *) (((usqInt) intRet)));
					strLen = 0;
					while (!((cString[strLen]) == 0)) {
						strLen += 1;
					}
					strOop = instantiateClassindexableSize(classString(), strLen);
					strPtr = firstIndexableField(strOop);
					for (i1 = 0; i1 < strLen; i1 += 1) {
						strPtr[i1] = (cString[i1]);
					}
					retOop1 = strOop;
	l6:	/* end ffiReturnCStringFrom: */;
					result = retOop1;
					goto l9;
				}
				
#if SPURVM
				oop1 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop1);
				ptr1[0] = (((sqInt) intRet));
				retOop1 = instantiateClassindexableSize(classExternalData(), 0);
				storePointerofObjectwithValue(0, retOop1, oop1);
#else /* SPURVM */
				pushRemappableOop(returnType);
				oop1 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop1);
				ptr1[0] = (((sqInt) intRet));
								pushRemappableOop(oop1);
				retOop1 = instantiateClassindexableSize(classExternalData(), 0);
				oop1 = popRemappableOop();
				storePointerofObjectwithValue(0, retOop1, oop1);
				returnType = popRemappableOop();
#endif /* SPURVM */
				storePointerofObjectwithValue(1, retOop1, returnType);
				result = retOop1;
				goto l9;
			}
			classOop = (((((calloutState->ffiRetHeader)) & FFIFlagStructure) != 0)
				? classByteArray()
				: classExternalAddress());
			
#if SPURVM
			oop1 = instantiateClassindexableSize(classOop, BytesPerWord);
#else /* SPURVM */
			pushRemappableOop(retClass1);
			oop1 = instantiateClassindexableSize(classOop, BytesPerWord);
			retClass1 = popRemappableOop();
#endif /* SPURVM */
			ptr1 = firstIndexableField(oop1);
			ptr1[0] = (((sqInt) intRet));
			
#if SPURVM
			retOop1 = instantiateClassindexableSize(retClass1, 0);
#else /* SPURVM */
			pushRemappableOop(oop1);
			retOop1 = instantiateClassindexableSize(retClass1, 0);
			oop1 = popRemappableOop();
#endif /* SPURVM */
			storePointerofObjectwithValue(0, retOop1, oop1);
			result = retOop1;
			goto l9;
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr1 = ((calloutState->structReturnType)
			? ((char *) ((&structRet)))
			: (calloutState->limit));
		retClass2 = fetchPointerofObject(1, returnType);
		retOop2 = instantiateClassindexableSize(retClass2, 0);
		
#if SPURVM
		oop2 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
#else /* SPURVM */
		pushRemappableOop(retOop2);
		oop2 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
		retOop2 = popRemappableOop();
#endif /* SPURVM */
		memcpy(firstIndexableField(oop2), longLongRetPtr1, (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop2, oop2);
		result = retOop2;
		goto l9;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	assert(!((isFloatAtomicType(atomicType))));
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(intRet))
			? intRet
			: intRet & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		result = (value == 0
			? falseObject()
			: trueObject());
		goto l9;
	}
	if (atomicType <= FFITypeSignedInt32) {

		/* these are all generall integer returns */
		if (atomicType <= (FFITypeSignedInt32)) {

			/* byte/short(/int). first extract partial word, then sign extend */

			/* # of significant bits */
			shift = (atomicType >= FFITypeUnsignedInt32
				? 32
				: (((usqInt)(atomicType)) >> 1) * 8);
			value = intRet & (((((unsigned long long)1)) << shift) - 1);
			if (((atomicType & 1) != 0)) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			result = integerObjectOf(value);
			goto l9;
		}
		if (((atomicType & 1) != 0)) {
			/* begin signedMachineIntegerFor: */
			result = signed64BitIntegerFor(((sqIntptr_t) intRet));
		}
		else {
			/* begin positiveMachineIntegerFor: */
			result = positive64BitIntegerFor(((usqIntptr_t) intRet));
		}
		goto l9;
	}
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedInt64)) >> 1)) {
		result = (((atomicType & 1) != 0)
			? signed64BitIntegerFor(intRet)
			: positive64BitIntegerFor(intRet));
		goto l9;
	}
	assert(isCharacterAtomicType(atomicType));
	switch (atomicType) {
	case FFITypeUnsignedChar8:
	case FFITypeSignedChar8:
		result = characterObjectOf(intRet & 0xFF);
		break;

	case FFITypeUnsignedChar16:
		result = characterObjectOf(intRet & 0xFFFF);
		break;

	case FFITypeUnsignedChar32:
		result = characterObjectOf(((unsigned int) intRet));
		break;

	default:
		error("Case not found and no otherwise clause");
		result = -1;
	}
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
	/* begin cleanupCalloutState: */
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs + 1, result);
	l10:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from ExternalFunction>>invokeWithArguments: */

	/* ThreadedFFIPlugin>>#primitiveCalloutWithArgs */
EXPORT(void)
primitiveCalloutWithArgs(void)
{
    sqInt address;
    sqInt address1;
    sqInt addressPtr;
    char *allocation;
    sqInt argArray;
    sqInt argClass;
    sqInt argSpec;
    sqInt argType;
    sqInt argTypeArray;
    sqInt argTypes;
    sqInt argTypes1;
    sqLong arrayAddr;
    sqInt atomicType;
    sqInt atomicType1;
    sqInt byteSize;
    extern void callAndReturnWithStructAddr(sqLong structAddr,sqLong procAddr,sqLong arrayAddr);
    CalloutState *calloutState;
    sqInt classOop;
    char *cString;
    double doubleRet;
    sqInt err;
    sqInt externalFunction;
    sqInt ffiRetType;
    sqInt flags;
    ThirtyTwoByteReturnDF floatRet;
    sqInt i;
    sqInt i1;
    usqLong intRet;
    extern void loadFloatRegs(double, double, double, double, double, double, double, double);
    void *longLongRetPtr;
    void *longLongRetPtr1;
    usqLong mask;
    sqInt nArgs;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt primNumArgs;
    sqIntptr_t *ptr;
    sqInt *ptr1;
    sqInt requiredStackSize;
    sqInt result;
    sqInt retClass;
    sqInt retClass1;
    sqInt retClass2;
    sqInt retOop;
    sqInt retOop1;
    sqInt retOop2;
    sqInt returnType;
    sqInt shift;
    sqInt specLiteral;
    sqInt specLiteral1;
    sqInt specSize;
    sqInt stackSize;
    sqInt strLen;
    sqInt strOop;
    char *strPtr;
    sqLong structAddr;
    SixteenByteReturnII structRet;
    CalloutState theCalloutState;
    sqInt typeSpec;
    sqInt typeSpec1;
    usqLong value;
    void *vmHandle;

	if (!((methodArgumentCount()) == 1)) {
		primitiveFailFor(PrimErrBadNumArgs);
		return;
	}
	externalFunction = stackValue(1);
	argArray = stackValue(0);
	if (!(isArray(argArray))) {
		primitiveFailFor(PrimErrBadArgument);
		return;
	}
	nArgs = slotSizeOf(argArray);
	/* begin ffiCall:ArgArrayOrNil:NumArgs: */
	primNumArgs = methodArgumentCount();
	if (!(isKindOfClass(externalFunction, classExternalFunction()))) {
		ffiFail(FFIErrorNotFunction);
		goto l10;
	}
	flags = fetchIntegerofObject(ExternalFunctionFlagsIndex, externalFunction);
	if (failed()) {
		ffiFail(FFIErrorBadArgs);
		goto l10;
	}
	/* begin ffiLoadCalloutAddress: */

	/* Make sure it's an external handle */
	addressPtr = fetchPointerofObject(0, externalFunction);
	
	if (!((isBytes(addressPtr))
		 && ((byteSizeOf(addressPtr)) == (sizeof(sqInt))))) {
		address1 = ffiFail(FFIErrorBadAddress);
		goto l2;
	}
	address1 = fetchPointerofObject(0, addressPtr);
	l2:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		address = 0;
		goto l3;
	}
	if (address1 == 0) {

		/* Go look it up in the module */
		if (externalFunctionInstSize > ExternalFunctionStackSizeIndex) {
			storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, -1);
		}
		if ((slotSizeOf(externalFunction)) < 5) {
			address = ffiFail(FFIErrorNoModule);
			goto l3;
		}
		address1 = ffiLoadCalloutAddressFrom(externalFunction);
		if (failed()) {
			address = 0;
			goto l3;
		}
		ptr = firstIndexableField(addressPtr);
		ptr[0] = address1;
	}
	address = address1;
	l3:	/* end ffiLoadCalloutAddress: */;
	if (failed()) {
		goto l10;
	}

	/* must be array of arg types */
	argTypeArray = fetchPointerofObject(ExternalFunctionArgTypesIndex, externalFunction);
	if (!((isArray(argTypeArray))
		 && ((slotSizeOf(argTypeArray)) == (nArgs + 1)))) {
		ffiFail(FFIErrorBadArgs);
		goto l10;
	}
#  if COGMTVM
	if (!(((flags & FFICallTypesMask) == FFICallTypeCDecl)
		 || ((flags & FFICallTypesMask) == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l10;
	}
#  else // COGMTVM

	/* not masking causes threaded calls to fail, which is as they should if the plugin is not threaded. */
	if (!((flags == FFICallTypeCDecl)
		 || (flags == FFICallTypeApi))) {
		ffiFail(FFIErrorCallType);
		goto l10;
	}
#  endif // COGMTVM
	requiredStackSize = (externalFunctionInstSize > ExternalFunctionStackSizeIndex
		? fetchIntegerofObject(ExternalFunctionStackSizeIndex, externalFunction)
		: -1);
	if (failed()) {
		primitiveFailFor((argArray == null
			? PrimErrBadMethod
			: PrimErrBadReceiver));
		goto l10;
	}
	stackSize = (requiredStackSize < 0
		? DefaultMaxStackSize
		: requiredStackSize);
	calloutState = (&theCalloutState);
	memset(calloutState, 0, sizeof(CalloutState));
	(calloutState->callFlags = flags);
	argType = fetchPointerofObject(0, argTypeArray);
	argSpec = fetchPointerofObject(0, argType);

	/* Witten this way to allow Slang to inline ffiCheckReturn:With:in: */
	argClass = fetchPointerofObject(1, argType);
	/* begin ffiCheckReturn:With:in: */
	if (!(argClass == (nilObject()))) {
		if (!(includesBehaviorThatOf(argClass, classExternalStructure()))) {
			err = FFIErrorBadReturn;
			goto l4;
		}
	}
	if (!((isWords(argSpec))
		 && ((slotSizeOf(argSpec)) > 0))) {
		err = FFIErrorWrongType;
		goto l4;
	}
	(calloutState->ffiRetSpec = argSpec);
	(calloutState->ffiRetHeader = fetchLong32ofObject(0, argSpec));
	if (!(((((calloutState->ffiRetHeader)) & FFIFlagAtomic) != 0))) {
		if (argClass == (nilObject())) {
			err = FFIErrorBadReturn;
			goto l4;
		}
	}
	if ((((calloutState->ffiRetHeader)) & (FFIFlagPointer | FFIFlagStructure)) == FFIFlagStructure) {
		(calloutState->structReturnSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask);
		/* begin encodeStructReturnTypeIn: */
		(calloutState->structReturnType = ((calloutState->structReturnSize)) <= (2 * BytesPerWord));
	}
	err = 0;
	l4:	/* end ffiCheckReturn:With:in: */;
	if (err != 0) {
		ffiFail(err);
		goto l10;
	}
	allocation = alloca((stackSize + ((calloutState->structReturnSize))) + (cStackAlignment()));
	if (mustAlignStack()) {
		allocation = ((char *) ((((((usqIntptr_t)allocation)) | ((cStackAlignment()) - 1)) - ((cStackAlignment()) - 1))));
	}
	(calloutState->argVector = allocation);
	(calloutState->currentArg = allocation);
	(calloutState->limit = allocation + stackSize);
	for (i = 1; i <= nArgs; i += 1) {
		argType = fetchPointerofObject(i, argTypeArray);
		argSpec = fetchPointerofObject(0, argType);
		argClass = fetchPointerofObject(1, argType);
		oop = (argArray == null
			? stackValue(nArgs - i)
			: fetchPointerofObject(i - 1, argArray));
		err = ffiArgumentSpecClassin(oop, argSpec, argClass, calloutState);
		if (err != 0) {
			/* begin cleanupCalloutState: */
			while (((calloutState->stringArgIndex)) > 0) {
				free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
			}
#      if COGMTVM
			if (err == (-PrimErrObjectMayMove)) {
				goto l10;
			}
#      endif
			ffiFail(err);
			goto l10;
		}
	}
	assert(!(failed()));
	/* begin ffiLogCallout: */
	if (ffiLogEnabled) {
		doFFILogCallout(externalFunction);
	}
	if ((requiredStackSize < 0)
	 && (externalFunctionInstSize > ExternalFunctionStackSizeIndex)) {
		stackSize = ((calloutState->currentArg)) - ((calloutState->argVector));
		storeIntegerofObjectwithValue(ExternalFunctionStackSizeIndex, externalFunction, stackSize);
	}
	/* begin ffiCalloutTo:SpecOnStack:in: */
	vmHandle = disownVM((((((calloutState->callFlags)) & FFICallFlagThreaded) != 0)
		? DisownVMForFFICall + DisownVMForThreading
		: DisownVMForFFICall));
	if (((calloutState->floatRegisterIndex)) > 0) {
		loadFloatRegs(((calloutState->floatRegisters))[0], ((calloutState->floatRegisters))[1], ((calloutState->floatRegisters))[2], ((calloutState->floatRegisters))[3], ((calloutState->floatRegisters))[4], ((calloutState->floatRegisters))[5], ((calloutState->floatRegisters))[6], ((calloutState->floatRegisters))[7]);
	}
	if ((allocaLiesSoSetSpBeforeCall())
	 || (mustAlignStack())) {
		setsp((calloutState->argVector));
	}
	/* begin atomicTypeOf: */
	typeSpec1 = (calloutState->ffiRetHeader);
	atomicType = ((usqInt)((typeSpec1 & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSingleFloat)) >> 1)) {
		if (atomicType == FFITypeDoubleFloat) {
			doubleRet = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((double (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]);
		}
		else {
			doubleRet = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((float (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]);
		}
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(vmHandle);
		result = floatObjectOf(doubleRet);
		goto l9;
	}
	if (((((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) == FFIFlagStructure)
	 && (structIsHomogenousFloatArrayOfSizetypeSpecofLength(((calloutState->ffiRetHeader)) & FFIStructSizeMask, ((unsigned int *) (firstIndexableField((calloutState->ffiRetSpec)))), ((specSize = byteSizeOf((calloutState->ffiRetSpec)))) / (sizeof(unsigned int))))) {
		(floatRet.d = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((struct dprr (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]));
		if (isCalleePopsConvention((calloutState->callFlags))) {
			setsp((calloutState->argVector));
		}
		ownVM(vmHandle);
		if (specSize > ((calloutState->structReturnSize))) {
			((((floatRet.f)).floats))[1] = (((((floatRet.f)).floats))[2]);
			((((floatRet.f)).floats))[2] = (((((floatRet.f)).floats))[4]);
			((((floatRet.f)).floats))[3] = (((((floatRet.f)).floats))[6]);
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr = (&floatRet);
		specLiteral1 = (argArray != null
			? stackValue(1)
			: literalofMethod(0, primitiveMethod()));
		argTypes1 = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral1);
		ffiRetType = fetchPointerofObject(0, argTypes1);
		retClass = fetchPointerofObject(1, ffiRetType);
		retOop = instantiateClassindexableSize(retClass, 0);
		
#if SPURVM
		oop3 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
#else /* SPURVM */
		pushRemappableOop(retOop);
		oop3 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
		retOop = popRemappableOop();
#endif /* SPURVM */
		memcpy(firstIndexableField(oop3), longLongRetPtr, (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop, oop3);
		result = retOop;
		goto l9;
	}
	if (((calloutState->structReturnSize)) > (2 * BytesPerWord)) {
		intRet = 0;
		/* begin setReturnRegister:andCall:withArgsArray: */
		structAddr = ((sqLong) ((calloutState->limit)));
		arrayAddr = ((sqLong) ((&((calloutState->integerRegisters)))));
		callAndReturnWithStructAddr(structAddr, ((sqLong) (((void *) address))), arrayAddr);
	}
	else {
		structRet = dispatchFunctionPointerwithwithwithwithwithwithwithwith(((SixteenByteReturnII (*)(sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t, sqIntptr_t)) (((void *) address))), ((calloutState->integerRegisters))[0], ((calloutState->integerRegisters))[1], ((calloutState->integerRegisters))[2], ((calloutState->integerRegisters))[3], ((calloutState->integerRegisters))[4], ((calloutState->integerRegisters))[5], ((calloutState->integerRegisters))[6], ((calloutState->integerRegisters))[7]);
		intRet = (structRet.a);
	}
	if (isCalleePopsConvention((calloutState->callFlags))) {
		setsp((calloutState->argVector));
	}
	ownVM(vmHandle);
	if (((((calloutState->ffiRetHeader)) & (FFIFlagPointer + FFIFlagStructure)) != 0)) {

		/* Note: Order is important here since FFIFlagPointer + FFIFlagStructure is used to represent
		   'typedef void* VoidPointer' and VoidPointer must be returned as pointer *not* as struct. */
		/* begin ffiReturnType: */
		specLiteral = (argArray != null
			? stackValue(1)
			: literalofMethod(0, primitiveMethod()));
		argTypes = fetchPointerofObject(ExternalFunctionArgTypesIndex, specLiteral);
		returnType = fetchPointerofObject(0, argTypes);
		if (((((calloutState->ffiRetHeader)) & FFIFlagPointer) != 0)) {
			/* begin ffiReturnPointer:ofType:in: */
			retClass1 = fetchPointerofObject(1, returnType);
			if (retClass1 == (nilObject())) {

				/* Create ExternalData upon return */
				/* begin atomicTypeOf: */
				typeSpec = (calloutState->ffiRetHeader);
				atomicType1 = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
				if ((((usqInt)(atomicType1)) >> 1) == (((usqInt)(FFITypeSignedChar8)) >> 1)) {

					/* String return */
					/* begin ffiReturnCStringFrom: */
					if (!(((usqInt) intRet))) {
						retOop1 = nilObject();
						goto l6;
					}
					cString = ((char *) (((usqInt) intRet)));
					strLen = 0;
					while (!((cString[strLen]) == 0)) {
						strLen += 1;
					}
					strOop = instantiateClassindexableSize(classString(), strLen);
					strPtr = firstIndexableField(strOop);
					for (i1 = 0; i1 < strLen; i1 += 1) {
						strPtr[i1] = (cString[i1]);
					}
					retOop1 = strOop;
	l6:	/* end ffiReturnCStringFrom: */;
					result = retOop1;
					goto l9;
				}
				
#if SPURVM
				oop1 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop1);
				ptr1[0] = (((sqInt) intRet));
				retOop1 = instantiateClassindexableSize(classExternalData(), 0);
				storePointerofObjectwithValue(0, retOop1, oop1);
#else /* SPURVM */
				pushRemappableOop(returnType);
				oop1 = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
				ptr1 = firstIndexableField(oop1);
				ptr1[0] = (((sqInt) intRet));
								pushRemappableOop(oop1);
				retOop1 = instantiateClassindexableSize(classExternalData(), 0);
				oop1 = popRemappableOop();
				storePointerofObjectwithValue(0, retOop1, oop1);
				returnType = popRemappableOop();
#endif /* SPURVM */
				storePointerofObjectwithValue(1, retOop1, returnType);
				result = retOop1;
				goto l9;
			}
			classOop = (((((calloutState->ffiRetHeader)) & FFIFlagStructure) != 0)
				? classByteArray()
				: classExternalAddress());
			
#if SPURVM
			oop1 = instantiateClassindexableSize(classOop, BytesPerWord);
#else /* SPURVM */
			pushRemappableOop(retClass1);
			oop1 = instantiateClassindexableSize(classOop, BytesPerWord);
			retClass1 = popRemappableOop();
#endif /* SPURVM */
			ptr1 = firstIndexableField(oop1);
			ptr1[0] = (((sqInt) intRet));
			
#if SPURVM
			retOop1 = instantiateClassindexableSize(retClass1, 0);
#else /* SPURVM */
			pushRemappableOop(oop1);
			retOop1 = instantiateClassindexableSize(retClass1, 0);
			oop1 = popRemappableOop();
#endif /* SPURVM */
			storePointerofObjectwithValue(0, retOop1, oop1);
			result = retOop1;
			goto l9;
		}
		/* begin ffiReturnStruct:ofType:in: */
		longLongRetPtr1 = ((calloutState->structReturnType)
			? ((char *) ((&structRet)))
			: (calloutState->limit));
		retClass2 = fetchPointerofObject(1, returnType);
		retOop2 = instantiateClassindexableSize(retClass2, 0);
		
#if SPURVM
		oop2 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
#else /* SPURVM */
		pushRemappableOop(retOop2);
		oop2 = instantiateClassindexableSize(classByteArray(), (calloutState->structReturnSize));
		retOop2 = popRemappableOop();
#endif /* SPURVM */
		memcpy(firstIndexableField(oop2), longLongRetPtr1, (calloutState->structReturnSize));
		storePointerofObjectwithValue(0, retOop2, oop2);
		result = retOop2;
		goto l9;
	}
	/* begin ffiCreateIntegralResultOop:ofAtomicType:in: */
	assert(!((isFloatAtomicType(atomicType))));
	if (atomicType == FFITypeBool) {

		/* Make sure bool honors the byte size requested */
		byteSize = ((calloutState->ffiRetHeader)) & FFIStructSizeMask;
		value = (byteSize == (sizeof(intRet))
			? intRet
			: intRet & (((((unsigned long long)1)) << (byteSize * 8)) - 1));
		result = (value == 0
			? falseObject()
			: trueObject());
		goto l9;
	}
	if (atomicType <= FFITypeSignedInt32) {

		/* these are all generall integer returns */
		if (atomicType <= (FFITypeSignedInt32)) {

			/* byte/short(/int). first extract partial word, then sign extend */

			/* # of significant bits */
			shift = (atomicType >= FFITypeUnsignedInt32
				? 32
				: (((usqInt)(atomicType)) >> 1) * 8);
			value = intRet & (((((unsigned long long)1)) << shift) - 1);
			if (((atomicType & 1) != 0)) {

				/* make the guy signed */
				mask = (((unsigned long long)1)) << (shift - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			result = integerObjectOf(value);
			goto l9;
		}
		if (((atomicType & 1) != 0)) {
			/* begin signedMachineIntegerFor: */
			result = signed64BitIntegerFor(((sqIntptr_t) intRet));
		}
		else {
			/* begin positiveMachineIntegerFor: */
			result = positive64BitIntegerFor(((usqIntptr_t) intRet));
		}
		goto l9;
	}
	if ((((usqInt)(atomicType)) >> 1) == (((usqInt)(FFITypeSignedInt64)) >> 1)) {
		result = (((atomicType & 1) != 0)
			? signed64BitIntegerFor(intRet)
			: positive64BitIntegerFor(intRet));
		goto l9;
	}
	assert(isCharacterAtomicType(atomicType));
	switch (atomicType) {
	case FFITypeUnsignedChar8:
	case FFITypeSignedChar8:
		result = characterObjectOf(intRet & 0xFF);
		break;

	case FFITypeUnsignedChar16:
		result = characterObjectOf(intRet & 0xFFFF);
		break;

	case FFITypeUnsignedChar32:
		result = characterObjectOf(((unsigned int) intRet));
		break;

	default:
		error("Case not found and no otherwise clause");
		result = -1;
	}
	l9:	/* end ffiCalloutTo:SpecOnStack:in: */;
	/* begin cleanupCalloutState: */
	while (((calloutState->stringArgIndex)) > 0) {
		free(((calloutState->stringArgs))[(calloutState->stringArgIndex = ((calloutState->stringArgIndex)) - 1)]);
	}
	popthenPush(primNumArgs + 1, result);
	l10:	/* end ffiCall:ArgArrayOrNil:NumArgs: */;
	return;
}


/*	Two forms of C Data Model infomation.
	With 0 arguments answer the string naming the C data model, LP32, LP64,
	LLP64, etc.
	WIth 1 argument, which must be a ByteArray of at least 9 elements, answer
	the sizes of
	char, short, int, long, long long, wchar_t, float, double, void *. */

	/* ThreadedFFIPlugin>>#primitiveCDataModel */
EXPORT(sqInt)
primitiveCDataModel(void)
{
    char * cascade0;
    sqInt errorCode;
    char *model;
    sqInt sizes;

	model = ((char *) 0);
	if ((methodArgumentCount()) == 1) {
		sizes = stackValue(0);
		if (!((isBytes(sizes))
			 && ((slotSizeOf(sizes)) == 9))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		cascade0 = ((char *) (firstIndexableField(sizes)));
		cascade0[0] = (sizeof(char));
		cascade0[1] = (sizeof(short));
		cascade0[2] = (sizeof(int));
		cascade0[3] = (sizeof(long));
		cascade0[4] = (sizeof(long long));
		cascade0[5] = (sizeof(wchar_t));
		cascade0[6] = (sizeof(float));
		cascade0[7] = (sizeof(double));
		cascade0[8] = (sizeof(void *));
		return methodReturnValue(sizes);
	}
	if (!((methodArgumentCount()) == 0)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}

	/* Set bit 0 if char is wrong, bit 1 if short is wrong, 2 for int, 3 for long, 4 for long long, 5 for void * */
	errorCode = 0;
	if ((sizeof(char)) != 1) {
		errorCode += 1;
	}
	if ((sizeof(short)) != 2) {

		/* N.B. SILP64 exists on Cray supercomputers; we don't care... */
		errorCode += 2;
	}
	if ((sizeof(long long)) != 8) {
		errorCode += 16;
	}
	if ((sizeof(void *)) == 8) {

		/* LP64 LLP64 ILP64 */
		if ((sizeof(int)) == 8) {

			/* ILP64 */
			if ((sizeof(long)) == 8) {
				model = "ILP64";
			}
			else {
				errorCode += 8;
			}
		}
		if ((sizeof(int)) == 4) {

			/* LP64 or LLP64 */
			if ((sizeof(long)) == 8) {

				/* LP64 */
				model = "LP64";
			}
			if ((sizeof(long)) == 4) {

				/* LLP64 */
				model = "LLP64";
			}
			if (((sizeof(long)) != 8)
			 && ((sizeof(long)) != 4)) {
				errorCode += 8;
			}
		}
		if (((sizeof(int)) != 8)
		 && ((sizeof(int)) != 4)) {
			errorCode += 4;
		}
	}
	if ((sizeof(void *)) == 4) {

		/* LP32 ILP32 */
		if ((sizeof(long)) != 4) {
			errorCode += 8;
		}
		if ((sizeof(int)) == 4) {

			/* ILP32 */
			model = "ILP32";
		}
		if ((sizeof(int)) == 2) {

			/* LP32 */
			model = "LP32";
		}
		if (((sizeof(int)) != 4)
		 && ((sizeof(int)) != 2)) {
			errorCode += 4;
		}
	}
	if (((sizeof(void *)) != 8)
	 && ((sizeof(void *)) != 4)) {
		errorCode += 32;
	}
	if (errorCode != 0) {
		return primitiveFailForOSError(errorCode);
	}
	if (!model) {
		return primitiveFailFor(PrimErrNotFound);
	}
	methodReturnString(model);
	return 0;
}


/*	arguments: name(type, stack offset)
	width(Integer, 4)
	height(Integer, 3)
	rowPitch(Integer, 2)
	depth(Integer, 1)
	isMSB(Boolean, 0) */

	/* ThreadedFFIPlugin>>#primitiveCreateManualSurface */
EXPORT(sqInt)
primitiveCreateManualSurface(void)
{
    sqInt depth;
    sqInt height;
    sqInt isMSB;
    sqInt result;
    sqInt rowPitch;
    sqInt width;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	width = stackIntegerValue(4);
	height = stackIntegerValue(3);
	rowPitch = stackIntegerValue(2);
	depth = stackIntegerValue(1);
	isMSB = stackValue(0);
	isMSB = booleanValueOf(isMSB);
	if (!(failed())) {
		result = createManualSurface(width, height, rowPitch, depth, isMSB);
		if (result >= 0) {
			return methodReturnInteger(result);
		}
	}
	primitiveFail();
	return 0;
}

	/* ThreadedFFIPlugin>>#primitiveDestroyManualSurface */
EXPORT(sqInt)
primitiveDestroyManualSurface(void)
{
    sqInt surfaceID;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	surfaceID = stackIntegerValue(0);
	if (!(failed())) {
		if ((destroyManualSurface(surfaceID)) == 0) {
			primitiveFail();
		}
		else {
			pop(1);
		}
	}
	return 0;
}


/*	Answer the address of a 4 byte or 8 byte ExternalAddress. */

	/* ThreadedFFIPlugin>>#primitiveExternalAddressAsInteger */
EXPORT(sqInt)
primitiveExternalAddressAsInteger(void)
{
    sqInt rcvr;
    sqInt size;

	rcvr = stackValue(0);
	size = byteSizeOf(rcvr);
	if (size == 8) {
		return methodReturnValue(positive64BitIntegerFor((*((usqLong *) (firstIndexableField(rcvr))))));
	}
	if (size == 4) {
		return methodReturnValue(positive32BitIntegerFor((*((unsigned int *) (firstIndexableField(rcvr))))));
	}
	primitiveFailFor(PrimErrBadReceiver);
	return 0;
}


/*	Answer a 4 byte or 8 byte ExternalAddress with value of the argument. */

	/* ThreadedFFIPlugin>>#primitiveExternalAddressFromInteger */
EXPORT(sqInt)
primitiveExternalAddressFromInteger(void)
{
    sqInt address;
    usqIntptr_t value;

	value = positiveMachineIntegerValueOf(stackValue(0));
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	address = instantiateClassindexableSize(classExternalAddress(), BytesPerWord);
	if (address == null) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	else {
		(*((usqIntptr_t *) (firstIndexableField(address))) = value);
		return methodReturnValue(address);
	}
}


/*	Primitive. Allocate an object on the external heap. */

	/* ThreadedFFIPlugin>>#primitiveFFIAllocate */
EXPORT(sqInt)
primitiveFFIAllocate(void)
{
    sqInt addr;
    sqInt byteSize;
    sqInt oop;
    sqIntptr_t *ptr;

	byteSize = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	addr = ffiAlloc(byteSize);
	if (addr == 0) {
		return primitiveFail();
	}
	oop = instantiateClassindexableSize(classExternalAddress(), sizeof(sqIntptr_t));
	ptr = firstIndexableField(oop);
	ptr[0] = addr;
	return popthenPush(2, oop);
}


/*	Answer a 64-bit IEEE double the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIDoubleAt */
EXPORT(sqInt)
primitiveFFIDoubleAt(void)
{
    void *addr;
    sqInt byteOffset;
    double floatValue;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(double));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		memcpy((&floatValue), addr, sizeof(double));
		return methodReturnFloat(floatValue);
	}
}


/*	Store a 64-bit IEEE double the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIDoubleAtPut */
EXPORT(sqInt)
primitiveFFIDoubleAtPut(void)
{
    void *addr;
    sqInt byteOffset;
    double floatValue;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = stackValue(0);
	if (isFloatObject(valueOop)) {
		floatValue = ((double) (floatValueOf(valueOop)));
	}
	else {
		if (isIntegerObject(valueOop)) {
			floatValue = ((double) (integerValueOf(valueOop)));
		}
		else {
			return primitiveFailFor(PrimErrBadArgument);
		}
	}
	byteOffset = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	rcvr = stackValue(2);
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(double));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		memcpy(addr, (&floatValue), sizeof(double));
		return methodReturnValue(valueOop);
	}
}


/*	Answer a 32-bit IEEE float the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIFloatAt */
EXPORT(sqInt)
primitiveFFIFloatAt(void)
{
    void *addr;
    sqInt byteOffset;
    float floatValue;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(float));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		memcpy((&floatValue), addr, sizeof(float));
		return methodReturnFloat(floatValue);
	}
}


/*	Store a 32-bit IEEE float the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveFFIFloatAtPut */
EXPORT(sqInt)
primitiveFFIFloatAtPut(void)
{
    void *addr;
    sqInt byteOffset;
    float floatValue;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = stackValue(0);
	if (isFloatObject(valueOop)) {
		floatValue = ((float) (floatValueOf(valueOop)));
	}
	else {
		if (isIntegerObject(valueOop)) {
			floatValue = ((float) (integerValueOf(valueOop)));
		}
		else {
			return primitiveFailFor(PrimErrBadArgument);
		}
	}
	byteOffset = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	rcvr = stackValue(2);
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(float));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		memcpy(addr, (&floatValue), sizeof(floatValue));
		return methodReturnValue(valueOop);
	}
}


/*	Primitive. Free the object pointed to on the external heap. */

	/* ThreadedFFIPlugin>>#primitiveFFIFree */
EXPORT(sqInt)
primitiveFFIFree(void)
{
    sqIntptr_t addr;
    sqInt oop;
    sqIntptr_t *ptr;

	oop = stackValue(0);
	if (!(((fetchClassOf(oop)) == (classExternalAddress()))
		 && ((byteSizeOf(oop)) == (sizeof(sqIntptr_t))))) {
		return primitiveFail();
	}
	ptr = firstIndexableField(oop);

	/* Don't you dare to free Squeak's memory! */
	addr = ptr[0];
	if ((addr == 0)
	 || ((((((usqIntptr_t)addr)) & ((sizeof(sqIntptr_t)) - 1)) != 0)
	 || (isInMemory(((usqIntptr_t)addr))))) {
		return primitiveFail();
	}
	ffiFree(addr);
	return ptr[0] = 0;
}


/*	Primitive. Return the error code from a failed call to the foreign
	function interface.
	This is for backwards-compatibility. Thread-safe access to the error code
	is via the
	primitive error code. */

	/* ThreadedFFIPlugin>>#primitiveFFIGetLastError */
EXPORT(sqInt)
primitiveFFIGetLastError(void)
{
	methodReturnInteger(ffiLastError);
	return 0;
}


/*	Answer a (signed or unsigned) n byte integer from the given byte offset
	in the receiver, using the platform's endianness. */

	/* ThreadedFFIPlugin>>#primitiveFFIIntegerAt */
EXPORT(sqInt)
primitiveFFIIntegerAt(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    usqLong mask;
    sqInt rcvr;
    usqLong value;
    sqInt valueOop;

	isSigned = booleanValueOf(stackValue(0));
	byteSize = stackIntegerValue(1);
	byteOffset = stackIntegerValue(2);
	rcvr = stackValue(3);
	if (failed()) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((((byteSize >= 1) && (byteSize <= 8)))
		 && ((byteSize & (byteSize - 1)) == 0)))) {
		return primitiveFail();
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (addr == null) {
		return primitiveFailFor((isWordsOrBytes(rcvr)
			? PrimErrBadIndex
			: PrimErrBadReceiver));
	}
	else {
		if (byteSize <= 2) {
			if (byteSize == 1) {
				value = ((unsigned char) (byteAt(addr)));
			}
			else {
				value = ((unsigned short) (unalignedShortAt(addr)));
			}
		}
		else {
			if (byteSize == 4) {
				value = ((unsigned int) (unalignedLong32At(addr)));
			}
			else {
				value = unalignedLong64At(addr);
			}
		}
		if (byteSize < BytesPerWord) {
			if (isSigned) {

				/* sign extend value */
				mask = (((unsigned long long)1)) << ((byteSize * 8) - 1);
				value = (value & (mask - 1)) - (value & mask);
			}
			valueOop = integerObjectOf(value);
		}
		else {

			/* general 64 bit integer; note these never fail */
			if (isSigned) {
				if (byteSize < 8) {

					/* sign extend value */
					mask = (((unsigned long long)1)) << ((byteSize * 8) - 1);
					value = (value & (mask - 1)) - (value & mask);
				}
				valueOop = signed64BitIntegerFor(value);
			}
			else {
				valueOop = positive64BitIntegerFor(value);
			}
		}
		return methodReturnValue(valueOop);
	}
}


/*	Store a (signed or unsigned) n byte integer at the given byte offset
	in the receiver, using the platform's endianness. */

	/* ThreadedFFIPlugin>>#primitiveFFIIntegerAtPut */
EXPORT(sqInt)
primitiveFFIIntegerAtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt byteSize;
    sqInt isSigned;
    sqLong max;
    sqInt rcvr;
    sqLong value;
    sqInt valueOop;

	isSigned = booleanValueOf(stackValue(0));
	byteSize = stackIntegerValue(1);
	valueOop = stackValue(2);
	byteOffset = stackIntegerValue(3);
	rcvr = stackValue(4);
	if (failed()) {
		return 0;
	}
	if (!((byteOffset > 0)
		 && ((((byteSize >= 1) && (byteSize <= 8)))
		 && ((byteSize & (byteSize - 1)) == 0)))) {
		return primitiveFail();
	}
	addr = ffiAddressOfstartingAtsize(rcvr, byteOffset, byteSize);
	if (addr == null) {
		return primitiveFailFor((isWordsOrBytes(rcvr)
			? PrimErrBadIndex
			: PrimErrBadReceiver));
	}
	else {
		if (isSigned) {
			value = signed64BitValueOf(valueOop);
		}
		else {
			value = positive64BitValueOf(valueOop);
		}
		if (failed()) {
			return 0;
		}
		if (byteSize < 8) {
			if (isSigned) {
				max = (((unsigned long long)1)) << ((8 * byteSize) - 1);
				if (!((value >= (0 - max))
					 && (value < max))) {
					return primitiveFail();
				}
			}
			else {
				if (!((((unsigned long long)value)) < ((((unsigned long long)1)) << (8 * byteSize)))) {
					return primitiveFail();
				}
			}
		}
		if (byteSize <= 2) {
			if (byteSize == 1) {
				byteAtput(addr, value);
			}
			else {
				unalignedShortAtput(addr, value);
			}
		}
		else {
			if (byteSize == 4) {
				unalignedLong32Atput(addr, value);
			}
			else {
				unalignedLong64Atput(addr, value);
			}
		}
		return methodReturnValue(valueOop);
	}
}


/*	Primitive. Force loading the receiver (an instance of ExternalLibrary). */

	/* ThreadedFFIPlugin>>#primitiveForceLoad */
EXPORT(sqInt)
primitiveForceLoad(void)
{
    sqInt ffiModuleName;
    sqInt moduleHandle;
    sqInt moduleHandlePtr;
    sqInt *ptr;
    sqInt rcvr;

	if (!((methodArgumentCount()) == 0)) {
		return primitiveFail();
	}
	rcvr = stackValue(0);
	if (!(isKindOfClass(rcvr, classExternalLibrary()))) {
		return ffiFail(FFIErrorBadExternalLibrary);
	}
	moduleHandlePtr = fetchPointerofObject(0, rcvr);
	/* begin ffiContentsOfHandle:errCode: */
	if (!((isBytes(moduleHandlePtr))
		 && ((byteSizeOf(moduleHandlePtr)) == (sizeof(sqInt))))) {
		moduleHandle = ffiFail(FFIErrorBadExternalLibrary);
		goto l1;
	}
	moduleHandle = fetchPointerofObject(0, moduleHandlePtr);
	l1:	/* end ffiContentsOfHandle:errCode: */;
	if (failed()) {
		return 0;
	}
	ffiModuleName = fetchPointerofObject(1, rcvr);
	if (!(isBytes(ffiModuleName))) {
		return ffiFail(FFIErrorBadExternalLibrary);
	}
	moduleHandle = ((sqInt)(ioLoadModuleOfLength(((sqInt)(firstIndexableField(ffiModuleName))), byteSizeOf(ffiModuleName))));
	if (failed()) {
		return ffiFail(FFIErrorModuleNotFound);
	}
	ptr = firstIndexableField(moduleHandlePtr);
	ptr[0] = moduleHandle;
	return 0;
}


/*	Attempt to find the address of a symbol in a loaded library.
	loadSymbol: aSymbol fromModule: moduleName
	<primitive: 'primitiveLoadSymbolFromModule' error: errorCode module:
	'SqueakFFIPrims'>  */

	/* ThreadedFFIPlugin>>#primitiveLoadSymbolFromModule */
EXPORT(sqInt)
primitiveLoadSymbolFromModule(void)
{
    void *address;
    sqInt module;
    sqInt moduleHandle;
    sqInt oop;
    void **ptr;
    sqInt symbol;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	module = stackValue(0);
	symbol = stackValue(1);
	moduleHandle = (module != (nilObject())
		? ffiLoadCalloutModule(module)
		: 0);
	if (failed()) {
		return primitiveFailFor(PrimErrNotFound);
	}
	address = ioLoadSymbolOfLengthFromModule(((sqInt) (firstIndexableField(symbol))), byteSizeOf(symbol), ((void *)moduleHandle));
	if ((failed())
	 || (address == 0)) {
		return primitiveFailFor(PrimErrNotFound);
	}
	oop = instantiateClassindexableSize(classExternalAddress(), sizeof(void *));
	ptr = firstIndexableField(oop);
	ptr[0] = address;
	return methodReturnValue(oop);
}


/*	Enable logging of FFI calls by providing it with a log file name. */

	/* ThreadedFFIPlugin>>#primitiveLogCallsTo */
EXPORT(sqInt)
primitiveLogCallsTo(void)
{
    sqInt logFile;
    sqInt ok;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	logFile = stackValue(0);
	if (logFile == (nilObject())) {

		/* disable logging */
		ok = ffiLogFileNameOfLength(null, 0);
		if (!ok) {
			return primitiveFail();
		}
		ffiLogEnabled = 0;
	}
	else {

		/* enable logging */
		if (!(isBytes(logFile))) {
			return primitiveFail();
		}
		ok = ffiLogFileNameOfLength(firstIndexableField(logFile), byteSizeOf(logFile));
		if (!ok) {
			return primitiveFail();
		}
		ffiLogEnabled = 1;
	}
	return pop(1);
}


/*	Answer the plugins current version to ensure compatibility with data
	structures shared between plugin an image code such as:
	- Type codes in FFIConstants
	- Known classes in the special-objects array */

	/* ThreadedFFIPlugin>>#primitivePluginVersion */
EXPORT(sqInt)
primitivePluginVersion(void)
{
	return methodReturnInteger(1);
}


/*	Create a 'manual surface' data-structure. See the ExternalForm class in
	the FFI package for example usage. */
/*	arguments: name(type, stack offset)
	surfaceID(Integer, 1)
	ptr(uint32/uint64, 0) */

	/* ThreadedFFIPlugin>>#primitiveSetManualSurfacePointer */
EXPORT(sqInt)
primitiveSetManualSurfacePointer(void)
{
    usqIntptr_t ptr;
    sqInt result;
    sqInt surfaceID;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	surfaceID = stackIntegerValue(1);
	ptr = positiveMachineIntegerValueOf(stackValue(0));
	if (failed()) {
		return null;
	}
	result = setManualSurfacePointer(surfaceID, ((void *)ptr));
	if (result == 0) {
		return primitiveFail();
	}
	return pop(2);
}


/*	Answer the signed 16-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt16At */
EXPORT(sqInt)
primitiveSignedInt16At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(short));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnInteger(((signed short) (unalignedShortAt(addr))));
	}
}


/*	Store the signed 16-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt16AtPut */
EXPORT(sqInt)
primitiveSignedInt16AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	if (!((isIntegerObject(valueArg))
		 && ((((((value = integerValueOf(valueArg))) >= -32768) && (value <= 0x7FFF)))
		 && (isIntegerObject(byteOffset))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(short));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		unalignedShortAtput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the signed 32-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt32At */
EXPORT(sqInt)
primitiveSignedInt32At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(int));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnValue(signed32BitIntegerFor(((signed int) (unalignedLong32At(addr)))));
	}
}


/*	Store the signed 32-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt32AtPut */
EXPORT(sqInt)
primitiveSignedInt32AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    int value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	value = signed32BitValueOf(valueArg);
	if (!((!(failed()))
		 && (isIntegerObject(byteOffset)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(int));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		unalignedLong32Atput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the signed 64-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt64At */
EXPORT(sqInt)
primitiveSignedInt64At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(sqLong));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnValue(signed64BitIntegerFor(((sqLong) (unalignedLong64At(addr)))));
	}
}


/*	Store the signed 64-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt64AtPut */
EXPORT(sqInt)
primitiveSignedInt64AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqLong value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	value = signed64BitValueOf(valueArg);
	if (!((!(failed()))
		 && (isIntegerObject(byteOffset)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(sqLong));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		unalignedLong64Atput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the signed 8-bit integer starting at the given byte offset (native
	endian). 
 */

	/* ThreadedFFIPlugin>>#primitiveSignedInt8At */
EXPORT(sqInt)
primitiveSignedInt8At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(char));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnInteger(((signed char) (byteAt(addr))));
	}
}


/*	Store the signed 8-bit integer starting at the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveSignedInt8AtPut */
EXPORT(sqInt)
primitiveSignedInt8AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	if (!((isIntegerObject(valueArg))
		 && ((((((value = integerValueOf(valueArg))) >= -128) && (value <= 0x7F)))
		 && (isIntegerObject(byteOffset))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(char));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		byteAtput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the alignment of an element of an atomic type, or a structure,
	within a structure on the current platform.
 */

	/* ThreadedFFIPlugin>>#primitiveStructureElementAlignment */
EXPORT(sqInt)
primitiveStructureElementAlignment(void)
{
    void *alignment;
    sqInt typeCode;

	typeCode = stackValue(0);
	if (!((isIntegerObject(typeCode))
		 && ((((((typeCode = integerValueOf(typeCode))) >= FFITypeUnsignedInt8) && (typeCode <= FFITypeDoubleFloat)))
		 || (typeCode == FFIFlagStructure)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	switch (typeCode) {
	case FFITypeUnsignedInt8:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structByte *) 0))->element)));
		break;

	case FFITypeSignedInt8:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structByte *) 0))->element)));
		break;

	case FFITypeUnsignedInt16:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structShort *) 0))->element)));
		break;

	case FFITypeSignedInt16:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structShort *) 0))->element)));
		break;

	case FFITypeUnsignedInt32:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structInt *) 0))->element)));
		break;

	case FFITypeSignedInt32:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structInt *) 0))->element)));
		break;

	case FFITypeUnsignedInt64:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structLongLong *) 0))->element)));
		break;

	case FFITypeSignedInt64:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structLongLong *) 0))->element)));
		break;

	case FFITypeSingleFloat:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structFloat *) 0))->element)));
		break;

	case FFITypeDoubleFloat:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structDouble *) 0))->element)));
		break;

	default:
		/* begin structOffsetOf:atomicTypeCode: */
		alignment = (&(((((structStruct *) 0))->element)));;
	}
	return methodReturnInteger(((usqIntptr_t)alignment));
}


/*	Answer the unsigned 16-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt16At */
EXPORT(sqInt)
primitiveUnsignedInt16At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(short));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnInteger(((unsigned short) (unalignedShortAt(addr))));
	}
}


/*	Store the unsigned 16-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt16AtPut */
EXPORT(sqInt)
primitiveUnsignedInt16AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	if (!((isIntegerObject(valueArg))
		 && ((((((value = integerValueOf(valueArg))) >= 0) && (value <= 0xFFFF)))
		 && (isIntegerObject(byteOffset))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(short));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		unalignedShortAtput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the unsigned 32-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt32At */
EXPORT(sqInt)
primitiveUnsignedInt32At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(int));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnValue(positive32BitIntegerFor(((unsigned int) (unalignedLong32At(addr)))));
	}
}


/*	Store the unsigned 32-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt32AtPut */
EXPORT(sqInt)
primitiveUnsignedInt32AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    usqInt value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	value = positive32BitValueOf(valueArg);
	if (!((!(failed()))
		 && (isIntegerObject(byteOffset)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(int));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		unalignedLong32Atput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the unsigned 64-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt64At */
EXPORT(sqInt)
primitiveUnsignedInt64At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(usqLong));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnValue(positive64BitIntegerFor(((usqLong) (unalignedLong64At(addr)))));
	}
}


/*	Store the unsigned 64-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt64AtPut */
EXPORT(sqInt)
primitiveUnsignedInt64AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    usqLong value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	value = positive64BitValueOf(valueArg);
	if (!((!(failed()))
		 && (isIntegerObject(byteOffset)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(sqLong));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		unalignedLong64Atput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Answer the unsigned 8-bit integer starting at the given byte offset
	(native endian).
 */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt8At */
EXPORT(sqInt)
primitiveUnsignedInt8At(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;

	byteOffset = stackValue(0);
	rcvr = stackValue(1);
	if (!(isIntegerObject(byteOffset))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(char));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		return methodReturnInteger(((unsigned char) (byteAt(addr))));
	}
}


/*	Store the unsigned 8-bit integer starting at the given byte offset. */

	/* ThreadedFFIPlugin>>#primitiveUnsignedInt8AtPut */
EXPORT(sqInt)
primitiveUnsignedInt8AtPut(void)
{
    void *addr;
    sqInt byteOffset;
    sqInt rcvr;
    sqInt value;
    sqInt valueArg;

	valueArg = stackValue(0);
	byteOffset = stackValue(1);
	rcvr = stackValue(2);
	if (!((isIntegerObject(valueArg))
		 && ((((((value = integerValueOf(valueArg))) >= 0) && (value <= 0xFF)))
		 && (isIntegerObject(byteOffset))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	addr = ffiAddressOfstartingAtsize(rcvr, integerValueOf(byteOffset), sizeof(char));
	if (addr == null) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	else {
		byteAtput(addr, value);
		return methodReturnValue(valueArg);
	}
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterObjectOf = interpreterProxy->characterObjectOf;
#else
#if !defined(characterObjectOf)
		characterObjectOf = 0;
#endif
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		characterValueOf = interpreterProxy->characterValueOf;
#else
#if !defined(characterValueOf)
		characterValueOf = 0;
#endif
#endif
		classAlien = interpreterProxy->classAlien;
		classByteArray = interpreterProxy->classByteArray;
		classExternalAddress = interpreterProxy->classExternalAddress;
		classExternalData = interpreterProxy->classExternalData;
		classExternalFunction = interpreterProxy->classExternalFunction;
		classExternalLibrary = interpreterProxy->classExternalLibrary;
		classExternalStructure = interpreterProxy->classExternalStructure;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classString = interpreterProxy->classString;
		disownVM = interpreterProxy->disownVM;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchLong32ofObject = interpreterProxy->fetchLong32ofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
		includesBehaviorThatOf = interpreterProxy->includesBehaviorThatOf;
		instanceSizeOf = interpreterProxy->instanceSizeOf;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
#if !defined(integerObjectOf)
		integerObjectOf = interpreterProxy->integerObjectOf;
#endif
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		ioLoadModuleOfLength = interpreterProxy->ioLoadModuleOfLength;
		ioLoadSymbolOfLengthFromModule = interpreterProxy->ioLoadSymbolOfLengthFromModule;
		isKindOf = interpreterProxy->isKindOf;
		isKindOfClass = interpreterProxy->isKindOfClass;
		isArray = interpreterProxy->isArray;
		isBytes = interpreterProxy->isBytes;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isCharacterObject = interpreterProxy->isCharacterObject;
#else
#if !defined(isCharacterObject)
		isCharacterObject = 0;
#endif
#endif
		isFloatObject = interpreterProxy->isFloatObject;
#if !defined(isImmediate)
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isImmediate = interpreterProxy->isImmediate;
#else
#if !defined(isImmediate)
		isImmediate = 0;
#endif
#endif
#endif /* !defined(isImmediate) */
		isInMemory = interpreterProxy->isInMemory;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isPinned = interpreterProxy->isPinned;
#else
#if !defined(isPinned)
		isPinned = 0;
#endif
#endif
		isPointers = interpreterProxy->isPointers;
		isWords = interpreterProxy->isWords;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		isYoung = interpreterProxy->isYoung;
		literalofMethod = interpreterProxy->literalofMethod;
		literalCountOf = interpreterProxy->literalCountOf;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnFloat = interpreterProxy->methodReturnFloat;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnString = interpreterProxy->methodReturnString;
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		ownVM = interpreterProxy->ownVM;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		positiveMachineIntegerValueOf = interpreterProxy->positiveMachineIntegerValueOf;
		primitiveErrorTable = interpreterProxy->primitiveErrorTable;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 14)
		primitiveFailForwithSecondary = interpreterProxy->primitiveFailForwithSecondary;
#else
#if !defined(primitiveFailForwithSecondary)
		primitiveFailForwithSecondary = 0;
#endif
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 14)
		primitiveFailForOSError = interpreterProxy->primitiveFailForOSError;
#else
#if !defined(primitiveFailForOSError)
		primitiveFailForOSError = 0;
#endif
#endif
		primitiveMethod = interpreterProxy->primitiveMethod;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed32BitValueOf = interpreterProxy->signed32BitValueOf;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		signed64BitValueOf = interpreterProxy->signed64BitValueOf;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* ThreadedARM64FFIPlugin>>#setReturnRegister:andCall:withArgsArray: */
static sqInt
setReturnRegisterandCallwithArgsArray(sqLong structAddr, sqLong procAddr, sqLong arrayAddr)
{
    extern void callAndReturnWithStructAddr(sqLong structAddr,sqLong procAddr,sqLong arrayAddr);

	callAndReturnWithStructAddr(structAddr, procAddr, arrayAddr);
	return 0;
}


/*	Answer the size field of an alienOop which is assumed to be an Alien of at
	least 8 bytes (32-bits) or 16 bytes (64 bits)
 */

	/* InterpreterPlugin>>#sizeField: */
static sqInt
sizeField(sqInt alienOop)
{
	return longAt(alienOop + BaseHeaderSize);
}


/*	Answer the start of an Alien's data. For direct aliens this is the address
	of the second field.
	For indirect and pointer aliens it is what the second field points to. */

	/* InterpreterPlugin>>#startOfData: */
static sqInt
startOfData(sqInt alienOop)
{
	return ((longAt(alienOop + BaseHeaderSize)) > 0
		? (alienOop + BaseHeaderSize) + BytesPerOop
		: longAt((alienOop + BaseHeaderSize) + BytesPerOop));
}


/*	See IHI0055B_aapcs64.pdf 
	4.3.5.1 Homogeneous Floating-point Aggregates (HFA)
	An Homogeneous Floating-point Aggregate (HFA) is an Homogeneous Aggregate
	with a
	Fundamental Data Type that is a Floating-Point type and at most four
	uniquely addressable members. */

	/* ThreadedARM64FFIPlugin>>#structIsHomogenousFloatArrayOfSize:typeSpec:ofLength: */
static sqInt
structIsHomogenousFloatArrayOfSizetypeSpecofLength(sqInt structSize, unsigned int *argSpec, sqInt argSpecSize)
{
    unsigned int firstField;
    sqInt idx;
    sqInt typeOfFirstField;
    sqInt typeSpec;

	if (!((structSize <= (4 * (sizeof(double))))
		 && (argSpecSize <= 5))) {

		/* header plus up to four fields */
		return 0;
	}
	/* begin atomicTypeOf: */
	typeSpec = (firstField = argSpec[1]);
	typeOfFirstField = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if ((typeOfFirstField != FFITypeSingleFloat)
	 && (typeOfFirstField != FFITypeDoubleFloat)) {
		return 0;
	}
	for (idx = 2; idx < argSpecSize; idx += 1) {
		if (firstField != (argSpec[idx])) {
			return 0;
		}
	}
	return 1;
}


/*	See IHI0055B_aapcs64.pdf 
	4.1.2 Short Vectors
	A short vector is a machine type that is composed of repeated instances of
	one fundamental integral
	or floating- point type. It may be 8 or 16 bytes in total size. A short
	vector has a base type that is the
	fundamental integral or floating-point type from which it is composed, but
	its alignment is always the
	same as its total size. The number of elements in the short vector is
	always such that the type is fully
	packed. For example, an 8-byte short vector may contain 8 unsigned byte
	elements, 4 unsigned half-word
	elements, 2 single-precision floating-point elements, or any other
	combination where the product of
	the number of elements and the size of an individual element is equal to
	8. Similarly, for 16-byte short
	vectors the product of the number of elements and the size of the
	individual elements must be 16.
	
	Elements in a short vector are numbered such that the lowest numbered
	element (element 0) occupies
	the lowest numbered bit (bit zero) in the vector and successive elements
	take on progressively
	increasing bit positions in the vector. When a short vector transferred
	between registers and memory
	it is treated as an opaque object. That is a short vector is stored in
	memory as if it were stored with
	a single STR of the entire register; a short vector is loaded from memory
	using the corresponding LDR
	instruction. On a little-endian system this means that element 0 will
	always contain the lowest
	addressed element of a short vector; on a big-endian system element 0 will
	contain the highest-addressed
	element of a short vector.
	
	A language binding may define extended types that map directly onto short
	vectors. Short vectors
	are not otherwise created spontaneously (for example because a user has
	declared an aggregate
	consisting of eight consecutive byte-sized objects). */

	/* ThreadedARM64FFIPlugin>>#structIsHomogenousIntegerArrayOfSize:typeSpec:ofLength: */
static sqInt
structIsHomogenousIntegerArrayOfSizetypeSpecofLength(sqInt structSize, unsigned int *argSpec, sqInt argSpecSize)
{
    unsigned int firstField;
    sqInt idx;
    sqInt sizeOfType;
    sqInt typeOfFirstField;
    sqInt typeSpec;

	if (!(structSize <= (4 * (sizeof(long))))) {
		return 0;
	}
	/* begin atomicTypeOf: */
	typeSpec = (firstField = argSpec[1]);
	typeOfFirstField = ((usqInt)((typeSpec & FFIAtomicTypeMask))) >> FFIAtomicTypeShift;
	if (!(((typeOfFirstField >= FFITypeUnsignedInt8) && (typeOfFirstField <= FFITypeSignedInt64)))) {
		return 0;
	}

	/* {	FFITypeUnsignedInt8. FFITypeUnsignedInt16. FFITypeUnsignedInt32. FFITypeUnsignedInt64.
	   FFITypeSignedInt8. FFITypeSignedInt16. FFITypeSignedInt32. FFITypeSignedInt64} collect:
	   [:typeOfFirstField| 1 << (typeOfFirstField >> 1 - 1)] */
	sizeOfType = 1U << ((((usqInt)(typeOfFirstField)) >> 1) - 1);
	if ((sizeOfType * argSpecSize) > (4 * (sizeof(long)))) {
		return 0;
	}
	for (idx = 2; idx < argSpecSize; idx += 1) {
		if (firstField != (argSpec[idx])) {
			return 0;
		}
	}
	return 1;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "SqueakFFIPrims";
void* RiscV64FFIPlugin_exports[][3] = {
	{(void*)_m, "ffiLogCallsTo", (void*)ffiLogCallsTo},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveCallout\000\377\000", (void*)primitiveCallout},
	{(void*)_m, "primitiveCalloutWithArgs\000\004\000", (void*)primitiveCalloutWithArgs},
	{(void*)_m, "primitiveCDataModel\000\001\001", (void*)primitiveCDataModel},
	{(void*)_m, "primitiveCreateManualSurface\000\000\000", (void*)primitiveCreateManualSurface},
	{(void*)_m, "primitiveDestroyManualSurface\000\000\000", (void*)primitiveDestroyManualSurface},
	{(void*)_m, "primitiveExternalAddressAsInteger\000\001\001", (void*)primitiveExternalAddressAsInteger},
	{(void*)_m, "primitiveExternalAddressFromInteger\000\000\001", (void*)primitiveExternalAddressFromInteger},
	{(void*)_m, "primitiveFFIAllocate\000\000\000", (void*)primitiveFFIAllocate},
	{(void*)_m, "primitiveFFIDoubleAt\000\001\003", (void*)primitiveFFIDoubleAt},
	{(void*)_m, "primitiveFFIDoubleAtPut\000\001\003", (void*)primitiveFFIDoubleAtPut},
	{(void*)_m, "primitiveFFIFloatAt\000\001\003", (void*)primitiveFFIFloatAt},
	{(void*)_m, "primitiveFFIFloatAtPut\000\001\003", (void*)primitiveFFIFloatAtPut},
	{(void*)_m, "primitiveFFIFree\000\001\000", (void*)primitiveFFIFree},
	{(void*)_m, "primitiveFFIGetLastError\000\377\001", (void*)primitiveFFIGetLastError},
	{(void*)_m, "primitiveFFIIntegerAt\000\001\001", (void*)primitiveFFIIntegerAt},
	{(void*)_m, "primitiveFFIIntegerAtPut\000\001\001", (void*)primitiveFFIIntegerAtPut},
	{(void*)_m, "primitiveForceLoad\000\002\000", (void*)primitiveForceLoad},
	{(void*)_m, "primitiveLoadSymbolFromModule\000\002\000", (void*)primitiveLoadSymbolFromModule},
	{(void*)_m, "primitiveLogCallsTo\000\001\000", (void*)primitiveLogCallsTo},
	{(void*)_m, "primitivePluginVersion\000\377\001", (void*)primitivePluginVersion},
	{(void*)_m, "primitiveSetManualSurfacePointer\000\000\000", (void*)primitiveSetManualSurfacePointer},
	{(void*)_m, "primitiveSignedInt16At\000\001\001", (void*)primitiveSignedInt16At},
	{(void*)_m, "primitiveSignedInt16AtPut\000\001\001", (void*)primitiveSignedInt16AtPut},
	{(void*)_m, "primitiveSignedInt32At\000\001\001", (void*)primitiveSignedInt32At},
	{(void*)_m, "primitiveSignedInt32AtPut\000\001\001", (void*)primitiveSignedInt32AtPut},
	{(void*)_m, "primitiveSignedInt64At\000\001\001", (void*)primitiveSignedInt64At},
	{(void*)_m, "primitiveSignedInt64AtPut\000\001\001", (void*)primitiveSignedInt64AtPut},
	{(void*)_m, "primitiveSignedInt8At\000\001\001", (void*)primitiveSignedInt8At},
	{(void*)_m, "primitiveSignedInt8AtPut\000\001\001", (void*)primitiveSignedInt8AtPut},
	{(void*)_m, "primitiveStructureElementAlignment\000\000\001", (void*)primitiveStructureElementAlignment},
	{(void*)_m, "primitiveUnsignedInt16At\000\001\001", (void*)primitiveUnsignedInt16At},
	{(void*)_m, "primitiveUnsignedInt16AtPut\000\001\001", (void*)primitiveUnsignedInt16AtPut},
	{(void*)_m, "primitiveUnsignedInt32At\000\001\001", (void*)primitiveUnsignedInt32At},
	{(void*)_m, "primitiveUnsignedInt32AtPut\000\001\001", (void*)primitiveUnsignedInt32AtPut},
	{(void*)_m, "primitiveUnsignedInt64At\000\001\001", (void*)primitiveUnsignedInt64At},
	{(void*)_m, "primitiveUnsignedInt64AtPut\000\001\001", (void*)primitiveUnsignedInt64AtPut},
	{(void*)_m, "primitiveUnsignedInt8At\000\001\001", (void*)primitiveUnsignedInt8At},
	{(void*)_m, "primitiveUnsignedInt8AtPut\000\001\001", (void*)primitiveUnsignedInt8AtPut},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
#include "sqFFITestFuncExports.h"
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveCalloutWithArgsMetadata = 0x400;
EXPORT(signed short) primitiveCDataModelMetadata = 0x101;
EXPORT(signed short) primitiveCreateManualSurfaceMetadata = 0;
EXPORT(signed short) primitiveDestroyManualSurfaceMetadata = 0;
EXPORT(signed short) primitiveExternalAddressAsIntegerMetadata = 0x101;
EXPORT(signed short) primitiveExternalAddressFromIntegerMetadata = 1;
EXPORT(signed short) primitiveFFIAllocateMetadata = 0;
EXPORT(signed short) primitiveFFIDoubleAtMetadata = 259;
EXPORT(signed short) primitiveFFIDoubleAtPutMetadata = 259;
EXPORT(signed short) primitiveFFIFloatAtMetadata = 259;
EXPORT(signed short) primitiveFFIFloatAtPutMetadata = 259;
EXPORT(signed short) primitiveFFIFreeMetadata = 0x100;
EXPORT(signed short) primitiveFFIGetLastErrorMetadata = -255;
EXPORT(signed short) primitiveFFIIntegerAtMetadata = 0x101;
EXPORT(signed short) primitiveFFIIntegerAtPutMetadata = 0x101;
EXPORT(signed short) primitiveForceLoadMetadata = 0x200;
EXPORT(signed short) primitiveLoadSymbolFromModuleMetadata = 0x200;
EXPORT(signed short) primitiveLogCallsToMetadata = 0x100;
EXPORT(signed short) primitivePluginVersionMetadata = -255;
EXPORT(signed short) primitiveSetManualSurfacePointerMetadata = 0;
EXPORT(signed short) primitiveSignedInt16AtMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt16AtPutMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt32AtMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt32AtPutMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt64AtMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt64AtPutMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt8AtMetadata = 0x101;
EXPORT(signed short) primitiveSignedInt8AtPutMetadata = 0x101;
EXPORT(signed short) primitiveStructureElementAlignmentMetadata = 1;
EXPORT(signed short) primitiveUnsignedInt16AtMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt16AtPutMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt32AtMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt32AtPutMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt64AtMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt64AtPutMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt8AtMetadata = 0x101;
EXPORT(signed short) primitiveUnsignedInt8AtPutMetadata = 0x101;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
