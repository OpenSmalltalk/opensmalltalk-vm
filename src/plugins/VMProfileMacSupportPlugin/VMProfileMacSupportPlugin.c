/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.3417 uuid: 6b0ab3f7-46c0-4e4c-a800-57a4d13ffef0
   from
	VMProfileMacSupportPlugin VMMaker.oscog-eem.3417 uuid: 6b0ab3f7-46c0-4e4c-a800-57a4d13ffef0
 */
static char __buildInfo[] = "VMProfileMacSupportPlugin VMMaker.oscog-eem.3417 uuid: 6b0ab3f7-46c0-4e4c-a800-57a4d13ffef0 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <dlfcn.h>
#include <mach-o/dyld.h>
#include <mach-o/getsect.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primitiveDLSym(void);
EXPORT(sqInt) primitiveExecutableModulesAndOffsets(void);
EXPORT(sqInt) primitiveTextSymbols(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*classArray)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static sqInt (*isBytes)(sqInt oop);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*nilObject)(void);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*topRemappableOop)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt classArray(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern void * firstIndexableField(sqInt oop);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern sqInt isBytes(sqInt oop);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
extern sqInt methodReturnValue(sqInt oop);
extern sqInt nilObject(void);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt topRemappableOop(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "VMProfileMacSupportPlugin VMMaker.oscog-eem.3417 " INT_EXT;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	Answer the address of the argument in the current process or nil if none. */

	/* VMProfileMacSupportPlugin>>#primitiveDLSym */
EXPORT(sqInt)
primitiveDLSym(void)
{
    void *addr;
    char *dstPtr;
    sqInt obj;
    char *symbolName;
    sqInt sz;

	/* begin stackEphemeralStringValue: */
	obj = stackValue(0);
	if (!(isBytes(obj))) {
		primitiveFailFor(PrimErrBadArgument);
		symbolName = null;
		goto l2;
	}
	sz = byteSizeOf(obj);
	dstPtr = alloca(sz + 1);
	if (!dstPtr) {
		primitiveFailFor(PrimErrNoCMemory);
		symbolName = null;
		goto l2;
	}
	memcpy(dstPtr, firstIndexableField(obj), sz);
	dstPtr[sz] = 0;
	symbolName = dstPtr;
	l2:	/* end stackEphemeralStringValue: */;
	if (!(symbolName == null)) {
		addr = dlsym(RTLD_SELF, symbolName);
		methodReturnValue((addr == 0
			? nilObject()
			: (/* begin positiveMachineIntegerFor: */
				(BytesPerWord == 8
						? positive64BitIntegerFor(((usqIntptr_t)addr))
						: positive32BitIntegerFor(((usqIntptr_t)addr))))));
	}
	return 0;
}


/*	Answer an Array of quads for executable modules (the VM executable
	and loaded libraries). Each quad is the module's name, its vm address
	relocation in memory, the (unrelocated) start address, and the size. */

	/* VMProfileMacSupportPlugin>>#primitiveExecutableModulesAndOffsets */
EXPORT(sqInt)
primitiveExecutableModulesAndOffsets(void)
{
    const struct mach_header *h;
    const struct mach_header_64 *h64;
    sqInt i;
    const char *name;
    char *nameObjData;
    sqInt nimages;
    sqInt resultObj;
    const struct section *s;
    const struct section_64 *s64;
    usqIntptr_t size;
    usqIntptr_t slide;
    usqIntptr_t start;
    sqInt valueObj;

	nimages = _dyld_image_count();
	resultObj = instantiateClassindexableSize(classArray(), nimages * 4);
	if (resultObj == 0) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	pushRemappableOop(resultObj);
	for (i = 0; i < nimages; i += 1) {

		/* impossible start & size */
		start = (size = -1);
		name = _dyld_get_image_name(i);
		slide = _dyld_get_image_vmaddr_slide(i);
#    if __x86_64__ || __arm64__
		h64 = ((const struct mach_header_64 *) (_dyld_get_image_header(i)));
		if (!(h64 == null)) {
			s64 = getsectbynamefromheader_64(h64, SEG_TEXT, SECT_TEXT);
			if (!(s64 == null)) {
				start = (s64->addr);
				size = (s64->size);
			}
		}
#    else // __x86_64__ || __arm64__
		h = _dyld_get_image_header(i);
		if (!(h == null)) {
			s = getsectbynamefromheader(h, SEG_TEXT, SECT_TEXT);
			if (!(s == null)) {
				start = (s->addr);
				size = (s->size);
			}
		}
#    endif // __x86_64__ || __arm64__
		valueObj = instantiateClassindexableSize(classString(), strlen(name));
		if (failed()) {
			popRemappableOop();
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue(i * 4, topRemappableOop(), valueObj);
		nameObjData = arrayValueOf(valueObj);
		memcpy(nameObjData, name, strlen(name));
		/* begin signedMachineIntegerFor: */
		valueObj = (BytesPerWord == 8
			? signed64BitIntegerFor(slide)
			: signed32BitIntegerFor(slide));
		if (failed()) {
			popRemappableOop();
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue((i * 4) + 1, topRemappableOop(), valueObj);
		/* begin positiveMachineIntegerFor: */
		valueObj = (BytesPerWord == 8
			? positive64BitIntegerFor(start)
			: positive32BitIntegerFor(start));
		if (failed()) {
			popRemappableOop();
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue((i * 4) + 2, topRemappableOop(), valueObj);
		/* begin positiveMachineIntegerFor: */
		valueObj = (BytesPerWord == 8
			? positive64BitIntegerFor(size)
			: positive32BitIntegerFor(size));
		if (failed()) {
			popRemappableOop();
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue((i * 4) + 3, topRemappableOop(), valueObj);
	}
	return methodReturnValue(popRemappableOop());
}


/*	Answer an Array of pairs of address, name, for text symbols in the n'th
	loaded module,
	as defined by the _dyld_image_count enumeration. */

	/* VMProfileMacSupportPlugin>>#primitiveTextSymbols */
EXPORT(sqInt)
primitiveTextSymbols(void)
{
    Dl_info dlInfo;
    Dl_info *dlInfos;
    usqIntptr_t end;
    const struct mach_header *h;
    const struct mach_header_64 *h64;
    sqInt increment;
    sqInt index;
    void *last_saddr;
    sqInt moduleIndex;
    char *nameObjData;
    sqInt ndlInfos;
    sqInt resultObj;
    const struct section *s;
    const struct section_64 *s64;
    usqIntptr_t slide;
    usqIntptr_t start;
    usqIntptr_t value;
    sqInt valueObj;

	end = 0;
	moduleIndex = stackValue(0);
	if (!((isIntegerObject(moduleIndex))
		 && ((((moduleIndex = integerValueOf(moduleIndex))) >= 0)
		 && ((_dyld_get_image_name(moduleIndex)) != null)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	start = 0;
	slide = _dyld_get_image_vmaddr_slide(moduleIndex);
#  if __x86_64__ || __arm64__
	h64 = ((const struct mach_header_64 *) (_dyld_get_image_header(moduleIndex)));
	if (!(h64 == null)) {
		s64 = getsectbynamefromheader_64(h64, SEG_TEXT, SECT_TEXT);
		if (!(s64 == null)) {
			start = ((s64->addr)) + slide;
			end = start + ((s64->size));
		}
	}
#  else // __x86_64__ || __arm64__
	h = _dyld_get_image_header(moduleIndex);
	if (!(h == null)) {
		s = getsectbynamefromheader(h, SEG_TEXT, SECT_TEXT);
		if (!(s == null)) {
			start = (s->addr);
			end = start + ((s->size));
		}
	}
#  endif // __x86_64__ || __arm64__
	if (start == 0) {
		return primitiveFailFor(PrimErrOperationFailed);
	}
	if (!((dlInfos = malloc((sizeof(Dl_info)) * ((ndlInfos = (increment = 0x400))))))) {
		return primitiveFailFor(PrimErrNoCMemory);
	}
	index = 0;

	/* Yes, dear reader, one could use binary search to reduce the amount of effort.  But when this author
	   attempted to do so, he achieved only a marginal improvement for a substantial increase in complexity.
	   So KISS and do a linear scan, looking ahead 64 bytes to reduce overhead as simply as possible. 64 gave
	   best results when tried on the VM module of an ARMv8/aarch64 VM; about 2.5x a naive step by sizeof(void *). */
	last_saddr = null;
	while ((start < end)
	 && ((dladdr(((void *)start), dlInfos + index)) != 0)) {
		if (((start + 64) < end)
		 && (((dladdr(((void *)(start + 64)), (&dlInfo))) != 0)
		 && (((dlInfo.dli_saddr)) == (((dlInfos[index]).dli_saddr))))) {
			start = (start + 64) + (sizeof(void *));
		}
		else {
			start += sizeof(void *);
		}
		if (last_saddr != (((dlInfos[index]).dli_saddr))) {
			last_saddr = ((dlInfos[index]).dli_saddr);
			if (((index += 1)) == ndlInfos) {
				dlInfos = reallocf(dlInfos, (sizeof(Dl_info)) * (ndlInfos + increment));
				if (!dlInfos) {
					return primitiveFailFor(PrimErrNoCMemory);
				}
				ndlInfos += increment;
				increment = increment * 2;
			}
		}
	}
	resultObj = instantiateClassindexableSize(classArray(), index * 2);
	if (resultObj == 0) {
		free(dlInfos);
		return primitiveFailFor(PrimErrNoMemory);
	}
	pushRemappableOop(resultObj);
	ndlInfos = index;
	index = 0;
	while (index < ndlInfos) {
		/* begin positiveMachineIntegerFor: */
		value = ((dlInfos[index]).dli_saddr);
		valueObj = (BytesPerWord == 8
			? positive64BitIntegerFor(value)
			: positive32BitIntegerFor(value));
		if (failed()) {
			free(dlInfos);
			popRemappableOop();
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue(index * 2, topRemappableOop(), valueObj);
		valueObj = instantiateClassindexableSize(classString(), strlen(((dlInfos[index]).dli_sname)));
		if (failed()) {
			free(dlInfos);
			popRemappableOop();
			return primitiveFailFor(PrimErrNoMemory);
		}
		storePointerofObjectwithValue((index * 2) + 1, topRemappableOop(), valueObj);
		nameObjData = arrayValueOf(valueObj);
		memcpy(nameObjData, ((dlInfos[index]).dli_sname), strlen(((dlInfos[index]).dli_sname)));
		index += 1;
	}
	free(dlInfos);
	return methodReturnValue(popRemappableOop());
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		classArray = interpreterProxy->classArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		firstIndexableField = interpreterProxy->firstIndexableField;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		isBytes = interpreterProxy->isBytes;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
		methodReturnValue = interpreterProxy->methodReturnValue;
		nilObject = interpreterProxy->nilObject;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		topRemappableOop = interpreterProxy->topRemappableOop;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "VMProfileMacSupportPlugin";
void* VMProfileMacSupportPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveDLSym\000\000\000", (void*)primitiveDLSym},
	{(void*)_m, "primitiveExecutableModulesAndOffsets\000\377\000", (void*)primitiveExecutableModulesAndOffsets},
	{(void*)_m, "primitiveTextSymbols\000\000\000", (void*)primitiveTextSymbols},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveDLSymMetadata = 0;
EXPORT(signed short) primitiveTextSymbolsMetadata = 0;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
