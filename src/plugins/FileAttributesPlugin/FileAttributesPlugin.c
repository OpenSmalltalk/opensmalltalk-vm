/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2347 uuid: 062614a7-e3da-4b30-997a-9568911b9ff5
   from
	FileAttributesPlugin FileAttributesPlugin-AlistairGrant.12 uuid: 4f4a6801-af1c-4227-beb4-2a7c1b763349
 */
static char __buildInfo[] = "FileAttributesPlugin FileAttributesPlugin-AlistairGrant.12 uuid: 4f4a6801-af1c-4227-beb4-2a7c1b763349 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <dirent.h>
#ifdef WIN32
#include <windows.h>
#include <winbase.h>
#define FAIL() { return -1; }
#include "sqWin32File.h"
#endif
typedef struct dirptrstruct {
    		DIR *dp;
		int path_len;
    		char *path_file;
   		char path[PATH_MAX+4];
    		} osdir;
#include <sys/stat.h>
#if !defined(HAVE_LSTAT) && !defined(WIN32)
#define HAVE_LSTAT 1
#endif
#include <unistd.h>
/* AKG 2017 - FileAttributesPlugin.c translated from class FileAttributesPlugin */

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Function Prototypes ***/
static sqInt accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset);
static sqInt addressObjectFor(void *aMachineAddress);
static sqInt byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop);
static sqInt canOpenDirectoryStreamForlength(char *aPathCString, sqInt length);
static sqInt canStatFilePathlength(char *aPathCString, sqInt length);
static sqInt cantAllocateMemory(void);
static sqInt cantOpenDir(void);
static sqInt cantReadlink(void);
static sqInt cantStatPath(void);
EXPORT(sqInt) checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag);
static sqInt corruptValue(void);
static sqInt fileCreationTimeForlengthto(char *pathString, sqInt pathLength, time_t *creationDate);
static sqInt fileExecutableFlag(void);
static sqInt fileOKFlag(void);
static sqInt fileReadableFlag(void);
static int fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray);
static sqInt fileWriteableFlag(void);
static sqInt getAttributesFailed(void);
EXPORT(const char*) getModuleName(void);
static sqInt invalidArguments(void);
static sqInt invalidRequest(void);
static sqInt isSymlinkboolean(char *cPathName, sqInt *resultOop);
static sqInt oopFromTimeT(time_t posixSeconds);
static int openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr);
static int pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen);
static void * pointerFrom(sqInt directoryPointerBytes);
EXPORT(sqInt) primitiveClosedir(void);
EXPORT(sqInt) primitiveFileAttribute(void);
EXPORT(sqInt) primitiveFileAttributes(void);
EXPORT(sqInt) primitiveFileExists(void);
EXPORT(sqInt) primitiveFileMasks(void);
EXPORT(sqInt) primitiveLogicalDrives(void);
EXPORT(sqInt) primitiveOpendir(void);
EXPORT(sqInt) primitivePathMax(void);
EXPORT(sqInt) primitiveReaddir(void);
EXPORT(sqInt) primitiveRewinddir(void);
EXPORT(sqInt) primitiveVersionString(void);
static sqInt putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static size_t readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt sizeOfPointer(void);
static sqInt smallOrLargeIntegerObjectFor(sqInt aPositiveInteger);
static sqInt statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop);
static sqInt statFailed(void);
static sqInt stringFromCString(const char *aCString);
static sqInt stringTooLong(void);
static sqInt timeConversionFailed(void);
static char * versionString(void);
static sqInt wrappedErrorCode(sqInt aNumber);


/*** Variables ***/
static int hasSecurityPlugin= 1;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*classArray)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classString)(void);
static sqInt (*falseObject)(void);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*nilObject)(void);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static sqInt (*primitiveFail)(void);
static sqInt (*push)(sqInt object);
static sqInt (*signed32BitIntegerFor)(sqInt integerValue);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqInt (*sizeOfSTArrayFromCPrimitive)(void *cPtr);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt classArray(void);
extern sqInt classByteArray(void);
extern sqInt classString(void);
extern sqInt falseObject(void);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt isBytes(sqInt oop);
extern sqInt nilObject(void);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern sqInt primitiveFail(void);
extern sqInt push(sqInt object);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FileAttributesPlugin FileAttributesPlugin-AlistairGrant.12 (i)"
#else
	"FileAttributesPlugin FileAttributesPlugin-AlistairGrant.12 (e)"
#endif
;
static int smallIntegerMaxVal= 1152921504606846975;



/*	Call access() for each access type (R, W, X) on the c string cPathName,
	storing the results in the st array attributeArray.
 */

	/* FileAttributesPlugin>>#accessAttributesForFilename:into:startingAt: */
static sqInt
accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset)
{
    sqInt boolean;
    sqInt index;

	index = offset;
	if ((access(cPathName, R_OK)) == 0) {
		boolean = trueObject();
	}
	else {
		boolean = falseObject();
	}
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	if ((access(cPathName, W_OK)) == 0) {
		boolean = trueObject();
	}
	else {
		boolean = falseObject();
	}
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	if ((access(cPathName, X_OK)) == 0) {
		boolean = trueObject();
	}
	else {
		boolean = falseObject();
	}
	storePointerofObjectwithValue(index, attributeArray, boolean);
	return 0;
}


/*	Answer an ExternalAddress object which represents aMachineAddress */

	/* FileAttributesPlugin>>#addressObjectFor: */
static sqInt
addressObjectFor(void *aMachineAddress)
{
    sqInt addressOop;
    unsigned char *addressOopArrayPointer;
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;

	addressOop = instantiateClassindexableSize(classByteArray(), sizeOfPointer());
	addressOopArrayPointer = arrayValueOf(addressOop);
	addressUnion.address = aMachineAddress;
	idx = 0;
	while (idx < (sizeOfPointer())) {
		addressOopArrayPointer[idx] = addressUnion.bytes[idx];
		idx += 1;
	}
	return addressOop;
}


/*	Answer a new ByteArray copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#byteArrayFromCString:to: */
static sqInt
byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop)
{
    unsigned char *byteArrayPtr;
    sqInt len;
    sqInt newByteArray;


	/* We never return strings longer than PATH_MAX */
	len = strlen(aCString);
	if (len > (PATH_MAX)) {
		return -1 /* stringTooLong */;
	}
	newByteArray = instantiateClassindexableSize(classByteArray(), len);
	byteArrayPtr = arrayValueOf(newByteArray);
	memcpy(byteArrayPtr, aCString, len);
	*byteArrayOop = newByteArray;
	return 0;
}


/*	Answer non-zero if security permits the directory to be listed. */
/*	FIXME: This function has not been tested. -dtl */

	/* FileAttributesPlugin>>#canOpenDirectoryStreamFor:length: */
static sqInt
canOpenDirectoryStreamForlength(char *aPathCString, sqInt length)
{
    void *sCLPfn;


	/* If the security plugin can be loaded, use it to check .
	   If not, assume it's ok */
	/* The hasSecurityPlugin flag is set to 1 by default */
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	sCLPfn = ioLoadFunctionFrom("secCanListPathOfSize", "SecurityPlugin");
	if (sCLPfn != 0) {
		return  ((int (*) (char *, int)) sCLPfn)(aPathCString, length);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Answer non-zero if security permits the a stat() call on the file path.
	Allow a
	stat() call only on files which we are permitted to open.
 */
/*	FIXME: This function has not been tested. -dtl */

	/* FileAttributesPlugin>>#canStatFilePath:length: */
static sqInt
canStatFilePathlength(char *aPathCString, sqInt length)
{
    void *sCOFfn;


	/* If the security plugin can be loaded, use it to check .
	   If not, assume it's ok */
	/* The hasSecurityPlugin flag is set to 1 by default */
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	sCOFfn = ioLoadFunctionFrom("secCanOpenFileOfSizeWritable", "SecurityPlugin");
	if (sCOFfn != 0) {
		return  ((int (*) (char *, int, int)) sCOFfn)(aPathCString, length, 0);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}

	/* FileAttributesPlugin>>#cantAllocateMemory */
static sqInt
cantAllocateMemory(void)
{
	return -10;
}

	/* FileAttributesPlugin>>#cantOpenDir */
static sqInt
cantOpenDir(void)
{
	return -9;
}

	/* FileAttributesPlugin>>#cantReadlink */
static sqInt
cantReadlink(void)
{
	return -8;
}


/*	SecurityPlugin determined that the requested path cannot be accessed. */

	/* FileAttributesPlugin>>#cantStatPath */
static sqInt
cantStatPath(void)
{
	return -3;
}


/*	Check access to pathString. */

	/* FileAttributesPlugin>>#checkAccess:mode:to: */
EXPORT(sqInt)
checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag)
{
    char cString[PATH_MAX];
    sqInt len;
    char *sPtr;


	/* Note: The static sized string buffer is faster than using a Smalltalk allocated
	   string as the buffer, and is unlikely to fail in practice. In the event that
	   the buffer turns out to be too small, write an error message to stdout before
	   failing. */
	len = stSizeOf(pathString);
	if (len >= (PATH_MAX)) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathString);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return -3;
	}
	memcpy(cString, sPtr, len);
	cString[len] = 0;
	*flag = access(cString, mode);
	return 0;
}

	/* FileAttributesPlugin>>#corruptValue */
static sqInt
corruptValue(void)
{
	return -7;
}


/*	Get the creationDate for the supplied file.
	Linux kernel 4.11 should have statx(), so hopefully there will be a
	cross-platform solution soon. Just dump the c-code and hope to remove it
	soon. 
 */

	/* FileAttributesPlugin>>#fileCreationTimeFor:length:to: */
static sqInt
fileCreationTimeForlengthto(char *pathString, sqInt pathLength, time_t *creationDate)
{
    struct tm tm;

	
#ifdef WIN32
  WIN32_FILE_ATTRIBUTE_DATA winAttrs;
  WCHAR *win32Path;
  SYSTEMTIME sysTime;
#endif

  memset(&tm, 0, sizeof(tm));

#ifdef WIN32
  /* convert the supplied path name into a wide string */
  ALLOC_WIN32_PATH(win32Path, pathString, pathLength);
	if ((GetFileAttributesExW(win32Path, 0, &winAttrs)) == 0) {
		return -4 /* getAttributesFailed */;
	}
	if ((FileTimeToSystemTime(&winAttrs.ftCreationTime, &sysTime)) == 0) {
		return -5 /* timeConversionFailed */;
	}
	
  tm.tm_year = sysTime.wYear - 1900;
  tm.tm_mon = sysTime.wMonth - 1;
  tm.tm_mday = sysTime.wDay;

  tm.tm_hour = sysTime.wHour;
  tm.tm_min = sysTime.wMinute;
  tm.tm_sec = sysTime.wSecond;
  tm.tm_isdst = 0;
#endif

  *creationDate = mktime(&tm);
	return 0;
}

	/* FileAttributesPlugin>>#fileExecutableFlag */
static sqInt
fileExecutableFlag(void)
{
	return X_OK;
}

	/* FileAttributesPlugin>>#fileOKFlag */
static sqInt
fileOKFlag(void)
{
	return F_OK;
}

	/* FileAttributesPlugin>>#fileReadableFlag */
static sqInt
fileReadableFlag(void)
{
	return R_OK;
}


/*	Answer a file attribute array from pathNameOop. */

	/* FileAttributesPlugin>>#fileToAttributeArray:mask:array: */
static int
fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray)
{
    sqInt accessArray;
    sqInt combinedArray;
    sqInt fileNameOop;
    int getAccess;
    int getStats;
    sqInt statArray;
    struct stat *statBufPointer= &statBuf;
    sqInt status;
    int useLstat;


	/* Determine which attributes to retrieve */
	accessArray = 0;
	fileNameOop = 0;
	statArray = 0;
	getStats = (attributeMask & 1) == 1;
	getAccess = (attributeMask & 2) == 2;
	if (!(getStats
		 || (getAccess))) {

		/* No information has been requested, which doesn't make sense */
		return -6 /* invalidArguments */;
	}
	if (getStats) {
		useLstat = (attributeMask & 4) == 4;
		statArray = instantiateClassindexableSize(classArray(), 12);
		if (useLstat) {
			status = putLStatForintoBuffertargetName(cPathName, statBufPointer, &fileNameOop);
		}
		else {
			status = putStatForintoBuffertargetName(cPathName, statBufPointer, &fileNameOop);
		}
		if (status != 0) {
			return status;
		}
		status = statArrayFortoArrayfromfileName(cPathName, statArray, statBufPointer, fileNameOop);
		if (status != 0) {
			return status;
		}
		*attributeArray = statArray;
	}
	if (getAccess) {
		accessArray = instantiateClassindexableSize(classArray(), 3);
		accessAttributesForFilenameintostartingAt(cPathName, accessArray, 0);
		*attributeArray = accessArray;
	}
	if (getStats
	 && (getAccess)) {
		combinedArray = instantiateClassindexableSize(classArray(), 2);
		*attributeArray = combinedArray;
		storePointerofObjectwithValue(0, combinedArray, statArray);
		storePointerofObjectwithValue(1, combinedArray, accessArray);
	}
	return 0;
}

	/* FileAttributesPlugin>>#fileWriteableFlag */
static sqInt
fileWriteableFlag(void)
{
	return W_OK;
}

	/* FileAttributesPlugin>>#getAttributesFailed */
static sqInt
getAttributesFailed(void)
{
	return -4;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* FileAttributesPlugin>>#invalidArguments */
static sqInt
invalidArguments(void)
{
	return -6;
}

	/* FileAttributesPlugin>>#invalidRequest */
static sqInt
invalidRequest(void)
{
	return -11;
}


/*	Set resultOop to a boolean indicating whether cPathName is a symbolic
	link. Answer status (0 = success) */

	/* FileAttributesPlugin>>#isSymlink:boolean: */
static sqInt
isSymlinkboolean(char *cPathName, sqInt *resultOop)
{
    struct stat statBuf;
    sqInt status;

	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("HAVE_LSTAT == 1", null, "", ((status = lstat(cPathName, &statBuf)),
	(status != 0
			? (/* begin cantStatPath */
				return -3)
			: 0),
	((S_ISLNK(statBuf.st_mode)) == 0
			? *resultOop = interpreterProxy->falseObject()
			: *resultOop = interpreterProxy->trueObject())), null);
	return 0;
}


/*	Answer an object representation of the provided time (time_t).
	The size of time_t is platform dependent, so check the size and convert
	appropriately. 
 */

	/* FileAttributesPlugin>>#oopFromTimeT: */
static sqInt
oopFromTimeT(time_t posixSeconds)
{
	if ((sizeof(time_t)) == 4) {
		return signed32BitIntegerFor(posixSeconds);
	}
	return signed64BitIntegerFor(posixSeconds);
}


/*	Open a new directory stream. Answer a pointer to the directory stream or
	NULL. 
 */

	/* FileAttributesPlugin>>#openDirectoryStream:ptr: */
static int
openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr)
{
    osdir *dir;
    sqInt len;
    char *sPtr;

	sPtr = arrayValueOf(pathOOP);

	/* The path buffer needs room for a trailing slash and the file name, so subtracting 2 is conservative */
	len = sizeOfSTArrayFromCPrimitive(sPtr);
	if (len > (PATH_MAX-2)) {
		return -1 /* stringTooLong */;
	}
	if (canOpenDirectoryStreamForlength(sPtr, len)) {
		dir = (osdir *) malloc(sizeof(osdir));
		if (dir == null) {
			/* begin cantAllocateMemory */
			return ((sqInt) -10);
		}
		memcpy(dir->path, sPtr, len);
		if (dir->path[len-1] != '/') {
				dir->path[len++] = '/';
				}
		dir->path_file = dir->path + len;
		dir->path_file[0] = '\0';
		dir->path_len = len;
		dir->dp =  opendir(dir->path);
		if ((dir->dp) == null) {
			free(dir);
			/* begin cantOpenDir */
			return ((sqInt) -9);
		}
		*osdirPtr = dir;
		return 0;
	}
	/* begin cantOpenDir */
	return ((sqInt) -9);
}


/*	Copy the supplied path name string object to the supplied c string buffer */

	/* FileAttributesPlugin>>#pathOop:toBuffer:maxLen: */
static int
pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen)
{
    sqInt len;
    char *sPtr;

	len = stSizeOf(pathNameOop);
	if (len >= maxLen) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathNameOop);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return ((sqInt) -3);
	}
	memcpy(cPathName, sPtr, len);
	cPathName[len] = 0;
	return 0;
}


/*	Answer the machine address contained in anExternalAddressOop. */

	/* FileAttributesPlugin>>#pointerFrom: */
static void *
pointerFrom(sqInt directoryPointerBytes)
{
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((isBytes(directoryPointerBytes))
		 && ((stSizeOf(directoryPointerBytes)) == (sizeOfPointer())))) {
		return null;
	}
	ptr = arrayValueOf(directoryPointerBytes);
	idx = 0;
	while (idx < (sizeOfPointer())) {
		addressUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return addressUnion.address;
}


/*	Close the directory stream for dirPointerOop. Answer dirPointerOop on
	success. 
 */

	/* FileAttributesPlugin>>#primitiveClosedir */
EXPORT(sqInt)
primitiveClosedir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;
    sqInt result;

	dirPointerOop = stackObjectValue(0);
	if (dirPointerOop == (nilObject())) {
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	if (!(isKindOf(dirPointerOop, "ByteArray"))) {
		fprintf(stderr, "primitiveClosedir: invalid argument, expected an ByteArray\n");
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	dirStream = pointerFrom(dirPointerOop);
	if (dirStream == null) {
		return (pop(2),
			push(signed32BitIntegerFor(-7 /* corruptValue */)));
	}
	result = closedir(dirStream->dp);
	if (!(result == 0)) {
		perror("closedir");
		return (pop(2),
			push(signed32BitIntegerFor(-7 /* corruptValue */)));
	}
	free(dirStream);
	pop(2);
	push(dirPointerOop);
	return 0;
}


/*	Answer a single file attribute.
	primFileAttributes: aString attributeNumber: attributeNumber
	aString is the path to the file
	attributeNumber identifies which attribute to return:
	1 - 12: stat(): name, mode, ino, dev, nlink, uid, gid, size, accessDate,
	modifiedDate, changeDate, creationDate
	13 - 15: access(): R_OK, W_OK, X_OK
	16: isSymlink
	On error, answer a single element array containing the appropriate error
	code. 
 */

	/* FileAttributesPlugin>>#primitiveFileAttribute */
EXPORT(sqInt)
primitiveFileAttribute(void)
{
    sqInt aPositiveInteger;
    sqInt aPositiveInteger1;
    sqInt aPositiveInteger2;
    sqInt attributeNumber;
    char cPathName[PATH_MAX];
    time_t creationDate;
    sqInt fileName;
    sqInt fileNameOop;
    sqInt mode;
    sqInt resultOop;
    sqInt sizeIfFile;
    struct stat statBuf;
    struct stat *statBufPointer= &statBuf;
    sqInt status;

	fileNameOop = 0;
	fileName = stackObjectValue(1);
	attributeNumber = stackIntegerValue(0);
	if ((attributeNumber < 1)
	 || (attributeNumber > 16)) {
		return (pop(3),
			push(wrappedErrorCode(-6 /* invalidArguments */)));
	}
	if (!(isKindOf(fileName, "String"))) {
		return (pop(3),
			push(wrappedErrorCode(-6 /* invalidArguments */)));
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return (pop(3),
			push(wrappedErrorCode(status)));
	}
	resultOop = 0;
	if (attributeNumber < 12) {

		/* Get requested stat entry */
		status = putStatForintoBuffertargetName(cPathName, statBufPointer, &fileNameOop);
		if (status != 0) {
			return (pop(3),
				push(wrappedErrorCode(status)));
		}
		if (attributeNumber == 1) {
			resultOop = fileNameOop;
		}
		if (attributeNumber == 2) {
			/* begin smallOrLargeIntegerObjectFor: */
			aPositiveInteger = statBuf.st_mode;
			if (aPositiveInteger > smallIntegerMaxVal) {
				resultOop = integerObjectOf(aPositiveInteger);
				goto l1;
			}
			else {
				resultOop = positive32BitIntegerFor(aPositiveInteger);
				goto l1;
			}
	l1:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 3) {
			resultOop = positive64BitIntegerFor(statBuf.st_ino);
		}
		if (attributeNumber == 4) {
			resultOop = positive64BitIntegerFor(statBuf.st_dev);
		}
		if (attributeNumber == 5) {
			resultOop = positive64BitIntegerFor(statBuf.st_nlink);
		}
		if (attributeNumber == 6) {
			/* begin smallOrLargeIntegerObjectFor: */
			aPositiveInteger1 = statBuf.st_uid;
			if (aPositiveInteger1 > smallIntegerMaxVal) {
				resultOop = integerObjectOf(aPositiveInteger1);
				goto l2;
			}
			else {
				resultOop = positive32BitIntegerFor(aPositiveInteger1);
				goto l2;
			}
	l2:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 7) {
			/* begin smallOrLargeIntegerObjectFor: */
			aPositiveInteger2 = statBuf.st_gid;
			if (aPositiveInteger2 > smallIntegerMaxVal) {
				resultOop = integerObjectOf(aPositiveInteger2);
				goto l3;
			}
			else {
				resultOop = positive32BitIntegerFor(aPositiveInteger2);
				goto l3;
			}
	l3:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 8) {
			if ((S_ISDIR(statBuf.st_mode)) == 0) {
				sizeIfFile = statBuf.st_size;
			}
			else {
				sizeIfFile = 0;
			}
			/* begin smallOrLargeIntegerObjectFor: */
			if (sizeIfFile > smallIntegerMaxVal) {
				resultOop = integerObjectOf(sizeIfFile);
				goto l4;
			}
			else {
				resultOop = positive32BitIntegerFor(sizeIfFile);
				goto l4;
			}
	l4:	/* end smallOrLargeIntegerObjectFor: */;
		}
		if (attributeNumber == 9) {
			resultOop = oopFromTimeT(statBuf.st_atime);
		}
		if (attributeNumber == 10) {
			resultOop = oopFromTimeT(statBuf.st_mtime);
		}
		if (attributeNumber == 11) {
			resultOop = oopFromTimeT(statBuf.st_ctime);
		}
	}
	else {
		if (attributeNumber == 12) {
			status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), &creationDate);
			if (status != 0) {
				return (pop(3),
					push(wrappedErrorCode(status)));
			}
			resultOop = oopFromTimeT(creationDate);
		}
		else {
			if (attributeNumber < 16) {

				/* Get requested access entry */
				if (attributeNumber == 13) {
					mode = fileReadableFlag();
				}
				if (attributeNumber == 14) {
					mode = fileWriteableFlag();
				}
				if (attributeNumber == 15) {
					mode = fileExecutableFlag();
				}
				if ((access(cPathName, mode)) == 0) {
					resultOop = trueObject();
				}
				else {
					resultOop = falseObject();
				}
			}
			else {

				/* attributeNumber = 16 */
				status = isSymlinkboolean(cPathName, &resultOop);
				if (status != 0) {
					return (pop(3),
						push(wrappedErrorCode(status)));
				}
			}
		}
	}
	if (resultOop == 0) {

		/* It shouldn't be possible to get here */
		return primitiveFail();
	}
	else {
		pop(3);
		push(resultOop);
	}
	return 0;
}


/*	Answer an array of file attributes.
	primFileAttributes: aString mask: attributeMask
	aString is the path to the file
	attributeMask indicates which attributes to retrieve:
	bit 0 - get stat() attributes
	bit 1 - get access() attributes
	bit 2 - use lstat() instead of stat()
	On error answer the appropriate error code (Integer) */

	/* FileAttributesPlugin>>#primitiveFileAttributes */
EXPORT(sqInt)
primitiveFileAttributes(void)
{
    sqInt attributeArray;
    sqInt attributeMask;
    char cPathName[PATH_MAX];
    sqInt fileName;
    int status;

	attributeArray = 0;
	fileName = stackObjectValue(1);
	attributeMask = stackIntegerValue(0);
	if (!(isKindOf(fileName, "String"))) {
		return (pop(3),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return (pop(3),
			push(signed32BitIntegerFor(status)));
	}
	status = fileToAttributeArraymaskarray(cPathName, attributeMask, &attributeArray);
	if (status != 0) {
		pop(3);
		push(signed32BitIntegerFor(status));
	}
	else {
		pop(3);
		push(attributeArray);
	}
	return 0;
}


/*	Check for existence of a file with a call to access(). */

	/* FileAttributesPlugin>>#primitiveFileExists */
EXPORT(sqInt)
primitiveFileExists(void)
{
    sqInt accessFlag;
    sqInt pathString;
    sqInt status;

	accessFlag = 0;
	pathString = stackObjectValue(0);
	if (!(isKindOf(pathString, "String"))) {
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	status = checkAccessmodeto(pathString, fileOKFlag(), &accessFlag);
	if (!(status == 0)) {
		return (pop(2),
			push(signed32BitIntegerFor(status)));
	}
	if (accessFlag == 0) {
		pop(2);
		push(trueObject());
	}
	else {
		pop(2);
		push(falseObject());
	}
	return 0;
}


/*	Answer an array of well known file masks */

	/* FileAttributesPlugin>>#primitiveFileMasks */
EXPORT(sqInt)
primitiveFileMasks(void)
{
    sqInt masks;

	masks = instantiateClassindexableSize(classArray(), 8);
	storePointerofObjectwithValue(0, masks, smallOrLargeIntegerObjectFor(S_IFMT));
	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("defined(WIN32)", null, "windows doesn't have SOCK or SYMLINK file types", null, (storePointerofObjectwithValue(1, masks, smallOrLargeIntegerObjectFor(S_IFSOCK)),
	storePointerofObjectwithValue(2, masks, smallOrLargeIntegerObjectFor(S_IFLNK))));
	storePointerofObjectwithValue(3, masks, smallOrLargeIntegerObjectFor(S_IFREG));
	storePointerofObjectwithValue(4, masks, smallOrLargeIntegerObjectFor(S_IFBLK));
	storePointerofObjectwithValue(5, masks, smallOrLargeIntegerObjectFor(S_IFDIR));
	storePointerofObjectwithValue(6, masks, smallOrLargeIntegerObjectFor(S_IFCHR));
	storePointerofObjectwithValue(7, masks, smallOrLargeIntegerObjectFor(S_IFIFO));
	popthenPush(1, masks);
	return 0;
}


/*	Answer the logical drive mask on windows */

	/* FileAttributesPlugin>>#primitiveLogicalDrives */
EXPORT(sqInt)
primitiveLogicalDrives(void)
{
    sqInt mask;

	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("defined(WIN32)", null, "Answer the logical drive mask on windows", ((mask = GetLogicalDrives()),
	(mask != 0
			? return popthenPush(1, positive32BitIntegerFor(mask))
			: 0)), null);
	return primitiveFail();
}


/*	self primOpendir: '/etc' */

	/* FileAttributesPlugin>>#primitiveOpendir */
EXPORT(sqInt)
primitiveOpendir(void)
{
    osdir *dir;
    sqInt dirName;
    sqInt dirOop;
    int status;

	dir = 0;
	dirName = stackObjectValue(0);
	if (!(isKindOf(dirName, "String"))) {
		fprintf(stderr, "primitiveOpendir: invalid argument, expected a String\n");
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	status = openDirectoryStreamptr(dirName, &dir);
	if (status != 0) {
		return (pop(2),
			push(signed32BitIntegerFor(status)));
	}
	dirOop = addressObjectFor(dir);
	pop(2);
	push(dirOop);
	return 0;
}


/*	Answer the value of PATH_MAX for the current VM */

	/* FileAttributesPlugin>>#primitivePathMax */
EXPORT(sqInt)
primitivePathMax(void)
{
	return popthenPush(1, smallOrLargeIntegerObjectFor(PATH_MAX));
}


/*	Get the next entry in the directory stream. Answer the name of the entry,
	or error for end of directory stream. */

	/* FileAttributesPlugin>>#primitiveReaddir */
EXPORT(sqInt)
primitiveReaddir(void)
{
    sqInt attributeArray;
    sqInt dirPointerOop;
    osdir *dirStream;
    struct dirent *ent;
    sqInt entryName;
    sqInt entry_len;
    int haveEntry;
    sqInt resultArray;
    sqInt status;

	attributeArray = 0;
	entryName = 0;
	dirPointerOop = stackObjectValue(0);
	if (!(isKindOf(dirPointerOop, "ByteArray"))) {
		fprintf(stderr, "primitiveReaddir: invalid argument, expected an ByteArray\n");
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	dirStream = pointerFrom(dirPointerOop);
	if (dirStream == null) {
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	haveEntry = 0;
	do {;
	ent = readdir(dirStream->dp);
	if (ent == NULL ||
                 		((! (ent->d_name[0] == '.' && strlen(ent->d_name) == 1)) && strcmp(ent->d_name, "..")))
                     		haveEntry = 1;
		} while (haveEntry == 0);
	if (ent == null) {

		/* This is the normal case for the end of a directory stream,
		   although it may indicate other error conditions for which errno would be updated.
		   Assume the normal case here. */
		return (pop(2),
			push(nilObject()));
	}
	status = byteArrayFromCStringto(ent->d_name, &entryName);
	if (status != 0) {
		return (pop(2),
			push(signed32BitIntegerFor(status)));
	}
	entry_len = strlen(ent->d_name);
	if (((dirStream->path_len) + entry_len) > (PATH_MAX-1)) {
		return (pop(2),
			push(signed32BitIntegerFor(-1 /* stringTooLong */)));
	}
	memcpy(dirStream->path_file, ent->d_name, entry_len);
	dirStream->path_file[entry_len] = '\0';

	/* If the stat() fails, still return the filename, just no attributes */
	status = fileToAttributeArraymaskarray(dirStream->path, 1, &attributeArray);
	if (status != 0) {
		attributeArray = nilObject();
	}
	resultArray = instantiateClassindexableSize(classArray(), 2);
	storePointerofObjectwithValue(0, resultArray, entryName);
	storePointerofObjectwithValue(1, resultArray, attributeArray);
	pop(2);
	push(resultArray);
	return 0;
}


/*	Set directoryStream to first entry. Answer dirPointerOop. */

	/* FileAttributesPlugin>>#primitiveRewinddir */
EXPORT(sqInt)
primitiveRewinddir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;

	dirPointerOop = stackObjectValue(0);
	if (!(isKindOf(dirPointerOop, "ByteArray"))) {
		fprintf(stderr, "primitiveRewindir: invalid argument, expected an ByteArray\n");
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	dirStream = pointerFrom(dirPointerOop);
	if (dirStream == null) {
		return (pop(2),
			push(signed32BitIntegerFor(-6 /* invalidArguments */)));
	}
	rewinddir(dirStream->dp);
	pop(2);
	push(dirPointerOop);
	return 0;
}


/*	Answer a string containing the version string for this plugin. */

	/* FileAttributesPlugin>>#primitiveVersionString */
EXPORT(sqInt)
primitiveVersionString(void)
{
	popthenPush(1, stringFromCString(versionString()));
	return 0;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putLStatFor:intoBuffer:targetName: */
static sqInt
putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    char *cLinkPtr = (char *) &cLinkName;
    size_t len;
    sqInt result;
    sqInt status;

	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("HAVE_LSTAT == 1", null, "Platforms which do not have lstat() should #define HAVE_LSTAT 0", ((result = lstat(cPathName, statBufPointer)),
	(result != 0
			? (/* begin cantStatPath */
				return -3)
			: 0),
	((S_ISLNK(statBufPointer->st_mode)) == 0
			? *fileNameOop = interpreterProxy->nilObject()
			: ((len = readLinkintomaxLength(cPathName, cLinkPtr, PATH_MAX)),
				(len < 0
						? return len
						: 0),
				(status = byteArrayFromCStringto(cLinkPtr, fileNameOop)),
				(status != 0
						? return status
						: 0)))), (/* begin invalidRequest */
	return -11));
	return 0;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putStatFor:intoBuffer:targetName: */
static sqInt
putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    sqInt result;
    sqInt status;

	
#ifdef WIN32
	TIME_ZONE_INFORMATION dtzi;
	#endif;
	result = stat(cPathName, statBufPointer);
	if (result != 0) {
		/* begin cantStatPath */
		return -3;
	}
	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("defined(WIN32)", null, "The windows version of stat() looks like it doesn't handle dst properly.  Adjust for DST.  Remove this code if ever switching to cygwin stat().", ((status = GetTimeZoneInformation(&dtzi)),
	(status == 2
			? (statBufPointer->st_atime -= 3600,
				statBufPointer->st_mtime -= 3600,
				statBufPointer->st_ctime -= 3600)
			: 0)), null);
	*fileNameOop = interpreterProxy->nilObject();
	return 0;
}


/*	Get the target filename of the supplied symbolic link. */

	/* FileAttributesPlugin>>#readLink:into:maxLength: */
static size_t
readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength)
{
    size_t len;

	len = 0;
	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("defined(WIN32)", null, "This should never be called on WIN32, just indicate failure", (len = -1), (len = readlink(cPathName, cLinkPtr, maxLength)));
	if (len < 0) {
		fprintf(stderr, "FileAttributesPlugin: unable to readlink(): %d\n", len);
		/* begin cantReadlink */
		return ((sqInt) -8);
	}
	cLinkPtr[len] = 0;
	return len;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		falseObject = interpreterProxy->falseObject;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isKindOf = interpreterProxy->isKindOf;
		isBytes = interpreterProxy->isBytes;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		primitiveFail = interpreterProxy->primitiveFail;
		push = interpreterProxy->push;
		signed32BitIntegerFor = interpreterProxy->signed32BitIntegerFor;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		sizeOfSTArrayFromCPrimitive = interpreterProxy->sizeOfSTArrayFromCPrimitive;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Size of a C pointer on this machine */

	/* FileAttributesPlugin>>#sizeOfPointer */
static sqInt
sizeOfPointer(void)
{
	return sizeof(void *);
}


/*	Answer an Integer object for aPositiveInteger. If the value is too large
	to fit in an SmallInteger, then answer a LargePositiveInteger. Note that
	smallIntegerMaxVal is a class variable with an initialization value
	determined when this class is translated to C code; see my
	#declareCVarsIn: class method.
 */

	/* FileAttributesPlugin>>#smallOrLargeIntegerObjectFor: */
static sqInt
smallOrLargeIntegerObjectFor(sqInt aPositiveInteger)
{
	if (aPositiveInteger > smallIntegerMaxVal) {
		return integerObjectOf(aPositiveInteger);
	}
	else {
		return positive32BitIntegerFor(aPositiveInteger);
	}
}


/*	Answer a file entry array from the supplied statBufPointer */

	/* FileAttributesPlugin>>#statArrayFor:toArray:from:fileName: */
static sqInt
statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop)
{
    time_t creationDate;
    sqInt index;
    sqInt sizeIfFile;
    sqInt status;

	if ((S_ISDIR(statBufPointer->st_mode)) == 0) {
		sizeIfFile = statBufPointer->st_size;
	}
	else {
		sizeIfFile = 0;
	}
	index = 0;
	storePointerofObjectwithValue(index, attributeArray, fileNameOop);

	/* 1 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(statBufPointer->st_mode));

	/* 2 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, positive64BitIntegerFor(statBufPointer->st_ino));

	/* 3 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, positive64BitIntegerFor(statBufPointer->st_dev));

	/* 4 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, positive64BitIntegerFor(statBufPointer->st_nlink));

	/* 5 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(statBufPointer->st_uid));

	/* 6 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(statBufPointer->st_gid));

	/* 7 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, smallOrLargeIntegerObjectFor(sizeIfFile));

	/* 8 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(statBufPointer->st_atime));

	/* 9 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(statBufPointer->st_mtime));

	/* 10 */
	index += 1;
	storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(statBufPointer->st_ctime));

	/* 11 */
	index += 1;
	isDefinedTrueExpressioninSmalltalkcommentifTrueifFalse("defined(WIN32)", null, "windows supports creation date", ((status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), &creationDate)),
	(status == 0
			? storePointerofObjectwithValue(index, attributeArray, oopFromTimeT(creationDate))
			: storePointerofObjectwithValue(index, attributeArray, nilObject()))), storePointerofObjectwithValue(index, attributeArray, nilObject()));
	return 0;
}


/*	A call to stat() failed */

	/* FileAttributesPlugin>>#statFailed */
static sqInt
statFailed(void)
{
	return -2;
}


/*	Answer a new String copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#stringFromCString: */
static sqInt
stringFromCString(const char *aCString)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(classString(), len);
	strncpy(arrayValueOf(newString), aCString, len);
	return newString;
}


/*	String too long. A file path name was longer than PATH_MAX */

	/* FileAttributesPlugin>>#stringTooLong */
static sqInt
stringTooLong(void)
{
	return -1;
}

	/* FileAttributesPlugin>>#timeConversionFailed */
static sqInt
timeConversionFailed(void)
{
	return -5;
}


/*	Answer a string containing the version string for this plugin. */

	/* FileAttributesPlugin>>#versionString */
static char *
versionString(void)
{
    static char version[]= "1.0.0";

	return version;
}


/*	Answer a single element Array containing the supplied error code. */

	/* FileAttributesPlugin>>#wrappedErrorCode: */
static sqInt
wrappedErrorCode(sqInt aNumber)
{
    sqInt newArray;

	newArray = instantiateClassindexableSize(classArray(), 1);
	storePointerofObjectwithValue(0, newArray, signed32BitIntegerFor(aNumber));
	return newArray;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "FileAttributesPlugin";
void* FileAttributesPlugin_exports[][3] = {
	{(void*)_m, "checkAccessmodeto", (void*)checkAccessmodeto},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveClosedir\000\001", (void*)primitiveClosedir},
	{(void*)_m, "primitiveFileAttribute\000\001", (void*)primitiveFileAttribute},
	{(void*)_m, "primitiveFileAttributes\000\001", (void*)primitiveFileAttributes},
	{(void*)_m, "primitiveFileExists\000\001", (void*)primitiveFileExists},
	{(void*)_m, "primitiveFileMasks\000\377", (void*)primitiveFileMasks},
	{(void*)_m, "primitiveLogicalDrives\000\377", (void*)primitiveLogicalDrives},
	{(void*)_m, "primitiveOpendir\000\002", (void*)primitiveOpendir},
	{(void*)_m, "primitivePathMax\000\377", (void*)primitivePathMax},
	{(void*)_m, "primitiveReaddir\000\001", (void*)primitiveReaddir},
	{(void*)_m, "primitiveRewinddir\000\001", (void*)primitiveRewinddir},
	{(void*)_m, "primitiveVersionString\000\377", (void*)primitiveVersionString},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveClosedirAccessorDepth = 1;
signed char primitiveFileAttributeAccessorDepth = 1;
signed char primitiveFileAttributesAccessorDepth = 1;
signed char primitiveFileExistsAccessorDepth = 1;
signed char primitiveOpendirAccessorDepth = 2;
signed char primitiveReaddirAccessorDepth = 1;
signed char primitiveRewinddirAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
