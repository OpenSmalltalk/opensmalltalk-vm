/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-topa.2418 uuid: 6a3317fd-ca50-498f-8879-332f920fe363
   from
	FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.30 uuid: 943fc170-d5c4-4cfd-846c-c3c937a110b5
 */
static char __buildInfo[] = "FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.30 uuid: 943fc170-d5c4-4cfd-846c-c3c937a110b5 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <limits.h>
#include <sys/types.h>
#include <dirent.h>
#ifdef _WIN32
#include <windows.h>
#include <winbase.h>
#define FAIL() { return -1; }
#include "sqWin32File.h"
#endif
typedef struct dirptrstruct {
    		DIR *dp;
		int path_len;
    		char *path_file;
   		char path[PATH_MAX+4];
    		} osdir;
#include <sys/stat.h>
#if !defined(HAVE_LSTAT) && !defined(_WIN32)
#define HAVE_LSTAT 1
#endif
#include <unistd.h>
/* AKG 2017 - FileAttributesPlugin.c translated from class FileAttributesPlugin */

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrNoMemory 9


/*** Function Prototypes ***/
static sqInt accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset);
static sqInt addressObjectFor(void *aMachineAddress);
static sqInt byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop);
static sqInt canOpenDirectoryStreamForlength(char *aPathCString, sqInt length);
static sqInt canStatFilePathlength(char *aPathCString, sqInt length);
EXPORT(sqInt) checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag);
#if _WIN32
static sqLong convertWinToSqueakTime(SYSTEMTIME st);
#endif /* _WIN32 */
static sqLong faConvertUnixToLongSqueakTime(time_t unixTime);
#if _WIN32
static sqInt fileCreationTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt fileLastAccessTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt fileLastWriteTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate);
#endif /* _WIN32 */
static int fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray);
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt isSymlinkboolean(char *cPathName, sqInt *resultOop);
static int openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr);
static int pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen);
static void * pointerFrom(sqInt directoryPointerBytes);
static sqInt posixFileTimesFromto(struct stat *statBufPointer, sqInt attributeArray);
EXPORT(sqInt) primitiveClosedir(void);
EXPORT(sqInt) primitiveFileAttribute(void);
EXPORT(sqInt) primitiveFileAttributes(void);
EXPORT(sqInt) primitiveFileExists(void);
EXPORT(sqInt) primitiveFileMasks(void);
EXPORT(sqInt) primitiveLogicalDrives(void);
EXPORT(sqInt) primitiveOpendir(void);
EXPORT(sqInt) primitivePathMax(void);
EXPORT(sqInt) primitiveReaddir(void);
EXPORT(sqInt) primitiveRewinddir(void);
EXPORT(sqInt) primitiveVersionString(void);
static sqInt putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop);
static sqInt stringFromCString(const char *aCString);
#if _WIN32
static sqInt winFileAttributesForlengthto(char *pathString, sqInt pathLength, WIN32_FILE_ATTRIBUTE_DATA *winAttrs);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileCreationTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *creationDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileLastAccessTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *accessDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileLastWriteTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *writeDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileTimesForto(char *cPathName, sqInt attributeArray);
#endif /* _WIN32 */


/*** Variables ***/
static int hasSecurityPlugin = 1;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*classArray)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*nilObject)(void);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*primitiveFailForOSError)(sqLong osError);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqInt (*sizeOfSTArrayFromCPrimitive)(void *cPtr);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt classArray(void);
extern sqInt classByteArray(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt nilObject(void);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailForOSError(sqLong osError);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.30 (i)"
#else
	"FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.30 (e)"
#endif
;
static void * sCLPfn;
static void * sCOFfn;



/*	Call access() for each access type (R, W, X) on the c string cPathName,
	storing the results in the st array attributeArray.
 */

	/* FileAttributesPlugin>>#accessAttributesForFilename:into:startingAt: */
static sqInt
accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset)
{
    sqInt boolean;
    sqInt index;

	index = offset;
	if ((access(cPathName, R_OK)) == 0) {
		boolean = trueObject();
	}
	else {
		boolean = falseObject();
	}
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	boolean = ((access(cPathName, W_OK)) == 0
		? trueObject()
		: falseObject());
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	boolean = ((access(cPathName, X_OK)) == 0
		? trueObject()
		: falseObject());
	storePointerofObjectwithValue(index, attributeArray, boolean);
	return 0;
}


/*	Answer an ExternalAddress object which represents aMachineAddress */

	/* FileAttributesPlugin>>#addressObjectFor: */
static sqInt
addressObjectFor(void *aMachineAddress)
{
    sqInt addressOop;
    unsigned char *addressOopArrayPointer;
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;

	addressOop = instantiateClassindexableSize(classByteArray(), sizeof(void *));
	if (!(addressOop)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	addressOopArrayPointer = arrayValueOf(addressOop);
	addressUnion.address = aMachineAddress;
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressOopArrayPointer[idx] = addressUnion.bytes[idx];
		idx += 1;
	}
	return addressOop;
}


/*	Answer a new ByteArray copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#byteArrayFromCString:to: */
static sqInt
byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop)
{
    unsigned char *byteArrayPtr;
    sqInt len;
    sqInt newByteArray;


	/* We never return strings longer than PATH_MAX */
	len = strlen(aCString);
	if (len > PATH_MAX) {
		return -1 /* stringTooLong */;
	}
	newByteArray = instantiateClassindexableSize(classByteArray(), len);
	if (!(newByteArray)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	byteArrayPtr = arrayValueOf(newByteArray);
	memcpy(byteArrayPtr, aCString, len);
	byteArrayOop[0] = newByteArray;
	return 0;
}


/*	Answer non-zero if security permits the directory to be listed. */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
/*	The hasSecurityPlugin flag is set to 1 by default */

	/* FileAttributesPlugin>>#canOpenDirectoryStreamFor:length: */
static sqInt
canOpenDirectoryStreamForlength(char *aPathCString, sqInt length)
{
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	if (sCLPfn != 0) {
		return  ((int (*) (char *, int)) sCLPfn)(aPathCString, length);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Answer non-zero if security permits the a stat() call on the file path.
	Allow a
	stat() call only on files which we are permitted to open.
 */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
/*	The hasSecurityPlugin flag is set to 1 by default */

	/* FileAttributesPlugin>>#canStatFilePath:length: */
static sqInt
canStatFilePathlength(char *aPathCString, sqInt length)
{
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	if (sCOFfn != 0) {
		return  ((int (*) (char *, int, int)) sCOFfn)(aPathCString, length, 0);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Check access to pathString. */

	/* FileAttributesPlugin>>#checkAccess:mode:to: */
EXPORT(sqInt)
checkAccessmodeto(sqInt pathString, sqInt mode, sqInt *flag)
{
    char cString[PATH_MAX];
    sqInt len;
    char *sPtr;


	/* Note: The static sized string buffer is faster than using a Smalltalk allocated
	   string as the buffer, and is unlikely to fail in practice. In the event that
	   the buffer turns out to be too small, write an error message to stdout before
	   failing. */
	len = stSizeOf(pathString);
	if (len >= PATH_MAX) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathString);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return -3;
	}
	memcpy(cString, sPtr, len);
	cString[len] = 0;
	flag[0] = (access(cString, mode));
	return 0;
}


/*	Convert the supplied Windows SYSTEMTIME to Squeak time */

	/* FileAttributesPlugin>>#convertWinToSqueakTime: */
#if _WIN32
static sqLong
convertWinToSqueakTime(SYSTEMTIME st)
{
    sqLong dy;
    static sqLong nDaysPerMonth[14] = { 
		0,  0,  31,  59,  90, 120, 151,
		181, 212, 243, 273, 304, 334, 365 };
    sqLong secs;

	dy = (st.wYear) - 1901;

	/* base seconds */
	/* seconds of leap years */
	/* check if month > 2 and current year is a leap year */
	secs = ((((dy * 365) * 24) * 60) * 60) + ((((((usqInt) dy >> 2)) * 24) * 60) * 60);
	if (((st.wMonth) > 2)
	 && ((dy & 3) == 3)) {

		/* add one day */
		secs += (24 * 60) * 60;
	}

	/* add the hours, minutes, and seconds */
	secs += (nDaysPerMonth[st.wMonth] + st.wDay - 1) * 24 * 60 * 60;
	secs += st.wSecond + 60*(st.wMinute + 60*st.wHour);
	return secs;
}
#endif /* _WIN32 */


/*	Convert the supplied Unix (UTC) time to Squeak time.
	
	Squeak time has an epoch of 1901 and uses local time
	i.e. timezone + daylight savings
	
	Answer an sqLong which is guaranteed to be 64 bits on all platforms.
 */

	/* FileAttributesPlugin>>#faConvertUnixToLongSqueakTime: */
static sqLong
faConvertUnixToLongSqueakTime(time_t unixTime)
{
    sqLong squeakTime;

	
#  if defined(_WIN32)
	squeakTime = 0;
#  else /* defined(_WIN32) */
	squeakTime = unixTime;
	
#  if defined(HAVE_TM_GMTOFF)
	squeakTime += localtime(&unixTime)->tm_gmtoff;
#  else /* defined(HAVE_TM_GMTOFF) */
	
#  if defined(HAVE_TIMEZONE)
	squeakTime += (daylight*60*60) - timezone;
#  else /* defined(HAVE_TIMEZONE) */
	
#error: cannot determine timezone correction
#  endif /* defined(HAVE_TIMEZONE) */
#  endif /* defined(HAVE_TM_GMTOFF) */
	squeakTime += (52*365UL + 17*366UL) * 24*60*60UL;
#  endif /* defined(_WIN32) */
	return squeakTime;
}


/*	Get the creationDate for the supplied file. */

	/* FileAttributesPlugin>>#fileCreationTimeFor:length:to: */
#if _WIN32
static sqInt
fileCreationTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate)
{
    sqInt status;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	status = winFileAttributesForlengthto(pathString, pathLength, (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileCreationTimeForto((&winAttrs), creationDate);
	if (!(status == 0)) {
		return status;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Get the creationDate for the supplied file. */

	/* FileAttributesPlugin>>#fileLastAccessTimeFor:length:to: */
#if _WIN32
static sqInt
fileLastAccessTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate)
{
    sqInt status;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	status = winFileAttributesForlengthto(pathString, pathLength, (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileLastAccessTimeForto((&winAttrs), creationDate);
	if (!(status == 0)) {
		return status;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Get the creationDate for the supplied file. */

	/* FileAttributesPlugin>>#fileLastWriteTimeFor:length:to: */
#if _WIN32
static sqInt
fileLastWriteTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate)
{
    sqInt status;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	status = winFileAttributesForlengthto(pathString, pathLength, (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileLastWriteTimeForto((&winAttrs), creationDate);
	if (!(status == 0)) {
		return status;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Answer a file attribute array from pathNameOop. */

	/* FileAttributesPlugin>>#fileToAttributeArray:mask:array: */
static int
fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray)
{
    sqInt accessArray;
    sqLong attributeDate;
    sqInt boolean;
    char cLinkName[PATH_MAX];
    sqInt combinedArray;
    sqInt fileNameOop;
    int getAccess;
    int getStats;
    sqInt index;
    sqInt len;
    sqInt sizeIfFile;
    sqInt statArray;
    struct stat statBuf;
    struct stat *statBufPointer;
    struct stat *statBufPointer1;
    struct stat *statBufPointer2;
    sqInt status;
    sqInt status1;
    sqInt status2;
    sqInt status3;
    int useLstat;


	/* Determine which attributes to retrieve */
	accessArray = 0;
	fileNameOop = 0;
	statArray = 0;
	getStats = attributeMask & 1;
	getAccess = attributeMask & 2;
	if (!(getStats
		 || (getAccess))) {

		/* No information has been requested, which doesn't make sense */
		return -6 /* invalidArguments */;
	}
	if (getStats) {
		useLstat = attributeMask & 4;
		statArray = instantiateClassindexableSize(classArray(), 12);
		if (!(statArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		if (useLstat) {
			/* begin putLStatFor:intoBuffer:targetName: */
			statBufPointer2 = ((struct stat *) ((&statBuf)));
			
#      if HAVE_LSTAT == 1
			status3 = lstat(cPathName, statBufPointer2);
			if (status3 != 0) {
				/* begin cantStatPath */
				status = -3;
				goto l5;
			}
			if ((S_ISLNK((statBufPointer2->st_mode))) == 0) {
				((&fileNameOop))[0] = (nilObject());
			}
			else {
				len = readLinkintomaxLength(cPathName, cLinkName, PATH_MAX);
				if (len < 0) {
					status = len;
					goto l5;
				}
				status3 = byteArrayFromCStringto(cLinkName, (&fileNameOop));
			}
#      else /* HAVE_LSTAT == 1 */

			/* #HAVE_LSTAT = 1 */
			/* begin invalidRequest */
			status3 = -11;
#      endif /* HAVE_LSTAT == 1 */
			status = status3;
	l5:	/* end putLStatFor:intoBuffer:targetName: */;
		}
		else {
			/* begin putStatFor:intoBuffer:targetName: */
			statBufPointer = ((struct stat *) ((&statBuf)));
			status1 = stat(cPathName, statBufPointer);
			if (status1 != 0) {
				/* begin cantStatPath */
				status = -3;
				goto l1;
			}
			((&fileNameOop))[0] = (nilObject());
			status = 0;
	l1:	/* end putStatFor:intoBuffer:targetName: */;
		}
		if (status != 0) {
			return status;
		}
		/* begin statArrayFor:toArray:from:fileName: */
		statBufPointer1 = ((struct stat *) ((&statBuf)));
		sizeIfFile = ((S_ISDIR((statBufPointer1->st_mode))) == 0
			? (statBufPointer1->st_size)
			: 0);
		storePointerofObjectwithValue(0, statArray, fileNameOop);
		storePointerofObjectwithValue(1, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_mode))
			: positive32BitIntegerFor((statBufPointer1->st_mode))));
		storePointerofObjectwithValue(2, statArray, positive64BitIntegerFor((statBufPointer1->st_ino)));
		storePointerofObjectwithValue(3, statArray, positive64BitIntegerFor((statBufPointer1->st_dev)));
		storePointerofObjectwithValue(4, statArray, positive64BitIntegerFor((statBufPointer1->st_nlink)));
		storePointerofObjectwithValue(5, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_uid))
			: positive32BitIntegerFor((statBufPointer1->st_uid))));
		storePointerofObjectwithValue(6, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_gid))
			: positive32BitIntegerFor((statBufPointer1->st_gid))));
		storePointerofObjectwithValue(7, statArray, positive64BitIntegerFor(sizeIfFile));
		
#    if defined(_WIN32)
		status2 = winFileTimesForto(cPathName, statArray);
#    else /* defined(_WIN32) */
		/* begin posixFileTimesFrom:to: */
		
#    if defined(_WIN32)
#    else /* defined(_WIN32) */
		attributeDate = faConvertUnixToLongSqueakTime((statBufPointer1->st_atime));
		storePointerofObjectwithValue(8, statArray, signed64BitIntegerFor(attributeDate));
		attributeDate = faConvertUnixToLongSqueakTime((statBufPointer1->st_mtime));
		storePointerofObjectwithValue(9, statArray, signed64BitIntegerFor(attributeDate));
		attributeDate = faConvertUnixToLongSqueakTime((statBufPointer1->st_ctime));
		storePointerofObjectwithValue(10, statArray, signed64BitIntegerFor(attributeDate));
		storePointerofObjectwithValue(11, statArray, nilObject());
#    endif /* defined(_WIN32) */
		status2 = 0;
#    endif /* defined(_WIN32) */
		status = status2;
		if (status != 0) {
			return status;
		}
		attributeArray[0] = statArray;
	}
	if (getAccess) {
		accessArray = instantiateClassindexableSize(classArray(), 3);
		if (!(accessArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		/* begin accessAttributesForFilename:into:startingAt: */
		index = 0;
		if ((access(cPathName, R_OK)) == 0) {
			boolean = trueObject();
		}
		else {
			boolean = falseObject();
		}
		storePointerofObjectwithValue(index, accessArray, boolean);
		index += 1;
		boolean = ((access(cPathName, W_OK)) == 0
			? trueObject()
			: falseObject());
		storePointerofObjectwithValue(index, accessArray, boolean);
		index += 1;
		boolean = ((access(cPathName, X_OK)) == 0
			? trueObject()
			: falseObject());
		storePointerofObjectwithValue(index, accessArray, boolean);
		attributeArray[0] = accessArray;
	}
	if (getStats
	 && (getAccess)) {
		combinedArray = instantiateClassindexableSize(classArray(), 2);
		if (!(combinedArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		attributeArray[0] = combinedArray;
		storePointerofObjectwithValue(0, combinedArray, statArray);
		storePointerofObjectwithValue(1, combinedArray, accessArray);
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* FileAttributesPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	sCOFfn = ioLoadFunctionFrom("secCanOpenFileOfSizeWritable", "SecurityPlugin");
	sCLPfn = ioLoadFunctionFrom("secCanListPathOfSize", "SecurityPlugin");
	return 1;
}


/*	Set resultOop to a boolean indicating whether cPathName is a symbolic
	link. Answer status (0 = success) */

	/* FileAttributesPlugin>>#isSymlink:boolean: */
static sqInt
isSymlinkboolean(char *cPathName, sqInt *resultOop)
{
    struct stat statBuf;
    sqInt status;

	
#  if HAVE_LSTAT == 1
	status = lstat(cPathName, (&statBuf));
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	if ((S_ISLNK((statBuf.st_mode))) == 0) {
		resultOop[0] = (falseObject());
	}
	else {
		resultOop[0] = (trueObject());
	}
#  endif /* HAVE_LSTAT == 1 */
	return 0;
}


/*	Open a new directory stream. Answer a pointer to the directory stream or
	NULL. 
 */

	/* FileAttributesPlugin>>#openDirectoryStream:ptr: */
static int
openDirectoryStreamptr(sqInt pathOOP, osdir **osdirPtr)
{
    osdir *dir;
    sqInt len;
    char *sPtr;

	sPtr = arrayValueOf(pathOOP);

	/* The path buffer needs room for a trailing slash and the file name, so subtracting 2 is conservative */
	len = sizeOfSTArrayFromCPrimitive(sPtr);
	if (len > (PATH_MAX - 2)) {
		return -1 /* stringTooLong */;
	}
	if (canOpenDirectoryStreamForlength(sPtr, len)) {
		dir = (osdir *) malloc(sizeof(osdir));
		if (dir == null) {
			/* begin cantAllocateMemory */
			return ((sqInt) -10);
		}
		memcpy((dir->path), sPtr, len);
		if (dir->path[len-1] != '/') {
				dir->path[len++] = '/';
				}
		dir->path_file = dir->path + len;
		dir->path_file[0] = '\0';
		dir->path_len = len;
		dir->dp =  opendir(dir->path);
		if (!((dir->dp))) {
			free(dir);
			/* begin cantOpenDir */
			return ((sqInt) -9);
		}
		osdirPtr[0] = dir;
		return 0;
	}
	/* begin cantOpenDir */
	return ((sqInt) -9);
}


/*	Copy the supplied path name string object to the supplied c string buffer */

	/* FileAttributesPlugin>>#pathOop:toBuffer:maxLen: */
static int
pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen)
{
    sqInt len;
    char *sPtr;

	len = stSizeOf(pathNameOop);
	if (len >= maxLen) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathNameOop);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return ((sqInt) -3);
	}
	memcpy(cPathName, sPtr, len);
	cPathName[len] = 0;
	return 0;
}


/*	Answer the machine address contained in anExternalAddressOop. */

	/* FileAttributesPlugin>>#pointerFrom: */
static void *
pointerFrom(sqInt directoryPointerBytes)
{
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((isKindOf(directoryPointerBytes, "ByteArray"))
		 && ((stSizeOf(directoryPointerBytes)) == (sizeof(void *))))) {
		return null;
	}
	ptr = arrayValueOf(directoryPointerBytes);
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return addressUnion.address;
}


/*	Populate attributeArray with the file times from statBufPointer */

	/* FileAttributesPlugin>>#posixFileTimesFrom:to: */
static sqInt
posixFileTimesFromto(struct stat *statBufPointer, sqInt attributeArray)
{
    sqLong attributeDate;

	
#  if defined(_WIN32)
#  else /* defined(_WIN32) */
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_atime));
	storePointerofObjectwithValue(8, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_mtime));
	storePointerofObjectwithValue(9, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_ctime));
	storePointerofObjectwithValue(10, attributeArray, signed64BitIntegerFor(attributeDate));
	storePointerofObjectwithValue(11, attributeArray, nilObject());
#  endif /* defined(_WIN32) */
	return 0;
}


/*	Close the directory stream for dirPointerOop. Answer dirPointerOop on
	success. Raise PrimErrBadArgument if the parameter is not a ByteArray
	length size(void *).
	If closedir() returns an error raise PrimitiveOSError.
 */

	/* FileAttributesPlugin>>#primitiveClosedir */
EXPORT(sqInt)
primitiveClosedir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;
    sqInt result;

	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	result = closedir((dirStream->dp));
	if (!(result == 0)) {
		return primitiveFailForOSError(-12 /* unableToCloseDir */);
	}
	free(dirStream);
	popthenPush(2, dirPointerOop);
	return 0;
}


/*	Answer a single file attribute.
	primFileAttributes: aString attributeNumber: attributeNumber
	aString is the path to the file
	attributeNumber identifies which attribute to return:
	1 - 12: stat(): name, mode, ino, dev, nlink, uid, gid, size, accessDate,
	modifiedDate, changeDate, creationDate
	13 - 15: access(): R_OK, W_OK, X_OK
	16: isSymlink
	On error, answer a single element array containing the appropriate error
	code. 
 */

	/* FileAttributesPlugin>>#primitiveFileAttribute */
EXPORT(sqInt)
primitiveFileAttribute(void)
{
    sqLong attributeDate;
    sqInt attributeNumber;
    char cPathName[PATH_MAX];
    sqInt fileName;
    sqInt fileNameOop;
    sqInt mode;
    sqInt resultOop;
    sqInt *resultOop1;
    sqInt sizeIfFile;
    struct stat statBuf;
    struct stat statBuf1;
    struct stat *statBufPointer;
    sqInt status;
    sqInt status1;
    sqInt status2;
    sqInt val;
    usqIntptr_t value;
    usqIntptr_t value1;
    usqIntptr_t value2;

	attributeDate = 0;
	fileNameOop = 0;
	mode = 0;
	val = 0;
	fileName = stackObjectValue(1);
	attributeNumber = stackIntegerValue(0);
	if ((failed())
	 || ((!(((attributeNumber >= 1) && (attributeNumber <= 16))))
	 || (!(isKindOf(fileName, "String"))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	resultOop = 0;
	if (attributeNumber < 12) {

		/* Get requested stat entry */
		/* begin putStatFor:intoBuffer:targetName: */
		statBufPointer = ((struct stat *) ((&statBuf)));
		status2 = stat(cPathName, statBufPointer);
		if (status2 != 0) {
			/* begin cantStatPath */
			status = -3;
			goto l9;
		}
		((&fileNameOop))[0] = (nilObject());
		status = 0;
	l9:	/* end putStatFor:intoBuffer:targetName: */;
		if (status != 0) {
			return primitiveFailForOSError(status);
		}
		if (attributeNumber == 1) {
			resultOop = fileNameOop;
		}
		if (attributeNumber == 2) {
			/* begin positiveMachineIntegerFor: */
			value = (statBuf.st_mode);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value)
				: positive32BitIntegerFor(value));
		}
		if (attributeNumber == 3) {
			resultOop = positive64BitIntegerFor((statBuf.st_ino));
		}
		if (attributeNumber == 4) {
			resultOop = positive64BitIntegerFor((statBuf.st_dev));
		}
		if (attributeNumber == 5) {
			resultOop = positive64BitIntegerFor((statBuf.st_nlink));
		}
		if (attributeNumber == 6) {
			/* begin positiveMachineIntegerFor: */
			value1 = (statBuf.st_uid);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value1)
				: positive32BitIntegerFor(value1));
		}
		if (attributeNumber == 7) {
			/* begin positiveMachineIntegerFor: */
			value2 = (statBuf.st_gid);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value2)
				: positive32BitIntegerFor(value2));
		}
		if (attributeNumber == 8) {
			sizeIfFile = ((S_ISDIR((statBuf.st_mode))) == 0
				? (statBuf.st_size)
				: 0);
			/* begin positiveMachineIntegerFor: */
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(sizeIfFile)
				: positive32BitIntegerFor(sizeIfFile));
		}
		if (attributeNumber == 9) {

			/* Access Time */
			
#      if defined(_WIN32)
			status = fileLastAccessTimeForlengthto(cPathName, strlen(cPathName), (&attributeDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			resultOop = signed64BitIntegerFor(attributeDate);
#      else /* defined(_WIN32) */
			attributeDate = faConvertUnixToLongSqueakTime((statBuf.st_atime));
			resultOop = signed64BitIntegerFor(attributeDate);
#      endif /* defined(_WIN32) */
		}
		if (attributeNumber == 10) {

			/* Modified Time */
			
#      if defined(_WIN32)
			status = fileLastWriteTimeForlengthto(cPathName, strlen(cPathName), (&attributeDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			resultOop = signed64BitIntegerFor(attributeDate);
#      else /* defined(_WIN32) */
			attributeDate = faConvertUnixToLongSqueakTime((statBuf.st_mtime));
			resultOop = signed64BitIntegerFor(attributeDate);
#      endif /* defined(_WIN32) */
		}
		if (attributeNumber == 11) {

			/* Change Time */
			
#      if defined(_WIN32)
			resultOop = nilObject();
#      else /* defined(_WIN32) */
			attributeDate = faConvertUnixToLongSqueakTime((statBuf.st_ctime));
			resultOop = signed64BitIntegerFor(attributeDate);
#      endif /* defined(_WIN32) */
		}
	}
	else {
		if (attributeNumber == 12) {

			/* Creation Time */
			
#      if defined(_WIN32)
			status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), (&attributeDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			resultOop = signed64BitIntegerFor(attributeDate);
#      else /* defined(_WIN32) */
			resultOop = nilObject();
#      endif /* defined(_WIN32) */
		}
		else {
			if (attributeNumber < 16) {

				/* Get requested access entry */
				if (attributeNumber == 13) {
					/* begin fileReadableFlag */
					mode = R_OK;
				}
				if (attributeNumber == 14) {
					/* begin fileWriteableFlag */
					mode = W_OK;
				}
				if (attributeNumber == 15) {
					/* begin fileExecutableFlag */
					mode = X_OK;
				}
				resultOop = ((access(cPathName, mode)) == 0
					? trueObject()
					: falseObject());
			}
			else {

				/* attributeNumber = 16, #isSymlink */
				/* begin isSymlink:boolean: */
				resultOop1 = ((sqInt *) ((&resultOop)));
				
#        if HAVE_LSTAT == 1
				status1 = lstat(cPathName, (&statBuf1));
				if (status1 != 0) {
					/* begin cantStatPath */
					status = -3;
					goto l8;
				}
				if ((S_ISLNK((statBuf1.st_mode))) == 0) {
					resultOop1[0] = (falseObject());
				}
				else {
					resultOop1[0] = (trueObject());
				}
#        endif /* HAVE_LSTAT == 1 */
				status = 0;
	l8:	/* end isSymlink:boolean: */;
				if (status != 0) {
					return primitiveFailForOSError(status);
				}
			}
		}
	}
	if (resultOop == 0) {

		/* It shouldn't be possible to get here */
		primitiveFail();
	}
	else {
		popthenPush(3, resultOop);
	}
	return 0;
}


/*	Answer an array of file attributes.
	primFileAttributes: aString mask: attributeMask
	aString is the path to the file
	attributeMask indicates which attributes to retrieve:
	bit 0 - get stat() attributes
	bit 1 - get access() attributes
	bit 2 - use lstat() instead of stat()
	On error answer the appropriate error code (Integer) */

	/* FileAttributesPlugin>>#primitiveFileAttributes */
EXPORT(sqInt)
primitiveFileAttributes(void)
{
    sqInt attributeArray;
    sqInt attributeMask;
    char cPathName[PATH_MAX];
    sqInt fileName;
    int status;
    sqInt val;

	attributeArray = 0;
	val = 0;
	fileName = stackObjectValue(1);
	attributeMask = stackIntegerValue(0);
	if ((failed())
	 || (!(isKindOf(fileName, "String")))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	status = pathOoptoBuffermaxLen(fileName, cPathName, PATH_MAX);
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	status = fileToAttributeArraymaskarray(cPathName, attributeMask, (&attributeArray));
	if (status != 0) {
		primitiveFailForOSError(status);
	}
	else {
		popthenPush(3, attributeArray);
	}
	return 0;
}


/*	Check for existence of a file with a call to access(). */

	/* FileAttributesPlugin>>#primitiveFileExists */
EXPORT(sqInt)
primitiveFileExists(void)
{
    sqInt accessFlag;
    char cString[PATH_MAX];
    sqInt len;
    sqInt mode;
    sqInt pathString;
    char *sPtr;
    sqInt status;

	accessFlag = 0;
	pathString = stackObjectValue(0);
	if (!(isKindOf(pathString, "String"))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	/* begin checkAccess:mode:to: */
	mode = F_OK;

	/* Note: The static sized string buffer is faster than using a Smalltalk allocated
	   string as the buffer, and is unlikely to fail in practice. In the event that
	   the buffer turns out to be too small, write an error message to stdout before
	   failing. */
	len = stSizeOf(pathString);
	if (len >= PATH_MAX) {
		status = -1 /* stringTooLong */;
		goto l1;
	}
	sPtr = arrayValueOf(pathString);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		status = -3;
		goto l1;
	}
	memcpy(cString, sPtr, len);
	cString[len] = 0;
	((&accessFlag))[0] = (access(cString, mode));
	status = 0;
	l1:	/* end checkAccess:mode:to: */;
	if (!(status == 0)) {
		return primitiveFailForOSError(status);
	}
	popthenPush(2, (accessFlag == 0
		? trueObject()
		: falseObject()));
	return 0;
}


/*	Answer an array of well known file masks */

	/* FileAttributesPlugin>>#primitiveFileMasks */
EXPORT(sqInt)
primitiveFileMasks(void)
{
    sqInt masks;

	masks = instantiateClassindexableSize(classArray(), 8);
	if (!(masks)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	storePointerofObjectwithValue(0, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFMT)
		: positive32BitIntegerFor(S_IFMT)));
	
#  if !(defined(_WIN32))
	storePointerofObjectwithValue(1, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFSOCK)
		: positive32BitIntegerFor(S_IFSOCK)));
	storePointerofObjectwithValue(2, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFLNK)
		: positive32BitIntegerFor(S_IFLNK)));
#  endif /* !(defined(_WIN32)) */
	storePointerofObjectwithValue(3, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFREG)
		: positive32BitIntegerFor(S_IFREG)));
	storePointerofObjectwithValue(4, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFBLK)
		: positive32BitIntegerFor(S_IFBLK)));
	storePointerofObjectwithValue(5, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFDIR)
		: positive32BitIntegerFor(S_IFDIR)));
	storePointerofObjectwithValue(6, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFCHR)
		: positive32BitIntegerFor(S_IFCHR)));
	storePointerofObjectwithValue(7, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFIFO)
		: positive32BitIntegerFor(S_IFIFO)));
	popthenPush(1, masks);
	return 0;
}


/*	Answer the logical drive mask on windows */

	/* FileAttributesPlugin>>#primitiveLogicalDrives */
EXPORT(sqInt)
primitiveLogicalDrives(void)
{
    unsigned int mask;

	
#  if defined(_WIN32)
	mask = GetLogicalDrives();
	if (mask != 0) {
		return popthenPush(1, positive32BitIntegerFor(mask));
	}
#  endif /* defined(_WIN32) */
	primitiveFail();
	return 0;
}


/*	self primOpendir: '/etc' */

	/* FileAttributesPlugin>>#primitiveOpendir */
EXPORT(sqInt)
primitiveOpendir(void)
{
    osdir *dir;
    sqInt dirName;
    sqInt dirOop;
    int status;

	dirName = stackObjectValue(0);
	if (!(isKindOf(dirName, "String"))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	status = openDirectoryStreamptr(dirName, (&dir));
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	dirOop = addressObjectFor(dir);
	popthenPush(2, dirOop);
	return 0;
}


/*	Answer the value of PATH_MAX for the current VM */

	/* FileAttributesPlugin>>#primitivePathMax */
EXPORT(sqInt)
primitivePathMax(void)
{
	return popthenPush(1, integerObjectOf(PATH_MAX));
}


/*	Get the next entry in the directory stream. Answer the name of the entry,
	or nil for the end of the directory stream. */

	/* FileAttributesPlugin>>#primitiveReaddir */
EXPORT(sqInt)
primitiveReaddir(void)
{
    sqInt attributeArray;
    sqInt dirPointerOop;
    osdir *dirStream;
    struct dirent *ent;
    sqInt entryName;
    sqInt entry_len;
    int haveEntry;
    sqInt resultArray;
    sqInt status;
    sqInt val;

	attributeArray = 0;
	entryName = 0;
	val = 0;
	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	haveEntry = 0;
	do {
		ent = readdir((dirStream->dp));
		if (ent == NULL ||
                 		((! (ent->d_name[0] == '.' && strlen(ent->d_name) == 1)) && strcmp(ent->d_name, "..")))
                     		haveEntry = 1;
	} while(haveEntry == 0);
	if (!(ent)) {

		/* This is the normal case for the end of a directory stream,
		   although it may indicate other error conditions for which errno would be updated.
		   Assume the normal case here. */
		return popthenPush(2, nilObject());
	}
	status = byteArrayFromCStringto((ent->d_name), (&entryName));
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	entry_len = strlen((ent->d_name));
	if ((((dirStream->path_len)) + entry_len) > (PATH_MAX - 1)) {
		return primitiveFailForOSError(-1 /* stringTooLong */);
	}
	memcpy((dirStream->path_file), (ent->d_name), entry_len);
	((dirStream->path_file))[entry_len] = 0;

	/* If the stat() fails, still return the filename, just no attributes */
	status = fileToAttributeArraymaskarray((dirStream->path), 1, (&attributeArray));
	if (status != 0) {
		attributeArray = nilObject();
	}
	
#if SPURVM
	resultArray = instantiateClassindexableSize(classArray(), 2);

#else /* SPURVM */
	pushRemappableOop(entryName);
	pushRemappableOop(attributeArray);
	resultArray = instantiateClassindexableSize(classArray(), 2);
	attributeArray = popRemappableOop();
	entryName = popRemappableOop()
#endif /* SPURVM */
;
	if (!(resultArray)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	storePointerofObjectwithValue(0, resultArray, entryName);
	storePointerofObjectwithValue(1, resultArray, attributeArray);
	popthenPush(2, resultArray);
	return 0;
}


/*	Set directoryStream to first entry. Answer dirPointerOop. */

	/* FileAttributesPlugin>>#primitiveRewinddir */
EXPORT(sqInt)
primitiveRewinddir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;

	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	rewinddir((dirStream->dp));
	popthenPush(2, dirPointerOop);
	return 0;
}


/*	Answer a string containing the version string for this plugin. */

	/* FileAttributesPlugin>>#primitiveVersionString */
EXPORT(sqInt)
primitiveVersionString(void)
{
	popthenPush(1, stringFromCString("1.3.2"));
	return 0;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putLStatFor:intoBuffer:targetName: */
static sqInt
putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    char cLinkName[PATH_MAX];
    sqInt len;
    sqInt status;

	
#  if HAVE_LSTAT == 1
	status = lstat(cPathName, statBufPointer);
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	if ((S_ISLNK((statBufPointer->st_mode))) == 0) {
		fileNameOop[0] = (nilObject());
	}
	else {
		len = readLinkintomaxLength(cPathName, cLinkName, PATH_MAX);
		if (len < 0) {
			return len;
		}
		status = byteArrayFromCStringto(cLinkName, fileNameOop);
	}
#  else /* HAVE_LSTAT == 1 */

	/* #HAVE_LSTAT = 1 */
	/* begin invalidRequest */
	status = -11;
#  endif /* HAVE_LSTAT == 1 */
	return status;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putStatFor:intoBuffer:targetName: */
static sqInt
putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    sqInt status;

	status = stat(cPathName, statBufPointer);
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	fileNameOop[0] = (nilObject());
	return 0;
}


/*	Get the target filename of the supplied symbolic link. */

	/* FileAttributesPlugin>>#readLink:into:maxLength: */
static sqInt
readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength)
{
    sqInt len;


	/* len must be signed so that -1 can be communicated as an error. */
	len = 
#  if defined(_WIN32)
		-1
#  else /* defined(_WIN32) */
		readlink(cPathName, cLinkPtr, maxLength)
#  endif /* defined(_WIN32) */
		;
	if (len < 0) {
		
#    if defined(INDEBUG)
		fprintf(stderr, "FileAttributesPlugin: unable to readlink(): %d, errno=%d\n", len, errno);
#    endif /* defined(INDEBUG) */
		/* begin cantReadlink */
		return -8;
	}
	cLinkPtr[len] = 0;
	return len;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isKindOf = interpreterProxy->isKindOf;
		nilObject = interpreterProxy->nilObject;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		primitiveFailForOSError = interpreterProxy->primitiveFailForOSError;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		sizeOfSTArrayFromCPrimitive = interpreterProxy->sizeOfSTArrayFromCPrimitive;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Answer a file entry array from the supplied statBufPointer */

	/* FileAttributesPlugin>>#statArrayFor:toArray:from:fileName: */
static sqInt
statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop)
{
    sqLong attributeDate;
    sqInt sizeIfFile;
    sqInt status;

	sizeIfFile = ((S_ISDIR((statBufPointer->st_mode))) == 0
		? (statBufPointer->st_size)
		: 0);
	storePointerofObjectwithValue(0, attributeArray, fileNameOop);
	storePointerofObjectwithValue(1, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_mode))
		: positive32BitIntegerFor((statBufPointer->st_mode))));
	storePointerofObjectwithValue(2, attributeArray, positive64BitIntegerFor((statBufPointer->st_ino)));
	storePointerofObjectwithValue(3, attributeArray, positive64BitIntegerFor((statBufPointer->st_dev)));
	storePointerofObjectwithValue(4, attributeArray, positive64BitIntegerFor((statBufPointer->st_nlink)));
	storePointerofObjectwithValue(5, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_uid))
		: positive32BitIntegerFor((statBufPointer->st_uid))));
	storePointerofObjectwithValue(6, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_gid))
		: positive32BitIntegerFor((statBufPointer->st_gid))));
	storePointerofObjectwithValue(7, attributeArray, positive64BitIntegerFor(sizeIfFile));
	
#  if defined(_WIN32)
	status = winFileTimesForto(cPathName, attributeArray);
#  else /* defined(_WIN32) */
	/* begin posixFileTimesFrom:to: */
	
#  if defined(_WIN32)
#  else /* defined(_WIN32) */
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_atime));
	storePointerofObjectwithValue(8, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_mtime));
	storePointerofObjectwithValue(9, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_ctime));
	storePointerofObjectwithValue(10, attributeArray, signed64BitIntegerFor(attributeDate));
	storePointerofObjectwithValue(11, attributeArray, nilObject());
#  endif /* defined(_WIN32) */
	status = 0;
#  endif /* defined(_WIN32) */
	return status;
}


/*	Answer a new String copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#stringFromCString: */
static sqInt
stringFromCString(const char *aCString)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(classString(), len);
	if (!(newString)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	strncpy(arrayValueOf(newString), aCString, len);
	return newString;
}


/*	Populate the supplied Win32 file attribute structure */

	/* FileAttributesPlugin>>#winFileAttributesFor:length:to: */
#if _WIN32
static sqInt
winFileAttributesForlengthto(char *pathString, sqInt pathLength, WIN32_FILE_ATTRIBUTE_DATA *winAttrs)
{
    WCHAR *win32Path;

	win32Path = 0;
	ALLOC_WIN32_PATH(win32Path, pathString, pathLength);
	if ((GetFileAttributesExW(win32Path, GetFileExInfoStandard, winAttrs)) == 0) {
		/* begin getAttributesFailed */
		return -4;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Set the file creation time from the supplied attributes. */

	/* FileAttributesPlugin>>#winFileCreationTimeFor:to: */
#if _WIN32
static sqInt
winFileCreationTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *creationDate)
{
    FILETIME fileTime;
    SYSTEMTIME sysTime;

	if ((FileTimeToLocalFileTime(&winAttrs->ftCreationTime, &fileTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	if ((FileTimeToSystemTime(&fileTime, &sysTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	*creationDate = convertWinToSqueakTime(sysTime);
	return 0;
}
#endif /* _WIN32 */


/*	Set the file creation time from the supplied attributes. */

	/* FileAttributesPlugin>>#winFileLastAccessTimeFor:to: */
#if _WIN32
static sqInt
winFileLastAccessTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *accessDate)
{
    FILETIME fileTime;
    SYSTEMTIME sysTime;

	if ((FileTimeToLocalFileTime(&winAttrs->ftLastAccessTime, &fileTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	if ((FileTimeToSystemTime(&fileTime, &sysTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	*accessDate = convertWinToSqueakTime(sysTime);
	return 0;
}
#endif /* _WIN32 */


/*	Set the file write time from the supplied attributes. */

	/* FileAttributesPlugin>>#winFileLastWriteTimeFor:to: */
#if _WIN32
static sqInt
winFileLastWriteTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *writeDate)
{
    FILETIME fileTime;
    SYSTEMTIME sysTime;

	if ((FileTimeToLocalFileTime(&winAttrs->ftLastWriteTime, &fileTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	if ((FileTimeToSystemTime(&fileTime, &sysTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	*writeDate = convertWinToSqueakTime(sysTime);
	return 0;
}
#endif /* _WIN32 */

	/* FileAttributesPlugin>>#winFileTimesFor:to: */
#if _WIN32
static sqInt
winFileTimesForto(char *cPathName, sqInt attributeArray)
{
    sqLong attributeDate;
    sqInt status;
    sqInt val;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	attributeDate = 0;
	val = 0;
	status = winFileAttributesForlengthto(cPathName, strlen(cPathName), (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileLastAccessTimeForto((&winAttrs), (&attributeDate));
	if (!(status == 0)) {
		return status;
	}
	storePointerofObjectwithValue(8, attributeArray, signed64BitIntegerFor(attributeDate));
	status = winFileLastWriteTimeForto((&winAttrs), (&attributeDate));
	if (!(status == 0)) {
		return status;
	}
	storePointerofObjectwithValue(9, attributeArray, signed64BitIntegerFor(attributeDate));
	storePointerofObjectwithValue(10, attributeArray, nilObject());
	status = winFileCreationTimeForto((&winAttrs), (&attributeDate));
	if (!(status == 0)) {
		return status;
	}
	storePointerofObjectwithValue(11, attributeArray, signed64BitIntegerFor(attributeDate));
	return 0;
}
#endif /* _WIN32 */


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "FileAttributesPlugin";
void* FileAttributesPlugin_exports[][3] = {
	{(void*)_m, "checkAccessmodeto", (void*)checkAccessmodeto},
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveClosedir\000\001", (void*)primitiveClosedir},
	{(void*)_m, "primitiveFileAttribute\000\001", (void*)primitiveFileAttribute},
	{(void*)_m, "primitiveFileAttributes\000\001", (void*)primitiveFileAttributes},
	{(void*)_m, "primitiveFileExists\000\001", (void*)primitiveFileExists},
	{(void*)_m, "primitiveFileMasks\000\377", (void*)primitiveFileMasks},
	{(void*)_m, "primitiveLogicalDrives\000\377", (void*)primitiveLogicalDrives},
	{(void*)_m, "primitiveOpendir\000\002", (void*)primitiveOpendir},
	{(void*)_m, "primitivePathMax\000\377", (void*)primitivePathMax},
	{(void*)_m, "primitiveReaddir\000\001", (void*)primitiveReaddir},
	{(void*)_m, "primitiveRewinddir\000\001", (void*)primitiveRewinddir},
	{(void*)_m, "primitiveVersionString\000\377", (void*)primitiveVersionString},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveClosedirAccessorDepth = 1;
signed char primitiveFileAttributeAccessorDepth = 1;
signed char primitiveFileAttributesAccessorDepth = 1;
signed char primitiveFileExistsAccessorDepth = 1;
signed char primitiveOpendirAccessorDepth = 2;
signed char primitiveReaddirAccessorDepth = 1;
signed char primitiveRewinddirAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
