/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-AlistairGrant.2426 uuid: f47080d3-d374-4ae7-a639-8eb41af95f0e
   from
	FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.32 uuid: 1d7a551c-3693-4180-8701-f2cac782d518
 */
static char __buildInfo[] = "FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.32 uuid: 1d7a551c-3693-4180-8701-f2cac782d518 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <limits.h>
#include <sys/types.h>
#include <dirent.h>
#ifdef _WIN32
#include <windows.h>
#include <winbase.h>
#define FAIL() { return -1; }
#include "sqWin32File.h"
#else
#include "sqUnixCharConv.h"
#endif
typedef struct dirptrstruct {
    		DIR *dp;
		int path_len;
    		char *path_file;
   		char path[PATH_MAX+4];
    		} osdir;
#include <sys/stat.h>
#if !defined(HAVE_LSTAT) && !defined(_WIN32)
#define HAVE_LSTAT 1
#endif
#include <unistd.h>
/* AKG 2017 - FileAttributesPlugin.c translated from class FileAttributesPlugin */

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrNoMemory 9


/*** Function Prototypes ***/
static sqInt accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset);
static sqInt addressObjectFor(void *aMachineAddress);
static sqInt byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop);
static sqInt canOpenDirectoryStreamForlength(char *aPathCString, sqInt length);
static sqInt canStatFilePathlength(char *aPathCString, sqInt length);
#if _WIN32
static sqLong convertWinToSqueakTime(SYSTEMTIME st);
#endif /* _WIN32 */
static sqLong faConvertUnixToLongSqueakTime(time_t unixTime);
#if _WIN32
static sqInt fileCreationTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt fileLastAccessTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt fileLastWriteTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate);
#endif /* _WIN32 */
static int fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray);
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt isSymlinkboolean(char *cPathName, sqInt *resultOop);
static int openDirectoryStreamptr(char *cPathName, osdir **osdirPtr);
static int pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen);
static void * pointerFrom(sqInt directoryPointerBytes);
static sqInt posixFileTimesFromto(struct stat *statBufPointer, sqInt attributeArray);
EXPORT(sqInt) primitiveClosedir(void);
EXPORT(sqInt) primitiveFileAttribute(void);
EXPORT(sqInt) primitiveFileAttributes(void);
EXPORT(sqInt) primitiveFileExists(void);
EXPORT(sqInt) primitiveFileMasks(void);
EXPORT(sqInt) primitiveLogicalDrives(void);
EXPORT(sqInt) primitiveOpendir(void);
EXPORT(sqInt) primitivePathMax(void);
EXPORT(sqInt) primitiveReaddir(void);
EXPORT(sqInt) primitiveRewinddir(void);
EXPORT(sqInt) primitiveVersionString(void);
static sqInt putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop);
static sqInt readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt squeakPathtoUnixmaxLen(sqInt pathOop, char *cPathString, sqInt maxLength);
static sqInt statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop);
static sqInt stringFromCString(const char *aCString);
static sqInt unixPathToOop(char *cPathString);
#if _WIN32
static sqInt winFileAttributesForlengthto(char *pathString, sqInt pathLength, WIN32_FILE_ATTRIBUTE_DATA *winAttrs);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileCreationTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *creationDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileLastAccessTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *accessDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileLastWriteTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *writeDate);
#endif /* _WIN32 */
#if _WIN32
static sqInt winFileTimesForto(char *cPathName, sqInt attributeArray);
#endif /* _WIN32 */


/*** Variables ***/
static int hasSecurityPlugin = 1;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*classArray)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*nilObject)(void);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*primitiveFailForOSError)(sqLong osError);
static sqInt (*primitiveFailureCode)(void);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signed64BitIntegerFor)(sqLong integerValue);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt classArray(void);
extern sqInt classByteArray(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt nilObject(void);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailForOSError(sqLong osError);
extern sqInt primitiveFailureCode(void);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.32 (i)"
#else
	"FileAttributesPlugin * FileAttributesPlugin.oscog-AlistairGrant.32 (e)"
#endif
;
static void * sCLPfn;
static void * sCOFfn;



/*	Call access() for each access type (R, W, X) on the c string cPathName,
	storing the results in the st array attributeArray.
 */

	/* FileAttributesPlugin>>#accessAttributesForFilename:into:startingAt: */
static sqInt
accessAttributesForFilenameintostartingAt(char *cPathName, sqInt attributeArray, sqInt offset)
{
    sqInt boolean;
    sqInt index;

	index = offset;
	if ((access(cPathName, R_OK)) == 0) {
		boolean = trueObject();
	}
	else {
		boolean = falseObject();
	}
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	boolean = ((access(cPathName, W_OK)) == 0
		? trueObject()
		: falseObject());
	storePointerofObjectwithValue(index, attributeArray, boolean);
	index += 1;
	boolean = ((access(cPathName, X_OK)) == 0
		? trueObject()
		: falseObject());
	storePointerofObjectwithValue(index, attributeArray, boolean);
	return 0;
}


/*	Answer an ExternalAddress object which represents aMachineAddress */

	/* FileAttributesPlugin>>#addressObjectFor: */
static sqInt
addressObjectFor(void *aMachineAddress)
{
    sqInt addressOop;
    unsigned char *addressOopArrayPointer;
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;

	addressOop = instantiateClassindexableSize(classByteArray(), sizeof(void *));
	if (!(addressOop)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	addressOopArrayPointer = arrayValueOf(addressOop);
	addressUnion.address = aMachineAddress;
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressOopArrayPointer[idx] = addressUnion.bytes[idx];
		idx += 1;
	}
	return addressOop;
}


/*	Answer a new ByteArray copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#byteArrayFromCString:to: */
static sqInt
byteArrayFromCStringto(const char *aCString, sqInt *byteArrayOop)
{
    unsigned char *byteArrayPtr;
    sqInt len;
    sqInt newByteArray;


	/* We never return strings longer than PATH_MAX */
	len = strlen(aCString);
	if (len > PATH_MAX) {
		return -1 /* stringTooLong */;
	}
	newByteArray = instantiateClassindexableSize(classByteArray(), len);
	if (!(newByteArray)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	byteArrayPtr = arrayValueOf(newByteArray);
	memcpy(byteArrayPtr, aCString, len);
	byteArrayOop[0] = newByteArray;
	return 0;
}


/*	Answer non-zero if security permits the directory to be listed. */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
/*	The hasSecurityPlugin flag is set to 1 by default */

	/* FileAttributesPlugin>>#canOpenDirectoryStreamFor:length: */
static sqInt
canOpenDirectoryStreamForlength(char *aPathCString, sqInt length)
{
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	if (sCLPfn != 0) {
		return  ((int (*) (char *, int)) sCLPfn)(aPathCString, length);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Answer non-zero if security permits the a stat() call on the file path.
	Allow a
	stat() call only on files which we are permitted to open.
 */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check . 
	If not, assume it's ok */
/*	The hasSecurityPlugin flag is set to 1 by default */

	/* FileAttributesPlugin>>#canStatFilePath:length: */
static sqInt
canStatFilePathlength(char *aPathCString, sqInt length)
{
	if (hasSecurityPlugin == 0) {
		return 1;
	}
	if (sCOFfn != 0) {
		return  ((int (*) (char *, int, int)) sCOFfn)(aPathCString, length, 0);
	}
	else {

		/* Reset the flag so we do not try again next time */
		hasSecurityPlugin = 0;
		return 1;
	}
}


/*	Convert the supplied Windows SYSTEMTIME to Squeak time */

	/* FileAttributesPlugin>>#convertWinToSqueakTime: */
#if _WIN32
static sqLong
convertWinToSqueakTime(SYSTEMTIME st)
{
    sqLong dy;
    static sqLong nDaysPerMonth[14] = { 
		0,  0,  31,  59,  90, 120, 151,
		181, 212, 243, 273, 304, 334, 365 };
    sqLong secs;

	dy = (st.wYear) - 1901;

	/* base seconds */
	/* seconds of leap years */
	/* check if month > 2 and current year is a leap year */
	secs = ((((dy * 365) * 24) * 60) * 60) + ((((((usqInt) dy >> 2)) * 24) * 60) * 60);
	if (((st.wMonth) > 2)
	 && ((dy & 3) == 3)) {

		/* add one day */
		secs += (24 * 60) * 60;
	}

	/* add the hours, minutes, and seconds */
	secs += (nDaysPerMonth[st.wMonth] + st.wDay - 1) * 24 * 60 * 60;
	secs += st.wSecond + 60*(st.wMinute + 60*st.wHour);
	return secs;
}
#endif /* _WIN32 */


/*	Convert the supplied Unix (UTC) time to Squeak time.
	
	Squeak time has an epoch of 1901 and uses local time
	i.e. timezone + daylight savings
	
	Answer an sqLong which is guaranteed to be 64 bits on all platforms.
 */

	/* FileAttributesPlugin>>#faConvertUnixToLongSqueakTime: */
static sqLong
faConvertUnixToLongSqueakTime(time_t unixTime)
{
    sqLong squeakTime;

	
#  if defined(_WIN32)
	squeakTime = 0;
#  else /* defined(_WIN32) */
	squeakTime = unixTime;
	
#  if defined(HAVE_TM_GMTOFF)
	squeakTime += localtime(&unixTime)->tm_gmtoff;
#  else /* defined(HAVE_TM_GMTOFF) */
	
#  if defined(HAVE_TIMEZONE)
	squeakTime += (daylight*60*60) - timezone;
#  else /* defined(HAVE_TIMEZONE) */
	
#error: cannot determine timezone correction
#  endif /* defined(HAVE_TIMEZONE) */
#  endif /* defined(HAVE_TM_GMTOFF) */
	squeakTime += (52*365UL + 17*366UL) * 24*60*60UL;
#  endif /* defined(_WIN32) */
	return squeakTime;
}


/*	Get the creationDate for the supplied file. */

	/* FileAttributesPlugin>>#fileCreationTimeFor:length:to: */
#if _WIN32
static sqInt
fileCreationTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate)
{
    sqInt status;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	status = winFileAttributesForlengthto(pathString, pathLength, (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileCreationTimeForto((&winAttrs), creationDate);
	if (!(status == 0)) {
		return status;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Get the creationDate for the supplied file. */

	/* FileAttributesPlugin>>#fileLastAccessTimeFor:length:to: */
#if _WIN32
static sqInt
fileLastAccessTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate)
{
    sqInt status;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	status = winFileAttributesForlengthto(pathString, pathLength, (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileLastAccessTimeForto((&winAttrs), creationDate);
	if (!(status == 0)) {
		return status;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Get the creationDate for the supplied file. */

	/* FileAttributesPlugin>>#fileLastWriteTimeFor:length:to: */
#if _WIN32
static sqInt
fileLastWriteTimeForlengthto(char *pathString, sqInt pathLength, sqLong *creationDate)
{
    sqInt status;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	status = winFileAttributesForlengthto(pathString, pathLength, (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileLastWriteTimeForto((&winAttrs), creationDate);
	if (!(status == 0)) {
		return status;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Answer a file attribute array from pathNameOop. */

	/* FileAttributesPlugin>>#fileToAttributeArray:mask:array: */
static int
fileToAttributeArraymaskarray(char *cPathName, sqInt attributeMask, sqInt *attributeArray)
{
    sqInt accessArray;
    sqLong attributeDate;
    sqInt boolean;
    char cLinkName[PATH_MAX];
    sqInt combinedArray;
    sqInt fileNameOop;
    int getAccess;
    int getStats;
    sqInt index;
    sqInt len;
    sqInt sizeIfFile;
    sqInt statArray;
    struct stat statBuf;
    struct stat *statBufPointer;
    struct stat *statBufPointer1;
    struct stat *statBufPointer2;
    sqInt status;
    sqInt status1;
    sqInt status2;
    sqInt status3;
    int useLstat;


	/* Determine which attributes to retrieve */
	accessArray = 0;
	fileNameOop = 0;
	statArray = 0;
	getStats = attributeMask & 1;
	getAccess = attributeMask & 2;
	if (!(getStats
		 || (getAccess))) {

		/* No information has been requested, which doesn't make sense */
		return -6 /* invalidArguments */;
	}
	if (getStats) {
		useLstat = attributeMask & 4;
		statArray = instantiateClassindexableSize(classArray(), 12);
		if (!(statArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		if (useLstat) {
			/* begin putLStatFor:intoBuffer:targetName: */
			statBufPointer2 = ((struct stat *) ((&statBuf)));
			
#      if HAVE_LSTAT == 1
			status3 = lstat(cPathName, statBufPointer2);
			if (status3 != 0) {
				/* begin cantStatPath */
				status = -3;
				goto l5;
			}
			if ((S_ISLNK((statBufPointer2->st_mode))) == 0) {
				((&fileNameOop))[0] = (nilObject());
			}
			else {
				len = readLinkintomaxLength(cPathName, cLinkName, PATH_MAX);
				if (len < 0) {
					status = len;
					goto l5;
				}
				status3 = byteArrayFromCStringto(cLinkName, (&fileNameOop));
			}
#      else /* HAVE_LSTAT == 1 */

			/* #HAVE_LSTAT = 1 */
			/* begin invalidRequest */
			status3 = -11;
#      endif /* HAVE_LSTAT == 1 */
			status = status3;
	l5:	/* end putLStatFor:intoBuffer:targetName: */;
		}
		else {
			/* begin putStatFor:intoBuffer:targetName: */
			statBufPointer = ((struct stat *) ((&statBuf)));
			status1 = stat(cPathName, statBufPointer);
			if (status1 != 0) {
				/* begin cantStatPath */
				status = -3;
				goto l1;
			}
			((&fileNameOop))[0] = (nilObject());
			status = 0;
	l1:	/* end putStatFor:intoBuffer:targetName: */;
		}
		if (status != 0) {
			return status;
		}
		/* begin statArrayFor:toArray:from:fileName: */
		statBufPointer1 = ((struct stat *) ((&statBuf)));
		sizeIfFile = ((S_ISDIR((statBufPointer1->st_mode))) == 0
			? (statBufPointer1->st_size)
			: 0);
		storePointerofObjectwithValue(0, statArray, fileNameOop);
		storePointerofObjectwithValue(1, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_mode))
			: positive32BitIntegerFor((statBufPointer1->st_mode))));
		storePointerofObjectwithValue(2, statArray, positive64BitIntegerFor((statBufPointer1->st_ino)));
		storePointerofObjectwithValue(3, statArray, positive64BitIntegerFor((statBufPointer1->st_dev)));
		storePointerofObjectwithValue(4, statArray, positive64BitIntegerFor((statBufPointer1->st_nlink)));
		storePointerofObjectwithValue(5, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_uid))
			: positive32BitIntegerFor((statBufPointer1->st_uid))));
		storePointerofObjectwithValue(6, statArray, (BytesPerWord == 8
			? positive64BitIntegerFor((statBufPointer1->st_gid))
			: positive32BitIntegerFor((statBufPointer1->st_gid))));
		storePointerofObjectwithValue(7, statArray, positive64BitIntegerFor(sizeIfFile));
		
#    if defined(_WIN32)
		status2 = winFileTimesForto(cPathName, statArray);
#    else /* defined(_WIN32) */
		/* begin posixFileTimesFrom:to: */
		
#    if defined(_WIN32)
#    else /* defined(_WIN32) */
		attributeDate = faConvertUnixToLongSqueakTime((statBufPointer1->st_atime));
		storePointerofObjectwithValue(8, statArray, signed64BitIntegerFor(attributeDate));
		attributeDate = faConvertUnixToLongSqueakTime((statBufPointer1->st_mtime));
		storePointerofObjectwithValue(9, statArray, signed64BitIntegerFor(attributeDate));
		attributeDate = faConvertUnixToLongSqueakTime((statBufPointer1->st_ctime));
		storePointerofObjectwithValue(10, statArray, signed64BitIntegerFor(attributeDate));
		storePointerofObjectwithValue(11, statArray, nilObject());
#    endif /* defined(_WIN32) */
		status2 = 0;
#    endif /* defined(_WIN32) */
		status = status2;
		if (status != 0) {
			return status;
		}
		attributeArray[0] = statArray;
	}
	if (getAccess) {
		accessArray = instantiateClassindexableSize(classArray(), 3);
		if (!(accessArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		/* begin accessAttributesForFilename:into:startingAt: */
		index = 0;
		if ((access(cPathName, R_OK)) == 0) {
			boolean = trueObject();
		}
		else {
			boolean = falseObject();
		}
		storePointerofObjectwithValue(index, accessArray, boolean);
		index += 1;
		boolean = ((access(cPathName, W_OK)) == 0
			? trueObject()
			: falseObject());
		storePointerofObjectwithValue(index, accessArray, boolean);
		index += 1;
		boolean = ((access(cPathName, X_OK)) == 0
			? trueObject()
			: falseObject());
		storePointerofObjectwithValue(index, accessArray, boolean);
		attributeArray[0] = accessArray;
	}
	if (getStats
	 && (getAccess)) {
		combinedArray = instantiateClassindexableSize(classArray(), 2);
		if (!(combinedArray)) {
			return primitiveFailFor(PrimErrNoMemory);
		}
		attributeArray[0] = combinedArray;
		storePointerofObjectwithValue(0, combinedArray, statArray);
		storePointerofObjectwithValue(1, combinedArray, accessArray);
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* FileAttributesPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	sCOFfn = ioLoadFunctionFrom("secCanOpenFileOfSizeWritable", "SecurityPlugin");
	sCLPfn = ioLoadFunctionFrom("secCanListPathOfSize", "SecurityPlugin");
	return 1;
}


/*	Set resultOop to a boolean indicating whether cPathName is a symbolic
	link. Answer status (0 = success) */

	/* FileAttributesPlugin>>#isSymlink:boolean: */
static sqInt
isSymlinkboolean(char *cPathName, sqInt *resultOop)
{
    struct stat statBuf;
    sqInt status;

	
#  if HAVE_LSTAT == 1
	status = lstat(cPathName, (&statBuf));
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	if ((S_ISLNK((statBuf.st_mode))) == 0) {
		resultOop[0] = (falseObject());
	}
	else {
		resultOop[0] = (trueObject());
	}
#  endif /* HAVE_LSTAT == 1 */
	return 0;
}


/*	Open a new directory stream. Answer a pointer to the directory stream or
	NULL. 
 */

	/* FileAttributesPlugin>>#openDirectoryStream:ptr: */
static int
openDirectoryStreamptr(char *cPathName, osdir **osdirPtr)
{
    osdir *dir;
    sqInt len;


	/* The path buffer needs room for a trailing slash and the file name, so subtracting 2 is conservative */
	len = strlen(cPathName);
	if (len > (PATH_MAX - 2)) {
		return -1 /* stringTooLong */;
	}
	if (canOpenDirectoryStreamForlength(cPathName, len)) {
		dir = (osdir *) malloc(sizeof(osdir));
		if (dir == null) {
			/* begin cantAllocateMemory */
			return ((sqInt) -10);
		}
		memcpy((dir->path), cPathName, len);
		if (dir->path[len-1] != '/') {
				dir->path[len++] = '/';
				}
		dir->path_file = dir->path + len;
		dir->path_file[0] = '\0';
		dir->path_len = len;
		dir->dp =  opendir(dir->path);
		if (!((dir->dp))) {
			free(dir);
			/* begin cantOpenDir */
			return ((sqInt) -9);
		}
		osdirPtr[0] = dir;
		return 0;
	}
	/* begin cantOpenDir */
	return ((sqInt) -9);
}


/*	Copy the supplied path name string object to the supplied c string buffer */

	/* FileAttributesPlugin>>#pathOop:toBuffer:maxLen: */
static int
pathOoptoBuffermaxLen(sqInt pathNameOop, char *cPathName, sqInt maxLen)
{
    sqInt len;
    char *sPtr;

	len = stSizeOf(pathNameOop);
	if (len >= maxLen) {
		return -1 /* stringTooLong */;
	}
	sPtr = arrayValueOf(pathNameOop);
	if ((canStatFilePathlength(sPtr, len)) == 0) {
		/* begin cantStatPath */
		return ((sqInt) -3);
	}
	memcpy(cPathName, sPtr, len);
	cPathName[len] = 0;
	return 0;
}


/*	Answer the machine address contained in anExternalAddressOop. */

	/* FileAttributesPlugin>>#pointerFrom: */
static void *
pointerFrom(sqInt directoryPointerBytes)
{
    union {void *address; unsigned char bytes[sizeof(void *)];} addressUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((isKindOf(directoryPointerBytes, "ByteArray"))
		 && ((stSizeOf(directoryPointerBytes)) == (sizeof(void *))))) {
		return null;
	}
	ptr = arrayValueOf(directoryPointerBytes);
	idx = 0;
	while (idx < (sizeof(void *))) {
		addressUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return addressUnion.address;
}


/*	Populate attributeArray with the file times from statBufPointer */

	/* FileAttributesPlugin>>#posixFileTimesFrom:to: */
static sqInt
posixFileTimesFromto(struct stat *statBufPointer, sqInt attributeArray)
{
    sqLong attributeDate;

	
#  if defined(_WIN32)
#  else /* defined(_WIN32) */
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_atime));
	storePointerofObjectwithValue(8, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_mtime));
	storePointerofObjectwithValue(9, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_ctime));
	storePointerofObjectwithValue(10, attributeArray, signed64BitIntegerFor(attributeDate));
	storePointerofObjectwithValue(11, attributeArray, nilObject());
#  endif /* defined(_WIN32) */
	return 0;
}


/*	Close the directory stream for dirPointerOop. Answer dirPointerOop on
	success. Raise PrimErrBadArgument if the parameter is not a ByteArray
	length size(void *).
	If closedir() returns an error raise PrimitiveOSError.
 */

	/* FileAttributesPlugin>>#primitiveClosedir */
EXPORT(sqInt)
primitiveClosedir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;
    sqInt result;

	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	result = closedir((dirStream->dp));
	if (!(result == 0)) {
		return primitiveFailForOSError(-12 /* unableToCloseDir */);
	}
	free(dirStream);
	popthenPush(2, dirPointerOop);
	return 0;
}


/*	Answer a single file attribute.
	primFileAttributes: aString attributeNumber: attributeNumber
	aString is the path to the file
	attributeNumber identifies which attribute to return:
	1 - 12: stat(): name, mode, ino, dev, nlink, uid, gid, size, accessDate,
	modifiedDate, changeDate, creationDate
	13 - 15: access(): R_OK, W_OK, X_OK
	16: isSymlink
	On error, answer a single element array containing the appropriate error
	code. 
 */

	/* FileAttributesPlugin>>#primitiveFileAttribute */
EXPORT(sqInt)
primitiveFileAttribute(void)
{
    sqLong attributeDate;
    sqInt attributeNumber;
    char cPathName[PATH_MAX+1];
    sqInt fileName;
    sqInt fileNameOop;
    sqInt mode;
    sqInt resultOop;
    sqInt *resultOop1;
    sqInt sizeIfFile;
    struct stat statBuf;
    struct stat statBuf1;
    struct stat *statBufPointer;
    sqInt status;
    sqInt status1;
    sqInt status2;
    sqInt val;
    usqIntptr_t value;
    usqIntptr_t value1;
    usqIntptr_t value2;

	attributeDate = 0;
	fileNameOop = 0;
	mode = 0;
	val = 0;
	fileName = stackObjectValue(1);
	attributeNumber = stackIntegerValue(0);
	if ((failed())
	 || ((!(((attributeNumber >= 1) && (attributeNumber <= 16))))
	 || (!(isKindOf(fileName, "String"))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	squeakPathtoUnixmaxLen(fileName, cPathName, PATH_MAX);
	if (failed()) {
		return primitiveFailureCode();
	}
	resultOop = 0;
	if (attributeNumber < 12) {

		/* Get requested stat entry */
		/* begin putStatFor:intoBuffer:targetName: */
		statBufPointer = ((struct stat *) ((&statBuf)));
		status2 = stat(cPathName, statBufPointer);
		if (status2 != 0) {
			/* begin cantStatPath */
			status = -3;
			goto l9;
		}
		((&fileNameOop))[0] = (nilObject());
		status = 0;
	l9:	/* end putStatFor:intoBuffer:targetName: */;
		if (status != 0) {
			return primitiveFailForOSError(status);
		}
		if (attributeNumber == 1) {
			resultOop = fileNameOop;
		}
		if (attributeNumber == 2) {
			/* begin positiveMachineIntegerFor: */
			value = (statBuf.st_mode);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value)
				: positive32BitIntegerFor(value));
		}
		if (attributeNumber == 3) {
			resultOop = positive64BitIntegerFor((statBuf.st_ino));
		}
		if (attributeNumber == 4) {
			resultOop = positive64BitIntegerFor((statBuf.st_dev));
		}
		if (attributeNumber == 5) {
			resultOop = positive64BitIntegerFor((statBuf.st_nlink));
		}
		if (attributeNumber == 6) {
			/* begin positiveMachineIntegerFor: */
			value1 = (statBuf.st_uid);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value1)
				: positive32BitIntegerFor(value1));
		}
		if (attributeNumber == 7) {
			/* begin positiveMachineIntegerFor: */
			value2 = (statBuf.st_gid);
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(value2)
				: positive32BitIntegerFor(value2));
		}
		if (attributeNumber == 8) {
			sizeIfFile = ((S_ISDIR((statBuf.st_mode))) == 0
				? (statBuf.st_size)
				: 0);
			/* begin positiveMachineIntegerFor: */
			resultOop = (BytesPerWord == 8
				? positive64BitIntegerFor(sizeIfFile)
				: positive32BitIntegerFor(sizeIfFile));
		}
		if (attributeNumber == 9) {

			/* Access Time */
			
#      if defined(_WIN32)
			status = fileLastAccessTimeForlengthto(cPathName, strlen(cPathName), (&attributeDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			resultOop = signed64BitIntegerFor(attributeDate);
#      else /* defined(_WIN32) */
			attributeDate = faConvertUnixToLongSqueakTime((statBuf.st_atime));
			resultOop = signed64BitIntegerFor(attributeDate);
#      endif /* defined(_WIN32) */
		}
		if (attributeNumber == 10) {

			/* Modified Time */
			
#      if defined(_WIN32)
			status = fileLastWriteTimeForlengthto(cPathName, strlen(cPathName), (&attributeDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			resultOop = signed64BitIntegerFor(attributeDate);
#      else /* defined(_WIN32) */
			attributeDate = faConvertUnixToLongSqueakTime((statBuf.st_mtime));
			resultOop = signed64BitIntegerFor(attributeDate);
#      endif /* defined(_WIN32) */
		}
		if (attributeNumber == 11) {

			/* Change Time */
			
#      if defined(_WIN32)
			resultOop = nilObject();
#      else /* defined(_WIN32) */
			attributeDate = faConvertUnixToLongSqueakTime((statBuf.st_ctime));
			resultOop = signed64BitIntegerFor(attributeDate);
#      endif /* defined(_WIN32) */
		}
	}
	else {
		if (attributeNumber == 12) {

			/* Creation Time */
			
#      if defined(_WIN32)
			status = fileCreationTimeForlengthto(cPathName, strlen(cPathName), (&attributeDate));
			if (status != 0) {
				return primitiveFailForOSError(status);
			}
			resultOop = signed64BitIntegerFor(attributeDate);
#      else /* defined(_WIN32) */
			resultOop = nilObject();
#      endif /* defined(_WIN32) */
		}
		else {
			if (attributeNumber < 16) {

				/* Get requested access entry */
				if (attributeNumber == 13) {
					/* begin fileReadableFlag */
					mode = R_OK;
				}
				if (attributeNumber == 14) {
					/* begin fileWriteableFlag */
					mode = W_OK;
				}
				if (attributeNumber == 15) {
					/* begin fileExecutableFlag */
					mode = X_OK;
				}
				resultOop = ((access(cPathName, mode)) == 0
					? trueObject()
					: falseObject());
			}
			else {

				/* attributeNumber = 16, #isSymlink */
				/* begin isSymlink:boolean: */
				resultOop1 = ((sqInt *) ((&resultOop)));
				
#        if HAVE_LSTAT == 1
				status1 = lstat(cPathName, (&statBuf1));
				if (status1 != 0) {
					/* begin cantStatPath */
					status = -3;
					goto l8;
				}
				if ((S_ISLNK((statBuf1.st_mode))) == 0) {
					resultOop1[0] = (falseObject());
				}
				else {
					resultOop1[0] = (trueObject());
				}
#        endif /* HAVE_LSTAT == 1 */
				status = 0;
	l8:	/* end isSymlink:boolean: */;
				if (status != 0) {
					return primitiveFailForOSError(status);
				}
			}
		}
	}
	if (resultOop == 0) {

		/* It shouldn't be possible to get here */
		primitiveFail();
	}
	else {
		popthenPush(3, resultOop);
	}
	return 0;
}


/*	Answer an array of file attributes.
	primFileAttributes: aString mask: attributeMask
	aString is the path to the file
	attributeMask indicates which attributes to retrieve:
	bit 0 - get stat() attributes
	bit 1 - get access() attributes
	bit 2 - use lstat() instead of stat()
	On error answer the appropriate error code (Integer) */

	/* FileAttributesPlugin>>#primitiveFileAttributes */
EXPORT(sqInt)
primitiveFileAttributes(void)
{
    sqInt attributeArray;
    sqInt attributeMask;
    char cPathName[PATH_MAX+1];
    sqInt fileName;
    int status;
    sqInt val;

	attributeArray = 0;
	val = 0;
	fileName = stackObjectValue(1);
	attributeMask = stackIntegerValue(0);
	if ((failed())
	 || (!(isKindOf(fileName, "String")))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	squeakPathtoUnixmaxLen(fileName, cPathName, PATH_MAX);
	if (failed()) {
		return primitiveFailureCode();
	}
	status = fileToAttributeArraymaskarray(cPathName, attributeMask, (&attributeArray));
	if (status != 0) {
		primitiveFailForOSError(status);
	}
	else {
		popthenPush(3, attributeArray);
	}
	return 0;
}


/*	Check for existence of a file with a call to access(). */

	/* FileAttributesPlugin>>#primitiveFileExists */
EXPORT(sqInt)
primitiveFileExists(void)
{
    sqInt accessFlag;
    char cString[PATH_MAX+1];
    sqInt fileNameOop;

	fileNameOop = stackObjectValue(0);
	if (!(isKindOf(fileNameOop, "String"))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	squeakPathtoUnixmaxLen(fileNameOop, cString, PATH_MAX);
	if (failed()) {
		return primitiveFailureCode();
	}
	accessFlag = access(cString, F_OK);
	popthenPush(2, (accessFlag == 0
		? trueObject()
		: falseObject()));
	return 0;
}


/*	Answer an array of well known file masks */

	/* FileAttributesPlugin>>#primitiveFileMasks */
EXPORT(sqInt)
primitiveFileMasks(void)
{
    sqInt masks;

	masks = instantiateClassindexableSize(classArray(), 8);
	if (!(masks)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	storePointerofObjectwithValue(0, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFMT)
		: positive32BitIntegerFor(S_IFMT)));
	
#  if !(defined(_WIN32))
	storePointerofObjectwithValue(1, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFSOCK)
		: positive32BitIntegerFor(S_IFSOCK)));
	storePointerofObjectwithValue(2, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFLNK)
		: positive32BitIntegerFor(S_IFLNK)));
#  endif /* !(defined(_WIN32)) */
	storePointerofObjectwithValue(3, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFREG)
		: positive32BitIntegerFor(S_IFREG)));
	storePointerofObjectwithValue(4, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFBLK)
		: positive32BitIntegerFor(S_IFBLK)));
	storePointerofObjectwithValue(5, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFDIR)
		: positive32BitIntegerFor(S_IFDIR)));
	storePointerofObjectwithValue(6, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFCHR)
		: positive32BitIntegerFor(S_IFCHR)));
	storePointerofObjectwithValue(7, masks, (BytesPerWord == 8
		? positive64BitIntegerFor(S_IFIFO)
		: positive32BitIntegerFor(S_IFIFO)));
	popthenPush(1, masks);
	return 0;
}


/*	Answer the logical drive mask on windows */

	/* FileAttributesPlugin>>#primitiveLogicalDrives */
EXPORT(sqInt)
primitiveLogicalDrives(void)
{
    unsigned int mask;

	
#  if defined(_WIN32)
	mask = GetLogicalDrives();
	if (mask != 0) {
		return popthenPush(1, positive32BitIntegerFor(mask));
	}
#  endif /* defined(_WIN32) */
	primitiveFail();
	return 0;
}


/*	self primOpendir: '/etc' */

	/* FileAttributesPlugin>>#primitiveOpendir */
EXPORT(sqInt)
primitiveOpendir(void)
{
    char cPathName[PATH_MAX+1];
    osdir *dir;
    sqInt dirName;
    sqInt dirOop;
    int status;

	dirName = stackObjectValue(0);
	if (!(isKindOf(dirName, "String"))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	squeakPathtoUnixmaxLen(dirName, cPathName, PATH_MAX);
	if (failed()) {
		return primitiveFailureCode();
	}
	status = openDirectoryStreamptr(cPathName, (&dir));
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	dirOop = addressObjectFor(dir);
	popthenPush(2, dirOop);
	return 0;
}


/*	Answer the value of PATH_MAX for the current VM */

	/* FileAttributesPlugin>>#primitivePathMax */
EXPORT(sqInt)
primitivePathMax(void)
{
	return popthenPush(1, integerObjectOf(PATH_MAX));
}


/*	Get the next entry in the directory stream. Answer the name of the entry,
	or nil for the end of the directory stream.
	Arguments:
	- directoryPointer (ByteArray) */

	/* FileAttributesPlugin>>#primitiveReaddir */
EXPORT(sqInt)
primitiveReaddir(void)
{
    sqInt attributeArray;
    sqInt dirPointerOop;
    osdir *dirStream;
    struct dirent *ent;
    sqInt entryName;
    sqInt entry_len;
    int haveEntry;
    sqInt resultArray;
    int status;
    sqInt val;

	attributeArray = 0;
	val = 0;
	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	haveEntry = 0;
	do {
		ent = readdir((dirStream->dp));
		if (ent == NULL ||
                 		((! (ent->d_name[0] == '.' && strlen(ent->d_name) == 1)) && strcmp(ent->d_name, "..")))
                     		haveEntry = 1;
	} while(haveEntry == 0);
	if (!(ent)) {

		/* This is the normal case for the end of a directory stream,
		   although it may indicate other error conditions for which errno would be updated.
		   Assume the normal case here. */
		return popthenPush(2, nilObject());
	}

	/* Build the path name (append the entry name to the path name) */
	entryName = unixPathToOop((ent->d_name));
	entry_len = strlen((ent->d_name));
	if ((((dirStream->path_len)) + entry_len) > (PATH_MAX - 1)) {
		return primitiveFailForOSError(-1 /* stringTooLong */);
	}
	memcpy((dirStream->path_file), (ent->d_name), entry_len);
	((dirStream->path_file))[entry_len] = 0;

	/* If the stat() fails, still return the filename, just no attributes */
	status = fileToAttributeArraymaskarray((dirStream->path), 1, (&attributeArray));
	if (status != 0) {
		attributeArray = nilObject();
	}
	
#if SPURVM
	resultArray = instantiateClassindexableSize(classArray(), 2);

#else /* SPURVM */
	pushRemappableOop(entryName);
	pushRemappableOop(attributeArray);
	resultArray = instantiateClassindexableSize(classArray(), 2);
	attributeArray = popRemappableOop();
	entryName = popRemappableOop()
#endif /* SPURVM */
;
	if (!(resultArray)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	storePointerofObjectwithValue(0, resultArray, entryName);
	storePointerofObjectwithValue(1, resultArray, attributeArray);
	popthenPush(2, resultArray);
	return 0;
}


/*	Set directoryStream to first entry. Answer dirPointerOop. */

	/* FileAttributesPlugin>>#primitiveRewinddir */
EXPORT(sqInt)
primitiveRewinddir(void)
{
    sqInt dirPointerOop;
    osdir *dirStream;

	dirPointerOop = stackValue(0);
	dirStream = pointerFrom(dirPointerOop);
	if (!(dirStream)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	rewinddir((dirStream->dp));
	popthenPush(2, dirPointerOop);
	return 0;
}


/*	Answer a string containing the version string for this plugin. */

	/* FileAttributesPlugin>>#primitiveVersionString */
EXPORT(sqInt)
primitiveVersionString(void)
{
	popthenPush(1, stringFromCString("1.3.3d01"));
	return 0;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putLStatFor:intoBuffer:targetName: */
static sqInt
putLStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    char cLinkName[PATH_MAX];
    sqInt len;
    sqInt status;

	
#  if HAVE_LSTAT == 1
	status = lstat(cPathName, statBufPointer);
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	if ((S_ISLNK((statBufPointer->st_mode))) == 0) {
		fileNameOop[0] = (nilObject());
	}
	else {
		len = readLinkintomaxLength(cPathName, cLinkName, PATH_MAX);
		if (len < 0) {
			return len;
		}
		status = byteArrayFromCStringto(cLinkName, fileNameOop);
	}
#  else /* HAVE_LSTAT == 1 */

	/* #HAVE_LSTAT = 1 */
	/* begin invalidRequest */
	status = -11;
#  endif /* HAVE_LSTAT == 1 */
	return status;
}


/*	Call stat() on cPathName, storing the results in
	the buffer at statBufPointer. */

	/* FileAttributesPlugin>>#putStatFor:intoBuffer:targetName: */
static sqInt
putStatForintoBuffertargetName(char *cPathName, struct stat *statBufPointer, sqInt *fileNameOop)
{
    sqInt status;

	status = stat(cPathName, statBufPointer);
	if (status != 0) {
		/* begin cantStatPath */
		return -3;
	}
	fileNameOop[0] = (nilObject());
	return 0;
}


/*	Get the target filename of the supplied symbolic link. */

	/* FileAttributesPlugin>>#readLink:into:maxLength: */
static sqInt
readLinkintomaxLength(char *cPathName, char *cLinkPtr, size_t maxLength)
{
    sqInt len;


	/* len must be signed so that -1 can be communicated as an error. */
	len = 
#  if defined(_WIN32)
		-1
#  else /* defined(_WIN32) */
		readlink(cPathName, cLinkPtr, maxLength)
#  endif /* defined(_WIN32) */
		;
	if (len < 0) {
		
#    if defined(INDEBUG)
		fprintf(stderr, "FileAttributesPlugin: unable to readlink(): %d, errno=%d\n", len, errno);
#    endif /* defined(INDEBUG) */
		/* begin cantReadlink */
		return -8;
	}
	cLinkPtr[len] = 0;
	return len;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isKindOf = interpreterProxy->isKindOf;
		nilObject = interpreterProxy->nilObject;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		primitiveFailForOSError = interpreterProxy->primitiveFailForOSError;
		primitiveFailureCode = interpreterProxy->primitiveFailureCode;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signed64BitIntegerFor = interpreterProxy->signed64BitIntegerFor;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	Convert the supplied path string oop to a unix c path string.
	Parameter checking is done in the main primitive, so pathOop is assumed to
	be valid.
	pathOop is supplied as a precomposed UTF8 string.
	cPathString must be encoded using the host OS conventions, e.g. decomposed
	UTF8 on MacOS.
	Signal primitive failure on error.
 */

	/* FileAttributesPlugin>>#squeakPath:toUnix:maxLen: */
static sqInt
squeakPathtoUnixmaxLen(sqInt pathOop, char *cPathString, sqInt maxLength)
{
    int status;
    char uxName[PATH_MAX+1];

	if (maxLength > (PATH_MAX+1)) {
		return primitiveFailForOSError(-6 /* invalidArguments */);
	}
	
#  if _WIN32
	status = pathOoptoBuffermaxLen(pathOop, cPathString, maxLength);
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
#  else /* _WIN32 */
	status = pathOoptoBuffermaxLen(pathOop, uxName, PATH_MAX);
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	status = sq2uxPath(uxName, strlen(uxName), cPathString, maxLength, 1);
	if (status == 0) {
		return primitiveFailForOSError(-6 /* invalidArguments */);
	}
#  endif /* _WIN32 */
	return 0;
}


/*	Answer a file entry array from the supplied statBufPointer */

	/* FileAttributesPlugin>>#statArrayFor:toArray:from:fileName: */
static sqInt
statArrayFortoArrayfromfileName(char *cPathName, sqInt attributeArray, struct stat *statBufPointer, sqInt fileNameOop)
{
    sqLong attributeDate;
    sqInt sizeIfFile;
    sqInt status;

	sizeIfFile = ((S_ISDIR((statBufPointer->st_mode))) == 0
		? (statBufPointer->st_size)
		: 0);
	storePointerofObjectwithValue(0, attributeArray, fileNameOop);
	storePointerofObjectwithValue(1, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_mode))
		: positive32BitIntegerFor((statBufPointer->st_mode))));
	storePointerofObjectwithValue(2, attributeArray, positive64BitIntegerFor((statBufPointer->st_ino)));
	storePointerofObjectwithValue(3, attributeArray, positive64BitIntegerFor((statBufPointer->st_dev)));
	storePointerofObjectwithValue(4, attributeArray, positive64BitIntegerFor((statBufPointer->st_nlink)));
	storePointerofObjectwithValue(5, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_uid))
		: positive32BitIntegerFor((statBufPointer->st_uid))));
	storePointerofObjectwithValue(6, attributeArray, (BytesPerWord == 8
		? positive64BitIntegerFor((statBufPointer->st_gid))
		: positive32BitIntegerFor((statBufPointer->st_gid))));
	storePointerofObjectwithValue(7, attributeArray, positive64BitIntegerFor(sizeIfFile));
	
#  if defined(_WIN32)
	status = winFileTimesForto(cPathName, attributeArray);
#  else /* defined(_WIN32) */
	/* begin posixFileTimesFrom:to: */
	
#  if defined(_WIN32)
#  else /* defined(_WIN32) */
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_atime));
	storePointerofObjectwithValue(8, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_mtime));
	storePointerofObjectwithValue(9, attributeArray, signed64BitIntegerFor(attributeDate));
	attributeDate = faConvertUnixToLongSqueakTime((statBufPointer->st_ctime));
	storePointerofObjectwithValue(10, attributeArray, signed64BitIntegerFor(attributeDate));
	storePointerofObjectwithValue(11, attributeArray, nilObject());
#  endif /* defined(_WIN32) */
	status = 0;
#  endif /* defined(_WIN32) */
	return status;
}


/*	Answer a new String copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

	/* FileAttributesPlugin>>#stringFromCString: */
static sqInt
stringFromCString(const char *aCString)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(classString(), len);
	if (!(newString)) {
		return primitiveFailFor(PrimErrNoMemory);
	}
	strncpy(arrayValueOf(newString), aCString, len);
	return newString;
}


/*	Convert the supplied cPathString to a ByteArray.
	cPathString is encoded using the host OS conventions, e.g. decomposed UTF8
	on MacOS.
 */

	/* FileAttributesPlugin>>#unixPathToOop: */
static sqInt
unixPathToOop(char *cPathString)
{
    sqInt pathOop;
    sqInt status;
    char uxName[PATH_MAX+1];
    sqInt val;

	val = 0;
	if ((strlen(cPathString)) > (PATH_MAX+1)) {
		return primitiveFailForOSError(-1 /* stringTooLong */);
	}
	pathOop = 0;
	
#  if _WIN32
	status = byteArrayFromCStringto(cPathString, (&pathOop));
#  else /* _WIN32 */
	status = ux2sqPath(cPathString, strlen(cPathString), uxName, PATH_MAX, 1);
	if (status == 0) {
		return primitiveFailForOSError(-6 /* invalidArguments */);
	}
	status = byteArrayFromCStringto(uxName, (&pathOop));
#  endif /* _WIN32 */
	if (status != 0) {
		return primitiveFailForOSError(status);
	}
	return pathOop;
}


/*	Populate the supplied Win32 file attribute structure */

	/* FileAttributesPlugin>>#winFileAttributesFor:length:to: */
#if _WIN32
static sqInt
winFileAttributesForlengthto(char *pathString, sqInt pathLength, WIN32_FILE_ATTRIBUTE_DATA *winAttrs)
{
    WCHAR *win32Path;

	win32Path = 0;
	ALLOC_WIN32_PATH(win32Path, pathString, pathLength);
	if ((GetFileAttributesExW(win32Path, GetFileExInfoStandard, winAttrs)) == 0) {
		/* begin getAttributesFailed */
		return -4;
	}
	return 0;
}
#endif /* _WIN32 */


/*	Set the file creation time from the supplied attributes. */

	/* FileAttributesPlugin>>#winFileCreationTimeFor:to: */
#if _WIN32
static sqInt
winFileCreationTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *creationDate)
{
    FILETIME fileTime;
    SYSTEMTIME sysTime;

	if ((FileTimeToLocalFileTime(&winAttrs->ftCreationTime, &fileTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	if ((FileTimeToSystemTime(&fileTime, &sysTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	*creationDate = convertWinToSqueakTime(sysTime);
	return 0;
}
#endif /* _WIN32 */


/*	Set the file creation time from the supplied attributes. */

	/* FileAttributesPlugin>>#winFileLastAccessTimeFor:to: */
#if _WIN32
static sqInt
winFileLastAccessTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *accessDate)
{
    FILETIME fileTime;
    SYSTEMTIME sysTime;

	if ((FileTimeToLocalFileTime(&winAttrs->ftLastAccessTime, &fileTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	if ((FileTimeToSystemTime(&fileTime, &sysTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	*accessDate = convertWinToSqueakTime(sysTime);
	return 0;
}
#endif /* _WIN32 */


/*	Set the file write time from the supplied attributes. */

	/* FileAttributesPlugin>>#winFileLastWriteTimeFor:to: */
#if _WIN32
static sqInt
winFileLastWriteTimeForto(WIN32_FILE_ATTRIBUTE_DATA *winAttrs, sqLong *writeDate)
{
    FILETIME fileTime;
    SYSTEMTIME sysTime;

	if ((FileTimeToLocalFileTime(&winAttrs->ftLastWriteTime, &fileTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	if ((FileTimeToSystemTime(&fileTime, &sysTime)) == 0) {
		/* begin timeConversionFailed */
		return -5;
	}
	*writeDate = convertWinToSqueakTime(sysTime);
	return 0;
}
#endif /* _WIN32 */

	/* FileAttributesPlugin>>#winFileTimesFor:to: */
#if _WIN32
static sqInt
winFileTimesForto(char *cPathName, sqInt attributeArray)
{
    sqLong attributeDate;
    sqInt status;
    sqInt val;
    WIN32_FILE_ATTRIBUTE_DATA winAttrs;


	/* Get the file attributes */
	attributeDate = 0;
	val = 0;
	status = winFileAttributesForlengthto(cPathName, strlen(cPathName), (&winAttrs));
	if (!(status == 0)) {
		return status;
	}
	status = winFileLastAccessTimeForto((&winAttrs), (&attributeDate));
	if (!(status == 0)) {
		return status;
	}
	storePointerofObjectwithValue(8, attributeArray, signed64BitIntegerFor(attributeDate));
	status = winFileLastWriteTimeForto((&winAttrs), (&attributeDate));
	if (!(status == 0)) {
		return status;
	}
	storePointerofObjectwithValue(9, attributeArray, signed64BitIntegerFor(attributeDate));
	storePointerofObjectwithValue(10, attributeArray, nilObject());
	status = winFileCreationTimeForto((&winAttrs), (&attributeDate));
	if (!(status == 0)) {
		return status;
	}
	storePointerofObjectwithValue(11, attributeArray, signed64BitIntegerFor(attributeDate));
	return 0;
}
#endif /* _WIN32 */


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "FileAttributesPlugin";
void* FileAttributesPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveClosedir\000\001", (void*)primitiveClosedir},
	{(void*)_m, "primitiveFileAttribute\000\001", (void*)primitiveFileAttribute},
	{(void*)_m, "primitiveFileAttributes\000\001", (void*)primitiveFileAttributes},
	{(void*)_m, "primitiveFileExists\000\001", (void*)primitiveFileExists},
	{(void*)_m, "primitiveFileMasks\000\377", (void*)primitiveFileMasks},
	{(void*)_m, "primitiveLogicalDrives\000\377", (void*)primitiveLogicalDrives},
	{(void*)_m, "primitiveOpendir\000\001", (void*)primitiveOpendir},
	{(void*)_m, "primitivePathMax\000\377", (void*)primitivePathMax},
	{(void*)_m, "primitiveReaddir\000\001", (void*)primitiveReaddir},
	{(void*)_m, "primitiveRewinddir\000\001", (void*)primitiveRewinddir},
	{(void*)_m, "primitiveVersionString\000\377", (void*)primitiveVersionString},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveClosedirAccessorDepth = 1;
signed char primitiveFileAttributeAccessorDepth = 1;
signed char primitiveFileAttributesAccessorDepth = 1;
signed char primitiveFileExistsAccessorDepth = 1;
signed char primitiveOpendirAccessorDepth = 1;
signed char primitiveReaddirAccessorDepth = 1;
signed char primitiveRewinddirAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
