/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
   from
	BalloonEnginePlugin VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
 */
static char __buildInfo[] = "BalloonEnginePlugin VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Constants ***/
#define BEBalloonEngineSize 12
#define BEBitBltIndex 2
#define BEFormsIndex 3
#define BESpanIndex 1
#define BEWorkBufferIndex 0
#define ETBalloonEdgeDataSize 6
#define ETIndexIndex 0
#define ETLinesIndex 4
#define ETXValueIndex 1
#define ETYValueIndex 2
#define ETZValueIndex 3
#define FTBalloonFillDataSize 6
#define FTIndexIndex 0
#define FTMaxXIndex 2
#define FTMinXIndex 1
#define FTYValueIndex 3
#define GBBaseSize 16
#define GBBitmapDepth 12
#define GBBitmapHeight 11
#define GBBitmapRaster 14
#define GBBitmapSize 13
#define GBBitmapWidth 10
#define GBColormapOffset 18
#define GBColormapSize 15
#define GBEndX 14
#define GBEndY 15
#define GBFinalX 21
#define GBMBaseSize 18
#define GBTileFlag 16
#define GBUpdateData 10
#define GBUpdateDDX 4
#define GBUpdateDDY 5
#define GBUpdateDX 2
#define GBUpdateDY 3
#define GBUpdateX 0
#define GBUpdateY 1
#define GBViaX 12
#define GBViaY 13
#define GBWideEntry 18
#define GBWideExit 19
#define GBWideExtent 20
#define GBWideFill 16
#define GBWideSize 28
#define GBWideUpdateData 22
#define GBWideWidth 17
#define GEBaseEdgeSize 10
#define GEBaseFillSize 4
#define GEEdgeFillsInvalid 0x10000
#define GEFAlreadyFailed 100
#define GEFBadPoint 121
#define GEFBitBltLoadFailed 122
#define GEFClassMismatch 114
#define GEFEdgeDataTooSmall 112
#define GEFEngineIsInteger 101
#define GEFEngineIsWords 102
#define GEFEngineStopped 104
#define GEFEngineTooSmall 103
#define GEFEntityCheckFailed 120
#define GEFEntityLoadFailed 119
#define GEFFillDataTooSmall 113
#define GEFFormLoadFailed 123
#define GEFillIndexLeft 8
#define GEFillIndexRight 9
#define GEFSizeMismatch 115
#define GEFWorkBufferBadMagic 108
#define GEFWorkBufferIsInteger 105
#define GEFWorkBufferIsPointers 106
#define GEFWorkBufferStartWrong 110
#define GEFWorkBufferTooSmall 107
#define GEFWorkBufferWrongSize 109
#define GEFWorkTooBig 111
#define GEFWrongEdge 118
#define GEFWrongFill 117
#define GEFWrongState 116
#define GENumLines 7
#define GEObjectIndex 2
#define GEObjectLength 1
#define GEObjectType 0
#define GEPrimitiveBezier 6
#define GEPrimitiveClippedBitmapFill 0x400
#define GEPrimitiveEdge 2
#define GEPrimitiveEdgeMask 0xFF
#define GEPrimitiveFill 0x100
#define GEPrimitiveFillMask 0xFF00
#define GEPrimitiveLine 4
#define GEPrimitiveLinearGradientFill 0x200
#define GEPrimitiveRadialGradientFill 0x300
#define GEPrimitiveTypeMask 0xFFFF
#define GEPrimitiveWide 1
#define GEPrimitiveWideBezier 7
#define GEPrimitiveWideLine 5
#define GEPrimitiveWideMask 0xFE
#define GErrorAETEntry 6
#define GErrorBadState 2
#define GErrorFillEntry 5
#define GErrorGETEntry 4
#define GErrorNeedFlush 3
#define GErrorNoMoreSpace 1
#define GEStateAddingFromGET 1
#define GEStateBlitBuffer 5
#define GEStateCompleted 8
#define GEStateScanningAET 3
#define GEStateUnlocked 0
#define GEStateUpdateEdges 6
#define GEStateWaitingChange 7
#define GEStateWaitingForEdge 2
#define GEStateWaitingForFill 4
#define GEXValue 4
#define GEYValue 5
#define GEZValue 6
#define GFDirectionX 6
#define GFDirectionY 7
#define GFNormalX 8
#define GFNormalY 9
#define GFOriginX 4
#define GFOriginY 5
#define GFRampLength 10
#define GFRampOffset 12
#define GGBaseSize 12
#define GLBaseSize 16
#define GLEndX 14
#define GLEndY 15
#define GLError 13
#define GLErrorAdjDown 15
#define GLErrorAdjUp 14
#define GLWideEntry 18
#define GLWideExit 19
#define GLWideExtent 20
#define GLWideFill 16
#define GLWideSize 21
#define GLWideWidth 17
#define GLXDirection 10
#define GLXIncrement 12
#define GLYDirection 11
#define GWAAColorMask 0x33
#define GWAAColorShift 50
#define GWAAHalfPixel 53
#define GWAALevel 48
#define GWAAScanMask 0x34
#define GWAAShift 49
#define GWAETStart 13
#define GWAETUsed 14
#define GWBezierHeightSubdivisions 109
#define GWBezierLineConversions 111
#define GWBezierMonotonSubdivisions 108
#define GWBezierOverflowSubdivisions 110
#define GWBufferTop 10
#define GWClearSpanBuffer 69
#define GWClipMaxX 43
#define GWClipMaxY 45
#define GWClipMinX 42
#define GWClipMinY 44
#define GWColorTransform 24
#define GWCountAddAETEntry 97
#define GWCountChangeAETEntry 107
#define GWCountDisplaySpan 103
#define GWCountFinishTest 93
#define GWCountInitializing 91
#define GWCountMergeFill 101
#define GWCountNextAETEntry 105
#define GWCountNextFillEntry 99
#define GWCountNextGETEntry 95
#define GWCurrentY 88
#define GWCurrentZ 113
#define GWDestOffsetX 46
#define GWDestOffsetY 47
#define GWEdgeTransform 18
#define GWFillMaxX 37
#define GWFillMaxY 39
#define GWFillMinX 36
#define GWFillMinY 38
#define GWGETStart 11
#define GWGETUsed 12
#define GWHasColorTransform 17
#define GWHasEdgeTransform 16
#define GWHeaderSize 128
#define GWLastExportedEdge 65
#define GWLastExportedFill 66
#define GWLastExportedLeftX 67
#define GWLastExportedRightX 68
#define GWMagicIndex 0
#define GWMagicNumber 1097753705
#define GWMinimalSize 256
#define GWNeedsFlush 63
#define GWObjStart 8
#define GWObjUsed 9
#define GWPoint1 80
#define GWPoint2 82
#define GWPoint3 84
#define GWPoint4 86
#define GWSize 1
#define GWSpanEnd 34
#define GWSpanEndAA 35
#define GWSpanSize 33
#define GWSpanStart 32
#define GWState 2
#define GWStopReason 64
#define GWTimeAddAETEntry 96
#define GWTimeChangeAETEntry 106
#define GWTimeDisplaySpan 102
#define GWTimeFinishTest 92
#define GWTimeInitializing 90
#define GWTimeMergeFill 100
#define GWTimeNextAETEntry 104
#define GWTimeNextFillEntry 98
#define GWTimeNextGETEntry 94


/*** Function Prototypes ***/
static sqInt accurateLengthOfwith(sqInt deltaX, sqInt deltaY);
static sqInt addEdgeToGET(sqInt edge);
static sqInt adjustWideBezierLeftwidthoffsetendX(sqInt bezier, sqInt lineWidth, sqInt lineOffset, sqInt endX);
static sqInt adjustWideBezierRightwidthoffsetendX(sqInt bezier, sqInt lineWidth, sqInt lineOffset, sqInt endX);
static sqInt adjustWideLineafterSteppingFromto(sqInt line, sqInt lastX, sqInt nextX);
static sqInt allocateGETEntry(sqInt nSlots);
static sqInt allocateObjEntry(sqInt nSlots);
static sqInt checkCompressedFillIndexListmaxsegments(sqInt fillList, sqInt maxIndex, sqInt nSegs);
static sqInt checkCompressedFills(sqInt indexList);
static int checkCompressedLineWidthssegments(sqInt lineWidthList, sqInt nSegments);
static sqInt checkCompressedPointssegments(sqInt points, sqInt nSegments);
static sqInt checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(sqInt points, sqInt nSegments, sqInt leftFills, sqInt rightFills, sqInt lineWidths, sqInt lineFills, sqInt fillIndexList);
static double * circleCosTable(void);
static double * circleSinTable(void);
static sqInt clearSpanBuffer(void);
static int computeBezierSplitAtHalf(sqInt index);
static int computeBeziersplitAt(sqInt index, double param);
static sqInt computeFinalWideBezierValueswidth(sqInt bezier, sqInt lineWidth);
static sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt yValue);
static sqInt createGlobalEdgeTable(void);
static sqInt displaySpanBufferAt(sqInt y);
static sqInt fillBitmapSpanAAfromtoat(sqInt bmFill, sqInt leftX, sqInt rightX, sqInt yValue);
static sqInt fillBitmapSpanfromto(int *bits, sqInt leftX, sqInt rightX);
static sqInt fillBitmapSpanfromtoat(sqInt bmFill, sqInt leftX, sqInt rightX, sqInt yValue);
static sqInt fillColorSpanAAx0x1(sqInt pixelValue32, sqInt leftX, sqInt rightX);
static sqInt fillLinearGradientAArampdsdsXfromto(sqInt fill, int *ramp, sqInt deltaS, sqInt dsX, sqInt leftX, sqInt rightX);
static sqInt fillLinearGradientfromtoat(sqInt fill, sqInt leftX, sqInt rightX, sqInt yValue);
static sqInt fillRadialDecreasingAArampdeltaSTdsXdtXfromto(sqInt fill, int *ramp, int *deltaST, sqInt dsX, sqInt dtX, sqInt leftX, sqInt rightX);
static sqInt fillRadialGradientfromtoat(sqInt fill, sqInt leftX, sqInt rightX, sqInt yValue);
static sqInt fillRadialIncreasingAArampdeltaSTdsXdtXfromto(sqInt fill, int *ramp, int *deltaST, sqInt dsX, sqInt dtX, sqInt leftX, sqInt rightX);
static int fillSortsbefore(sqInt fillEntry1, sqInt fillEntry2);
static sqInt fillSpanfromto(unsigned int fill, sqInt leftX, sqInt rightX);
static sqInt findNextExternalEntryFromGET(void);
static sqInt findNextExternalFillFromAET(void);
static sqInt findNextExternalUpdateFromAET(void);
static sqInt findStackFilldepth(sqInt fillIndex, sqInt depth);
EXPORT(const char*) getModuleName(void);
static sqInt getSortsbefore(sqInt edge1, sqInt edge2);
static sqInt hideFilldepth(sqInt fillIndex, sqInt depth);
static sqInt indexForInsertingIntoAET(sqInt edge);
static sqInt initColorTransform(void);
static sqInt initEdgeTransform(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt initializeGETProcessing(void);
static sqInt insertEdgeIntoAET(sqInt edge);
static sqInt insertToAETbeforeIndex(sqInt edge, sqInt index);
static sqInt isEdge(sqInt edge);
static sqInt isFillOkay(sqInt fill);
static sqInt loadAndSubdivideBezierFromviatoisWide(int *point1, int *point2, int *point3, sqInt wideFlag);
static sqInt loadArrayShapenSegmentsfilllineWidthlineFill(sqInt points, sqInt nSegments, sqInt fillIndex, sqInt lineWidth, sqInt lineFill);
static sqInt loadArrayTransformFromintolength(sqInt transformOop, float *destPtr, sqInt n);
static sqInt loadBeziersegmentleftFillrightFilloffset(sqInt bezier, sqInt index, sqInt leftFillIndex, sqInt rightFillIndex, sqInt yOffset);
static sqInt loadBitBltFrom(sqInt bbObj);
static int * loadBitsFrom(sqInt bmFill);
static sqInt loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(int *points, sqInt nSegments, int *leftFills, int *rightFills, int *lineWidths, int *lineFills, int *fillIndexList, sqInt pointsShort);
static int loadEdgeStateFrom(sqInt edgeOop);
static sqInt loadEdgeTransformFrom(sqInt transformOop);
static sqInt loadFillOrientationfromalongnormalwidthheight(sqInt fill, int *point1, int *point2, int *point3, sqInt fillWidth, sqInt fillHeight);
static sqInt loadFormsFrom(sqInt arrayOop);
static sqInt loadGradientFillfromalongnormalisRadial(sqInt rampOop, int *point1, int *point2, int *point3, sqInt isRadial);
static sqInt loadOvalSegmentwhcxcy(sqInt seg, sqInt w, sqInt h, sqInt cx, sqInt cy);
static sqInt loadOvallineFillleftFillrightFill(sqInt lineWidth, sqInt lineFill, sqInt leftFill, sqInt rightFill);
static sqInt loadPointfrom(int *pointArray, sqInt pointOop);
static sqInt loadRenderingState(void);
static sqInt loadShapenSegmentsfilllineWidthlineFillpointsShort(int *points, sqInt nSegments, sqInt fillIndex, sqInt lineWidth, sqInt lineFill, sqInt pointsShort);
static sqInt loadSpanBufferFrom(sqInt spanOop);
static sqInt loadTransformFromintolength(sqInt transformOop, float *destPtr, sqInt n);
static sqInt loadWideBezierlineFillleftFillrightFilln(sqInt lineWidth, sqInt lineFill, sqInt leftFill, sqInt rightFill, sqInt nSegments);
static sqInt loadWideLinefromtolineFillleftFillrightFill(sqInt lineWidth, int *p1, int *p2, sqInt lineFill, sqInt leftFill, sqInt rightFill);
static sqInt loadWordTransformFromintolength(sqInt transformOop, float *destPtr, sqInt n);
static sqInt loadWorkBufferFrom(sqInt wbOop);
EXPORT(sqInt) moduleUnloaded(char *aModuleName);
static sqInt moveAETEntryFromedgex(sqInt index, sqInt edge, sqInt xValue);
static sqInt postDisplayAction(void);
EXPORT(sqInt) primitiveAbortProcessing(void);
EXPORT(sqInt) primitiveAddActiveEdgeEntry(void);
EXPORT(sqInt) primitiveAddBezier(void);
EXPORT(sqInt) primitiveAddBezierShape(void);
EXPORT(sqInt) primitiveAddBitmapFill(void);
EXPORT(sqInt) primitiveAddCompressedShape(void);
EXPORT(sqInt) primitiveAddGradientFill(void);
EXPORT(sqInt) primitiveAddLine(void);
EXPORT(sqInt) primitiveAddOval(void);
EXPORT(sqInt) primitiveAddPolygon(void);
EXPORT(sqInt) primitiveAddRect(void);
EXPORT(sqInt) primitiveChangedActiveEdgeEntry(void);
EXPORT(sqInt) primitiveCopyBuffer(void);
EXPORT(sqInt) primitiveDisplaySpanBuffer(void);
EXPORT(sqInt) primitiveDoProfileStats(void);
EXPORT(sqInt) primitiveFinishedProcessing(void);
EXPORT(sqInt) primitiveGetAALevel(void);
EXPORT(sqInt) primitiveGetBezierStats(void);
EXPORT(sqInt) primitiveGetClipRect(void);
EXPORT(sqInt) primitiveGetCounts(void);
EXPORT(sqInt) primitiveGetDepth(void);
EXPORT(sqInt) primitiveGetFailureReason(void);
EXPORT(sqInt) primitiveGetOffset(void);
EXPORT(sqInt) primitiveGetTimes(void);
EXPORT(sqInt) primitiveInitializeBuffer(void);
EXPORT(sqInt) primitiveInitializeProcessing(void);
EXPORT(sqInt) primitiveMergeFillFrom(void);
EXPORT(sqInt) primitiveNeedsFlush(void);
EXPORT(sqInt) primitiveNeedsFlushPut(void);
EXPORT(sqInt) primitiveNextActiveEdgeEntry(void);
EXPORT(sqInt) primitiveNextFillEntry(void);
EXPORT(sqInt) primitiveNextGlobalEdgeEntry(void);
EXPORT(sqInt) primitiveRegisterExternalEdge(void);
EXPORT(sqInt) primitiveRegisterExternalFill(void);
EXPORT(sqInt) primitiveRenderImage(void);
EXPORT(sqInt) primitiveRenderScanline(void);
EXPORT(sqInt) primitiveSetAALevel(void);
EXPORT(sqInt) primitiveSetBitBltPlugin(void);
EXPORT(sqInt) primitiveSetClipRect(void);
EXPORT(sqInt) primitiveSetColorTransform(void);
EXPORT(sqInt) primitiveSetDepth(void);
EXPORT(sqInt) primitiveSetEdgeTransform(void);
EXPORT(sqInt) primitiveSetOffset(void);
static sqInt proceedRenderingImage(void);
static sqInt proceedRenderingScanline(void);
static sqInt quickLoadEngineFrom(sqInt engineOop);
static sqInt quickLoadEngineFromrequiredState(sqInt oop, sqInt requiredState);
static sqInt quickLoadEngineFromrequiredStateor(sqInt oop, sqInt requiredState, sqInt alternativeState);
static sqInt quickSortGlobalEdgeTablefromto(int *array, sqInt i, sqInt j);
static sqInt removeFirstAETEntry(void);
static sqInt resetGraphicsEngineStats(void);
static sqInt resortFirstAETEntry(void);
static int * rShiftTable(void);
static sqInt setAALevel(sqInt level);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt showFilldepthrightX(sqInt fillIndex, sqInt depth, sqInt rightX);
static int * smallSqrtTable(void);
static sqInt stepToFirstBezierInat(sqInt bezier, sqInt yValue);
static sqInt stepToFirstLineInat(sqInt line, sqInt yValue);
static sqInt stepToFirstWideBezierInat(sqInt bezier, sqInt yValue);
static sqInt stepToFirstWideLineInat(sqInt line, sqInt yValue);
static sqInt stepToNextWideBezierInat(sqInt bezier, sqInt yValue);
static sqInt storeEdgeStateFrominto(sqInt edge, sqInt edgeOop);
static sqInt storeFillStateInto(sqInt fillOop);
static sqInt storeRenderingState(void);
static sqInt subdivideBezierFrom(sqInt index);
static sqInt subdivideBezier(sqInt index);
static sqInt subdivideToBeMonotonInX(sqInt index);
static sqInt subdivideToBeMonotonInY(sqInt index);
static sqInt subdivideToBeMonotoninX(sqInt base, sqInt doTestX);
static sqInt toggleFillsOf(sqInt edge);
static sqInt toggleFilldepthrightX(sqInt fillIndex, sqInt depth, sqInt rightX);
static sqInt toggleWideFillOf(sqInt edge);
static int topDepth(void);
static int topFill(void);
static int topRightX(void);
static sqInt transformColor(sqInt fillIndex);
static sqInt transformWidth(sqInt w);
static sqInt uncheckedTransformColor(sqInt fillIndex);


/*** Variables ***/
static int* aetBuffer;
static char bbPluginName[256] = "BitBltPlugin";
static void * copyBitsFn;
static sqInt dispatchedValue;
static sqInt dispatchReturnValue;
static sqInt engine;
static sqInt engineStopped;
static sqInt formArray;
static sqInt geProfileTime;
static int* getBuffer;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*classBitmap)(void);
static sqInt (*classPoint)(void);
static sqInt (*failed)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static double (*floatValueOf)(sqInt oop);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName);
static unsigned int (*ioMicroMSecs)(void);
static sqInt (*isArray)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isFloatObject)(sqInt oop);
#if !defined(isImmediate)
static sqInt (*isImmediate)(sqInt anObject);
#endif
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isPointers)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*makePointwithxValueyValue)(sqInt xValue, sqInt yValue);
static sqInt (*methodArgumentCount)(void);
static sqInt (*nilObject)(void);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static usqInt (*positive32BitValueOf)(sqInt oop);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*pushBool)(sqInt trueOrFalse);
static sqInt (*pushInteger)(sqInt integerValue);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*topRemappableOop)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt classBitmap(void);
extern sqInt classPoint(void);
extern sqInt failed(void);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern double floatValueOf(sqInt oop);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern unsigned int ioMicroMSecs(void);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isFloatObject(sqInt oop);
#if !defined(isImmediate)
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isImmediate(sqInt anObject);
#else
# define isImmediate(anObject) 0
#endif
#endif /* !defined(isImmediate) */
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
extern sqInt isPointers(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
extern sqInt methodArgumentCount(void);
extern sqInt nilObject(void);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern usqInt positive32BitValueOf(sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt pushBool(sqInt trueOrFalse);
extern sqInt pushInteger(sqInt integerValue);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt topRemappableOop(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static void * loadBBFn;
static const char *moduleName = "B2DPlugin VMMaker.oscog-eem.3456 " INT_EXT;
static int* objBuffer;
static sqInt objUsed;
static unsigned int* spanBuffer;
static int* workBuffer;
static int doProfileStats = 0;


/*** Methods ***/


/*	Return the accurate length of the vector described by deltaX and deltaY */

	/* BalloonEngineBase>>#accurateLengthOf:with: */
static sqInt
accurateLengthOfwith(sqInt deltaX, sqInt deltaY)
{
    sqInt length2;

	if (!deltaX) {
		if (deltaY < 0) {
			return 0 - deltaY;
		}
		else {
			return deltaY;
		}
	}
	if (!deltaY) {
		if (deltaX < 0) {
			return 0 - deltaX;
		}
		else {
			return deltaX;
		}
	}
	length2 = (deltaX * deltaX) + (deltaY * deltaY);

	/* begin computeSqrt: */
	if (length2 < 32) {
		return (smallSqrtTable())[length2];
	}
	else {
		return ((sqInt)((sqrt(((double) length2 ))) + 0.5));
	}
}

	/* BalloonEngineBase>>#addEdgeToGET: */
static sqInt
addEdgeToGET(sqInt edge)
{
	if (!(allocateGETEntry(1))) {
		return 0;
	}
	getBuffer[workBuffer[GWGETUsed]] = edge;

	/* getUsedPut: */
	workBuffer[GWGETUsed] = ((workBuffer[GWGETUsed]) + 1);
	return 0;
}


/*	Adjust the wide bezier curve (dx < 0) to start/end at the right point */

	/* BalloonEnginePlugin>>#adjustWideBezierLeft:width:offset:endX: */
static sqInt
adjustWideBezierLeftwidthoffsetendX(sqInt bezier, sqInt lineWidth, sqInt lineOffset, sqInt endX)
{
    int lastX;
    int lastY;

	((objBuffer + bezier) + GBUpdateData)[GBUpdateX] = ((((objBuffer + bezier) + GBUpdateData)[GBUpdateX]) - (lineOffset * 0x100));
	lastX = ((objBuffer + bezier) + GBWideUpdateData)[GBUpdateX];
	((objBuffer + bezier) + GBWideUpdateData)[GBUpdateX] = (lastX + ((lineWidth - lineOffset) * 0x100));
	lastY = ((objBuffer + bezier) + GBWideUpdateData)[GBUpdateY];
	((objBuffer + bezier) + GBWideUpdateData)[GBUpdateY] = (lastY + (lineWidth * 0x100));

	/* #bezierFinalXOf:put: #obj:at:put: */
	objBuffer[bezier + GBFinalX] = (endX - lineOffset);
	return 0;
}


/*	Adjust the wide bezier curve (dx >= 0) to start/end at the right point */

	/* BalloonEnginePlugin>>#adjustWideBezierRight:width:offset:endX: */
static sqInt
adjustWideBezierRightwidthoffsetendX(sqInt bezier, sqInt lineWidth, sqInt lineOffset, sqInt endX)
{
    int lastX;
    int lastY;

	((objBuffer + bezier) + GBUpdateData)[GBUpdateX] = ((((objBuffer + bezier) + GBUpdateData)[GBUpdateX]) + (lineOffset * 0x100));
	lastX = ((objBuffer + bezier) + GBWideUpdateData)[GBUpdateX];
	((objBuffer + bezier) + GBWideUpdateData)[GBUpdateX] = (lastX - ((lineWidth - lineOffset) * 0x100));

	/* Set lineWidth pixels down */
	lastY = ((objBuffer + bezier) + GBWideUpdateData)[GBUpdateY];
	((objBuffer + bezier) + GBWideUpdateData)[GBUpdateY] = (lastY + (lineWidth * 0x100));

	/* #bezierFinalXOf:put: #obj:at:put: */
	objBuffer[bezier + GBFinalX] = ((endX - lineOffset) + lineWidth);
	return 0;
}


/*	Adjust the wide line after it has been stepped from lastX to nextX.
	Special adjustments of line width and start position are made here
	to simulate a rectangular brush */

	/* BalloonEnginePlugin>>#adjustWideLine:afterSteppingFrom:to: */
static sqInt
adjustWideLineafterSteppingFromto(sqInt line, sqInt lastX, sqInt nextX)
{
    int baseWidth;
    sqInt deltaX;
    sqInt lineOffset;
    int lineWidth;
    int xDir;
    int yEntry;
    int yExit;


	/* Don't inline this */
	/* Fetch the values the adjustment decisions are based on */
	yEntry = objBuffer[line + GLWideEntry];
	yExit = objBuffer[line + GLWideExit];
	baseWidth = objBuffer[line + GLWideExtent];
	lineOffset = baseWidth / 2;
	lineWidth = objBuffer[line + GLWideWidth];
	xDir = objBuffer[line + GLXDirection];

	/* Adjust the start of the line to fill an entire rectangle */
	deltaX = nextX - lastX;
	if (yEntry < baseWidth) {
		if (xDir < 0) {
			/* effectively adding */
			lineWidth -= deltaX;
		}
		else {
			lineWidth += deltaX;

			/* #edgeXValueOf:put: #obj:at:put: */
			objBuffer[line + GEXValue] = lastX;
		}
	}
	if (!(yExit + lineOffset)) {
		if (xDir > 0) {
			lineWidth -= objBuffer[line + GLXIncrement];
		}
		else {
			/* effectively subtracting */
			lineWidth += objBuffer[line + GLXIncrement];

			/* #edgeXValueOf:put: #obj:at:put: */
			objBuffer[line + GEXValue] = lastX;
		}
	}
	if ((yExit + lineOffset) > 0) {
		if (xDir < 0) {
			/* effectively subtracting */
			lineWidth += deltaX;

			/* #edgeXValueOf:put: #obj:at:put: */
			objBuffer[line + GEXValue] = lastX;
		}
		else {
			lineWidth -= deltaX;
		}
	}

	/* #wideLineWidthOf:put: #obj:at:put: */
	objBuffer[line + GLWideWidth] = lineWidth;
	return 0;
}


/*	Allocate n slots in the global edge table */

	/* BalloonEngineBase>>#allocateGETEntry: */
static sqInt
allocateGETEntry(sqInt nSlots)
{
    sqInt dstIndex;
    sqInt i;
    int srcIndex;


	/* First allocate nSlots in the AET */
	/* begin allocateAETEntry: */
	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + nSlots) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return 0;
	}
	if (workBuffer[GWAETUsed]) {

		/* Then move the AET upwards */
		srcIndex = workBuffer[GWAETUsed];
		dstIndex = (workBuffer[GWAETUsed]) + nSlots;
		for (i = 1; i <= (workBuffer[GWAETUsed]); i += 1) {
			aetBuffer[(dstIndex -= 1)] = (aetBuffer[(srcIndex -= 1)]);
		}
	}
	aetBuffer += nSlots;
	return 1;
}


/*	Allocate n slots in the object buffer */

	/* BalloonEngineBase>>#allocateObjEntry: */
static sqInt
allocateObjEntry(sqInt nSlots)
{
    sqInt dstIndex;
    sqInt i;
    int srcIndex;


	/* First allocate nSlots in the GET */
	if (!(allocateGETEntry(nSlots))) {
		return 0;
	}
	if (workBuffer[GWGETUsed]) {

		/* Then move the GET upwards */
		srcIndex = workBuffer[GWGETUsed];
		dstIndex = (workBuffer[GWGETUsed]) + nSlots;
		for (i = 1; i <= (workBuffer[GWGETUsed]); i += 1) {
			getBuffer[(dstIndex -= 1)] = (getBuffer[(srcIndex -= 1)]);
		}
	}
	getBuffer += nSlots;
	return 1;
}


/*	Check the fill indexes in the run-length encoded fillList */

	/* BalloonEnginePlugin>>#checkCompressedFillIndexList:max:segments: */
static sqInt
checkCompressedFillIndexListmaxsegments(sqInt fillList, sqInt maxIndex, sqInt nSegs)
{
    int *fillPtr;
    sqInt i;
    sqInt length;
    sqInt nFills;
    sqInt runLength;
    int runValue;

	length = slotSizeOf(fillList);
	fillPtr = firstIndexableField(fillList);
	nFills = 0;
	for (i = 0; i < length; i += 1) {
		runLength = (((usqInt)(((((int *) fillPtr))[i]))) >> 16);
		runValue = ((((int *) fillPtr))[i]) & 0xFFFF;
		if (!((runValue >= 0)
			 && (runValue <= maxIndex))) {
			return 0;
		}
		nFills += runLength;
	}
	return nFills == nSegs;
}


/*	Check if the indexList (containing fill handles) is okay. */

	/* BalloonEnginePlugin>>#checkCompressedFills: */
static sqInt
checkCompressedFills(sqInt indexList)
{
    int fillIndex;
    int *fillPtr;
    sqInt i;
    sqInt length;


	/* First check if the oops have the right format */
	if (!(isWords(indexList))) {
		return 0;
	}
	length = slotSizeOf(indexList);
	fillPtr = firstIndexableField(indexList);
	for (i = 0; i < length; i += 1) {
		/* Make sure the fill is okay */
		fillIndex = fillPtr[i];
		if (!(isFillOkay(fillIndex))) {
			return 0;
		}
	}
	return 1;
}


/*	Check the run-length encoded lineWidthList matches nSegments */

	/* BalloonEnginePlugin>>#checkCompressedLineWidths:segments: */
static int
checkCompressedLineWidthssegments(sqInt lineWidthList, sqInt nSegments)
{
    sqInt i;
    sqInt length;
    sqInt nItems;
    int *ptr;
    sqInt runLength;

	length = slotSizeOf(lineWidthList);
	ptr = firstIndexableField(lineWidthList);
	nItems = 0;
	for (i = 0; i < length; i += 1) {
		runLength = (((usqInt)(((((int *) ptr))[i]))) >> 16);
		nItems += runLength;
	}
	return nItems == nSegments;
}


/*	Check if the given point array can be handled by the engine. */

	/* BalloonEnginePlugin>>#checkCompressedPoints:segments: */
static sqInt
checkCompressedPointssegments(sqInt points, sqInt nSegments)
{
    sqInt pSize;

	if (!(isWords(points))) {
		return 0;
	}

	/* The points must be either in PointArray format or ShortPointArray format.
	   Also, we currently handle only quadratic segments (e.g., 3 points each) and thus either
	   pSize = nSegments * 3,		for ShortPointArrays or,
	   pSize = nSegments * 6,		for PointArrays */
	pSize = slotSizeOf(points);
	if (!((pSize == (nSegments * 3))
		 || (pSize == (nSegments * 6)))) {
		return 0;
	}
	return 1;
}


/*	Check if the given shape can be handled by the engine. 
	Since there are a number of requirements this is an extra method. */

	/* BalloonEnginePlugin>>#checkCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:fillIndexList: */
static sqInt
checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(sqInt points, sqInt nSegments, sqInt leftFills, sqInt rightFills, sqInt lineWidths, sqInt lineFills, sqInt fillIndexList)
{
    sqInt maxFillIndex;

	if (!(checkCompressedPointssegments(points, nSegments))) {
		return 0;
	}
	if (!(checkCompressedFills(fillIndexList))) {
		return 0;
	}
	maxFillIndex = slotSizeOf(fillIndexList);
	if (!(checkCompressedFillIndexListmaxsegments(leftFills, maxFillIndex, nSegments))) {
		return 0;
	}
	if (!(checkCompressedFillIndexListmaxsegments(rightFills, maxFillIndex, nSegments))) {
		return 0;
	}
	if (!(checkCompressedFillIndexListmaxsegments(lineFills, maxFillIndex, nSegments))) {
		return 0;
	}
	if (!(checkCompressedLineWidthssegments(lineWidths, nSegments))) {
		return 0;
	}
	return 1;
}

	/* BalloonEnginePlugin>>#circleCosTable */
static double *
circleCosTable(void)
{
    static double theTable[33] =
		{1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,
		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,
		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,
		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,
		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,
		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,
		0.0, 0.1950903220161282, 0.38268343236509, 0.555570233019602,
		0.707106781186547, 0.831469612302545, 0.9238795325112865, 0.98078528040323,
		1.0 };

	return theTable;
}

	/* BalloonEnginePlugin>>#circleSinTable */
static double *
circleSinTable(void)
{
    static double theTable[33] =
		{0.0, 0.1950903220161282, 0.3826834323650897, 0.555570233019602,
		0.707106781186547, 0.831469612302545, 0.923879532511287, 0.98078528040323,
		1.0, 0.98078528040323, 0.923879532511287, 0.831469612302545,
		0.7071067811865475, 0.555570233019602, 0.38268343236509, 0.1950903220161286,
		0.0, -0.1950903220161283, -0.3826834323650896, -0.555570233019602,
		-0.707106781186547, -0.831469612302545, -0.9238795325112865, -0.98078528040323,
		-1.0, -0.98078528040323, -0.923879532511287, -0.831469612302545,
		-0.707106781186548, -0.555570233019602, -0.3826834323650903, -0.1950903220161287,
		 0.0 };

	return theTable;
}


/*	Clear the current span buffer.
	The span buffer is only cleared in the area that has been used by the
	previous scan line.
 */

	/* BalloonEngineBase>>#clearSpanBuffer */
static sqInt
clearSpanBuffer(void)
{
    int x0;
    int x1;

	x0 = ((usqInt)((workBuffer[GWSpanStart]))) >> (workBuffer[GWAAShift]);
	x1 = (((usqInt)((workBuffer[GWSpanEnd]))) >> (workBuffer[GWAAShift])) + 1;
	if (x0 < 0) {
		x0 = 0;
	}
	if (x1 > (workBuffer[GWSpanSize])) {
		x1 = workBuffer[GWSpanSize];
	}
	while (x0 < x1) {
		spanBuffer[x0] = 0;
		x0 += 1;
	}

	/* spanStartPut: */
	workBuffer[GWSpanStart] = (workBuffer[GWSpanSize]);

	/* spanEndPut: */
	workBuffer[GWSpanEnd] = 0;
	return 0;
}


/*	Split the bezier curve at 0.5. */

	/* BalloonEnginePlugin>>#computeBezierSplitAtHalf: */
static int
computeBezierSplitAtHalf(sqInt index)
{
    int endX;
    int endY;
    int leftViaX;
    int leftViaY;
    int newIndex;
    int rightViaX;
    int rightViaY;
    int sharedX;
    int sharedY;
    int startX;
    int startY;
    int viaX;
    int viaY;

	/* begin allocateBezierStackEntry */
	/* begin wbStackPush: */
	/* begin allocateStackEntry: */
	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 6) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		goto l1;
	}

	/* wbTopPut: */
	workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) - 6);
l1:	/* end wbStackPush: */;
	newIndex = (workBuffer[GWSize]) - (workBuffer[GWBufferTop]);
	if (engineStopped) {
		return 0;
	}
	leftViaX = (startX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index))]);
	leftViaY = (startY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)]);
	rightViaX = (viaX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)]);
	rightViaY = (viaY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)]);
	endX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)];

	/* Compute intermediate points */
	endY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)];
	leftViaX += (viaX - startX) / 2;
	leftViaY += (viaY - startY) / 2;
	sharedX = (rightViaX += (endX - viaX) / 2);

	/* Compute new shared point */
	sharedY = (rightViaY += (endY - viaY) / 2);
	sharedX += (leftViaX - rightViaX) / 2;

	/* Store the first part back */
	sharedY += (leftViaY - rightViaY) / 2;

	/* #bzViaX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)] = leftViaX;

	/* #bzViaY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)] = leftViaY;

	/* #bzEndX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)] = sharedX;

	/* #bzEndY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)] = sharedY;

	/* #bzStartX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex))] = sharedX;

	/* #bzStartY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 1)] = sharedY;

	/* #bzViaX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 2)] = rightViaX;

	/* #bzViaY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 3)] = rightViaY;

	/* #bzEndX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 4)] = endX;

	/* #bzEndY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 5)] = endY;
	return newIndex;
}


/*	Split the bezier curve at the given parametric value.
	Note: Since this method is only invoked to make non-monoton
	beziers monoton we must check for the resulting y values
	to be *really* between the start and end value. */

	/* BalloonEnginePlugin>>#computeBezier:splitAt: */
static int
computeBeziersplitAt(sqInt index, double param)
{
    int endX;
    int endY;
    int leftViaX;
    int leftViaY;
    int newIndex;
    int rightViaX;
    int rightViaY;
    int sharedX;
    int sharedY;
    int startX;
    int startY;
    int viaX;
    int viaY;

	leftViaX = (startX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index))]);
	leftViaY = (startY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)]);
	rightViaX = (viaX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)]);
	rightViaY = (viaY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)]);
	endX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)];

	/* Compute intermediate points */
	endY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)];
	sharedX = (leftViaX += ((sqInt)((((double) (viaX - startX) )) * param)));
	sharedY = (leftViaY += ((sqInt)((((double) (viaY - startY) )) * param)));
	rightViaX += ((sqInt)((((double) (endX - viaX) )) * param));

	/* Compute new shared point */
	rightViaY += ((sqInt)((((double) (endY - viaY) )) * param));
	sharedX += ((sqInt)((((double) (rightViaX - leftViaX) )) * param));

	/* Check the new via points */
	sharedY += ((sqInt)((((double) (rightViaY - leftViaY) )) * param));

	/* begin assureValue:between:and: */
	if (startY > sharedY) {
		if (leftViaY > startY) {
			leftViaY = startY;
			goto l1;
		}
		if (leftViaY < sharedY) {
			leftViaY = sharedY;
			goto l1;
		}
	}
	else {
		if (leftViaY < startY) {
			leftViaY = startY;
			goto l1;
		}
		if (leftViaY > sharedY) {
			leftViaY = sharedY;
			goto l1;
		}
	}
l1:	/* end assureValue:between:and: */;

	/* begin assureValue:between:and: */
	if (sharedY > endY) {
		if (rightViaY > sharedY) {
			rightViaY = sharedY;
			goto l2;
		}
		if (rightViaY < endY) {
			rightViaY = endY;
			goto l2;
		}
	}
	else {
		if (rightViaY < sharedY) {
			rightViaY = sharedY;
			goto l2;
		}
		if (rightViaY > endY) {
			rightViaY = endY;
			goto l2;
		}
	}
l2:	/* end assureValue:between:and: */;

	/* begin allocateBezierStackEntry */
	/* begin wbStackPush: */
	/* begin allocateStackEntry: */
	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 6) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		goto l3;
	}

	/* wbTopPut: */
	workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) - 6);
l3:	/* end wbStackPush: */;
	newIndex = (workBuffer[GWSize]) - (workBuffer[GWBufferTop]);
	if (engineStopped) {
		return 0;
	}

	/* #bzViaX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)] = leftViaX;

	/* #bzViaY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)] = leftViaY;

	/* #bzEndX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)] = sharedX;

	/* #bzEndY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)] = sharedY;

	/* #bzStartX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex))] = sharedX;

	/* #bzStartY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 1)] = sharedY;

	/* #bzViaX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 2)] = rightViaX;

	/* #bzViaY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 3)] = rightViaY;

	/* #bzEndX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 4)] = endX;

	/* #bzEndY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - newIndex) + 5)] = endY;
	return newIndex;
}


/*	Get both values from the two boundaries of the given bezier 
	and compute the actual position/width of the line */

	/* BalloonEnginePlugin>>#computeFinalWideBezierValues:width: */
static sqInt
computeFinalWideBezierValueswidth(sqInt bezier, sqInt lineWidth)
{
    int leftX;
    int rightX;
    int temp;

	leftX = (((objBuffer + bezier) + GBUpdateData)[GBUpdateX]) / 0x100;
	rightX = (((objBuffer + bezier) + GBWideUpdateData)[GBUpdateX]) / 0x100;
	if (leftX > rightX) {
		temp = leftX;
		leftX = rightX;
		rightX = temp;
	}

	/* #edgeXValueOf:put: #obj:at:put: */
	objBuffer[bezier + GEXValue] = leftX;
	if ((rightX - leftX) > lineWidth) {
		/* #wideBezierWidthOf:put: #obj:at:put: */
		objBuffer[bezier + GBWideWidth] = (rightX - leftX);
	}
	else {
		/* #wideBezierWidthOf:put: #obj:at:put: */
		objBuffer[bezier + GBWideWidth] = lineWidth;
	}
	return 0;
}

	/* BalloonEngineBase>>#copyBitsFrom:to:at: */
static sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt yValue)
{
	if (!copyBitsFn) {

		/* We need copyBits here so try to load it implicitly */
		if (!(initialiseModule())) {
			return 0;
		}
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))copyBitsFn)(x0, x1, yValue);
}


/*	Create the global edge table */

	/* BalloonEngineBase>>#createGlobalEdgeTable */
static sqInt
createGlobalEdgeTable(void)
{
    sqInt end;
    int lineWidth;
    sqInt object;

	object = 0;
	end = objUsed;
	while (object < end) {

		/* Note: addEdgeToGET: may fail on insufficient space but that's not a problem here */
		if (isEdge(object)) {

			/* Check if the edge starts below fillMaxY. */
			if (!((objBuffer[object + GEYValue]) >= (workBuffer[GWFillMaxY]))) {
				/* begin checkedAddEdgeToGET: */
				if ((((objBuffer[object + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWideMask) == GEPrimitiveLine) {
					/* begin checkedAddLineToGET: */
					if (((objBuffer[object + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWide) {
						lineWidth = objBuffer[object + GLWideExtent];
					}
					else {
						lineWidth = 0;
					}
					if (((objBuffer[object + GLEndY]) + lineWidth) < (workBuffer[GWFillMinY])) {
						goto l1;
					}
					if ((((objBuffer[object + GEXValue]) - lineWidth) >= (workBuffer[GWFillMaxX]))
					 && (((objBuffer[object + GLEndX]) - lineWidth) >= (workBuffer[GWFillMaxX]))) {
						goto l1;
					}
					addEdgeToGET(object);
					goto l1;
				}
				if ((((objBuffer[object + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWideMask) == GEPrimitiveBezier) {
					/* begin checkedAddBezierToGET: */
					if (((objBuffer[object + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWide) {
						lineWidth = objBuffer[object + GBWideExtent];
					}
					else {
						lineWidth = 0;
					}
					if (((objBuffer[object + GBEndY]) + lineWidth) < (workBuffer[GWFillMinY])) {
						goto l1;
					}
					if ((((objBuffer[object + GEXValue]) - lineWidth) >= (workBuffer[GWFillMaxX]))
					 && (((objBuffer[object + GBEndX]) - lineWidth) >= (workBuffer[GWFillMaxX]))) {
						goto l1;
					}
					addEdgeToGET(object);
					goto l1;
				}
				addEdgeToGET(object);
l1:	/* end checkedAddEdgeToGET: */;
			}
		}
		object += objBuffer[object + GEObjectLength];
	}
	return 0;
}


/*	Display the span buffer at the current scan line. */

	/* BalloonEngineBase>>#displaySpanBufferAt: */
static sqInt
displaySpanBufferAt(sqInt y)
{
    int targetX0;
    int targetX1;
    sqInt targetY;


	/* self aaLevelGet > 1 ifTrue:[self adjustAALevel]. */
	targetX0 = ((usqInt)((workBuffer[GWSpanStart]))) >> (workBuffer[GWAAShift]);
	if (targetX0 < (workBuffer[GWClipMinX])) {
		targetX0 = workBuffer[GWClipMinX];
	}
	targetX1 = ((usqInt)((((workBuffer[GWSpanEnd]) + (workBuffer[GWAALevel])) - 1))) >> (workBuffer[GWAAShift]);
	if (targetX1 > (workBuffer[GWClipMaxX])) {
		targetX1 = workBuffer[GWClipMaxX];
	}
	targetY = ((usqInt)(y)) >> (workBuffer[GWAAShift]);
	if ((targetY < (workBuffer[GWClipMinY]))
	 || ((targetY >= (workBuffer[GWClipMaxY]))
	 || ((targetX1 < (workBuffer[GWClipMinX]))
	 || (targetX0 >= (workBuffer[GWClipMaxX]))))) {
		return 0;
	}
	copyBitsFromtoat(targetX0, targetX1, targetY);
	return 0;
}

	/* BalloonEnginePlugin>>#fillBitmapSpanAA:from:to:at: */
static sqInt
fillBitmapSpanAAfromtoat(sqInt bmFill, sqInt leftX, sqInt rightX, sqInt yValue)
{
    sqInt a;
    int aaLevel;
    usqInt b;
    int baseShift;
    int *bits;
    int bmDepth;
    int bmHeight;
    int bmRaster;
    int bmWidth;
    unsigned int cMask;
    sqInt cMaskSqInt;
    int cShift;
    sqInt deltaX;
    sqInt deltaY;
    sqInt ds;
    int dsX;
    sqInt dt;
    int dtX;
    sqInt fillValue;
    sqInt firstPixel;
    sqInt firstPixelSqInt;
    usqInt g;
    sqInt idx;
    sqInt lastPixel;
    sqInt newDelta;
    sqInt newDeltaSqInt;
    usqInt r;
    int rShift;
    int tileFlag;
    int value;
    sqInt x;
    sqInt xp;
    sqInt yp;

	bits = loadBitsFrom(bmFill);
	if (!bits) {
		return null;
	}
	bmWidth = objBuffer[bmFill + GBBitmapWidth];
	bmHeight = objBuffer[bmFill + GBBitmapHeight];
	tileFlag = (objBuffer[bmFill + GBTileFlag]) == 1;
	deltaX = leftX - (objBuffer[bmFill + GFOriginX]);
	deltaY = yValue - (objBuffer[bmFill + GFOriginY]);
	dsX = objBuffer[bmFill + GFDirectionX];
	dtX = objBuffer[bmFill + GFNormalX];
	ds = (deltaX * dsX) + (deltaY * (objBuffer[bmFill + GFDirectionY]));
	dt = (deltaX * dtX) + (deltaY * (objBuffer[bmFill + GFNormalY]));
	aaLevel = workBuffer[GWAALevel];

	/* begin aaFirstPixelFrom:to: */
	firstPixelSqInt = ((leftX + (workBuffer[GWAALevel])) - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if (firstPixelSqInt > rightX) {
		firstPixel = rightX;
	}
	else {
		firstPixel = firstPixelSqInt;
	}
	lastPixel = (rightX - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	baseShift = workBuffer[GWAAShift];
	cMask = workBuffer[GWAAColorMask];
	cShift = workBuffer[GWAAColorShift];
	x = leftX;
	while (x < firstPixel) {
		if (tileFlag) {
			/* begin repeatValue:max: */
			newDelta = ds;
			while (newDelta < 0) {
				newDelta += (((usqInt)(bmWidth) << 16));
			}
			while (newDelta >= ((((usqInt)(bmWidth) << 16)))) {
				newDelta -= (((usqInt)(bmWidth) << 16));
			}
			ds = newDelta;

			/* begin repeatValue:max: */
			newDeltaSqInt = dt;
			while (newDeltaSqInt < 0) {
				newDeltaSqInt += (((usqInt)(bmHeight) << 16));
			}
			while (newDeltaSqInt >= ((((usqInt)(bmHeight) << 16)))) {
				newDeltaSqInt -= (((usqInt)(bmHeight) << 16));
			}
			dt = newDeltaSqInt;
		}
		xp = ds / 0x10000;
		yp = dt / 0x10000;
		if (!tileFlag) {
			/* begin clampValue:max: */
			if (xp < 0) {
				xp = 0;
			}
			else {
				if (xp >= bmWidth) {
					xp = bmWidth - 1;
				}
				else {
				}
			}

			/* begin clampValue:max: */
			if (yp < 0) {
				yp = 0;
			}
			else {
				if (yp >= bmHeight) {
					yp = bmHeight - 1;
				}
				else {
				}
			}
		}
		if ((xp >= 0)
		 && ((yp >= 0)
		 && ((xp < bmWidth)
		 && (yp < bmHeight)))) {
			/* begin bitmapValue:bits:atX:y: */
			bmDepth = objBuffer[bmFill + GBBitmapDepth];
			bmRaster = objBuffer[bmFill + GBBitmapRaster];
			if (bmDepth == 32) {
				value = (((int *) bits))[(bmRaster * yp) + xp];
				if ((value != 0)
				 && ((value & 0xFF000000U) == 0)) {
					value = value | 0xFF000000U;
				}
				fillValue = uncheckedTransformColor(value);
				goto l1;
			}
			rShift = (rShiftTable())[bmDepth];

			/* cMask - mask out the pixel from the word */
			value = (((int *) bits))[(bmRaster * yp) + (((usqInt)(xp)) >> rShift)];

			/* rShift - shift value to move the pixel in the word to the lowest bit position */
			cMaskSqInt = (1U << bmDepth) - 1;
			rShift = (32 - bmDepth) - ((xp & ((1U << rShift) - 1)) * bmDepth);
			value = (((usqInt)(value)) >> rShift) & cMaskSqInt;
			if (bmDepth == 16) {

				/* Must convert by expanding bits */
				if (value) {
					b = (((usqInt)((value & 0x1F)) << 3));
					b += (b) >> 5;
					g = (((usqInt)(((((usqInt)(value)) >> 5) & 0x1F)) << 3));
					g += (g) >> 5;
					r = (((usqInt)(((((usqInt)(value)) >> 10) & 0x1F)) << 3));
					r += (r) >> 5;
					a = 0xFF;
					value = ((b + ((g << 8))) + ((r << 16))) + ((((usqInt)(a) << 24)));
				}
			}
			else {

				/* Must convert by using color map */
				if (objBuffer[bmFill + GBColormapSize]) {
					value = ((objBuffer + bmFill) + GBColormapOffset)[value];
				}
				else {
					value = 0;
				}
			}
			fillValue = uncheckedTransformColor(value);
l1:	/* end bitmapValue:bits:atX:y: */;
			fillValue = ((usqInt)((fillValue & cMask))) >> cShift;
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + fillValue);
		}
		ds += dsX;
		dt += dtX;
		x += 1;
	}
	cMask = (((usqInt)((workBuffer[GWAAColorMask]))) >> (workBuffer[GWAAShift])) | 0xF0F0F0F0U;
	cShift = workBuffer[GWAAShift];
	while (x < lastPixel) {
		if (tileFlag) {
			/* begin repeatValue:max: */
			newDelta = ds;
			while (newDelta < 0) {
				newDelta += (((usqInt)(bmWidth) << 16));
			}
			while (newDelta >= ((((usqInt)(bmWidth) << 16)))) {
				newDelta -= (((usqInt)(bmWidth) << 16));
			}
			ds = newDelta;

			/* begin repeatValue:max: */
			newDeltaSqInt = dt;
			while (newDeltaSqInt < 0) {
				newDeltaSqInt += (((usqInt)(bmHeight) << 16));
			}
			while (newDeltaSqInt >= ((((usqInt)(bmHeight) << 16)))) {
				newDeltaSqInt -= (((usqInt)(bmHeight) << 16));
			}
			dt = newDeltaSqInt;
		}
		xp = ds / 0x10000;
		yp = dt / 0x10000;
		if (!tileFlag) {
			/* begin clampValue:max: */
			if (xp < 0) {
				xp = 0;
			}
			else {
				if (xp >= bmWidth) {
					xp = bmWidth - 1;
				}
				else {
				}
			}

			/* begin clampValue:max: */
			if (yp < 0) {
				yp = 0;
			}
			else {
				if (yp >= bmHeight) {
					yp = bmHeight - 1;
				}
				else {
				}
			}
		}
		if ((xp >= 0)
		 && ((yp >= 0)
		 && ((xp < bmWidth)
		 && (yp < bmHeight)))) {
			/* begin bitmapValue:bits:atX:y: */
			bmDepth = objBuffer[bmFill + GBBitmapDepth];
			bmRaster = objBuffer[bmFill + GBBitmapRaster];
			if (bmDepth == 32) {
				value = (((int *) bits))[(bmRaster * yp) + xp];
				if ((value != 0)
				 && ((value & 0xFF000000U) == 0)) {
					value = value | 0xFF000000U;
				}
				fillValue = uncheckedTransformColor(value);
				goto l2;
			}
			rShift = (rShiftTable())[bmDepth];

			/* cMask - mask out the pixel from the word */
			value = (((int *) bits))[(bmRaster * yp) + (((usqInt)(xp)) >> rShift)];

			/* rShift - shift value to move the pixel in the word to the lowest bit position */
			cMaskSqInt = (1U << bmDepth) - 1;
			rShift = (32 - bmDepth) - ((xp & ((1U << rShift) - 1)) * bmDepth);
			value = (((usqInt)(value)) >> rShift) & cMaskSqInt;
			if (bmDepth == 16) {

				/* Must convert by expanding bits */
				if (value) {
					b = (((usqInt)((value & 0x1F)) << 3));
					b += (b) >> 5;
					g = (((usqInt)(((((usqInt)(value)) >> 5) & 0x1F)) << 3));
					g += (g) >> 5;
					r = (((usqInt)(((((usqInt)(value)) >> 10) & 0x1F)) << 3));
					r += (r) >> 5;
					a = 0xFF;
					value = ((b + ((g << 8))) + ((r << 16))) + ((((usqInt)(a) << 24)));
				}
			}
			else {

				/* Must convert by using color map */
				if (objBuffer[bmFill + GBColormapSize]) {
					value = ((objBuffer + bmFill) + GBColormapOffset)[value];
				}
				else {
					value = 0;
				}
			}
			fillValue = uncheckedTransformColor(value);
l2:	/* end bitmapValue:bits:atX:y: */;
			fillValue = ((usqInt)((fillValue & cMask))) >> cShift;
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + fillValue);
		}
		ds += (((usqInt)(dsX) << cShift));
		dt += (((usqInt)(dtX) << cShift));
		x += aaLevel;
	}
	cMask = workBuffer[GWAAColorMask];
	cShift = workBuffer[GWAAColorShift];
	while (x < rightX) {
		if (tileFlag) {
			/* begin repeatValue:max: */
			newDelta = ds;
			while (newDelta < 0) {
				newDelta += (((usqInt)(bmWidth) << 16));
			}
			while (newDelta >= ((((usqInt)(bmWidth) << 16)))) {
				newDelta -= (((usqInt)(bmWidth) << 16));
			}
			ds = newDelta;

			/* begin repeatValue:max: */
			newDeltaSqInt = dt;
			while (newDeltaSqInt < 0) {
				newDeltaSqInt += (((usqInt)(bmHeight) << 16));
			}
			while (newDeltaSqInt >= ((((usqInt)(bmHeight) << 16)))) {
				newDeltaSqInt -= (((usqInt)(bmHeight) << 16));
			}
			dt = newDeltaSqInt;
		}
		xp = ds / 0x10000;
		yp = dt / 0x10000;
		if (!tileFlag) {
			/* begin clampValue:max: */
			if (xp < 0) {
				xp = 0;
			}
			else {
				if (xp >= bmWidth) {
					xp = bmWidth - 1;
				}
				else {
				}
			}

			/* begin clampValue:max: */
			if (yp < 0) {
				yp = 0;
			}
			else {
				if (yp >= bmHeight) {
					yp = bmHeight - 1;
				}
				else {
				}
			}
		}
		if ((xp >= 0)
		 && ((yp >= 0)
		 && ((xp < bmWidth)
		 && (yp < bmHeight)))) {
			/* begin bitmapValue:bits:atX:y: */
			bmDepth = objBuffer[bmFill + GBBitmapDepth];
			bmRaster = objBuffer[bmFill + GBBitmapRaster];
			if (bmDepth == 32) {
				value = (((int *) bits))[(bmRaster * yp) + xp];
				if ((value != 0)
				 && ((value & 0xFF000000U) == 0)) {
					value = value | 0xFF000000U;
				}
				fillValue = uncheckedTransformColor(value);
				goto l3;
			}
			rShift = (rShiftTable())[bmDepth];

			/* cMask - mask out the pixel from the word */
			value = (((int *) bits))[(bmRaster * yp) + (((usqInt)(xp)) >> rShift)];

			/* rShift - shift value to move the pixel in the word to the lowest bit position */
			cMaskSqInt = (1U << bmDepth) - 1;
			rShift = (32 - bmDepth) - ((xp & ((1U << rShift) - 1)) * bmDepth);
			value = (((usqInt)(value)) >> rShift) & cMaskSqInt;
			if (bmDepth == 16) {

				/* Must convert by expanding bits */
				if (value) {
					b = (((usqInt)((value & 0x1F)) << 3));
					b += (b) >> 5;
					g = (((usqInt)(((((usqInt)(value)) >> 5) & 0x1F)) << 3));
					g += (g) >> 5;
					r = (((usqInt)(((((usqInt)(value)) >> 10) & 0x1F)) << 3));
					r += (r) >> 5;
					a = 0xFF;
					value = ((b + ((g << 8))) + ((r << 16))) + ((((usqInt)(a) << 24)));
				}
			}
			else {

				/* Must convert by using color map */
				if (objBuffer[bmFill + GBColormapSize]) {
					value = ((objBuffer + bmFill) + GBColormapOffset)[value];
				}
				else {
					value = 0;
				}
			}
			fillValue = uncheckedTransformColor(value);
l3:	/* end bitmapValue:bits:atX:y: */;
			fillValue = ((usqInt)((fillValue & cMask))) >> cShift;
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + fillValue);
		}
		ds += dsX;
		dt += dtX;
		x += 1;
	}
	return 0;
}


/*	Fill the span buffer between leftEdge and rightEdge using the given bits.
	Note: We always start from zero - this avoids using huge bitmap buffers if
	the bitmap is to be displayed at the very far right hand side and also
	gives us a chance of using certain bitmaps (e.g., those with depth 32)
	directly. 
 */

	/* BalloonEngineBase>>#fillBitmapSpan:from:to: */
static sqInt
fillBitmapSpanfromto(int *bits, sqInt leftX, sqInt rightX)
{
    int baseShift;
    sqInt bitX;
    int colorMask;
    int colorShift;
    sqInt fillValue;
    sqInt x;
    sqInt x0;
    sqInt x1;

	x0 = leftX;
	x1 = rightX;

	/* Hack for pre-increment */
	bitX = -1;
	if ((workBuffer[GWAALevel]) == 1) {

		/* Speedy version for no anti-aliasing */
		while (x0 < x1) {
			fillValue = (((int *) bits))[(bitX += 1)];
			spanBuffer[x0] = fillValue;
			x0 += 1;
		}
	}
	else {

		/* Generic version with anti-aliasing */
		colorMask = workBuffer[GWAAColorMask];
		colorShift = workBuffer[GWAAColorShift];
		baseShift = workBuffer[GWAAShift];
		while (x0 < x1) {
			x = ((usqInt)(x0)) >> baseShift;
			fillValue = (((int *) bits))[(bitX += 1)];
			fillValue = ((usqInt)((fillValue & colorMask))) >> colorShift;
			spanBuffer[x] = ((spanBuffer[x]) + fillValue);
			x0 += 1;
		}
	}
	if (x1 > (workBuffer[GWSpanEnd])) {
		/* spanEndPut: */
		workBuffer[GWSpanEnd] = x1;
	}
	if (x1 > (workBuffer[GWSpanEndAA])) {
		/* spanEndAAPut: */
		workBuffer[GWSpanEndAA] = x1;
	}
	return 0;
}

	/* BalloonEnginePlugin>>#fillBitmapSpan:from:to:at: */
static sqInt
fillBitmapSpanfromtoat(sqInt bmFill, sqInt leftX, sqInt rightX, sqInt yValue)
{
    sqInt a;
    usqInt b;
    int *bits;
    int bmDepth;
    int bmHeight;
    int bmRaster;
    int bmWidth;
    sqInt cMask;
    sqInt deltaX;
    sqInt deltaY;
    sqInt ds;
    int dsX;
    sqInt dt;
    int dtX;
    sqInt fillValue;
    usqInt g;
    sqInt newDelta;
    sqInt newDeltaSqInt;
    usqInt r;
    int rShift;
    int tileFlag;
    int value;
    sqInt x;
    sqInt x1;
    sqInt xp;
    sqInt yp;

	if (!((workBuffer[GWAALevel]) == 1)) {
		return fillBitmapSpanAAfromtoat(bmFill, leftX, rightX, yValue);
	}
	bits = loadBitsFrom(bmFill);
	if (!bits) {
		return null;
	}
	bmWidth = objBuffer[bmFill + GBBitmapWidth];
	bmHeight = objBuffer[bmFill + GBBitmapHeight];
	tileFlag = (objBuffer[bmFill + GBTileFlag]) == 1;
	deltaX = leftX - (objBuffer[bmFill + GFOriginX]);
	deltaY = yValue - (objBuffer[bmFill + GFOriginY]);
	dsX = objBuffer[bmFill + GFDirectionX];
	dtX = objBuffer[bmFill + GFNormalX];
	ds = (deltaX * dsX) + (deltaY * (objBuffer[bmFill + GFDirectionY]));
	dt = (deltaX * dtX) + (deltaY * (objBuffer[bmFill + GFNormalY]));
	x = leftX;
	x1 = rightX;
	while (x < x1) {
		if (tileFlag) {
			/* begin repeatValue:max: */
			newDelta = ds;
			while (newDelta < 0) {
				newDelta += (((usqInt)(bmWidth) << 16));
			}
			while (newDelta >= ((((usqInt)(bmWidth) << 16)))) {
				newDelta -= (((usqInt)(bmWidth) << 16));
			}
			ds = newDelta;

			/* begin repeatValue:max: */
			newDeltaSqInt = dt;
			while (newDeltaSqInt < 0) {
				newDeltaSqInt += (((usqInt)(bmHeight) << 16));
			}
			while (newDeltaSqInt >= ((((usqInt)(bmHeight) << 16)))) {
				newDeltaSqInt -= (((usqInt)(bmHeight) << 16));
			}
			dt = newDeltaSqInt;
		}
		xp = ds / 0x10000;
		yp = dt / 0x10000;
		if (!tileFlag) {
			/* begin clampValue:max: */
			if (xp < 0) {
				xp = 0;
			}
			else {
				if (xp >= bmWidth) {
					xp = bmWidth - 1;
				}
				else {
				}
			}

			/* begin clampValue:max: */
			if (yp < 0) {
				yp = 0;
			}
			else {
				if (yp >= bmHeight) {
					yp = bmHeight - 1;
				}
				else {
				}
			}
		}
		if ((xp >= 0)
		 && ((yp >= 0)
		 && ((xp < bmWidth)
		 && (yp < bmHeight)))) {
			/* begin bitmapValue:bits:atX:y: */
			bmDepth = objBuffer[bmFill + GBBitmapDepth];
			bmRaster = objBuffer[bmFill + GBBitmapRaster];
			if (bmDepth == 32) {
				value = (((int *) bits))[(bmRaster * yp) + xp];
				if ((value != 0)
				 && ((value & 0xFF000000U) == 0)) {
					value = value | 0xFF000000U;
				}
				fillValue = uncheckedTransformColor(value);
				goto l1;
			}
			rShift = (rShiftTable())[bmDepth];

			/* cMask - mask out the pixel from the word */
			value = (((int *) bits))[(bmRaster * yp) + (((usqInt)(xp)) >> rShift)];

			/* rShift - shift value to move the pixel in the word to the lowest bit position */
			cMask = (1U << bmDepth) - 1;
			rShift = (32 - bmDepth) - ((xp & ((1U << rShift) - 1)) * bmDepth);
			value = (((usqInt)(value)) >> rShift) & cMask;
			if (bmDepth == 16) {

				/* Must convert by expanding bits */
				if (value) {
					b = (((usqInt)((value & 0x1F)) << 3));
					b += (b) >> 5;
					g = (((usqInt)(((((usqInt)(value)) >> 5) & 0x1F)) << 3));
					g += (g) >> 5;
					r = (((usqInt)(((((usqInt)(value)) >> 10) & 0x1F)) << 3));
					r += (r) >> 5;
					a = 0xFF;
					value = ((b + ((g << 8))) + ((r << 16))) + ((((usqInt)(a) << 24)));
				}
			}
			else {

				/* Must convert by using color map */
				if (objBuffer[bmFill + GBColormapSize]) {
					value = ((objBuffer + bmFill) + GBColormapOffset)[value];
				}
				else {
					value = 0;
				}
			}
			fillValue = uncheckedTransformColor(value);
l1:	/* end bitmapValue:bits:atX:y: */;
			spanBuffer[x] = fillValue;
		}
		ds += dsX;
		dt += dtX;
		x += 1;
	}
	return 0;
}


/*	This is the inner loop for solid color fills with anti-aliasing.
	This loop has been unrolled for speed and quality into three parts:
	a) copy all pixels that fall into the first full pixel.
	b) copy aaLevel pixels between the first and the last full pixel
	c) copy all pixels that fall in the last full pixel */

	/* BalloonEngineBase>>#fillColorSpanAA:x0:x1: */
static sqInt
fillColorSpanAAx0x1(sqInt pixelValue32, sqInt leftX, sqInt rightX)
{
    int aaLevel;
    int baseShift;
    unsigned int colorMask;
    sqInt firstPixel;
    sqInt firstPixelSqInt;
    sqInt idx;
    sqInt lastPixel;
    sqInt pv32;
    sqInt x;


	/* Not now -- maybe later */
	/* Compute the pixel boundaries. */
	/* begin aaFirstPixelFrom:to: */
	firstPixelSqInt = ((leftX + (workBuffer[GWAALevel])) - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if (firstPixelSqInt > rightX) {
		firstPixel = rightX;
	}
	else {
		firstPixel = firstPixelSqInt;
	}
	lastPixel = (rightX - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	aaLevel = workBuffer[GWAALevel];
	baseShift = workBuffer[GWAAShift];

	/* Part a: Deal with the first n sub-pixels */
	x = leftX;
	if (x < firstPixel) {
		pv32 = ((usqInt)((pixelValue32 & (workBuffer[GWAAColorMask])))) >> (workBuffer[GWAAColorShift]);
		while (x < firstPixel) {
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + pv32);
			x += 1;
		}
	}
	if (x < lastPixel) {
		colorMask = (((usqInt)((workBuffer[GWAAColorMask]))) >> (workBuffer[GWAAShift])) | 0xF0F0F0F0U;
		pv32 = ((usqInt)((pixelValue32 & colorMask))) >> (workBuffer[GWAAShift]);
		while (x < lastPixel) {
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + pv32);
			x += aaLevel;
		}
	}
	if (x < rightX) {
		pv32 = ((usqInt)((pixelValue32 & (workBuffer[GWAAColorMask])))) >> (workBuffer[GWAAColorShift]);
		while (x < rightX) {
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + pv32);
			x += 1;
		}
	}
	return 0;
}


/*	This is the AA version of linear gradient filling. */

	/* BalloonEnginePlugin>>#fillLinearGradientAA:ramp:ds:dsX:from:to: */
static sqInt
fillLinearGradientAArampdsdsXfromto(sqInt fill, int *ramp, sqInt deltaS, sqInt dsX, sqInt leftX, sqInt rightX)
{
    int aaLevel;
    int baseShift;
    unsigned int colorMask;
    int colorShift;
    sqInt ds;
    sqInt firstPixel;
    sqInt firstPixelSqInt;
    sqInt idx;
    sqInt lastPixel;
    sqInt rampIndex;
    int rampSize;
    sqInt rampValue;
    sqInt x;

	aaLevel = workBuffer[GWAALevel];
	baseShift = workBuffer[GWAAShift];
	rampSize = objBuffer[fill + GFRampLength];
	ds = deltaS;
	x = leftX;
	rampIndex = ds / 0x10000;

	/* begin aaFirstPixelFrom:to: */
	firstPixelSqInt = ((leftX + (workBuffer[GWAALevel])) - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if (firstPixelSqInt > rightX) {
		firstPixel = rightX;
	}
	else {
		firstPixel = firstPixelSqInt;
	}

	/* Deal with the first n sub-pixels */
	lastPixel = (rightX - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	colorMask = workBuffer[GWAAColorMask];
	colorShift = workBuffer[GWAAColorShift];
	while ((x < firstPixel)
	 && ((rampIndex < rampSize)
	 && (rampIndex >= 0))) {
		rampValue = (((int *) ramp))[rampIndex];

		/* Copy as many pixels as possible */
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while ((x < firstPixel)
		 && ((ds / 0x10000) == rampIndex)) {
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + rampValue);
			x += 1;
			ds += dsX;
		}
		rampIndex = ds / 0x10000;
	}
	colorMask = (((usqInt)((workBuffer[GWAAColorMask]))) >> (workBuffer[GWAAShift])) | 0xF0F0F0F0U;
	colorShift = workBuffer[GWAAShift];
	while ((x < lastPixel)
	 && ((rampIndex < rampSize)
	 && (rampIndex >= 0))) {
		rampValue = (((int *) ramp))[rampIndex];

		/* Copy as many pixels as possible */
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while ((x < lastPixel)
		 && ((ds / 0x10000) == rampIndex)) {
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + rampValue);
			x += aaLevel;
			ds += (((usqInt)(dsX) << colorShift));
		}
		rampIndex = ds / 0x10000;
	}
	colorMask = workBuffer[GWAAColorMask];
	colorShift = workBuffer[GWAAColorShift];
	while ((x < rightX)
	 && ((rampIndex < rampSize)
	 && (rampIndex >= 0))) {
		rampValue = (((int *) ramp))[rampIndex];

		/* Copy as many pixels as possible */
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while ((x < rightX)
		 && ((ds / 0x10000) == rampIndex)) {
			idx = ((usqInt)(x)) >> baseShift;
			spanBuffer[idx] = ((spanBuffer[idx]) + rampValue);
			x += 1;
			ds += dsX;
		}
		rampIndex = ds / 0x10000;
	}
	return x;
}


/*	Draw a linear gradient fill. */

	/* BalloonEnginePlugin>>#fillLinearGradient:from:to:at: */
static sqInt
fillLinearGradientfromtoat(sqInt fill, sqInt leftX, sqInt rightX, sqInt yValue)
{
    sqInt ds;
    int dsX;
    int *ramp;
    sqInt rampIndex;
    int rampSize;
    sqInt x;
    sqInt x0;
    sqInt x0SqInt;
    sqInt x1;

	rampIndex = 0;
	ramp = (objBuffer + fill) + GFRampOffset;
	rampSize = objBuffer[fill + GFRampLength];
	dsX = objBuffer[fill + GFDirectionX];
	ds = ((leftX - (objBuffer[fill + GFOriginX])) * dsX) + ((yValue - (objBuffer[fill + GFOriginY])) * (objBuffer[fill + GFDirectionY]));
	x = (x0 = leftX);

	/* Note: The inner loop has been divided into three parts for speed */
	/* Part one: Fill everything outside the left boundary */
	x1 = rightX;
	while (((((rampIndex = ds / 0x10000)) < 0)
	 || (rampIndex >= rampSize))
	 && (x < x1)) {
		x += 1;
		ds += dsX;
	}
	if (x > x0) {
		if (rampIndex < 0) {
			rampIndex = 0;
		}
		if (rampIndex >= rampSize) {
			rampIndex = rampSize - 1;
		}

		/* begin fillColorSpan:from:to: */
		if (!((workBuffer[GWAALevel]) == 1)) {
			fillColorSpanAAx0x1(ramp[rampIndex], x0, x);
			goto l1;
		}

		/* Unroll the inner loop four times, since we're only storing data. */
		x0SqInt = x0;
		while ((x0SqInt + 4) < x) {
			spanBuffer[x0SqInt] = (ramp[rampIndex]);
			spanBuffer[x0SqInt + 1] = (ramp[rampIndex]);
			spanBuffer[x0SqInt + 2] = (ramp[rampIndex]);
			spanBuffer[x0SqInt + 3] = (ramp[rampIndex]);
			x0SqInt += 4;
		}
		while (x0SqInt < x) {
			spanBuffer[x0SqInt] = (ramp[rampIndex]);
			x0SqInt += 1;
		}
l1:	/* end fillColorSpan:from:to: */;
	}
	if ((workBuffer[GWAALevel]) == 1) {

		/* Fast version w/o anti-aliasing */
		while (((((rampIndex = ds / 0x10000)) < rampSize)
		 && (rampIndex >= 0))
		 && (x < x1)) {
			spanBuffer[x] = (ramp[rampIndex]);
			x += 1;
			ds += dsX;
		}
	}
	else {
		x = fillLinearGradientAArampdsdsXfromto(fill, ramp, ds, dsX, x, rightX);
	}
	if (x < x1) {
		if (rampIndex < 0) {
			rampIndex = 0;
		}
		if (rampIndex >= rampSize) {
			rampIndex = rampSize - 1;
		}

		/* begin fillColorSpan:from:to: */
		if (!((workBuffer[GWAALevel]) == 1)) {
			fillColorSpanAAx0x1(ramp[rampIndex], x, x1);
			goto l2;
		}

		/* Unroll the inner loop four times, since we're only storing data. */
		x0SqInt = x;
		while ((x0SqInt + 4) < x1) {
			spanBuffer[x0SqInt] = (ramp[rampIndex]);
			spanBuffer[x0SqInt + 1] = (ramp[rampIndex]);
			spanBuffer[x0SqInt + 2] = (ramp[rampIndex]);
			spanBuffer[x0SqInt + 3] = (ramp[rampIndex]);
			x0SqInt += 4;
		}
		while (x0SqInt < x1) {
			spanBuffer[x0SqInt] = (ramp[rampIndex]);
			x0SqInt += 1;
		}
l2:	/* end fillColorSpan:from:to: */;
	}
	return 0;
}


/*	Part 2a) Compute the decreasing part of the ramp */

	/* BalloonEnginePlugin>>#fillRadialDecreasingAA:ramp:deltaST:dsX:dtX:from:to: */
static sqInt
fillRadialDecreasingAArampdeltaSTdsXdtXfromto(sqInt fill, int *ramp, int *deltaST, sqInt dsX, sqInt dtX, sqInt leftX, sqInt rightX)
{
    int aaLevel;
    int baseShift;
    unsigned int colorMask;
    int colorShift;
    int ds;
    int dt;
    sqInt firstPixel;
    sqInt firstPixelSqInt;
    sqInt index;
    sqInt lastPixel;
    sqInt length2;
    sqInt nextLength;
    sqInt rampIndex;
    sqInt rampValue;
    sqInt x;
    sqInt x1;

	ds = (*((int *) deltaST));
	dt = (((int *) deltaST))[1];
	aaLevel = workBuffer[GWAALevel];
	baseShift = workBuffer[GWAAShift];
	rampIndex = accurateLengthOfwith(ds / 0x10000, dt / 0x10000);
	length2 = (rampIndex - 1) * (rampIndex - 1);
	x = leftX;
	x1 = objBuffer[fill + GFOriginX];
	if (x1 > rightX) {
		x1 = rightX;
	}

	/* begin aaFirstPixelFrom:to: */
	firstPixelSqInt = ((leftX + (workBuffer[GWAALevel])) - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if (firstPixelSqInt > x1) {
		firstPixel = x1;
	}
	else {
		firstPixel = firstPixelSqInt;
	}

	/* Deal with the first n sub-pixels */
	lastPixel = (x1 - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if (x < firstPixel) {
		colorMask = workBuffer[GWAAColorMask];
		colorShift = workBuffer[GWAAColorShift];
		rampValue = (((int *) ramp))[rampIndex];
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while (x < firstPixel) {

			/* Try to copy the current value more than just once */
			while ((x < firstPixel)
			 && ((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) >= length2)) {
				index = ((usqInt)(x)) >> baseShift;
				spanBuffer[index] = ((spanBuffer[index]) + rampValue);
				x += 1;
				ds += dsX;
				dt += dtX;
			}
			nextLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
			while (nextLength < length2) {
				rampIndex -= 1;
				rampValue = (((int *) ramp))[rampIndex];
				rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
				length2 = (rampIndex - 1) * (rampIndex - 1);
			}
		}
	}
	if (x < lastPixel) {
		colorMask = (((usqInt)((workBuffer[GWAAColorMask]))) >> (workBuffer[GWAAShift])) | 0xF0F0F0F0U;
		colorShift = workBuffer[GWAAShift];
		rampValue = (((int *) ramp))[rampIndex];
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while (x < lastPixel) {

			/* Try to copy the current value more than just once */
			while ((x < lastPixel)
			 && ((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) >= length2)) {
				index = ((usqInt)(x)) >> baseShift;
				spanBuffer[index] = ((spanBuffer[index]) + rampValue);
				x += aaLevel;
				ds += (((usqInt)(dsX) << colorShift));
				dt += (((usqInt)(dtX) << colorShift));
			}
			nextLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
			while (nextLength < length2) {
				rampIndex -= 1;
				rampValue = (((int *) ramp))[rampIndex];
				rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
				length2 = (rampIndex - 1) * (rampIndex - 1);
			}
		}
	}
	if (x < x1) {
		colorMask = workBuffer[GWAAColorMask];
		colorShift = workBuffer[GWAAColorShift];
		rampValue = (((int *) ramp))[rampIndex];
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while (x < x1) {

			/* Try to copy the current value more than just once */
			while ((x < x1)
			 && ((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) >= length2)) {
				index = ((usqInt)(x)) >> baseShift;
				spanBuffer[index] = ((spanBuffer[index]) + rampValue);
				x += 1;
				ds += dsX;
				dt += dtX;
			}
			nextLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
			while (nextLength < length2) {
				rampIndex -= 1;
				rampValue = (((int *) ramp))[rampIndex];
				rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
				length2 = (rampIndex - 1) * (rampIndex - 1);
			}
		}
	}
	(*((int *) deltaST) = ds);
	(((int *) deltaST))[1] = dt;
	return x;
}


/*	Draw a radial gradient fill. */

	/* BalloonEnginePlugin>>#fillRadialGradient:from:to:at: */
static sqInt
fillRadialGradientfromtoat(sqInt fill, sqInt leftX, sqInt rightX, sqInt yValue)
{
    int *deltaST;
    sqInt deltaX;
    sqInt deltaY;
    sqInt ds;
    int dsInt;
    int dsX;
    sqInt dt;
    int dtInt;
    int dtX;
    sqInt lastLength;
    int length2;
    int length2Int;
    sqInt length2SqInt;
    sqInt nextLength;
    int *ramp;
    sqInt rampIndex;
    int rampSize;
    int rampSizeInt;
    sqInt rampValue;
    sqInt x;
    sqInt x0;
    sqInt x1;
    sqInt x1SqInt;
    sqInt xSqInt;

	ramp = (objBuffer + fill) + GFRampOffset;
	rampSize = objBuffer[fill + GFRampLength];
	deltaX = leftX - (objBuffer[fill + GFOriginX]);
	deltaY = yValue - (objBuffer[fill + GFOriginY]);
	dsX = objBuffer[fill + GFDirectionX];
	dtX = objBuffer[fill + GFNormalX];
	ds = (deltaX * dsX) + (deltaY * (objBuffer[fill + GFDirectionY]));
	dt = (deltaX * dtX) + (deltaY * (objBuffer[fill + GFNormalY]));
	x = leftX;

	/* Note: The inner loop has been divided into three parts for speed */
	/* Part one: Fill everything outside the left boundary */
	x1 = rightX;

	/* This is the upper bound */
	length2 = (rampSize - 1) * (rampSize - 1);
	while (((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) >= length2)
	 && (x < x1)) {
		x += 1;
		ds += dsX;
		dt += dtX;
	}
	if (x > leftX) {
		/* begin fillColorSpan:from:to: */
		if (!((workBuffer[GWAALevel]) == 1)) {
			fillColorSpanAAx0x1(ramp[rampSize - 1], leftX, x);
			goto l1;
		}

		/* Unroll the inner loop four times, since we're only storing data. */
		x0 = leftX;
		while ((x0 + 4) < x) {
			spanBuffer[x0] = (ramp[rampSize - 1]);
			spanBuffer[x0 + 1] = (ramp[rampSize - 1]);
			spanBuffer[x0 + 2] = (ramp[rampSize - 1]);
			spanBuffer[x0 + 3] = (ramp[rampSize - 1]);
			x0 += 4;
		}
		while (x0 < x) {
			spanBuffer[x0] = (ramp[rampSize - 1]);
			x0 += 1;
		}
l1:	/* end fillColorSpan:from:to: */;
	}
	deltaST = ((int *) (workBuffer + GWPoint1));
	deltaST[0] = ds;
	deltaST[1] = dt;
	if (x < (objBuffer[fill + GFOriginX])) {

		/* Draw the decreasing part */
		if ((workBuffer[GWAALevel]) == 1) {
			/* begin fillRadialDecreasing:ramp:deltaST:dsX:dtX:from:to: */
			dsInt = (*((int *) deltaST));
			dtInt = (((int *) deltaST))[1];
			rampIndex = accurateLengthOfwith(dsInt / 0x10000, dtInt / 0x10000);
			rampValue = (((int *) ramp))[rampIndex];
			length2SqInt = (rampIndex - 1) * (rampIndex - 1);
			xSqInt = x;
			x1SqInt = x1;
			if (x1SqInt > (objBuffer[fill + GFOriginX])) {
				x1SqInt = objBuffer[fill + GFOriginX];
			}
			while (xSqInt < x1SqInt) {

				/* Try to copy the current value more than just once */
				while ((xSqInt < x1SqInt)
				 && ((((dsInt / 0x10000) * (dsInt / 0x10000)) + ((dtInt / 0x10000) * (dtInt / 0x10000))) >= length2SqInt)) {
					spanBuffer[xSqInt] = rampValue;
					xSqInt += 1;
					dsInt += dsX;
					dtInt += dtX;
				}
				nextLength = ((dsInt / 0x10000) * (dsInt / 0x10000)) + ((dtInt / 0x10000) * (dtInt / 0x10000));
				while (nextLength < length2SqInt) {
					rampIndex -= 1;
					rampValue = (((int *) ramp))[rampIndex];
					length2SqInt = (rampIndex - 1) * (rampIndex - 1);
				}
			}
			(*((int *) deltaST) = dsInt);
			(((int *) deltaST))[1] = dtInt;
			x = xSqInt;
		}
		else {
			x = fillRadialDecreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1);
		}
	}
	if (x < x1) {

		/* Draw the increasing part */
		if ((workBuffer[GWAALevel]) == 1) {
			/* begin fillRadialIncreasing:ramp:deltaST:dsX:dtX:from:to: */
			dsInt = (*((int *) deltaST));
			dtInt = (((int *) deltaST))[1];
			rampIndex = accurateLengthOfwith(dsInt / 0x10000, dtInt / 0x10000);
			rampValue = (((int *) ramp))[rampIndex];
			rampSizeInt = objBuffer[fill + GFRampLength];

			/* This is the upper bound */
			length2Int = (rampSizeInt - 1) * (rampSizeInt - 1);
			nextLength = (rampIndex + 1) * (rampIndex + 1);
			lastLength = ((dsInt / 0x10000) * (dsInt / 0x10000)) + ((dtInt / 0x10000) * (dtInt / 0x10000));
			xSqInt = x;
			x1SqInt = x1;
			while ((xSqInt < x1SqInt)
			 && (lastLength < length2Int)) {

				/* Try to copy the current value more than once */
				while ((xSqInt < x1SqInt)
				 && ((((dsInt / 0x10000) * (dsInt / 0x10000)) + ((dtInt / 0x10000) * (dtInt / 0x10000))) <= nextLength)) {
					spanBuffer[xSqInt] = rampValue;
					xSqInt += 1;
					dsInt += dsX;
					dtInt += dtX;
				}
				lastLength = ((dsInt / 0x10000) * (dsInt / 0x10000)) + ((dtInt / 0x10000) * (dtInt / 0x10000));
				while (lastLength > nextLength) {
					rampIndex += 1;
					rampValue = (((int *) ramp))[rampIndex];
					nextLength = (rampIndex + 1) * (rampIndex + 1);
				}
			}
			(*((int *) deltaST) = dsInt);
			(((int *) deltaST))[1] = dtInt;
			x = xSqInt;
		}
		else {
			x = fillRadialIncreasingAArampdeltaSTdsXdtXfromto(fill, ramp, deltaST, dsX, dtX, x, x1);
		}
	}
	if (x < rightX) {
		/* begin fillColorSpan:from:to: */
		if (!((workBuffer[GWAALevel]) == 1)) {
			fillColorSpanAAx0x1(ramp[rampSize - 1], x, rightX);
			goto l2;
		}

		/* Unroll the inner loop four times, since we're only storing data. */
		x0 = x;
		while ((x0 + 4) < rightX) {
			spanBuffer[x0] = (ramp[rampSize - 1]);
			spanBuffer[x0 + 1] = (ramp[rampSize - 1]);
			spanBuffer[x0 + 2] = (ramp[rampSize - 1]);
			spanBuffer[x0 + 3] = (ramp[rampSize - 1]);
			x0 += 4;
		}
		while (x0 < rightX) {
			spanBuffer[x0] = (ramp[rampSize - 1]);
			x0 += 1;
		}
l2:	/* end fillColorSpan:from:to: */;
	}
	return 0;
}


/*	Part 2b) Compute the increasing part of the ramp */

	/* BalloonEnginePlugin>>#fillRadialIncreasingAA:ramp:deltaST:dsX:dtX:from:to: */
static sqInt
fillRadialIncreasingAArampdeltaSTdsXdtXfromto(sqInt fill, int *ramp, int *deltaST, sqInt dsX, sqInt dtX, sqInt leftX, sqInt rightX)
{
    int aaLevel;
    int baseShift;
    unsigned int colorMask;
    int colorShift;
    int ds;
    int dt;
    sqInt firstPixel;
    sqInt firstPixelSqInt;
    sqInt index;
    sqInt lastLength;
    sqInt lastPixel;
    int length2;
    sqInt nextLength;
    sqInt rampIndex;
    int rampSize;
    sqInt rampValue;
    sqInt x;

	ds = (*((int *) deltaST));
	dt = (((int *) deltaST))[1];
	aaLevel = workBuffer[GWAALevel];
	baseShift = workBuffer[GWAAShift];
	rampIndex = accurateLengthOfwith(ds / 0x10000, dt / 0x10000);
	rampSize = objBuffer[fill + GFRampLength];

	/* This is the upper bound */
	length2 = (rampSize - 1) * (rampSize - 1);
	nextLength = (rampIndex + 1) * (rampIndex + 1);
	lastLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
	x = leftX;

	/* begin aaFirstPixelFrom:to: */
	firstPixelSqInt = ((leftX + (workBuffer[GWAALevel])) - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if (firstPixelSqInt > rightX) {
		firstPixel = rightX;
	}
	else {
		firstPixel = firstPixelSqInt;
	}

	/* Deal with the first n subPixels */
	lastPixel = (rightX - 1) & ((unsigned int)~((workBuffer[GWAALevel]) - 1));
	if ((x < firstPixel)
	 && (lastLength < length2)) {
		colorMask = workBuffer[GWAAColorMask];
		colorShift = workBuffer[GWAAColorShift];
		rampValue = (((int *) ramp))[rampIndex];
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while ((x < firstPixel)
		 && (lastLength < length2)) {

			/* Try to copy the current value more than once */
			while ((x < firstPixel)
			 && ((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) <= nextLength)) {
				index = ((usqInt)(x)) >> baseShift;
				spanBuffer[index] = ((spanBuffer[index]) + rampValue);
				x += 1;
				ds += dsX;
				dt += dtX;
			}
			lastLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
			while (lastLength > nextLength) {
				rampIndex += 1;
				rampValue = (((int *) ramp))[rampIndex];
				rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
				nextLength = (rampIndex + 1) * (rampIndex + 1);
			}
		}
	}
	if ((x < lastPixel)
	 && (lastLength < length2)) {
		colorMask = (((usqInt)((workBuffer[GWAAColorMask]))) >> (workBuffer[GWAAShift])) | 0xF0F0F0F0U;
		colorShift = workBuffer[GWAAShift];
		rampValue = (((int *) ramp))[rampIndex];
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while ((x < lastPixel)
		 && (lastLength < length2)) {

			/* Try to copy the current value more than once */
			while ((x < lastPixel)
			 && ((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) <= nextLength)) {
				index = ((usqInt)(x)) >> baseShift;
				spanBuffer[index] = ((spanBuffer[index]) + rampValue);
				x += aaLevel;
				ds += (((usqInt)(dsX) << colorShift));
				dt += (((usqInt)(dtX) << colorShift));
			}
			lastLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
			while (lastLength > nextLength) {
				rampIndex += 1;
				rampValue = (((int *) ramp))[rampIndex];
				rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
				nextLength = (rampIndex + 1) * (rampIndex + 1);
			}
		}
	}
	if ((x < rightX)
	 && (lastLength < length2)) {
		colorMask = workBuffer[GWAAColorMask];
		colorShift = workBuffer[GWAAColorShift];
		rampValue = (((int *) ramp))[rampIndex];
		rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
		while ((x < rightX)
		 && (lastLength < length2)) {

			/* Try to copy the current value more than once */
			while ((x < rightX)
			 && ((((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000))) <= nextLength)) {
				index = ((usqInt)(x)) >> baseShift;
				spanBuffer[index] = ((spanBuffer[index]) + rampValue);
				x += 1;
				ds += dsX;
				dt += dtX;
			}
			lastLength = ((ds / 0x10000) * (ds / 0x10000)) + ((dt / 0x10000) * (dt / 0x10000));
			while (lastLength > nextLength) {
				rampIndex += 1;
				rampValue = (((int *) ramp))[rampIndex];
				rampValue = ((usqInt)((rampValue & colorMask))) >> colorShift;
				nextLength = (rampIndex + 1) * (rampIndex + 1);
			}
		}
	}
	(*((int *) deltaST) = ds);
	(((int *) deltaST))[1] = dt;
	return x;
}


/*	Return true if fillEntry1 should be drawn before fillEntry2 */

	/* BalloonEngineBase>>#fillSorts:before: */
static int
fillSortsbefore(sqInt fillEntry1, sqInt fillEntry2)
{
    int diff;


	/* First check the depth value */
	diff = (workBuffer[(workBuffer[GWBufferTop]) + (fillEntry1 + 1)]) - (workBuffer[(workBuffer[GWBufferTop]) + (fillEntry2 + 1)]);
	if (diff) {
		return diff > 0;
	}
	return (((unsigned) (workBuffer[(workBuffer[GWBufferTop]) + fillEntry1]))) < (((unsigned) (workBuffer[(workBuffer[GWBufferTop]) + fillEntry2])));
}


/*	Fill the span buffer from leftX to rightX with the given fill.
	Clip before performing any operations. Return true if the fill must
	be handled by some Smalltalk code. */

	/* BalloonEngineBase>>#fillSpan:from:to: */
static sqInt
fillSpanfromto(unsigned int fill, sqInt leftX, sqInt rightX)
{
    unsigned int type;
    sqInt x0;
    sqInt x0SqInt;
    sqInt x1;

	if (!fill) {
		return 0;
	}
	if (leftX < (workBuffer[GWSpanEndAA])) {
		x0 = workBuffer[GWSpanEndAA];
	}
	else {
		x0 = leftX;
	}
	if (rightX > ((((usqInt)((workBuffer[GWSpanSize])) << (workBuffer[GWAAShift]))))) {
		x1 = ((sqInt)((usqInt)((workBuffer[GWSpanSize])) << (workBuffer[GWAAShift])));
	}
	else {
		x1 = rightX;
	}
	if (x0 < (workBuffer[GWFillMinX])) {
		x0 = workBuffer[GWFillMinX];
	}
	if (x1 > (workBuffer[GWFillMaxX])) {
		x1 = workBuffer[GWFillMaxX];
	}
	if (x0 < (workBuffer[GWSpanStart])) {
		/* spanStartPut: */
		workBuffer[GWSpanStart] = x0;
	}
	if (x1 > (workBuffer[GWSpanEnd])) {
		/* spanEndPut: */
		workBuffer[GWSpanEnd] = x1;
	}
	if (x1 > (workBuffer[GWSpanEndAA])) {
		/* spanEndAAPut: */
		workBuffer[GWSpanEndAA] = x1;
	}
	if (x0 >= x1) {
		return 0;
	}
	if (fill & 0xFF000000U) {
		/* begin fillColorSpan:from:to: */
		if (!((workBuffer[GWAALevel]) == 1)) {
			fillColorSpanAAx0x1(fill, x0, x1);
			goto l1;
		}

		/* Unroll the inner loop four times, since we're only storing data. */
		x0SqInt = x0;
		while ((x0SqInt + 4) < x1) {
			spanBuffer[x0SqInt] = fill;
			spanBuffer[x0SqInt + 1] = fill;
			spanBuffer[x0SqInt + 2] = fill;
			spanBuffer[x0SqInt + 3] = fill;
			x0SqInt += 4;
		}
		while (x0SqInt < x1) {
			spanBuffer[x0SqInt] = fill;
			x0SqInt += 1;
		}
l1:	/* end fillColorSpan:from:to: */;
	}
	else {

		/* Store the values for the dispatch */
		/* lastExportedFillPut: */
		workBuffer[GWLastExportedFill] = fill;

		/* lastExportedLeftXPut: */
		workBuffer[GWLastExportedLeftX] = x0;

		/* lastExportedRightXPut: */
		workBuffer[GWLastExportedRightX] = x1;
		type = ((usqInt)((((objBuffer[fill + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveFillMask))) >> 8;
		if (type <= 1) {
			return 1;
		}
		switch (type) {
		case 0: // errorWrongIndex
		case 1: // errorWrongIndex
			error("BalloonEngine: Fatal dispatch error");
			break;
		case 2: // fillLinearGradient
			fillLinearGradientfromtoat(workBuffer[GWLastExportedFill], workBuffer[GWLastExportedLeftX], workBuffer[GWLastExportedRightX], workBuffer[GWCurrentY]);
			break;
		case 3: // fillRadialGradient
			fillRadialGradientfromtoat(workBuffer[GWLastExportedFill], workBuffer[GWLastExportedLeftX], workBuffer[GWLastExportedRightX], workBuffer[GWCurrentY]);
			break;
		case 4: // fillBitmapSpan
		case 5: // fillBitmapSpan
			fillBitmapSpanfromtoat(workBuffer[GWLastExportedFill], workBuffer[GWLastExportedLeftX], workBuffer[GWLastExportedRightX], workBuffer[GWCurrentY]);
			break;
		}
	}
	return 0;
}


/*	Check the global edge table for any entries that cannot be handled by the
	engine itself.
	If there are any, return true. Otherwise, initialize the the edge and add
	it to the AET
 */

	/* BalloonEngineBase>>#findNextExternalEntryFromGET */
static sqInt
findNextExternalEntryFromGET(void)
{
    int edge;
    unsigned int type;
    int yValue;

	/* As long as we have entries in the GET */
	yValue = workBuffer[GWCurrentY];
	while ((workBuffer[GWGETStart]) < (workBuffer[GWGETUsed])) {
		edge = getBuffer[workBuffer[GWGETStart]];
		if ((objBuffer[edge + GEYValue]) > yValue) {
			return 0;
		}
		type = (objBuffer[edge + GEObjectType]) & GEPrimitiveTypeMask;
		if ((type & GEPrimitiveWideMask) == GEPrimitiveEdge) {
			return 1;
		}

		/* begin needAvailableSpace: */
		if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 1) > (workBuffer[GWBufferTop])) {
			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorNoMoreSpace;
			engineStopped = 1;
			return 0;
		}
		switch (type) {
		case 0: // errorWrongIndex
		case 1: // errorWrongIndex
		case 2: // errorWrongIndex
		case 3: // errorWrongIndex
			error("BalloonEngine: Fatal dispatch error");
			break;
		case 4: // stepToFirstLine
			stepToFirstLineInat(getBuffer[workBuffer[GWGETStart]], workBuffer[GWCurrentY]);
			break;
		case 5: // stepToFirstWideLine
			stepToFirstWideLineInat(getBuffer[workBuffer[GWGETStart]], workBuffer[GWCurrentY]);
			break;
		case 6: // stepToFirstBezier
			stepToFirstBezierInat(getBuffer[workBuffer[GWGETStart]], workBuffer[GWCurrentY]);
			break;
		case 7: // stepToFirstWideBezier
			stepToFirstWideBezierInat(getBuffer[workBuffer[GWGETStart]], workBuffer[GWCurrentY]);
			break;
		}
		insertEdgeIntoAET(edge);

		/* getStartPut: */
		workBuffer[GWGETStart] = ((workBuffer[GWGETStart]) + 1);
	}
	return 0;
}


/*	Scan the active edge table. If there is any fill that cannot be handled by
	the engine itself, return true. Otherwise handle the fills and return
	false. 
 */
/*	self currentYGet >= 680 ifTrue:[
	self printAET.
	self halt.
	].
 */

	/* BalloonEngineBase>>#findNextExternalFillFromAET */
static sqInt
findNextExternalFillFromAET(void)
{
    sqInt fill;
    int leftEdge;
    int leftX;
    int rightEdge;
    int rightX;
    sqInt startX;
    int stopX;

	leftX = (rightX = workBuffer[GWFillMaxX]);
	while ((workBuffer[GWAETStart]) < (workBuffer[GWAETUsed])) {
		/* TODO: We should check if leftX from last operation
		   is  greater than leftX from next edge.
		   Currently, we rely here on spanEndAA
		   from the span buffer fill. */
		leftEdge = (rightEdge = aetBuffer[workBuffer[GWAETStart]]);
		leftX = (rightX = objBuffer[leftEdge + GEXValue]);
		if (leftX >= (workBuffer[GWFillMaxX])) {
			return 0;
		}

		/* begin quickRemoveInvalidFillsAt: */
		if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
			goto l1;
		}
		while ((topRightX()) <= leftX) {
			hideFilldepth(topFill(), topDepth());
			if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
				goto l1;
			}
		}
l1:	/* end quickRemoveInvalidFillsAt: */;
		if (((objBuffer[leftEdge + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWide) {
			toggleWideFillOf(leftEdge);
		}
		if (!((objBuffer[leftEdge + GEObjectType]) & GEEdgeFillsInvalid)) {
			toggleFillsOf(leftEdge);
			if (engineStopped) {
				return 0;
			}
		}

		/* aetStartPut: */
		workBuffer[GWAETStart] = ((workBuffer[GWAETStart]) + 1);
		if ((workBuffer[GWAETStart]) < (workBuffer[GWAETUsed])) {
			rightEdge = aetBuffer[workBuffer[GWAETStart]];
			rightX = objBuffer[rightEdge + GEXValue];
			if (rightX >= (workBuffer[GWFillMinX])) {

				/* This is the visible portion */
				/* begin fillAllFrom:to: */
				/* begin topFill */
				if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
					fill = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
				}
				else {
					fill = 0;
				}
				startX = leftX;

				/* begin topRightX */
				if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
					stopX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];
				}
				else {
					stopX = 999999999;
				}
				while (stopX < rightX) {
					/* begin topFill */
					if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
						fill = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
					}
					else {
						fill = 0;
					}
					if (fill) {
						if (fillSpanfromto(fill, startX, stopX)) {
							goto l3;
						}
					}

					/* begin quickRemoveInvalidFillsAt: */
					if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
						goto l2;
					}
					while ((topRightX()) <= stopX) {
						hideFilldepth(topFill(), topDepth());
						if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
							goto l2;
						}
					}
l2:	/* end quickRemoveInvalidFillsAt: */;
					startX = stopX;

					/* begin topRightX */
					if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
						stopX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];
					}
					else {
						stopX = 999999999;
					}
				}

				/* begin topFill */
				if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
					fill = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
				}
				else {
					fill = 0;
				}
				if (fill) {
					fillSpanfromto(fill, startX, rightX);
					goto l3;
				}
l3:	/* end fillAllFrom:to: */;
			}
		}
	}
	if (rightX < (workBuffer[GWFillMaxX])) {
		/* begin fillAllFrom:to: */
		/* begin topFill */
		if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
			fill = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
		}
		else {
			fill = 0;
		}
		startX = rightX;

		/* begin topRightX */
		if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
			stopX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];
		}
		else {
			stopX = 999999999;
		}
		while (stopX < (workBuffer[GWFillMaxX])) {
			/* begin topFill */
			if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
				fill = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
			}
			else {
				fill = 0;
			}
			if (fill) {
				if (fillSpanfromto(fill, startX, stopX)) {
					goto l5;
				}
			}

			/* begin quickRemoveInvalidFillsAt: */
			if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
				goto l4;
			}
			while ((topRightX()) <= stopX) {
				hideFilldepth(topFill(), topDepth());
				if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
					goto l4;
				}
			}
l4:	/* end quickRemoveInvalidFillsAt: */;
			startX = stopX;

			/* begin topRightX */
			if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
				stopX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];
			}
			else {
				stopX = 999999999;
			}
		}

		/* begin topFill */
		if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
			fill = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
		}
		else {
			fill = 0;
		}
		if (fill) {
			fillSpanfromto(fill, startX, workBuffer[GWFillMaxX]);
			goto l5;
		}
l5:	/* end fillAllFrom:to: */;
	}
	return 0;
}


/*	Check the active edge table for any entries that cannot be handled by the
	engine itself.
	If there are any, return true. Otherwise, step the the edge to the next y
	value. 
 */

	/* BalloonEngineBase>>#findNextExternalUpdateFromAET */
static sqInt
findNextExternalUpdateFromAET(void)
{
    int count;
    int edge;
    int err;
    int errInt;
    int fwDx;
    int fwDy;
    int lastX;
    int lastXInt;
    int lastY;
    sqInt line;
    sqInt lineOffset;
    sqInt lineSqInt;
    int lineWidth;
    sqInt minY;
    int nextX;
    unsigned int type;
    int *updateData;
    int x;
    int xInt;
    sqInt xValue;
    int yEntry;
    int yExit;

	while ((workBuffer[GWAETStart]) < (workBuffer[GWAETUsed])) {
		edge = aetBuffer[workBuffer[GWAETStart]];
		count = (objBuffer[edge + GENumLines]) - 1;
		if (count) {

			/* Store remaining lines back */
			/* #edgeNumLinesOf:put: #obj:at:put: */
			objBuffer[edge + GENumLines] = count;
			type = (objBuffer[edge + GEObjectType]) & GEPrimitiveTypeMask;
			if ((type & GEPrimitiveWideMask) == GEPrimitiveEdge) {
				return 1;
			}
			switch (type) {
			case 0: // errorWrongIndex
			case 1: // errorWrongIndex
			case 2: // errorWrongIndex
			case 3: // errorWrongIndex
				error("BalloonEngine: Fatal dispatch error");
				break;
			case 4: // stepToNextLine
				line = aetBuffer[workBuffer[GWAETStart]];

				/* begin stepToNextLineIn:at: */
				x = (objBuffer[line + GEXValue]) + (objBuffer[line + GLXIncrement]);
				err = (objBuffer[line + GLError]) + (objBuffer[line + GLErrorAdjUp]);
				if (err > 0) {
					x += objBuffer[line + GLXDirection];
					err -= objBuffer[line + GLErrorAdjDown];
				}

				/* #lineErrorOf:put: #obj:at:put: */
				objBuffer[line + GLError] = err;

				/* #edgeXValueOf:put: #obj:at:put: */
				objBuffer[line + GEXValue] = x;
				break;
			case 5: // stepToNextWideLine
				lineSqInt = aetBuffer[workBuffer[GWAETStart]];

				/* begin stepToNextWideLineIn:at: */
				yEntry = (objBuffer[lineSqInt + GLWideEntry]) + 1;
				yExit = (objBuffer[lineSqInt + GLWideExit]) + 1;

				/* #wideLineEntryOf:put: #obj:at:put: */
				objBuffer[lineSqInt + GLWideEntry] = yEntry;

				/* #wideLineExitOf:put: #obj:at:put: */
				objBuffer[lineSqInt + GLWideExit] = yExit;
				lineWidth = objBuffer[lineSqInt + GLWideExtent];
				lineOffset = lineWidth / 2;
				if (yEntry >= lineOffset) {
					/* #edgeFillsValidate: #objectTypeOf:put: #obj:at:put: */
					objBuffer[lineSqInt + GEObjectType] = (((objBuffer[lineSqInt + GEObjectType]) & GEPrimitiveTypeMask) & ((unsigned int)~GEEdgeFillsInvalid));
				}
				if (yExit >= 0) {
					/* #edgeFillsInvalidate: #objectTypeOf:put: #obj:at:put: */
					objBuffer[lineSqInt + GEObjectType] = (((objBuffer[lineSqInt + GEObjectType]) & GEPrimitiveTypeMask) | GEEdgeFillsInvalid);
				}
				lastXInt = objBuffer[lineSqInt + GEXValue];

				/* begin stepToNextLineIn:at: */
				xInt = (objBuffer[lineSqInt + GEXValue]) + (objBuffer[lineSqInt + GLXIncrement]);
				errInt = (objBuffer[lineSqInt + GLError]) + (objBuffer[lineSqInt + GLErrorAdjUp]);
				if (errInt > 0) {
					xInt += objBuffer[lineSqInt + GLXDirection];
					errInt -= objBuffer[lineSqInt + GLErrorAdjDown];
				}

				/* #lineErrorOf:put: #obj:at:put: */
				objBuffer[lineSqInt + GLError] = errInt;

				/* #edgeXValueOf:put: #obj:at:put: */
				objBuffer[lineSqInt + GEXValue] = xInt;

				/* Check for special start/end adjustments */
				nextX = objBuffer[lineSqInt + GEXValue];
				if ((yEntry <= lineWidth)
				 || ((yExit + lineOffset) >= 0)) {

					/* Yes, need an update */
					adjustWideLineafterSteppingFromto(lineSqInt, lastXInt, nextX);
				}
				break;
			case 6: // stepToNextBezier
				updateData = (objBuffer + (aetBuffer[workBuffer[GWAETStart]])) + GBUpdateData;

				/* begin stepToNextBezierForward:at: */
				lastX = updateData[GBUpdateX];
				lastY = updateData[GBUpdateY];
				fwDx = updateData[GBUpdateDX];
				fwDy = updateData[GBUpdateDY];

				/* Step as long as we haven't yet reached minY and also
				   as long as fwDy is greater than zero thus stepping down.
				   Note: The test for fwDy should not be necessary in theory
				   but is a good insurance in practice. */
				minY = (workBuffer[GWCurrentY]) * 0x100;
				while ((minY > lastY)
				 && (fwDy >= 0)) {
					lastX += (((sqInt)((fwDx + 0x8000))) >> 16);
					lastY += (((sqInt)((fwDy + 0x8000))) >> 16);
					fwDx += updateData[GBUpdateDDX];
					fwDy += updateData[GBUpdateDDY];
				}
				updateData[GBUpdateX] = lastX;
				updateData[GBUpdateY] = lastY;
				updateData[GBUpdateDX] = fwDx;
				updateData[GBUpdateDY] = fwDy;
				xValue = (((sqInt)(lastX)) >> 8);

				/* #edgeXValueOf:put: #obj:at:put: */
				objBuffer[(aetBuffer[workBuffer[GWAETStart]]) + GEXValue] = xValue;
				break;
			case 7: // stepToNextWideBezier
				stepToNextWideBezierInat(aetBuffer[workBuffer[GWAETStart]], workBuffer[GWCurrentY]);
				break;
			}
			resortFirstAETEntry();

			/* aetStartPut: */
			workBuffer[GWAETStart] = ((workBuffer[GWAETStart]) + 1);
		}
		else {

			/* Edge at end -- remove it */
			removeFirstAETEntry();
		}
	}
	return 0;
}

	/* BalloonEngineBase>>#findStackFill:depth: */
static sqInt
findStackFilldepth(sqInt fillIndex, sqInt depth)
{
    sqInt index;

	index = 0;
	while ((index < ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])))
	 && (((workBuffer[(workBuffer[GWBufferTop]) + index]) != fillIndex)
	 || ((workBuffer[(workBuffer[GWBufferTop]) + (index + 1)]) != depth))) {
		index += 3 /* stackFillEntryLength */;
	}
	if (index >= ((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
		return -1;
	}
	else {
		return index;
	}
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	Return true if the edge at index i should sort before the edge at index j. */

	/* BalloonEngineBase>>#getSorts:before: */
static sqInt
getSortsbefore(sqInt edge1, sqInt edge2)
{
    int diff;

	if (edge1 == edge2) {
		return 1;
	}
	diff = (objBuffer[edge1 + GEYValue]) - (objBuffer[edge2 + GEYValue]);
	if (diff) {
		return diff < 0;
	}
	diff = (objBuffer[edge1 + GEXValue]) - (objBuffer[edge2 + GEXValue]);
	return diff < 0;
}


/*	Make the fill style with the given index invisible */

	/* BalloonEngineBase>>#hideFill:depth: */
static sqInt
hideFilldepth(sqInt fillIndex, sqInt depth)
{
    sqInt index;
    int newDepth;
    int newRightX;
    int newTop;
    sqInt newTopIndex;
    sqInt value;

	index = findStackFilldepth(fillIndex, depth);
	if (index == -1) {
		return 0;
	}
	if (!index) {
		/* begin freeStackFillEntry */
		/* begin wbStackPop: */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) + 3 /* stackFillEntryLength */);
		return 1;
	}

	/* #stackFillValue:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + index] = (workBuffer[(workBuffer[GWBufferTop])]);

	/* #stackFillDepth:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + (index + 1)] = (workBuffer[(workBuffer[GWBufferTop]) + 1]);

	/* #stackFillRightX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + (index + 2)] = (workBuffer[(workBuffer[GWBufferTop]) + 2]);

	/* begin freeStackFillEntry */
	/* begin wbStackPop: */
	/* wbTopPut: */
	workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) + 3 /* stackFillEntryLength */);
	if (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) <= 3 /* stackFillEntryLength */) {
		return 1;
	}
	newTopIndex = 0;
	index = 3 /* stackFillEntryLength */;
	while (index < ((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
		if (fillSortsbefore(index, newTopIndex)) {
			newTopIndex = index;
		}
		index += 3 /* stackFillEntryLength */;
	}
	if ((newTopIndex + 3 /* stackFillEntryLength */) == ((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
		return 1;
	}
	newTop = workBuffer[(workBuffer[GWBufferTop]) + newTopIndex];
	value = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];

	/* begin stackFillValue:put: */
	/* wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + newTopIndex] = value;

	/* #topFillValuePut: #stackFillValue:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)] = newTop;
	newDepth = workBuffer[(workBuffer[GWBufferTop]) + (newTopIndex + 1)];
	value = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 1)];

	/* begin stackFillDepth:put: */
	/* wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + (newTopIndex + 1)] = value;

	/* #topFillDepthPut: #stackFillDepth:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 1)] = newDepth;
	newRightX = workBuffer[(workBuffer[GWBufferTop]) + (newTopIndex + 2)];
	value = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];

	/* begin stackFillRightX:put: */
	/* wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + (newTopIndex + 2)] = value;

	/* #topFillRightXPut: #stackFillRightX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)] = newRightX;
	return 1;
}


/*	Find insertion point for the given edge in the AET */

	/* BalloonEngineBase>>#indexForInsertingIntoAET: */
static sqInt
indexForInsertingIntoAET(sqInt edge)
{
    sqInt index;
    int initialX;

	initialX = objBuffer[edge + GEXValue];
	index = 0;
	while ((index < (workBuffer[GWAETUsed]))
	 && ((objBuffer[(aetBuffer[index]) + GEXValue]) < initialX)) {
		index += 1;
	}
	while ((index < (workBuffer[GWAETUsed]))
	 && (((objBuffer[(aetBuffer[index]) + GEXValue]) == initialX)
	 && (getSortsbefore(aetBuffer[index], edge)))) {
		index += 1;
	}
	return index;
}

	/* BalloonEngineBase>>#initColorTransform */
static sqInt
initColorTransform(void)
{
    float *transform;

	/* begin colorTransform */
	transform = ((float *) (workBuffer + GWColorTransform));
	transform[0] = (1.0f);
	transform[1] = (0.0f);
	transform[2] = (1.0f);
	transform[3] = (0.0f);
	transform[4] = (1.0f);
	transform[5] = (0.0f);
	transform[6] = (1.0f);
	transform[7] = (0.0f);

	/* hasColorTransformPut: */
	workBuffer[GWHasColorTransform] = 0;
	return 0;
}

	/* BalloonEngineBase>>#initEdgeTransform */
static sqInt
initEdgeTransform(void)
{
    float *transform;

	/* begin edgeTransform */
	transform = ((float *) (workBuffer + GWEdgeTransform));
	transform[0] = (1.0f);
	transform[1] = (0.0f);
	transform[2] = (0.0f);
	transform[3] = (0.0f);
	transform[4] = (1.0f);
	transform[5] = (0.0f);

	/* hasEdgeTransformPut: */
	workBuffer[GWHasEdgeTransform] = 0;
	return 0;
}

	/* BalloonEngineBase>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	loadBBFn = ioLoadFunctionFrom("loadBitBltFrom", bbPluginName);
	copyBitsFn = ioLoadFunctionFrom("copyBitsFromtoat", bbPluginName);
	return (loadBBFn != 0)
	 && (copyBitsFn != 0);
}


/*	Initialization stuff that needs to be done before any processing can take
	place. 
 */
/*	Make sure aaLevel is initialized */

	/* BalloonEngineBase>>#initializeGETProcessing */
static sqInt
initializeGETProcessing(void)
{
    sqInt value;

	setAALevel(workBuffer[GWAALevel]);
	if ((workBuffer[GWClipMinX]) < 0) {
		/* clipMinXPut: */
		workBuffer[GWClipMinX] = 0;
	}
	if ((workBuffer[GWClipMaxX]) > (workBuffer[GWSpanSize])) {
		/* clipMaxXPut: */
		workBuffer[GWClipMaxX] = (workBuffer[GWSpanSize]);
	}

	/* fillMinXPut: */
	workBuffer[GWFillMinX] = (((sqInt)((usqInt)((workBuffer[GWClipMinX])) << (workBuffer[GWAAShift]))));

	/* fillMinYPut: */
	workBuffer[GWFillMinY] = (((sqInt)((usqInt)((workBuffer[GWClipMinY])) << (workBuffer[GWAAShift]))));

	/* fillMaxXPut: */
	workBuffer[GWFillMaxX] = (((sqInt)((usqInt)((workBuffer[GWClipMaxX])) << (workBuffer[GWAAShift]))));

	/* fillMaxYPut: */
	workBuffer[GWFillMaxY] = (((sqInt)((usqInt)((workBuffer[GWClipMaxY])) << (workBuffer[GWAAShift]))));

	/* getUsedPut: */
	workBuffer[GWGETUsed] = 0;

	/* aetUsedPut: */
	workBuffer[GWAETUsed] = 0;
	getBuffer = objBuffer + objUsed;

	/* Create the global edge table */
	aetBuffer = objBuffer + objUsed;
	createGlobalEdgeTable();
	if (engineStopped) {
		return null;
	}
	if (!(workBuffer[GWGETUsed])) {

		/* Nothing to do */
		/* currentYPut: */
		workBuffer[GWCurrentY] = (workBuffer[GWFillMaxY]);
		return 0;
	}

	/* begin sortGlobalEdgeTable */
	quickSortGlobalEdgeTablefromto(getBuffer, 0, (workBuffer[GWGETUsed]) - 1);
	value = objBuffer[(getBuffer[0]) + GEYValue];

	/* begin currentYPut: */
	workBuffer[GWCurrentY] = value;
	if ((workBuffer[GWCurrentY]) < (workBuffer[GWFillMinY])) {
		/* currentYPut: */
		workBuffer[GWCurrentY] = (workBuffer[GWFillMinY]);
	}

	/* spanStartPut: */
	workBuffer[GWSpanStart] = 0;

	/* spanEndPut: */
	workBuffer[GWSpanEnd] = (((((usqInt)((workBuffer[GWSpanSize])) << (workBuffer[GWAAShift])))) - 1);
	clearSpanBuffer();
	return 0;
}


/*	Insert the edge with the given index from the global edge table into the
	active edge table.
	The edge has already been stepped to the initial yValue -- thus
	remainingLines and rasterX
	are both set.
 */

	/* BalloonEngineBase>>#insertEdgeIntoAET: */
static sqInt
insertEdgeIntoAET(sqInt edge)
{
    sqInt index;


	/* Check for the number of lines remaining */
	if ((objBuffer[edge + GENumLines]) <= 0) {
		return null;
	}

	/* And insert edge */
	index = indexForInsertingIntoAET(edge);
	insertToAETbeforeIndex(edge, index);
	return 0;
}


/*	Insert the given edge into the AET. */

	/* BalloonEngineBase>>#insertToAET:beforeIndex: */
static sqInt
insertToAETbeforeIndex(sqInt edge, sqInt index)
{
    int i;


	/* Make sure we have space in the AET */
	/* begin allocateAETEntry: */
	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 1) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return null;
	}
	i = (workBuffer[GWAETUsed]) - 1;
	while (!(i < index)) {
		aetBuffer[i + 1] = (aetBuffer[i]);
		i -= 1;
	}
	aetBuffer[index] = edge;

	/* aetUsedPut: */
	workBuffer[GWAETUsed] = ((workBuffer[GWAETUsed]) + 1);
	return 0;
}

	/* BalloonEngineBase>>#isEdge: */
static sqInt
isEdge(sqInt edge)
{
    unsigned int type;

	type = 0;
	return (((type = (objBuffer[edge + GEObjectType]) & GEPrimitiveTypeMask)) <= GEPrimitiveEdgeMask)
	 && ((type & GEPrimitiveEdgeMask) != 0);
}

	/* BalloonEnginePlugin>>#isFillOkay: */
static sqInt
isFillOkay(sqInt fill)
{
	return (fill == 0)
	 || (((fill & 0xFF000000U) != 0)
	 || ((/* isObject: */
		(fill >= 0)
	 && (fill < objUsed))
	 && (/* isFill: */
		((fill & 0xFF000000U) != 0)
	 || ((((objBuffer[fill + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveFillMask) != 0))));
}


/*	Load and subdivide the bezier curve from point1/point2/point3.
	If wideFlag is set then make sure the curve is monoton in X. */

	/* BalloonEnginePlugin>>#loadAndSubdivideBezierFrom:via:to:isWide: */
static sqInt
loadAndSubdivideBezierFromviatoisWide(int *point1, int *point2, int *point3, sqInt wideFlag)
{
    int bz1;
    sqInt bz2;
    int index;
    sqInt index1;
    sqInt index2;

	/* begin allocateBezierStackEntry */
	/* begin wbStackPush: */
	/* begin allocateStackEntry: */
	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 6) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		goto l1;
	}

	/* wbTopPut: */
	workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) - 6);
l1:	/* end wbStackPush: */;
	bz1 = (workBuffer[GWSize]) - (workBuffer[GWBufferTop]);
	if (engineStopped) {
		return 0;
	}

	/* #bzStartX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - bz1))] = (point1[0]);

	/* #bzStartY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - bz1) + 1)] = (point1[1]);

	/* #bzViaX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - bz1) + 2)] = (point2[0]);

	/* #bzViaY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - bz1) + 3)] = (point2[1]);

	/* #bzEndX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - bz1) + 4)] = (point3[0]);

	/* #bzEndY:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - bz1) + 5)] = (point3[1]);
	index2 = (bz2 = subdivideToBeMonotoninX(bz1, wideFlag));
	for (index = bz1; index <= bz2; index += 6) {
		index1 = subdivideBezierFrom(index);
		if (index1 > index2) {
			index2 = index1;
		}
		if (engineStopped) {
			return 0;
		}
	}
	return index2 / 6;
}

	/* BalloonEnginePlugin>>#loadArrayShape:nSegments:fill:lineWidth:lineFill: */
static sqInt
loadArrayShapenSegmentsfilllineWidthlineFill(sqInt points, sqInt nSegments, sqInt fillIndex, sqInt lineWidth, sqInt lineFill)
{
    int *dstPoint1;
    sqInt i;
    int *point;
    sqInt pointOop;
    sqInt segs;
    float *transform;
    sqInt x;
    int x0;
    int x1;
    int x2;
    sqInt y;
    int y0;
    int y1;
    int y2;

	for (i = 0; i < nSegments; i += 1) {
		pointOop = fetchPointerofObject(i * 3, points);
		loadPointfrom(((int *) (workBuffer + GWPoint1)), pointOop);
		pointOop = fetchPointerofObject((i * 3) + 1, points);
		loadPointfrom(((int *) (workBuffer + GWPoint2)), pointOop);
		pointOop = fetchPointerofObject((i * 3) + 2, points);
		loadPointfrom(((int *) (workBuffer + GWPoint3)), pointOop);
		if (failed()) {
			return null;
		}

		/* begin transformPoints: */
		if (3 > 0) {
			point = ((int *) (workBuffer + GWPoint1));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 1) {
			point = ((int *) (workBuffer + GWPoint2));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 2) {
			point = ((int *) (workBuffer + GWPoint3));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 3) {
			point = ((int *) (workBuffer + GWPoint4));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		x0 = (*((int *) (workBuffer + GWPoint1)));
		y0 = (((int *) (workBuffer + GWPoint1)))[1];
		x1 = (*((int *) (workBuffer + GWPoint2)));
		y1 = (((int *) (workBuffer + GWPoint2)))[1];
		x2 = (*((int *) (workBuffer + GWPoint3)));

		/* Check if we can use a line */
		y2 = (((int *) (workBuffer + GWPoint3)))[1];
		if (((x0 == y0)
		 && (x1 == y1))
		 || ((x1 == x2)
		 && (y1 == y2))) {
			loadWideLinefromtolineFillleftFillrightFill(lineWidth, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint3)), lineFill, fillIndex, 0);
		}
		else {

			/* Need bezier */
			segs = loadAndSubdivideBezierFromviatoisWide(((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), (lineWidth != 0)
				 && (lineFill != 0));
			if (engineStopped) {
				return null;
			}
			loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);
		}
		if (engineStopped) {
			return null;
		}
	}
	return 0;
}


/*	Load a transformation from the given array. */

	/* BalloonEngineBase>>#loadArrayTransformFrom:into:length: */
static sqInt
loadArrayTransformFromintolength(sqInt transformOop, float *destPtr, sqInt n)
{
    sqInt i;
    sqInt value;

	for (i = 0; i < n; i += 1) {
		value = fetchPointerofObject(i, transformOop);
		if (!((isIntegerObject(value))
			 || (isFloatObject(value)))) {
			return primitiveFail();
		}
		if (isIntegerObject(value)) {
			destPtr[i] = (((float) (((double) (integerValueOf(value)) ))));
		}
		else {
			destPtr[i] = (((float) (floatValueOf(value))));
		}
	}
	return 0;
}


/*	Initialize the bezier segment stored on the stack */

	/* BalloonEnginePlugin>>#loadBezier:segment:leftFill:rightFill:offset: */
static sqInt
loadBeziersegmentleftFillrightFilloffset(sqInt bezier, sqInt index, sqInt leftFillIndex, sqInt rightFillIndex, sqInt yOffset)
{
	if ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)]) >= (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)])) {

		/* Top to bottom */
		/* #edgeXValueOf:put: #obj:at:put: */
		objBuffer[bezier + GEXValue] = (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index))]);

		/* #edgeYValueOf:put: #obj:at:put: */
		objBuffer[bezier + GEYValue] = ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)]) - yOffset);

		/* #bezierViaXOf:put: #obj:at:put: */
		objBuffer[bezier + GBViaX] = (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)]);

		/* #bezierViaYOf:put: #obj:at:put: */
		objBuffer[bezier + GBViaY] = ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)]) - yOffset);

		/* #bezierEndXOf:put: #obj:at:put: */
		objBuffer[bezier + GBEndX] = (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)]);

		/* #bezierEndYOf:put: #obj:at:put: */
		objBuffer[bezier + GBEndY] = ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)]) - yOffset);
	}
	else {
		/* #edgeXValueOf:put: #obj:at:put: */
		objBuffer[bezier + GEXValue] = (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)]);

		/* #edgeYValueOf:put: #obj:at:put: */
		objBuffer[bezier + GEYValue] = ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)]) - yOffset);

		/* #bezierViaXOf:put: #obj:at:put: */
		objBuffer[bezier + GBViaX] = (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)]);

		/* #bezierViaYOf:put: #obj:at:put: */
		objBuffer[bezier + GBViaY] = ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)]) - yOffset);

		/* #bezierEndXOf:put: #obj:at:put: */
		objBuffer[bezier + GBEndX] = (workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index))]);

		/* #bezierEndYOf:put: #obj:at:put: */
		objBuffer[bezier + GBEndY] = ((workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)]) - yOffset);
	}

	/* #edgeZValueOf:put: #obj:at:put: */
	objBuffer[bezier + GEZValue] = (workBuffer[GWCurrentZ]);

	/* #edgeLeftFillOf:put: #obj:at:put: */
	objBuffer[bezier + GEFillIndexLeft] = leftFillIndex;

	/* #edgeRightFillOf:put: #obj:at:put: */
	objBuffer[bezier + GEFillIndexRight] = rightFillIndex;
	return 0;
}

	/* BalloonEngineBase>>#loadBitBltFrom: */
static sqInt
loadBitBltFrom(sqInt bbObj)
{
	if (!loadBBFn) {

		/* We need copyBits here so try to load it implicitly */
		if (!(initialiseModule())) {
			return 0;
		}
	}
	return ((sqInt (*)(sqInt))loadBBFn)(bbObj);
}


/*	Note: Assumes that the contents of formArray has been checked before */

	/* BalloonEnginePlugin>>#loadBitsFrom: */
static int *
loadBitsFrom(sqInt bmFill)
{
    sqInt bitsLen;
    sqInt bitsOop;
    sqInt formOop;
    int xIndex;

	xIndex = objBuffer[bmFill + GEObjectIndex];
	if (xIndex > (slotSizeOf(formArray))) {
		return null;
	}
	formOop = fetchPointerofObject(xIndex, formArray);
	bitsOop = fetchPointerofObject(0, formOop);
	bitsLen = slotSizeOf(bitsOop);
	if (!(bitsLen == (objBuffer[bmFill + GBBitmapSize]))) {
		return null;
	}
	return firstIndexableField(bitsOop);
}


/*	Load a compressed shape into the engine.
	WARNING: THIS METHOD NEEDS THE FULL FRAME SIZE!!!!
	 */

	/* BalloonEnginePlugin>>#loadCompressedShape:segments:leftFills:rightFills:lineWidths:lineFills:fillIndexList:pointShort: */
static sqInt
loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(int *points, sqInt nSegments, int *leftFills, int *rightFills, int *lineWidths, int *lineFills, int *fillIndexList, sqInt pointsShort)
{
    int *dstPoint1;
    sqInt i;
    sqInt index;
    sqInt leftLength;
    sqInt leftRun;
    sqInt leftValue;
    sqInt lineFillLength;
    sqInt lineFillRun;
    unsigned int lineFillValue;
    int *point;
    sqInt rightLength;
    sqInt rightRun;
    sqInt rightValue;
    sqInt segs;
    float *transform;
    sqInt widthLength;
    sqInt widthRun;
    sqInt widthValue;
    sqInt x;
    sqInt x0;
    sqInt x1;
    sqInt x2;
    sqInt y;
    sqInt y0;
    sqInt y1;
    sqInt y2;

	if (!nSegments) {
		return 0;
	}
	leftRun = (rightRun = (widthRun = (lineFillRun = -1)));
	leftLength = (rightLength = (widthLength = (lineFillLength = 1)));
	leftValue = (rightValue = (widthValue = (lineFillValue = 0)));
	for (i = 1; i <= nSegments; i += 1) {

		/* Decrement current run length and load new stuff */
		if (((leftLength -= 1)) <= 0) {
			leftRun += 1;
			leftLength = (((usqInt)(((((int *) leftFills))[leftRun]))) >> 16);
			leftValue = ((((int *) leftFills))[leftRun]) & 0xFFFF;
			if (leftValue) {
				leftValue = fillIndexList[leftValue - 1];
				leftValue = transformColor(leftValue);
				if (engineStopped) {
					return null;
				}
			}
		}
		if (((rightLength -= 1)) <= 0) {
			rightRun += 1;
			rightLength = (((usqInt)(((((int *) rightFills))[rightRun]))) >> 16);
			rightValue = ((((int *) rightFills))[rightRun]) & 0xFFFF;
			if (rightValue) {
				rightValue = fillIndexList[rightValue - 1];
				rightValue = transformColor(rightValue);
			}
		}
		if (((widthLength -= 1)) <= 0) {
			widthRun += 1;
			widthLength = (((usqInt)(((((int *) lineWidths))[widthRun]))) >> 16);
			widthValue = ((((int *) lineWidths))[widthRun]) & 0xFFFF;
			if (widthValue) {
				widthValue = transformWidth(widthValue);
			}
		}
		if (((lineFillLength -= 1)) <= 0) {
			lineFillRun += 1;
			lineFillLength = (((usqInt)(((((int *) lineFills))[lineFillRun]))) >> 16);
			lineFillValue = ((((int *) lineFills))[lineFillRun]) & 0xFFFF;
			if (lineFillValue) {
				lineFillValue = fillIndexList[lineFillValue - 1];
			}
		}

		/* begin loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */
		if ((leftValue == rightValue)
		 && ((widthValue == 0)
		 || (lineFillValue == 0))) {
			goto l1;
		}

		/* 3 points with x/y each */
		index = (i - 1) * 6;
		if (pointsShort) {

			/* Load short points */
			x0 = (((short *) points))[index];
			y0 = (((short *) points))[index + 1];
			x1 = (((short *) points))[index + 2];
			y1 = (((short *) points))[index + 3];
			x2 = (((short *) points))[index + 4];
			y2 = (((short *) points))[index + 5];
		}
		else {
			x0 = (((int *) points))[index];
			y0 = (((int *) points))[index + 1];
			x1 = (((int *) points))[index + 2];
			y1 = (((int *) points))[index + 3];
			x2 = (((int *) points))[index + 4];
			y2 = (((int *) points))[index + 5];
		}
		if (((x0 == x1)
		 && (y0 == y1))
		 || ((x1 == x2)
		 && (y1 == y2))) {

			/* We can use a line from x0/y0 to x2/y2 */
			if ((x0 == x2)
			 && (y0 == y2)) {
				goto l1;
			}
			(*((int *) (workBuffer + GWPoint1)) = x0);
			(((int *) (workBuffer + GWPoint1)))[1] = y0;
			(*((int *) (workBuffer + GWPoint2)) = x2);
			(((int *) (workBuffer + GWPoint2)))[1] = y2;

			/* begin transformPoints: */
			if (2 > 0) {
				point = ((int *) (workBuffer + GWPoint1));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 1) {
				point = ((int *) (workBuffer + GWPoint2));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 2) {
				point = ((int *) (workBuffer + GWPoint3));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 3) {
				point = ((int *) (workBuffer + GWPoint4));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			loadWideLinefromtolineFillleftFillrightFill(widthValue, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), lineFillValue, leftValue, rightValue);
			goto l1;
		}
		(*((int *) (workBuffer + GWPoint1)) = x0);
		(((int *) (workBuffer + GWPoint1)))[1] = y0;
		(*((int *) (workBuffer + GWPoint2)) = x1);
		(((int *) (workBuffer + GWPoint2)))[1] = y1;
		(*((int *) (workBuffer + GWPoint3)) = x2);
		(((int *) (workBuffer + GWPoint3)))[1] = y2;

		/* begin transformPoints: */
		if (3 > 0) {
			point = ((int *) (workBuffer + GWPoint1));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 1) {
			point = ((int *) (workBuffer + GWPoint2));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 2) {
			point = ((int *) (workBuffer + GWPoint3));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 3) {
			point = ((int *) (workBuffer + GWPoint4));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		segs = loadAndSubdivideBezierFromviatoisWide(((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), (widthValue != 0)
			 && (lineFillValue != 0));
		if (engineStopped) {
			goto l1;
		}
		loadWideBezierlineFillleftFillrightFilln(widthValue, lineFillValue, leftValue, rightValue, segs);
l1:	/* end loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */;
		if (engineStopped) {
			return null;
		}
	}
	return 0;
}

	/* BalloonEngineBase>>#loadEdgeStateFrom: */
static int
loadEdgeStateFrom(sqInt edgeOop)
{
    int edge;
    sqInt value;

	edge = workBuffer[GWLastExportedEdge];
	if ((slotSizeOf(edgeOop)) < ETBalloonEdgeDataSize) {
		return null;
	}
	value = fetchIntegerofObject(ETXValueIndex, edgeOop);

	/* begin edgeXValueOf:put: */
	/* obj:at:put: */
	objBuffer[edge + GEXValue] = value;
	value = fetchIntegerofObject(ETYValueIndex, edgeOop);

	/* begin edgeYValueOf:put: */
	/* obj:at:put: */
	objBuffer[edge + GEYValue] = value;
	value = fetchIntegerofObject(ETZValueIndex, edgeOop);

	/* begin edgeZValueOf:put: */
	/* obj:at:put: */
	objBuffer[edge + GEZValue] = value;
	value = fetchIntegerofObject(ETLinesIndex, edgeOop);

	/* begin edgeNumLinesOf:put: */
	/* obj:at:put: */
	objBuffer[edge + GENumLines] = value;
	return edge;
}


/*	Load a 2x3 transformation matrix from the given oop.
	Return true if the matrix is not nil, false otherwise */

	/* BalloonEngineBase>>#loadEdgeTransformFrom: */
static sqInt
loadEdgeTransformFrom(sqInt transformOop)
{
    sqInt okay;
    float *transform;

	/* hasEdgeTransformPut: */
	workBuffer[GWHasEdgeTransform] = 0;

	/* begin edgeTransform */
	transform = ((float *) (workBuffer + GWEdgeTransform));
	okay = loadTransformFromintolength(transformOop, transform, 6);
	if (failed()) {
		return null;
	}
	if (!okay) {
		return 0;
	}

	/* hasEdgeTransformPut: */
	workBuffer[GWHasEdgeTransform] = 1;
	transform[2] = (((float) ((transform[2]) + (((double) (workBuffer[GWDestOffsetX]) )))));
	transform[5] = (((float) ((transform[5]) + (((double) (workBuffer[GWDestOffsetY]) )))));
	return 1;
}


/*	Transform the points */

	/* BalloonEnginePlugin>>#loadFillOrientation:from:along:normal:width:height: */
static sqInt
loadFillOrientationfromalongnormalwidthheight(sqInt fill, int *point1, int *point2, int *point3, sqInt fillWidth, sqInt fillHeight)
{
    int dirX;
    int dirY;
    int dsLength2;
    int *dstPoint1;
    sqInt dsX;
    sqInt dsY;
    int dtLength2;
    sqInt dtX;
    sqInt dtY;
    int nrmX;
    int nrmY;
    float *transform;
    sqInt x;
    sqInt y;

	point2[0] = ((point2[0]) + (point1[0]));
	point2[1] = ((point2[1]) + (point1[1]));
	point3[0] = ((point3[0]) + (point1[0]));
	point3[1] = ((point3[1]) + (point1[1]));

	/* begin transformPoint: */
	if (workBuffer[GWHasEdgeTransform]) {

		/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
		/* begin transformPoint:into: */
		dstPoint1 = ((int *) point1);
		transform = ((float *) (workBuffer + GWEdgeTransform));
		x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point1))) ))) + ((transform[1]) * (((double) ((((int *) point1))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
		y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point1))) ))) + ((transform[4]) * (((double) ((((int *) point1))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
		dstPoint1[0] = x;
		dstPoint1[1] = y;
	}
	else {

		/* Multiply each component by aaLevel and add a half pixel */
		point1[0] = (((point1[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
		point1[1] = (((point1[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
	}

	/* begin transformPoint: */
	if (workBuffer[GWHasEdgeTransform]) {

		/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
		/* begin transformPoint:into: */
		dstPoint1 = ((int *) point2);
		transform = ((float *) (workBuffer + GWEdgeTransform));
		x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point2))) ))) + ((transform[1]) * (((double) ((((int *) point2))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
		y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point2))) ))) + ((transform[4]) * (((double) ((((int *) point2))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
		dstPoint1[0] = x;
		dstPoint1[1] = y;
	}
	else {

		/* Multiply each component by aaLevel and add a half pixel */
		point2[0] = (((point2[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
		point2[1] = (((point2[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
	}

	/* begin transformPoint: */
	if (workBuffer[GWHasEdgeTransform]) {

		/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
		/* begin transformPoint:into: */
		dstPoint1 = ((int *) point3);
		transform = ((float *) (workBuffer + GWEdgeTransform));
		x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point3))) ))) + ((transform[1]) * (((double) ((((int *) point3))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
		y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point3))) ))) + ((transform[4]) * (((double) ((((int *) point3))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
		dstPoint1[0] = x;
		dstPoint1[1] = y;
	}
	else {

		/* Multiply each component by aaLevel and add a half pixel */
		point3[0] = (((point3[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
		point3[1] = (((point3[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
	}
	dirX = (point2[0]) - (point1[0]);
	dirY = (point2[1]) - (point1[1]);
	nrmX = (point3[0]) - (point1[0]);

	/* Compute the scale from direction/normal into ramp size */
	nrmY = (point3[1]) - (point1[1]);
	dsLength2 = (dirX * dirX) + (dirY * dirY);
	if (dsLength2 > 0) {
		dsX = ((sqInt)((((((double) dirX )) * (((double) fillWidth ))) * 65536.0) / (((double) dsLength2 ))));
		dsY = ((sqInt)((((((double) dirY )) * (((double) fillWidth ))) * 65536.0) / (((double) dsLength2 ))));
	}
	else {
		dsX = 0;
		dsY = 0;
	}
	dtLength2 = (nrmX * nrmX) + (nrmY * nrmY);
	if (dtLength2 > 0) {
		dtX = ((sqInt)((((((double) nrmX )) * (((double) fillHeight ))) * 65536.0) / (((double) dtLength2 ))));
		dtY = ((sqInt)((((((double) nrmY )) * (((double) fillHeight ))) * 65536.0) / (((double) dtLength2 ))));
	}
	else {
		dtX = 0;
		dtY = 0;
	}

	/* #fillOriginXOf:put: #obj:at:put: */
	objBuffer[fill + GFOriginX] = (point1[0]);

	/* #fillOriginYOf:put: #obj:at:put: */
	objBuffer[fill + GFOriginY] = (point1[1]);

	/* #fillDirectionXOf:put: #obj:at:put: */
	objBuffer[fill + GFDirectionX] = dsX;

	/* #fillDirectionYOf:put: #obj:at:put: */
	objBuffer[fill + GFDirectionY] = dsY;

	/* #fillNormalXOf:put: #obj:at:put: */
	objBuffer[fill + GFNormalX] = dtX;

	/* #fillNormalYOf:put: #obj:at:put: */
	objBuffer[fill + GFNormalY] = dtY;
	return 0;
}


/*	Check all the forms from arrayOop. */

	/* BalloonEngineBase>>#loadFormsFrom: */
static sqInt
loadFormsFrom(sqInt arrayOop)
{
    sqInt bmBits;
    sqInt bmBitsSize;
    sqInt bmDepth;
    sqInt bmHeight;
    sqInt bmRaster;
    sqInt bmWidth;
    sqInt formOop;
    sqInt i;
    sqInt ppw;
    sqInt toDoLimit;

	if (!(isArray(arrayOop))) {
		return 0;
	}
	formArray = arrayOop;
	toDoLimit = (slotSizeOf(formArray)) - 1;
	for (i = 0; i <= toDoLimit; i += 1) {
		formOop = fetchPointerofObject(i, formArray);
		if (!(isPointers(formOop))) {
			return 0;
		}
		if ((slotSizeOf(formOop)) < 5) {
			return 0;
		}
		bmBits = fetchPointerofObject(0, formOop);
		if (!((fetchClassOf(bmBits)) == (classBitmap()))) {
			return 0;
		}
		bmBitsSize = slotSizeOf(bmBits);
		bmWidth = fetchIntegerofObject(1, formOop);
		bmHeight = fetchIntegerofObject(2, formOop);
		bmDepth = fetchIntegerofObject(3, formOop);
		if (failed()) {
			return 0;
		}
		if (!((bmWidth >= 0)
			 && (bmHeight >= 0))) {
			return 0;
		}
		ppw = 32 / bmDepth;
		bmRaster = (bmWidth + (ppw - 1)) / ppw;
		if (!(bmBitsSize == (bmRaster * bmHeight))) {
			return 0;
		}
	}
	return 1;
}


/*	Load the gradient fill as defined by the color ramp. */

	/* BalloonEnginePlugin>>#loadGradientFill:from:along:normal:isRadial: */
static sqInt
loadGradientFillfromalongnormalisRadial(sqInt rampOop, int *point1, int *point2, int *point3, sqInt isRadial)
{
    sqInt fill;
    sqInt fillSize;
    sqInt fillSqInt;
    sqInt i;
    int *ramp;
    int *rampPtr;
    sqInt rampWidth;

	if (!((fetchClassOf(rampOop)) == (classBitmap()))) {
		return primitiveFail();
	}
	rampWidth = slotSizeOf(rampOop);
	ramp = firstIndexableField(rampOop);

	/* begin allocateGradientFill:rampWidth:isRadial: */
	fillSize = GGBaseSize + rampWidth;
	if (!(allocateObjEntry(fillSize))) {
		fill = 0;
		goto l1;
	}
	fillSqInt = objUsed;
	objUsed = fillSqInt + fillSize;
	if (isRadial) {
		/* #objectTypeOf:put: #obj:at:put: */
		objBuffer[fillSqInt + GEObjectType] = GEPrimitiveRadialGradientFill;
	}
	else {
		/* #objectTypeOf:put: #obj:at:put: */
		objBuffer[fillSqInt + GEObjectType] = GEPrimitiveLinearGradientFill;
	}

	/* #objectIndexOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GEObjectIndex] = 0;

	/* #objectLengthOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GEObjectLength] = fillSize;
	rampPtr = (objBuffer + fillSqInt) + GFRampOffset;
	if (workBuffer[GWHasColorTransform]) {
		for (i = 0; i < rampWidth; i += 1) {
			rampPtr[i] = (transformColor(ramp[i]));
		}
	}
	else {
		for (i = 0; i < rampWidth; i += 1) {
			rampPtr[i] = (ramp[i]);
		}
	}

	/* #gradientRampLengthOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GFRampLength] = rampWidth;
	fill = fillSqInt;
l1:	/* end allocateGradientFill:rampWidth:isRadial: */;
	if (engineStopped) {
		return null;
	}
	loadFillOrientationfromalongnormalwidthheight(fill, point1, point2, point3, rampWidth, rampWidth);
	return fill;
}

	/* BalloonEnginePlugin>>#loadOvalSegment:w:h:cx:cy: */
static sqInt
loadOvalSegmentwhcxcy(sqInt seg, sqInt w, sqInt h, sqInt cx, sqInt cy)
{
    sqInt x0;
    sqInt x1;
    sqInt x2;
    sqInt y0;
    sqInt y1;
    sqInt y2;


	/* Load start point of segment */
	x0 = ((sqInt)((((circleCosTable())[(seg * 2)]) * (((double) w ))) + cx));
	y0 = ((sqInt)((((circleSinTable())[(seg * 2)]) * (((double) h ))) + cy));
	(*((int *) (workBuffer + GWPoint1)) = x0);
	(((int *) (workBuffer + GWPoint1)))[1] = y0;
	x2 = ((sqInt)((((circleCosTable())[(seg * 2) + 2]) * (((double) w ))) + cx));
	y2 = ((sqInt)((((circleSinTable())[(seg * 2) + 2]) * (((double) h ))) + cy));
	(*((int *) (workBuffer + GWPoint3)) = x2);
	(((int *) (workBuffer + GWPoint3)))[1] = y2;
	x1 = ((sqInt)((((circleCosTable())[(seg * 2) + 1]) * (((double) w ))) + cx));

	/* NOTE: The intermediate point is the point ON the curve
	   and not yet the control point (which is OFF the curve) */
	y1 = ((sqInt)((((circleSinTable())[(seg * 2) + 1]) * (((double) h ))) + cy));
	x1 = (x1 * 2) - ((x0 + x2) / 2);
	y1 = (y1 * 2) - ((y0 + y2) / 2);
	(*((int *) (workBuffer + GWPoint2)) = x1);
	(((int *) (workBuffer + GWPoint2)))[1] = y1;
	return 0;
}


/*	Load a rectangular oval currently defined by point1/point2 */

	/* BalloonEnginePlugin>>#loadOval:lineFill:leftFill:rightFill: */
static sqInt
loadOvallineFillleftFillrightFill(sqInt lineWidth, sqInt lineFill, sqInt leftFill, sqInt rightFill)
{
    int cx;
    int cy;
    int *dstPoint1;
    int h;
    sqInt i;
    sqInt nSegments;
    int *point;
    float *transform;
    int w;
    sqInt x;
    sqInt y;

	w = (((*((int *) (workBuffer + GWPoint2)))) - ((*((int *) (workBuffer + GWPoint1))))) / 2;
	h = (((((int *) (workBuffer + GWPoint2)))[1]) - ((((int *) (workBuffer + GWPoint1)))[1])) / 2;
	cx = (((*((int *) (workBuffer + GWPoint2)))) + ((*((int *) (workBuffer + GWPoint1))))) / 2;
	cy = (((((int *) (workBuffer + GWPoint2)))[1]) + ((((int *) (workBuffer + GWPoint1)))[1])) / 2;
	for (i = 0; i <= 15; i += 1) {
		loadOvalSegmentwhcxcy(i, w, h, cx, cy);

		/* begin transformPoints: */
		if (3 > 0) {
			point = ((int *) (workBuffer + GWPoint1));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 1) {
			point = ((int *) (workBuffer + GWPoint2));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 2) {
			point = ((int *) (workBuffer + GWPoint3));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 3) {
			point = ((int *) (workBuffer + GWPoint4));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		nSegments = loadAndSubdivideBezierFromviatoisWide(((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), (lineWidth != 0)
			 && (lineFill != 0));
		if (engineStopped) {
			return null;
		}
		loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, leftFill, rightFill, nSegments);
		if (engineStopped) {
			return null;
		}
	}
	return 0;
}


/*	Load the contents of pointOop into pointArray */

	/* BalloonEngineBase>>#loadPoint:from: */
static sqInt
loadPointfrom(int *pointArray, sqInt pointOop)
{
    sqInt value;

	if (!((fetchClassOf(pointOop)) == (classPoint()))) {
		return primitiveFail();
	}
	value = fetchPointerofObject(0, pointOop);
	if (!((isIntegerObject(value))
		 || (isFloatObject(value)))) {
		return primitiveFail();
	}
	if (isIntegerObject(value)) {
		pointArray[0] = (integerValueOf(value));
	}
	else {
		pointArray[0] = (((sqInt)(floatValueOf(value))));
	}
	value = fetchPointerofObject(1, pointOop);
	if (!((isIntegerObject(value))
		 || (isFloatObject(value)))) {
		return primitiveFail();
	}
	if (isIntegerObject(value)) {
		pointArray[1] = (integerValueOf(value));
	}
	else {
		pointArray[1] = (((sqInt)(floatValueOf(value))));
	}
	return 0;
}


/*	Load the entire state from the interpreter for the rendering primitives.
	Answer 0 on success or a non-zero failure code on failure. */

	/* BalloonEngineBase>>#loadRenderingState */
static sqInt
loadRenderingState(void)
{
    sqInt edgeOop;
    sqInt failCode;
    sqInt fillOop;
    int state;

	if (!((methodArgumentCount()) == 2)) {
		return PrimErrBadNumArgs;
	}
	if ((failCode = quickLoadEngineFrom(stackValue(2)))) {
		return failCode;
	}
	fillOop = stackObjectValue(0);
	edgeOop = stackObjectValue(1);
	if (failed()) {
		return PrimErrBadArgument;
	}
	if ((failCode = loadSpanBufferFrom(fetchPointerofObject(BESpanIndex, engine)))) {
		return failCode;
	}
	if (!(loadBitBltFrom(fetchPointerofObject(BEBitBltIndex, engine)))) {
		return GEFBitBltLoadFailed;
	}
	if (!(loadFormsFrom(fetchPointerofObject(BEFormsIndex, engine)))) {
		return GEFFormLoadFailed;
	}
	if ((slotSizeOf(edgeOop)) < ETBalloonEdgeDataSize) {
		return GEFEdgeDataTooSmall;
	}
	if ((slotSizeOf(fillOop)) < FTBalloonFillDataSize) {
		return GEFFillDataTooSmall;
	}
	state = workBuffer[GWState];
	if ((state == GEStateWaitingForEdge)
	 || ((state == GEStateWaitingForFill)
	 || (state == GEStateWaitingChange))) {
		return GEFWrongState;
	}
	return 0;
}

	/* BalloonEnginePlugin>>#loadShape:nSegments:fill:lineWidth:lineFill:pointsShort: */
static sqInt
loadShapenSegmentsfilllineWidthlineFillpointsShort(int *points, sqInt nSegments, sqInt fillIndex, sqInt lineWidth, sqInt lineFill, sqInt pointsShort)
{
    int *dstPoint1;
    sqInt i;
    sqInt index;
    int *point;
    sqInt segs;
    float *transform;
    sqInt x;
    sqInt x0;
    sqInt x1;
    sqInt x2;
    sqInt y;
    sqInt y0;
    sqInt y1;
    sqInt y2;

	for (i = 1; i <= nSegments; i += 1) {
		/* begin loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */
		if ((fillIndex == 0)
		 && ((lineWidth == 0)
		 || (lineFill == 0))) {
			goto l1;
		}

		/* 3 points with x/y each */
		index = (i - 1) * 6;
		if (pointsShort) {

			/* Load short points */
			x0 = (((short *) points))[index];
			y0 = (((short *) points))[index + 1];
			x1 = (((short *) points))[index + 2];
			y1 = (((short *) points))[index + 3];
			x2 = (((short *) points))[index + 4];
			y2 = (((short *) points))[index + 5];
		}
		else {
			x0 = (((int *) points))[index];
			y0 = (((int *) points))[index + 1];
			x1 = (((int *) points))[index + 2];
			y1 = (((int *) points))[index + 3];
			x2 = (((int *) points))[index + 4];
			y2 = (((int *) points))[index + 5];
		}
		if (((x0 == x1)
		 && (y0 == y1))
		 || ((x1 == x2)
		 && (y1 == y2))) {

			/* We can use a line from x0/y0 to x2/y2 */
			if ((x0 == x2)
			 && (y0 == y2)) {
				goto l1;
			}
			(*((int *) (workBuffer + GWPoint1)) = x0);
			(((int *) (workBuffer + GWPoint1)))[1] = y0;
			(*((int *) (workBuffer + GWPoint2)) = x2);
			(((int *) (workBuffer + GWPoint2)))[1] = y2;

			/* begin transformPoints: */
			if (2 > 0) {
				point = ((int *) (workBuffer + GWPoint1));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 1) {
				point = ((int *) (workBuffer + GWPoint2));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 2) {
				point = ((int *) (workBuffer + GWPoint3));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 3) {
				point = ((int *) (workBuffer + GWPoint4));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			loadWideLinefromtolineFillleftFillrightFill(lineWidth, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), lineFill, fillIndex, 0);
			goto l1;
		}
		(*((int *) (workBuffer + GWPoint1)) = x0);
		(((int *) (workBuffer + GWPoint1)))[1] = y0;
		(*((int *) (workBuffer + GWPoint2)) = x1);
		(((int *) (workBuffer + GWPoint2)))[1] = y1;
		(*((int *) (workBuffer + GWPoint3)) = x2);
		(((int *) (workBuffer + GWPoint3)))[1] = y2;

		/* begin transformPoints: */
		if (3 > 0) {
			point = ((int *) (workBuffer + GWPoint1));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 1) {
			point = ((int *) (workBuffer + GWPoint2));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 2) {
			point = ((int *) (workBuffer + GWPoint3));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		if (3 > 3) {
			point = ((int *) (workBuffer + GWPoint4));

			/* begin transformPoint: */
			if (workBuffer[GWHasEdgeTransform]) {

				/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
				/* begin transformPoint:into: */
				dstPoint1 = ((int *) point);
				transform = ((float *) (workBuffer + GWEdgeTransform));
				x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
				y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
				dstPoint1[0] = x;
				dstPoint1[1] = y;
			}
			else {

				/* Multiply each component by aaLevel and add a half pixel */
				point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
				point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
			}
		}
		segs = loadAndSubdivideBezierFromviatoisWide(((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), (lineWidth != 0)
			 && (lineFill != 0));
		if (engineStopped) {
			goto l1;
		}
		loadWideBezierlineFillleftFillrightFilln(lineWidth, lineFill, fillIndex, 0, segs);
l1:	/* end loadCompressedSegment:from:short:leftFill:rightFill:lineWidth:lineColor: */;
		if (engineStopped) {
			return null;
		}
	}
	return 0;
}


/*	Load the span buffer from the given oop.
	Answer 0 on success or a non-zero failure code on failure. */

	/* BalloonEngineBase>>#loadSpanBufferFrom: */
static sqInt
loadSpanBufferFrom(sqInt spanOop)
{
    sqInt value;

	if (!((fetchClassOf(spanOop)) == (classBitmap()))) {
		return GEFClassMismatch;
	}

	/* Leave last entry unused to avoid complications */
	spanBuffer = firstIndexableField(spanOop);
	value = (slotSizeOf(spanOop)) - 1;

	/* begin spanSizePut: */
	workBuffer[GWSpanSize] = value;
	return 0;
}


/*	Load a transformation from transformOop into the float array
	defined by destPtr. The transformation is assumed to be either
	an array or a FloatArray of length n. */

	/* BalloonEngineBase>>#loadTransformFrom:into:length: */
static sqInt
loadTransformFromintolength(sqInt transformOop, float *destPtr, sqInt n)
{
	if (transformOop == (nilObject())) {
		return 0;
	}
	if (isImmediate(transformOop)) {
		return primitiveFail();
	}
	if (!((slotSizeOf(transformOop)) == n)) {
		return primitiveFail();
	}
	if (isWords(transformOop)) {
		loadWordTransformFromintolength(transformOop, destPtr, n);
	}
	else {
		loadArrayTransformFromintolength(transformOop, destPtr, n);
	}
	return 1;
}


/*	Load the (possibly wide) bezier from the segments currently on the bezier
	stack. 
 */

	/* BalloonEnginePlugin>>#loadWideBezier:lineFill:leftFill:rightFill:n: */
static sqInt
loadWideBezierlineFillleftFillrightFilln(sqInt lineWidth, sqInt lineFill, sqInt leftFill, sqInt rightFill, sqInt nSegments)
{
    sqInt bezier;
    sqInt bezier1;
    sqInt bezierSqInt;
    sqInt index;
    sqInt offset;
    sqInt wide;

	if ((lineWidth == 0)
	 || (lineFill == 0)) {
		wide = 0;
		offset = 0;
	}
	else {
		wide = 1;
		offset = lineWidth / 2;
	}
	index = nSegments * 6;
	while (index > 0) {
		if (wide) {
			/* begin allocateWideBezier */
			if (!(allocateObjEntry(GBWideSize))) {
				bezier = 0;
				goto l1;
			}
			bezierSqInt = objUsed;
			objUsed = bezierSqInt + GBWideSize;

			/* #objectTypeOf:put: #obj:at:put: */
			objBuffer[bezierSqInt + GEObjectType] = GEPrimitiveWideBezier;

			/* #objectIndexOf:put: #obj:at:put: */
			objBuffer[bezierSqInt + GEObjectIndex] = 0;

			/* #objectLengthOf:put: #obj:at:put: */
			objBuffer[bezierSqInt + GEObjectLength] = GBWideSize;
			bezier = bezierSqInt;
l1:	/* end allocateWideBezier */;
		}
		else {
			/* begin allocateBezier */
			if (!(allocateObjEntry(GBBaseSize))) {
				bezier = 0;
				goto l2;
			}
			bezier1 = objUsed;
			objUsed = bezier1 + GBBaseSize;

			/* #objectTypeOf:put: #obj:at:put: */
			objBuffer[bezier1 + GEObjectType] = GEPrimitiveBezier;

			/* #objectIndexOf:put: #obj:at:put: */
			objBuffer[bezier1 + GEObjectIndex] = 0;

			/* #objectLengthOf:put: #obj:at:put: */
			objBuffer[bezier1 + GEObjectLength] = GBBaseSize;
			bezier = bezier1;
l2:	/* end allocateBezier */;
		}
		if (engineStopped) {
			return 0;
		}
		loadBeziersegmentleftFillrightFilloffset(bezier, index, leftFill, rightFill, offset);
		if (wide) {
			/* #wideBezierFillOf:put: #obj:at:put: */
			objBuffer[bezier + GBWideFill] = lineFill;

			/* #wideBezierWidthOf:put: #obj:at:put: */
			objBuffer[bezier + GBWideWidth] = lineWidth;

			/* #wideBezierExtentOf:put: #obj:at:put: */
			objBuffer[bezier + GBWideExtent] = lineWidth;
		}
		index -= 6;
	}

	/* begin wbStackClear */
	/* wbTopPut: */
	workBuffer[GWBufferTop] = (workBuffer[GWSize]);
	return 0;
}


/*	Load a (possibly wide) line defined by the points p1 and p2 */

	/* BalloonEnginePlugin>>#loadWideLine:from:to:lineFill:leftFill:rightFill: */
static sqInt
loadWideLinefromtolineFillleftFillrightFill(sqInt lineWidth, int *p1, int *p2, sqInt lineFill, sqInt leftFill, sqInt rightFill)
{
    sqInt line;
    sqInt lineSqInt;
    sqInt offset;
    int *p11;
    int *p21;
    sqInt yDir;

	if ((lineWidth == 0)
	 || (lineFill == 0)) {
		/* begin allocateLine */
		if (!(allocateObjEntry(GLBaseSize))) {
			line = 0;
			goto l1;
		}
		lineSqInt = objUsed;
		objUsed = lineSqInt + GLBaseSize;

		/* #objectTypeOf:put: #obj:at:put: */
		objBuffer[lineSqInt + GEObjectType] = GEPrimitiveLine;

		/* #objectIndexOf:put: #obj:at:put: */
		objBuffer[lineSqInt + GEObjectIndex] = 0;

		/* #objectLengthOf:put: #obj:at:put: */
		objBuffer[lineSqInt + GEObjectLength] = GLBaseSize;
		line = lineSqInt;
l1:	/* end allocateLine */;
		offset = 0;
	}
	else {
		/* begin allocateWideLine */
		if (!(allocateObjEntry(GLWideSize))) {
			line = 0;
			goto l2;
		}
		lineSqInt = objUsed;
		objUsed = lineSqInt + GLWideSize;

		/* #objectTypeOf:put: #obj:at:put: */
		objBuffer[lineSqInt + GEObjectType] = GEPrimitiveWideLine;

		/* #objectIndexOf:put: #obj:at:put: */
		objBuffer[lineSqInt + GEObjectIndex] = 0;

		/* #objectLengthOf:put: #obj:at:put: */
		objBuffer[lineSqInt + GEObjectLength] = GLWideSize;
		line = lineSqInt;
l2:	/* end allocateWideLine */;
		offset = lineWidth / 2;
	}
	if (engineStopped) {
		return 0;
	}

	/* begin loadLine:from:to:offset:leftFill:rightFill: */
	if ((p1[1]) <= (p2[1])) {
		p11 = p1;
		p21 = p2;
		yDir = 1;
	}
	else {
		p11 = p2;
		p21 = p1;
		yDir = -1;
	}

	/* #edgeXValueOf:put: #obj:at:put: */
	objBuffer[line + GEXValue] = (p11[0]);

	/* #edgeYValueOf:put: #obj:at:put: */
	objBuffer[line + GEYValue] = ((p11[1]) - offset);

	/* #edgeZValueOf:put: #obj:at:put: */
	objBuffer[line + GEZValue] = (workBuffer[GWCurrentZ]);

	/* #edgeLeftFillOf:put: #obj:at:put: */
	objBuffer[line + GEFillIndexLeft] = leftFill;

	/* #edgeRightFillOf:put: #obj:at:put: */
	objBuffer[line + GEFillIndexRight] = rightFill;

	/* #lineEndXOf:put: #obj:at:put: */
	objBuffer[line + GLEndX] = (p21[0]);

	/* #lineEndYOf:put: #obj:at:put: */
	objBuffer[line + GLEndY] = ((p21[1]) - offset);

	/* #lineYDirectionOf:put: #obj:at:put: */
	objBuffer[line + GLYDirection] = yDir;
	if (((objBuffer[line + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWide) {
		/* #wideLineFillOf:put: #obj:at:put: */
		objBuffer[line + GLWideFill] = lineFill;

		/* #wideLineWidthOf:put: #obj:at:put: */
		objBuffer[line + GLWideWidth] = lineWidth;

		/* #wideLineExtentOf:put: #obj:at:put: */
		objBuffer[line + GLWideExtent] = lineWidth;
	}
	return 0;
}


/*	Load a float array transformation from the given oop */

	/* BalloonEngineBase>>#loadWordTransformFrom:into:length: */
static sqInt
loadWordTransformFromintolength(sqInt transformOop, float *destPtr, sqInt n)
{
    sqInt i;
    float *srcPtr;

	srcPtr = firstIndexableField(transformOop);
	for (i = 0; i < n; i += 1) {
		destPtr[i] = (srcPtr[i]);
	}
	return 0;
}


/*	Load the working buffer from the given oop */

	/* BalloonEngineBase>>#loadWorkBufferFrom: */
static sqInt
loadWorkBufferFrom(sqInt wbOop)
{
	if (isImmediate(wbOop)) {
		return GEFWorkBufferIsInteger;
	}
	if (!(isWords(wbOop))) {
		return GEFWorkBufferIsPointers;
	}
	if ((slotSizeOf(wbOop)) < GWMinimalSize) {
		return GEFWorkBufferTooSmall;
	}

	/* begin workBufferPut: */
	workBuffer = firstIndexableField(wbOop);
	if (!((workBuffer[GWMagicIndex]) == GWMagicNumber)) {
		return GEFWorkBufferBadMagic;
	}
	if (!((workBuffer[GWSize]) == (slotSizeOf(wbOop)))) {
		return GEFWorkBufferWrongSize;
	}
	if (!((workBuffer[GWObjStart]) == GWHeaderSize)) {
		return GEFWorkBufferStartWrong;
	}
	objBuffer = workBuffer + (workBuffer[GWObjStart]);
	getBuffer = objBuffer + (workBuffer[GWObjUsed]);

	/* Make sure we don't exceed the work buffer */
	aetBuffer = getBuffer + (workBuffer[GWGETUsed]);
	if ((((GWHeaderSize + (workBuffer[GWObjUsed])) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) > (workBuffer[GWSize])) {
		return GEFWorkTooBig;
	}
	return 0;
}


/*	The module with the given name was just unloaded.
	Make sure we have no dangling references. */

	/* BalloonEngineBase>>#moduleUnloaded: */
EXPORT(sqInt)
moduleUnloaded(char *aModuleName)
{
	if (!(strcmp(aModuleName, bbPluginName))) {

		/* BitBlt just shut down. How nasty. */
		loadBBFn = 0;
		copyBitsFn = 0;
	}
	return 0;
}


/*	The entry at index is not in the right position of the AET. 
	Move it to the left until the position is okay. */

	/* BalloonEngineBase>>#moveAETEntryFrom:edge:x: */
static sqInt
moveAETEntryFromedgex(sqInt index, sqInt edge, sqInt xValue)
{
    sqInt newIndex;

	newIndex = index;
	while ((newIndex > 0)
	 && ((objBuffer[(aetBuffer[newIndex - 1]) + GEXValue]) > xValue)) {
		aetBuffer[newIndex] = (aetBuffer[newIndex - 1]);
		newIndex -= 1;
	}
	aetBuffer[newIndex] = edge;
	return 0;
}


/*	We have just blitted a scan line to the screen.
	Do whatever seems to be a good idea here. */
/*	Note: In the future we may check the time needed for this scan line and
	interrupt processing to give the Smalltalk code a chance to run at a
	certain time.
 */
/*	Check if there is any more work to do. */

	/* BalloonEngineBase>>#postDisplayAction */
static sqInt
postDisplayAction(void)
{
	if (((workBuffer[GWGETStart]) >= (workBuffer[GWGETUsed]))
	 && ((workBuffer[GWAETUsed]) == 0)) {

		/* No more entries to process */
		/* statePut: */
		workBuffer[GWState] = GEStateCompleted;
	}
	if ((workBuffer[GWCurrentY]) >= (workBuffer[GWFillMaxY])) {

		/* Out of clipping range */
		/* statePut: */
		workBuffer[GWState] = GEStateCompleted;
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveAbortProcessing */
EXPORT(sqInt)
primitiveAbortProcessing(void)
{
    sqInt failureCode;

	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(0)))) {
		return primitiveFailFor(failureCode);
	}

	/* statePut: */
	workBuffer[GWState] = GEStateCompleted;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	return 0;
}


/*	Note: No need to load either bitBlt or spanBuffer */

	/* BalloonEngineBase>>#primitiveAddActiveEdgeEntry */
EXPORT(sqInt)
primitiveAddActiveEdgeEntry(void)
{
    int edge;
    sqInt edgeOop;
    sqInt failureCode;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateWaitingForEdge))) {
		return primitiveFailFor(failureCode);
	}
	edgeOop = stackObjectValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	edge = loadEdgeStateFrom(edgeOop);
	if (!edge) {
		return primitiveFailFor(GEFEdgeDataTooSmall);
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 1) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return primitiveFailFor(GEFWorkTooBig);
	}
	if ((objBuffer[edge + GENumLines]) > 0) {
		insertEdgeIntoAET(edge);
	}
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}

	/* statePut: */
	workBuffer[GWState] = GEStateAddingFromGET;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountAddAETEntry] = ((workBuffer[GWCountAddAETEntry]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeAddAETEntry] = ((workBuffer[GWTimeAddAETEntry]) + value);
	}
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddBezier */
EXPORT(sqInt)
primitiveAddBezier(void)
{
    int *dstPoint1;
    sqInt endOop;
    sqInt failureCode;
    usqInt leftFill;
    sqInt nSegments;
    int *point;
    usqInt rightFill;
    sqInt startOop;
    float *transform;
    sqInt viaOop;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	rightFill = positive32BitValueOf(stackValue(0));
	leftFill = positive32BitValueOf(stackValue(1));
	viaOop = stackObjectValue(2);
	endOop = stackObjectValue(3);
	startOop = stackObjectValue(4);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(5), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	if (!((isFillOkay(leftFill))
		 && (isFillOkay(rightFill)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	if ((leftFill == rightFill) && 0) {
		return pop(6);
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), startOop);
	loadPointfrom(((int *) (workBuffer + GWPoint2)), viaOop);
	loadPointfrom(((int *) (workBuffer + GWPoint3)), endOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* begin transformPoints: */
	if (3 > 0) {
		point = ((int *) (workBuffer + GWPoint1));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (3 > 1) {
		point = ((int *) (workBuffer + GWPoint2));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (3 > 2) {
		point = ((int *) (workBuffer + GWPoint3));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (3 > 3) {
		point = ((int *) (workBuffer + GWPoint4));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	nSegments = loadAndSubdivideBezierFromviatoisWide(((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), 0);

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + (nSegments * GBBaseSize)) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		goto l1;
	}
l1:	/* end needAvailableSpace: */;
	if (!engineStopped) {
		leftFill = transformColor(leftFill);
		rightFill = transformColor(rightFill);
	}
	if (!engineStopped) {
		loadWideBezierlineFillleftFillrightFilln(0, 0, leftFill, rightFill, nSegments);
	}
	if (engineStopped) {

		/* Make sure the stack is okay */
		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(5);
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddBezierShape */
EXPORT(sqInt)
primitiveAddBezierShape(void)
{
    sqInt failureCode;
    usqInt fillIndex;
    sqInt length;
    usqInt lineFill;
    sqInt lineWidth;
    sqInt nSegments;
    sqInt points;
    sqInt pointsIsArray;
    sqInt segSize;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	lineFill = positive32BitValueOf(stackValue(0));
	lineWidth = stackIntegerValue(1);
	fillIndex = positive32BitValueOf(stackValue(2));
	nSegments = stackIntegerValue(3);
	points = stackObjectValue(4);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(5), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	length = slotSizeOf(points);
	if (isWords(points)) {
		/* Either PointArray or ShortPointArray */
		pointsIsArray = 0;
		if (!((length == (nSegments * 3))
			 || (length == (nSegments * 6)))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
	}
	else {

		/* Must be Array of points */
		if (!(isArray(points))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		if (!(length == (nSegments * 3))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		pointsIsArray = 1;
	}
	if ((lineWidth == 0)
	 || (lineFill == 0)) {
		segSize = GLBaseSize;
	}
	else {
		segSize = GLWideSize;
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + (segSize * nSegments)) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return primitiveFailFor(GEFWorkTooBig);
	}
	if (!((isFillOkay(lineFill))
		 && (isFillOkay(fillIndex)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	lineFill = transformColor(lineFill);
	fillIndex = transformColor(fillIndex);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (((lineFill == 0)
	 || (lineWidth == 0))
	 && (fillIndex == 0)) {
		return pop(5);
	}
	if (lineWidth) {
		lineWidth = transformWidth(lineWidth);
		if (lineWidth < 1) {
			lineWidth = 1;
		}
	}
	if (pointsIsArray) {
		loadArrayShapenSegmentsfilllineWidthlineFill(points, nSegments, fillIndex, lineWidth, lineFill);
	}
	else {
		loadShapenSegmentsfilllineWidthlineFillpointsShort(firstIndexableField(points), nSegments, fillIndex, lineWidth, lineFill, (nSegments * 3) == length);
	}
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* needsFlushPut: */
	workBuffer[GWNeedsFlush] = 1;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(5);
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddBitmapFill */
EXPORT(sqInt)
primitiveAddBitmapFill(void)
{
    sqInt bmBits;
    sqInt bmBitsSize;
    sqInt bmDepth;
    sqInt bmFill;
    sqInt bmHeight;
    sqInt bmRaster;
    sqInt bmWidth;
    int *cm;
    int *cmBits;
    sqInt cmOop;
    sqInt cmSize;
    sqInt dirOop;
    sqInt failureCode;
    sqInt fill;
    sqInt fillSize;
    sqInt fillSqInt;
    sqInt formOop;
    sqInt i;
    sqInt nrmOop;
    sqInt originOop;
    sqInt ppw;
    sqInt tileFlag;
    sqInt tileFlagSqInt;
    sqInt xIndex;

	if (!((methodArgumentCount()) == 7)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	xIndex = stackIntegerValue(0);
	if (xIndex <= 0) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	nrmOop = stackObjectValue(1);
	dirOop = stackObjectValue(2);
	originOop = stackObjectValue(3);
	tileFlag = booleanValueOf(stackValue(4));
	cmOop = stackObjectValue(5);
	formOop = stackObjectValue(6);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(7), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), originOop);
	loadPointfrom(((int *) (workBuffer + GWPoint2)), dirOop);
	loadPointfrom(((int *) (workBuffer + GWPoint3)), nrmOop);
	if (failed()) {
		return primitiveFailFor(GEFBadPoint);
	}
	tileFlagSqInt = (tileFlag
				? 1
				: 0);

	/* begin loadBitmapFill:colormap:tile:from:along:normal:xIndex: */
	if (cmOop == (nilObject())) {
		cmSize = 0;
		cmBits = null;
	}
	else {
		if (!((fetchClassOf(cmOop)) == (classBitmap()))) {
			fill = primitiveFail();
			goto l2;
		}
		cmSize = slotSizeOf(cmOop);
		cmBits = firstIndexableField(cmOop);
	}
	if (!(isPointers(formOop))) {
		fill = primitiveFail();
		goto l2;
	}
	if ((slotSizeOf(formOop)) < 5) {
		fill = primitiveFail();
		goto l2;
	}
	bmBits = fetchPointerofObject(0, formOop);
	if (!((fetchClassOf(bmBits)) == (classBitmap()))) {
		fill = primitiveFail();
		goto l2;
	}
	bmBitsSize = slotSizeOf(bmBits);
	bmWidth = fetchIntegerofObject(1, formOop);
	bmHeight = fetchIntegerofObject(2, formOop);
	bmDepth = fetchIntegerofObject(3, formOop);
	if (failed()) {
		fill = null;
		goto l2;
	}
	if (!((bmWidth >= 0)
		 && (bmHeight >= 0))) {
		fill = primitiveFail();
		goto l2;
	}
	if (!((((((bmDepth == 32) || (bmDepth == 8)) || (bmDepth == 16)) || (bmDepth == 1)) || (bmDepth == 2)) || (bmDepth == 4))) {
		fill = primitiveFail();
		goto l2;
	}
	if (!((cmSize == 0)
		 || (cmSize == (1U << bmDepth)))) {
		fill = primitiveFail();
		goto l2;
	}
	ppw = 32 / bmDepth;
	bmRaster = (bmWidth + (ppw - 1)) / ppw;
	if (!(bmBitsSize == (bmRaster * bmHeight))) {
		fill = primitiveFail();
		goto l2;
	}

	/* begin allocateBitmapFill:colormap: */
	fillSize = GBMBaseSize + cmSize;
	if (!(allocateObjEntry(fillSize))) {
		bmFill = 0;
		goto l1;
	}
	fillSqInt = objUsed;
	objUsed = fillSqInt + fillSize;

	/* #objectTypeOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GEObjectType] = GEPrimitiveClippedBitmapFill;

	/* #objectIndexOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GEObjectIndex] = 0;

	/* #objectLengthOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GEObjectLength] = fillSize;
	cm = (objBuffer + fillSqInt) + GBColormapOffset;
	if (workBuffer[GWHasColorTransform]) {
		for (i = 0; i < cmSize; i += 1) {
			cm[i] = (transformColor(cmBits[i]));
		}
	}
	else {
		for (i = 0; i < cmSize; i += 1) {
			cm[i] = (cmBits[i]);
		}
	}

	/* #bitmapCmSizeOf:put: #obj:at:put: */
	objBuffer[fillSqInt + GBColormapSize] = cmSize;
	bmFill = fillSqInt;
l1:	/* end allocateBitmapFill:colormap: */;
	if (engineStopped) {
		fill = null;
		goto l2;
	}

	/* #bitmapWidthOf:put: #obj:at:put: */
	objBuffer[bmFill + GBBitmapWidth] = bmWidth;

	/* #bitmapHeightOf:put: #obj:at:put: */
	objBuffer[bmFill + GBBitmapHeight] = bmHeight;

	/* #bitmapDepthOf:put: #obj:at:put: */
	objBuffer[bmFill + GBBitmapDepth] = bmDepth;

	/* #bitmapRasterOf:put: #obj:at:put: */
	objBuffer[bmFill + GBBitmapRaster] = bmRaster;

	/* #bitmapSizeOf:put: #obj:at:put: */
	objBuffer[bmFill + GBBitmapSize] = bmBitsSize;

	/* #bitmapTileFlagOf:put: #obj:at:put: */
	objBuffer[bmFill + GBTileFlag] = tileFlagSqInt;

	/* #objectIndexOf:put: #obj:at:put: */
	objBuffer[bmFill + GEObjectIndex] = (xIndex - 1);
	loadFillOrientationfromalongnormalwidthheight(bmFill, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), bmWidth, bmHeight);
	fill = bmFill;
l2:	/* end loadBitmapFill:colormap:tile:from:along:normal:xIndex: */;
	if (engineStopped) {

		/* Make sure the stack is okay */
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	popthenPush(8, positive32BitIntegerFor(fill));
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddCompressedShape */
EXPORT(sqInt)
primitiveAddCompressedShape(void)
{
    sqInt failureCode;
    sqInt fillIndexList;
    sqInt leftFills;
    sqInt lineFills;
    sqInt lineWidths;
    sqInt nSegments;
    sqInt points;
    int pointsShort;
    sqInt rightFills;

	if (!((methodArgumentCount()) == 7)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	fillIndexList = stackObjectValue(0);
	lineFills = stackObjectValue(1);
	lineWidths = stackObjectValue(2);
	rightFills = stackObjectValue(3);
	leftFills = stackObjectValue(4);
	nSegments = stackIntegerValue(5);
	points = stackObjectValue(6);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(7), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	if (!(checkCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexList(points, nSegments, leftFills, rightFills, lineWidths, lineFills, fillIndexList))) {
		return primitiveFailFor(GEFEntityCheckFailed);
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + ((((GBBaseSize < GLBaseSize) ? GLBaseSize : GBBaseSize)) * nSegments)) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return primitiveFailFor(GEFWorkTooBig);
	}

	/* Then actually load the compressed shape */
	pointsShort = (slotSizeOf(points)) == (nSegments * 3);
	loadCompressedShapesegmentsleftFillsrightFillslineWidthslineFillsfillIndexListpointShort(firstIndexableField(points), nSegments, firstIndexableField(leftFills), firstIndexableField(rightFills), firstIndexableField(lineWidths), firstIndexableField(lineFills), firstIndexableField(fillIndexList), pointsShort);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* needsFlushPut: */
	workBuffer[GWNeedsFlush] = 1;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(7);
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddGradientFill */
EXPORT(sqInt)
primitiveAddGradientFill(void)
{
    sqInt dirOop;
    sqInt failureCode;
    sqInt fill;
    sqInt isRadial;
    sqInt nrmOop;
    sqInt originOop;
    sqInt rampOop;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	isRadial = booleanValueOf(stackValue(0));
	nrmOop = stackValue(1);
	dirOop = stackValue(2);
	originOop = stackValue(3);
	rampOop = stackValue(4);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(5), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), originOop);
	loadPointfrom(((int *) (workBuffer + GWPoint2)), dirOop);
	loadPointfrom(((int *) (workBuffer + GWPoint3)), nrmOop);
	if (failed()) {
		return primitiveFailFor(GEFBadPoint);
	}
	fill = loadGradientFillfromalongnormalisRadial(rampOop, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), isRadial);
	if (engineStopped) {

		/* Make sure the stack is okay */
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	popthenPush(6, positive32BitIntegerFor(fill));
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddLine */
EXPORT(sqInt)
primitiveAddLine(void)
{
    int *dstPoint1;
    sqInt endOop;
    sqInt failureCode;
    usqInt leftFill;
    int *point;
    usqInt rightFill;
    sqInt startOop;
    float *transform;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 4)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	rightFill = positive32BitValueOf(stackValue(0));
	leftFill = positive32BitValueOf(stackValue(1));
	endOop = stackObjectValue(2);
	startOop = stackObjectValue(3);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(4), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	if (!((isFillOkay(leftFill))
		 && (isFillOkay(rightFill)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), startOop);
	loadPointfrom(((int *) (workBuffer + GWPoint2)), endOop);
	if (failed()) {
		return primitiveFailFor(GEFBadPoint);
	}

	/* begin transformPoints: */
	if (2 > 0) {
		point = ((int *) (workBuffer + GWPoint1));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (2 > 1) {
		point = ((int *) (workBuffer + GWPoint2));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (2 > 2) {
		point = ((int *) (workBuffer + GWPoint3));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (2 > 3) {
		point = ((int *) (workBuffer + GWPoint4));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	leftFill = transformColor(leftFill);
	rightFill = transformColor(rightFill);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	loadWideLinefromtolineFillleftFillrightFill(0, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), 0, leftFill, rightFill);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(4);
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddOval */
EXPORT(sqInt)
primitiveAddOval(void)
{
    usqInt borderIndex;
    sqInt borderWidth;
    sqInt endOop;
    sqInt failureCode;
    usqInt fillIndex;
    sqInt startOop;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	borderIndex = positive32BitValueOf(stackValue(0));
	borderWidth = stackIntegerValue(1);
	fillIndex = positive32BitValueOf(stackValue(2));
	endOop = stackObjectValue(3);
	startOop = stackObjectValue(4);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(5), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	if (!((isFillOkay(borderIndex))
		 && (isFillOkay(fillIndex)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	fillIndex = transformColor(fillIndex);
	borderIndex = transformColor(borderIndex);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if ((fillIndex == 0)
	 && ((borderIndex == 0)
	 || (borderWidth <= 0))) {
		return pop(5);
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + (16 * GBBaseSize)) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return primitiveFailFor(GEFWorkTooBig);
	}
	if ((borderWidth > 0)
	 && (borderIndex != 0)) {
		borderWidth = transformWidth(borderWidth);
	}
	else {
		borderWidth = 0;
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), startOop);
	loadPointfrom(((int *) (workBuffer + GWPoint2)), endOop);
	if (failed()) {
		return primitiveFailFor(GEFBadPoint);
	}
	loadOvallineFillleftFillrightFill(borderWidth, borderIndex, 0, fillIndex);
	if (engineStopped) {
		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* needsFlushPut: */
	workBuffer[GWNeedsFlush] = 1;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(5);
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddPolygon */
EXPORT(sqInt)
primitiveAddPolygon(void)
{
    int *dstPoint1;
    sqInt failureCode;
    usqInt fillIndex;
    sqInt i;
    sqInt length;
    usqInt lineFill;
    sqInt lineWidth;
    sqInt nPoints;
    int *point;
    sqInt points;
    int *points1;
    sqInt pointsIsArray;
    sqInt segSize;
    float *transform;
    sqInt x;
    int x0;
    sqInt x0SqInt;
    int x1;
    sqInt x1SqInt;
    sqInt y;
    int y0;
    sqInt y0SqInt;
    int y1;
    sqInt y1SqInt;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	lineFill = positive32BitValueOf(stackValue(0));
	lineWidth = stackIntegerValue(1);
	fillIndex = positive32BitValueOf(stackValue(2));
	nPoints = stackIntegerValue(3);
	points = stackObjectValue(4);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(5), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	length = slotSizeOf(points);
	if (isWords(points)) {
		/* Either PointArray or ShortPointArray */
		pointsIsArray = 0;
		if (!((length == nPoints)
			 || ((nPoints * 2) == length))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
	}
	else {

		/* Must be Array of points */
		if (!(isArray(points))) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		if (!(length == nPoints)) {
			return primitiveFailFor(PrimErrBadArgument);
		}
		pointsIsArray = 1;
	}
	if ((lineWidth == 0)
	 || (lineFill == 0)) {
		segSize = GLBaseSize;
	}
	else {
		segSize = GLWideSize;
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + (segSize * nPoints)) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return primitiveFail();
	}
	if (!((isFillOkay(lineFill))
		 && (isFillOkay(fillIndex)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	lineFill = transformColor(lineFill);
	fillIndex = transformColor(fillIndex);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (((lineFill == 0)
	 || (lineWidth == 0))
	 && (fillIndex == 0)) {
		return pop(5);
	}
	if (lineWidth) {
		lineWidth = transformWidth(lineWidth);
	}
	if (pointsIsArray) {
		/* begin loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */
		loadPointfrom(((int *) (workBuffer + GWPoint1)), fetchPointerofObject(0, points));
		if (failed()) {
			goto l1;
		}
		x0 = (*((int *) (workBuffer + GWPoint1)));
		y0 = (((int *) (workBuffer + GWPoint1)))[1];
		for (i = 1; i < nPoints; i += 1) {
			loadPointfrom(((int *) (workBuffer + GWPoint1)), fetchPointerofObject(i, points));
			if (failed()) {
				goto l1;
			}
			x1 = (*((int *) (workBuffer + GWPoint1)));
			y1 = (((int *) (workBuffer + GWPoint1)))[1];
			(*((int *) (workBuffer + GWPoint1)) = x0);
			(((int *) (workBuffer + GWPoint1)))[1] = y0;
			(*((int *) (workBuffer + GWPoint2)) = x1);
			(((int *) (workBuffer + GWPoint2)))[1] = y1;

			/* begin transformPoints: */
			if (2 > 0) {
				point = ((int *) (workBuffer + GWPoint1));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 1) {
				point = ((int *) (workBuffer + GWPoint2));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 2) {
				point = ((int *) (workBuffer + GWPoint3));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 3) {
				point = ((int *) (workBuffer + GWPoint4));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			loadWideLinefromtolineFillleftFillrightFill(lineWidth, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), lineFill, fillIndex, 0);
			if (engineStopped) {
				goto l1;
			}
			x0 = x1;
			y0 = y1;
		}
l1:	/* end loadArrayPolygon:nPoints:fill:lineWidth:lineFill: */;
	}
	else {
		points1 = firstIndexableField(points);

		/* begin loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort: */
		if (nPoints == length) {
			x0SqInt = (*((short *) points1));
			y0SqInt = (((short *) points1))[1];
		}
		else {
			x0SqInt = (*((int *) points1));
			y0SqInt = (((int *) points1))[1];
		}
		for (i = 1; i < nPoints; i += 1) {
			if (nPoints == length) {
				x1SqInt = (((short *) points1))[i * 2];
				y1SqInt = (((short *) points1))[(i * 2) + 1];
			}
			else {
				x1SqInt = (((int *) points1))[i * 2];
				y1SqInt = (((int *) points1))[(i * 2) + 1];
			}
			(*((int *) (workBuffer + GWPoint1)) = x0SqInt);
			(((int *) (workBuffer + GWPoint1)))[1] = y0SqInt;
			(*((int *) (workBuffer + GWPoint2)) = x1SqInt);
			(((int *) (workBuffer + GWPoint2)))[1] = y1SqInt;

			/* begin transformPoints: */
			if (2 > 0) {
				point = ((int *) (workBuffer + GWPoint1));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 1) {
				point = ((int *) (workBuffer + GWPoint2));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 2) {
				point = ((int *) (workBuffer + GWPoint3));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			if (2 > 3) {
				point = ((int *) (workBuffer + GWPoint4));

				/* begin transformPoint: */
				if (workBuffer[GWHasEdgeTransform]) {

					/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
					/* begin transformPoint:into: */
					dstPoint1 = ((int *) point);
					transform = ((float *) (workBuffer + GWEdgeTransform));
					x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
					y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
					dstPoint1[0] = x;
					dstPoint1[1] = y;
				}
				else {

					/* Multiply each component by aaLevel and add a half pixel */
					point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
					point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
				}
			}
			loadWideLinefromtolineFillleftFillrightFill(lineWidth, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), lineFill, fillIndex, 0);
			if (engineStopped) {
				goto l2;
			}
			x0SqInt = x1SqInt;
			y0SqInt = y1SqInt;
		}
l2:	/* end loadPolygon:nPoints:fill:lineWidth:lineFill:pointsShort: */;
	}
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* needsFlushPut: */
	workBuffer[GWNeedsFlush] = 1;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(5);
	return 0;
}


/*	Fail if we have the wrong number of arguments */

	/* BalloonEnginePlugin>>#primitiveAddRect */
EXPORT(sqInt)
primitiveAddRect(void)
{
    usqInt borderIndex;
    sqInt borderWidth;
    int *dstPoint1;
    sqInt endOop;
    sqInt failureCode;
    usqInt fillIndex;
    int *point;
    sqInt startOop;
    float *transform;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	borderIndex = positive32BitValueOf(stackValue(0));
	borderWidth = stackIntegerValue(1);
	fillIndex = positive32BitValueOf(stackValue(2));
	endOop = stackObjectValue(3);
	startOop = stackObjectValue(4);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(5), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	if (!((isFillOkay(borderIndex))
		 && (isFillOkay(fillIndex)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	borderIndex = transformColor(borderIndex);
	fillIndex = transformColor(fillIndex);
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if ((fillIndex == 0)
	 && ((borderIndex == 0)
	 || (borderWidth == 0))) {
		return pop(5);
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + (4 * GLBaseSize)) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return primitiveFailFor(GEFWorkTooBig);
	}
	if ((borderWidth > 0)
	 && (borderIndex != 0)) {
		borderWidth = transformWidth(borderWidth);
	}
	else {
		borderWidth = 0;
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), startOop);
	loadPointfrom(((int *) (workBuffer + GWPoint3)), endOop);
	if (failed()) {
		return primitiveFailFor(GEFBadPoint);
	}
	(*((int *) (workBuffer + GWPoint2)) = (*((int *) (workBuffer + GWPoint3))));
	(((int *) (workBuffer + GWPoint2)))[1] = ((((int *) (workBuffer + GWPoint1)))[1]);
	(*((int *) (workBuffer + GWPoint4)) = (*((int *) (workBuffer + GWPoint1))));
	(((int *) (workBuffer + GWPoint4)))[1] = ((((int *) (workBuffer + GWPoint3)))[1]);

	/* begin transformPoints: */
	if (4 > 0) {
		point = ((int *) (workBuffer + GWPoint1));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (4 > 1) {
		point = ((int *) (workBuffer + GWPoint2));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (4 > 2) {
		point = ((int *) (workBuffer + GWPoint3));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (4 > 3) {
		point = ((int *) (workBuffer + GWPoint4));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}

	/* begin loadRectangle:lineFill:leftFill:rightFill: */
	loadWideLinefromtolineFillleftFillrightFill(borderWidth, ((int *) (workBuffer + GWPoint1)), ((int *) (workBuffer + GWPoint2)), borderIndex, 0, fillIndex);
	loadWideLinefromtolineFillleftFillrightFill(borderWidth, ((int *) (workBuffer + GWPoint2)), ((int *) (workBuffer + GWPoint3)), borderIndex, 0, fillIndex);
	loadWideLinefromtolineFillleftFillrightFill(borderWidth, ((int *) (workBuffer + GWPoint3)), ((int *) (workBuffer + GWPoint4)), borderIndex, 0, fillIndex);
	loadWideLinefromtolineFillleftFillrightFill(borderWidth, ((int *) (workBuffer + GWPoint4)), ((int *) (workBuffer + GWPoint1)), borderIndex, 0, fillIndex);
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* needsFlushPut: */
	workBuffer[GWNeedsFlush] = 1;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(5);
	return 0;
}


/*	Note: No need to load either bitBlt or spanBuffer */

	/* BalloonEngineBase>>#primitiveChangedActiveEdgeEntry */
EXPORT(sqInt)
primitiveChangedActiveEdgeEntry(void)
{
    int edge;
    sqInt edgeOop;
    sqInt failureCode;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateWaitingChange))) {
		return primitiveFailFor(failureCode);
	}
	edgeOop = stackObjectValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	edge = loadEdgeStateFrom(edgeOop);
	if (!edge) {
		return primitiveFailFor(GEFEdgeDataTooSmall);
	}
	if (objBuffer[edge + GENumLines]) {
		resortFirstAETEntry();

		/* aetStartPut: */
		workBuffer[GWAETStart] = ((workBuffer[GWAETStart]) + 1);
	}
	else {
		removeFirstAETEntry();
	}

	/* statePut: */
	workBuffer[GWState] = GEStateUpdateEdges;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountChangeAETEntry] = ((workBuffer[GWCountChangeAETEntry]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeChangeAETEntry] = ((workBuffer[GWTimeChangeAETEntry]) + value);
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveCopyBuffer */
EXPORT(sqInt)
primitiveCopyBuffer(void)
{
    sqInt buf1;
    sqInt buf2;
    sqInt diff;
    int *dst;
    sqInt failCode;
    sqInt i;
    int *src;
    int toDoLimit;
    int toDoLimit1;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	buf2 = stackValue(0);

	/* Make sure the old buffer is properly initialized */
	buf1 = stackValue(1);
	if ((failCode = loadWorkBufferFrom(buf1))) {
		return primitiveFailFor(failCode);
	}
	if (!((fetchClassOf(buf1)) == (fetchClassOf(buf2)))) {
		return primitiveFailFor(GEFClassMismatch);
	}
	diff = (slotSizeOf(buf2)) - (slotSizeOf(buf1));
	if (diff < 0) {
		return primitiveFailFor(GEFSizeMismatch);
	}
	src = workBuffer;
	dst = firstIndexableField(buf2);
	toDoLimit = (workBuffer[GWBufferTop]) - 1;
	for (i = 0; i <= toDoLimit; i += 1) {
		dst[i] = (src[i]);
	}
	dst[GWBufferTop] = ((workBuffer[GWBufferTop]) + diff);
	dst[GWSize] = ((workBuffer[GWSize]) + diff);
	src += workBuffer[GWBufferTop];
	dst = (dst + (workBuffer[GWBufferTop])) + diff;
	toDoLimit1 = ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 1;
	for (i = 0; i <= toDoLimit1; i += 1) {
		dst[i] = (src[i]);
	}
	if ((failCode = loadWorkBufferFrom(buf2))) {
		return primitiveFailFor(failCode);
	}
	pop(2);
	return 0;
}


/*	Note: Must load bitBlt and spanBuffer */

	/* BalloonEngineBase>>#primitiveDisplaySpanBuffer */
EXPORT(sqInt)
primitiveDisplaySpanBuffer(void)
{
    sqInt failureCode;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(0), GEStateBlitBuffer))) {
		return primitiveFailFor(failureCode);
	}
	if ((failureCode = loadSpanBufferFrom(fetchPointerofObject(BESpanIndex, engine)))) {
		return primitiveFailFor(failureCode);
	}
	if (!(loadBitBltFrom(fetchPointerofObject(BEBitBltIndex, engine)))) {
		return primitiveFailFor(GEFBitBltLoadFailed);
	}
	if (((workBuffer[GWCurrentY]) & (workBuffer[GWAAScanMask])) == (workBuffer[GWAAScanMask])) {
		displaySpanBufferAt(workBuffer[GWCurrentY]);
		postDisplayAction();
	}
	if (!((workBuffer[GWState]) == GEStateCompleted)) {
		/* aetStartPut: */
		workBuffer[GWAETStart] = 0;

		/* currentYPut: */
		workBuffer[GWCurrentY] = ((workBuffer[GWCurrentY]) + 1);

		/* statePut: */
		workBuffer[GWState] = GEStateUpdateEdges;
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountDisplaySpan] = ((workBuffer[GWCountDisplaySpan]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeDisplaySpan] = ((workBuffer[GWTimeDisplaySpan]) + value);
	}
	return 0;
}


/*	Turn on/off profiling. Return the old value of the flag. */

	/* BalloonEngineBase>>#primitiveDoProfileStats */
EXPORT(sqInt)
primitiveDoProfileStats(void)
{
    sqInt newValue;
    int oldValue;

	oldValue = doProfileStats;
	newValue = stackObjectValue(0);
	newValue = booleanValueOf(newValue);
	if (!(failed())) {
		doProfileStats = newValue;
		pop(2);
		pushBool(oldValue);
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveFinishedProcessing */
EXPORT(sqInt)
primitiveFinishedProcessing(void)
{
    sqInt failureCode;
    int finished;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(0)))) {
		return primitiveFailFor(failureCode);
	}
	finished = (workBuffer[GWState]) == GEStateCompleted;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	pushBool(finished);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountFinishTest] = ((workBuffer[GWCountFinishTest]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeFinishTest] = ((workBuffer[GWTimeFinishTest]) + value);
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveGetAALevel */
EXPORT(sqInt)
primitiveGetAALevel(void)
{
    sqInt failureCode;

	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(0)))) {
		return primitiveFailFor(failureCode);
	}
	pop(1);
	pushInteger(workBuffer[GWAALevel]);
	return 0;
}

	/* BalloonEnginePlugin>>#primitiveGetBezierStats */
EXPORT(sqInt)
primitiveGetBezierStats(void)
{
    sqInt failureCode;
    sqInt statOop;
    int *stats;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(1)))) {
		return primitiveFailFor(failureCode);
	}
	statOop = stackObjectValue(0);
	if (!((!(failed()))
		 && ((isWords(statOop))
		 && ((slotSizeOf(statOop)) >= 4)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	stats = firstIndexableField(statOop);
	stats[0] = ((stats[0]) + (workBuffer[GWBezierMonotonSubdivisions]));
	stats[1] = ((stats[1]) + (workBuffer[GWBezierHeightSubdivisions]));
	stats[2] = ((stats[2]) + (workBuffer[GWBezierOverflowSubdivisions]));
	stats[3] = ((stats[3]) + (workBuffer[GWBezierLineConversions]));
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveGetClipRect */
EXPORT(sqInt)
primitiveGetClipRect(void)
{
    sqInt failureCode;
    sqInt pointOop;
    sqInt rectOop;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(1)))) {
		return primitiveFailFor(failureCode);
	}
	rectOop = stackObjectValue(0);
	if (!((!(failed()))
		 && ((isPointers(rectOop))
		 && ((slotSizeOf(rectOop)) >= 2)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	pushRemappableOop(rectOop);
	pointOop = makePointwithxValueyValue(workBuffer[GWClipMinX], workBuffer[GWClipMinY]);
	storePointerofObjectwithValue(0, topRemappableOop(), pointOop);
	pointOop = makePointwithxValueyValue(workBuffer[GWClipMaxX], workBuffer[GWClipMaxY]);
	rectOop = popRemappableOop();
	storePointerofObjectwithValue(1, rectOop, pointOop);
	popthenPush(2, rectOop);
	return 0;
}

	/* BalloonEngineBase>>#primitiveGetCounts */
EXPORT(sqInt)
primitiveGetCounts(void)
{
    sqInt failureCode;
    sqInt statOop;
    int *stats;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(1)))) {
		return primitiveFailFor(failureCode);
	}
	statOop = stackObjectValue(0);
	if (!((!(failed()))
		 && ((isWords(statOop))
		 && ((slotSizeOf(statOop)) >= 9)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	stats = firstIndexableField(statOop);
	stats[0] = ((stats[0]) + (workBuffer[GWCountInitializing]));
	stats[1] = ((stats[1]) + (workBuffer[GWCountFinishTest]));
	stats[2] = ((stats[2]) + (workBuffer[GWCountNextGETEntry]));
	stats[3] = ((stats[3]) + (workBuffer[GWCountAddAETEntry]));
	stats[4] = ((stats[4]) + (workBuffer[GWCountNextFillEntry]));
	stats[5] = ((stats[5]) + (workBuffer[GWCountMergeFill]));
	stats[6] = ((stats[6]) + (workBuffer[GWCountDisplaySpan]));
	stats[7] = ((stats[7]) + (workBuffer[GWCountNextAETEntry]));
	stats[8] = ((stats[8]) + (workBuffer[GWCountChangeAETEntry]));
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveGetDepth */
EXPORT(sqInt)
primitiveGetDepth(void)
{
    sqInt failureCode;

	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(0)))) {
		return primitiveFailFor(failureCode);
	}
	pop(1);
	pushInteger(workBuffer[GWCurrentZ]);
	return 0;
}


/*	Return the reason why the last operation failed. */

	/* BalloonEngineBase>>#primitiveGetFailureReason */
EXPORT(sqInt)
primitiveGetFailureReason(void)
{
    sqInt failCode;

	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}

	/* Note -- don't call loadEngineFrom here because this will override the stopReason with Zero */
	engine = stackValue(0);
	if (isImmediate(engine)) {
		return primitiveFailFor(GEFEngineIsInteger);
	}
	if (!(isPointers(engine))) {
		return primitiveFailFor(GEFEngineIsWords);
	}
	if ((slotSizeOf(engine)) < BEBalloonEngineSize) {
		return primitiveFailFor(GEFEngineTooSmall);
	}
	if ((failCode = loadWorkBufferFrom(fetchPointerofObject(BEWorkBufferIndex, engine)))) {
		return primitiveFailFor(failCode);
	}
	pop(1);
	pushInteger(workBuffer[GWStopReason]);
	return 0;
}

	/* BalloonEngineBase>>#primitiveGetOffset */
EXPORT(sqInt)
primitiveGetOffset(void)
{
    sqInt failureCode;
    sqInt pointOop;

	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(0)))) {
		return primitiveFailFor(failureCode);
	}
	pointOop = makePointwithxValueyValue(workBuffer[GWDestOffsetX], workBuffer[GWDestOffsetY]);
	popthenPush(1, pointOop);
	return 0;
}

	/* BalloonEngineBase>>#primitiveGetTimes */
EXPORT(sqInt)
primitiveGetTimes(void)
{
    sqInt failureCode;
    sqInt statOop;
    int *stats;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(1)))) {
		return primitiveFailFor(failureCode);
	}
	statOop = stackObjectValue(0);
	if (!((!(failed()))
		 && ((isWords(statOop))
		 && ((slotSizeOf(statOop)) >= 9)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	stats = firstIndexableField(statOop);
	stats[0] = ((stats[0]) + (workBuffer[GWTimeInitializing]));
	stats[1] = ((stats[1]) + (workBuffer[GWTimeFinishTest]));
	stats[2] = ((stats[2]) + (workBuffer[GWTimeNextGETEntry]));
	stats[3] = ((stats[3]) + (workBuffer[GWTimeAddAETEntry]));
	stats[4] = ((stats[4]) + (workBuffer[GWTimeNextFillEntry]));
	stats[5] = ((stats[5]) + (workBuffer[GWTimeMergeFill]));
	stats[6] = ((stats[6]) + (workBuffer[GWTimeDisplaySpan]));
	stats[7] = ((stats[7]) + (workBuffer[GWTimeNextAETEntry]));
	stats[8] = ((stats[8]) + (workBuffer[GWTimeChangeAETEntry]));
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveInitializeBuffer */
EXPORT(sqInt)
primitiveInitializeBuffer(void)
{
    sqInt size;
    sqInt wbOop;

	wbOop = 0;
	if (!(((methodArgumentCount()) == 1)
		 && ((isWords((wbOop = stackValue(0))))
		 && (((size = slotSizeOf(wbOop))) >= GWMinimalSize)))) {
		return primitiveFail();
	}

	/* begin workBufferPut: */
	workBuffer = firstIndexableField(wbOop);
	objBuffer = workBuffer + GWHeaderSize;

	/* magicNumberPut: */
	workBuffer[GWMagicIndex] = GWMagicNumber;

	/* wbSizePut: */
	workBuffer[GWSize] = size;

	/* wbTopPut: */
	workBuffer[GWBufferTop] = size;

	/* statePut: */
	workBuffer[GWState] = GEStateUnlocked;

	/* objStartPut: */
	workBuffer[GWObjStart] = GWHeaderSize;

	/* objUsedPut: */
	workBuffer[GWObjUsed] = 4;

	/* #objectTypeOf:put: #obj:at:put: */
	objBuffer[0 /* (0 + GEObjectType) */] = GEPrimitiveFill;

	/* #objectLengthOf:put: #obj:at:put: */
	objBuffer[1 /* (0 + GEObjectLength) */] = 4;

	/* #objectIndexOf:put: #obj:at:put: */
	objBuffer[2 /* (0 + GEObjectIndex) */] = 0;

	/* getStartPut: */
	workBuffer[GWGETStart] = 0;

	/* getUsedPut: */
	workBuffer[GWGETUsed] = 0;

	/* aetStartPut: */
	workBuffer[GWAETStart] = 0;

	/* aetUsedPut: */
	workBuffer[GWAETUsed] = 0;

	/* stopReasonPut: */
	workBuffer[GWStopReason] = 0;

	/* needsFlushPut: */
	workBuffer[GWNeedsFlush] = 0;

	/* clipMinXPut: */
	workBuffer[GWClipMinX] = 0;

	/* clipMaxXPut: */
	workBuffer[GWClipMaxX] = 0;

	/* clipMinYPut: */
	workBuffer[GWClipMinY] = 0;

	/* clipMaxYPut: */
	workBuffer[GWClipMaxY] = 0;

	/* currentZPut: */
	workBuffer[GWCurrentZ] = 0;
	resetGraphicsEngineStats();
	initEdgeTransform();
	initColorTransform();
	popthenPush(2, wbOop);
	return 0;
}


/*	Note: No need to load bitBlt but must load spanBuffer */

	/* BalloonEngineBase>>#primitiveInitializeProcessing */
EXPORT(sqInt)
primitiveInitializeProcessing(void)
{
    sqInt failureCode;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(0), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	if ((failureCode = loadSpanBufferFrom(fetchPointerofObject(BESpanIndex, engine)))) {
		return primitiveFailFor(failureCode);
	}
	initializeGETProcessing();
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}

	/* statePut: */
	workBuffer[GWState] = GEStateAddingFromGET;
	if (!(failed())) {
		/* begin storeEngineStateInto: */
		/* objUsedPut: */
		workBuffer[GWObjUsed] = objUsed;
	}
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountInitializing] = ((workBuffer[GWCountInitializing]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeInitializing] = ((workBuffer[GWTimeInitializing]) + value);
	}
	return 0;
}


/*	Note: No need to load bitBlt but must load spanBuffer */

	/* BalloonEngineBase>>#primitiveMergeFillFrom */
EXPORT(sqInt)
primitiveMergeFillFrom(void)
{
    sqInt bitsOop;
    sqInt failureCode;
    sqInt fillOop;
    sqInt value;
    sqInt valueSqInt;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(2), GEStateWaitingForFill))) {
		return primitiveFailFor(failureCode);
	}
	if ((failureCode = loadSpanBufferFrom(fetchPointerofObject(BESpanIndex, engine)))) {
		return primitiveFailFor(failureCode);
	}
	fillOop = stackObjectValue(0);

	/* Check bitmap */
	bitsOop = stackObjectValue(1);
	if (!((!(failed()))
		 && ((fetchClassOf(bitsOop)) == (classBitmap())))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if ((slotSizeOf(fillOop)) < FTBalloonFillDataSize) {
		return primitiveFailFor(GEFFillDataTooSmall);
	}
	value = fetchIntegerofObject(FTIndexIndex, fillOop);
	if (!((objBuffer[(workBuffer[GWLastExportedFill]) + GEObjectIndex]) == value)) {
		return primitiveFailFor(GEFWrongFill);
	}
	value = fetchIntegerofObject(FTMinXIndex, fillOop);
	if (!((workBuffer[GWLastExportedLeftX]) == value)) {
		return primitiveFailFor(GEFWrongFill);
	}
	value = fetchIntegerofObject(FTMaxXIndex, fillOop);
	if (!((workBuffer[GWLastExportedRightX]) == value)) {
		return primitiveFailFor(GEFWrongFill);
	}
	if ((slotSizeOf(bitsOop)) < ((workBuffer[GWLastExportedRightX]) - (workBuffer[GWLastExportedLeftX]))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (failed()) {
		return null;
	}
	fillBitmapSpanfromto(firstIndexableField(bitsOop), workBuffer[GWLastExportedLeftX], workBuffer[GWLastExportedRightX]);

	/* statePut: */
	workBuffer[GWState] = GEStateScanningAET;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(2);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountMergeFill] = ((workBuffer[GWCountMergeFill]) + 1);
		valueSqInt = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeMergeFill] = ((workBuffer[GWTimeMergeFill]) + valueSqInt);
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveNeedsFlush */
EXPORT(sqInt)
primitiveNeedsFlush(void)
{
    sqInt failureCode;
    int needFlush;

	if (methodArgumentCount()) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(0)))) {
		return primitiveFailFor(failureCode);
	}
	needFlush = (workBuffer[GWNeedsFlush]) != 0;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	pushBool(needFlush);
	return 0;
}

	/* BalloonEngineBase>>#primitiveNeedsFlushPut */
EXPORT(sqInt)
primitiveNeedsFlushPut(void)
{
    sqInt failureCode;
    sqInt needFlush;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFrom(stackValue(1)))) {
		return primitiveFailFor(failureCode);
	}
	needFlush = booleanValueOf(stackValue(0));
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (needFlush == 1) {
		/* needsFlushPut: */
		workBuffer[GWNeedsFlush] = 1;
	}
	else {
		/* needsFlushPut: */
		workBuffer[GWNeedsFlush] = 0;
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}


/*	Note: No need to load either bitBlt or spanBuffer */

	/* BalloonEngineBase>>#primitiveNextActiveEdgeEntry */
EXPORT(sqInt)
primitiveNextActiveEdgeEntry(void)
{
    int edge;
    sqInt edgeOop;
    sqInt failureCode;
    sqInt hasEdge;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredStateor(stackValue(1), GEStateUpdateEdges, GEStateCompleted))) {
		return primitiveFailFor(failureCode);
	}
	edgeOop = stackObjectValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	hasEdge = 0;
	if (!((workBuffer[GWState]) == GEStateCompleted)) {
		hasEdge = findNextExternalUpdateFromAET();
		if (hasEdge) {
			edge = aetBuffer[workBuffer[GWAETStart]];
			storeEdgeStateFrominto(edge, edgeOop);

			/* statePut: */
			workBuffer[GWState] = GEStateWaitingChange;
		}
		else {
			/* statePut: */
			workBuffer[GWState] = GEStateAddingFromGET;
		}
	}
	if (failed()) {
		return null;
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(2);
	pushBool(!hasEdge);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountNextAETEntry] = ((workBuffer[GWCountNextAETEntry]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeNextAETEntry] = ((workBuffer[GWTimeNextAETEntry]) + value);
	}
	return 0;
}


/*	Note: No need to load bitBlt but must load spanBuffer */

	/* BalloonEngineBase>>#primitiveNextFillEntry */
EXPORT(sqInt)
primitiveNextFillEntry(void)
{
    sqInt failureCode;
    sqInt fillOop;
    sqInt hasFill;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateScanningAET))) {
		return primitiveFailFor(failureCode);
	}
	if ((failureCode = loadSpanBufferFrom(fetchPointerofObject(BESpanIndex, engine)))) {
		return primitiveFailFor(failureCode);
	}
	if (!(loadFormsFrom(fetchPointerofObject(BEFormsIndex, engine)))) {
		return primitiveFailFor(GEFFormLoadFailed);
	}
	if (workBuffer[GWClearSpanBuffer]) {
		if (!((workBuffer[GWCurrentY]) & (workBuffer[GWAAScanMask]))) {
			clearSpanBuffer();
		}

		/* clearSpanBufferPut: */
		workBuffer[GWClearSpanBuffer] = 0;
	}
	fillOop = stackObjectValue(0);
	hasFill = findNextExternalFillFromAET();
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (hasFill) {
		storeFillStateInto(fillOop);
	}
	if (failed()) {
		return primitiveFailFor(GEFWrongFill);
	}
	if (hasFill) {
		/* statePut: */
		workBuffer[GWState] = GEStateWaitingForFill;
	}
	else {
		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);

		/* spanEndAAPut: */
		workBuffer[GWSpanEndAA] = 0;

		/* statePut: */
		workBuffer[GWState] = GEStateBlitBuffer;
	}
	workBuffer[GWObjUsed] = objUsed;
	pop(2);
	pushBool(!hasFill);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountNextFillEntry] = ((workBuffer[GWCountNextFillEntry]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeNextFillEntry] = ((workBuffer[GWTimeNextFillEntry]) + value);
	}
	return 0;
}


/*	Note: No need to load either bitBlt or spanBuffer */

	/* BalloonEngineBase>>#primitiveNextGlobalEdgeEntry */
EXPORT(sqInt)
primitiveNextGlobalEdgeEntry(void)
{
    int edge;
    sqInt edgeOop;
    sqInt failureCode;
    sqInt hasEdge;
    sqInt value;

	if (doProfileStats) {
		geProfileTime = ioMicroMSecs();
	}
	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateAddingFromGET))) {
		return primitiveFailFor(failureCode);
	}
	edgeOop = stackObjectValue(0);
	hasEdge = findNextExternalEntryFromGET();
	if (hasEdge) {
		edge = getBuffer[workBuffer[GWGETStart]];
		storeEdgeStateFrominto(edge, edgeOop);

		/* getStartPut: */
		workBuffer[GWGETStart] = ((workBuffer[GWGETStart]) + 1);
	}
	if (failed()) {
		return primitiveFailFor(GEFWrongEdge);
	}
	if (hasEdge) {
		/* statePut: */
		workBuffer[GWState] = GEStateWaitingForEdge;
	}
	else {

		/* Start scanning the AET */
		/* statePut: */
		workBuffer[GWState] = GEStateScanningAET;

		/* clearSpanBufferPut: */
		workBuffer[GWClearSpanBuffer] = 1;

		/* aetStartPut: */
		workBuffer[GWAETStart] = 0;

		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);
	}
	workBuffer[GWObjUsed] = objUsed;
	pop(2);
	pushBool(!hasEdge);
	if (doProfileStats) {
		/* incrementStat:by: */
		workBuffer[GWCountNextGETEntry] = ((workBuffer[GWCountNextGETEntry]) + 1);
		value = (ioMicroMSecs()) - geProfileTime;

		/* begin incrementStat:by: */
		workBuffer[GWTimeNextGETEntry] = ((workBuffer[GWTimeNextGETEntry]) + value);
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveRegisterExternalEdge */
EXPORT(sqInt)
primitiveRegisterExternalEdge(void)
{
    sqInt edge;
    sqInt failureCode;
    sqInt index;
    sqInt initialX;
    sqInt initialY;
    sqInt initialZ;
    usqInt leftFillIndex;
    usqInt rightFillIndex;
    sqInt value;

	if (!((methodArgumentCount()) == 6)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(6), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	rightFillIndex = positive32BitValueOf(stackValue(0));
	leftFillIndex = positive32BitValueOf(stackValue(1));
	initialZ = stackIntegerValue(2);
	initialY = stackIntegerValue(3);
	initialX = stackIntegerValue(4);
	index = stackIntegerValue(5);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	if (!(allocateObjEntry(GEBaseEdgeSize))) {
		return primitiveFailFor(GEFWorkTooBig);
	}
	if (!((isFillOkay(leftFillIndex))
		 && (isFillOkay(rightFillIndex)))) {
		return primitiveFailFor(GEFWrongFill);
	}
	edge = objUsed;

	/* Install type and length */
	objUsed = edge + GEBaseEdgeSize;

	/* #objectTypeOf:put: #obj:at:put: */
	objBuffer[edge + GEObjectType] = GEPrimitiveEdge;

	/* #objectLengthOf:put: #obj:at:put: */
	objBuffer[edge + GEObjectLength] = GEBaseEdgeSize;

	/* #objectIndexOf:put: #obj:at:put: */
	objBuffer[edge + GEObjectIndex] = index;

	/* #edgeXValueOf:put: #obj:at:put: */
	objBuffer[edge + GEXValue] = initialX;

	/* #edgeYValueOf:put: #obj:at:put: */
	objBuffer[edge + GEYValue] = initialY;

	/* #edgeZValueOf:put: #obj:at:put: */
	objBuffer[edge + GEZValue] = initialZ;
	value = transformColor(leftFillIndex);

	/* begin edgeLeftFillOf:put: */
	/* obj:at:put: */
	objBuffer[edge + GEFillIndexLeft] = value;
	value = transformColor(rightFillIndex);

	/* begin edgeRightFillOf:put: */
	/* obj:at:put: */
	objBuffer[edge + GEFillIndexRight] = value;
	if (engineStopped) {
		return primitiveFailFor(GEFEngineStopped);
	}
	if (!(failed())) {
		/* begin storeEngineStateInto: */
		/* objUsedPut: */
		workBuffer[GWObjUsed] = objUsed;
		pop(6);
	}
	return 0;
}

	/* BalloonEngineBase>>#primitiveRegisterExternalFill */
EXPORT(sqInt)
primitiveRegisterExternalFill(void)
{
    sqInt failureCode;
    sqInt fill;
    sqInt index;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	index = stackIntegerValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fill = 0;
	while (fill == 0) {
		if (!(allocateObjEntry(GEBaseEdgeSize))) {
			return primitiveFailFor(GEFWorkTooBig);
		}
		fill = objUsed;

		/* Install type and length */
		objUsed = fill + GEBaseFillSize;

		/* #objectTypeOf:put: #obj:at:put: */
		objBuffer[fill + GEObjectType] = GEPrimitiveFill;

		/* #objectLengthOf:put: #obj:at:put: */
		objBuffer[fill + GEObjectLength] = GEBaseFillSize;

		/* #objectIndexOf:put: #obj:at:put: */
		objBuffer[fill + GEObjectIndex] = index;
	}
	if (!(failed())) {
		/* begin storeEngineStateInto: */
		/* objUsedPut: */
		workBuffer[GWObjUsed] = objUsed;
		pop(2);
		pushInteger(fill);
	}
	return 0;
}


/*	Start/Proceed rendering the entire image */

	/* BalloonEngineBase>>#primitiveRenderImage */
EXPORT(sqInt)
primitiveRenderImage(void)
{
    sqInt failCode;

	if ((failCode = loadRenderingState())) {
		return primitiveFailFor(failCode);
	}
	proceedRenderingScanline();
	if (engineStopped) {
		return storeRenderingState();
	}
	proceedRenderingImage();
	storeRenderingState();
	return 0;
}


/*	Start rendering the entire image */

	/* BalloonEngineBase>>#primitiveRenderScanline */
EXPORT(sqInt)
primitiveRenderScanline(void)
{
    sqInt failCode;

	if ((failCode = loadRenderingState())) {
		return primitiveFailFor(failCode);
	}
	proceedRenderingScanline();
	storeRenderingState();
	return 0;
}

	/* BalloonEngineBase>>#primitiveSetAALevel */
EXPORT(sqInt)
primitiveSetAALevel(void)
{
    sqInt failureCode;
    sqInt level;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	level = stackIntegerValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	setAALevel(level);

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}


/*	Primitive. Set the BitBlt plugin to use. */

	/* BalloonEngineBase>>#primitiveSetBitBltPlugin */
EXPORT(sqInt)
primitiveSetBitBltPlugin(void)
{
    sqInt i;
    sqInt length;
    sqInt needReload;
    sqInt pluginName;
    char *ptr;

	/* Must be string to work */
	pluginName = stackValue(0);
	if (!(isBytes(pluginName))) {
		return primitiveFail();
	}
	length = byteSizeOf(pluginName);
	if (length >= 0x100) {
		return primitiveFail();
	}
	ptr = firstIndexableField(pluginName);
	needReload = 0;
	for (i = 0; i < length; i += 1) {

		/* Compare and store the plugin to be used */
		if (!((bbPluginName[i]) == (ptr[i]))) {
			bbPluginName[i] = (ptr[i]);
			needReload = 1;
		}
	}
	if (bbPluginName[length]) {
		bbPluginName[length] = 0;
		needReload = 1;
	}
	if (needReload) {
		if (!(initialiseModule())) {
			return primitiveFail();
		}
	}
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveSetClipRect */
EXPORT(sqInt)
primitiveSetClipRect(void)
{
    sqInt failureCode;
    sqInt rectOop;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	rectOop = stackObjectValue(0);
	if (!((!(failed()))
		 && ((isPointers(rectOop))
		 && ((slotSizeOf(rectOop)) >= 2)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), fetchPointerofObject(0, rectOop));
	loadPointfrom(((int *) (workBuffer + GWPoint2)), fetchPointerofObject(1, rectOop));
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* clipMinXPut: */
	workBuffer[GWClipMinX] = ((*((int *) (workBuffer + GWPoint1))));

	/* clipMinYPut: */
	workBuffer[GWClipMinY] = ((((int *) (workBuffer + GWPoint1)))[1]);

	/* clipMaxXPut: */
	workBuffer[GWClipMaxX] = ((*((int *) (workBuffer + GWPoint2))));

	/* clipMaxYPut: */
	workBuffer[GWClipMaxY] = ((((int *) (workBuffer + GWPoint2)))[1]);

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveSetColorTransform */
EXPORT(sqInt)
primitiveSetColorTransform(void)
{
    sqInt failureCode;
    sqInt okay;
    float *transform;
    sqInt transformOop;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	transformOop = stackObjectValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* begin loadColorTransformFrom: */
	/* begin colorTransform */
	transform = ((float *) (workBuffer + GWColorTransform));

	/* hasColorTransformPut: */
	workBuffer[GWHasColorTransform] = 0;
	okay = loadTransformFromintolength(transformOop, transform, 8);
	if (!okay) {
		goto l1;
	}

	/* hasColorTransformPut: */
	workBuffer[GWHasColorTransform] = 1;
	transform[1] = ((transform[1]) * (256.0f));
	transform[3] = ((transform[3]) * (256.0f));
	transform[5] = ((transform[5]) * (256.0f));
	transform[7] = ((transform[7]) * (256.0f));
l1:	/* end loadColorTransformFrom: */;
	if (failed()) {
		return primitiveFailFor(GEFEntityLoadFailed);
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveSetDepth */
EXPORT(sqInt)
primitiveSetDepth(void)
{
    sqInt depth;
    sqInt failureCode;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	depth = stackIntegerValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* currentZPut: */
	workBuffer[GWCurrentZ] = depth;

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveSetEdgeTransform */
EXPORT(sqInt)
primitiveSetEdgeTransform(void)
{
    sqInt failureCode;
    sqInt transformOop;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	transformOop = stackObjectValue(0);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	loadEdgeTransformFrom(transformOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}

	/* BalloonEngineBase>>#primitiveSetOffset */
EXPORT(sqInt)
primitiveSetOffset(void)
{
    sqInt failureCode;
    sqInt pointOop;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	if ((failureCode = quickLoadEngineFromrequiredState(stackValue(1), GEStateUnlocked))) {
		return primitiveFailFor(failureCode);
	}
	pointOop = stackValue(0);
	if (!((fetchClassOf(pointOop)) == (classPoint()))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	loadPointfrom(((int *) (workBuffer + GWPoint1)), pointOop);
	if (failed()) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* destOffsetXPut: */
	workBuffer[GWDestOffsetX] = ((*((int *) (workBuffer + GWPoint1))));

	/* destOffsetYPut: */
	workBuffer[GWDestOffsetY] = ((((int *) (workBuffer + GWPoint1)))[1]);

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(1);
	return 0;
}


/*	This is the main rendering entry */

	/* BalloonEngineBase>>#proceedRenderingImage */
static sqInt
proceedRenderingImage(void)
{
    sqInt external;
    sqInt value;
    sqInt value1;
    sqInt valueSqInt;

	while (!((workBuffer[GWState]) == GEStateCompleted)) {
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		external = findNextExternalEntryFromGET();
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountNextGETEntry] = ((workBuffer[GWCountNextGETEntry]) + 1);
			value = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeNextGETEntry] = ((workBuffer[GWTimeNextGETEntry]) + value);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateAddingFromGET;
		}
		if (external) {
			/* statePut: */
			workBuffer[GWState] = GEStateWaitingForEdge;

			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorGETEntry;
			engineStopped = 1;
			return null;
		}

		/* aetStartPut: */
		workBuffer[GWAETStart] = 0;

		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);

		/* clearSpanBufferPut: */
		workBuffer[GWClearSpanBuffer] = 1;
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		if (((workBuffer[GWClearSpanBuffer]) != 0)
		 && (((workBuffer[GWCurrentY]) & (workBuffer[GWAAScanMask])) == 0)) {
			clearSpanBuffer();
		}

		/* clearSpanBufferPut: */
		workBuffer[GWClearSpanBuffer] = 0;
		external = findNextExternalFillFromAET();
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountNextFillEntry] = ((workBuffer[GWCountNextFillEntry]) + 1);
			valueSqInt = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeNextFillEntry] = ((workBuffer[GWTimeNextFillEntry]) + valueSqInt);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateScanningAET;
		}
		if (external) {
			/* statePut: */
			workBuffer[GWState] = GEStateWaitingForFill;

			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorFillEntry;
			engineStopped = 1;
			return null;
		}

		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);

		/* spanEndAAPut: */
		workBuffer[GWSpanEndAA] = 0;
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		if (((workBuffer[GWCurrentY]) & (workBuffer[GWAAScanMask])) == (workBuffer[GWAAScanMask])) {
			displaySpanBufferAt(workBuffer[GWCurrentY]);
			postDisplayAction();
		}
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountDisplaySpan] = ((workBuffer[GWCountDisplaySpan]) + 1);
			value1 = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeDisplaySpan] = ((workBuffer[GWTimeDisplaySpan]) + value1);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateBlitBuffer;
		}
		if ((workBuffer[GWState]) == GEStateCompleted) {
			return 0;
		}

		/* aetStartPut: */
		workBuffer[GWAETStart] = 0;

		/* currentYPut: */
		workBuffer[GWCurrentY] = ((workBuffer[GWCurrentY]) + 1);
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		external = findNextExternalUpdateFromAET();
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountNextAETEntry] = ((workBuffer[GWCountNextAETEntry]) + 1);
			value1 = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeNextAETEntry] = ((workBuffer[GWTimeNextAETEntry]) + value1);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateUpdateEdges;
		}
		if (external) {
			/* statePut: */
			workBuffer[GWState] = GEStateWaitingChange;

			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorAETEntry;
			engineStopped = 1;
			return null;
		}
	}
	return 0;
}


/*	Proceed rendering the current scan line.
	This method may be called after some Smalltalk code has been executed
	inbetween. 
 */
/*	This is the main rendering entry */

	/* BalloonEngineBase>>#proceedRenderingScanline */
static sqInt
proceedRenderingScanline(void)
{
    sqInt external;
    int state;
    sqInt value;

	state = workBuffer[GWState];
	if (!state) {
		initializeGETProcessing();
		if (engineStopped) {
			return 0;
		}
		state = GEStateAddingFromGET;
	}
	if (state == GEStateAddingFromGET) {
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		external = findNextExternalEntryFromGET();
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountNextGETEntry] = ((workBuffer[GWCountNextGETEntry]) + 1);
			value = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeNextGETEntry] = ((workBuffer[GWTimeNextGETEntry]) + value);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateAddingFromGET;
		}
		if (external) {
			/* statePut: */
			workBuffer[GWState] = GEStateWaitingForEdge;

			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorGETEntry;
			engineStopped = 1;
			return null;
		}

		/* aetStartPut: */
		workBuffer[GWAETStart] = 0;

		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);

		/* clearSpanBufferPut: */
		workBuffer[GWClearSpanBuffer] = 1;
		state = GEStateScanningAET;
	}
	if (state == GEStateScanningAET) {
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		if (((workBuffer[GWClearSpanBuffer]) != 0)
		 && (((workBuffer[GWCurrentY]) & (workBuffer[GWAAScanMask])) == 0)) {
			clearSpanBuffer();
		}

		/* clearSpanBufferPut: */
		workBuffer[GWClearSpanBuffer] = 0;
		external = findNextExternalFillFromAET();
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountNextFillEntry] = ((workBuffer[GWCountNextFillEntry]) + 1);
			value = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeNextFillEntry] = ((workBuffer[GWTimeNextFillEntry]) + value);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateScanningAET;
		}
		if (external) {
			/* statePut: */
			workBuffer[GWState] = GEStateWaitingForFill;

			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorFillEntry;
			engineStopped = 1;
			return null;
		}
		state = GEStateBlitBuffer;

		/* begin wbStackClear */
		/* wbTopPut: */
		workBuffer[GWBufferTop] = (workBuffer[GWSize]);

		/* spanEndAAPut: */
		workBuffer[GWSpanEndAA] = 0;
	}
	if (state == GEStateBlitBuffer) {
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		if (((workBuffer[GWCurrentY]) & (workBuffer[GWAAScanMask])) == (workBuffer[GWAAScanMask])) {
			displaySpanBufferAt(workBuffer[GWCurrentY]);
			postDisplayAction();
		}
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountDisplaySpan] = ((workBuffer[GWCountDisplaySpan]) + 1);
			value = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeDisplaySpan] = ((workBuffer[GWTimeDisplaySpan]) + value);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateBlitBuffer;
		}
		if ((workBuffer[GWState]) == GEStateCompleted) {
			return 0;
		}
		state = GEStateUpdateEdges;

		/* aetStartPut: */
		workBuffer[GWAETStart] = 0;

		/* currentYPut: */
		workBuffer[GWCurrentY] = ((workBuffer[GWCurrentY]) + 1);
	}
	if (state == GEStateUpdateEdges) {
		if (doProfileStats) {
			geProfileTime = ioMicroMSecs();
		}
		external = findNextExternalUpdateFromAET();
		if (doProfileStats) {
			/* incrementStat:by: */
			workBuffer[GWCountNextAETEntry] = ((workBuffer[GWCountNextAETEntry]) + 1);
			value = (ioMicroMSecs()) - geProfileTime;

			/* begin incrementStat:by: */
			workBuffer[GWTimeNextAETEntry] = ((workBuffer[GWTimeNextAETEntry]) + value);
		}
		if (engineStopped) {
			return workBuffer[GWState] = GEStateUpdateEdges;
		}
		if (external) {
			/* statePut: */
			workBuffer[GWState] = GEStateWaitingChange;

			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorAETEntry;
			engineStopped = 1;
			return null;
		}

		/* statePut: */
		workBuffer[GWState] = GEStateAddingFromGET;
	}
	return 0;
}


/*	Load the minimal required state from the engineOop, e.g., just the work
	buffer. Answer 0 on success or non-zero a failure code on failure */

	/* BalloonEngineBase>>#quickLoadEngineFrom: */
static sqInt
quickLoadEngineFrom(sqInt engineOop)
{
    sqInt failCode;

	if (failed()) {
		return GEFAlreadyFailed;
	}
	if (isImmediate(engineOop)) {
		return GEFEngineIsInteger;
	}
	if (!(isPointers(engineOop))) {
		return GEFEngineIsWords;
	}
	if ((slotSizeOf(engineOop)) < BEBalloonEngineSize) {
		return GEFEngineTooSmall;
	}
	engine = engineOop;
	if ((failCode = loadWorkBufferFrom(fetchPointerofObject(BEWorkBufferIndex, engineOop)))) {
		return failCode;
	}

	/* stopReasonPut: */
	workBuffer[GWStopReason] = 0;
	objUsed = workBuffer[GWObjUsed];
	engineStopped = 0;
	return 0;
}

	/* BalloonEngineBase>>#quickLoadEngineFrom:requiredState: */
static sqInt
quickLoadEngineFromrequiredState(sqInt oop, sqInt requiredState)
{
    sqInt failureCode;

	if ((failureCode = quickLoadEngineFrom(oop))) {
		return failureCode;
	}
	if ((workBuffer[GWState]) == requiredState) {
		return 0;
	}

	/* stopReasonPut: */
	workBuffer[GWStopReason] = GErrorBadState;
	return GEFWrongState;
}

	/* BalloonEngineBase>>#quickLoadEngineFrom:requiredState:or: */
static sqInt
quickLoadEngineFromrequiredStateor(sqInt oop, sqInt requiredState, sqInt alternativeState)
{
    sqInt failureCode;

	if ((failureCode = quickLoadEngineFrom(oop))) {
		return failureCode;
	}
	if ((workBuffer[GWState]) == requiredState) {
		return 0;
	}
	if ((workBuffer[GWState]) == alternativeState) {
		return 0;
	}

	/* stopReasonPut: */
	workBuffer[GWStopReason] = GErrorBadState;
	return GEFWrongState;
}


/*	Sort elements i through j of self to be nondescending according to
	sortBlock. */
/*	Note: The original loop has been heavily re-written for C translation */

	/* BalloonEngineBase>>#quickSortGlobalEdgeTable:from:to: */
static sqInt
quickSortGlobalEdgeTablefromto(int *array, sqInt i, sqInt j)
{
    sqInt again;
    sqInt before;
    int di;
    int dij;
    int dj;
    sqInt ij;
    sqInt k;
    sqInt l;
    sqInt n;
    int tmp;
    int tt;


	/* The prefix d means the data at that index. */
	if (((n = (j + 1) - i)) <= 1) {
		return 0;
	}
	di = array[i];
	dj = array[j];

	/* i.e., should di precede dj? */
	before = getSortsbefore(di, dj);
	if (!before) {
		tmp = array[i];
		array[i] = (array[j]);
		array[j] = tmp;
		tt = di;
		di = dj;
		dj = tt;
	}
	if (n <= 2) {
		return 0;
	}

	/* ij is the midpoint of i and j. */
	ij = (i + j) / 2;

	/* Sort di,dij,dj.  Make dij be their median. */
	dij = array[ij];

	/* i.e. should di precede dij? */
	before = getSortsbefore(di, dij);
	if (before) {
		/* i.e., should dij precede dj? */
		before = getSortsbefore(dij, dj);
		if (!before) {

			/* i.e., should dij precede dj? */
			tmp = array[j];
			array[j] = (array[ij]);
			array[ij] = tmp;
			dij = dj;
		}
	}
	else {

		/* i.e. di should come after dij */
		tmp = array[i];
		array[i] = (array[ij]);
		array[ij] = tmp;
		dij = di;
	}
	if (n <= 3) {
		return 0;
	}
	k = i;
	l = j;
	again = 1;
	while (again) {
		before = 1;
		while (before) {
			if (k <= ((l -= 1))) {
				tmp = array[l];
				before = getSortsbefore(dij, tmp);
			}
			else {
				before = 0;
			}
		}
		before = 1;
		while (before) {
			if (((k += 1)) <= l) {
				tmp = array[k];
				before = getSortsbefore(tmp, dij);
			}
			else {
				before = 0;
			}
		}
		again = k <= l;
		if (again) {
			tmp = array[k];
			array[k] = (array[l]);
			array[l] = tmp;
		}
	}
	quickSortGlobalEdgeTablefromto(array, i, l);
	quickSortGlobalEdgeTablefromto(array, k, j);
	return 0;
}

	/* BalloonEngineBase>>#removeFirstAETEntry */
static sqInt
removeFirstAETEntry(void)
{
    int index;

	index = workBuffer[GWAETStart];

	/* aetUsedPut: */
	workBuffer[GWAETUsed] = ((workBuffer[GWAETUsed]) - 1);
	while (index < (workBuffer[GWAETUsed])) {
		aetBuffer[index] = (aetBuffer[index + 1]);
		index += 1;
	}
	return 0;
}

	/* BalloonEngineBase>>#resetGraphicsEngineStats */
static sqInt
resetGraphicsEngineStats(void)
{
	workBuffer[GWTimeInitializing] = 0;
	workBuffer[GWTimeFinishTest] = 0;
	workBuffer[GWTimeNextGETEntry] = 0;
	workBuffer[GWTimeAddAETEntry] = 0;
	workBuffer[GWTimeNextFillEntry] = 0;
	workBuffer[GWTimeMergeFill] = 0;
	workBuffer[GWTimeDisplaySpan] = 0;
	workBuffer[GWTimeNextAETEntry] = 0;
	workBuffer[GWTimeChangeAETEntry] = 0;
	workBuffer[GWCountInitializing] = 0;
	workBuffer[GWCountFinishTest] = 0;
	workBuffer[GWCountNextGETEntry] = 0;
	workBuffer[GWCountAddAETEntry] = 0;
	workBuffer[GWCountNextFillEntry] = 0;
	workBuffer[GWCountMergeFill] = 0;
	workBuffer[GWCountDisplaySpan] = 0;
	workBuffer[GWCountNextAETEntry] = 0;
	workBuffer[GWCountChangeAETEntry] = 0;
	workBuffer[GWBezierMonotonSubdivisions] = 0;
	workBuffer[GWBezierHeightSubdivisions] = 0;
	workBuffer[GWBezierOverflowSubdivisions] = 0;
	workBuffer[GWBezierLineConversions] = 0;
	return 0;
}

	/* BalloonEngineBase>>#resortFirstAETEntry */
static sqInt
resortFirstAETEntry(void)
{
    int edge;
    int leftEdge;
    int xValue;

	if (!(workBuffer[GWAETStart])) {
		return null;
	}
	edge = aetBuffer[workBuffer[GWAETStart]];
	xValue = objBuffer[edge + GEXValue];
	leftEdge = aetBuffer[(workBuffer[GWAETStart]) - 1];
	if ((objBuffer[leftEdge + GEXValue]) <= xValue) {
		return null;
	}
	moveAETEntryFromedgex(workBuffer[GWAETStart], edge, xValue);
	return 0;
}

	/* BalloonEnginePlugin>>#rShiftTable */
static int *
rShiftTable(void)
{
    static int theTable[17] =
		{0, 5, 4, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1};

	return theTable;
}


/*	Set the anti-aliasing level. Three levels are supported:
	1 - No antialiasing
	2 - 2x2 unweighted anti-aliasing
	4 - 4x4 unweighted anti-aliasing.
	 */

	/* BalloonEngineBase>>#setAALevel: */
static sqInt
setAALevel(sqInt level)
{
    sqInt aaLevel;

	aaLevel = 0;
	if (level >= 4) {
		aaLevel = 4;
	}
	if ((level >= 2) && (level < 4)) {
		aaLevel = 2;
	}
	if (level < 2) {
		aaLevel = 1;
	}

	/* aaLevelPut: */
	workBuffer[GWAALevel] = aaLevel;
	if (aaLevel == 1) {
		/* aaShiftPut: */
		workBuffer[GWAAShift] = 0;

		/* aaColorMaskPut: */
		workBuffer[GWAAColorMask] = 0xFFFFFFFFU;

		/* aaScanMaskPut: */
		workBuffer[GWAAScanMask] = 0;
	}
	if (aaLevel == 2) {
		/* aaShiftPut: */
		workBuffer[GWAAShift] = 1;

		/* aaColorMaskPut: */
		workBuffer[GWAAColorMask] = 0xFCFCFCFCU;

		/* aaScanMaskPut: */
		workBuffer[GWAAScanMask] = 1;
	}
	if (aaLevel == 4) {
		/* aaShiftPut: */
		workBuffer[GWAAShift] = 2;

		/* aaColorMaskPut: */
		workBuffer[GWAAColorMask] = 0xF0F0F0F0U;

		/* aaScanMaskPut: */
		workBuffer[GWAAScanMask] = 3;
	}

	/* aaColorShiftPut: */
	workBuffer[GWAAColorShift] = ((workBuffer[GWAAShift]) * 2);

	/* aaHalfPixelPut: */
	workBuffer[GWAAHalfPixel] = (workBuffer[GWAAShift]);
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
		 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		classBitmap = interpreterProxy->classBitmap;
		classPoint = interpreterProxy->classPoint;
		failed = interpreterProxy->failed;
		fetchClassOf = interpreterProxy->fetchClassOf;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		ioMicroMSecs = interpreterProxy->ioMicroMSecs;
		isArray = interpreterProxy->isArray;
		isBytes = interpreterProxy->isBytes;
		isFloatObject = interpreterProxy->isFloatObject;
#if !defined(isImmediate)
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isImmediate = interpreterProxy->isImmediate;
#else
#if !defined(isImmediate)
		isImmediate = 0;
#endif
#endif
#endif /* !defined(isImmediate) */
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
		isPointers = interpreterProxy->isPointers;
		isWords = interpreterProxy->isWords;
		makePointwithxValueyValue = interpreterProxy->makePointwithxValueyValue;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		pushBool = interpreterProxy->pushBool;
		pushInteger = interpreterProxy->pushInteger;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		topRemappableOop = interpreterProxy->topRemappableOop;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* BalloonEngineBase>>#showFill:depth:rightX: */
static sqInt
showFilldepthrightX(sqInt fillIndex, sqInt depth, sqInt rightX)
{
    sqInt value;

	/* begin allocateStackFillEntry */
	/* begin wbStackPush: */
	/* begin allocateStackEntry: */
	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 3 /* stackFillEntryLength */) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return null;
	}

	/* wbTopPut: */
	workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) - 3 /* stackFillEntryLength */);

	/* #stackFillValue:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop])] = fillIndex;

	/* #stackFillDepth:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + 1] = depth;

	/* #stackFillRightX:put: #wbStackValue:put: */
	workBuffer[(workBuffer[GWBufferTop]) + 2] = rightX;
	if (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) == 3 /* stackFillEntryLength */) {
		return null;
	}
	if (fillSortsbefore(0, ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)) {

		/* New top fill */
		value = workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];

		/* begin stackFillValue:put: */
		/* wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop])] = value;
		value = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 1)];

		/* begin stackFillDepth:put: */
		/* wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + 1] = value;
		value = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];

		/* begin stackFillRightX:put: */
		/* wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + 2] = value;

		/* #topFillValuePut: #stackFillValue:put: #wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)] = fillIndex;

		/* #topFillDepthPut: #stackFillDepth:put: #wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 1)] = depth;

		/* #topFillRightXPut: #stackFillRightX:put: #wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)] = rightX;
	}
	return 0;
}

	/* BalloonEngineBase>>#smallSqrtTable */
static int *
smallSqrtTable(void)
{
    static int theTable[32] = 
	{0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6};

	return theTable;
}


/*	Initialize the bezier at yValue.
	TODO: Check if reducing maxSteps from 2*deltaY to deltaY 
	brings a *significant* performance improvement.
	In theory this should make for double step performance
	but will cost in quality. Might be that the AA stuff will
	compensate for this - but I'm not really sure. */

	/* BalloonEnginePlugin>>#stepToFirstBezierIn:at: */
static sqInt
stepToFirstBezierInat(sqInt bezier, sqInt yValue)
{
    int deltaY;
    int endX;
    int endY;
    sqInt fwDDx;
    sqInt fwDDy;
    sqInt fwDx;
    int fwDxInt;
    sqInt fwDy;
    int fwDyInt;
    int fwX1;
    int fwX2;
    int fwY1;
    int fwY2;
    int lastX;
    int lastY;
    int maxSteps;
    sqInt minY;
    int scaledStepSize;
    sqInt squaredStepSize;
    int startX;
    int startY;
    int *updateData;
    int *updateData1;
    int viaX;
    int viaY;
    unsigned int word1;
    unsigned int word2;
    sqInt xValue;


	/* Do a quick check if there is anything at all to do */
	if ((!((((objBuffer[bezier + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWide) != 0))
	 && (yValue >= (objBuffer[bezier + GBEndY]))) {
		return objBuffer[bezier + GENumLines] = 0;
	}
	startX = objBuffer[bezier + GEXValue];
	startY = objBuffer[bezier + GEYValue];
	viaX = objBuffer[bezier + GBViaX];
	viaY = objBuffer[bezier + GBViaY];
	endX = objBuffer[bezier + GBEndX];
	endY = objBuffer[bezier + GBEndY];

	/* Initialize integer forward differencing */
	deltaY = endY - startY;
	fwX1 = (viaX - startX) * 2;
	fwX2 = (startX + endX) - (viaX * 2);
	fwY1 = (viaY - startY) * 2;
	fwY2 = (startY + endY) - (viaY * 2);
	maxSteps = deltaY * 2;
	if (maxSteps < 2) {
		maxSteps = 2;
	}
	scaledStepSize = 0x1000000 / maxSteps;

	/* begin absoluteSquared8Dot24: */
	word1 = scaledStepSize & 0xFFFF;
	word2 = ((((usqInt)(scaledStepSize)) >> 16)) & 0xFF;
	squaredStepSize = (((usqInt)(((((((usqInt)((word1 * word1))) >> 16)) + ((word1 * word2) * 2)) + (((((usqInt)((word2 * word2)) << 16))))))) >> 8);
	fwDx = fwX1 * scaledStepSize;
	fwDDx = (fwX2 * squaredStepSize) * 2;
	fwDx += fwDDx / 2;
	fwDy = fwY1 * scaledStepSize;
	fwDDy = (fwY2 * squaredStepSize) * 2;

	/* Store the values */
	fwDy += fwDDy / 2;

	/* #edgeNumLinesOf:put: #obj:at:put: */
	objBuffer[bezier + GENumLines] = deltaY;
	updateData = (objBuffer + bezier) + GBUpdateData;
	updateData[GBUpdateX] = (startX * 0x100);
	updateData[GBUpdateY] = (startY * 0x100);
	updateData[GBUpdateDX] = fwDx;
	updateData[GBUpdateDY] = fwDy;
	updateData[GBUpdateDDX] = fwDDx;
	updateData[GBUpdateDDY] = fwDDy;
	if (!(((startY = objBuffer[bezier + GEYValue])) == yValue)) {
		/* begin stepToNextBezierIn:at: */
		updateData1 = (objBuffer + bezier) + GBUpdateData;
		lastX = updateData1[GBUpdateX];
		lastY = updateData1[GBUpdateY];
		fwDxInt = updateData1[GBUpdateDX];
		fwDyInt = updateData1[GBUpdateDY];

		/* Step as long as we haven't yet reached minY and also
		   as long as fwDy is greater than zero thus stepping down.
		   Note: The test for fwDy should not be necessary in theory
		   but is a good insurance in practice. */
		minY = yValue * 0x100;
		while ((minY > lastY)
		 && (fwDyInt >= 0)) {
			lastX += (((sqInt)((fwDxInt + 0x8000))) >> 16);
			lastY += (((sqInt)((fwDyInt + 0x8000))) >> 16);
			fwDxInt += updateData1[GBUpdateDDX];
			fwDyInt += updateData1[GBUpdateDDY];
		}
		updateData1[GBUpdateX] = lastX;
		updateData1[GBUpdateY] = lastY;
		updateData1[GBUpdateDX] = fwDxInt;
		updateData1[GBUpdateDY] = fwDyInt;
		xValue = (((sqInt)(lastX)) >> 8);

		/* #edgeXValueOf:put: #obj:at:put: */
		objBuffer[bezier + GEXValue] = xValue;

		/* #edgeNumLinesOf:put: #obj:at:put: */
		objBuffer[bezier + GENumLines] = (deltaY - (yValue - startY));
	}
	return 0;
}


/*	Initialize the line at yValue */

	/* BalloonEnginePlugin>>#stepToFirstLineIn:at: */
static sqInt
stepToFirstLineInat(sqInt line, sqInt yValue)
{
    int deltaX;
    int deltaY;
    int err;
    int error;
    int errorAdjUp;
    sqInt i;
    int startY;
    int widthX;
    int x;
    sqInt xDir;
    int xInc;


	/* Do a quick check if there is anything at all to do */
	if ((!((((objBuffer[line + GEObjectType]) & GEPrimitiveTypeMask) & GEPrimitiveWide) != 0))
	 && (yValue >= (objBuffer[line + GLEndY]))) {
		return objBuffer[line + GENumLines] = 0;
	}
	deltaX = (objBuffer[line + GLEndX]) - (objBuffer[line + GEXValue]);

	/* Check if edge goes left to right */
	deltaY = (objBuffer[line + GLEndY]) - (objBuffer[line + GEYValue]);
	if (deltaX >= 0) {
		xDir = 1;
		widthX = deltaX;
		error = 0;
	}
	else {
		xDir = -1;
		widthX = 0 - deltaX;
		error = 1 - deltaY;
	}
	if (deltaY) {

		/* Check if edge is y-major */
		if (deltaY > widthX) {

			/* Note: The '>' instead of '>=' could be important here... */
			xInc = 0;
			errorAdjUp = widthX;
		}
		else {
			xInc = (widthX / deltaY) * xDir;
			errorAdjUp = widthX % deltaY;
		}
	}
	else {
		/* No error for horizontal edges */
		error = 0;

		/* Encodes width and direction */
		xInc = deltaX;
		errorAdjUp = 0;
	}

	/* #edgeNumLinesOf:put: #obj:at:put: */
	objBuffer[line + GENumLines] = deltaY;

	/* #lineXDirectionOf:put: #obj:at:put: */
	objBuffer[line + GLXDirection] = xDir;

	/* #lineXIncrementOf:put: #obj:at:put: */
	objBuffer[line + GLXIncrement] = xInc;

	/* #lineErrorOf:put: #obj:at:put: */
	objBuffer[line + GLError] = error;

	/* #lineErrorAdjUpOf:put: #obj:at:put: */
	objBuffer[line + GLErrorAdjUp] = errorAdjUp;

	/* #lineErrorAdjDownOf:put: #obj:at:put: */
	objBuffer[line + GLErrorAdjDown] = deltaY;
	if (!(((startY = objBuffer[line + GEYValue])) == yValue)) {
		for (i = startY; i < yValue; i += 1) {
			/* begin stepToNextLineIn:at: */
			x = (objBuffer[line + GEXValue]) + (objBuffer[line + GLXIncrement]);
			err = (objBuffer[line + GLError]) + (objBuffer[line + GLErrorAdjUp]);
			if (err > 0) {
				x += objBuffer[line + GLXDirection];
				err -= objBuffer[line + GLErrorAdjDown];
			}

			/* #lineErrorOf:put: #obj:at:put: */
			objBuffer[line + GLError] = err;

			/* #edgeXValueOf:put: #obj:at:put: */
			objBuffer[line + GEXValue] = x;
		}

		/* #edgeNumLinesOf:put: #obj:at:put: */
		objBuffer[line + GENumLines] = (deltaY - (yValue - startY));
	}
	return 0;
}


/*	Initialize the bezier at yValue */

	/* BalloonEnginePlugin>>#stepToFirstWideBezierIn:at: */
static sqInt
stepToFirstWideBezierInat(sqInt bezier, sqInt yValue)
{
    int endX;
    sqInt i;
    sqInt lineOffset;
    int lineWidth;
    int nLines;
    int startY;
    int xDir;
    sqInt yEntry;
    sqInt yExit;


	/* Get some values */
	lineWidth = objBuffer[bezier + GBWideExtent];

	/* Compute the incremental values of the bezier */
	lineOffset = lineWidth / 2;
	endX = objBuffer[bezier + GBEndX];
	startY = objBuffer[bezier + GEYValue];
	stepToFirstBezierInat(bezier, startY);

	/* Copy the incremental update data */
	nLines = objBuffer[bezier + GENumLines];
	for (i = 0; i <= 5; i += 1) {
		((objBuffer + bezier) + GBWideUpdateData)[i] = (((objBuffer + bezier) + GBUpdateData)[i]);
	}
	xDir = ((objBuffer + bezier) + GBUpdateData)[GBUpdateDX];
	if (!xDir) {
		xDir = ((objBuffer + bezier) + GBUpdateData)[GBUpdateDDX];
	}
	if (xDir >= 0) {
		xDir = 1;
	}
	else {
		xDir = -1;
	}
	if (xDir < 0) {
		adjustWideBezierLeftwidthoffsetendX(bezier, lineWidth, lineOffset, endX);
	}
	else {
		adjustWideBezierRightwidthoffsetendX(bezier, lineWidth, lineOffset, endX);
	}
	if (!nLines) {
		((objBuffer + bezier) + GBUpdateData)[GBUpdateX] = ((objBuffer[bezier + GBFinalX]) * 0x100);
	}

	/* #edgeNumLinesOf:put: #obj:at:put: */
	objBuffer[bezier + GENumLines] = (nLines + lineWidth);

	/* turned on at lineOffset */
	yEntry = 0;

	/* turned off at zero */
	yExit = (0 - nLines) - lineOffset;

	/* #wideBezierEntryOf:put: #obj:at:put: */
	objBuffer[bezier + GBWideEntry] = yEntry;

	/* #wideBezierExitOf:put: #obj:at:put: */
	objBuffer[bezier + GBWideExit] = yExit;
	if ((yEntry >= lineOffset)
	 && (yExit < 0)) {
		/* #edgeFillsValidate: #objectTypeOf:put: #obj:at:put: */
		objBuffer[bezier + GEObjectType] = (((objBuffer[bezier + GEObjectType]) & GEPrimitiveTypeMask) & ((unsigned int)~GEEdgeFillsInvalid));
	}
	else {
		/* #edgeFillsInvalidate: #objectTypeOf:put: #obj:at:put: */
		objBuffer[bezier + GEObjectType] = (((objBuffer[bezier + GEObjectType]) & GEPrimitiveTypeMask) | GEEdgeFillsInvalid);
	}
	computeFinalWideBezierValueswidth(bezier, lineWidth);
	if (!(startY == yValue)) {

		/* Note: Must single step here so that entry/exit works */
		for (i = startY; i < yValue; i += 1) {
			stepToNextWideBezierInat(bezier, i);
		}

		/* #edgeNumLinesOf:put: #obj:at:put: */
		objBuffer[bezier + GENumLines] = ((objBuffer[bezier + GENumLines]) - (yValue - startY));
	}
	return 0;
}


/*	Initialize the wide line at yValue. */

	/* BalloonEnginePlugin>>#stepToFirstWideLineIn:at: */
static sqInt
stepToFirstWideLineInat(sqInt line, sqInt yValue)
{
    int err;
    sqInt i;
    int lastX;
    sqInt lineOffset;
    sqInt lineOffsetSqInt;
    int lineWidth;
    int lineWidthInt;
    int nextX;
    int nLines;
    int startX;
    int startY;
    int x;
    int xDir;
    sqInt yEntry;
    int yEntryInt;
    sqInt yExit;
    int yExitInt;


	/* Get some values */
	lineWidth = objBuffer[line + GLWideExtent];

	/* Compute the incremental values of the line */
	lineOffset = lineWidth / 2;
	startX = objBuffer[line + GEXValue];
	startY = objBuffer[line + GEYValue];
	stepToFirstLineInat(line, startY);
	nLines = objBuffer[line + GENumLines];

	/* Adjust the line to start at the correct X position */
	xDir = objBuffer[line + GLXDirection];

	/* #edgeXValueOf:put: #obj:at:put: */
	objBuffer[line + GEXValue] = (startX - lineOffset);

	/* #edgeNumLinesOf:put: #obj:at:put: */
	objBuffer[line + GENumLines] = (nLines + lineWidth);
	if (xDir > 0) {
		/* #wideLineWidthOf:put: #obj:at:put: */
		objBuffer[line + GLWideWidth] = ((objBuffer[line + GLXIncrement]) + lineWidth);
	}
	else {
		/* #wideLineWidthOf:put: #obj:at:put: */
		objBuffer[line + GLWideWidth] = (lineWidth - (objBuffer[line + GLXIncrement]));

		/* #edgeXValueOf:put: #obj:at:put: */
		objBuffer[line + GEXValue] = ((objBuffer[line + GEXValue]) + (objBuffer[line + GLXIncrement]));
	}

	/* turned on at lineOffset */
	yEntry = 0;

	/* turned off at zero */
	yExit = (0 - nLines) - lineOffset;

	/* #wideLineEntryOf:put: #obj:at:put: */
	objBuffer[line + GLWideEntry] = yEntry;

	/* #wideLineExitOf:put: #obj:at:put: */
	objBuffer[line + GLWideExit] = yExit;
	if ((yEntry >= lineOffset)
	 && (yExit < 0)) {
		/* #edgeFillsValidate: #objectTypeOf:put: #obj:at:put: */
		objBuffer[line + GEObjectType] = (((objBuffer[line + GEObjectType]) & GEPrimitiveTypeMask) & ((unsigned int)~GEEdgeFillsInvalid));
	}
	else {
		/* #edgeFillsInvalidate: #objectTypeOf:put: #obj:at:put: */
		objBuffer[line + GEObjectType] = (((objBuffer[line + GEObjectType]) & GEPrimitiveTypeMask) | GEEdgeFillsInvalid);
	}
	if (!(startY == yValue)) {
		for (i = startY; i < yValue; i += 1) {
			/* begin stepToNextWideLineIn:at: */
			yEntryInt = (objBuffer[line + GLWideEntry]) + 1;
			yExitInt = (objBuffer[line + GLWideExit]) + 1;

			/* #wideLineEntryOf:put: #obj:at:put: */
			objBuffer[line + GLWideEntry] = yEntryInt;

			/* #wideLineExitOf:put: #obj:at:put: */
			objBuffer[line + GLWideExit] = yExitInt;
			lineWidthInt = objBuffer[line + GLWideExtent];
			lineOffsetSqInt = lineWidthInt / 2;
			if (yEntryInt >= lineOffsetSqInt) {
				/* #edgeFillsValidate: #objectTypeOf:put: #obj:at:put: */
				objBuffer[line + GEObjectType] = (((objBuffer[line + GEObjectType]) & GEPrimitiveTypeMask) & ((unsigned int)~GEEdgeFillsInvalid));
			}
			if (yExitInt >= 0) {
				/* #edgeFillsInvalidate: #objectTypeOf:put: #obj:at:put: */
				objBuffer[line + GEObjectType] = (((objBuffer[line + GEObjectType]) & GEPrimitiveTypeMask) | GEEdgeFillsInvalid);
			}
			lastX = objBuffer[line + GEXValue];

			/* begin stepToNextLineIn:at: */
			x = (objBuffer[line + GEXValue]) + (objBuffer[line + GLXIncrement]);
			err = (objBuffer[line + GLError]) + (objBuffer[line + GLErrorAdjUp]);
			if (err > 0) {
				x += objBuffer[line + GLXDirection];
				err -= objBuffer[line + GLErrorAdjDown];
			}

			/* #lineErrorOf:put: #obj:at:put: */
			objBuffer[line + GLError] = err;

			/* #edgeXValueOf:put: #obj:at:put: */
			objBuffer[line + GEXValue] = x;

			/* Check for special start/end adjustments */
			nextX = objBuffer[line + GEXValue];
			if ((yEntryInt <= lineWidthInt)
			 || ((yExitInt + lineOffsetSqInt) >= 0)) {

				/* Yes, need an update */
				adjustWideLineafterSteppingFromto(line, lastX, nextX);
			}
		}

		/* #edgeNumLinesOf:put: #obj:at:put: */
		objBuffer[line + GENumLines] = ((objBuffer[line + GENumLines]) - (yValue - startY));
	}
	return 0;
}


/*	Incrementally step to the next scan line in the given wide bezier */

	/* BalloonEnginePlugin>>#stepToNextWideBezierIn:at: */
static sqInt
stepToNextWideBezierInat(sqInt bezier, sqInt yValue)
{
    int fwDx;
    int fwDy;
    int lastX;
    int lastY;
    sqInt lineOffset;
    int lineWidth;
    sqInt minY;
    int *updateData;
    int yEntry;
    int yExit;


	/* Don't inline this */
	lineWidth = objBuffer[bezier + GBWideExtent];
	lineOffset = lineWidth / 2;
	yEntry = (objBuffer[bezier + GBWideEntry]) + 1;
	yExit = (objBuffer[bezier + GBWideExit]) + 1;

	/* #wideBezierEntryOf:put: #obj:at:put: */
	objBuffer[bezier + GBWideEntry] = yEntry;

	/* #wideBezierExitOf:put: #obj:at:put: */
	objBuffer[bezier + GBWideExit] = yExit;
	if (yEntry >= lineOffset) {
		/* #edgeFillsValidate: #objectTypeOf:put: #obj:at:put: */
		objBuffer[bezier + GEObjectType] = (((objBuffer[bezier + GEObjectType]) & GEPrimitiveTypeMask) & ((unsigned int)~GEEdgeFillsInvalid));
	}
	if (yExit >= 0) {
		/* #edgeFillsInvalidate: #objectTypeOf:put: #obj:at:put: */
		objBuffer[bezier + GEObjectType] = (((objBuffer[bezier + GEObjectType]) & GEPrimitiveTypeMask) | GEEdgeFillsInvalid);
	}
	if ((yExit + lineOffset) < 0) {
		updateData = (objBuffer + bezier) + GBUpdateData;

		/* begin stepToNextBezierForward:at: */
		lastX = updateData[GBUpdateX];
		lastY = updateData[GBUpdateY];
		fwDx = updateData[GBUpdateDX];
		fwDy = updateData[GBUpdateDY];

		/* Step as long as we haven't yet reached minY and also
		   as long as fwDy is greater than zero thus stepping down.
		   Note: The test for fwDy should not be necessary in theory
		   but is a good insurance in practice. */
		minY = yValue * 0x100;
		while ((minY > lastY)
		 && (fwDy >= 0)) {
			lastX += (((sqInt)((fwDx + 0x8000))) >> 16);
			lastY += (((sqInt)((fwDy + 0x8000))) >> 16);
			fwDx += updateData[GBUpdateDDX];
			fwDy += updateData[GBUpdateDDY];
		}
		updateData[GBUpdateX] = lastX;
		updateData[GBUpdateY] = lastY;
		updateData[GBUpdateDX] = fwDx;
		updateData[GBUpdateDY] = fwDy;
		(((sqInt)(lastX)) >> 8);
	}
	else {

		/* Adjust the last x value to the final x recorded previously */
		((objBuffer + bezier) + GBUpdateData)[GBUpdateX] = ((objBuffer[bezier + GBFinalX]) * 0x100);
	}
	updateData = (objBuffer + bezier) + GBWideUpdateData;

	/* begin stepToNextBezierForward:at: */
	lastX = updateData[GBUpdateX];
	lastY = updateData[GBUpdateY];
	fwDx = updateData[GBUpdateDX];
	fwDy = updateData[GBUpdateDY];

	/* Step as long as we haven't yet reached minY and also
	   as long as fwDy is greater than zero thus stepping down.
	   Note: The test for fwDy should not be necessary in theory
	   but is a good insurance in practice. */
	minY = yValue * 0x100;
	while ((minY > lastY)
	 && (fwDy >= 0)) {
		lastX += (((sqInt)((fwDx + 0x8000))) >> 16);
		lastY += (((sqInt)((fwDy + 0x8000))) >> 16);
		fwDx += updateData[GBUpdateDDX];
		fwDy += updateData[GBUpdateDDY];
	}
	updateData[GBUpdateX] = lastX;
	updateData[GBUpdateY] = lastY;
	updateData[GBUpdateDX] = fwDx;
	updateData[GBUpdateDY] = fwDy;
	(((sqInt)(lastX)) >> 8);
	computeFinalWideBezierValueswidth(bezier, lineWidth);
	return 0;
}

	/* BalloonEngineBase>>#storeEdgeStateFrom:into: */
static sqInt
storeEdgeStateFrominto(sqInt edge, sqInt edgeOop)
{
	if ((slotSizeOf(edgeOop)) < ETBalloonEdgeDataSize) {
		return primitiveFail();
	}
	storeIntegerofObjectwithValue(ETIndexIndex, edgeOop, objBuffer[edge + GEObjectIndex]);
	storeIntegerofObjectwithValue(ETXValueIndex, edgeOop, objBuffer[edge + GEXValue]);
	storeIntegerofObjectwithValue(ETYValueIndex, edgeOop, workBuffer[GWCurrentY]);
	storeIntegerofObjectwithValue(ETZValueIndex, edgeOop, objBuffer[edge + GEZValue]);
	storeIntegerofObjectwithValue(ETLinesIndex, edgeOop, objBuffer[edge + GENumLines]);

	/* lastExportedEdgePut: */
	workBuffer[GWLastExportedEdge] = edge;
	return 0;
}

	/* BalloonEngineBase>>#storeFillStateInto: */
static sqInt
storeFillStateInto(sqInt fillOop)
{
    int fillIndex;
    int leftX;
    int rightX;

	fillIndex = workBuffer[GWLastExportedFill];
	leftX = workBuffer[GWLastExportedLeftX];
	rightX = workBuffer[GWLastExportedRightX];
	if ((slotSizeOf(fillOop)) < FTBalloonFillDataSize) {
		return primitiveFail();
	}
	storeIntegerofObjectwithValue(FTIndexIndex, fillOop, objBuffer[fillIndex + GEObjectIndex]);
	storeIntegerofObjectwithValue(FTMinXIndex, fillOop, leftX);
	storeIntegerofObjectwithValue(FTMaxXIndex, fillOop, rightX);
	storeIntegerofObjectwithValue(FTYValueIndex, fillOop, workBuffer[GWCurrentY]);
	return 0;
}

	/* BalloonEngineBase>>#storeRenderingState */
static sqInt
storeRenderingState(void)
{
    int edge;
    sqInt edgeOop;
    sqInt fillOop;
    int reason;

	if (failed()) {
		return null;
	}
	if (engineStopped) {

		/* Check the stop reason and store the required information */
		edgeOop = stackObjectValue(1);
		fillOop = stackObjectValue(0);

		/* begin storeStopStateIntoEdge:fill: */
		reason = workBuffer[GWStopReason];
		if (reason == GErrorGETEntry) {
			edge = getBuffer[workBuffer[GWGETStart]];
			storeEdgeStateFrominto(edge, edgeOop);

			/* getStartPut: */
			workBuffer[GWGETStart] = ((workBuffer[GWGETStart]) + 1);
		}
		if (reason == GErrorFillEntry) {
			storeFillStateInto(fillOop);
		}
		if (reason == GErrorAETEntry) {
			edge = aetBuffer[workBuffer[GWAETStart]];
			storeEdgeStateFrominto(edge, edgeOop);
		}
	}

	/* begin storeEngineStateInto: */
	/* objUsedPut: */
	workBuffer[GWObjUsed] = objUsed;
	pop(3);
	pushInteger(workBuffer[GWStopReason]);
	return 0;
}


/*	Recursively subdivide the curve on the bezier stack. */

	/* BalloonEnginePlugin>>#subdivideBezierFrom: */
static sqInt
subdivideBezierFrom(sqInt index)
{
    sqInt index1;
    sqInt index2;
    sqInt otherIndex;

	otherIndex = subdivideBezier(index);
	if (!(otherIndex == index)) {
		index1 = subdivideBezierFrom(index);
		if (engineStopped) {
			return 0;
		}
		index2 = subdivideBezierFrom(otherIndex);
		if (engineStopped) {
			return 0;
		}
		if (index1 >= index2) {
			return index1;
		}
		else {
			return index2;
		}
	}
	return index;
}


/*	Subdivide the given bezier curve if necessary */

	/* BalloonEnginePlugin>>#subdivideBezier: */
static sqInt
subdivideBezier(sqInt index)
{
    int deltaX;
    int deltaY;
    int endX;
    int endY;
    int startX;
    int startY;

	startY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)];

	/* If the receiver is horizontal, don't do anything */
	endY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)];
	if (endY == startY) {
		return index;
	}
	deltaY = endY - startY;
	if (deltaY < 0) {
		deltaY = 0 - deltaY;
	}
	if (deltaY > 0xFF) {
		/* incrementStat:by: */
		workBuffer[GWBezierHeightSubdivisions] = ((workBuffer[GWBezierHeightSubdivisions]) + 1);
		return computeBezierSplitAtHalf(index);
	}
	startX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index))];
	endX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)];
	deltaX = endX - startX;
	if (deltaX < 0) {
		deltaX = 0 - deltaX;
	}
	if ((deltaY * 32) < deltaX) {
		/* incrementStat:by: */
		workBuffer[GWBezierOverflowSubdivisions] = ((workBuffer[GWBezierOverflowSubdivisions]) + 1);
		return computeBezierSplitAtHalf(index);
	}
	return index;
}


/*	Check if the given bezier curve is monoton in X. If not, subdivide it */

	/* BalloonEnginePlugin>>#subdivideToBeMonotonInX: */
static sqInt
subdivideToBeMonotonInX(sqInt index)
{
    int denom;
    int dx1;
    int dx2;
    int endX;
    int num;
    int startX;
    int viaX;

	startX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index))];
	viaX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 2)];
	endX = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 4)];
	dx1 = viaX - startX;
	dx2 = endX - viaX;
	if ((dx1 * dx2) >= 0) {
		return index;
	}

	/* incrementStat:by: */
	workBuffer[GWBezierMonotonSubdivisions] = ((workBuffer[GWBezierMonotonSubdivisions]) + 1);
	denom = dx2 - dx1;
	num = dx1;
	if (num < 0) {
		num = 0 - num;
	}
	if (denom < 0) {
		denom = 0 - denom;
	}
	return computeBeziersplitAt(index, (((double) num )) / (((double) denom )));
}


/*	Check if the given bezier curve is monoton in Y. If not, subdivide it */

	/* BalloonEnginePlugin>>#subdivideToBeMonotonInY: */
static sqInt
subdivideToBeMonotonInY(sqInt index)
{
    int denom;
    int dy1;
    int dy2;
    int endY;
    int num;
    int startY;
    int viaY;

	startY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 1)];
	viaY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 3)];
	endY = workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - index) + 5)];
	dy1 = viaY - startY;
	dy2 = endY - viaY;
	if ((dy1 * dy2) >= 0) {
		return index;
	}

	/* incrementStat:by: */
	workBuffer[GWBezierMonotonSubdivisions] = ((workBuffer[GWBezierMonotonSubdivisions]) + 1);
	denom = dy2 - dy1;
	num = dy1;
	if (num < 0) {
		num = 0 - num;
	}
	if (denom < 0) {
		denom = 0 - denom;
	}
	return computeBeziersplitAt(index, (((double) num )) / (((double) denom )));
}


/*	Check if the given bezier curve is monoton in Y, and, if desired in X. 
	If not, subdivide it */

	/* BalloonEnginePlugin>>#subdivideToBeMonoton:inX: */
static sqInt
subdivideToBeMonotoninX(sqInt base, sqInt doTestX)
{
    sqInt base2;
    sqInt index1;
    sqInt index2;

	base2 = (index1 = (index2 = subdivideToBeMonotonInY(base)));
	if (doTestX) {
		index1 = subdivideToBeMonotonInX(base);
	}
	if (index1 > index2) {
		index2 = index1;
	}
	if ((base != base2)
	 && (doTestX)) {
		index1 = subdivideToBeMonotonInX(base2);
	}
	if (index1 > index2) {
		index2 = index1;
	}
	return index2;
}

	/* BalloonEngineBase>>#toggleFillsOf: */
static sqInt
toggleFillsOf(sqInt edge)
{
    sqInt depth;
    int fillIndex;

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 6 /* (stackFillEntryLength * 2) */) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return null;
	}
	depth = ((sqInt)((usqInt)((objBuffer[edge + GEZValue])) << 1));
	fillIndex = objBuffer[edge + GEFillIndexLeft];
	if (fillIndex) {
		toggleFilldepthrightX(fillIndex, depth, 999999999);
	}
	fillIndex = objBuffer[edge + GEFillIndexRight];
	if (fillIndex) {
		toggleFilldepthrightX(fillIndex, depth, 999999999);
	}

	/* begin quickRemoveInvalidFillsAt: */
	if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
		goto l1;
	}
	while ((topRightX()) <= (objBuffer[edge + GEXValue])) {
		hideFilldepth(topFill(), topDepth());
		if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
			goto l1;
		}
	}
l1:	/* end quickRemoveInvalidFillsAt: */;
	return 0;
}


/*	Make the fill style with the given index either visible or invisible */

	/* BalloonEngineBase>>#toggleFill:depth:rightX: */
static sqInt
toggleFilldepthrightX(sqInt fillIndex, sqInt depth, sqInt rightX)
{
    sqInt hidden;

	if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
		hidden = hideFilldepth(fillIndex, depth);
		if (!hidden) {
			showFilldepthrightX(fillIndex, depth, rightX);
		}
	}
	else {
		/* begin allocateStackFillEntry */
		/* begin wbStackPush: */
		/* begin allocateStackEntry: */
		/* begin needAvailableSpace: */
		if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 3 /* stackFillEntryLength */) > (workBuffer[GWBufferTop])) {
			/* begin stopBecauseOf: */
			/* stopReasonPut: */
			workBuffer[GWStopReason] = GErrorNoMoreSpace;
			engineStopped = 1;
			goto l1;
		}

		/* wbTopPut: */
		workBuffer[GWBufferTop] = ((workBuffer[GWBufferTop]) - 3 /* stackFillEntryLength */);

		/* #topFillValuePut: #stackFillValue:put: #wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)] = fillIndex;

		/* #topFillDepthPut: #stackFillDepth:put: #wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 1)] = depth;

		/* #topFillRightXPut: #stackFillRightX:put: #wbStackValue:put: */
		workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)] = rightX;
l1:;
	}
	return 0;
}

	/* BalloonEngineBase>>#toggleWideFillOf: */
static sqInt
toggleWideFillOf(sqInt edge)
{
    sqInt depth;
    sqInt fill;
    sqInt index;
    sqInt lineWidth;
    sqInt rightX;
    sqInt type;

	type = ((usqInt)(((objBuffer[edge + GEObjectType]) & GEPrimitiveTypeMask))) >> 1;
	dispatchedValue = edge;
	switch (type) {
	case 0: // errorWrongIndex
	case 1: // errorWrongIndex
		error("BalloonEngine: Fatal dispatch error");
		break;
	case 2: // returnWideLineWidth
		dispatchReturnValue = objBuffer[dispatchedValue + GLWideWidth];
		break;
	case 3: // returnWideBezierWidth
		dispatchReturnValue = objBuffer[dispatchedValue + GBWideWidth];
		break;
	}
	lineWidth = dispatchReturnValue;
	switch (type) {
	case 0: // errorWrongIndex
	case 1: // errorWrongIndex
		error("BalloonEngine: Fatal dispatch error");
		break;
	case 2: // returnWideLineFill
		dispatchReturnValue = objBuffer[dispatchedValue + GLWideFill];
		break;
	case 3: // returnWideBezierFill
		dispatchReturnValue = objBuffer[dispatchedValue + GBWideFill];
		break;
	}
	fill = dispatchReturnValue;
	if (!fill) {
		return null;
	}

	/* begin needAvailableSpace: */
	if (((((GWHeaderSize + objUsed) + (workBuffer[GWGETUsed])) + (workBuffer[GWAETUsed])) + 3 /* stackFillEntryLength */) > (workBuffer[GWBufferTop])) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNoMoreSpace;
		engineStopped = 1;
		return null;
	}

	/* So lines sort before interior fills */
	depth = ((((usqInt)((objBuffer[edge + GEZValue])) << 1))) + 1;
	rightX = (objBuffer[edge + GEXValue]) + lineWidth;
	index = findStackFilldepth(fill, depth);
	if (index == -1) {
		showFilldepthrightX(fill, depth, rightX);
	}
	else {
		if ((workBuffer[(workBuffer[GWBufferTop]) + (index + 2)]) < rightX) {
			/* #stackFillRightX:put: #wbStackValue:put: */
			workBuffer[(workBuffer[GWBufferTop]) + (index + 2)] = rightX;
		}
	}

	/* begin quickRemoveInvalidFillsAt: */
	if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
		goto l1;
	}
	while ((topRightX()) <= (objBuffer[edge + GEXValue])) {
		hideFilldepth(topFill(), topDepth());
		if (!((workBuffer[GWSize]) - (workBuffer[GWBufferTop]))) {
			goto l1;
		}
	}
l1:	/* end quickRemoveInvalidFillsAt: */;
	return 0;
}

	/* BalloonEngineBase>>#topDepth */
static int
topDepth(void)
{
	if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
		return workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 1)];
	}
	else {
		return -1;
	}
}

	/* BalloonEngineBase>>#topFill */
static int
topFill(void)
{
	if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
		return workBuffer[(workBuffer[GWBufferTop]) + (((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */)];
	}
	else {
		return 0;
	}
}

	/* BalloonEngineBase>>#topRightX */
static int
topRightX(void)
{
	if ((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) {
		return workBuffer[(workBuffer[GWBufferTop]) + ((((workBuffer[GWSize]) - (workBuffer[GWBufferTop])) - 3 /* stackFillEntryLength */) + 2)];
	}
	else {
		return 999999999;
	}
}

	/* BalloonEngineBase>>#transformColor: */
static sqInt
transformColor(sqInt fillIndex)
{
    sqInt a;
    double alphaScale;
    sqInt b;
    sqInt g;
    sqInt r;
    float *transform;

	if (!((fillIndex == 0)
		 || ((fillIndex & 0xFF000000U) != 0))) {
		return fillIndex;
	}
	b = fillIndex & 0xFF;
	g = (((usqInt)(fillIndex)) >> 8) & 0xFF;
	r = (((usqInt)(fillIndex)) >> 16) & 0xFF;
	a = (((usqInt)(fillIndex)) >> 24) & 0xFF;
	if (workBuffer[GWHasColorTransform]) {
		/* begin colorTransform */
		transform = ((float *) (workBuffer + GWColorTransform));
		alphaScale = ((a * (transform[6])) + (transform[7])) / a;
		r = ((sqInt)(((r * (transform[0])) + (transform[1])) * alphaScale));
		g = ((sqInt)(((g * (transform[2])) + (transform[3])) * alphaScale));
		b = ((sqInt)(((b * (transform[4])) + (transform[5])) * alphaScale));
		a = ((sqInt)(a * alphaScale));
		r = ((r < 0) ? 0 : r);
		r = ((r < 0xFF) ? r : 0xFF);
		g = ((g < 0) ? 0 : g);
		g = ((g < 0xFF) ? g : 0xFF);
		b = ((b < 0) ? 0 : b);
		b = ((b < 0xFF) ? b : 0xFF);
		a = ((a < 0) ? 0 : a);
		a = ((a < 0xFF) ? a : 0xFF);
	}
	if (a < 1) {
		return 0;
	}
	if ((a < 0xFF)
	 && ((workBuffer[GWNeedsFlush]) != 0)) {
		/* begin stopBecauseOf: */
		/* stopReasonPut: */
		workBuffer[GWStopReason] = GErrorNeedFlush;
		engineStopped = 1;
	}
	return ((b + ((((usqInt)(g) << 8)))) + ((((usqInt)(r) << 16)))) + ((((usqInt)(a) << 24)));
}


/*	Transform the given width */

	/* BalloonEngineBase>>#transformWidth: */
static sqInt
transformWidth(sqInt w)
{
    double deltaX;
    double deltaY;
    int *dstPoint1;
    sqInt dstWidth;
    sqInt dstWidth2;
    int *point;
    float *transform;
    sqInt x;
    sqInt y;

	if (!w) {
		return 0;
	}
	(*((int *) (workBuffer + GWPoint1)) = 0);
	(((int *) (workBuffer + GWPoint1)))[1] = 0;
	(*((int *) (workBuffer + GWPoint2)) = w * 0x100);
	(((int *) (workBuffer + GWPoint2)))[1] = 0;
	(*((int *) (workBuffer + GWPoint3)) = 0);
	(((int *) (workBuffer + GWPoint3)))[1] = (w * 0x100);

	/* begin transformPoints: */
	if (3 > 0) {
		point = ((int *) (workBuffer + GWPoint1));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (3 > 1) {
		point = ((int *) (workBuffer + GWPoint2));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (3 > 2) {
		point = ((int *) (workBuffer + GWPoint3));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	if (3 > 3) {
		point = ((int *) (workBuffer + GWPoint4));

		/* begin transformPoint: */
		if (workBuffer[GWHasEdgeTransform]) {

			/* Note: AA adjustment is done in #transformPoint: for higher accuracy */
			/* begin transformPoint:into: */
			dstPoint1 = ((int *) point);
			transform = ((float *) (workBuffer + GWEdgeTransform));
			x = ((sqInt)(((((transform[0]) * (((double) ((*((int *) point))) ))) + ((transform[1]) * (((double) ((((int *) point))[1]) )))) + (transform[2])) * (((double) (workBuffer[GWAALevel]) ))));
			y = ((sqInt)(((((transform[3]) * (((double) ((*((int *) point))) ))) + ((transform[4]) * (((double) ((((int *) point))[1]) )))) + (transform[5])) * (((double) (workBuffer[GWAALevel]) ))));
			dstPoint1[0] = x;
			dstPoint1[1] = y;
		}
		else {

			/* Multiply each component by aaLevel and add a half pixel */
			point[0] = (((point[0]) + (workBuffer[GWDestOffsetX])) * (workBuffer[GWAALevel]));
			point[1] = (((point[1]) + (workBuffer[GWDestOffsetY])) * (workBuffer[GWAALevel]));
		}
	}
	deltaX = ((double) (((*((int *) (workBuffer + GWPoint2)))) - ((*((int *) (workBuffer + GWPoint1))))) );
	deltaY = ((double) (((((int *) (workBuffer + GWPoint2)))[1]) - ((((int *) (workBuffer + GWPoint1)))[1])) );
	dstWidth = ((((sqInt)(sqrt((deltaX * deltaX) + (deltaY * deltaY))))) + 128) / 0x100;
	deltaX = ((double) (((*((int *) (workBuffer + GWPoint3)))) - ((*((int *) (workBuffer + GWPoint1))))) );
	deltaY = ((double) (((((int *) (workBuffer + GWPoint3)))[1]) - ((((int *) (workBuffer + GWPoint1)))[1])) );
	dstWidth2 = ((((sqInt)(sqrt((deltaX * deltaX) + (deltaY * deltaY))))) + 128) / 0x100;
	if (dstWidth2 < dstWidth) {
		dstWidth = dstWidth2;
	}
	if (dstWidth) {
		return dstWidth;
	}
	else {
		return 1;
	}
}

	/* BalloonEngineBase>>#uncheckedTransformColor: */
static sqInt
uncheckedTransformColor(sqInt fillIndex)
{
    sqInt a;
    sqInt b;
    sqInt g;
    sqInt r;
    float *transform;

	if (!(workBuffer[GWHasColorTransform])) {
		return fillIndex;
	}
	b = fillIndex & 0xFF;
	g = (((usqInt)(fillIndex)) >> 8) & 0xFF;
	r = (((usqInt)(fillIndex)) >> 16) & 0xFF;
	a = (((usqInt)(fillIndex)) >> 24) & 0xFF;

	/* begin colorTransform */
	transform = ((float *) (workBuffer + GWColorTransform));
	r = ((sqInt)((r * (transform[0])) + (transform[1])));
	g = ((sqInt)((g * (transform[2])) + (transform[3])));
	b = ((sqInt)((b * (transform[4])) + (transform[5])));
	a = ((sqInt)((a * (transform[6])) + (transform[7])));
	r = ((r < 0) ? 0 : r);
	r = ((r < 0xFF) ? r : 0xFF);
	g = ((g < 0) ? 0 : g);
	g = ((g < 0xFF) ? g : 0xFF);
	b = ((b < 0) ? 0 : b);
	b = ((b < 0xFF) ? b : 0xFF);
	a = ((a < 0) ? 0 : a);
	a = ((a < 0xFF) ? a : 0xFF);
	if (a < 16) {
		return 0;
	}
	return ((b + ((((usqInt)(g) << 8)))) + ((((usqInt)(r) << 16)))) + ((((usqInt)(a) << 24)));
}

/*** Exports ***/

#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "B2DPlugin";
void* B2DPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveAbortProcessing\000\002\003", (void*)primitiveAbortProcessing},
	{(void*)_m, "primitiveAddActiveEdgeEntry\000\002\003", (void*)primitiveAddActiveEdgeEntry},
	{(void*)_m, "primitiveAddBezier\000\002\003", (void*)primitiveAddBezier},
	{(void*)_m, "primitiveAddBezierShape\000\002\003", (void*)primitiveAddBezierShape},
	{(void*)_m, "primitiveAddBitmapFill\000\002\003", (void*)primitiveAddBitmapFill},
	{(void*)_m, "primitiveAddCompressedShape\000\002\003", (void*)primitiveAddCompressedShape},
	{(void*)_m, "primitiveAddGradientFill\000\002\003", (void*)primitiveAddGradientFill},
	{(void*)_m, "primitiveAddLine\000\002\003", (void*)primitiveAddLine},
	{(void*)_m, "primitiveAddOval\000\002\003", (void*)primitiveAddOval},
	{(void*)_m, "primitiveAddPolygon\000\002\003", (void*)primitiveAddPolygon},
	{(void*)_m, "primitiveAddRect\000\002\003", (void*)primitiveAddRect},
	{(void*)_m, "primitiveChangedActiveEdgeEntry\000\002\003", (void*)primitiveChangedActiveEdgeEntry},
	{(void*)_m, "primitiveCopyBuffer\000\001\003", (void*)primitiveCopyBuffer},
	{(void*)_m, "primitiveDisplaySpanBuffer\000\002\000", (void*)primitiveDisplaySpanBuffer},
	{(void*)_m, "primitiveDoProfileStats\000\000\003", (void*)primitiveDoProfileStats},
	{(void*)_m, "primitiveFinishedProcessing\000\002\003", (void*)primitiveFinishedProcessing},
	{(void*)_m, "primitiveGetAALevel\000\002\003", (void*)primitiveGetAALevel},
	{(void*)_m, "primitiveGetBezierStats\000\002\003", (void*)primitiveGetBezierStats},
	{(void*)_m, "primitiveGetClipRect\000\002\003", (void*)primitiveGetClipRect},
	{(void*)_m, "primitiveGetCounts\000\002\003", (void*)primitiveGetCounts},
	{(void*)_m, "primitiveGetDepth\000\002\003", (void*)primitiveGetDepth},
	{(void*)_m, "primitiveGetFailureReason\000\002\003", (void*)primitiveGetFailureReason},
	{(void*)_m, "primitiveGetOffset\000\002\003", (void*)primitiveGetOffset},
	{(void*)_m, "primitiveGetTimes\000\002\003", (void*)primitiveGetTimes},
	{(void*)_m, "primitiveInitializeBuffer\000\001\003", (void*)primitiveInitializeBuffer},
	{(void*)_m, "primitiveInitializeProcessing\000\002\003", (void*)primitiveInitializeProcessing},
	{(void*)_m, "primitiveMergeFillFrom\000\002\003", (void*)primitiveMergeFillFrom},
	{(void*)_m, "primitiveNeedsFlush\000\002\003", (void*)primitiveNeedsFlush},
	{(void*)_m, "primitiveNeedsFlushPut\000\002\003", (void*)primitiveNeedsFlushPut},
	{(void*)_m, "primitiveNextActiveEdgeEntry\000\002\003", (void*)primitiveNextActiveEdgeEntry},
	{(void*)_m, "primitiveNextFillEntry\000\004\003", (void*)primitiveNextFillEntry},
	{(void*)_m, "primitiveNextGlobalEdgeEntry\000\002\003", (void*)primitiveNextGlobalEdgeEntry},
	{(void*)_m, "primitiveRegisterExternalEdge\000\002\003", (void*)primitiveRegisterExternalEdge},
	{(void*)_m, "primitiveRegisterExternalFill\000\002\003", (void*)primitiveRegisterExternalFill},
	{(void*)_m, "primitiveRenderImage\000\377\000", (void*)primitiveRenderImage},
	{(void*)_m, "primitiveRenderScanline\000\377\000", (void*)primitiveRenderScanline},
	{(void*)_m, "primitiveSetAALevel\000\002\003", (void*)primitiveSetAALevel},
	{(void*)_m, "primitiveSetBitBltPlugin\000\001\003", (void*)primitiveSetBitBltPlugin},
	{(void*)_m, "primitiveSetClipRect\000\002\003", (void*)primitiveSetClipRect},
	{(void*)_m, "primitiveSetColorTransform\000\002\003", (void*)primitiveSetColorTransform},
	{(void*)_m, "primitiveSetDepth\000\002\003", (void*)primitiveSetDepth},
	{(void*)_m, "primitiveSetEdgeTransform\000\002\003", (void*)primitiveSetEdgeTransform},
	{(void*)_m, "primitiveSetOffset\000\002\003", (void*)primitiveSetOffset},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveAbortProcessingMetadata = 515;
EXPORT(signed short) primitiveAddActiveEdgeEntryMetadata = 515;
EXPORT(signed short) primitiveAddBezierMetadata = 515;
EXPORT(signed short) primitiveAddBezierShapeMetadata = 515;
EXPORT(signed short) primitiveAddBitmapFillMetadata = 515;
EXPORT(signed short) primitiveAddCompressedShapeMetadata = 515;
EXPORT(signed short) primitiveAddGradientFillMetadata = 515;
EXPORT(signed short) primitiveAddLineMetadata = 515;
EXPORT(signed short) primitiveAddOvalMetadata = 515;
EXPORT(signed short) primitiveAddPolygonMetadata = 515;
EXPORT(signed short) primitiveAddRectMetadata = 515;
EXPORT(signed short) primitiveChangedActiveEdgeEntryMetadata = 515;
EXPORT(signed short) primitiveCopyBufferMetadata = 259;
EXPORT(signed short) primitiveDisplaySpanBufferMetadata = 0x200;
EXPORT(signed short) primitiveDoProfileStatsMetadata = 3;
EXPORT(signed short) primitiveFinishedProcessingMetadata = 515;
EXPORT(signed short) primitiveGetAALevelMetadata = 515;
EXPORT(signed short) primitiveGetBezierStatsMetadata = 515;
EXPORT(signed short) primitiveGetClipRectMetadata = 515;
EXPORT(signed short) primitiveGetCountsMetadata = 515;
EXPORT(signed short) primitiveGetDepthMetadata = 515;
EXPORT(signed short) primitiveGetFailureReasonMetadata = 515;
EXPORT(signed short) primitiveGetOffsetMetadata = 515;
EXPORT(signed short) primitiveGetTimesMetadata = 515;
EXPORT(signed short) primitiveInitializeBufferMetadata = 259;
EXPORT(signed short) primitiveInitializeProcessingMetadata = 515;
EXPORT(signed short) primitiveMergeFillFromMetadata = 515;
EXPORT(signed short) primitiveNeedsFlushMetadata = 515;
EXPORT(signed short) primitiveNeedsFlushPutMetadata = 515;
EXPORT(signed short) primitiveNextActiveEdgeEntryMetadata = 515;
EXPORT(signed short) primitiveNextFillEntryMetadata = 1027;
EXPORT(signed short) primitiveNextGlobalEdgeEntryMetadata = 515;
EXPORT(signed short) primitiveRegisterExternalEdgeMetadata = 515;
EXPORT(signed short) primitiveRegisterExternalFillMetadata = 515;
EXPORT(signed short) primitiveSetAALevelMetadata = 515;
EXPORT(signed short) primitiveSetBitBltPluginMetadata = 259;
EXPORT(signed short) primitiveSetClipRectMetadata = 515;
EXPORT(signed short) primitiveSetColorTransformMetadata = 515;
EXPORT(signed short) primitiveSetDepthMetadata = 515;
EXPORT(signed short) primitiveSetEdgeTransformMetadata = 515;
EXPORT(signed short) primitiveSetOffsetMetadata = 515;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
