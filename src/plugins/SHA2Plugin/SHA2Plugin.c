/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.3090 uuid: 3e2b8343-01bb-4169-ba4c-aecf82b4dcfc
   from
	SHA2Plugin * CryptographyPlugins-eem.23 uuid: bc8a8db4-2e4d-458f-bac9-f007458fdd4d
 */
static char __buildInfo[] = "SHA2Plugin * CryptographyPlugins-eem.23 uuid: bc8a8db4-2e4d-458f-bac9-f007458fdd4d " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrBadNumArgs 5
#if !defined(VMBIGENDIAN) /* Allow this to be overridden on the compiler command line */
# define VMBIGENDIAN 0
#endif


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primitiveCopyDoubleWordsIntoBytesBigEndian(void);
EXPORT(sqInt) primitiveCopyWordsIntoBytesBigEndian(void);
EXPORT(sqInt) primitiveIsPluginAvailable(void);
EXPORT(sqInt) primitiveSHA256ProcessBufferUpdatingHash(void);
EXPORT(sqInt) primitiveSHA512ProcessBufferUpdatingHash(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*byteSizeOf)(sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*isWordsOrBytes)(sqInt oop);
static sqInt (*methodArgumentCount)(void);
static sqInt (*methodReturnBool)(sqInt boolean);
static sqInt (*methodReturnReceiver)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackObjectValue)(sqInt offset);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt byteSizeOf(sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt methodArgumentCount(void);
extern sqInt methodReturnBool(sqInt boolean);
extern sqInt methodReturnReceiver(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackObjectValue(sqInt offset);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "SHA2Plugin * CryptographyPlugins-eem.23 " INT_EXT;
static const unsigned int sha256k[] = {
/*0*/	1116352408, 1899447441, 3049323471U, 3921009573U, 961987163, 0x59F111F1, 2453635748U,
/*7*/	2870763221U, 0xD807AA98U, 310598401, 607225278, 1426881987, 1925078388, 2162078206U,
/*14*/	2614888103U, 3248222580U, 3835390401U, 4022224774U, 264347078, 604807628,
/*20*/	770255983, 0x4A7484AA, 1555081692, 1996064986, 2554220882U, 0xA831C66DU, 2952996808U,
/*27*/	3210313671U, 3336571891U, 3584528711U, 113926993, 338241895, 666307205, 773529912,
/*34*/	1294757372, 1396182291, 1695183700, 1986661051, 2177026350U, 0x92722C85U,
/*40*/	2730485921U, 2820302411U, 3259730800U, 3345764771U, 3516065817U, 3600352804U,
/*46*/	4094571909U, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571,
/*53*/	1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452U, 0x8CC70208U,
/*60*/	0x90BEFFFAU, 2756734187U, 3204031479U, 3329325298U
	};
static const unsigned long long sha512k[] = {
/*0*/	4794697086780616226LL, 8158064640168781261LL, 13096744586834688815ULL, 16840607885511220156ULL,
/*4*/	4131703408338449720LL, 0x59F111F1B605D019LL, 10538285296894168987ULL, 12329834152419229976ULL,
/*8*/	15566598209576043074ULL, 1334009975649890238LL, 2608012711638119052LL, 6128411473006802146LL,
/*12*/	8268148722764581231LL, 9286055187155687089ULL, 11230858885718282805ULL, 13951009754708518548ULL,
/*16*/	16472876342353939154ULL, 17275323862435702243ULL, 1135362057144423861LL, 0x240CA1CC77AC9C65LL,
/*20*/	3308224258029322869LL, 5365058923640841347LL, 6679025012923562964LL, 8573033837759648693LL,
/*24*/	10970295158949994411ULL, 12119686244451234320ULL, 12683024718118986047ULL, 13788192230050041572ULL,
/*28*/	14330467153632333762ULL, 15395433587784984357ULL, 489312712824947311LL, 1452737877330783856LL,
/*32*/	2861767655752347644LL, 3322285676063803686LL, 5560940570517711597LL, 5996557281743188959LL,
/*36*/	7280758554555802590LL, 8532644243296465576LL, 9350256976987008742ULL, 10552545826968843579ULL,
/*40*/	11727347734174303076ULL, 12113106623233404929ULL, 14000437183269869457ULL, 14369950271660146224ULL,
/*44*/	15101387698204529176ULL, 0xD69906245565A910ULL, 0xF40E35855771202AULL, 1182934255886127544LL,
/*48*/	1847814050463011016LL, 2177327727835720531LL, 0x2748774CDF8EEB99LL, 3796741975233480872LL,
/*52*/	4115178125766777443LL, 5681478168544905931LL, 6601373596472566643LL, 7507060721942968483LL,
/*56*/	8399075790359081724LL, 8693463985226723168LL, 9568029438360202098ULL, 10144078919501101548ULL,
/*60*/	10430055236837252648ULL, 11840083180663258601ULL, 13761210420658862357ULL, 14299343276471374635ULL,
/*64*/	14566680578165727644ULL, 15097957966210449927ULL, 16922976911328602910ULL, 17689382322260857208ULL,
/*68*/	500013540394364858LL, 748580250866718886LL, 1242879168328830382LL, 1977374033974150939LL,
/*72*/	2944078676154940804LL, 3659926193048069267LL, 4368137639120453308LL, 4836135668995329356LL,
/*76*/	5532061633213252278LL, 6448918945643986474LL, 6902733635092675308LL, 7801388544844847127LL
	};



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* SHA2Plugin>>#primitiveCopyDoubleWordsIntoBytesBigEndian */
EXPORT(sqInt)
primitiveCopyDoubleWordsIntoBytesBigEndian(void)
{
    sqInt byteCount;
    unsigned char *bytes;
    sqInt bytesOop;
    sqInt doubleWordCount;
    unsigned long long *doubleWords;
    sqInt doubleWordsOop;
    sqInt i;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}

	/* TODO: there's no easy way to check whether doubleWordsOop is a DoubleWord object, so be creative here */
	doubleWordsOop = stackObjectValue(1);
	if (!(isWordsOrBytes(doubleWordsOop))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	doubleWordCount = stSizeOf(doubleWordsOop);
	if (!((byteSizeOf(doubleWordsOop)) == (doubleWordCount * 8))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	bytesOop = stackObjectValue(0);
	if (!(isBytes(bytesOop))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	byteCount = stSizeOf(bytesOop);
	if (!((doubleWordCount * 8) == byteCount)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	doubleWords = firstIndexableField(doubleWordsOop);
	bytes = firstIndexableField(bytesOop);
	/* begin copyDoubleWords:into:count: */
	if (VMBIGENDIAN) {
		memcpy(((unsigned long *) (((unsigned long long*) bytes))), ((unsigned long *) doubleWords), doubleWordCount * 8);
	}
	else {
		for (i = 0; i < doubleWordCount; i += 1) {
			(((unsigned long *) (((unsigned long long*) bytes))))[i] = (SQ_SWAP_8_BYTES(((((unsigned long *) doubleWords))[i])));
		}
	}
	methodReturnReceiver();
	return 0;
}


/*	Copy all words into bytes in big-endian byte order. */

	/* SHA2Plugin>>#primitiveCopyWordsIntoBytesBigEndian */
EXPORT(sqInt)
primitiveCopyWordsIntoBytesBigEndian(void)
{
    sqInt byteCount;
    unsigned char *bytes;
    sqInt bytesOop;
    sqInt i;
    sqInt wordCount;
    unsigned int *words;
    sqInt wordsOop;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	wordsOop = stackObjectValue(1);
	if (!(isWords(wordsOop))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	bytesOop = stackObjectValue(0);
	if (!(isBytes(bytesOop))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	wordCount = stSizeOf(wordsOop);
	byteCount = stSizeOf(bytesOop);
	if (!((wordCount * 4) == byteCount)) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	words = firstIndexableField(wordsOop);
	bytes = firstIndexableField(bytesOop);
	/* begin copyWords:into:count: */
	if (VMBIGENDIAN) {
		memcpy(((unsigned int *) bytes), words, wordCount * 4);
	}
	else {
		for (i = 0; i < wordCount; i += 1) {
			(((unsigned int *) bytes))[i] = (SQ_SWAP_4_BYTES((words[i])));
		}
	}
	methodReturnReceiver();
	return 0;
}

	/* SHA2Plugin>>#primitiveIsPluginAvailable */
EXPORT(sqInt)
primitiveIsPluginAvailable(void)
{
	methodReturnBool(1);
	return 0;
}

	/* SHA2Plugin>>#primitiveSHA256ProcessBufferUpdatingHash */
EXPORT(sqInt)
primitiveSHA256ProcessBufferUpdatingHash(void)
{
    unsigned int a;
    unsigned int b;
    unsigned char *buffer;
    sqInt bufferOop;
    unsigned int c;
    unsigned int ch;
    unsigned int d;
    unsigned int e;
    unsigned int f;
    unsigned int g;
    unsigned int h;
    unsigned int *hash;
    sqInt hashOop;
    unsigned int i;
    sqInt i1;
    sqInt i2;
    unsigned int maj;
    unsigned int s0;
    unsigned int s01;
    unsigned int s1;
    unsigned int s11;
    unsigned int t1;
    unsigned int t2;
    unsigned int w[64];

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	bufferOop = stackObjectValue(1);
	if (!((isBytes(bufferOop))
		 && ((stSizeOf(bufferOop)) == 64))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	hashOop = stackObjectValue(0);
	if (!((isWords(hashOop))
		 && ((stSizeOf(hashOop)) == 8))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	buffer = firstIndexableField(bufferOop);
	hash = firstIndexableField(hashOop);
	/* begin sha256ProcessBuffer:updatingHash: */
	/* begin sha256CopyAndExpandBuffer:into: */
	if (VMBIGENDIAN) {
		memcpy(w, ((unsigned int*) buffer), 64);
	}
	else {
		for (i1 = 0; i1 < 16; i1 += 1) {
			w[i1] = (SQ_SWAP_4_BYTES(((((unsigned int*) buffer))[i1])));
		}
	}
	for (i2 = 16; i2 <= 0x3F; i2 += 1) {
		s01 = (((((usqInt)((w[i2 - 15]))) >> 7) | (((usqInt)((w[i2 - 15])) << (25)))) ^ ((((usqInt)((w[i2 - 15]))) >> 18) | (((usqInt)((w[i2 - 15])) << (14))))) ^ (((usqInt)((w[i2 - 15]))) >> 3);
		s11 = (((((usqInt)((w[i2 - 2]))) >> 17) | (((usqInt)((w[i2 - 2])) << (15)))) ^ ((((usqInt)((w[i2 - 2]))) >> 19) | (((usqInt)((w[i2 - 2])) << (13))))) ^ (((usqInt)((w[i2 - 2]))) >> 10);
		w[i2] = (((s01 + s11) + (w[i2 - 16])) + (w[i2 - 7]));
	}
	a = hash[0];
	b = hash[1];
	c = hash[2];
	d = hash[3];
	e = hash[4];
	f = hash[5];
	g = hash[6];
	h = hash[7];
	for (i = 0; i <= 0x3F; i += 1) {
		s0 = (((((usqInt)(a)) >> 2) | (((usqInt)(a) << (30)))) ^ ((((usqInt)(a)) >> 13) | (((usqInt)(a) << (19))))) ^ ((((usqInt)(a)) >> 22) | (((usqInt)(a) << (10))));

		/* optimized form of (a and b) xor (a and c) xor (b and c) */
		maj = ((a | b) & c) | (a & b);
		t2 = s0 + maj;
		s1 = (((((usqInt)(e)) >> 6) | (((usqInt)(e) << (26)))) ^ ((((usqInt)(e)) >> 11) | (((usqInt)(e) << (21))))) ^ ((((usqInt)(e)) >> 25) | (((usqInt)(e) << (7))));

		/* optimized form of (e and f) xor ((not e) and g) */
		ch = ((f ^ g) & e) ^ g;
		t1 = (((h + s1) + ch) + (sha256k[i])) + (w[i]);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}
	hash[0] = ((hash[0]) + a);
	hash[1] = ((hash[1]) + b);
	hash[2] = ((hash[2]) + c);
	hash[3] = ((hash[3]) + d);
	hash[4] = ((hash[4]) + e);
	hash[5] = ((hash[5]) + f);
	hash[6] = ((hash[6]) + g);
	hash[7] = ((hash[7]) + h);
	methodReturnReceiver();
	return 0;
}

	/* SHA2Plugin>>#primitiveSHA512ProcessBufferUpdatingHash */
EXPORT(sqInt)
primitiveSHA512ProcessBufferUpdatingHash(void)
{
    unsigned long long a;
    unsigned long long b;
    unsigned char *buffer;
    sqInt bufferOop;
    unsigned long long c;
    unsigned long long ch;
    unsigned long long d;
    unsigned long long e;
    unsigned long long f;
    unsigned long long g;
    unsigned long long h;
    unsigned long long *hash;
    sqInt hashOop;
    unsigned long long i;
    sqInt i1;
    sqInt i2;
    unsigned long long maj;
    unsigned long long s0;
    unsigned long long s01;
    unsigned long long s1;
    unsigned long long s11;
    unsigned long long t1;
    unsigned long long t2;
    unsigned long long w[80];

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	bufferOop = stackObjectValue(1);
	if (!((isBytes(bufferOop))
		 && ((stSizeOf(bufferOop)) == 128))) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* TODO: there's no easy way to check whether doubleWordsOop is a DoubleWord object, so be creative here */
	hashOop = stackObjectValue(0);
	if (!((isWordsOrBytes(hashOop))
		 && (((stSizeOf(hashOop)) == 8)
		 && ((byteSizeOf(hashOop)) == 64)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	buffer = firstIndexableField(bufferOop);
	hash = firstIndexableField(hashOop);
	/* begin sha512ProcessBuffer:updatingHash: */
	/* begin sha512CopyAndExpandBuffer:into: */
	if (VMBIGENDIAN) {
		memcpy(((unsigned long *) w), ((unsigned long *) (((unsigned long long*) buffer))), 128);
	}
	else {
		for (i1 = 0; i1 < 16; i1 += 1) {
			(((unsigned long *) w))[i1] = (SQ_SWAP_8_BYTES(((((unsigned long *) (((unsigned long long*) buffer))))[i1])));
		}
	}
	for (i2 = 16; i2 <= 79; i2 += 1) {
		s01 = (((((w[i2 - 15])) >> 1) | ((w[i2 - 15]) << (0x3F))) ^ ((((w[i2 - 15])) >> 8) | ((w[i2 - 15]) << (56)))) ^ (((w[i2 - 15])) >> 7);
		s11 = (((((w[i2 - 2])) >> 19) | ((w[i2 - 2]) << (45))) ^ ((((w[i2 - 2])) >> 61) | ((w[i2 - 2]) << (3)))) ^ (((w[i2 - 2])) >> 6);
		w[i2] = (((s01 + s11) + (w[i2 - 16])) + (w[i2 - 7]));
	}
	a = hash[0];
	b = hash[1];
	c = hash[2];
	d = hash[3];
	e = hash[4];
	f = hash[5];
	g = hash[6];
	h = hash[7];
	for (i = 0; i <= 79; i += 1) {
		s0 = ((((a) >> 28) | (a << (36))) ^ (((a) >> 34) | (a << (30)))) ^ (((a) >> 39) | (a << (25)));

		/* optimized form of (a and b) xor (a and c) xor (b and c) */
		maj = ((a | b) & c) | (a & b);
		t2 = s0 + maj;
		s1 = ((((e) >> 14) | (e << (50))) ^ (((e) >> 18) | (e << (46)))) ^ (((e) >> 41) | (e << (23)));

		/* optimized form of (e and f) xor ((not e) and g) */
		ch = ((f ^ g) & e) ^ g;
		t1 = (((h + s1) + ch) + (sha512k[i])) + (w[i]);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}
	hash[0] = ((hash[0]) + a);
	hash[1] = ((hash[1]) + b);
	hash[2] = ((hash[2]) + c);
	hash[3] = ((hash[3]) + d);
	hash[4] = ((hash[4]) + e);
	hash[5] = ((hash[5]) + f);
	hash[6] = ((hash[6]) + g);
	hash[7] = ((hash[7]) + h);
	methodReturnReceiver();
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		byteSizeOf = interpreterProxy->byteSizeOf;
		firstIndexableField = interpreterProxy->firstIndexableField;
		isBytes = interpreterProxy->isBytes;
		isWords = interpreterProxy->isWords;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnBool = interpreterProxy->methodReturnBool;
		methodReturnReceiver = interpreterProxy->methodReturnReceiver;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		stSizeOf = interpreterProxy->stSizeOf;
		stackObjectValue = interpreterProxy->stackObjectValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "SHA2Plugin";
void* SHA2Plugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveCopyDoubleWordsIntoBytesBigEndian\000\001\001", (void*)primitiveCopyDoubleWordsIntoBytesBigEndian},
	{(void*)_m, "primitiveCopyWordsIntoBytesBigEndian\000\001\001", (void*)primitiveCopyWordsIntoBytesBigEndian},
	{(void*)_m, "primitiveIsPluginAvailable\000\377\001", (void*)primitiveIsPluginAvailable},
	{(void*)_m, "primitiveSHA256ProcessBufferUpdatingHash\000\001\001", (void*)primitiveSHA256ProcessBufferUpdatingHash},
	{(void*)_m, "primitiveSHA512ProcessBufferUpdatingHash\000\001\001", (void*)primitiveSHA512ProcessBufferUpdatingHash},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveCopyDoubleWordsIntoBytesBigEndianMetadata = 0x101;
EXPORT(signed short) primitiveCopyWordsIntoBytesBigEndianMetadata = 0x101;
EXPORT(signed short) primitiveIsPluginAvailableMetadata = -255;
EXPORT(signed short) primitiveSHA256ProcessBufferUpdatingHashMetadata = 0x101;
EXPORT(signed short) primitiveSHA512ProcessBufferUpdatingHashMetadata = 0x101;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
