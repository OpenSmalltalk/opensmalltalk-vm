/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
   from
	KlattSynthesizerPlugin VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
 */
static char __buildInfo[] = "KlattSynthesizerPlugin VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Constants ***/
#define A1v 46
#define A2f 34
#define A2v 47
#define A3f 35
#define A3v 48
#define A4f 36
#define A4v 49
#define A5f 37
#define A6f 38
#define Anv 45
#define Aspiration 9
#define Atv 50
#define B1 13
#define B2 17
#define B2f 40
#define B3 19
#define B3f 41
#define B4 21
#define B4f 42
#define B5 23
#define B5f 43
#define B6 25
#define B6f 44
#define Bnp 27
#define Bnz 29
#define Btp 31
#define Btz 33
#define Bypass 39
#define Diplophonia 4
#define Epsilon 0.0001
#define F0 0
#define F1 12
#define F2 16
#define F3 18
#define F4 20
#define F5 22
#define F6 24
#define Flutter 1
#define Fnp 26
#define Fnz 28
#define Friction 10
#define Ftp 30
#define Ftz 32
#define Gain 51
#define Jitter 2
#define PI 3.141592653589793
#define R1c 12
#define R1vp 3
#define R2c 13
#define R2fp 7
#define R2vp 4
#define R3c 14
#define R3fp 8
#define R3vp 5
#define R4c 15
#define R4fp 9
#define R4vp 6
#define R5c 16
#define R5fp 10
#define R6c 17
#define R6fp 11
#define R7c 18
#define R8c 19
#define Ra 7
#define Rk 8
#define Rnpc 20
#define Rnpp 1
#define Rnz 21
#define Ro 6
#define Rout 24
#define Rtpc 22
#define Rtpp 2
#define Rtz 23
#define Shimmer 3
#define Turbulence 11
#define Voicing 5


/*** Function Prototypes ***/
static void antiResonatorfrequencybandwidth(sqInt index, float freq, float bw);
EXPORT(const char*) getModuleName(void);
static float linearFromdB(double aNumber);
static sqInt loadFrom(sqInt klattOop);
static sqInt nextRandom(void);
static float parallelFrictionBranch(float source);
static float parallelVoicedBranch(float source);
EXPORT(sqInt) primitiveSynthesizeFrameIntoStartingAt(void);
static float resonatorA(sqInt index);
static float resonatorB(sqInt index);
static float resonatorC(sqInt index);
static float resonatorP1(sqInt index);
static float resonatorP2(sqInt index);
static void resonatorfrequencybandwidth(sqInt index, float freq, float bw);
static float resonatorvalue(sqInt index, float aFloat);
static sqInt saveTo(sqInt origKlattOop);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);


/*** Variables ***/
static sqInt cascade;
static float * frame;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*failed)(void);
static double (*fetchFloatofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*floatObjectOf)(double aFloat);
static sqInt (*isWords)(sqInt oop);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popRemappableOop)(void);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*success)(sqInt aBoolean);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt failed(void);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern sqInt isWords(sqInt oop);
extern sqInt pop(sqInt nItems);
extern sqInt popRemappableOop(void);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt success(sqInt aBoolean);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "Klatt VMMaker.oscog-eem.3456 " INT_EXT;
static sqInt nmod;
static sqInt nopen;
static sqInt nper;
static sqInt periodCount;
static float * resonators;
static sqInt samplesCount;
static sqInt samplesPerFrame;
static sqInt samplingRate;
static sqInt seed;
static sqInt t0;
static float a1;
static float a2;
static float b1;
static float c1;
static float glast;
static float nlast;
static float pitch;
static float vlast;
static float x1;
static float x2;


/*** Methods ***/


/*	Set up an anti-resonator */

	/* KlattSynthesizerPlugin>>#antiResonator:frequency:bandwidth: */
static void
antiResonatorfrequencybandwidth(sqInt index, float freq, float bw)
{
    float a;
    double arg;
    float b;
    float c;
    float r;

	arg = ((0.0 - PI) / samplingRate) * bw;
	r = exp(arg);
	c = 0.0 - (r * r);
	arg = ((PI * 2.0) / samplingRate) * freq;
	b = (r * (cos(arg))) * 2.0;
	a = (1.0 - b) - c;
	a = 1.0 / a;
	b = (0.0 - b) * a;
	c = (0.0 - c) * a;

	/* begin resonatorA:put: */
	resonators[(index * 5) - 5] = a;
	resonators[(index * 5) - 4] = b;
	resonators[(index * 5) - 3] = c;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* KlattSynthesizerPlugin>>#linearFromdB: */
static float
linearFromdB(double aNumber)
{
	return (pow(2.0,((aNumber - 87.0) / 6.0))) * 32.767;
}

	/* KlattSynthesizerPlugin>>#loadFrom: */
static sqInt
loadFrom(sqInt klattOop)
{
    sqInt oop;

	success((slotSizeOf(klattOop)) == 22);
	if (failed()) {
		return 0;
	}
	oop = fetchPointerofObject(0, klattOop);

	/* begin checkedFloatPtrOf: */
	success(isWords(oop));
	if (failed()) {
		resonators = 0;
		goto l1;
	}
	resonators = firstIndexableField(oop);
l1:	/* end checkedFloatPtrOf: */;
	pitch = fetchFloatofObject(2, klattOop);
	t0 = fetchIntegerofObject(3, klattOop);
	nper = fetchIntegerofObject(4, klattOop);
	nopen = fetchIntegerofObject(5, klattOop);
	nmod = fetchIntegerofObject(6, klattOop);
	a1 = fetchFloatofObject(7, klattOop);
	a2 = fetchFloatofObject(8, klattOop);
	x1 = fetchFloatofObject(9, klattOop);
	x2 = fetchFloatofObject(10, klattOop);
	b1 = fetchFloatofObject(11, klattOop);
	c1 = fetchFloatofObject(12, klattOop);
	glast = fetchFloatofObject(13, klattOop);
	vlast = fetchFloatofObject(14, klattOop);
	nlast = fetchFloatofObject(15, klattOop);
	periodCount = fetchIntegerofObject(16, klattOop);
	samplesCount = fetchIntegerofObject(17, klattOop);
	seed = fetchIntegerofObject(18, klattOop);
	cascade = fetchIntegerofObject(19, klattOop);
	samplesPerFrame = fetchIntegerofObject(20, klattOop);
	samplingRate = fetchIntegerofObject(21, klattOop);
	return (failed()) == 0;
}


/*	Answer a random number between 0 and 65535. */

	/* KlattSynthesizerPlugin>>#nextRandom */
static sqInt
nextRandom(void)
{
	seed = ((seed * 1309) + 13849) & 0xFFFF;
	return seed;
}


/*	Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,
	outputs added with alternating sign. Sound source for other
	parallel resonators is friction plus first difference of
	voicing waveform. */

	/* KlattSynthesizerPlugin>>#parallelFrictionBranch: */
static float
parallelFrictionBranch(float source)
{
	return ((((resonatorvalue(R2fp, source)) - (resonatorvalue(R3fp, source))) + (resonatorvalue(R4fp, source))) - (resonatorvalue(R5fp, source))) + (resonatorvalue(R6fp, source));
}


/*	Voice-excited parallel vocal tract F1, F2, F3, F4, FNP and FTP. */

	/* KlattSynthesizerPlugin>>#parallelVoicedBranch: */
static float
parallelVoicedBranch(float source)
{
	return (((((resonatorvalue(R1vp, source)) + (resonatorvalue(R2vp, source))) + (resonatorvalue(R3vp, source))) + (resonatorvalue(R4vp, source))) + (resonatorvalue(Rnpp, source))) + (resonatorvalue(Rtpp, source));
}

	/* KlattSynthesizerPlugin>>#primitiveSynthesizeFrameIntoStartingAt */
EXPORT(sqInt)
primitiveSynthesizeFrameIntoStartingAt(void)
{
    float aFloat;
    float aFloatFloat;
    float *aKlattFrame;
    float ampF1V;
    float ampF2F;
    float ampF2V;
    float ampF3F;
    float ampF3V;
    float ampF4F;
    float ampF4V;
    float ampF5F;
    float ampF6F;
    float ampFNV;
    float ampFTV;
    float ampGain;
    float answer;
    double answerDouble;
    float answerFloat;
    float asin;
    float aspiration;
    float aspirationNoise;
    float bsin;
    short *buffer;
    sqInt bufferOop;
    float bw;
    float bypass;
    float cosphi;
    float csin;
    float d;
    double deltaF0;
    float expuphi;
    float friction;
    float frictionNoise;
    float gain;
    float gamma;
    float gammapwr;
    float glotout;
    sqInt index;
    sqInt ingore;
    float noise;
    sqInt oop;
    float out;
    float outFloat;
    float p1;
    double p1Double;
    float p1Float;
    float parGlotout;
    float parVoicing;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    sqInt rcvr;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    float source;
    sqInt startIndex;
    sqInt te;
    sqInt temp;
    float theta;
    float timeCount;
    sqInt top;
    float turbulence;
    float u;
    float ua;
    float ub;
    float uc;
    float voice;
    float voicing;
    float x0;

	oop = stackValue(2);

	/* begin checkedFloatPtrOf: */
	success(isWords(oop));
	if (failed()) {
		aKlattFrame = 0;
		goto l1;
	}
	aKlattFrame = firstIndexableField(oop);
l1:	/* end checkedFloatPtrOf: */;
	oop = (bufferOop = stackValue(1));

	/* begin checkedShortPtrOf: */
	success(isWords(oop));
	if (failed()) {
		buffer = 0;
		goto l2;
	}
	buffer = firstIndexableField(oop);
l2:	/* end checkedShortPtrOf: */;
	startIndex = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	rcvr = stackObjectValue(3);
	if (!(loadFrom(rcvr))) {
		return null;
	}
	success(((stSizeOf(bufferOop)) * 2) >= samplesPerFrame);
	if (failed()) {
		return null;
	}

	/* begin synthesizeFrame:into:startingAt: */
	/* begin setCurrentFrame: */
	/* Fudge factors... */
	frame = aKlattFrame;

	/* -4.44 dB */
	ampFNV = (linearFromdB(frame[Anv])) * 0.6;

	/* -4.44 dB */
	ampFTV = (linearFromdB(frame[Atv])) * 0.6;

	/* -7.96 dB */
	ampF1V = (linearFromdB(frame[A1v])) * 0.4;

	/* -16.5 dB */
	ampF2V = (linearFromdB(frame[A2v])) * 0.15;

	/* -24.4 dB */
	ampF3V = (linearFromdB(frame[A3v])) * 0.06;

	/* -28.0 dB */
	ampF4V = (linearFromdB(frame[A4v])) * 0.04;

	/* -16.5 dB */
	ampF2F = (linearFromdB(frame[A2f])) * 0.15;

	/* -24.4 dB */
	ampF3F = (linearFromdB(frame[A3f])) * 0.06;

	/* -28.0 dB */
	ampF4F = (linearFromdB(frame[A4f])) * 0.04;

	/* -33.2 dB */
	ampF5F = (linearFromdB(frame[A5f])) * 0.022;

	/* -30.5 dB */
	/* Set coefficients of variable cascade resonators */
	ampF6F = (linearFromdB(frame[A6f])) * 0.03;
	if (cascade >= 8) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R8c, 7500, 600);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 7) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R7c, 6500, 500);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 6) {
		resonatorfrequencybandwidth(R6c, frame[F6], frame[B6]);
	}
	if (cascade >= 5) {
		resonatorfrequencybandwidth(R5c, frame[F5], frame[B5]);
	}
	resonatorfrequencybandwidth(R4c, frame[F4], frame[B4]);
	resonatorfrequencybandwidth(R3c, frame[F3], frame[B3]);
	resonatorfrequencybandwidth(R2c, frame[F2], frame[B2]);
	resonatorfrequencybandwidth(R1c, frame[F1], frame[B1]);
	resonatorfrequencybandwidth(Rnpc, frame[Fnp], frame[Bnp]);
	resonatorfrequencybandwidth(Rtpc, frame[Ftp], frame[Btp]);
	antiResonatorfrequencybandwidth(Rnz, frame[Fnz], frame[Bnz]);
	antiResonatorfrequencybandwidth(Rtz, frame[Ftz], frame[Btz]);

	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rnpp, frame[Fnp], frame[Bnp]);
	aFloat = (resonatorA(Rnpp)) * ampFNV;

	/* begin resonatorA:put: */
	resonators[0 /* ((Rnpp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(Rtpp, frame[Ftp], frame[Btp]);
	aFloat = (resonatorA(Rtpp)) * ampFTV;

	/* begin resonatorA:put: */
	resonators[5 /* ((Rtpp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R1vp, frame[F1], frame[B1]);
	aFloat = (resonatorA(R1vp)) * ampF1V;

	/* begin resonatorA:put: */
	resonators[10 /* ((R1vp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R2vp, frame[F2], frame[B2]);
	aFloat = (resonatorA(R2vp)) * ampF2V;

	/* begin resonatorA:put: */
	resonators[15 /* ((R2vp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R3vp, frame[F3], frame[B3]);
	aFloat = (resonatorA(R3vp)) * ampF3V;

	/* begin resonatorA:put: */
	resonators[20 /* ((R3vp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R4vp, frame[F4], frame[B4]);
	aFloat = (resonatorA(R4vp)) * ampF4V;

	/* begin resonatorA:put: */
	resonators[25 /* ((R4vp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R2fp, frame[F2], frame[B2f]);
	aFloat = (resonatorA(R2fp)) * ampF2F;

	/* begin resonatorA:put: */
	resonators[30 /* ((R2fp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R3fp, frame[F3], frame[B3f]);
	aFloat = (resonatorA(R3fp)) * ampF3F;

	/* begin resonatorA:put: */
	resonators[35 /* ((R3fp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R4fp, frame[F4], frame[B4f]);
	aFloat = (resonatorA(R4fp)) * ampF4F;

	/* begin resonatorA:put: */
	resonators[40 /* ((R4fp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R5fp, frame[F5], frame[B5f]);
	aFloat = (resonatorA(R5fp)) * ampF5F;

	/* begin resonatorA:put: */
	resonators[45 /* ((R5fp * 5) - 5) */] = aFloat;
	resonatorfrequencybandwidth(R6fp, frame[F6], frame[B6f]);
	aFloat = (resonatorA(R6fp)) * ampF6F;

	/* begin resonatorA:put: */
	resonators[50 /* ((R6fp * 5) - 5) */] = aFloat;
	if (pitch > 0) {
		/* begin linearFromdB: */
		voicing = (pow(2.0,((((frame[Voicing]) - 7) - 87.0) / 6.0))) * 32.767;
		parVoicing = (pow(2.0,(((frame[Voicing]) - 87.0) / 6.0))) * 32.767;
		turbulence = (linearFromdB(frame[Turbulence])) * 0.1;
	}
	else {
		voicing = (parVoicing = (turbulence = 0.0));
	}
	friction = (linearFromdB(frame[Friction])) * 0.25;
	aspiration = (linearFromdB(frame[Aspiration])) * 0.05;

	/* -26.0 dB */
	/* Flod overall gain into output resonator (low-pass filter) */
	bypass = (linearFromdB(frame[Bypass])) * 0.05;
	gain = (frame[Gain]) - 3;
	if (gain <= 0) {
		gain = 57;
	}

	/* begin linearFromdB: */
	ampGain = (pow(2.0,((gain - 87.0) / 6.0))) * 32.767;
	bw = samplingRate;

	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rout, 0, bw);
	aFloat = (resonatorA(Rout)) * ampGain;

	/* begin resonatorA:put: */
	resonators[115 /* ((Rout * 5) - 5) */] = aFloat;
	noise = nlast;
	index = startIndex;
	top = (samplesPerFrame + startIndex) - 1;
	while (index <= top) {

		/* Get low-passed random number for aspiration and friction noise */
		/* radom number between -8196.0 and 8196.0 */
		/* Tilt down noise spectrum by soft low-pass filter having
		   a pole near the origin in the z-plane. */
		noise = (((double) ((nextRandom()) - 0x8000) )) / 4.0;
		noise += 0.75 * nlast;

		/* Amplitude modulate noise (reduce noise amplitude during second
		   half of glottal period) if voicing  simultaneously present. */
		nlast = noise;
		if (nper > nmod) {
			noise = noise * 0.5;
		}

		/* Compute voicing waveform. */
		frictionNoise = friction * noise;

		/* begin glottalSource */
		if (!t0) {
			voice = 0;
			goto l4;
		}
		if (nper < nopen) {
			x0 = (a1 * x1) + (a2 * x2);
			x2 = x1;
			x1 = x0;
		}
		else {
			x0 = (b1 * x1) - c1;
			x1 = x0;
		}
		if (nper >= t0) {
			nper = 0;

			/* begin pitchSynchronousReset */
			if ((frame[F0]) > 0) {
				/* begin voicedPitchSynchronousReset */
				/* Add flutter and jitter (F0 perturbations). */
				pitch = frame[F0];
				timeCount = (((float) samplesCount)) / (((float) samplingRate));
				asin = sin(((2.0 * PI) * 12.7) * timeCount);
				bsin = sin(((2.0 * PI) * 7.1) * timeCount);
				csin = sin(((2.0 * PI) * 4.7) * timeCount);
				deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
				pitch += deltaF0;

				/* begin addJitter */
				pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
				if (periodCount % 2) {
					pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
				}
				else {
					pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
				}
				if (pitch < 0) {
					pitch = 0;
				}

				/* Duration of period before amplitude modulation. */
				t0 = ((sqInt)(samplingRate / pitch));
				nmod = t0;
				if ((frame[Voicing]) > 0) {
					nmod = nmod / 2;
				}

				/* Set the LF glottal pulse model parameters. */
				nopen = ((sqInt)(t0 * (frame[Ro])));

				/* begin ro:ra:rk: */
				te = ((sqInt)(t0 * (frame[Ro])));
				ro = (((double) te )) / (((double) t0 ));
				rk = frame[Rk];
				ra = frame[Ra];
				if (ra <= 0.0) {
					d = 1.0;
				}
				else {
					r = (1.0 - ro) / ra;
					d = 1.0 - (r / ((exp(r)) - 1.0));
				}
				phi = PI * (rk + 1.0);
				cosphi = cos(phi);
				sinphi = sin(phi);
				rphid = ((ra / ro) * phi) * d;

				/* begin zeroQphi:cosphi:sinphi:rphid: */
				/* begin qu:phi:cosphi:sinphi:rphid: */
				expuphi = exp(0);
				qzero = (expuphi * ((((rphid)) * sinphi) - cosphi)) + 1.0;
				if (qzero > 0) {
					ua = 0;
					ub = 1;
					qa = qzero;

					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi = exp(ub * phi);
					qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
					while (qb > 0) {
						ua = ub;
						qa = qb;
						ub = ub * 2;

						/* begin qu:phi:cosphi:sinphi:rphid: */
						expuphi = exp(ub * phi);
						qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
					}
				}
				else {
					ua = -1;
					ub = 0;

					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi = exp(ua * phi);
					qa = (expuphi * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
					qb = qzero;
					while (qa < 0) {
						ub = ua;
						qb = qa;
						ua = ua * 2;

						/* begin qu:phi:cosphi:sinphi:rphid: */
						expuphi = exp(ua * phi);
						qa = (expuphi * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
					}
				}
				while ((ub - ua) > Epsilon) {
					uc = (ub + ua) / 2.0;

					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi = exp(uc * phi);
					qc = (expuphi * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
					if (qc > 0) {
						ua = uc;
						qa = qc;
					}
					else {
						ub = uc;
						qb = qc;
					}
				}
				u = (ub + ua) / 2.0;
				theta = phi / te;
				rho = exp(u * theta);
				a1 = (2.0 * (cos(theta))) * rho;
				a2 = 0.0 - (rho * rho);
				x2 = 0.0;
				x1 = rho * (sin(theta));
				gamma = exp(-1.0 / (ra * t0));
				gammapwr = pow(gamma,(t0 - te));
				b1 = gamma;
				c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);

				/* begin normalizeGlottalPulse */
				s0 = 0.0;
				s1 = x1;
				s2 = x2;
				for (ingore = 1; ingore <= nopen; ingore += 1) {
					s0 = (a1 * s1) + (a2 * s2);
					s2 = s1;
					s1 = s0;
				}
				if (!(s0 == 0.0)) {
					x1 = (x1 / s0) * 10000.0;
				}

				/* begin addShimmer */
				/* x1 must be <= 0 */
				x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
				if (x1 > 0) {
					x1 = 0;
				}

				/* begin addAmplitudeDiplophonia */
				if (periodCount % 2) {
					/* x1 must be <= 0 */
					x1 = x1 * (1.0 - (frame[Diplophonia]));
					if (x1 > 0) {
						x1 = 0;
					}
				}
				periodCount = (periodCount + 1) % 0xFFFF;
			}
			else {
				t0 = 1;
				nmod = t0;
			}
		}
		nper += 1;
		voice = x0;
l4:	/* end glottalSource */;

		/* Add turbulence during glottal open phase.
		   Use random rather than noise because noise is low-passed. */
		vlast = voice;
		if (nper < nopen) {
			voice += (turbulence * (((double) ((nextRandom()) - 0x8000) ))) / 4.0;
		}
		glotout = voicing * voice;

		/* Compute aspiration amplitude and add to voicing source. */
		parGlotout = parVoicing * voice;
		aspirationNoise = aspiration * noise;
		glotout += aspirationNoise;

		/* Cascade vocal tract, excited by laryngeal sources.
		   Nasal antiresonator, nasal resonator, trachearl antirresonator,
		   tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1. */
		parGlotout += aspirationNoise;

		/* begin cascadeBranch: */
		if (!(cascade > 0)) {
			out = 0.0;
			goto l3;
		}

		/* begin antiResonator:value: */
		answerDouble = (((resonatorA(Rnz)) * glotout) + ((resonatorB(Rnz)) * ((p1Double = resonatorP1(Rnz))))) + ((resonatorC(Rnz)) * (resonatorP2(Rnz)));
		aFloatFloat = p1Double;

		/* begin resonatorP2:put: */
		resonators[104 /* ((Rnz * 5) - 1) */] = aFloatFloat;
		aFloatFloat = glotout;

		/* begin resonatorP1:put: */
		resonators[103 /* ((Rnz * 5) - 2) */] = aFloatFloat;
		outFloat = answerDouble;

		/* begin resonator:value: */
		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answerFloat = (((resonatorA(Rnpc)) * outFloat) + ((resonatorB(Rnpc)) * ((p1Float = resonatorP1(Rnpc))))) + ((resonatorC(Rnpc)) * (resonatorP2(Rnpc)));
		resonators[99 /* ((Rnpc * 5) - 1) */] = p1Float;
		resonators[98 /* ((Rnpc * 5) - 2) */] = answerFloat;
		outFloat = answerFloat;

		/* begin antiResonator:value: */
		answerDouble = (((resonatorA(Rtz)) * outFloat) + ((resonatorB(Rtz)) * ((p1Double = resonatorP1(Rtz))))) + ((resonatorC(Rtz)) * (resonatorP2(Rtz)));
		aFloatFloat = p1Double;

		/* begin resonatorP2:put: */
		resonators[114 /* ((Rtz * 5) - 1) */] = aFloatFloat;
		aFloatFloat = outFloat;

		/* begin resonatorP1:put: */
		resonators[113 /* ((Rtz * 5) - 2) */] = aFloatFloat;
		outFloat = answerDouble;

		/* begin resonator:value: */
		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answerFloat = (((resonatorA(Rtpc)) * outFloat) + ((resonatorB(Rtpc)) * ((p1Float = resonatorP1(Rtpc))))) + ((resonatorC(Rtpc)) * (resonatorP2(Rtpc)));
		resonators[109 /* ((Rtpc * 5) - 1) */] = p1Float;
		resonators[108 /* ((Rtpc * 5) - 2) */] = answerFloat;
		outFloat = answerFloat;
		if (cascade >= 8) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R8c)) * outFloat) + ((resonatorB(R8c)) * ((p1Float = resonatorP1(R8c))))) + ((resonatorC(R8c)) * (resonatorP2(R8c)));
			resonators[94 /* ((R8c * 5) - 1) */] = p1Float;
			resonators[93 /* ((R8c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 7) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R7c)) * outFloat) + ((resonatorB(R7c)) * ((p1Float = resonatorP1(R7c))))) + ((resonatorC(R7c)) * (resonatorP2(R7c)));
			resonators[89 /* ((R7c * 5) - 1) */] = p1Float;
			resonators[88 /* ((R7c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 6) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R6c)) * outFloat) + ((resonatorB(R6c)) * ((p1Float = resonatorP1(R6c))))) + ((resonatorC(R6c)) * (resonatorP2(R6c)));
			resonators[84 /* ((R6c * 5) - 1) */] = p1Float;
			resonators[83 /* ((R6c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 5) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R5c)) * outFloat) + ((resonatorB(R5c)) * ((p1Float = resonatorP1(R5c))))) + ((resonatorC(R5c)) * (resonatorP2(R5c)));
			resonators[79 /* ((R5c * 5) - 1) */] = p1Float;
			resonators[78 /* ((R5c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 4) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R4c)) * outFloat) + ((resonatorB(R4c)) * ((p1Float = resonatorP1(R4c))))) + ((resonatorC(R4c)) * (resonatorP2(R4c)));
			resonators[74 /* ((R4c * 5) - 1) */] = p1Float;
			resonators[73 /* ((R4c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 3) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R3c)) * outFloat) + ((resonatorB(R3c)) * ((p1Float = resonatorP1(R3c))))) + ((resonatorC(R3c)) * (resonatorP2(R3c)));
			resonators[69 /* ((R3c * 5) - 1) */] = p1Float;
			resonators[68 /* ((R3c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 2) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R2c)) * outFloat) + ((resonatorB(R2c)) * ((p1Float = resonatorP1(R2c))))) + ((resonatorC(R2c)) * (resonatorP2(R2c)));
			resonators[64 /* ((R2c * 5) - 1) */] = p1Float;
			resonators[0x3F /* ((R2c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		if (cascade >= 1) {
			/* begin resonator:value: */
			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answerFloat = (((resonatorA(R1c)) * outFloat) + ((resonatorB(R1c)) * ((p1Float = resonatorP1(R1c))))) + ((resonatorC(R1c)) * (resonatorP2(R1c)));
			resonators[59 /* ((R1c * 5) - 1) */] = p1Float;
			resonators[58 /* ((R1c * 5) - 2) */] = answerFloat;
			outFloat = answerFloat;
		}
		out = outFloat;
l3:	/* end cascadeBranch: */;

		/* Source is voicing plus aspiration. */
		source = parGlotout;

		/* Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,
		   outputs added with alternating sign. Sound source for other
		   parallel resonators is friction plus first difference of
		   voicing waveform. */
		out += parallelVoicedBranch(source);
		source = (frictionNoise + parGlotout) - glast;
		glast = parGlotout;

		/* Apply bypas and output low-pass filter */
		out = (parallelFrictionBranch(source)) - out;
		out = (bypass * source) - out;

		/* begin resonator:value: */
		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer = (((resonatorA(Rout)) * out) + ((resonatorB(Rout)) * ((p1 = resonatorP1(Rout))))) + ((resonatorC(Rout)) * (resonatorP2(Rout)));
		resonators[119 /* ((Rout * 5) - 1) */] = p1;
		resonators[118 /* ((Rout * 5) - 2) */] = answer;
		out = answer;
		temp = ((sqInt)(out * ampGain));
		if (temp < -32768) {
			temp = -32768;
		}
		if (temp > 0x7FFF) {
			temp = 0x7FFF;
		}
		buffer[index - 1] = temp;
		index += 1;
		samplesCount += 1;
	}
	if (!(saveTo(rcvr))) {
		return null;
	}
	pop(3);
	return 0;
}

	/* KlattSynthesizerPlugin>>#resonatorA: */
static float
resonatorA(sqInt index)
{
	return resonators[(index * 5) - 5];
}

	/* KlattSynthesizerPlugin>>#resonatorB: */
static float
resonatorB(sqInt index)
{
	return resonators[(index * 5) - 4];
}

	/* KlattSynthesizerPlugin>>#resonatorC: */
static float
resonatorC(sqInt index)
{
	return resonators[(index * 5) - 3];
}

	/* KlattSynthesizerPlugin>>#resonatorP1: */
static float
resonatorP1(sqInt index)
{
	return resonators[(index * 5) - 2];
}

	/* KlattSynthesizerPlugin>>#resonatorP2: */
static float
resonatorP2(sqInt index)
{
	return resonators[(index * 5) - 1];
}


/*	Convert formant frequencies and bandwidth into
	resonator difference equation coefficients. */

	/* KlattSynthesizerPlugin>>#resonator:frequency:bandwidth: */
static void
resonatorfrequencybandwidth(sqInt index, float freq, float bw)
{
    float a;
    double arg;
    float b;
    float c;
    float r;

	arg = ((0.0 - PI) / samplingRate) * bw;
	r = exp(arg);
	c = 0.0 - (r * r);
	arg = ((PI * 2.0) / samplingRate) * freq;
	b = (r * (cos(arg))) * 2.0;
	a = (1.0 - b) - c;

	/* begin resonatorA:put: */
	resonators[(index * 5) - 5] = a;
	resonators[(index * 5) - 4] = b;
	resonators[(index * 5) - 3] = c;
}

	/* KlattSynthesizerPlugin>>#resonator:value: */
static float
resonatorvalue(sqInt index, float aFloat)
{
    float answer;
    float p1;

	/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
	   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
	answer = (((resonatorA(index)) * aFloat) + ((resonatorB(index)) * ((p1 = resonatorP1(index))))) + ((resonatorC(index)) * (resonatorP2(index)));

	/* begin resonatorP2:put: */
	resonators[(index * 5) - 1] = p1;
	resonators[(index * 5) - 2] = answer;
	return answer;
}

	/* KlattSynthesizerPlugin>>#saveTo: */
static sqInt
saveTo(sqInt origKlattOop)
{
    sqInt a1Oop;
    sqInt a2Oop;
    sqInt b1Oop;
    sqInt c1Oop;
    sqInt glastOop;
    sqInt klattOop;
    sqInt nlastOop;
    sqInt pitchOop;
    sqInt vlastOop;
    sqInt x1Oop;
    sqInt x2Oop;

	pushRemappableOop(origKlattOop);
	pushRemappableOop(floatObjectOf(pitch));
	pushRemappableOop(floatObjectOf(a1));
	pushRemappableOop(floatObjectOf(a2));
	pushRemappableOop(floatObjectOf(x1));
	pushRemappableOop(floatObjectOf(x2));
	pushRemappableOop(floatObjectOf(b1));
	pushRemappableOop(floatObjectOf(c1));
	pushRemappableOop(floatObjectOf(glast));
	pushRemappableOop(floatObjectOf(vlast));
	nlastOop = floatObjectOf(nlast);
	vlastOop = popRemappableOop();
	glastOop = popRemappableOop();
	c1Oop = popRemappableOop();
	b1Oop = popRemappableOop();
	x2Oop = popRemappableOop();
	x1Oop = popRemappableOop();
	a2Oop = popRemappableOop();
	a1Oop = popRemappableOop();
	pitchOop = popRemappableOop();
	klattOop = popRemappableOop();
	if (failed()) {
		return 0;
	}
	storePointerofObjectwithValue(2, klattOop, pitchOop);
	storeIntegerofObjectwithValue(3, klattOop, t0);
	storeIntegerofObjectwithValue(4, klattOop, nper);
	storeIntegerofObjectwithValue(5, klattOop, nopen);
	storeIntegerofObjectwithValue(6, klattOop, nmod);
	storePointerofObjectwithValue(7, klattOop, a1Oop);
	storePointerofObjectwithValue(8, klattOop, a2Oop);
	storePointerofObjectwithValue(9, klattOop, x1Oop);
	storePointerofObjectwithValue(10, klattOop, x2Oop);
	storePointerofObjectwithValue(11, klattOop, b1Oop);
	storePointerofObjectwithValue(12, klattOop, c1Oop);
	storePointerofObjectwithValue(13, klattOop, glastOop);
	storePointerofObjectwithValue(14, klattOop, vlastOop);
	storePointerofObjectwithValue(15, klattOop, nlastOop);
	storeIntegerofObjectwithValue(16, klattOop, periodCount);
	storeIntegerofObjectwithValue(17, klattOop, samplesCount);
	storeIntegerofObjectwithValue(18, klattOop, seed);
	return (failed()) == 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
		 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		failed = interpreterProxy->failed;
		fetchFloatofObject = interpreterProxy->fetchFloatofObject;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatObjectOf = interpreterProxy->floatObjectOf;
		isWords = interpreterProxy->isWords;
		pop = interpreterProxy->pop;
		popRemappableOop = interpreterProxy->popRemappableOop;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		success = interpreterProxy->success;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

/*** Exports ***/

#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "Klatt";
void* Klatt_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveSynthesizeFrameIntoStartingAt\000\001\000", (void*)primitiveSynthesizeFrameIntoStartingAt},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveSynthesizeFrameIntoStartingAtMetadata = 0x100;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
