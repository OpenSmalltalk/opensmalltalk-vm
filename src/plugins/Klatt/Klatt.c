/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
   from
	KlattSynthesizerPlugin VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1
 */
static char __buildInfo[] = "KlattSynthesizerPlugin VMMaker.oscog-eem.2480 uuid: bb3ffda7-8241-4dea-b886-d656e474b6c1 " __DATE__ ;



#include "config.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define A1v 46
#define A2f 34
#define A2v 47
#define A3f 35
#define A3v 48
#define A4f 36
#define A4v 49
#define A5f 37
#define A6f 38
#define Anv 45
#define Aspiration 9
#define Atv 50
#define B1 13
#define B2 17
#define B2f 40
#define B3 19
#define B3f 41
#define B4 21
#define B4f 42
#define B5 23
#define B5f 43
#define B6 25
#define B6f 44
#define Bnp 27
#define Bnz 29
#define Btp 31
#define Btz 33
#define Bypass 39
#define Diplophonia 4
#define Epsilon 0.0001
#define F0 0
#define F1 12
#define F2 16
#define F3 18
#define F4 20
#define F5 22
#define F6 24
#define Flutter 1
#define Fnp 26
#define Fnz 28
#define Friction 10
#define Ftp 30
#define Ftz 32
#define Gain 51
#define Jitter 2
#define PI 3.141592653589793
#define R1c 12
#define R1vp 3
#define R2c 13
#define R2fp 7
#define R2vp 4
#define R3c 14
#define R3fp 8
#define R3vp 5
#define R4c 15
#define R4fp 9
#define R4vp 6
#define R5c 16
#define R5fp 10
#define R6c 17
#define R6fp 11
#define R7c 18
#define R8c 19
#define Ra 7
#define Rk 8
#define Rnpc 20
#define Rnpp 1
#define Rnz 21
#define Ro 6
#define Rout 24
#define Rtpc 22
#define Rtpp 2
#define Rtz 23
#define Shimmer 3
#define Turbulence 11
#define Voicing 5


/*** Function Prototypes ***/
static void addAmplitudeDiplophonia(void);
static void addFlutter(void);
static void addFrequencyDiplophonia(void);
static void addJitter(void);
static void addShimmer(void);
static void antiResonatorfrequencybandwidth(sqInt index, float freq, float bw);
static float antiResonatorvalue(sqInt index, double aFloat);
static float cascadeBranch(float source);
static float * checkedFloatPtrOf(sqInt oop);
static short * checkedShortPtrOf(sqInt oop);
EXPORT(const char*) getModuleName(void);
static float glottalSource(void);
static float linearFromdB(double aNumber);
static sqInt loadFrom(sqInt klattOop);
static sqInt nextRandom(void);
static void normalizeGlottalPulse(void);
static float parallelFrictionBranch(float source);
static float parallelVoicedBranch(float source);
static void pitchSynchronousReset(void);
EXPORT(sqInt) primitiveSynthesizeFrameIntoStartingAt(void);
static float quphicosphisinphirphid(float u, float phi, float cosphi, float sinphi, float rphid);
static float resonatorA(sqInt index);
static void resonatorAput(sqInt index, float aFloat);
static float resonatorB(sqInt index);
static void resonatorBput(sqInt index, float aFloat);
static float resonatorC(sqInt index);
static void resonatorCput(sqInt index, float aFloat);
static float resonatorP1(sqInt index);
static void resonatorP1put(sqInt index, float aFloat);
static float resonatorP2(sqInt index);
static void resonatorP2put(sqInt index, float aFloat);
static void resonatorfrequencybandwidth(sqInt index, float freq, float bw);
static void resonatorfrequencybandwidthgain(sqInt index, float freq, float bw, float gain);
static float resonatorvalue(sqInt index, float aFloat);
static void rorark(float roNumber, float raNumber, float rkNumber);
static sqInt saveTo(sqInt origKlattOop);
static void setCurrentFrame(float *aKlattFrame);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static void synthesizeFrameintostartingAt(float *aKlattFrame, short *buffer, sqInt startIndex);
static void voicedPitchSynchronousReset(void);
static float zeroQphicosphisinphirphid(float phi, float cosphi, float sinphi, float rphid);


/*** Variables ***/
static float a1;
static float a2;
static float b1;
static float c1;
static sqInt cascade;
static float * frame;
static float glast;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*failed)(void);
static double (*fetchFloatofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*floatObjectOf)(double aFloat);
static sqInt (*isWords)(sqInt oop);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popRemappableOop)(void);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storeIntegerofObjectwithValue)(sqInt index, sqInt oop, sqInt integer);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*success)(sqInt aBoolean);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt failed(void);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern sqInt isWords(sqInt oop);
extern sqInt pop(sqInt nItems);
extern sqInt popRemappableOop(void);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storeIntegerofObjectwithValue(sqInt index, sqInt oop, sqInt integer);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt success(sqInt aBoolean);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"Klatt VMMaker.oscog-eem.2480 (i)"
#else
	"Klatt VMMaker.oscog-eem.2480 (e)"
#endif
;
static float nlast;
static sqInt nmod;
static sqInt nopen;
static sqInt nper;
static sqInt periodCount;
static float pitch;
static float * resonators;
static sqInt samplesCount;
static sqInt samplesPerFrame;
static sqInt samplingRate;
static sqInt seed;
static sqInt t0;
static float vlast;
static float x1;
static float x2;



/*	Add diplophonia (bicyclic voice). Change voicing amplitude. */

	/* KlattSynthesizerPlugin>>#addAmplitudeDiplophonia */
static void
addAmplitudeDiplophonia(void)
{
	if (!((periodCount % 2) == 0)) {

		/* x1 must be <= 0 */
		x1 = x1 * (1.0 - (frame[Diplophonia]));
		if (x1 > 0) {
			x1 = 0;
		}
	}
}


/*	Add F0 flutter, as specified in:
	'Analysis, synthesis and perception of voice quality variations among
	female and male talkers' D.H. Klatt and L.C. Klatt JASA 87(2) February
	1990. Flutter is added by applying a quasi-random element constructed from
	three slowly varying sine waves. */

	/* KlattSynthesizerPlugin>>#addFlutter */
static void
addFlutter(void)
{
    float asin;
    float bsin;
    float csin;
    double deltaF0;
    float timeCount;

	timeCount = (((float) samplesCount)) / (((float) samplingRate));
	asin = sin(((2.0 * PI) * 12.7) * timeCount);
	bsin = sin(((2.0 * PI) * 7.1) * timeCount);
	csin = sin(((2.0 * PI) * 4.7) * timeCount);
	deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
	pitch += deltaF0;
}


/*	Add diplophonia (bicyclic voice). Change F0. */

	/* KlattSynthesizerPlugin>>#addFrequencyDiplophonia */
static void
addFrequencyDiplophonia(void)
{
	if ((periodCount % 2) == 0) {
		pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
	}
	else {
		pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
	}
}


/*	Add jitter (random F0 perturbation). */

	/* KlattSynthesizerPlugin>>#addJitter */
static void
addJitter(void)
{
	pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
}


/*	Add shimmer (random voicing amplitude perturbation). */

	/* KlattSynthesizerPlugin>>#addShimmer */
static void
addShimmer(void)
{

	/* x1 must be <= 0 */
	x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
	if (x1 > 0) {
		x1 = 0;
	}
}


/*	Set up an anti-resonator */

	/* KlattSynthesizerPlugin>>#antiResonator:frequency:bandwidth: */
static void
antiResonatorfrequencybandwidth(sqInt index, float freq, float bw)
{
    float a;
    double arg;
    float b;
    float c;
    float r;

	arg = ((0.0 - PI) / samplingRate) * bw;
	r = exp(arg);
	c = 0.0 - (r * r);
	arg = ((PI * 2.0) / samplingRate) * freq;
	b = (r * (cos(arg))) * 2.0;
	a = (1.0 - b) - c;
	a = 1.0 / a;
	b = (0.0 - b) * a;
	c = (0.0 - c) * a;
	/* begin resonatorA:put: */
	resonators[(index * 5) - 5] = a;
	/* begin resonatorB:put: */
	resonators[(index * 5) - 4] = b;
	/* begin resonatorC:put: */
	resonators[(index * 5) - 3] = c;
}

	/* KlattSynthesizerPlugin>>#antiResonator:value: */
static float
antiResonatorvalue(sqInt index, double aFloat)
{
    double answer;
    double p1;

	answer = (((resonatorA(index)) * aFloat) + ((resonatorB(index)) * ((p1 = resonatorP1(index))))) + ((resonatorC(index)) * (resonatorP2(index)));
	/* begin resonatorP2:put: */
	resonators[(index * 5) - 1] = p1;
	/* begin resonatorP1:put: */
	resonators[(index * 5) - 2] = aFloat;
	return answer;
}


/*	Cascade vocal tract, excited by laryngeal sources.
	Nasal antiresonator, nasal resonator, tracheal antirresonator,
	tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1. */

	/* KlattSynthesizerPlugin>>#cascadeBranch: */
static float
cascadeBranch(float source)
{
    float answer;
    float answer1;
    double answer10;
    float answer11;
    float answer2;
    float answer3;
    float answer4;
    float answer5;
    float answer6;
    float answer7;
    double answer8;
    float answer9;
    float out;
    float p1;
    float p11;
    double p110;
    float p111;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    double p18;
    float p19;

	if (!(cascade > 0)) {
		return 0.0;
	}
	/* begin antiResonator:value: */
	answer8 = (((resonatorA(Rnz)) * source) + ((resonatorB(Rnz)) * ((p18 = resonatorP1(Rnz))))) + ((resonatorC(Rnz)) * (resonatorP2(Rnz)));
	/* begin resonatorP2:put: */
	resonators[(Rnz * 5) - 1] = p18;
	/* begin resonatorP1:put: */
	resonators[(Rnz * 5) - 2] = source;
	out = answer8;
	/* begin resonator:value: */

	/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
	   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
	answer9 = (((resonatorA(Rnpc)) * out) + ((resonatorB(Rnpc)) * ((p19 = resonatorP1(Rnpc))))) + ((resonatorC(Rnpc)) * (resonatorP2(Rnpc)));
	resonators[(Rnpc * 5) - 1] = p19;
	/* begin resonatorP1:put: */
	resonators[(Rnpc * 5) - 2] = answer9;
	out = answer9;
	/* begin antiResonator:value: */
	answer10 = (((resonatorA(Rtz)) * out) + ((resonatorB(Rtz)) * ((p110 = resonatorP1(Rtz))))) + ((resonatorC(Rtz)) * (resonatorP2(Rtz)));
	/* begin resonatorP2:put: */
	resonators[(Rtz * 5) - 1] = p110;
	/* begin resonatorP1:put: */
	resonators[(Rtz * 5) - 2] = out;
	out = answer10;
	/* begin resonator:value: */

	/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
	   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
	answer11 = (((resonatorA(Rtpc)) * out) + ((resonatorB(Rtpc)) * ((p111 = resonatorP1(Rtpc))))) + ((resonatorC(Rtpc)) * (resonatorP2(Rtpc)));
	resonators[(Rtpc * 5) - 1] = p111;
	/* begin resonatorP1:put: */
	resonators[(Rtpc * 5) - 2] = answer11;
	out = answer11;
	if (cascade >= 8) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer = (((resonatorA(R8c)) * out) + ((resonatorB(R8c)) * ((p1 = resonatorP1(R8c))))) + ((resonatorC(R8c)) * (resonatorP2(R8c)));
		resonators[(R8c * 5) - 1] = p1;
		/* begin resonatorP1:put: */
		resonators[(R8c * 5) - 2] = answer;
		out = answer;
	}
	if (cascade >= 7) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer1 = (((resonatorA(R7c)) * out) + ((resonatorB(R7c)) * ((p11 = resonatorP1(R7c))))) + ((resonatorC(R7c)) * (resonatorP2(R7c)));
		resonators[(R7c * 5) - 1] = p11;
		/* begin resonatorP1:put: */
		resonators[(R7c * 5) - 2] = answer1;
		out = answer1;
	}
	if (cascade >= 6) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer2 = (((resonatorA(R6c)) * out) + ((resonatorB(R6c)) * ((p12 = resonatorP1(R6c))))) + ((resonatorC(R6c)) * (resonatorP2(R6c)));
		resonators[(R6c * 5) - 1] = p12;
		/* begin resonatorP1:put: */
		resonators[(R6c * 5) - 2] = answer2;
		out = answer2;
	}
	if (cascade >= 5) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer3 = (((resonatorA(R5c)) * out) + ((resonatorB(R5c)) * ((p13 = resonatorP1(R5c))))) + ((resonatorC(R5c)) * (resonatorP2(R5c)));
		resonators[(R5c * 5) - 1] = p13;
		/* begin resonatorP1:put: */
		resonators[(R5c * 5) - 2] = answer3;
		out = answer3;
	}
	if (cascade >= 4) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer4 = (((resonatorA(R4c)) * out) + ((resonatorB(R4c)) * ((p14 = resonatorP1(R4c))))) + ((resonatorC(R4c)) * (resonatorP2(R4c)));
		resonators[(R4c * 5) - 1] = p14;
		/* begin resonatorP1:put: */
		resonators[(R4c * 5) - 2] = answer4;
		out = answer4;
	}
	if (cascade >= 3) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer5 = (((resonatorA(R3c)) * out) + ((resonatorB(R3c)) * ((p15 = resonatorP1(R3c))))) + ((resonatorC(R3c)) * (resonatorP2(R3c)));
		resonators[(R3c * 5) - 1] = p15;
		/* begin resonatorP1:put: */
		resonators[(R3c * 5) - 2] = answer5;
		out = answer5;
	}
	if (cascade >= 2) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer6 = (((resonatorA(R2c)) * out) + ((resonatorB(R2c)) * ((p16 = resonatorP1(R2c))))) + ((resonatorC(R2c)) * (resonatorP2(R2c)));
		resonators[(R2c * 5) - 1] = p16;
		/* begin resonatorP1:put: */
		resonators[(R2c * 5) - 2] = answer6;
		out = answer6;
	}
	if (cascade >= 1) {
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer7 = (((resonatorA(R1c)) * out) + ((resonatorB(R1c)) * ((p17 = resonatorP1(R1c))))) + ((resonatorC(R1c)) * (resonatorP2(R1c)));
		resonators[(R1c * 5) - 1] = p17;
		/* begin resonatorP1:put: */
		resonators[(R1c * 5) - 2] = answer7;
		out = answer7;
	}
	return out;
}


/*	Return the first indexable word of oop which is assumed to be
	variableWordSubclass 
 */

	/* KlattSynthesizerPlugin>>#checkedFloatPtrOf: */
static float *
checkedFloatPtrOf(sqInt oop)
{
	success(isWords(oop));
	if (failed()) {
		return 0;
	}
	return ((float *) (firstIndexableField(oop)));
}


/*	Return the first indexable word of oop which is assumed to be
	variableWordSubclass 
 */

	/* KlattSynthesizerPlugin>>#checkedShortPtrOf: */
static short *
checkedShortPtrOf(sqInt oop)
{
	success(isWords(oop));
	if (failed()) {
		return 0;
	}
	return ((short *) (firstIndexableField(oop)));
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* KlattSynthesizerPlugin>>#glottalSource */
static float
glottalSource(void)
{
    float asin;
    float bsin;
    float cosphi;
    float csin;
    float d;
    double deltaF0;
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float gamma;
    float gammapwr;
    sqInt ingore;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    sqInt te;
    float theta;
    float timeCount;
    float u;
    float ua;
    float ub;
    float uc;
    float x0;

	if (t0 == 0) {
		return 0;
	}
	if (nper < nopen) {
		x0 = (a1 * x1) + (a2 * x2);
		x2 = x1;
		x1 = x0;
	}
	else {
		x0 = (b1 * x1) - c1;
		x1 = x0;
	}
	if (nper >= t0) {
		nper = 0;
		/* begin pitchSynchronousReset */
		if ((frame[F0]) > 0) {
			/* begin voicedPitchSynchronousReset */

			/* Add flutter and jitter (F0 perturbations). */
			pitch = frame[F0];
			timeCount = (((float) samplesCount)) / (((float) samplingRate));
			asin = sin(((2.0 * PI) * 12.7) * timeCount);
			bsin = sin(((2.0 * PI) * 7.1) * timeCount);
			csin = sin(((2.0 * PI) * 4.7) * timeCount);
			deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
			pitch += deltaF0;
			/* begin addJitter */
			pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
			/* begin addFrequencyDiplophonia */
			if ((periodCount % 2) == 0) {
				pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
			}
			else {
				pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
			}
			if (pitch < 0) {
				pitch = 0;
			}

			/* Duration of period before amplitude modulation. */
			t0 = ((sqInt)(samplingRate / pitch));
			nmod = t0;
			if ((frame[Voicing]) > 0) {
				nmod = nmod / 2;
			}

			/* Set the LF glottal pulse model parameters. */
			nopen = ((sqInt)(t0 * (frame[Ro])));
			/* begin ro:ra:rk: */
			te = ((sqInt)(t0 * (frame[Ro])));
			ro = (((double) te )) / (((double) t0 ));
			rk = frame[Rk];
			ra = frame[Ra];
			if (ra <= 0.0) {
				d = 1.0;
			}
			else {
				r = (1.0 - ro) / ra;
				d = 1.0 - (r / ((exp(r)) - 1.0));
			}
			phi = PI * (rk + 1.0);
			cosphi = cos(phi);
			sinphi = sin(phi);
			rphid = ((ra / ro) * phi) * d;
			/* begin zeroQphi:cosphi:sinphi:rphid: */
			expuphi5 = exp(0 * phi);
			qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
			if (qzero > 0) {
				ua = 0;
				ub = 1;
				qa = qzero;
				/* begin qu:phi:cosphi:sinphi:rphid: */
				expuphi1 = exp(ub * phi);
				qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
				while (qb > 0) {
					ua = ub;
					qa = qb;
					ub = ub * 2;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi = exp(ub * phi);
					qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
				}
			}
			else {
				ua = -1;
				ub = 0;
				/* begin qu:phi:cosphi:sinphi:rphid: */
				expuphi3 = exp(ua * phi);
				qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
				qb = qzero;
				while (qa < 0) {
					ub = ua;
					qb = qa;
					ua = ua * 2;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi2 = exp(ua * phi);
					qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
				}
			}
			while ((ub - ua) > Epsilon) {
				uc = (ub + ua) / 2.0;
				/* begin qu:phi:cosphi:sinphi:rphid: */
				expuphi4 = exp(uc * phi);
				qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
				if (qc > 0) {
					ua = uc;
					qa = qc;
				}
				else {
					ub = uc;
					qb = qc;
				}
			}
			u = (ub + ua) / 2.0;
			theta = phi / te;
			rho = exp(u * theta);
			a1 = (2.0 * (cos(theta))) * rho;
			a2 = 0.0 - (rho * rho);
			x2 = 0.0;
			x1 = rho * (sin(theta));
			gamma = exp(-1.0 / (ra * t0));
			gammapwr = pow(gamma,(t0 - te));
			b1 = gamma;
			c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);
			/* begin normalizeGlottalPulse */
			s0 = 0.0;
			s1 = x1;
			s2 = x2;
			for (ingore = 1; ingore <= nopen; ingore += 1) {
				s0 = (a1 * s1) + (a2 * s2);
				s2 = s1;
				s1 = s0;
			}
			if (!(s0 == 0.0)) {
				x1 = (x1 / s0) * 10000.0;
			}
			/* begin addShimmer */

			/* x1 must be <= 0 */
			x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
			if (x1 > 0) {
				x1 = 0;
			}
			/* begin addAmplitudeDiplophonia */
			if (!((periodCount % 2) == 0)) {

				/* x1 must be <= 0 */
				x1 = x1 * (1.0 - (frame[Diplophonia]));
				if (x1 > 0) {
					x1 = 0;
				}
			}
			periodCount = (periodCount + 1) % 0xFFFF;
		}
		else {
			t0 = 1;
			nmod = t0;
		}
	}
	nper += 1;
	return x0;
}

	/* KlattSynthesizerPlugin>>#linearFromdB: */
static float
linearFromdB(double aNumber)
{
	return (pow(2.0,((aNumber - 87.0) / 6.0))) * 32.767;
}

	/* KlattSynthesizerPlugin>>#loadFrom: */
static sqInt
loadFrom(sqInt klattOop)
{
    sqInt oop;

	success((slotSizeOf(klattOop)) == 22);
	if (failed()) {
		return 0;
	}
	oop = fetchPointerofObject(0, klattOop);
	/* begin checkedFloatPtrOf: */
	success(isWords(oop));
	if (failed()) {
		resonators = 0;
		goto l1;
	}
	resonators = ((float *) (firstIndexableField(oop)));
	l1:	/* end checkedFloatPtrOf: */;
	pitch = fetchFloatofObject(2, klattOop);
	t0 = fetchIntegerofObject(3, klattOop);
	nper = fetchIntegerofObject(4, klattOop);
	nopen = fetchIntegerofObject(5, klattOop);
	nmod = fetchIntegerofObject(6, klattOop);
	a1 = fetchFloatofObject(7, klattOop);
	a2 = fetchFloatofObject(8, klattOop);
	x1 = fetchFloatofObject(9, klattOop);
	x2 = fetchFloatofObject(10, klattOop);
	b1 = fetchFloatofObject(11, klattOop);
	c1 = fetchFloatofObject(12, klattOop);
	glast = fetchFloatofObject(13, klattOop);
	vlast = fetchFloatofObject(14, klattOop);
	nlast = fetchFloatofObject(15, klattOop);
	periodCount = fetchIntegerofObject(16, klattOop);
	samplesCount = fetchIntegerofObject(17, klattOop);
	seed = fetchIntegerofObject(18, klattOop);
	cascade = fetchIntegerofObject(19, klattOop);
	samplesPerFrame = fetchIntegerofObject(20, klattOop);
	samplingRate = fetchIntegerofObject(21, klattOop);
	return (failed()) == 0;
}


/*	Answer a random number between 0 and 65535. */

	/* KlattSynthesizerPlugin>>#nextRandom */
static sqInt
nextRandom(void)
{
	seed = ((seed * 1309) + 13849) & 0xFFFF;
	return seed;
}

	/* KlattSynthesizerPlugin>>#normalizeGlottalPulse */
static void
normalizeGlottalPulse(void)
{
    sqInt ingore;
    float s0;
    float s1;
    float s2;

	s0 = 0.0;
	s1 = x1;
	s2 = x2;
	for (ingore = 1; ingore <= nopen; ingore += 1) {
		s0 = (a1 * s1) + (a2 * s2);
		s2 = s1;
		s1 = s0;
	}
	if (!(s0 == 0.0)) {
		x1 = (x1 / s0) * 10000.0;
	}
}


/*	Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,
	outputs added with alternating sign. Sound source for other
	parallel resonators is friction plus first difference of
	voicing waveform. */

	/* KlattSynthesizerPlugin>>#parallelFrictionBranch: */
static float
parallelFrictionBranch(float source)
{
	return ((((resonatorvalue(R2fp, source)) - (resonatorvalue(R3fp, source))) + (resonatorvalue(R4fp, source))) - (resonatorvalue(R5fp, source))) + (resonatorvalue(R6fp, source));
}


/*	Voice-excited parallel vocal tract F1, F2, F3, F4, FNP and FTP. */

	/* KlattSynthesizerPlugin>>#parallelVoicedBranch: */
static float
parallelVoicedBranch(float source)
{
	return (((((resonatorvalue(R1vp, source)) + (resonatorvalue(R2vp, source))) + (resonatorvalue(R3vp, source))) + (resonatorvalue(R4vp, source))) + (resonatorvalue(Rnpp, source))) + (resonatorvalue(Rtpp, source));
}

	/* KlattSynthesizerPlugin>>#pitchSynchronousReset */
static void
pitchSynchronousReset(void)
{
    float asin;
    float bsin;
    float cosphi;
    float csin;
    float d;
    double deltaF0;
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float gamma;
    float gammapwr;
    sqInt ingore;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    sqInt te;
    float theta;
    float timeCount;
    float u;
    float ua;
    float ub;
    float uc;

	if ((frame[F0]) > 0) {
		/* begin voicedPitchSynchronousReset */

		/* Add flutter and jitter (F0 perturbations). */
		pitch = frame[F0];
		timeCount = (((float) samplesCount)) / (((float) samplingRate));
		asin = sin(((2.0 * PI) * 12.7) * timeCount);
		bsin = sin(((2.0 * PI) * 7.1) * timeCount);
		csin = sin(((2.0 * PI) * 4.7) * timeCount);
		deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
		pitch += deltaF0;
		/* begin addJitter */
		pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
		/* begin addFrequencyDiplophonia */
		if ((periodCount % 2) == 0) {
			pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
		}
		else {
			pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
		}
		if (pitch < 0) {
			pitch = 0;
		}

		/* Duration of period before amplitude modulation. */
		t0 = ((sqInt)(samplingRate / pitch));
		nmod = t0;
		if ((frame[Voicing]) > 0) {
			nmod = nmod / 2;
		}

		/* Set the LF glottal pulse model parameters. */
		nopen = ((sqInt)(t0 * (frame[Ro])));
		/* begin ro:ra:rk: */
		te = ((sqInt)(t0 * (frame[Ro])));
		ro = (((double) te )) / (((double) t0 ));
		rk = frame[Rk];
		ra = frame[Ra];
		if (ra <= 0.0) {
			d = 1.0;
		}
		else {
			r = (1.0 - ro) / ra;
			d = 1.0 - (r / ((exp(r)) - 1.0));
		}
		phi = PI * (rk + 1.0);
		cosphi = cos(phi);
		sinphi = sin(phi);
		rphid = ((ra / ro) * phi) * d;
		/* begin zeroQphi:cosphi:sinphi:rphid: */
		expuphi5 = exp(0 * phi);
		qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
		if (qzero > 0) {
			ua = 0;
			ub = 1;
			qa = qzero;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi1 = exp(ub * phi);
			qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
			while (qb > 0) {
				ua = ub;
				qa = qb;
				ub = ub * 2;
				/* begin qu:phi:cosphi:sinphi:rphid: */
				expuphi = exp(ub * phi);
				qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
			}
		}
		else {
			ua = -1;
			ub = 0;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi3 = exp(ua * phi);
			qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
			qb = qzero;
			while (qa < 0) {
				ub = ua;
				qb = qa;
				ua = ua * 2;
				/* begin qu:phi:cosphi:sinphi:rphid: */
				expuphi2 = exp(ua * phi);
				qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
			}
		}
		while ((ub - ua) > Epsilon) {
			uc = (ub + ua) / 2.0;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi4 = exp(uc * phi);
			qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
			if (qc > 0) {
				ua = uc;
				qa = qc;
			}
			else {
				ub = uc;
				qb = qc;
			}
		}
		u = (ub + ua) / 2.0;
		theta = phi / te;
		rho = exp(u * theta);
		a1 = (2.0 * (cos(theta))) * rho;
		a2 = 0.0 - (rho * rho);
		x2 = 0.0;
		x1 = rho * (sin(theta));
		gamma = exp(-1.0 / (ra * t0));
		gammapwr = pow(gamma,(t0 - te));
		b1 = gamma;
		c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);
		/* begin normalizeGlottalPulse */
		s0 = 0.0;
		s1 = x1;
		s2 = x2;
		for (ingore = 1; ingore <= nopen; ingore += 1) {
			s0 = (a1 * s1) + (a2 * s2);
			s2 = s1;
			s1 = s0;
		}
		if (!(s0 == 0.0)) {
			x1 = (x1 / s0) * 10000.0;
		}
		/* begin addShimmer */

		/* x1 must be <= 0 */
		x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
		if (x1 > 0) {
			x1 = 0;
		}
		/* begin addAmplitudeDiplophonia */
		if (!((periodCount % 2) == 0)) {

			/* x1 must be <= 0 */
			x1 = x1 * (1.0 - (frame[Diplophonia]));
			if (x1 > 0) {
				x1 = 0;
			}
		}
		periodCount = (periodCount + 1) % 0xFFFF;
	}
	else {
		t0 = 1;
		nmod = t0;
	}
}

	/* KlattSynthesizerPlugin>>#primitiveSynthesizeFrameIntoStartingAt */
EXPORT(sqInt)
primitiveSynthesizeFrameIntoStartingAt(void)
{
    float aFloat;
    float aFloat1;
    float aFloat10;
    float aFloat11;
    float aFloat2;
    float aFloat3;
    float aFloat4;
    float aFloat5;
    float aFloat6;
    float aFloat7;
    float aFloat8;
    float aFloat9;
    float *aKlattFrame;
    float ampF1V;
    float ampF2F;
    float ampF2V;
    float ampF3F;
    float ampF3V;
    float ampF4F;
    float ampF4V;
    float ampF5F;
    float ampF6F;
    float ampFNV;
    float ampFTV;
    float ampGain;
    float answer;
    float answer1;
    double answer10;
    float answer11;
    float answer12;
    float answer2;
    float answer3;
    float answer4;
    float answer5;
    float answer6;
    float answer7;
    double answer8;
    float answer9;
    float asin;
    float aspiration;
    float aspirationNoise;
    float bsin;
    short *buffer;
    sqInt bufferOop;
    float bypass;
    float cosphi;
    float csin;
    float d;
    double deltaF0;
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float friction;
    float frictionNoise;
    float gain;
    float gamma;
    float gammapwr;
    float glotout;
    sqInt index;
    sqInt ingore;
    float noise;
    sqInt oop;
    sqInt oop1;
    float out;
    float out1;
    float p1;
    float p11;
    double p110;
    float p111;
    float p112;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    double p18;
    float p19;
    float parGlotout;
    float parVoicing;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    sqInt rcvr;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    float source;
    sqInt startIndex;
    sqInt te;
    sqInt temp;
    float theta;
    float timeCount;
    sqInt top;
    float turbulence;
    float u;
    float ua;
    float ub;
    float uc;
    float voice;
    float voicing;
    float x0;

	/* begin checkedFloatPtrOf: */
	oop = stackValue(2);
	success(isWords(oop));
	if (failed()) {
		aKlattFrame = 0;
		goto l1;
	}
	aKlattFrame = ((float *) (firstIndexableField(oop)));
	l1:	/* end checkedFloatPtrOf: */;
	/* begin checkedShortPtrOf: */
	oop1 = (bufferOop = stackValue(1));
	success(isWords(oop1));
	if (failed()) {
		buffer = 0;
		goto l2;
	}
	buffer = ((short *) (firstIndexableField(oop1)));
	l2:	/* end checkedShortPtrOf: */;
	startIndex = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	rcvr = stackObjectValue(3);
	if (!(loadFrom(rcvr))) {
		return null;
	}
	success(((stSizeOf(bufferOop)) * 2) >= samplesPerFrame);
	if (failed()) {
		return null;
	}
	/* begin synthesizeFrame:into:startingAt: */
	
	/* Fudge factors... */
	frame = aKlattFrame;

	/* -4.44 dB */
	ampFNV = (linearFromdB(frame[Anv])) * 0.6;

	/* -4.44 dB */
	ampFTV = (linearFromdB(frame[Atv])) * 0.6;

	/* -7.96 dB */
	ampF1V = (linearFromdB(frame[A1v])) * 0.4;

	/* -16.5 dB */
	ampF2V = (linearFromdB(frame[A2v])) * 0.15;

	/* -24.4 dB */
	ampF3V = (linearFromdB(frame[A3v])) * 0.06;

	/* -28.0 dB */
	ampF4V = (linearFromdB(frame[A4v])) * 0.04;

	/* -16.5 dB */
	ampF2F = (linearFromdB(frame[A2f])) * 0.15;

	/* -24.4 dB */
	ampF3F = (linearFromdB(frame[A3f])) * 0.06;

	/* -28.0 dB */
	ampF4F = (linearFromdB(frame[A4f])) * 0.04;

	/* -33.2 dB */
	ampF5F = (linearFromdB(frame[A5f])) * 0.022;

	/* -30.5 dB */
	/* Set coefficients of variable cascade resonators */
	ampF6F = (linearFromdB(frame[A6f])) * 0.03;
	if (cascade >= 8) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R8c, 7500, 600);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 7) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R7c, 6500, 500);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 6) {
		resonatorfrequencybandwidth(R6c, frame[F6], frame[B6]);
	}
	if (cascade >= 5) {
		resonatorfrequencybandwidth(R5c, frame[F5], frame[B5]);
	}
	resonatorfrequencybandwidth(R4c, frame[F4], frame[B4]);
	resonatorfrequencybandwidth(R3c, frame[F3], frame[B3]);
	resonatorfrequencybandwidth(R2c, frame[F2], frame[B2]);
	resonatorfrequencybandwidth(R1c, frame[F1], frame[B1]);
	resonatorfrequencybandwidth(Rnpc, frame[Fnp], frame[Bnp]);
	resonatorfrequencybandwidth(Rtpc, frame[Ftp], frame[Btp]);
	antiResonatorfrequencybandwidth(Rnz, frame[Fnz], frame[Bnz]);
	antiResonatorfrequencybandwidth(Rtz, frame[Ftz], frame[Btz]);
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rnpp, frame[Fnp], frame[Bnp]);
	/* begin resonatorA:put: */
	aFloat11 = (resonatorA(Rnpp)) * ampFNV;
	resonators[(Rnpp * 5) - 5] = aFloat11;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rtpp, frame[Ftp], frame[Btp]);
	/* begin resonatorA:put: */
	aFloat1 = (resonatorA(Rtpp)) * ampFTV;
	resonators[(Rtpp * 5) - 5] = aFloat1;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R1vp, frame[F1], frame[B1]);
	/* begin resonatorA:put: */
	aFloat2 = (resonatorA(R1vp)) * ampF1V;
	resonators[(R1vp * 5) - 5] = aFloat2;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R2vp, frame[F2], frame[B2]);
	/* begin resonatorA:put: */
	aFloat3 = (resonatorA(R2vp)) * ampF2V;
	resonators[(R2vp * 5) - 5] = aFloat3;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R3vp, frame[F3], frame[B3]);
	/* begin resonatorA:put: */
	aFloat4 = (resonatorA(R3vp)) * ampF3V;
	resonators[(R3vp * 5) - 5] = aFloat4;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R4vp, frame[F4], frame[B4]);
	/* begin resonatorA:put: */
	aFloat5 = (resonatorA(R4vp)) * ampF4V;
	resonators[(R4vp * 5) - 5] = aFloat5;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R2fp, frame[F2], frame[B2f]);
	/* begin resonatorA:put: */
	aFloat6 = (resonatorA(R2fp)) * ampF2F;
	resonators[(R2fp * 5) - 5] = aFloat6;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R3fp, frame[F3], frame[B3f]);
	/* begin resonatorA:put: */
	aFloat7 = (resonatorA(R3fp)) * ampF3F;
	resonators[(R3fp * 5) - 5] = aFloat7;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R4fp, frame[F4], frame[B4f]);
	/* begin resonatorA:put: */
	aFloat8 = (resonatorA(R4fp)) * ampF4F;
	resonators[(R4fp * 5) - 5] = aFloat8;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R5fp, frame[F5], frame[B5f]);
	/* begin resonatorA:put: */
	aFloat9 = (resonatorA(R5fp)) * ampF5F;
	resonators[(R5fp * 5) - 5] = aFloat9;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R6fp, frame[F6], frame[B6f]);
	/* begin resonatorA:put: */
	aFloat10 = (resonatorA(R6fp)) * ampF6F;
	resonators[(R6fp * 5) - 5] = aFloat10;
	if (pitch > 0) {
		/* begin linearFromdB: */
		voicing = (pow(2.0,((((frame[Voicing]) - 7) - 87.0) / 6.0))) * 32.767;
		/* begin linearFromdB: */
		parVoicing = (pow(2.0,(((frame[Voicing]) - 87.0) / 6.0))) * 32.767;
		turbulence = (linearFromdB(frame[Turbulence])) * 0.1;
	}
	else {
		voicing = (parVoicing = (turbulence = 0.0));
	}
	friction = (linearFromdB(frame[Friction])) * 0.25;
	aspiration = (linearFromdB(frame[Aspiration])) * 0.05;

	/* -26.0 dB */
	/* Flod overall gain into output resonator (low-pass filter) */
	bypass = (linearFromdB(frame[Bypass])) * 0.05;
	gain = (frame[Gain]) - 3;
	if (gain <= 0) {
		gain = 57;
	}
	/* begin linearFromdB: */
	ampGain = (pow(2.0,((gain - 87.0) / 6.0))) * 32.767;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rout, 0, samplingRate);
	/* begin resonatorA:put: */
	aFloat = (resonatorA(Rout)) * ampGain;
	resonators[(Rout * 5) - 5] = aFloat;
	noise = nlast;
	index = startIndex;
	top = (samplesPerFrame + startIndex) - 1;
	while (index <= top) {

		/* Get low-passed random number for aspiration and friction noise */

		/* radom number between -8196.0 and 8196.0 */
		/* Tilt down noise spectrum by soft low-pass filter having
		   a pole near the origin in the z-plane. */
		noise = (((double) ((nextRandom()) - 32768) )) / 4.0;
		noise += 0.75 * nlast;

		/* Amplitude modulate noise (reduce noise amplitude during second
		   half of glottal period) if voicing  simultaneously present. */
		nlast = noise;
		if (nper > nmod) {
			noise = noise * 0.5;
		}

		/* Compute voicing waveform. */
		frictionNoise = friction * noise;
		/* begin glottalSource */
		if (t0 == 0) {
			voice = 0;
			goto l25;
		}
		if (nper < nopen) {
			x0 = (a1 * x1) + (a2 * x2);
			x2 = x1;
			x1 = x0;
		}
		else {
			x0 = (b1 * x1) - c1;
			x1 = x0;
		}
		if (nper >= t0) {
			nper = 0;
			/* begin pitchSynchronousReset */
			if ((frame[F0]) > 0) {
				/* begin voicedPitchSynchronousReset */

				/* Add flutter and jitter (F0 perturbations). */
				pitch = frame[F0];
				timeCount = (((float) samplesCount)) / (((float) samplingRate));
				asin = sin(((2.0 * PI) * 12.7) * timeCount);
				bsin = sin(((2.0 * PI) * 7.1) * timeCount);
				csin = sin(((2.0 * PI) * 4.7) * timeCount);
				deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
				pitch += deltaF0;
				/* begin addJitter */
				pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
				/* begin addFrequencyDiplophonia */
				if ((periodCount % 2) == 0) {
					pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
				}
				else {
					pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
				}
				if (pitch < 0) {
					pitch = 0;
				}

				/* Duration of period before amplitude modulation. */
				t0 = ((sqInt)(samplingRate / pitch));
				nmod = t0;
				if ((frame[Voicing]) > 0) {
					nmod = nmod / 2;
				}

				/* Set the LF glottal pulse model parameters. */
				nopen = ((sqInt)(t0 * (frame[Ro])));
				/* begin ro:ra:rk: */
				te = ((sqInt)(t0 * (frame[Ro])));
				ro = (((double) te )) / (((double) t0 ));
				rk = frame[Rk];
				ra = frame[Ra];
				if (ra <= 0.0) {
					d = 1.0;
				}
				else {
					r = (1.0 - ro) / ra;
					d = 1.0 - (r / ((exp(r)) - 1.0));
				}
				phi = PI * (rk + 1.0);
				cosphi = cos(phi);
				sinphi = sin(phi);
				rphid = ((ra / ro) * phi) * d;
				/* begin zeroQphi:cosphi:sinphi:rphid: */
				expuphi5 = exp(0 * phi);
				qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
				if (qzero > 0) {
					ua = 0;
					ub = 1;
					qa = qzero;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi1 = exp(ub * phi);
					qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
					while (qb > 0) {
						ua = ub;
						qa = qb;
						ub = ub * 2;
						/* begin qu:phi:cosphi:sinphi:rphid: */
						expuphi = exp(ub * phi);
						qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
					}
				}
				else {
					ua = -1;
					ub = 0;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi3 = exp(ua * phi);
					qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
					qb = qzero;
					while (qa < 0) {
						ub = ua;
						qb = qa;
						ua = ua * 2;
						/* begin qu:phi:cosphi:sinphi:rphid: */
						expuphi2 = exp(ua * phi);
						qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
					}
				}
				while ((ub - ua) > Epsilon) {
					uc = (ub + ua) / 2.0;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi4 = exp(uc * phi);
					qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
					if (qc > 0) {
						ua = uc;
						qa = qc;
					}
					else {
						ub = uc;
						qb = qc;
					}
				}
				u = (ub + ua) / 2.0;
				theta = phi / te;
				rho = exp(u * theta);
				a1 = (2.0 * (cos(theta))) * rho;
				a2 = 0.0 - (rho * rho);
				x2 = 0.0;
				x1 = rho * (sin(theta));
				gamma = exp(-1.0 / (ra * t0));
				gammapwr = pow(gamma,(t0 - te));
				b1 = gamma;
				c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);
				/* begin normalizeGlottalPulse */
				s0 = 0.0;
				s1 = x1;
				s2 = x2;
				for (ingore = 1; ingore <= nopen; ingore += 1) {
					s0 = (a1 * s1) + (a2 * s2);
					s2 = s1;
					s1 = s0;
				}
				if (!(s0 == 0.0)) {
					x1 = (x1 / s0) * 10000.0;
				}
				/* begin addShimmer */

				/* x1 must be <= 0 */
				x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
				if (x1 > 0) {
					x1 = 0;
				}
				/* begin addAmplitudeDiplophonia */
				if (!((periodCount % 2) == 0)) {

					/* x1 must be <= 0 */
					x1 = x1 * (1.0 - (frame[Diplophonia]));
					if (x1 > 0) {
						x1 = 0;
					}
				}
				periodCount = (periodCount + 1) % 0xFFFF;
			}
			else {
				t0 = 1;
				nmod = t0;
			}
		}
		nper += 1;
		voice = x0;
	l25:	/* end glottalSource */;

		/* Add turbulence during glottal open phase.
		   Use random rather than noise because noise is low-passed. */
		vlast = voice;
		if (nper < nopen) {
			voice += (turbulence * (((double) ((nextRandom()) - 32768) ))) / 4.0;
		}
		glotout = voicing * voice;

		/* Compute aspiration amplitude and add to voicing source. */
		parGlotout = parVoicing * voice;
		aspirationNoise = aspiration * noise;
		glotout += aspirationNoise;

		/* Cascade vocal tract, excited by laryngeal sources.
		   Nasal antiresonator, nasal resonator, trachearl antirresonator,
		   tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1. */
		parGlotout += aspirationNoise;
		/* begin cascadeBranch: */
		if (!(cascade > 0)) {
			out = 0.0;
			goto l17;
		}
		/* begin antiResonator:value: */
		answer8 = (((resonatorA(Rnz)) * glotout) + ((resonatorB(Rnz)) * ((p18 = resonatorP1(Rnz))))) + ((resonatorC(Rnz)) * (resonatorP2(Rnz)));
		/* begin resonatorP2:put: */
		resonators[(Rnz * 5) - 1] = p18;
		/* begin resonatorP1:put: */
		resonators[(Rnz * 5) - 2] = glotout;
		out1 = answer8;
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer9 = (((resonatorA(Rnpc)) * out1) + ((resonatorB(Rnpc)) * ((p19 = resonatorP1(Rnpc))))) + ((resonatorC(Rnpc)) * (resonatorP2(Rnpc)));
		resonators[(Rnpc * 5) - 1] = p19;
		/* begin resonatorP1:put: */
		resonators[(Rnpc * 5) - 2] = answer9;
		out1 = answer9;
		/* begin antiResonator:value: */
		answer10 = (((resonatorA(Rtz)) * out1) + ((resonatorB(Rtz)) * ((p110 = resonatorP1(Rtz))))) + ((resonatorC(Rtz)) * (resonatorP2(Rtz)));
		/* begin resonatorP2:put: */
		resonators[(Rtz * 5) - 1] = p110;
		/* begin resonatorP1:put: */
		resonators[(Rtz * 5) - 2] = out1;
		out1 = answer10;
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer11 = (((resonatorA(Rtpc)) * out1) + ((resonatorB(Rtpc)) * ((p111 = resonatorP1(Rtpc))))) + ((resonatorC(Rtpc)) * (resonatorP2(Rtpc)));
		resonators[(Rtpc * 5) - 1] = p111;
		/* begin resonatorP1:put: */
		resonators[(Rtpc * 5) - 2] = answer11;
		out1 = answer11;
		if (cascade >= 8) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer12 = (((resonatorA(R8c)) * out1) + ((resonatorB(R8c)) * ((p112 = resonatorP1(R8c))))) + ((resonatorC(R8c)) * (resonatorP2(R8c)));
			resonators[(R8c * 5) - 1] = p112;
			/* begin resonatorP1:put: */
			resonators[(R8c * 5) - 2] = answer12;
			out1 = answer12;
		}
		if (cascade >= 7) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer1 = (((resonatorA(R7c)) * out1) + ((resonatorB(R7c)) * ((p11 = resonatorP1(R7c))))) + ((resonatorC(R7c)) * (resonatorP2(R7c)));
			resonators[(R7c * 5) - 1] = p11;
			/* begin resonatorP1:put: */
			resonators[(R7c * 5) - 2] = answer1;
			out1 = answer1;
		}
		if (cascade >= 6) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer2 = (((resonatorA(R6c)) * out1) + ((resonatorB(R6c)) * ((p12 = resonatorP1(R6c))))) + ((resonatorC(R6c)) * (resonatorP2(R6c)));
			resonators[(R6c * 5) - 1] = p12;
			/* begin resonatorP1:put: */
			resonators[(R6c * 5) - 2] = answer2;
			out1 = answer2;
		}
		if (cascade >= 5) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer3 = (((resonatorA(R5c)) * out1) + ((resonatorB(R5c)) * ((p13 = resonatorP1(R5c))))) + ((resonatorC(R5c)) * (resonatorP2(R5c)));
			resonators[(R5c * 5) - 1] = p13;
			/* begin resonatorP1:put: */
			resonators[(R5c * 5) - 2] = answer3;
			out1 = answer3;
		}
		if (cascade >= 4) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer4 = (((resonatorA(R4c)) * out1) + ((resonatorB(R4c)) * ((p14 = resonatorP1(R4c))))) + ((resonatorC(R4c)) * (resonatorP2(R4c)));
			resonators[(R4c * 5) - 1] = p14;
			/* begin resonatorP1:put: */
			resonators[(R4c * 5) - 2] = answer4;
			out1 = answer4;
		}
		if (cascade >= 3) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer5 = (((resonatorA(R3c)) * out1) + ((resonatorB(R3c)) * ((p15 = resonatorP1(R3c))))) + ((resonatorC(R3c)) * (resonatorP2(R3c)));
			resonators[(R3c * 5) - 1] = p15;
			/* begin resonatorP1:put: */
			resonators[(R3c * 5) - 2] = answer5;
			out1 = answer5;
		}
		if (cascade >= 2) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer6 = (((resonatorA(R2c)) * out1) + ((resonatorB(R2c)) * ((p16 = resonatorP1(R2c))))) + ((resonatorC(R2c)) * (resonatorP2(R2c)));
			resonators[(R2c * 5) - 1] = p16;
			/* begin resonatorP1:put: */
			resonators[(R2c * 5) - 2] = answer6;
			out1 = answer6;
		}
		if (cascade >= 1) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer7 = (((resonatorA(R1c)) * out1) + ((resonatorB(R1c)) * ((p17 = resonatorP1(R1c))))) + ((resonatorC(R1c)) * (resonatorP2(R1c)));
			resonators[(R1c * 5) - 1] = p17;
			/* begin resonatorP1:put: */
			resonators[(R1c * 5) - 2] = answer7;
			out1 = answer7;
		}
		out = out1;
	l17:	/* end cascadeBranch: */;

		/* Source is voicing plus aspiration. */
		source = parGlotout;

		/* Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,
		   outputs added with alternating sign. Sound source for other
		   parallel resonators is friction plus first difference of
		   voicing waveform. */
		out += parallelVoicedBranch(source);
		source = (frictionNoise + parGlotout) - glast;
		glast = parGlotout;

		/* Apply bypas and output low-pass filter */
		out = (parallelFrictionBranch(source)) - out;
		out = (bypass * source) - out;
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer = (((resonatorA(Rout)) * out) + ((resonatorB(Rout)) * ((p1 = resonatorP1(Rout))))) + ((resonatorC(Rout)) * (resonatorP2(Rout)));
		resonators[(Rout * 5) - 1] = p1;
		/* begin resonatorP1:put: */
		resonators[(Rout * 5) - 2] = answer;
		out = answer;
		temp = ((sqInt)(out * ampGain));
		if (temp < -32768) {
			temp = -32768;
		}
		if (temp > 0x7FFF) {
			temp = 0x7FFF;
		}
		buffer[index - 1] = temp;
		index += 1;
		samplesCount += 1;
	}
	if (!(saveTo(rcvr))) {
		return null;
	}
	pop(3);
	return 0;
}

	/* KlattSynthesizerPlugin>>#qu:phi:cosphi:sinphi:rphid: */
static float
quphicosphisinphirphid(float u, float phi, float cosphi, float sinphi, float rphid)
{
    float expuphi;

	expuphi = exp(u * phi);
	return (expuphi * ((((rphid * ((u * u) + 1.0)) + u) * sinphi) - cosphi)) + 1.0;
}

	/* KlattSynthesizerPlugin>>#resonatorA: */
static float
resonatorA(sqInt index)
{
	return resonators[(index * 5) - 5];
}

	/* KlattSynthesizerPlugin>>#resonatorA:put: */
static void
resonatorAput(sqInt index, float aFloat)
{
	resonators[(index * 5) - 5] = aFloat;
}

	/* KlattSynthesizerPlugin>>#resonatorB: */
static float
resonatorB(sqInt index)
{
	return resonators[(index * 5) - 4];
}

	/* KlattSynthesizerPlugin>>#resonatorB:put: */
static void
resonatorBput(sqInt index, float aFloat)
{
	resonators[(index * 5) - 4] = aFloat;
}

	/* KlattSynthesizerPlugin>>#resonatorC: */
static float
resonatorC(sqInt index)
{
	return resonators[(index * 5) - 3];
}

	/* KlattSynthesizerPlugin>>#resonatorC:put: */
static void
resonatorCput(sqInt index, float aFloat)
{
	resonators[(index * 5) - 3] = aFloat;
}

	/* KlattSynthesizerPlugin>>#resonatorP1: */
static float
resonatorP1(sqInt index)
{
	return resonators[(index * 5) - 2];
}

	/* KlattSynthesizerPlugin>>#resonatorP1:put: */
static void
resonatorP1put(sqInt index, float aFloat)
{
	resonators[(index * 5) - 2] = aFloat;
}

	/* KlattSynthesizerPlugin>>#resonatorP2: */
static float
resonatorP2(sqInt index)
{
	return resonators[(index * 5) - 1];
}

	/* KlattSynthesizerPlugin>>#resonatorP2:put: */
static void
resonatorP2put(sqInt index, float aFloat)
{
	resonators[(index * 5) - 1] = aFloat;
}


/*	Convert formant frequencies and bandwidth into
	resonator difference equation coefficients. */

	/* KlattSynthesizerPlugin>>#resonator:frequency:bandwidth: */
static void
resonatorfrequencybandwidth(sqInt index, float freq, float bw)
{
    float a;
    double arg;
    float b;
    float c;
    float r;

	arg = ((0.0 - PI) / samplingRate) * bw;
	r = exp(arg);
	c = 0.0 - (r * r);
	arg = ((PI * 2.0) / samplingRate) * freq;
	b = (r * (cos(arg))) * 2.0;
	a = (1.0 - b) - c;
	/* begin resonatorA:put: */
	resonators[(index * 5) - 5] = a;
	/* begin resonatorB:put: */
	resonators[(index * 5) - 4] = b;
	/* begin resonatorC:put: */
	resonators[(index * 5) - 3] = c;
}


/*	Convert formant frequencies and bandwidth into
	resonator difference equation coefficients. */

	/* KlattSynthesizerPlugin>>#resonator:frequency:bandwidth:gain: */
static void
resonatorfrequencybandwidthgain(sqInt index, float freq, float bw, float gain)
{
    float aFloat;

	resonatorfrequencybandwidth(index, freq, bw);
	/* begin resonatorA:put: */
	aFloat = (resonatorA(index)) * gain;
	resonators[(index * 5) - 5] = aFloat;
}

	/* KlattSynthesizerPlugin>>#resonator:value: */
static float
resonatorvalue(sqInt index, float aFloat)
{
    float answer;
    float p1;


	/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
	   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
	answer = (((resonatorA(index)) * aFloat) + ((resonatorB(index)) * ((p1 = resonatorP1(index))))) + ((resonatorC(index)) * (resonatorP2(index)));
	/* begin resonatorP2:put: */
	resonators[(index * 5) - 1] = p1;
	/* begin resonatorP1:put: */
	resonators[(index * 5) - 2] = answer;
	return answer;
}

	/* KlattSynthesizerPlugin>>#ro:ra:rk: */
static void
rorark(float roNumber, float raNumber, float rkNumber)
{
    float cosphi;
    float d;
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float gamma;
    float gammapwr;
    sqInt ingore;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    sqInt te;
    float theta;
    float u;
    float ua;
    float ub;
    float uc;

	te = ((sqInt)(t0 * roNumber));
	ro = (((double) te )) / (((double) t0 ));
	rk = rkNumber;
	ra = raNumber;
	if (ra <= 0.0) {
		d = 1.0;
	}
	else {
		r = (1.0 - ro) / ra;
		d = 1.0 - (r / ((exp(r)) - 1.0));
	}
	phi = PI * (rk + 1.0);
	cosphi = cos(phi);
	sinphi = sin(phi);
	rphid = ((ra / ro) * phi) * d;
	/* begin zeroQphi:cosphi:sinphi:rphid: */
	expuphi5 = exp(0 * phi);
	qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
	if (qzero > 0) {
		ua = 0;
		ub = 1;
		qa = qzero;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi1 = exp(ub * phi);
		qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
		while (qb > 0) {
			ua = ub;
			qa = qb;
			ub = ub * 2;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi = exp(ub * phi);
			qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
		}
	}
	else {
		ua = -1;
		ub = 0;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi3 = exp(ua * phi);
		qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
		qb = qzero;
		while (qa < 0) {
			ub = ua;
			qb = qa;
			ua = ua * 2;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi2 = exp(ua * phi);
			qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
		}
	}
	while ((ub - ua) > Epsilon) {
		uc = (ub + ua) / 2.0;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi4 = exp(uc * phi);
		qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
		if (qc > 0) {
			ua = uc;
			qa = qc;
		}
		else {
			ub = uc;
			qb = qc;
		}
	}
	u = (ub + ua) / 2.0;
	theta = phi / te;
	rho = exp(u * theta);
	a1 = (2.0 * (cos(theta))) * rho;
	a2 = 0.0 - (rho * rho);
	x2 = 0.0;
	x1 = rho * (sin(theta));
	gamma = exp(-1.0 / (ra * t0));
	gammapwr = pow(gamma,(t0 - te));
	b1 = gamma;
	c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);
	/* begin normalizeGlottalPulse */
	s0 = 0.0;
	s1 = x1;
	s2 = x2;
	for (ingore = 1; ingore <= nopen; ingore += 1) {
		s0 = (a1 * s1) + (a2 * s2);
		s2 = s1;
		s1 = s0;
	}
	if (!(s0 == 0.0)) {
		x1 = (x1 / s0) * 10000.0;
	}
}

	/* KlattSynthesizerPlugin>>#saveTo: */
static sqInt
saveTo(sqInt origKlattOop)
{
    sqInt a1Oop;
    sqInt a2Oop;
    sqInt b1Oop;
    sqInt c1Oop;
    sqInt glastOop;
    sqInt klattOop;
    sqInt nlastOop;
    sqInt pitchOop;
    sqInt vlastOop;
    sqInt x1Oop;
    sqInt x2Oop;

	pushRemappableOop(origKlattOop);
	pushRemappableOop(floatObjectOf(pitch));
	pushRemappableOop(floatObjectOf(a1));
	pushRemappableOop(floatObjectOf(a2));
	pushRemappableOop(floatObjectOf(x1));
	pushRemappableOop(floatObjectOf(x2));
	pushRemappableOop(floatObjectOf(b1));
	pushRemappableOop(floatObjectOf(c1));
	pushRemappableOop(floatObjectOf(glast));
	pushRemappableOop(floatObjectOf(vlast));
	nlastOop = floatObjectOf(nlast);
	vlastOop = popRemappableOop();
	glastOop = popRemappableOop();
	c1Oop = popRemappableOop();
	b1Oop = popRemappableOop();
	x2Oop = popRemappableOop();
	x1Oop = popRemappableOop();
	a2Oop = popRemappableOop();
	a1Oop = popRemappableOop();
	pitchOop = popRemappableOop();
	klattOop = popRemappableOop();
	if (failed()) {
		return 0;
	}
	storePointerofObjectwithValue(2, klattOop, pitchOop);
	storeIntegerofObjectwithValue(3, klattOop, t0);
	storeIntegerofObjectwithValue(4, klattOop, nper);
	storeIntegerofObjectwithValue(5, klattOop, nopen);
	storeIntegerofObjectwithValue(6, klattOop, nmod);
	storePointerofObjectwithValue(7, klattOop, a1Oop);
	storePointerofObjectwithValue(8, klattOop, a2Oop);
	storePointerofObjectwithValue(9, klattOop, x1Oop);
	storePointerofObjectwithValue(10, klattOop, x2Oop);
	storePointerofObjectwithValue(11, klattOop, b1Oop);
	storePointerofObjectwithValue(12, klattOop, c1Oop);
	storePointerofObjectwithValue(13, klattOop, glastOop);
	storePointerofObjectwithValue(14, klattOop, vlastOop);
	storePointerofObjectwithValue(15, klattOop, nlastOop);
	storeIntegerofObjectwithValue(16, klattOop, periodCount);
	storeIntegerofObjectwithValue(17, klattOop, samplesCount);
	storeIntegerofObjectwithValue(18, klattOop, seed);
	return (failed()) == 0;
}

	/* KlattSynthesizerPlugin>>#setCurrentFrame: */
static void
setCurrentFrame(float *aKlattFrame)
{
    float aFloat;
    float aFloat1;
    float aFloat10;
    float aFloat2;
    float aFloat3;
    float aFloat4;
    float aFloat5;
    float aFloat6;
    float aFloat7;
    float aFloat8;
    float aFloat9;
    float ampF1V;
    float ampF2F;
    float ampF2V;
    float ampF3F;
    float ampF3V;
    float ampF4F;
    float ampF4V;
    float ampF5F;
    float ampF6F;
    float ampFNV;
    float ampFTV;


	/* Fudge factors... */
	frame = aKlattFrame;

	/* -4.44 dB */
	ampFNV = (linearFromdB(frame[Anv])) * 0.6;

	/* -4.44 dB */
	ampFTV = (linearFromdB(frame[Atv])) * 0.6;

	/* -7.96 dB */
	ampF1V = (linearFromdB(frame[A1v])) * 0.4;

	/* -16.5 dB */
	ampF2V = (linearFromdB(frame[A2v])) * 0.15;

	/* -24.4 dB */
	ampF3V = (linearFromdB(frame[A3v])) * 0.06;

	/* -28.0 dB */
	ampF4V = (linearFromdB(frame[A4v])) * 0.04;

	/* -16.5 dB */
	ampF2F = (linearFromdB(frame[A2f])) * 0.15;

	/* -24.4 dB */
	ampF3F = (linearFromdB(frame[A3f])) * 0.06;

	/* -28.0 dB */
	ampF4F = (linearFromdB(frame[A4f])) * 0.04;

	/* -33.2 dB */
	ampF5F = (linearFromdB(frame[A5f])) * 0.022;

	/* -30.5 dB */
	/* Set coefficients of variable cascade resonators */
	ampF6F = (linearFromdB(frame[A6f])) * 0.03;
	if (cascade >= 8) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R8c, 7500, 600);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 7) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R7c, 6500, 500);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 6) {
		resonatorfrequencybandwidth(R6c, frame[F6], frame[B6]);
	}
	if (cascade >= 5) {
		resonatorfrequencybandwidth(R5c, frame[F5], frame[B5]);
	}
	resonatorfrequencybandwidth(R4c, frame[F4], frame[B4]);
	resonatorfrequencybandwidth(R3c, frame[F3], frame[B3]);
	resonatorfrequencybandwidth(R2c, frame[F2], frame[B2]);
	resonatorfrequencybandwidth(R1c, frame[F1], frame[B1]);
	resonatorfrequencybandwidth(Rnpc, frame[Fnp], frame[Bnp]);
	resonatorfrequencybandwidth(Rtpc, frame[Ftp], frame[Btp]);
	antiResonatorfrequencybandwidth(Rnz, frame[Fnz], frame[Bnz]);
	antiResonatorfrequencybandwidth(Rtz, frame[Ftz], frame[Btz]);
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rnpp, frame[Fnp], frame[Bnp]);
	/* begin resonatorA:put: */
	aFloat = (resonatorA(Rnpp)) * ampFNV;
	resonators[(Rnpp * 5) - 5] = aFloat;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rtpp, frame[Ftp], frame[Btp]);
	/* begin resonatorA:put: */
	aFloat1 = (resonatorA(Rtpp)) * ampFTV;
	resonators[(Rtpp * 5) - 5] = aFloat1;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R1vp, frame[F1], frame[B1]);
	/* begin resonatorA:put: */
	aFloat2 = (resonatorA(R1vp)) * ampF1V;
	resonators[(R1vp * 5) - 5] = aFloat2;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R2vp, frame[F2], frame[B2]);
	/* begin resonatorA:put: */
	aFloat3 = (resonatorA(R2vp)) * ampF2V;
	resonators[(R2vp * 5) - 5] = aFloat3;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R3vp, frame[F3], frame[B3]);
	/* begin resonatorA:put: */
	aFloat4 = (resonatorA(R3vp)) * ampF3V;
	resonators[(R3vp * 5) - 5] = aFloat4;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R4vp, frame[F4], frame[B4]);
	/* begin resonatorA:put: */
	aFloat5 = (resonatorA(R4vp)) * ampF4V;
	resonators[(R4vp * 5) - 5] = aFloat5;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R2fp, frame[F2], frame[B2f]);
	/* begin resonatorA:put: */
	aFloat6 = (resonatorA(R2fp)) * ampF2F;
	resonators[(R2fp * 5) - 5] = aFloat6;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R3fp, frame[F3], frame[B3f]);
	/* begin resonatorA:put: */
	aFloat7 = (resonatorA(R3fp)) * ampF3F;
	resonators[(R3fp * 5) - 5] = aFloat7;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R4fp, frame[F4], frame[B4f]);
	/* begin resonatorA:put: */
	aFloat8 = (resonatorA(R4fp)) * ampF4F;
	resonators[(R4fp * 5) - 5] = aFloat8;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R5fp, frame[F5], frame[B5f]);
	/* begin resonatorA:put: */
	aFloat9 = (resonatorA(R5fp)) * ampF5F;
	resonators[(R5fp * 5) - 5] = aFloat9;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R6fp, frame[F6], frame[B6f]);
	/* begin resonatorA:put: */
	aFloat10 = (resonatorA(R6fp)) * ampF6F;
	resonators[(R6fp * 5) - 5] = aFloat10;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		failed = interpreterProxy->failed;
		fetchFloatofObject = interpreterProxy->fetchFloatofObject;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatObjectOf = interpreterProxy->floatObjectOf;
		isWords = interpreterProxy->isWords;
		pop = interpreterProxy->pop;
		popRemappableOop = interpreterProxy->popRemappableOop;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storeIntegerofObjectwithValue = interpreterProxy->storeIntegerofObjectwithValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		success = interpreterProxy->success;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* KlattSynthesizerPlugin>>#synthesizeFrame:into:startingAt: */
static void
synthesizeFrameintostartingAt(float *aKlattFrame, short *buffer, sqInt startIndex)
{
    float aFloat;
    float aFloat1;
    float aFloat10;
    float aFloat11;
    float aFloat2;
    float aFloat3;
    float aFloat4;
    float aFloat5;
    float aFloat6;
    float aFloat7;
    float aFloat8;
    float aFloat9;
    float ampF1V;
    float ampF2F;
    float ampF2V;
    float ampF3F;
    float ampF3V;
    float ampF4F;
    float ampF4V;
    float ampF5F;
    float ampF6F;
    float ampFNV;
    float ampFTV;
    float ampGain;
    float answer;
    float answer1;
    double answer10;
    float answer11;
    float answer12;
    float answer2;
    float answer3;
    float answer4;
    float answer5;
    float answer6;
    float answer7;
    double answer8;
    float answer9;
    float asin;
    float aspiration;
    float aspirationNoise;
    float bsin;
    float bypass;
    float cosphi;
    float csin;
    float d;
    double deltaF0;
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float friction;
    float frictionNoise;
    float gain;
    float gamma;
    float gammapwr;
    float glotout;
    sqInt index;
    sqInt ingore;
    float noise;
    float out;
    float out1;
    float p1;
    float p11;
    double p110;
    float p111;
    float p112;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    double p18;
    float p19;
    float parGlotout;
    float parVoicing;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    float source;
    sqInt te;
    sqInt temp;
    float theta;
    float timeCount;
    sqInt top;
    float turbulence;
    float u;
    float ua;
    float ub;
    float uc;
    float voice;
    float voicing;
    float x0;

	/* begin setCurrentFrame: */

	/* Fudge factors... */
	frame = aKlattFrame;

	/* -4.44 dB */
	ampFNV = (linearFromdB(frame[Anv])) * 0.6;

	/* -4.44 dB */
	ampFTV = (linearFromdB(frame[Atv])) * 0.6;

	/* -7.96 dB */
	ampF1V = (linearFromdB(frame[A1v])) * 0.4;

	/* -16.5 dB */
	ampF2V = (linearFromdB(frame[A2v])) * 0.15;

	/* -24.4 dB */
	ampF3V = (linearFromdB(frame[A3v])) * 0.06;

	/* -28.0 dB */
	ampF4V = (linearFromdB(frame[A4v])) * 0.04;

	/* -16.5 dB */
	ampF2F = (linearFromdB(frame[A2f])) * 0.15;

	/* -24.4 dB */
	ampF3F = (linearFromdB(frame[A3f])) * 0.06;

	/* -28.0 dB */
	ampF4F = (linearFromdB(frame[A4f])) * 0.04;

	/* -33.2 dB */
	ampF5F = (linearFromdB(frame[A5f])) * 0.022;

	/* -30.5 dB */
	/* Set coefficients of variable cascade resonators */
	ampF6F = (linearFromdB(frame[A6f])) * 0.03;
	if (cascade >= 8) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R8c, 7500, 600);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 7) {
		if (samplingRate >= 16000) {

			/* Inside Nyquist rate? */
			resonatorfrequencybandwidth(R7c, 6500, 500);
		}
		else {
			cascade = 6;
		}
	}
	if (cascade >= 6) {
		resonatorfrequencybandwidth(R6c, frame[F6], frame[B6]);
	}
	if (cascade >= 5) {
		resonatorfrequencybandwidth(R5c, frame[F5], frame[B5]);
	}
	resonatorfrequencybandwidth(R4c, frame[F4], frame[B4]);
	resonatorfrequencybandwidth(R3c, frame[F3], frame[B3]);
	resonatorfrequencybandwidth(R2c, frame[F2], frame[B2]);
	resonatorfrequencybandwidth(R1c, frame[F1], frame[B1]);
	resonatorfrequencybandwidth(Rnpc, frame[Fnp], frame[Bnp]);
	resonatorfrequencybandwidth(Rtpc, frame[Ftp], frame[Btp]);
	antiResonatorfrequencybandwidth(Rnz, frame[Fnz], frame[Bnz]);
	antiResonatorfrequencybandwidth(Rtz, frame[Ftz], frame[Btz]);
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rnpp, frame[Fnp], frame[Bnp]);
	/* begin resonatorA:put: */
	aFloat11 = (resonatorA(Rnpp)) * ampFNV;
	resonators[(Rnpp * 5) - 5] = aFloat11;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rtpp, frame[Ftp], frame[Btp]);
	/* begin resonatorA:put: */
	aFloat1 = (resonatorA(Rtpp)) * ampFTV;
	resonators[(Rtpp * 5) - 5] = aFloat1;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R1vp, frame[F1], frame[B1]);
	/* begin resonatorA:put: */
	aFloat2 = (resonatorA(R1vp)) * ampF1V;
	resonators[(R1vp * 5) - 5] = aFloat2;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R2vp, frame[F2], frame[B2]);
	/* begin resonatorA:put: */
	aFloat3 = (resonatorA(R2vp)) * ampF2V;
	resonators[(R2vp * 5) - 5] = aFloat3;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R3vp, frame[F3], frame[B3]);
	/* begin resonatorA:put: */
	aFloat4 = (resonatorA(R3vp)) * ampF3V;
	resonators[(R3vp * 5) - 5] = aFloat4;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R4vp, frame[F4], frame[B4]);
	/* begin resonatorA:put: */
	aFloat5 = (resonatorA(R4vp)) * ampF4V;
	resonators[(R4vp * 5) - 5] = aFloat5;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R2fp, frame[F2], frame[B2f]);
	/* begin resonatorA:put: */
	aFloat6 = (resonatorA(R2fp)) * ampF2F;
	resonators[(R2fp * 5) - 5] = aFloat6;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R3fp, frame[F3], frame[B3f]);
	/* begin resonatorA:put: */
	aFloat7 = (resonatorA(R3fp)) * ampF3F;
	resonators[(R3fp * 5) - 5] = aFloat7;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R4fp, frame[F4], frame[B4f]);
	/* begin resonatorA:put: */
	aFloat8 = (resonatorA(R4fp)) * ampF4F;
	resonators[(R4fp * 5) - 5] = aFloat8;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R5fp, frame[F5], frame[B5f]);
	/* begin resonatorA:put: */
	aFloat9 = (resonatorA(R5fp)) * ampF5F;
	resonators[(R5fp * 5) - 5] = aFloat9;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(R6fp, frame[F6], frame[B6f]);
	/* begin resonatorA:put: */
	aFloat10 = (resonatorA(R6fp)) * ampF6F;
	resonators[(R6fp * 5) - 5] = aFloat10;
	if (pitch > 0) {
		/* begin linearFromdB: */
		voicing = (pow(2.0,((((frame[Voicing]) - 7) - 87.0) / 6.0))) * 32.767;
		/* begin linearFromdB: */
		parVoicing = (pow(2.0,(((frame[Voicing]) - 87.0) / 6.0))) * 32.767;
		turbulence = (linearFromdB(frame[Turbulence])) * 0.1;
	}
	else {
		voicing = (parVoicing = (turbulence = 0.0));
	}
	friction = (linearFromdB(frame[Friction])) * 0.25;
	aspiration = (linearFromdB(frame[Aspiration])) * 0.05;

	/* -26.0 dB */
	/* Flod overall gain into output resonator (low-pass filter) */
	bypass = (linearFromdB(frame[Bypass])) * 0.05;
	gain = (frame[Gain]) - 3;
	if (gain <= 0) {
		gain = 57;
	}
	/* begin linearFromdB: */
	ampGain = (pow(2.0,((gain - 87.0) / 6.0))) * 32.767;
	/* begin resonator:frequency:bandwidth:gain: */
	resonatorfrequencybandwidth(Rout, 0, samplingRate);
	/* begin resonatorA:put: */
	aFloat = (resonatorA(Rout)) * ampGain;
	resonators[(Rout * 5) - 5] = aFloat;
	noise = nlast;
	index = startIndex;
	top = (samplesPerFrame + startIndex) - 1;
	while (index <= top) {

		/* Get low-passed random number for aspiration and friction noise */

		/* radom number between -8196.0 and 8196.0 */
		/* Tilt down noise spectrum by soft low-pass filter having
		   a pole near the origin in the z-plane. */
		noise = (((double) ((nextRandom()) - 32768) )) / 4.0;
		noise += 0.75 * nlast;

		/* Amplitude modulate noise (reduce noise amplitude during second
		   half of glottal period) if voicing  simultaneously present. */
		nlast = noise;
		if (nper > nmod) {
			noise = noise * 0.5;
		}

		/* Compute voicing waveform. */
		frictionNoise = friction * noise;
		/* begin glottalSource */
		if (t0 == 0) {
			voice = 0;
			goto l25;
		}
		if (nper < nopen) {
			x0 = (a1 * x1) + (a2 * x2);
			x2 = x1;
			x1 = x0;
		}
		else {
			x0 = (b1 * x1) - c1;
			x1 = x0;
		}
		if (nper >= t0) {
			nper = 0;
			/* begin pitchSynchronousReset */
			if ((frame[F0]) > 0) {
				/* begin voicedPitchSynchronousReset */

				/* Add flutter and jitter (F0 perturbations). */
				pitch = frame[F0];
				timeCount = (((float) samplesCount)) / (((float) samplingRate));
				asin = sin(((2.0 * PI) * 12.7) * timeCount);
				bsin = sin(((2.0 * PI) * 7.1) * timeCount);
				csin = sin(((2.0 * PI) * 4.7) * timeCount);
				deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
				pitch += deltaF0;
				/* begin addJitter */
				pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
				/* begin addFrequencyDiplophonia */
				if ((periodCount % 2) == 0) {
					pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
				}
				else {
					pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
				}
				if (pitch < 0) {
					pitch = 0;
				}

				/* Duration of period before amplitude modulation. */
				t0 = ((sqInt)(samplingRate / pitch));
				nmod = t0;
				if ((frame[Voicing]) > 0) {
					nmod = nmod / 2;
				}

				/* Set the LF glottal pulse model parameters. */
				nopen = ((sqInt)(t0 * (frame[Ro])));
				/* begin ro:ra:rk: */
				te = ((sqInt)(t0 * (frame[Ro])));
				ro = (((double) te )) / (((double) t0 ));
				rk = frame[Rk];
				ra = frame[Ra];
				if (ra <= 0.0) {
					d = 1.0;
				}
				else {
					r = (1.0 - ro) / ra;
					d = 1.0 - (r / ((exp(r)) - 1.0));
				}
				phi = PI * (rk + 1.0);
				cosphi = cos(phi);
				sinphi = sin(phi);
				rphid = ((ra / ro) * phi) * d;
				/* begin zeroQphi:cosphi:sinphi:rphid: */
				expuphi5 = exp(0 * phi);
				qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
				if (qzero > 0) {
					ua = 0;
					ub = 1;
					qa = qzero;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi1 = exp(ub * phi);
					qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
					while (qb > 0) {
						ua = ub;
						qa = qb;
						ub = ub * 2;
						/* begin qu:phi:cosphi:sinphi:rphid: */
						expuphi = exp(ub * phi);
						qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
					}
				}
				else {
					ua = -1;
					ub = 0;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi3 = exp(ua * phi);
					qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
					qb = qzero;
					while (qa < 0) {
						ub = ua;
						qb = qa;
						ua = ua * 2;
						/* begin qu:phi:cosphi:sinphi:rphid: */
						expuphi2 = exp(ua * phi);
						qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
					}
				}
				while ((ub - ua) > Epsilon) {
					uc = (ub + ua) / 2.0;
					/* begin qu:phi:cosphi:sinphi:rphid: */
					expuphi4 = exp(uc * phi);
					qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
					if (qc > 0) {
						ua = uc;
						qa = qc;
					}
					else {
						ub = uc;
						qb = qc;
					}
				}
				u = (ub + ua) / 2.0;
				theta = phi / te;
				rho = exp(u * theta);
				a1 = (2.0 * (cos(theta))) * rho;
				a2 = 0.0 - (rho * rho);
				x2 = 0.0;
				x1 = rho * (sin(theta));
				gamma = exp(-1.0 / (ra * t0));
				gammapwr = pow(gamma,(t0 - te));
				b1 = gamma;
				c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);
				/* begin normalizeGlottalPulse */
				s0 = 0.0;
				s1 = x1;
				s2 = x2;
				for (ingore = 1; ingore <= nopen; ingore += 1) {
					s0 = (a1 * s1) + (a2 * s2);
					s2 = s1;
					s1 = s0;
				}
				if (!(s0 == 0.0)) {
					x1 = (x1 / s0) * 10000.0;
				}
				/* begin addShimmer */

				/* x1 must be <= 0 */
				x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
				if (x1 > 0) {
					x1 = 0;
				}
				/* begin addAmplitudeDiplophonia */
				if (!((periodCount % 2) == 0)) {

					/* x1 must be <= 0 */
					x1 = x1 * (1.0 - (frame[Diplophonia]));
					if (x1 > 0) {
						x1 = 0;
					}
				}
				periodCount = (periodCount + 1) % 0xFFFF;
			}
			else {
				t0 = 1;
				nmod = t0;
			}
		}
		nper += 1;
		voice = x0;
	l25:	/* end glottalSource */;

		/* Add turbulence during glottal open phase.
		   Use random rather than noise because noise is low-passed. */
		vlast = voice;
		if (nper < nopen) {
			voice += (turbulence * (((double) ((nextRandom()) - 32768) ))) / 4.0;
		}
		glotout = voicing * voice;

		/* Compute aspiration amplitude and add to voicing source. */
		parGlotout = parVoicing * voice;
		aspirationNoise = aspiration * noise;
		glotout += aspirationNoise;

		/* Cascade vocal tract, excited by laryngeal sources.
		   Nasal antiresonator, nasal resonator, trachearl antirresonator,
		   tracheal resonator, then formants F8, F7, F6, F5, F4, F3, F2, F1. */
		parGlotout += aspirationNoise;
		/* begin cascadeBranch: */
		if (!(cascade > 0)) {
			out = 0.0;
			goto l17;
		}
		/* begin antiResonator:value: */
		answer8 = (((resonatorA(Rnz)) * glotout) + ((resonatorB(Rnz)) * ((p18 = resonatorP1(Rnz))))) + ((resonatorC(Rnz)) * (resonatorP2(Rnz)));
		/* begin resonatorP2:put: */
		resonators[(Rnz * 5) - 1] = p18;
		/* begin resonatorP1:put: */
		resonators[(Rnz * 5) - 2] = glotout;
		out1 = answer8;
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer9 = (((resonatorA(Rnpc)) * out1) + ((resonatorB(Rnpc)) * ((p19 = resonatorP1(Rnpc))))) + ((resonatorC(Rnpc)) * (resonatorP2(Rnpc)));
		resonators[(Rnpc * 5) - 1] = p19;
		/* begin resonatorP1:put: */
		resonators[(Rnpc * 5) - 2] = answer9;
		out1 = answer9;
		/* begin antiResonator:value: */
		answer10 = (((resonatorA(Rtz)) * out1) + ((resonatorB(Rtz)) * ((p110 = resonatorP1(Rtz))))) + ((resonatorC(Rtz)) * (resonatorP2(Rtz)));
		/* begin resonatorP2:put: */
		resonators[(Rtz * 5) - 1] = p110;
		/* begin resonatorP1:put: */
		resonators[(Rtz * 5) - 2] = out1;
		out1 = answer10;
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer11 = (((resonatorA(Rtpc)) * out1) + ((resonatorB(Rtpc)) * ((p111 = resonatorP1(Rtpc))))) + ((resonatorC(Rtpc)) * (resonatorP2(Rtpc)));
		resonators[(Rtpc * 5) - 1] = p111;
		/* begin resonatorP1:put: */
		resonators[(Rtpc * 5) - 2] = answer11;
		out1 = answer11;
		if (cascade >= 8) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer12 = (((resonatorA(R8c)) * out1) + ((resonatorB(R8c)) * ((p112 = resonatorP1(R8c))))) + ((resonatorC(R8c)) * (resonatorP2(R8c)));
			resonators[(R8c * 5) - 1] = p112;
			/* begin resonatorP1:put: */
			resonators[(R8c * 5) - 2] = answer12;
			out1 = answer12;
		}
		if (cascade >= 7) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer1 = (((resonatorA(R7c)) * out1) + ((resonatorB(R7c)) * ((p11 = resonatorP1(R7c))))) + ((resonatorC(R7c)) * (resonatorP2(R7c)));
			resonators[(R7c * 5) - 1] = p11;
			/* begin resonatorP1:put: */
			resonators[(R7c * 5) - 2] = answer1;
			out1 = answer1;
		}
		if (cascade >= 6) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer2 = (((resonatorA(R6c)) * out1) + ((resonatorB(R6c)) * ((p12 = resonatorP1(R6c))))) + ((resonatorC(R6c)) * (resonatorP2(R6c)));
			resonators[(R6c * 5) - 1] = p12;
			/* begin resonatorP1:put: */
			resonators[(R6c * 5) - 2] = answer2;
			out1 = answer2;
		}
		if (cascade >= 5) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer3 = (((resonatorA(R5c)) * out1) + ((resonatorB(R5c)) * ((p13 = resonatorP1(R5c))))) + ((resonatorC(R5c)) * (resonatorP2(R5c)));
			resonators[(R5c * 5) - 1] = p13;
			/* begin resonatorP1:put: */
			resonators[(R5c * 5) - 2] = answer3;
			out1 = answer3;
		}
		if (cascade >= 4) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer4 = (((resonatorA(R4c)) * out1) + ((resonatorB(R4c)) * ((p14 = resonatorP1(R4c))))) + ((resonatorC(R4c)) * (resonatorP2(R4c)));
			resonators[(R4c * 5) - 1] = p14;
			/* begin resonatorP1:put: */
			resonators[(R4c * 5) - 2] = answer4;
			out1 = answer4;
		}
		if (cascade >= 3) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer5 = (((resonatorA(R3c)) * out1) + ((resonatorB(R3c)) * ((p15 = resonatorP1(R3c))))) + ((resonatorC(R3c)) * (resonatorP2(R3c)));
			resonators[(R3c * 5) - 1] = p15;
			/* begin resonatorP1:put: */
			resonators[(R3c * 5) - 2] = answer5;
			out1 = answer5;
		}
		if (cascade >= 2) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer6 = (((resonatorA(R2c)) * out1) + ((resonatorB(R2c)) * ((p16 = resonatorP1(R2c))))) + ((resonatorC(R2c)) * (resonatorP2(R2c)));
			resonators[(R2c * 5) - 1] = p16;
			/* begin resonatorP1:put: */
			resonators[(R2c * 5) - 2] = answer6;
			out1 = answer6;
		}
		if (cascade >= 1) {
			/* begin resonator:value: */

			/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
			   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
			answer7 = (((resonatorA(R1c)) * out1) + ((resonatorB(R1c)) * ((p17 = resonatorP1(R1c))))) + ((resonatorC(R1c)) * (resonatorP2(R1c)));
			resonators[(R1c * 5) - 1] = p17;
			/* begin resonatorP1:put: */
			resonators[(R1c * 5) - 2] = answer7;
			out1 = answer7;
		}
		out = out1;
	l17:	/* end cascadeBranch: */;

		/* Source is voicing plus aspiration. */
		source = parGlotout;

		/* Friction-excited parallel vocal tract formants F6, F5, F4, F3, F2,
		   outputs added with alternating sign. Sound source for other
		   parallel resonators is friction plus first difference of
		   voicing waveform. */
		out += parallelVoicedBranch(source);
		source = (frictionNoise + parGlotout) - glast;
		glast = parGlotout;

		/* Apply bypas and output low-pass filter */
		out = (parallelFrictionBranch(source)) - out;
		out = (bypass * source) - out;
		/* begin resonator:value: */

		/* (p1 between: -100000 and: 100000) ifFalse: [self halt].
		   (answer between: -100000 and: 100000) ifFalse: [self halt]. */
		answer = (((resonatorA(Rout)) * out) + ((resonatorB(Rout)) * ((p1 = resonatorP1(Rout))))) + ((resonatorC(Rout)) * (resonatorP2(Rout)));
		resonators[(Rout * 5) - 1] = p1;
		/* begin resonatorP1:put: */
		resonators[(Rout * 5) - 2] = answer;
		out = answer;
		temp = ((sqInt)(out * ampGain));
		if (temp < -32768) {
			temp = -32768;
		}
		if (temp > 0x7FFF) {
			temp = 0x7FFF;
		}
		buffer[index - 1] = temp;
		index += 1;
		samplesCount += 1;
	}
}


/*	Set the pitch. */

	/* KlattSynthesizerPlugin>>#voicedPitchSynchronousReset */
static void
voicedPitchSynchronousReset(void)
{
    float asin;
    float bsin;
    float cosphi;
    float csin;
    float d;
    double deltaF0;
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float gamma;
    float gammapwr;
    sqInt ingore;
    float phi;
    float qa;
    float qb;
    float qc;
    float qzero;
    float r;
    float ra;
    float rho;
    float rk;
    float ro;
    float rphid;
    float s0;
    float s1;
    float s2;
    float sinphi;
    sqInt te;
    float theta;
    float timeCount;
    float u;
    float ua;
    float ub;
    float uc;


	/* Add flutter and jitter (F0 perturbations). */
	pitch = frame[F0];
	/* begin addFlutter */
	timeCount = (((float) samplesCount)) / (((float) samplingRate));
	asin = sin(((2.0 * PI) * 12.7) * timeCount);
	bsin = sin(((2.0 * PI) * 7.1) * timeCount);
	csin = sin(((2.0 * PI) * 4.7) * timeCount);
	deltaF0 = ((((frame[Flutter]) * 2.0) * (frame[F0])) / 100.0) * ((asin + bsin) + csin);
	pitch += deltaF0;
	/* begin addJitter */
	pitch += ((((nextRandom()) - 0x7FFF) * (frame[Jitter])) / 32768.0) * (frame[F0]);
	/* begin addFrequencyDiplophonia */
	if ((periodCount % 2) == 0) {
		pitch += ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
	}
	else {
		pitch -= ((frame[Diplophonia]) * (frame[F0])) * (1.0 - (frame[Ro]));
	}
	if (pitch < 0) {
		pitch = 0;
	}

	/* Duration of period before amplitude modulation. */
	t0 = ((sqInt)(samplingRate / pitch));
	nmod = t0;
	if ((frame[Voicing]) > 0) {
		nmod = nmod / 2;
	}

	/* Set the LF glottal pulse model parameters. */
	nopen = ((sqInt)(t0 * (frame[Ro])));
	/* begin ro:ra:rk: */
	te = ((sqInt)(t0 * (frame[Ro])));
	ro = (((double) te )) / (((double) t0 ));
	rk = frame[Rk];
	ra = frame[Ra];
	if (ra <= 0.0) {
		d = 1.0;
	}
	else {
		r = (1.0 - ro) / ra;
		d = 1.0 - (r / ((exp(r)) - 1.0));
	}
	phi = PI * (rk + 1.0);
	cosphi = cos(phi);
	sinphi = sin(phi);
	rphid = ((ra / ro) * phi) * d;
	/* begin zeroQphi:cosphi:sinphi:rphid: */
	expuphi5 = exp(0 * phi);
	qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
	if (qzero > 0) {
		ua = 0;
		ub = 1;
		qa = qzero;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi1 = exp(ub * phi);
		qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
		while (qb > 0) {
			ua = ub;
			qa = qb;
			ub = ub * 2;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi = exp(ub * phi);
			qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
		}
	}
	else {
		ua = -1;
		ub = 0;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi3 = exp(ua * phi);
		qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
		qb = qzero;
		while (qa < 0) {
			ub = ua;
			qb = qa;
			ua = ua * 2;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi2 = exp(ua * phi);
			qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
		}
	}
	while ((ub - ua) > Epsilon) {
		uc = (ub + ua) / 2.0;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi4 = exp(uc * phi);
		qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
		if (qc > 0) {
			ua = uc;
			qa = qc;
		}
		else {
			ub = uc;
			qb = qc;
		}
	}
	u = (ub + ua) / 2.0;
	theta = phi / te;
	rho = exp(u * theta);
	a1 = (2.0 * (cos(theta))) * rho;
	a2 = 0.0 - (rho * rho);
	x2 = 0.0;
	x1 = rho * (sin(theta));
	gamma = exp(-1.0 / (ra * t0));
	gammapwr = pow(gamma,(t0 - te));
	b1 = gamma;
	c1 = ((1.0 - gamma) * gammapwr) / (1.0 - gammapwr);
	/* begin normalizeGlottalPulse */
	s0 = 0.0;
	s1 = x1;
	s2 = x2;
	for (ingore = 1; ingore <= nopen; ingore += 1) {
		s0 = (a1 * s1) + (a2 * s2);
		s2 = s1;
		s1 = s0;
	}
	if (!(s0 == 0.0)) {
		x1 = (x1 / s0) * 10000.0;
	}
	/* begin addShimmer */

	/* x1 must be <= 0 */
	x1 += ((((nextRandom()) - 0x7FFF) * (frame[Shimmer])) / 32768.0) * x1;
	if (x1 > 0) {
		x1 = 0;
	}
	/* begin addAmplitudeDiplophonia */
	if (!((periodCount % 2) == 0)) {

		/* x1 must be <= 0 */
		x1 = x1 * (1.0 - (frame[Diplophonia]));
		if (x1 > 0) {
			x1 = 0;
		}
	}
}

	/* KlattSynthesizerPlugin>>#zeroQphi:cosphi:sinphi:rphid: */
static float
zeroQphicosphisinphirphid(float phi, float cosphi, float sinphi, float rphid)
{
    float expuphi;
    float expuphi1;
    float expuphi2;
    float expuphi3;
    float expuphi4;
    float expuphi5;
    float qa;
    float qb;
    float qc;
    float qzero;
    float ua;
    float ub;
    float uc;

	/* begin qu:phi:cosphi:sinphi:rphid: */
	expuphi5 = exp(0 * phi);
	qzero = (expuphi5 * ((((rphid)) * sinphi) - cosphi)) + 1.0;
	if (qzero > 0) {
		ua = 0;
		ub = 1;
		qa = qzero;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi1 = exp(ub * phi);
		qb = (expuphi1 * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
		while (qb > 0) {
			ua = ub;
			qa = qb;
			ub = ub * 2;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi = exp(ub * phi);
			qb = (expuphi * ((((rphid * ((ub * ub) + 1.0)) + ub) * sinphi) - cosphi)) + 1.0;
		}
	}
	else {
		ua = -1;
		ub = 0;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi3 = exp(ua * phi);
		qa = (expuphi3 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
		qb = qzero;
		while (qa < 0) {
			ub = ua;
			qb = qa;
			ua = ua * 2;
			/* begin qu:phi:cosphi:sinphi:rphid: */
			expuphi2 = exp(ua * phi);
			qa = (expuphi2 * ((((rphid * ((ua * ua) + 1.0)) + ua) * sinphi) - cosphi)) + 1.0;
		}
	}
	while ((ub - ua) > Epsilon) {
		uc = (ub + ua) / 2.0;
		/* begin qu:phi:cosphi:sinphi:rphid: */
		expuphi4 = exp(uc * phi);
		qc = (expuphi4 * ((((rphid * ((uc * uc) + 1.0)) + uc) * sinphi) - cosphi)) + 1.0;
		if (qc > 0) {
			ua = uc;
			qa = qc;
		}
		else {
			ub = uc;
			qb = qc;
		}
	}
	return (ub + ua) / 2.0;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "Klatt";
void* Klatt_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveSynthesizeFrameIntoStartingAt\000\001", (void*)primitiveSynthesizeFrameIntoStartingAt},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveSynthesizeFrameIntoStartingAtAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
