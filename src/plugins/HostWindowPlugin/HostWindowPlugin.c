/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.3024 uuid: 417aa150-be4e-4631-b35b-948afa18e190
   from
	HostWindowPlugin VMMaker.oscog-eem.3024 uuid: 417aa150-be4e-4631-b35b-948afa18e190
 */
static char __buildInfo[] = "HostWindowPlugin VMMaker.oscog-eem.3024 uuid: 417aa150-be4e-4631-b35b-948afa18e190 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "HostWindowPlugin.h"
#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrNoMemory 9


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primitiveCloseHostWindow(void);
EXPORT(sqInt) primitiveCreateHostWindow(void);
EXPORT(sqInt) primitiveHostWindowIcon(void);
EXPORT(sqInt) primitiveHostWindowPosition(void);
EXPORT(sqInt) primitiveHostWindowPositionSet(void);
#if TerfVM
EXPORT(sqInt) primitiveHostWindowScreenWorkAreaPosition(void);
#endif /* TerfVM */
#if TerfVM
EXPORT(sqInt) primitiveHostWindowScreenWorkAreaSize(void);
#endif /* TerfVM */
EXPORT(sqInt) primitiveHostWindowSize(void);
EXPORT(sqInt) primitiveHostWindowSizeSet(void);
EXPORT(sqInt) primitiveHostWindowTitle(void);
#if TerfVM
EXPORT(sqInt) primitiveNativeDisplayPosition(void);
#endif /* TerfVM */
#if TerfVM
EXPORT(sqInt) primitiveNativeDisplaySize(void);
#endif /* TerfVM */
#if TerfVM
EXPORT(sqInt) primitiveNativeWindowPosition(void);
#endif /* TerfVM */
#if TerfVM
EXPORT(sqInt) primitiveNativeWindowSize(void);
#endif /* TerfVM */
#if TerfVM
EXPORT(sqInt) primitiveScreenRectangles(void);
#endif /* TerfVM */
EXPORT(sqInt) primitiveSetCursorPosition(void);
EXPORT(sqInt) primitiveShowHostWindowRect(void);
#if TerfVM
EXPORT(sqInt) primitiveSqueakWindowHandle(void);
#endif /* TerfVM */
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
EXPORT(sqInt) shutdownModule(void);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*failed)(void);
static void * (*firstIndexableField)(sqInt oop);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static sqInt (*isBytes)(sqInt oop);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isPositiveMachineIntegerObject)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*makePointwithxValueyValue)(sqInt xValue, sqInt yValue);
static sqInt (*methodReturnInteger)(sqInt integer);
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*pop)(sqInt nItems);
static sqInt (*positive32BitIntegerFor)(unsigned int integerValue);
static usqInt (*positive32BitValueOf)(sqInt oop);
static sqInt (*positive64BitIntegerFor)(usqLong integerValue);
static usqLong (*positive64BitValueOf)(sqInt oop);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stackValue)(sqInt offset);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt failed(void);
extern void * firstIndexableField(sqInt oop);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern sqInt isBytes(sqInt oop);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
extern sqInt isPositiveMachineIntegerObject(sqInt oop);
#else
# define isPositiveMachineIntegerObject(oop) 0
#endif
extern sqInt isWords(sqInt oop);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt pop(sqInt nItems);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern usqInt positive32BitValueOf(sqInt oop);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern usqLong positive64BitValueOf(sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stackValue(sqInt offset);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "HostWindowPlugin VMMaker.oscog-eem.3024 " INT_EXT;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	Close a host window. windowIndex is the SmallInt handle returned
	previously by primitiveCreateHostWindow. Fail if the index is invalid or
	the platform code fails
 */

	/* HostWindowPlugin>>#primitiveCloseHostWindow: */
EXPORT(sqInt)
primitiveCloseHostWindow(void)
{
	sqInt ok;
	sqInt windowIndex;

	if (!(isIntegerObject((windowIndex = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowIndex = integerValueOf(windowIndex);
	ok = closeWindow(windowIndex);
	if (!ok) {
		primitiveFail();
	}
	if (!(failed())) {
		pop(1);
	}
	return null;
}


/*	Create a host window of width 'w' pixels, height 'h' with the origin of
	the user area at 'x@y' from the topleft corner of the screen.
	Return the SmallInt value of the internal index to the window description
	block - which is whatever the host platform code needs it to be.
 */

	/* HostWindowPlugin>>#primitiveCreateHostWindowWidth:height:originX:y:attributes: */
EXPORT(sqInt)
primitiveCreateHostWindow(void)
{
	sqInt h;
	char *list;
	sqInt listLength;
	sqInt w;
	sqInt windowIndex;
	sqInt x;
	sqInt y;

	if (!((isIntegerObject((w = stackValue(4))))
		 && ((isIntegerObject((h = stackValue(3))))
		 && ((isIntegerObject((x = stackValue(2))))
		 && ((isIntegerObject((y = stackValue(1))))
		 && (isBytes(stackValue(0)))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	w = integerValueOf(w);
	h = integerValueOf(h);
	x = integerValueOf(x);
	y = integerValueOf(y);
	list = ((char *) (firstIndexableField(stackValue(0))));
	listLength = slotSizeOf(((sqInt)(sqIntptr_t)(list) - BaseHeaderSize));
	windowIndex = createWindowWidthheightoriginXyattrlength(w, h, x, y, list, listLength);
	if (windowIndex > 0) {
		methodReturnInteger(windowIndex);
		return null;
	}
	else {
		return primitiveFail();
	}
}


/*	Set the icon of the window by fetching the logo in given path. Fail if the
	windowIndex is invalid or the platform routine returns -1 to indicate
	failure 
 */

	/* HostWindowPlugin>>#primitiveHostWindowIcon:path: */
EXPORT(sqInt)
primitiveHostWindowIcon(void)
{
	sqInt id;
	sqInt pathLength;
	char *pathString;
	sqInt res;

	if (!((isIntegerObject((id = stackValue(1))))
		 && (isBytes(stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	id = integerValueOf(id);
	pathString = ((char *) (firstIndexableField(stackValue(0))));
	pathLength = slotSizeOf(((sqInt)(sqIntptr_t)(pathString) - BaseHeaderSize));
	res = ioSetIconOfWindow(id, pathString, pathLength);
	if (res == 0) {
		if (!(failed())) {
			pop(2);
		}
		return null;
	}
	if (res == -1) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	return primitiveFail();
}


/*	Return the origin position of the user area of the window in pixels from
	the topleft corner of the screen. Fail if the windowIndex is invalid or
	the platform routine returns -1 to indicate failure
 */

	/* HostWindowPlugin>>#primitiveHostWindowPosition: */
EXPORT(sqInt)
primitiveHostWindowPosition(void)
{
	sqInt pos;
	sqInt windowIndex;
	sqInt _return_value;

	if (!(isIntegerObject((windowIndex = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowIndex = integerValueOf(windowIndex);
	pos = ioPositionOfWindow(windowIndex);
	if (pos == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(pos)) >> 16)), ((short) (pos & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}


/*	Set the origin position of the user area of the window in pixels from the
	topleft corner of the screen- return the position actually set by the
	OS/GUI/window manager. Fail if the windowIndex is invalid or the platform
	routine returns -1 to indicate failure
 */

	/* HostWindowPlugin>>#primitiveHostWindowPositionSet:x:y: */
EXPORT(sqInt)
primitiveHostWindowPositionSet(void)
{
	sqInt pos;
	sqInt windowIndex;
	sqInt x;
	sqInt y;
	sqInt _return_value;

	if (!((isIntegerObject((windowIndex = stackValue(2))))
		 && ((isIntegerObject((x = stackValue(1))))
		 && (isIntegerObject((y = stackValue(0))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowIndex = integerValueOf(windowIndex);
	x = integerValueOf(x);
	y = integerValueOf(y);
	pos = ioPositionOfWindowSetxy(windowIndex, x, y);
	if (pos == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(pos)) >> 16)), ((short) (pos & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}


/*	Answer the platform's notion of the available work area on the screen
	containing the given window.
 */

	/* HostWindowPlugin>>#primitiveHostWindowScreenWorkAreaPosition: */
#if TerfVM
EXPORT(sqInt)
primitiveHostWindowScreenWorkAreaPosition(void)
{
	sqInt size;
	sqInt windex;
	sqInt _return_value;

	if (!(isIntegerObject((windex = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windex = integerValueOf(windex);
	size = ioPositionOfScreenWorkArea(windex);
	if (size == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(size)) >> 16)), ((short) (size & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Answer the platform's notion of the available work area on the screen
	containing the given window.
 */

	/* HostWindowPlugin>>#primitiveHostWindowScreenWorkAreaSize: */
#if TerfVM
EXPORT(sqInt)
primitiveHostWindowScreenWorkAreaSize(void)
{
	sqInt size;
	sqInt windex;
	sqInt _return_value;

	if (!(isIntegerObject((windex = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windex = integerValueOf(windex);
	size = ioSizeOfScreenWorkArea(windex);
	if (size == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(size)) >> 16)), ((short) (size & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Return the size of the user area of the window in pixels. Fail if the
	windowIndex is invalid or the platform routine returns -1 to indicate
	failure 
 */

	/* HostWindowPlugin>>#primitiveHostWindowSize: */
EXPORT(sqInt)
primitiveHostWindowSize(void)
{
	sqInt size;
	sqInt windowIndex;
	sqInt _return_value;

	if (!(isIntegerObject((windowIndex = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowIndex = integerValueOf(windowIndex);
	size = ioSizeOfWindow(windowIndex);
	if (size == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(size)) >> 16)), ((short) (size & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}


/*	Set the size of the user area of the window in pixels - return what is
	actually set by the OS/GUI/window manager. Fail if the windowIndex is
	invalid or the platform routine returns -1 to indicate failure
 */

	/* HostWindowPlugin>>#primitiveHostWindowSizeSet:x:y: */
EXPORT(sqInt)
primitiveHostWindowSizeSet(void)
{
	sqInt size;
	sqInt windowIndex;
	sqInt x;
	sqInt y;
	sqInt _return_value;

	if (!((isIntegerObject((windowIndex = stackValue(2))))
		 && ((isIntegerObject((x = stackValue(1))))
		 && (isIntegerObject((y = stackValue(0))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowIndex = integerValueOf(windowIndex);
	x = integerValueOf(x);
	y = integerValueOf(y);
	size = ioSizeOfWindowSetxy(windowIndex, x, y);
	if (size == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(size)) >> 16)), ((short) (size & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}


/*	Set the title bar label of the window. Fail if the windowIndex is invalid
	or the platform routine returns -1 to indicate failure
 */

	/* HostWindowPlugin>>#primitiveHostWindowTitle:string: */
EXPORT(sqInt)
primitiveHostWindowTitle(void)
{
	sqInt id;
	sqInt titleLength;
	char *titleString;

	if (!((isIntegerObject((id = stackValue(1))))
		 && (isBytes(stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	id = integerValueOf(id);
	titleString = ((char *) (firstIndexableField(stackValue(0))));
	titleLength = slotSizeOf(((sqInt)(sqIntptr_t)(titleString) - BaseHeaderSize));
	if ((ioSetTitleOfWindow(id, titleString, titleLength)) == -1) {
		primitiveFail();
	}
	if (!(failed())) {
		pop(2);
	}
	return null;
}


/*	Answer the origin position of the user area of the given native window in
	pixels from the topleft corner of the screen.
	Fail if the windowHandle is invalid or the platform routine returns -1 to
	indicate failure
 */

	/* HostWindowPlugin>>#primitiveNativeDisplayPosition: */
#if TerfVM
EXPORT(sqInt)
primitiveNativeDisplayPosition(void)
{
	sqInt pos;
	usqIntptr_t windowHandle;
	sqInt _return_value;

	if (!(isPositiveMachineIntegerObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowHandle = (BytesPerOop == 4
		? positive32BitValueOf(stackValue(0))
		: positive64BitValueOf(stackValue(0)));
	pos = ioPositionOfNativeDisplay(windowHandle);
	if (pos == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(pos)) >> 16)), ((short) (pos & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Answer the size of the user area of the given native window in pixels.
	Fail if the windowHandle is invalid or the platform routine returns -1 to
	indicate failure */

	/* HostWindowPlugin>>#primitiveNativeDisplaySize: */
#if TerfVM
EXPORT(sqInt)
primitiveNativeDisplaySize(void)
{
	sqInt size;
	usqIntptr_t windowHandle;
	sqInt _return_value;

	if (!(isPositiveMachineIntegerObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowHandle = (BytesPerOop == 4
		? positive32BitValueOf(stackValue(0))
		: positive64BitValueOf(stackValue(0)));
	size = ioSizeOfNativeDisplay(windowHandle);
	if (size == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(size)) >> 16)), ((short) (size & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Answer the origin position of the given native window in pixels from the
	topleft corner of the screen.
	Fail if the windowHandle is invalid or the platform routine returns -1 to
	indicate failure
 */

	/* HostWindowPlugin>>#primitiveNativeWindowPosition: */
#if TerfVM
EXPORT(sqInt)
primitiveNativeWindowPosition(void)
{
	sqInt pos;
	usqIntptr_t windowHandle;
	sqInt _return_value;

	if (!(isPositiveMachineIntegerObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowHandle = (BytesPerOop == 4
		? positive32BitValueOf(stackValue(0))
		: positive64BitValueOf(stackValue(0)));
	pos = ioPositionOfNativeWindow(windowHandle);
	if (pos == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(pos)) >> 16)), ((short) (pos & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Answer the size of the given native window in pixels.
	Fail if the windowHandle is invalid or the platform routine returns -1 to
	indicate failure */

	/* HostWindowPlugin>>#primitiveNativeWindowSize: */
#if TerfVM
EXPORT(sqInt)
primitiveNativeWindowSize(void)
{
	sqInt size;
	usqIntptr_t windowHandle;
	sqInt _return_value;

	if (!(isPositiveMachineIntegerObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowHandle = (BytesPerOop == 4
		? positive32BitValueOf(stackValue(0))
		: positive64BitValueOf(stackValue(0)));
	size = ioSizeOfNativeWindow(windowHandle);
	if (size == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin pointFromCompactPointEncoding: */
		_return_value = makePointwithxValueyValue(((short) (((usqInt)(size)) >> 16)), ((short) (size & 0xFFFF)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Answer an Array of pairs of packed x,y repreeentation origins and extents
	for all the available monitors.
 */

	/* HostWindowPlugin>>#primitiveScreenRectangles */
#if TerfVM
EXPORT(sqInt)
primitiveScreenRectangles(void)
{
	sqInt screenRectangles;

	screenRectangles = ioScreenRectangles();
	if (screenRectangles == null) {
		primitiveFailFor(PrimErrNoMemory);
	}
	else {
		methodReturnValue(screenRectangles);
	}
	return 0;
}
#endif /* TerfVM */


/*	Set the position of the cursor to the specified position on the desktop
	(*not* the display).
	Fail if the platform routine returns -1 to indicate failure. */

	/* HostWindowPlugin>>#primitiveSetCursorPositionX:Y: */
EXPORT(sqInt)
primitiveSetCursorPosition(void)
{
	sqInt result;
	sqInt x;
	sqInt y;

	if (!((isIntegerObject((x = stackValue(1))))
		 && (isIntegerObject((y = stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	x = integerValueOf(x);
	y = integerValueOf(y);
	result = ioSetCursorPositionXY(x, y);
	if (result == -1) {
		return primitiveFail();
	}
	if (!(failed())) {
		pop(2);
	}
	return null;
}


/*	Host window analogue of DisplayScreen> primShowRectLeft:right:top:bottom:
	(Interpreter>primitiveShowDisplayRect) which takes the window index,
	bitmap details and the rectangle bounds. Fail if the windowIndex is
	invalid or the
	platform routine returns false to indicate failure
 */

	/* HostWindowPlugin>>#primitiveShowHostWindow:bits:width:height:depth:left:right:top:bottom: */
EXPORT(sqInt)
primitiveShowHostWindowRect(void)
{
	sqInt bottom;
	sqInt d;
	unsigned *dispBits;
	sqInt h;
	sqInt left;
	sqInt right;
	sqInt top;
	sqInt w;
	sqInt windowIndex;

	if (!((isIntegerObject((windowIndex = stackValue(8))))
		 && ((isWords(stackValue(7)))
		 && ((isIntegerObject((w = stackValue(6))))
		 && ((isIntegerObject((h = stackValue(5))))
		 && ((isIntegerObject((d = stackValue(4))))
		 && ((isIntegerObject((left = stackValue(3))))
		 && ((isIntegerObject((right = stackValue(2))))
		 && ((isIntegerObject((top = stackValue(1))))
		 && (isIntegerObject((bottom = stackValue(0))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	windowIndex = integerValueOf(windowIndex);
	dispBits = ((unsigned *) (firstIndexableField(stackValue(7))));
	w = integerValueOf(w);
	h = integerValueOf(h);
	d = integerValueOf(d);
	left = integerValueOf(left);
	right = integerValueOf(right);
	top = integerValueOf(top);
	bottom = integerValueOf(bottom);
	if (!(ioShowDisplayOnWindow(dispBits, w, h, d, left, right, top, bottom, windowIndex))) {
		primitiveFail();
	}
	if (!(failed())) {
		pop(9);
	}
	return null;
}


/*	Answer the native Squeak window handle, presumably a pointer, as an
	unsigned integer.
	This value should be usable in native calls to the window manager as well
	as the argument to primitiveNativeWindowPosition: */

	/* HostWindowPlugin>>#primitiveSqueakWindowHandle */
#if TerfVM
EXPORT(sqInt)
primitiveSqueakWindowHandle(void)
{
	void *handle;
	sqInt _return_value;

	handle = ioGetWindowHandle();
	if (handle == 0) {
		return primitiveFail();
	}
	if (!(failed())) {
		/* begin positiveMachineIntegerFor: */
		_return_value = (BytesPerWord == 8
			? positive64BitIntegerFor(((sqInt) handle))
			: positive32BitIntegerFor(((sqInt) handle)));
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}
#endif /* TerfVM */


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
	sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		failed = interpreterProxy->failed;
		firstIndexableField = interpreterProxy->firstIndexableField;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		isBytes = interpreterProxy->isBytes;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
		isPositiveMachineIntegerObject = interpreterProxy->isPositiveMachineIntegerObject;
#else
#if !defined(isPositiveMachineIntegerObject)
		isPositiveMachineIntegerObject = 0;
#endif
#endif
		isWords = interpreterProxy->isWords;
		makePointwithxValueyValue = interpreterProxy->makePointwithxValueyValue;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnValue = interpreterProxy->methodReturnValue;
		pop = interpreterProxy->pop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		positive64BitIntegerFor = interpreterProxy->positive64BitIntegerFor;
		positive64BitValueOf = interpreterProxy->positive64BitValueOf;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackValue = interpreterProxy->stackValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


/*	do any window related VM closing down work your platform requires. */

	/* HostWindowPlugin>>#shutdownModule */
EXPORT(sqInt)
shutdownModule(void)
{
	return ioCloseAllWindows();
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "HostWindowPlugin";
void* HostWindowPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveCloseHostWindow\000\000\000", (void*)primitiveCloseHostWindow},
	{(void*)_m, "primitiveCreateHostWindow\000\000\000", (void*)primitiveCreateHostWindow},
	{(void*)_m, "primitiveHostWindowIcon\000\000\000", (void*)primitiveHostWindowIcon},
	{(void*)_m, "primitiveHostWindowPosition\000\000\000", (void*)primitiveHostWindowPosition},
	{(void*)_m, "primitiveHostWindowPositionSet\000\000\000", (void*)primitiveHostWindowPositionSet},
#if TerfVM
	{(void*)_m, "primitiveHostWindowScreenWorkAreaPosition\000\000\000", (void*)primitiveHostWindowScreenWorkAreaPosition},
#endif /* TerfVM */
#if TerfVM
	{(void*)_m, "primitiveHostWindowScreenWorkAreaSize\000\000\000", (void*)primitiveHostWindowScreenWorkAreaSize},
#endif /* TerfVM */
	{(void*)_m, "primitiveHostWindowSize\000\000\000", (void*)primitiveHostWindowSize},
	{(void*)_m, "primitiveHostWindowSizeSet\000\000\000", (void*)primitiveHostWindowSizeSet},
	{(void*)_m, "primitiveHostWindowTitle\000\000\000", (void*)primitiveHostWindowTitle},
#if TerfVM
	{(void*)_m, "primitiveNativeDisplayPosition\000\377\000", (void*)primitiveNativeDisplayPosition},
#endif /* TerfVM */
#if TerfVM
	{(void*)_m, "primitiveNativeDisplaySize\000\377\000", (void*)primitiveNativeDisplaySize},
#endif /* TerfVM */
#if TerfVM
	{(void*)_m, "primitiveNativeWindowPosition\000\377\000", (void*)primitiveNativeWindowPosition},
#endif /* TerfVM */
#if TerfVM
	{(void*)_m, "primitiveNativeWindowSize\000\377\000", (void*)primitiveNativeWindowSize},
#endif /* TerfVM */
#if TerfVM
	{(void*)_m, "primitiveScreenRectangles\000\377\000", (void*)primitiveScreenRectangles},
#endif /* TerfVM */
	{(void*)_m, "primitiveSetCursorPosition\000\000\000", (void*)primitiveSetCursorPosition},
	{(void*)_m, "primitiveShowHostWindowRect\000\000\000", (void*)primitiveShowHostWindowRect},
#if TerfVM
	{(void*)_m, "primitiveSqueakWindowHandle\000\377\000", (void*)primitiveSqueakWindowHandle},
#endif /* TerfVM */
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveCloseHostWindowMetadata = 0;
EXPORT(signed short) primitiveCreateHostWindowMetadata = 0;
EXPORT(signed short) primitiveHostWindowIconMetadata = 0;
EXPORT(signed short) primitiveHostWindowPositionMetadata = 0;
EXPORT(signed short) primitiveHostWindowPositionSetMetadata = 0;
#if TerfVM
EXPORT(signed short) primitiveHostWindowScreenWorkAreaPositionMetadata = 0;
#endif /* TerfVM */
#if TerfVM
EXPORT(signed short) primitiveHostWindowScreenWorkAreaSizeMetadata = 0;
#endif /* TerfVM */
EXPORT(signed short) primitiveHostWindowSizeMetadata = 0;
EXPORT(signed short) primitiveHostWindowSizeSetMetadata = 0;
EXPORT(signed short) primitiveHostWindowTitleMetadata = 0;
EXPORT(signed short) primitiveSetCursorPositionMetadata = 0;
EXPORT(signed short) primitiveShowHostWindowRectMetadata = 0;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
