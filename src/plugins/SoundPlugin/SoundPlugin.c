/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker-oscog.8 uuid: b336429e-652e-4551-8d38-a00ef67eaa61
   from
	SoundPlugin VMMaker-oscog.8 uuid: b336429e-652e-4551-8d38-a00ef67eaa61
 */
static char __buildInfo[] = "SoundPlugin VMMaker-oscog.8 uuid: b336429e-652e-4551-8d38-a00ef67eaa61 " __DATE__ ;




#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif
#include "SoundPlugin.h"

#include "sqMemoryAccess.h"



/*** Constants ***/


/*** Function Prototypes ***/
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt msg(char *s);
EXPORT(sqInt) primitiveGetDefaultSoundPlayer(void);
EXPORT(sqInt) primitiveGetDefaultSoundRecorder(void);
EXPORT(sqInt) primitiveGetNumberOfSoundPlayerDevices(void);
EXPORT(sqInt) primitiveGetNumberOfSoundRecorderDevices(void);
EXPORT(sqInt) primitiveGetSoundPlayerDeviceName(void);
EXPORT(sqInt) primitiveGetSoundRecorderDeviceName(void);
EXPORT(sqInt) primitiveSetDefaultSoundPlayer(void);
EXPORT(sqInt) primitiveSetDefaultSoundRecorder(void);
EXPORT(sqInt) primitiveSoundAvailableSpace(void);
EXPORT(sqInt) primitiveSoundEnableAEC(void);
EXPORT(sqInt) primitiveSoundGetRecordingSampleRate(void);
EXPORT(sqInt) primitiveSoundGetRecordLevel(void);
EXPORT(sqInt) primitiveSoundGetVolume(void);
EXPORT(sqInt) primitiveSoundInsertSamples(void);
EXPORT(sqInt) primitiveSoundPlaySamples(void);
EXPORT(sqInt) primitiveSoundPlaySilence(void);
EXPORT(sqInt) primitiveSoundRecordSamples(void);
EXPORT(sqInt) primitiveSoundSetLeftVolume(void);
EXPORT(sqInt) primitiveSoundSetRecordLevel(void);
EXPORT(sqInt) primitiveSoundStart(void);
EXPORT(sqInt) primitiveSoundStartRecording(void);
EXPORT(sqInt) primitiveSoundStartWithSemaphore(void);
EXPORT(sqInt) primitiveSoundStop(void);
EXPORT(sqInt) primitiveSoundStopRecording(void);
EXPORT(sqInt) primitiveSoundSupportsAEC(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static void sqAssert(sqInt aBool);


/*** Variables ***/

#ifdef SQUEAK_BUILTIN_PLUGIN
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"SoundPlugin VMMaker-oscog.8 (i)"
#else
	"SoundPlugin VMMaker-oscog.8 (e)"
#endif
;



/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void) {
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void) {
	return moduleName;
}

static sqInt
halt(void) {
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void) {
	return soundInit();
}

static sqInt
msg(char *s) {
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Answer a String with the operating system name of the default output
	device, or nil
 */
/*	no arguments */

EXPORT(sqInt)
primitiveGetDefaultSoundPlayer(void) {
	char*cDeviceName;
	char*newStringPtr;
	sqInt newString;
	sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	cDeviceName = getDefaultSoundPlayer();
	if (cDeviceName == 0) {
		return interpreterProxy->popthenPush(1, interpreterProxy->nilObject());
	}
	sz = strlen(cDeviceName);
	newString = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	newStringPtr = interpreterProxy->firstIndexableField(newString);
	strncpy(newStringPtr, cDeviceName, sz);
	;
	;
	return interpreterProxy->popthenPush(1, newString);
}


/*	Answer a String with the operating system name of the default input
	device, or nil
 */
/*	no arguments */

EXPORT(sqInt)
primitiveGetDefaultSoundRecorder(void) {
	char*cDeviceName;
	char*newStringPtr;
	sqInt newString;
	sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}
	cDeviceName = getDefaultSoundRecorder();
	if (cDeviceName == 0) {
		return interpreterProxy->popthenPush(1, interpreterProxy->nilObject());
	}
	sz = strlen(cDeviceName);
	newString = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	newStringPtr = interpreterProxy->firstIndexableField(newString);
	strncpy(newStringPtr, cDeviceName, sz);
	;
	;
	return interpreterProxy->popthenPush(1, newString);
}


/*	arguments: name(type, stack offset)
	dialString(String, 0) */
/*	answers an Integer */

EXPORT(sqInt)
primitiveGetNumberOfSoundPlayerDevices(void) {
	sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}

	/* answer it */

	result = getNumberOfSoundPlayerDevices();
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(1, result);
}


/*	arguments: name(type, stack offset)
	dialString(String, 0) */
/*	answers an Integer */

EXPORT(sqInt)
primitiveGetNumberOfSoundRecorderDevices(void) {
	sqInt result;

	if (!((interpreterProxy->methodArgumentCount()) == 0)) {
		return interpreterProxy->primitiveFail();
	}

	/* answer it */

	result = getNumberOfSoundRecorderDevices();
	result = interpreterProxy->signed32BitIntegerFor(result);
	return interpreterProxy->popthenPush(1, result);
}


/*	arguments: name(type, stack offset)
	deviceNumber(Integer, 0) */
/*	answers a string or nil */

EXPORT(sqInt)
primitiveGetSoundPlayerDeviceName(void) {
	sqInt deviceNumber;
	char*cDeviceName;
	char*newStringPtr;
	sqInt newString;
	sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	deviceNumber = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	cDeviceName = getSoundPlayerDeviceName(deviceNumber - 1);
	if (cDeviceName == 0) {
		return interpreterProxy->popthenPush(2, interpreterProxy->nilObject());
	}
	sz = strlen(cDeviceName);
	newString = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	newStringPtr = interpreterProxy->firstIndexableField(newString);
	strncpy(newStringPtr, cDeviceName, sz);
	;
	;
	;
	return interpreterProxy->popthenPush(2, newString);
}


/*	arguments: name(type, stack offset)
	deviceNumber(Integer, 0) */
/*	answers a string or nil */

EXPORT(sqInt)
primitiveGetSoundRecorderDeviceName(void) {
	sqInt deviceNumber;
	char*cDeviceName;
	char*newStringPtr;
	sqInt newString;
	sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	deviceNumber = interpreterProxy->positive32BitValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	cDeviceName = getSoundRecorderDeviceName(deviceNumber - 1);
	if (cDeviceName == 0) {
		return interpreterProxy->popthenPush(2, interpreterProxy->nilObject());
	}
	sz = strlen(cDeviceName);
	newString = interpreterProxy->instantiateClassindexableSize(interpreterProxy->classString(), sz);
	newStringPtr = interpreterProxy->firstIndexableField(newString);
	strncpy(newStringPtr, cDeviceName, sz);
	;
	;
	;
	return interpreterProxy->popthenPush(2, newString);
}


/*	Tell the operating system to use the specified device name as the next
	output device to be opened.
 */
/*	arg at top of stack is the String */

EXPORT(sqInt)
primitiveSetDefaultSoundPlayer(void) {
	sqInt obj;
	char deviceName[1024];
	char *srcPtr;
	sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	obj = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isBytes(obj))) {
		return interpreterProxy->primitiveFail();
	}
	sz = interpreterProxy->byteSizeOf(obj);
	srcPtr = interpreterProxy->firstIndexableField(obj);
	;
	;
	;
	strncpy(deviceName, srcPtr, sz);
	deviceName[sz] = NULL;
	setDefaultSoundPlayer(deviceName);
	return interpreterProxy->pop(1);
}


/*	Tell the operating system to use the specified device name as the next
	input device to be opened.
 */
/*	arg at top of stack is the String */

EXPORT(sqInt)
primitiveSetDefaultSoundRecorder(void) {
	sqInt obj;
	char deviceName[1024];
	char *srcPtr;
	sqInt sz;

	if (!((interpreterProxy->methodArgumentCount()) == 1)) {
		return interpreterProxy->primitiveFail();
	}
	obj = interpreterProxy->stackValue(0);
	if (!(interpreterProxy->isBytes(obj))) {
		return interpreterProxy->primitiveFail();
	}
	sz = interpreterProxy->byteSizeOf(obj);
	srcPtr = interpreterProxy->firstIndexableField(obj);
	;
	;
	;
	strncpy(deviceName, srcPtr, sz);
	deviceName[sz] = NULL;
	setDefaultSoundRecorder(deviceName);
	return interpreterProxy->pop(1);
}


/*	Returns the number of bytes of available sound output buffer space. This
	should be (frames*4) if the device is in stereo mode, or (frames*2)
	otherwise 
 */

EXPORT(sqInt)
primitiveSoundAvailableSpace(void) {
	sqInt frames;
	sqInt _return_value;


	/* -1 if sound output not started */

	frames = snd_AvailableSpace();
	interpreterProxy->success(frames >= 0);
	_return_value = interpreterProxy->positive32BitIntegerFor(frames);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(1, _return_value);
	return null;
}


/*	Enable or disable acoustic echo-cancellation (AEC). trueOrFalse should be
	0 for false, and 1 for true. */

EXPORT(sqInt)
primitiveSoundEnableAEC(void) {
	sqInt result;
	sqInt trueOrFalse;

	trueOrFalse = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	if (!(interpreterProxy->failed())) {
		result = snd_EnableAEC(trueOrFalse);
		if (!(result == 0)) {
			interpreterProxy->primitiveFailFor(result);
		}
	}
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(1);
	return null;
}


/*	Return a float representing the actual sampling rate during recording.
	Fail if not currently recording.
 */

EXPORT(sqInt)
primitiveSoundGetRecordingSampleRate(void) {
	double  rate;
	sqInt _return_value;


	/* fail if not recording */

	rate = snd_GetRecordingSampleRate();
	_return_value = interpreterProxy->floatObjectOf(rate);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(1, _return_value);
	return null;
}


/*	Get the sound input recording level. */

EXPORT(sqInt)
primitiveSoundGetRecordLevel(void) {
	sqInt level;
	sqInt _return_value;

	level = snd_GetRecordLevel();
	_return_value = interpreterProxy->positive32BitIntegerFor(level);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(1, _return_value);
	return null;
}


/*	Set the sound input recording level. */

EXPORT(sqInt)
primitiveSoundGetVolume(void) {
	double  right;
	sqInt results;
	double  left;

	left = 0;
	right = 0;
	snd_Volume((double *) &left,(double *) &right);
	interpreterProxy->pushRemappableOop(interpreterProxy->floatObjectOf(right));
	interpreterProxy->pushRemappableOop(interpreterProxy->floatObjectOf(left));
	interpreterProxy->pushRemappableOop(interpreterProxy->instantiateClassindexableSize(interpreterProxy->classArray(), 2));
	results = interpreterProxy->popRemappableOop();
	interpreterProxy->storePointerofObjectwithValue(0, results, interpreterProxy->popRemappableOop());
	interpreterProxy->storePointerofObjectwithValue(1, results, interpreterProxy->popRemappableOop());
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(1, results);
	return null;
}


/*	Insert a buffer's worth of sound samples into the currently playing 
	buffer. Used to make a sound start playing as quickly as possible. The 
	new sound is mixed with the previously buffered sampled. */
/*	Details: Unlike primitiveSoundPlaySamples, this primitive always starts 
	with the first sample the given sample buffer. Its third argument 
	specifies the number of samples past the estimated sound output buffer 
	position the inserted sound should start. If successful, it returns the 
	number of samples inserted. */

EXPORT(sqInt)
primitiveSoundInsertSamples(void) {
	sqInt framesPlayed;
	sqInt frameCount;
	usqInt *buf;
	sqInt leadTime;
	sqInt _return_value;

	frameCount = interpreterProxy->stackIntegerValue(2);
	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
	buf = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
	leadTime = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->success(frameCount <= (interpreterProxy->slotSizeOf(((sqInt)(long)(buf) - 4))));
	if (!(interpreterProxy->failed())) {
		framesPlayed = snd_InsertSamplesFromLeadTime(frameCount, (int)buf, leadTime);
		interpreterProxy->success(framesPlayed >= 0);
	}
	_return_value = interpreterProxy->positive32BitIntegerFor(framesPlayed);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(4, _return_value);
	return null;
}


/*	Output a buffer's worth of sound samples. */

EXPORT(sqInt)
primitiveSoundPlaySamples(void) {
	sqInt framesPlayed;
	sqInt frameCount;
	usqInt *buf;
	sqInt startIndex;
	sqInt _return_value;

	frameCount = interpreterProxy->stackIntegerValue(2);
	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
	buf = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
	startIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->success((startIndex >= 1)
	 && (((startIndex + frameCount) - 1) <= (interpreterProxy->slotSizeOf(((sqInt)(long)(buf) - 4)))));
	if (!(interpreterProxy->failed())) {
		framesPlayed = snd_PlaySamplesFromAtLength(frameCount, (int)buf, startIndex - 1);
		interpreterProxy->success(framesPlayed >= 0);
	}
	_return_value = interpreterProxy->positive32BitIntegerFor(framesPlayed);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(4, _return_value);
	return null;
}


/*	Output a buffer's worth of silence. Returns the number of sample frames
	played. 
 */

EXPORT(sqInt)
primitiveSoundPlaySilence(void) {
	sqInt framesPlayed;
	sqInt _return_value;


	/* -1 if sound output not started */

	framesPlayed = snd_PlaySilence();
	interpreterProxy->success(framesPlayed >= 0);
	_return_value = interpreterProxy->positive32BitIntegerFor(framesPlayed);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(1, _return_value);
	return null;
}


/*	Record a buffer's worth of 16-bit sound samples. */

EXPORT(sqInt)
primitiveSoundRecordSamples(void) {
	sqInt samplesRecorded;
	sqInt bufSizeInBytes;
	usqInt *buf;
	sqInt startWordIndex;
	sqInt _return_value;

	interpreterProxy->success(interpreterProxy->isWords(interpreterProxy->stackValue(1)));
	buf = ((unsigned *) (interpreterProxy->firstIndexableField(interpreterProxy->stackValue(1))));
	startWordIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	if (!(interpreterProxy->failed())) {
		bufSizeInBytes = (interpreterProxy->slotSizeOf(((sqInt)(long)(buf) - 4))) * 4;
		interpreterProxy->success((startWordIndex >= 1)
		 && (((startWordIndex - 1) * 2) < bufSizeInBytes));
	}
	if (!(interpreterProxy->failed())) {
		samplesRecorded = snd_RecordSamplesIntoAtLength((int)buf, startWordIndex - 1, bufSizeInBytes);
	}
	_return_value = interpreterProxy->positive32BitIntegerFor(samplesRecorded);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->popthenPush(3, _return_value);
	return null;
}


/*	Set the sound input recording level. */

EXPORT(sqInt)
primitiveSoundSetLeftVolume(void) {
	double aLeftVolume;
	double aRightVolume;

	aLeftVolume = interpreterProxy->stackFloatValue(1);
	aRightVolume = interpreterProxy->stackFloatValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	if (!(interpreterProxy->failed())) {
		snd_SetVolume(aLeftVolume,aRightVolume);
	}
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(2);
	return null;
}


/*	Set the sound input recording level. */

EXPORT(sqInt)
primitiveSoundSetRecordLevel(void) {
	sqInt level;

	level = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	if (!(interpreterProxy->failed())) {
		snd_SetRecordLevel(level);
	}
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(1);
	return null;
}


/*	Start the double-buffered sound output with the given buffer size, sample
	rate, and stereo flag.
 */

EXPORT(sqInt)
primitiveSoundStart(void) {
	sqInt bufFrames;
	sqInt samplesPerSec;
	sqInt stereoFlag;

	bufFrames = interpreterProxy->stackIntegerValue(2);
	samplesPerSec = interpreterProxy->stackIntegerValue(1);
	stereoFlag = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(0));
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->success(snd_Start(bufFrames, samplesPerSec, stereoFlag, 0));
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(3);
	return null;
}


/*	Start recording sound with the given parameters. */

EXPORT(sqInt)
primitiveSoundStartRecording(void) {
	sqInt desiredSamplesPerSec;
	sqInt stereoFlag;
	sqInt semaIndex;

	desiredSamplesPerSec = interpreterProxy->stackIntegerValue(2);
	stereoFlag = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(1));
	semaIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	snd_StartRecording(desiredSamplesPerSec, stereoFlag, semaIndex);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(3);
	return null;
}


/*	Start the double-buffered sound output with the given buffer size, sample
	rate, stereo flag, and semaphore index.
 */

EXPORT(sqInt)
primitiveSoundStartWithSemaphore(void) {
	sqInt bufFrames;
	sqInt samplesPerSec;
	sqInt stereoFlag;
	sqInt semaIndex;

	bufFrames = interpreterProxy->stackIntegerValue(3);
	samplesPerSec = interpreterProxy->stackIntegerValue(2);
	stereoFlag = interpreterProxy->booleanValueOf(interpreterProxy->stackValue(1));
	semaIndex = interpreterProxy->stackIntegerValue(0);
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->success(snd_Start(bufFrames, samplesPerSec, stereoFlag, semaIndex));
	if (interpreterProxy->failed()) {
		return null;
	}
	interpreterProxy->pop(4);
	return null;
}


/*	Stop double-buffered sound output. */

EXPORT(sqInt)
primitiveSoundStop(void) {
	snd_Stop();
	if (interpreterProxy->failed()) {
		return null;
	}
	return null;
}


/*	Stop recording sound. */

EXPORT(sqInt)
primitiveSoundStopRecording(void) {
	snd_StopRecording();
	if (interpreterProxy->failed()) {
		return null;
	}
	return null;
}


/*	Answer true if the OS/hardware supports echo-cancellation, and false
	otherwise. 
 */

EXPORT(sqInt)
primitiveSoundSupportsAEC(void) {
	sqInt result;
	sqInt _return_value;

	if (!(interpreterProxy->failed())) {
		result = snd_SupportsAEC();
		if (result == 0) {
			_return_value = interpreterProxy->falseObject();
			if (interpreterProxy->failed()) {
				return null;
			}
			interpreterProxy->popthenPush(1, _return_value);
			return null;
		}
		else {
			_return_value = interpreterProxy->trueObject();
			if (interpreterProxy->failed()) {
				return null;
			}
			interpreterProxy->popthenPush(1, _return_value);
			return null;
		}
	}
	if (interpreterProxy->failed()) {
		return null;
	}
	return null;
}


/*	Note: This is coded so that is can be run from Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter) {
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy->majorVersion() == VM_PROXY_MAJOR;
	if (ok == 0) {
		return 0;
	}
	ok = interpreterProxy->minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

EXPORT(sqInt)
shutdownModule(void) {
	return soundShutdown();
}

static void
sqAssert(sqInt aBool) {
	/* missing DebugCode */;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* SoundPlugin_exports[][3] = {
	{"SoundPlugin", "getModuleName", (void*)getModuleName},
	{"SoundPlugin", "initialiseModule", (void*)initialiseModule},
	{"SoundPlugin", "primitiveGetDefaultSoundPlayer", (void*)primitiveGetDefaultSoundPlayer},
	{"SoundPlugin", "primitiveGetDefaultSoundRecorder", (void*)primitiveGetDefaultSoundRecorder},
	{"SoundPlugin", "primitiveGetNumberOfSoundPlayerDevices", (void*)primitiveGetNumberOfSoundPlayerDevices},
	{"SoundPlugin", "primitiveGetNumberOfSoundRecorderDevices", (void*)primitiveGetNumberOfSoundRecorderDevices},
	{"SoundPlugin", "primitiveGetSoundPlayerDeviceName", (void*)primitiveGetSoundPlayerDeviceName},
	{"SoundPlugin", "primitiveGetSoundRecorderDeviceName", (void*)primitiveGetSoundRecorderDeviceName},
	{"SoundPlugin", "primitiveSetDefaultSoundPlayer", (void*)primitiveSetDefaultSoundPlayer},
	{"SoundPlugin", "primitiveSetDefaultSoundRecorder", (void*)primitiveSetDefaultSoundRecorder},
	{"SoundPlugin", "primitiveSoundAvailableSpace", (void*)primitiveSoundAvailableSpace},
	{"SoundPlugin", "primitiveSoundEnableAEC", (void*)primitiveSoundEnableAEC},
	{"SoundPlugin", "primitiveSoundGetRecordingSampleRate", (void*)primitiveSoundGetRecordingSampleRate},
	{"SoundPlugin", "primitiveSoundGetRecordLevel", (void*)primitiveSoundGetRecordLevel},
	{"SoundPlugin", "primitiveSoundGetVolume", (void*)primitiveSoundGetVolume},
	{"SoundPlugin", "primitiveSoundInsertSamples", (void*)primitiveSoundInsertSamples},
	{"SoundPlugin", "primitiveSoundPlaySamples", (void*)primitiveSoundPlaySamples},
	{"SoundPlugin", "primitiveSoundPlaySilence", (void*)primitiveSoundPlaySilence},
	{"SoundPlugin", "primitiveSoundRecordSamples", (void*)primitiveSoundRecordSamples},
	{"SoundPlugin", "primitiveSoundSetLeftVolume", (void*)primitiveSoundSetLeftVolume},
	{"SoundPlugin", "primitiveSoundSetRecordLevel", (void*)primitiveSoundSetRecordLevel},
	{"SoundPlugin", "primitiveSoundStart", (void*)primitiveSoundStart},
	{"SoundPlugin", "primitiveSoundStartRecording", (void*)primitiveSoundStartRecording},
	{"SoundPlugin", "primitiveSoundStartWithSemaphore", (void*)primitiveSoundStartWithSemaphore},
	{"SoundPlugin", "primitiveSoundStop", (void*)primitiveSoundStop},
	{"SoundPlugin", "primitiveSoundStopRecording", (void*)primitiveSoundStopRecording},
	{"SoundPlugin", "primitiveSoundSupportsAEC", (void*)primitiveSoundSupportsAEC},
	{"SoundPlugin", "setInterpreter", (void*)setInterpreter},
	{"SoundPlugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
