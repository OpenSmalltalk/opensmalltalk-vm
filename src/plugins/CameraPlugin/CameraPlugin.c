/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2957 uuid: 1905cffe-ff84-45bc-b423-79e7978ecfd7
   from
	CameraPlugin VMMaker.oscog-eem.2957 uuid: 1905cffe-ff84-45bc-b423-79e7978ecfd7
 */
static char __buildInfo[] = "CameraPlugin VMMaker.oscog-eem.2957 uuid: 1905cffe-ff84-45bc-b423-79e7978ecfd7 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "CameraPlugin.h"
#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrBadNumArgs 5


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
EXPORT(sqInt) primAcknowledgeFrame(void);
EXPORT(sqInt) primCameraName(void);
EXPORT(sqInt) primCameraUID(void);
EXPORT(sqInt) primCloseCamera(void);
EXPORT(sqInt) primFrameExtent(void);
EXPORT(sqInt) primGetCameraSemaphore(void);
EXPORT(sqInt) primGetFrame(void);
EXPORT(sqInt) primGetParam(void);
EXPORT(sqInt) primOpenCamera(void);
EXPORT(sqInt) primSetCameraBuffers(void);
EXPORT(sqInt) primSetCameraSemaphore(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
EXPORT(sqInt) shutdownModule(void);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*failed)(void);
static void * (*firstIndexableField)(sqInt oop);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isPinned)(sqInt anObject);
static sqInt (*isWords)(sqInt oop);
static sqInt (*isWordsOrBytes)(sqInt oop);
static sqInt (*methodArgumentCount)(void);
static sqInt (*methodReturnInteger)(sqInt integer);
static sqInt (*methodReturnReceiver)(void);
static sqInt (*methodReturnString)(char *aCString);
static sqInt (*nilObject)(void);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*success)(sqInt aBoolean);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt failed(void);
extern void * firstIndexableField(sqInt oop);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
extern sqInt isPinned(sqInt anObject);
#else
# define isPinned(anObject) 0
#endif
extern sqInt isWords(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt methodArgumentCount(void);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnReceiver(void);
extern sqInt methodReturnString(char *aCString);
extern sqInt nilObject(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt success(sqInt aBoolean);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "CameraPlugin VMMaker.oscog-eem.2957 " INT_EXT;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* CameraPlugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	return cameraInit();
}


/*	Acknowledge the receipt of one or more buffered frames, installed via
	primSetCameraBuffers. Answer the number of times a buffer was filled since
	the last invocation. This is a version of
	primGetFrame that does not need to supply a buffer to receiver the result. */

	/* CameraPlugin>>#primAcknowledgeFrame */
EXPORT(sqInt)
primAcknowledgeFrame(void)
{
    sqInt cameraNum;
    sqInt result;

	cameraNum = stackValue(0);
	if (!(isIntegerObject(cameraNum))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	result = CameraGetFrame(cameraNum, 0, 0);
	if (result < 0) {
		return primitiveFailFor(-result);
	}
	methodReturnInteger(result);
	return 0;
}


/*	Answer the name for the camera with the given number.
	Fail if the camera number is less than one or greater than the number of
	available cameras. */

	/* CameraPlugin>>#primCameraName */
EXPORT(sqInt)
primCameraName(void)
{
    sqInt cameraNum;

	cameraNum = stackIntegerValue(0);
	if (!(failed())) {
		methodReturnString(CameraName(cameraNum));
	}
	return 0;
}


/*	Answer a UID for the camera with the given number.
	Fail if the camera number is less than one or greater than the number of
	available cameras. */

	/* CameraPlugin>>#primCameraUID */
EXPORT(sqInt)
primCameraUID(void)
{
    sqInt cameraNum;

	cameraNum = stackIntegerValue(0);
	if (!(failed())) {
		methodReturnString(CameraUID(cameraNum));
	}
	return 0;
}


/*	Close the camera. Do nothing if it was not open. */

	/* CameraPlugin>>#primCloseCamera */
EXPORT(sqInt)
primCloseCamera(void)
{
    sqInt cameraNum;

	cameraNum = stackIntegerValue(0);
	if (failed()) {
		return 0;
	}
	CameraClose(cameraNum);
	methodReturnReceiver();
	return 0;
}


/*	Answer the frame extent of the given camera, or zero if the camera is not
	open. The extent is 16 bits of width and height packed into a single
	integer. 
 */

	/* CameraPlugin>>#primFrameExtent */
EXPORT(sqInt)
primFrameExtent(void)
{
    sqInt cameraNum;

	cameraNum = stackIntegerValue(0);
	if (!(failed())) {
		methodReturnInteger(CameraExtent(cameraNum));
	}
	return 0;
}


/*	Answers the semaphoreIndex set through primSetCameraSemaphore.
	Fails if no semaphore has been set. */

	/* CameraPlugin>>#primGetCameraSemaphore */
EXPORT(sqInt)
primGetCameraSemaphore(void)
{
    sqInt cameraNum;
    sqInt index;

	cameraNum = stackIntegerValue(0);
	if (!(failed())) {
		index = CameraGetSemaphore(cameraNum);
		if (index == null) {
			primitiveFail();
		}
		else {
			methodReturnInteger(index);
		}
	}
	return 0;
}


/*	Copy a camera frame into the given Bitmap. The Bitmap should be for a Form
	of depth 32 that is the same width and height as the current camera frame.
	Fail if the camera is not open or if the bitmap is not the right size. If
	successful, answer the number of frames received from the camera since the
	last call. If this is zero, then there has been no change.
 */

	/* CameraPlugin>>#primGetFrame */
EXPORT(sqInt)
primGetFrame(void)
{
    unsigned char *bitmap;
    sqInt bitmapOop;
    sqInt cameraNum;
    sqInt pixCount;
    sqInt result;

	cameraNum = stackIntegerValue(1);
	bitmapOop = stackValue(0);
	success(isWords(bitmapOop));
	if (failed()) {
		return 0;
	}
	bitmap = ((unsigned char *) (firstIndexableField(bitmapOop)));
	pixCount = stSizeOf(bitmapOop);
	result = CameraGetFrame(cameraNum, bitmap, pixCount);
	if (result < 0) {
		return primitiveFailFor(-result);
	}
	methodReturnInteger(result);
	return 0;
}


/*	Answer the given integer parameter of the given camera. */

	/* CameraPlugin>>#primGetParam */
EXPORT(sqInt)
primGetParam(void)
{
    sqInt cameraNum;
    sqInt paramNum;

	cameraNum = stackIntegerValue(1);
	paramNum = stackIntegerValue(0);
	if (!(failed())) {
		methodReturnInteger(CameraGetParam(cameraNum, paramNum));
	}
	return 0;
}


/*	Open a camera. Takes one argument, the index of the device to open.
	CameraOpen should choose the default size for the device if both
	desiredFrameWidth and desiredFrameHeight are zero, and the closest to the
	non-zero value(s) if either or both
	of desiredFrameWidth and desiredFrameHeight are non-zero. */

	/* CameraPlugin>>#primOpenCamera */
EXPORT(sqInt)
primOpenCamera(void)
{
    sqInt cameraNum;
    sqInt desiredFrameHeight;
    sqInt desiredFrameWidth;
    sqInt ok;

	cameraNum = stackIntegerValue(2);
	desiredFrameWidth = stackIntegerValue(1);
	desiredFrameHeight = stackIntegerValue(0);
	if (failed()) {
		return 0;
	}
	ok = CameraOpen(cameraNum, desiredFrameWidth, desiredFrameHeight);
	if (ok <= 0) {
		success(0);
		return 0;
	}
	methodReturnReceiver();
	return 0;
}


/*	Sets one or two frame buffers to receive camera frames. The buffer(s) must
	be big enough and pinned.
	Provides these two interfaces:
	camera: cameraNum setFrameBuffer: pinnedNonPointers
	camera: cameraNum setFrameBufferA: pinnedNonPointers B:
	pinnedNonPointersOrNil 
 */

	/* CameraPlugin>>#primSetCameraBuffers */
EXPORT(sqInt)
primSetCameraBuffers(void)
{
    sqInt bufferOne;
    sqInt bufferTwo;
    sqInt cameraNum;
    sqInt failCode;

	switch (methodArgumentCount()) {
	case 3:
		cameraNum = stackValue(2);
		bufferOne = stackValue(1);
		bufferTwo = stackValue(0);
		break;
	case 2:
		cameraNum = stackValue(1);
		bufferOne = stackValue(0);
		bufferTwo = null;
		break;
	default:
		return primitiveFailFor(PrimErrBadNumArgs);

	}
	if (!((isIntegerObject(cameraNum))
		 && ((isWordsOrBytes(bufferOne))
		 && ((isPinned(bufferOne))
		 && ((bufferTwo == null)
		 || ((bufferTwo == (nilObject()))
		 || ((isWordsOrBytes(bufferTwo))
		 && (isPinned(bufferTwo))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}

	/* coerce nilObject to nil */
	failCode = CameraSetFrameBuffers(integerValueOf(cameraNum), bufferOne, (!(bufferTwo == (nilObject()))
		? bufferTwo
		: 0));
	if (failCode != 0) {
		return primitiveFailFor(failCode);
	}
	methodReturnReceiver();
	return 0;
}


/*	Supplies a semaphoreIndex through which to signal a semaphore when a frame
	is available from a camera.
	Fails if the platform does not provide an interrupt-driven camera
	interface. 
 */

	/* CameraPlugin>>#primSetCameraSemaphore */
EXPORT(sqInt)
primSetCameraSemaphore(void)
{
    sqInt cameraNum;
    sqInt failCode;
    sqInt semaphoreIndex;

	cameraNum = stackIntegerValue(1);
	semaphoreIndex = stackIntegerValue(0);
	if (failed()) {
		return 0;
	}
	failCode = CameraSetSemaphore(cameraNum, semaphoreIndex);
	if (failCode != 0) {
		return primitiveFailFor(failCode);
	}
	methodReturnReceiver();
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		failed = interpreterProxy->failed;
		firstIndexableField = interpreterProxy->firstIndexableField;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 13)
		isPinned = interpreterProxy->isPinned;
#else
#if !defined(isPinned)
		isPinned = 0;
#endif
#endif
		isWords = interpreterProxy->isWords;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnReceiver = interpreterProxy->methodReturnReceiver;
		methodReturnString = interpreterProxy->methodReturnString;
		nilObject = interpreterProxy->nilObject;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		success = interpreterProxy->success;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* CameraPlugin>>#shutdownModule */
EXPORT(sqInt)
shutdownModule(void)
{
	return cameraShutdown();
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "CameraPlugin";
void* CameraPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primAcknowledgeFrame\000\000", (void*)primAcknowledgeFrame},
	{(void*)_m, "primCameraName\000\000", (void*)primCameraName},
	{(void*)_m, "primCameraUID\000\000", (void*)primCameraUID},
	{(void*)_m, "primCloseCamera\000\000", (void*)primCloseCamera},
	{(void*)_m, "primFrameExtent\000\000", (void*)primFrameExtent},
	{(void*)_m, "primGetCameraSemaphore\000\000", (void*)primGetCameraSemaphore},
	{(void*)_m, "primGetFrame\000\000", (void*)primGetFrame},
	{(void*)_m, "primGetParam\000\000", (void*)primGetParam},
	{(void*)_m, "primOpenCamera\000\000", (void*)primOpenCamera},
	{(void*)_m, "primSetCameraBuffers\000\000", (void*)primSetCameraBuffers},
	{(void*)_m, "primSetCameraSemaphore\000\000", (void*)primSetCameraSemaphore},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "shutdownModule\000\377", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primAcknowledgeFrameAccessorDepth = 0;
EXPORT(signed char) primCameraNameAccessorDepth = 0;
EXPORT(signed char) primCameraUIDAccessorDepth = 0;
EXPORT(signed char) primCloseCameraAccessorDepth = 0;
EXPORT(signed char) primFrameExtentAccessorDepth = 0;
EXPORT(signed char) primGetCameraSemaphoreAccessorDepth = 0;
EXPORT(signed char) primGetFrameAccessorDepth = 0;
EXPORT(signed char) primGetParamAccessorDepth = 0;
EXPORT(signed char) primOpenCameraAccessorDepth = 0;
EXPORT(signed char) primSetCameraBuffersAccessorDepth = 0;
EXPORT(signed char) primSetCameraSemaphoreAccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
