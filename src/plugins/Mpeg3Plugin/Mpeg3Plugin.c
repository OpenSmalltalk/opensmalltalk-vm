/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
   from
	Mpeg3Plugin VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
 */
static char __buildInfo[] = "Mpeg3Plugin VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "Mpeg3Plugin.h"
#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Function Prototypes ***/
extern sqInt checkFileEntry(mpeg3_t *aMpegFile);
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) initialiseModule(void);
extern sqInt makeFileEntry(mpeg3_t *aMpegFile);
static mpeg3_t * mpeg3tValueOf(sqInt mpeg3tHandle);
EXPORT(sqInt) primitiveMPEG3AudioChannels(void);
EXPORT(sqInt) primitiveMPEG3AudioSamples(void);
EXPORT(sqInt) primitiveMPEG3CheckSig(void);
EXPORT(sqInt) primitiveMPEG3Close(void);
EXPORT(sqInt) primitiveMPEG3DropFrames(void);
EXPORT(sqInt) primitiveMPEG3EndOfAudio(void);
EXPORT(sqInt) primitiveMPEG3EndOfVideo(void);
EXPORT(sqInt) primitiveMPEG3FrameRate(void);
EXPORT(sqInt) primitiveMPEG3GenerateToc(void);
EXPORT(sqInt) primitiveMPEG3GetFrame(void);
EXPORT(sqInt) primitiveMPEG3GetSample(void);
EXPORT(sqInt) primitiveMPEG3GetTime(void);
EXPORT(sqInt) primitiveMPEG3HasAudio(void);
EXPORT(sqInt) primitiveMPEG3HasVideo(void);
EXPORT(sqInt) primitiveMPEG3Open(void);
EXPORT(sqInt) primitiveMPEG3OpenABuffer(void);
EXPORT(sqInt) primitiveMPEG3PreviousFrame(void);
EXPORT(sqInt) primitiveMPEG3ReadAudio(void);
EXPORT(sqInt) primitiveMPEG3ReadFrame(void);
EXPORT(sqInt) primitiveMPEG3ReadFrameBufferOffset(void);
EXPORT(sqInt) primitiveMPEG3ReReadAudio(void);
EXPORT(sqInt) primitiveMPEG3SampleRate(void);
EXPORT(sqInt) primitiveMPEG3SeekPercentage(void);
EXPORT(sqInt) primitiveMPEG3SetCpus(void);
EXPORT(sqInt) primitiveMPEG3SetFrame(void);
EXPORT(sqInt) primitiveMPEG3SetMmx(void);
EXPORT(sqInt) primitiveMPEG3SetSample(void);
EXPORT(sqInt) primitiveMPEG3TellPercentage(void);
EXPORT(sqInt) primitiveMPEG3TotalAStreams(void);
EXPORT(sqInt) primitiveMPEG3TotalVStreams(void);
EXPORT(sqInt) primitiveMPEG3VideoFrames(void);
EXPORT(sqInt) primitiveMPEG3VideoHeight(void);
EXPORT(sqInt) primitiveMPEG3VideoWidth(void);
extern sqInt removeFileEntry(mpeg3_t *aMpegFile);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
EXPORT(sqInt) shutdownModule(void);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*classByteArray)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*floatObjectOf)(double aFloat);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static sqInt (*ioFilenamefromStringofLengthresolveAliases)(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt (*isBooleanObject)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isFloatObject)(sqInt oop);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isWords)(sqInt oop);
static sqInt (*methodReturnInteger)(sqInt integer);
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*pop)(sqInt nItems);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*slotSizeOf)(sqInt oop);
static double (*stackFloatValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*success)(sqInt aBoolean);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt classByteArray(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern void * firstIndexableField(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
extern sqInt ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
extern sqInt isBooleanObject(sqInt oop);
#else
# define isBooleanObject(oop) 0
#endif
extern sqInt isBytes(sqInt oop);
extern sqInt isFloatObject(sqInt oop);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
extern sqInt isWords(sqInt oop);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt pop(sqInt nItems);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt slotSizeOf(sqInt oop);
extern double stackFloatValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt success(sqInt aBoolean);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static sqInt maximumNumberOfFilesToWatch;
static const char *moduleName = "Mpeg3Plugin VMMaker.oscog-eem.3456 " INT_EXT;
static mpeg3_t *mpegFiles[1024+1];


/*** Methods ***/

	/* Mpeg3Plugin>>#checkFileEntry: */
sqInt
checkFileEntry(mpeg3_t *aMpegFile)
{
	sqInt i;

	for (i = 1; i <= maximumNumberOfFilesToWatch; i += 1) {
		if ((mpegFiles[i]) == aMpegFile) {
			return 1;
		}
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* Mpeg3Plugin>>#initialiseModule */
EXPORT(sqInt)
initialiseModule(void)
{
	sqInt i;

	maximumNumberOfFilesToWatch = 0x400;
	for (i = 1; i <= maximumNumberOfFilesToWatch; i += 1) {
		mpegFiles[i] = 0;
	}
	return 1;
}

	/* Mpeg3Plugin>>#makeFileEntry: */
sqInt
makeFileEntry(mpeg3_t *aMpegFile)
{
	sqInt i;

	for (i = 1; i <= maximumNumberOfFilesToWatch; i += 1) {
		if (!(mpegFiles[i])) {
			mpegFiles[i] = aMpegFile;
			return 1;
		}
	}
	return 0;
}


/*	Return a pointer to the first byte of of the mpeg3_t record within the 
	given Smalltalk object, or nil if socketOop is not a mpeg3_t record. */

	/* Mpeg3Plugin>>#mpeg3tValueOf: */
static mpeg3_t *
mpeg3tValueOf(sqInt mpeg3tHandle)
{
	sqInt check;
	mpeg3_t **index;

	check = 0;
	success((isBytes(mpeg3tHandle))
	 && ((byteSizeOf(mpeg3tHandle)) == 4));
	if (failed()) {
		return null;
	}
	else {
		index = firstIndexableField(mpeg3tHandle);
		check = checkFileEntry(*index);
		if (!check) {
			return null;
		}
		return *index;
	}
}


/*	int mpeg3_audio_channels(mpeg3_t *file,int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3AudioChannels:stream: */
EXPORT(sqInt)
primitiveMPEG3AudioChannels(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_audio_channels(file,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	long mpeg3_audio_samples(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3AudioSamples:stream: */
EXPORT(sqInt)
primitiveMPEG3AudioSamples(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;
	sqInt _return_value;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_audio_samples(file,aNumber);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	int mpeg3_check_sig(char *path) */

	/* Mpeg3Plugin>>#primitiveMPEG3CheckSig: */
EXPORT(sqInt)
primitiveMPEG3CheckSig(void)
{
	char *path;
	sqInt result;
	char storage[1024] ;
	sqInt sz;

	result = 0;
	if (!(isBytes(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	path = firstIndexableField(stackValue(0));
	sz = byteSizeOf(((sqInt)(sqIntptr_t)(path) - BaseHeaderSize));
	ioFilenamefromStringofLengthresolveAliases(storage, path, sz, 1);
	result = mpeg3_check_sig(storage);
	if (!(failed())) {
		methodReturnValue(((result) ? trueObject() : falseObject()));
	}
	return null;
}


/*	int mpeg3_close(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3Close: */
EXPORT(sqInt)
primitiveMPEG3Close(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	mpeg3_t **index;

	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	removeFileEntry(file); mpeg3_close(file);
	index = firstIndexableField(fileHandle);
	*index = 0;
	if (!(failed())) {
		pop(1);
	}
	return null;
}


/*	int mpeg3_drop_frames(mpeg3_t *file, long frames, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3DropFrames:frames:stream: */
EXPORT(sqInt)
primitiveMPEG3DropFrames(void)
{
	sqInt aFrameNumber;
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!((isIntegerObject((aFrameNumber = stackValue(1))))
		 && (isIntegerObject((aNumber = stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(2);
	aFrameNumber = integerValueOf(aFrameNumber);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_drop_frames(file,aFrameNumber,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_end_of_audio(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3EndOfAudio:stream: */
EXPORT(sqInt)
primitiveMPEG3EndOfAudio(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_end_of_audio(file,aNumber);
	if (!(failed())) {
		methodReturnValue(((result) ? trueObject() : falseObject()));
	}
	return null;
}


/*	int mpeg3_end_of_video(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3EndOfVideo:stream: */
EXPORT(sqInt)
primitiveMPEG3EndOfVideo(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_end_of_video(file,aNumber);
	if (!(failed())) {
		methodReturnValue(((result) ? trueObject() : falseObject()));
	}
	return null;
}


/*	float mpeg3_frame_rate(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3FrameRate:stream: */
EXPORT(sqInt)
primitiveMPEG3FrameRate(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	double result;
	sqInt _return_value;

	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result =  mpeg3_frame_rate(file,aNumber);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	int mpeg3_generate_toc_for_Squeak(FILE *output, char *path, int
	timecode_search, int print_streams, char *buffer)
 */

	/* Mpeg3Plugin>>#primitiveMPEG3GenerateToc:useSearch:doStreams:buffer: */
EXPORT(sqInt)
primitiveMPEG3GenerateToc(void)
{
	char *aString;
	sqInt bufferSize;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt streams;
	sqInt timecode;

	if (!((isIntegerObject((timecode = stackValue(2))))
		 && ((isBooleanObject(stackValue(1)))
		 && (isBytes(stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(3);
	timecode = integerValueOf(timecode);
	streams = booleanValueOf(stackValue(1));
	aString = firstIndexableField(stackValue(0));
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	bufferSize = slotSizeOf(stackValue(0));
	mpeg3_generate_toc_for_Squeak(file,timecode,streams,aString,bufferSize);
	if (!(failed())) {
		pop(4);
	}
	return null;
}


/*	long mpeg3_get_frame(mpeg3_t *file,int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3GetFrame:stream: */
EXPORT(sqInt)
primitiveMPEG3GetFrame(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;
	sqInt _return_value;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_get_frame(file,aNumber);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	int mpeg3_video_width(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3GetSample:stream: */
EXPORT(sqInt)
primitiveMPEG3GetSample(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;
	sqInt _return_value;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_get_sample(file,aNumber);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	double mpeg3_get_time(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3GetTime: */
EXPORT(sqInt)
primitiveMPEG3GetTime(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	double result;
	sqInt _return_value;

	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	result = mpeg3_get_time(file);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	int mpeg3_has_audio(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3HasAudio: */
EXPORT(sqInt)
primitiveMPEG3HasAudio(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	result = mpeg3_has_audio(file);
	if (!(failed())) {
		methodReturnValue(((result) ? trueObject() : falseObject()));
	}
	return null;
}


/*	int mpeg3_has_video(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3HasVideo: */
EXPORT(sqInt)
primitiveMPEG3HasVideo(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	result = mpeg3_has_video(file);
	if (!(failed())) {
		methodReturnValue(((result) ? trueObject() : falseObject()));
	}
	return null;
}


/*	mpeg3_t* mpeg3_open(char *path) */

	/* Mpeg3Plugin>>#primitiveMPEG3Open: */
EXPORT(sqInt)
primitiveMPEG3Open(void)
{
	mpeg3_t ** index;
	sqInt mpeg3Oop;
	char *path;
	char storage[1024];
	sqInt sz;

	if (!(isBytes(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	path = firstIndexableField(stackValue(0));
	sz = byteSizeOf(((sqInt)(sqIntptr_t)(path) - BaseHeaderSize));
	ioFilenamefromStringofLengthresolveAliases(storage, path, sz, 1);
	mpeg3Oop = instantiateClassindexableSize(classByteArray(), 4);
	index = firstIndexableField(mpeg3Oop);
	*index = mpeg3_open(storage,0); makeFileEntry(*index);
	if (!(failed())) {
		methodReturnValue(mpeg3Oop);
	}
	return null;
}

	/* Mpeg3Plugin>>#primitiveMPEG3OpenABuffer:size: */
EXPORT(sqInt)
primitiveMPEG3OpenABuffer(void)
{
	mpeg3_t ** index;
	sqInt mpeg3Oop;
	char *path;
	sqInt size;

	if (!((isBytes(stackValue(1)))
		 && (isIntegerObject((size = stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	path = firstIndexableField(stackValue(1));
	size = integerValueOf(size);
	mpeg3Oop = instantiateClassindexableSize(classByteArray(), 4);
	index = firstIndexableField(mpeg3Oop);
	*index = mpeg3_open(path,size); makeFileEntry(*index);
	if (!(failed())) {
		methodReturnValue(mpeg3Oop);
	}
	return null;
}


/*	int mpeg3_previous_frame(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3PreviousFrame:stream: */
EXPORT(sqInt)
primitiveMPEG3PreviousFrame(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (!file) {
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_previous_frame(file,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_read_audio(mpeg3_t *file, 
	float *output_f, 
	short *output_i, 
	int channel, 
	long samples,
	int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3ReadAudio:shortArray:channel:samples:stream: */
EXPORT(sqInt)
primitiveMPEG3ReadAudio(void)
{
	sqInt aChannelNumber;
	sqInt aNumber;
	unsigned *anArray;
	short *arrayBase;
	sqInt aSampleNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!((isWords(stackValue(3)))
		 && ((isIntegerObject((aChannelNumber = stackValue(2))))
		 && ((isIntegerObject((aSampleNumber = stackValue(1))))
		 && (isIntegerObject((aNumber = stackValue(0)))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(4);
	anArray = firstIndexableField(stackValue(3));
	aChannelNumber = integerValueOf(aChannelNumber);
	aSampleNumber = integerValueOf(aSampleNumber);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	arrayBase = ((short *) anArray);
	if (failed()) {
		return null;
	}
	result = mpeg3_read_audio(file,(float *) NULL,arrayBase,aChannelNumber,aSampleNumber,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}

	/* Mpeg3Plugin>>#primitiveMPEG3ReadFrame:buffer:x:y:w:h:ow:oh:colorModel:stream:bytesPerRow: */
EXPORT(sqInt)
primitiveMPEG3ReadFrame(void)
{
	unsigned *aBuffer;
	sqInt aByteNumber;
	sqInt aNumber;
	unsigned char *bufferBaseAddr;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt height;
	sqInt i;
	sqInt model;
	sqInt outHeight;
	unsigned char  **outputRowsPtr;
	sqInt outWidth;
	sqInt result;
	sqInt width;
	sqInt xNumber;
	sqInt yNumber;


	/* int mpeg3_read_frame(mpeg3_t *file,
	   unsigned char **output_rows,
	   int in_x,
	   int in_y,
	   int in_w,
	   int in_h,
	   int out_w,
	   int out_h,
	   int color_model,
	   int stream) */
	outputRowsPtr = ((unsigned char  **) 0);
	result = 0;
	if (!((isWords(stackValue(9)))
		 && ((isIntegerObject((xNumber = stackValue(8))))
		 && ((isIntegerObject((yNumber = stackValue(7))))
		 && ((isIntegerObject((width = stackValue(6))))
		 && ((isIntegerObject((height = stackValue(5))))
		 && ((isIntegerObject((outWidth = stackValue(4))))
		 && ((isIntegerObject((outHeight = stackValue(3))))
		 && ((isIntegerObject((model = stackValue(2))))
		 && ((isIntegerObject((aNumber = stackValue(1))))
		 && (isIntegerObject((aByteNumber = stackValue(0)))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(10);
	aBuffer = firstIndexableField(stackValue(9));
	xNumber = integerValueOf(xNumber);
	yNumber = integerValueOf(yNumber);
	width = integerValueOf(width);
	height = integerValueOf(height);
	outWidth = integerValueOf(outWidth);
	outHeight = integerValueOf(outHeight);
	model = integerValueOf(model);
	aNumber = integerValueOf(aNumber);
	aByteNumber = integerValueOf(aByteNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	bufferBaseAddr = ((unsigned char *) aBuffer);
	outputRowsPtr = (unsigned char **) memoryAllocate(1,sizeof(unsigned char*) * outHeight);
	for (i = 0; i < outHeight; i += 1) {
		outputRowsPtr[i] = (bufferBaseAddr + (aByteNumber * i));
	}
	result = mpeg3_read_frame(file,outputRowsPtr,xNumber,yNumber,width,height,outWidth,outHeight,model,aNumber);
	memoryFree(outputRowsPtr);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}

	/* Mpeg3Plugin>>#primitiveMPEG3ReadFrame:buffer:bufferOffset:x:y:w:h:ow:oh:colorModel:stream:bytesPerRow: */
EXPORT(sqInt)
primitiveMPEG3ReadFrameBufferOffset(void)
{
	unsigned *aBuffer;
	sqInt aBufferOffset;
	sqInt aByteNumber;
	sqInt aNumber;
	unsigned char *bufferBaseAddr;
	mpeg3_t * file;
	sqInt fileHandle;
	sqInt height;
	sqInt i;
	sqInt model;
	sqInt outHeight;
	unsigned char  ** outputRowsPtr;
	sqInt outWidth;
	sqInt result;
	sqInt width;
	sqInt xNumber;
	sqInt yNumber;


	/* int mpeg3_read_frame(mpeg3_t *file,
	   unsigned char **output_rows,
	   int in_x,
	   int in_y,
	   int in_w,
	   int in_h,
	   int out_w,
	   int out_h,
	   int color_model,
	   int stream) */
	outputRowsPtr = ((unsigned char  **) 0);
	result = 0;
	if (!((isWords(stackValue(10)))
		 && ((isIntegerObject((aBufferOffset = stackValue(9))))
		 && ((isIntegerObject((xNumber = stackValue(8))))
		 && ((isIntegerObject((yNumber = stackValue(7))))
		 && ((isIntegerObject((width = stackValue(6))))
		 && ((isIntegerObject((height = stackValue(5))))
		 && ((isIntegerObject((outWidth = stackValue(4))))
		 && ((isIntegerObject((outHeight = stackValue(3))))
		 && ((isIntegerObject((model = stackValue(2))))
		 && ((isIntegerObject((aNumber = stackValue(1))))
		 && (isIntegerObject((aByteNumber = stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(11);
	aBuffer = firstIndexableField(stackValue(10));
	aBufferOffset = integerValueOf(aBufferOffset);
	xNumber = integerValueOf(xNumber);
	yNumber = integerValueOf(yNumber);
	width = integerValueOf(width);
	height = integerValueOf(height);
	outWidth = integerValueOf(outWidth);
	outHeight = integerValueOf(outHeight);
	model = integerValueOf(model);
	aNumber = integerValueOf(aNumber);
	aByteNumber = integerValueOf(aByteNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	bufferBaseAddr = ((unsigned char *) aBuffer);
	outputRowsPtr = (unsigned char **) memoryAllocate(1,sizeof(unsigned char*) * outHeight);
	for (i = 0; i < outHeight; i += 1) {
		outputRowsPtr[i] = ((bufferBaseAddr + aBufferOffset) + (aByteNumber * i));
	}
	result = mpeg3_read_frame(file,outputRowsPtr,xNumber,yNumber,width,height,outWidth,outHeight,model,aNumber);
	memoryFree(outputRowsPtr);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_reread_audio(mpeg3_t *file, 
	float *output_f, 
	short *output_i, 
	int channel, 
	long samples,
	int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3ReReadAudio:shortArray:channel:samples:stream: */
EXPORT(sqInt)
primitiveMPEG3ReReadAudio(void)
{
	sqInt aChannelNumber;
	sqInt aNumber;
	unsigned *anArray;
	short *arrayBase;
	sqInt aSampleNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!((isWords(stackValue(3)))
		 && ((isIntegerObject((aChannelNumber = stackValue(2))))
		 && ((isIntegerObject((aSampleNumber = stackValue(1))))
		 && (isIntegerObject((aNumber = stackValue(0)))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(4);
	anArray = firstIndexableField(stackValue(3));
	aChannelNumber = integerValueOf(aChannelNumber);
	aSampleNumber = integerValueOf(aSampleNumber);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	arrayBase = ((short *) anArray);
	if (failed()) {
		return null;
	}
	result = mpeg3_reread_audio(file,(float *) NULL,arrayBase,aChannelNumber,aSampleNumber,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_sample_rate(mpeg3_t *file,int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3SampleRate:stream: */
EXPORT(sqInt)
primitiveMPEG3SampleRate(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_sample_rate(file,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_seek_percentage(mpeg3_t *file, double percentage) */

	/* Mpeg3Plugin>>#primitiveMPEG3SeekPercentage:percentage: */
EXPORT(sqInt)
primitiveMPEG3SeekPercentage(void)
{
	double aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isFloatObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = stackFloatValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (aNumber < 0.0) {
		success(0);
		return null;
	}
	if (aNumber > 1.0) {
		success(0);
		return null;
	}
	if (!file) {
		return null;
	}
	result = mpeg3_seek_percentage(file,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_set_cpus(mpeg3_t *file, int cpus) */

	/* Mpeg3Plugin>>#primitiveMPEG3SetCpus:number: */
EXPORT(sqInt)
primitiveMPEG3SetCpus(void)
{
	sqInt cpus;
	mpeg3_t *file;
	sqInt fileHandle;

	if (!(isIntegerObject((cpus = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	cpus = integerValueOf(cpus);
	file = mpeg3tValueOf(fileHandle);
	if (cpus < 0) {
		success(0);
		return null;
	}
	if (!file) {
		return null;
	}
	mpeg3_set_cpus(file,cpus);
	if (!(failed())) {
		pop(2);
	}
	return null;
}


/*	int mpeg3_set_frame(mpeg3_t *file, long frame, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3SetFrame:frame:stream: */
EXPORT(sqInt)
primitiveMPEG3SetFrame(void)
{
	double aFrameNumber;
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!((isFloatObject(stackValue(1)))
		 && (isIntegerObject((aNumber = stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(2);
	aFrameNumber = stackFloatValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_set_frame(file,(long) aFrameNumber,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_set_mmx(mpeg3_t *file, int use_mmx) */

	/* Mpeg3Plugin>>#primitiveMPEG3SetMmx:useMmx: */
EXPORT(sqInt)
primitiveMPEG3SetMmx(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt mmx;

	if (!(isBooleanObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	mmx = booleanValueOf(stackValue(0));
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	mpeg3_set_mmx(file,mmx);
	if (!(failed())) {
		pop(2);
	}
	return null;
}


/*	int mpeg3_set_sample(mpeg3_t *file, long sample, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3SetSample:sample:stream: */
EXPORT(sqInt)
primitiveMPEG3SetSample(void)
{
	sqInt aNumber;
	double aSampleNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!((isFloatObject(stackValue(1)))
		 && (isIntegerObject((aNumber = stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(2);
	aSampleNumber = stackFloatValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_astreams(file))) {
		success(0);
		return null;
	}
	if (aSampleNumber < 0) {
		success(0);
		return null;
	}
	result = mpeg3_set_sample(file,aSampleNumber,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	double mpeg3_tell_percentage(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3TellPercentage: */
EXPORT(sqInt)
primitiveMPEG3TellPercentage(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	double result;
	sqInt _return_value;

	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	result = mpeg3_tell_percentage(file);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	int mpeg3_total_astreams(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3TotalAStreams: */
EXPORT(sqInt)
primitiveMPEG3TotalAStreams(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	result = mpeg3_total_astreams(file);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_total_vstreams(mpeg3_t *file) */

	/* Mpeg3Plugin>>#primitiveMPEG3TotalVStreams: */
EXPORT(sqInt)
primitiveMPEG3TotalVStreams(void)
{
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	fileHandle = stackValue(0);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		return null;
	}
	result = mpeg3_total_vstreams(file);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	long mpeg3_video_frames(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3VideoFrames:stream: */
EXPORT(sqInt)
primitiveMPEG3VideoFrames(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;
	sqInt _return_value;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_video_frames(file,aNumber);
	_return_value = floatObjectOf(result);
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}


/*	int mpeg3_video_height(mpeg3_t *file,int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3VideoHeight:stream: */
EXPORT(sqInt)
primitiveMPEG3VideoHeight(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_video_height(file,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}


/*	int mpeg3_video_width(mpeg3_t *file, int stream) */

	/* Mpeg3Plugin>>#primitiveMPEG3VideoWidth:stream: */
EXPORT(sqInt)
primitiveMPEG3VideoWidth(void)
{
	sqInt aNumber;
	mpeg3_t *file;
	sqInt fileHandle;
	sqInt result;

	result = 0;
	if (!(isIntegerObject((aNumber = stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	fileHandle = stackValue(1);
	aNumber = integerValueOf(aNumber);
	file = mpeg3tValueOf(fileHandle);
	if (!file) {
		methodReturnInteger(0);
		return null;
	}
	if (aNumber < 0) {
		success(0);
		return null;
	}
	if (aNumber >= (result = mpeg3_total_vstreams(file))) {
		success(0);
		return null;
	}
	result = mpeg3_video_width(file,aNumber);
	if (!(failed())) {
		methodReturnInteger(result);
	}
	return null;
}

	/* Mpeg3Plugin>>#removeFileEntry: */
sqInt
removeFileEntry(mpeg3_t *aMpegFile)
{
	sqInt i;

	for (i = 1; i <= maximumNumberOfFilesToWatch; i += 1) {
		if ((mpegFiles[i]) == aMpegFile) {
			mpegFiles[i] = 0;
			return 1;
		}
	}
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
	sqInt ok;

	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
		 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		classByteArray = interpreterProxy->classByteArray;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatObjectOf = interpreterProxy->floatObjectOf;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
		ioFilenamefromStringofLengthresolveAliases = interpreterProxy->ioFilenamefromStringofLengthresolveAliases;
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
		isBooleanObject = interpreterProxy->isBooleanObject;
#else
#if !defined(isBooleanObject)
		isBooleanObject = 0;
#endif
#endif
		isBytes = interpreterProxy->isBytes;
		isFloatObject = interpreterProxy->isFloatObject;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
		isWords = interpreterProxy->isWords;
		methodReturnInteger = interpreterProxy->methodReturnInteger;
		methodReturnValue = interpreterProxy->methodReturnValue;
		pop = interpreterProxy->pop;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackFloatValue = interpreterProxy->stackFloatValue;
		stackValue = interpreterProxy->stackValue;
		success = interpreterProxy->success;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* Mpeg3Plugin>>#shutdownModule */
EXPORT(sqInt)
shutdownModule(void)
{
	sqInt i;

	for (i = 1; i <= maximumNumberOfFilesToWatch; i += 1) {
		if (mpegFiles[i]) {
			mpeg3_close(mpegFiles[i]);
			mpegFiles[i] = 0;
		}
	}
	return 1;
}

/*** Exports ***/

#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "Mpeg3Plugin";
void* Mpeg3Plugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "initialiseModule", (void*)initialiseModule},
	{(void*)_m, "primitiveMPEG3AudioChannels\000\001\000", (void*)primitiveMPEG3AudioChannels},
	{(void*)_m, "primitiveMPEG3AudioSamples\000\001\000", (void*)primitiveMPEG3AudioSamples},
	{(void*)_m, "primitiveMPEG3CheckSig\000\000\000", (void*)primitiveMPEG3CheckSig},
	{(void*)_m, "primitiveMPEG3Close\000\001\000", (void*)primitiveMPEG3Close},
	{(void*)_m, "primitiveMPEG3DropFrames\000\001\000", (void*)primitiveMPEG3DropFrames},
	{(void*)_m, "primitiveMPEG3EndOfAudio\000\001\000", (void*)primitiveMPEG3EndOfAudio},
	{(void*)_m, "primitiveMPEG3EndOfVideo\000\001\000", (void*)primitiveMPEG3EndOfVideo},
	{(void*)_m, "primitiveMPEG3FrameRate\000\001\000", (void*)primitiveMPEG3FrameRate},
	{(void*)_m, "primitiveMPEG3GenerateToc\000\001\000", (void*)primitiveMPEG3GenerateToc},
	{(void*)_m, "primitiveMPEG3GetFrame\000\001\000", (void*)primitiveMPEG3GetFrame},
	{(void*)_m, "primitiveMPEG3GetSample\000\001\000", (void*)primitiveMPEG3GetSample},
	{(void*)_m, "primitiveMPEG3GetTime\000\001\000", (void*)primitiveMPEG3GetTime},
	{(void*)_m, "primitiveMPEG3HasAudio\000\001\000", (void*)primitiveMPEG3HasAudio},
	{(void*)_m, "primitiveMPEG3HasVideo\000\001\000", (void*)primitiveMPEG3HasVideo},
	{(void*)_m, "primitiveMPEG3Open\000\000\000", (void*)primitiveMPEG3Open},
	{(void*)_m, "primitiveMPEG3OpenABuffer\000\000\000", (void*)primitiveMPEG3OpenABuffer},
	{(void*)_m, "primitiveMPEG3PreviousFrame\000\001\000", (void*)primitiveMPEG3PreviousFrame},
	{(void*)_m, "primitiveMPEG3ReadAudio\000\001\000", (void*)primitiveMPEG3ReadAudio},
	{(void*)_m, "primitiveMPEG3ReadFrame\000\001\000", (void*)primitiveMPEG3ReadFrame},
	{(void*)_m, "primitiveMPEG3ReadFrameBufferOffset\000\001\000", (void*)primitiveMPEG3ReadFrameBufferOffset},
	{(void*)_m, "primitiveMPEG3ReReadAudio\000\001\000", (void*)primitiveMPEG3ReReadAudio},
	{(void*)_m, "primitiveMPEG3SampleRate\000\001\000", (void*)primitiveMPEG3SampleRate},
	{(void*)_m, "primitiveMPEG3SeekPercentage\000\001\000", (void*)primitiveMPEG3SeekPercentage},
	{(void*)_m, "primitiveMPEG3SetCpus\000\001\000", (void*)primitiveMPEG3SetCpus},
	{(void*)_m, "primitiveMPEG3SetFrame\000\001\000", (void*)primitiveMPEG3SetFrame},
	{(void*)_m, "primitiveMPEG3SetMmx\000\001\000", (void*)primitiveMPEG3SetMmx},
	{(void*)_m, "primitiveMPEG3SetSample\000\001\000", (void*)primitiveMPEG3SetSample},
	{(void*)_m, "primitiveMPEG3TellPercentage\000\001\000", (void*)primitiveMPEG3TellPercentage},
	{(void*)_m, "primitiveMPEG3TotalAStreams\000\001\000", (void*)primitiveMPEG3TotalAStreams},
	{(void*)_m, "primitiveMPEG3TotalVStreams\000\001\000", (void*)primitiveMPEG3TotalVStreams},
	{(void*)_m, "primitiveMPEG3VideoFrames\000\001\000", (void*)primitiveMPEG3VideoFrames},
	{(void*)_m, "primitiveMPEG3VideoHeight\000\001\000", (void*)primitiveMPEG3VideoHeight},
	{(void*)_m, "primitiveMPEG3VideoWidth\000\001\000", (void*)primitiveMPEG3VideoWidth},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{(void*)_m, "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primitiveMPEG3AudioChannelsMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3AudioSamplesMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3CheckSigMetadata = 0;
EXPORT(signed short) primitiveMPEG3CloseMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3DropFramesMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3EndOfAudioMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3EndOfVideoMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3FrameRateMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3GenerateTocMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3GetFrameMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3GetSampleMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3GetTimeMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3HasAudioMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3HasVideoMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3OpenMetadata = 0;
EXPORT(signed short) primitiveMPEG3OpenABufferMetadata = 0;
EXPORT(signed short) primitiveMPEG3PreviousFrameMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3ReadAudioMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3ReadFrameMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3ReadFrameBufferOffsetMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3ReReadAudioMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3SampleRateMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3SeekPercentageMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3SetCpusMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3SetFrameMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3SetMmxMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3SetSampleMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3TellPercentageMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3TotalAStreamsMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3TotalVStreamsMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3VideoFramesMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3VideoHeightMetadata = 0x100;
EXPORT(signed short) primitiveMPEG3VideoWidthMetadata = 0x100;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
