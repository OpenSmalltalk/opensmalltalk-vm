/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.2950 uuid: dbcba85e-dc26-495f-9ce8-aa01633f6aa5
   from
	DESPlugin CryptographyPlugins-ul.22 uuid: 1308f614-8494-46ef-bffd-21a70d1f8dee
 */
static char __buildInfo[] = "DESPlugin CryptographyPlugins-ul.22 uuid: 1308f614-8494-46ef-bffd-21a70d1f8dee " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Constants ***/
#define PrimErrBadArgument 3
#define PrimErrBadNumArgs 5


/*** Function Prototypes ***/
static sqInt cookKeyto(unsigned int *rawPtr, unsigned int *cookPtr);
static sqInt encryptwith(unsigned int *dataPtr, unsigned int *key);
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primitiveDESCookKey(void);
EXPORT(sqInt) primitiveDESPluginAvailable(void);
EXPORT(sqInt) primitiveDESTransform(void);
static sqInt processKeymodeto(unsigned char *keyPtr, sqInt encode, unsigned int *cookedPtr);
static sqInt scrunchto(unsigned char *bytePtr, unsigned int *wordPtr);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt unscrunchto(unsigned int *wordPtr, unsigned char *bytePtr);


/*** Variables ***/
static unsigned int bigByte[24] = { 8388608,4194304,2097152,1048576,524288,262144,131072,65536,32768,16384,8192,4096,2048,1024,512,256,128,64,32,16,8,4,2,1, };
static unsigned short byteBit[8] = {
128,64,32,16,8,4,2,1 };

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*methodArgumentCount)(void);
static sqInt (*methodReturnBool)(sqInt boolean);
static sqInt (*pop)(sqInt nItems);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * firstIndexableField(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt methodArgumentCount(void);
extern sqInt methodReturnBool(sqInt boolean);
extern sqInt pop(sqInt nItems);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "DESPlugin CryptographyPlugins-ul.22 " INT_EXT;
static unsigned char pc1[56] = {
		56, 48, 40, 32, 24, 16,  8,	 0, 57, 49, 41, 33, 25, 17,
		 9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
		62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
		13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3 };
static unsigned char pc2[48] = {
		13, 16, 10, 23,  0,  4,	 2, 27, 14,  5, 20,  9,
		22, 18, 11,  3, 25,  7,	15,  6, 26, 19, 12,  1,
		40, 51, 30, 36, 46, 54,	 29, 39, 50, 44, 32, 47,
		43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
static unsigned int sp1[64] = {
		0x01010400, 0x00000000, 0x00010000, 0x01010404,
		0x01010004, 0x00010404, 0x00000004, 0x00010000,
		0x00000400, 0x01010400, 0x01010404, 0x00000400,
		0x01000404, 0x01010004, 0x01000000, 0x00000004,
		0x00000404, 0x01000400, 0x01000400, 0x00010400,
		0x00010400, 0x01010000, 0x01010000, 0x01000404,
		0x00010004, 0x01000004, 0x01000004, 0x00010004,
		0x00000000, 0x00000404, 0x00010404, 0x01000000,
		0x00010000, 0x01010404, 0x00000004, 0x01010000,
		0x01010400, 0x01000000, 0x01000000, 0x00000400,
		0x01010004, 0x00010000, 0x00010400, 0x01000004,
		0x00000400, 0x00000004, 0x01000404, 0x00010404,
		0x01010404, 0x00010004, 0x01010000, 0x01000404,
		0x01000004, 0x00000404, 0x00010404, 0x01010400,
		0x00000404, 0x01000400, 0x01000400, 0x00000000,
		0x00010004, 0x00010400, 0x00000000, 0x01010004L };
static unsigned int sp2[64] = {
		0x80108020, 0x80008000, 0x00008000, 0x00108020,
		0x00100000, 0x00000020, 0x80100020, 0x80008020,
		0x80000020, 0x80108020, 0x80108000, 0x80000000,
		0x80008000, 0x00100000, 0x00000020, 0x80100020,
		0x00108000, 0x00100020, 0x80008020, 0x00000000,
		0x80000000, 0x00008000, 0x00108020, 0x80100000,
		0x00100020, 0x80000020, 0x00000000, 0x00108000,
		0x00008020, 0x80108000, 0x80100000, 0x00008020,
		0x00000000, 0x00108020, 0x80100020, 0x00100000,
		0x80008020, 0x80100000, 0x80108000, 0x00008000,
		0x80100000, 0x80008000, 0x00000020, 0x80108020,
		0x00108020, 0x00000020, 0x00008000, 0x80000000,
		0x00008020, 0x80108000, 0x00100000, 0x80000020,
		0x00100020, 0x80008020, 0x80000020, 0x00100020,
		0x00108000, 0x00000000, 0x80008000, 0x00008020,
		0x80000000, 0x80100020, 0x80108020, 0x00108000L };
static unsigned int sp3[64] = {
		0x00000208, 0x08020200, 0x00000000, 0x08020008,
		0x08000200, 0x00000000, 0x00020208, 0x08000200,
		0x00020008, 0x08000008, 0x08000008, 0x00020000,
		0x08020208, 0x00020008, 0x08020000, 0x00000208,
		0x08000000, 0x00000008, 0x08020200, 0x00000200,
		0x00020200, 0x08020000, 0x08020008, 0x00020208,
		0x08000208, 0x00020200, 0x00020000, 0x08000208,
		0x00000008, 0x08020208, 0x00000200, 0x08000000,
		0x08020200, 0x08000000, 0x00020008, 0x00000208,
		0x00020000, 0x08020200, 0x08000200, 0x00000000,
		0x00000200, 0x00020008, 0x08020208, 0x08000200,
		0x08000008, 0x00000200, 0x00000000, 0x08020008,
		0x08000208, 0x00020000, 0x08000000, 0x08020208,
		0x00000008, 0x00020208, 0x00020200, 0x08000008,
		0x08020000, 0x08000208, 0x00000208, 0x08020000,
		0x00020208, 0x00000008, 0x08020008, 0x00020200L };
static unsigned int sp4[64] = {
		0x00802001, 0x00002081, 0x00002081, 0x00000080,
		0x00802080, 0x00800081, 0x00800001, 0x00002001,
		0x00000000, 0x00802000, 0x00802000, 0x00802081,
		0x00000081, 0x00000000, 0x00800080, 0x00800001,
		0x00000001, 0x00002000, 0x00800000, 0x00802001,
		0x00000080, 0x00800000, 0x00002001, 0x00002080,
		0x00800081, 0x00000001, 0x00002080, 0x00800080,
		0x00002000, 0x00802080, 0x00802081, 0x00000081,
		0x00800080, 0x00800001, 0x00802000, 0x00802081,
		0x00000081, 0x00000000, 0x00000000, 0x00802000,
		0x00002080, 0x00800080, 0x00800081, 0x00000001,
		0x00802001, 0x00002081, 0x00002081, 0x00000080,
		0x00802081, 0x00000081, 0x00000001, 0x00002000,
		0x00800001, 0x00002001, 0x00802080, 0x00800081,
		0x00002001, 0x00002080, 0x00800000, 0x00802001,
		0x00000080, 0x00800000, 0x00002000, 0x00802080L };
static unsigned int sp5[64] = {
		0x00000100, 0x02080100, 0x02080000, 0x42000100,
		0x00080000, 0x00000100, 0x40000000, 0x02080000,
		0x40080100, 0x00080000, 0x02000100, 0x40080100,
		0x42000100, 0x42080000, 0x00080100, 0x40000000,
		0x02000000, 0x40080000, 0x40080000, 0x00000000,
		0x40000100, 0x42080100, 0x42080100, 0x02000100,
		0x42080000, 0x40000100, 0x00000000, 0x42000000,
		0x02080100, 0x02000000, 0x42000000, 0x00080100,
		0x00080000, 0x42000100, 0x00000100, 0x02000000,
		0x40000000, 0x02080000, 0x42000100, 0x40080100,
		0x02000100, 0x40000000, 0x42080000, 0x02080100,
		0x40080100, 0x00000100, 0x02000000, 0x42080000,
		0x42080100, 0x00080100, 0x42000000, 0x42080100,
		0x02080000, 0x00000000, 0x40080000, 0x42000000,
		0x00080100, 0x02000100, 0x40000100, 0x00080000,
		0x00000000, 0x40080000, 0x02080100, 0x40000100 };
static unsigned int sp6[64] = {
		0x20000010, 0x20400000, 0x00004000, 0x20404010,
		0x20400000, 0x00000010, 0x20404010, 0x00400000,
		0x20004000, 0x00404010, 0x00400000, 0x20000010,
		0x00400010, 0x20004000, 0x20000000, 0x00004010,
		0x00000000, 0x00400010, 0x20004010, 0x00004000,
		0x00404000, 0x20004010, 0x00000010, 0x20400010,
		0x20400010, 0x00000000, 0x00404010, 0x20404000,
		0x00004010, 0x00404000, 0x20404000, 0x20000000,
		0x20004000, 0x00000010, 0x20400010, 0x00404000,
		0x20404010, 0x00400000, 0x00004010, 0x20000010,
		0x00400000, 0x20004000, 0x20000000, 0x00004010,
		0x20000010, 0x20404010, 0x00404000, 0x20400000,
		0x00404010, 0x20404000, 0x00000000, 0x20400010,
		0x00000010, 0x00004000, 0x20400000, 0x00404010,
		0x00004000, 0x00400010, 0x20004010, 0x00000000,
		0x20404000, 0x20000000, 0x00400010, 0x20004010L };
static unsigned int sp7[64] = {
		0x00200000, 0x04200002, 0x04000802, 0x00000000,
		0x00000800, 0x04000802, 0x00200802, 0x04200800,
		0x04200802, 0x00200000, 0x00000000, 0x04000002,
		0x00000002, 0x04000000, 0x04200002, 0x00000802,
		0x04000800, 0x00200802, 0x00200002, 0x04000800,
		0x04000002, 0x04200000, 0x04200800, 0x00200002,
		0x04200000, 0x00000800, 0x00000802, 0x04200802,
		0x00200800, 0x00000002, 0x04000000, 0x00200800,
		0x04000000, 0x00200800, 0x00200000, 0x04000802,
		0x04000802, 0x04200002, 0x04200002, 0x00000002,
		0x00200002, 0x04000000, 0x04000800, 0x00200000,
		0x04200800, 0x00000802, 0x00200802, 0x04200800,
		0x00000802, 0x04000002, 0x04200802, 0x04200000,
		0x00200800, 0x00000000, 0x00000002, 0x04200802,
		0x00000000, 0x00200802, 0x04200000, 0x00000800,
		0x04000002, 0x04000800, 0x00000800, 0x00200002 };
static unsigned int sp8[64] = {
		0x10001040, 0x00001000, 0x00040000, 0x10041040,
		0x10000000, 0x10001040, 0x00000040, 0x10000000,
		0x00040040, 0x10040000, 0x10041040, 0x00041000,
		0x10041000, 0x00041040, 0x00001000, 0x00000040,
		0x10040000, 0x10000040, 0x10001000, 0x00001040,
		0x00041000, 0x00040040, 0x10040040, 0x10041000,
		0x00001040, 0x00000000, 0x00000000, 0x10040040,
		0x10000040, 0x10001000, 0x00041040, 0x00040000,
		0x00041040, 0x00040000, 0x10041000, 0x00001000,
		0x00000040, 0x10040040, 0x00001000, 0x00041040,
		0x10001000, 0x00000040, 0x10000040, 0x10040000,
		0x10040040, 0x10000000, 0x00040000, 0x10001040,
		0x00000000, 0x10041040, 0x00040040, 0x10000040,
		0x10040000, 0x10001000, 0x10001040, 0x00000000,
		0x10041040, 0x00041000, 0x00041000, 0x00001040,
		0x00001040, 0x00040040, 0x10000000, 0x10041000 };
static unsigned char totRot[16] = { 1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28 };



/*	preprocess the key to more useful format */

	/* DESPlugin>>#cookKey:to: */
static sqInt
cookKeyto(unsigned int *rawPtr, unsigned int *cookPtr)
{
    unsigned int cook;
    sqInt i;
    unsigned int raw0;
    unsigned int raw1;


	/* 32 words */
	/* 32 words */
	for (i = 0; i <= 15; i += 1) {
		raw0 = rawPtr[i * 2];
		raw1 = rawPtr[(i * 2) + 1];
		cook = ((usqInt)((raw0 & 0xFC0000)) << 6);
		cook = cook | (((usqInt)((raw0 & 0xFC0)) << 10));
		cook = cook | (((usqInt)((raw1 & 0xFC0000))) >> 10);
		cook = cook | (((usqInt)((raw1 & 0xFC0))) >> 6);
		cookPtr[i * 2] = cook;
		cook = ((usqInt)((raw0 & 0x3F000)) << 12);
		cook = cook | (((usqInt)((raw0 & 0x3F)) << 16));
		cook = cook | (((usqInt)((raw1 & 0x3F000))) >> 4);
		cook = cook | (raw1 & 0x3F);
		cookPtr[(i * 2) + 1] = cook;
	}
	return 0;
}

	/* DESPlugin>>#encrypt:with: */
static sqInt
encryptwith(unsigned int *dataPtr, unsigned int *key)
{
    unsigned int fVal;
    unsigned int left;
    unsigned int right;
    sqInt round;
    unsigned int work;

	left = dataPtr[0];

	/* perform required but otherwise pointless bit twizzling */
	right = dataPtr[1];
	work = ((((usqInt)(left)) >> 4) ^ right) & 0xF0F0F0F;
	right = right ^ work;
	left = left ^ (((usqInt)(work) << 4));
	work = ((((usqInt)(left)) >> 16) ^ right) & 0xFFFF;
	right = right ^ work;
	left = left ^ (((usqInt)(work) << 16));
	work = ((((usqInt)(right)) >> 2) ^ left) & 0x33333333;
	left = left ^ work;
	right = right ^ (((usqInt)(work) << 2));
	work = ((((usqInt)(right)) >> 8) ^ left) & 0xFF00FF;
	left = left ^ work;
	right = right ^ (((usqInt)(work) << 8));
	right = ((((usqInt)(right) << 1)) | ((((usqInt)(right)) >> 0x1F) & 1)) & 0xFFFFFFFFU;
	work = (left ^ right) & 0xAAAAAAAAU;
	left = left ^ work;
	right = right ^ work;

	/* perform the 8 rounds of real encryption */
	left = ((((usqInt)(left) << 1)) | ((((usqInt)(left)) >> 0x1F) & 1)) & 0xFFFFFFFFU;
	for (round = 0; round <= 28; round += 4) {
		work = (((usqInt)(right) << 28)) | (((usqInt)(right)) >> 4);
		work = work ^ (key[round]);
		fVal = sp7[work & 0x3F];
		fVal = fVal | (sp5[(((usqInt)(work)) >> 8) & 0x3F]);
		fVal = fVal | (sp3[(((usqInt)(work)) >> 16) & 0x3F]);
		fVal = fVal | (sp1[(((usqInt)(work)) >> 24) & 0x3F]);
		work = right ^ (key[round + 1]);
		fVal = fVal | (sp8[work & 0x3F]);
		fVal = fVal | (sp6[(((usqInt)(work)) >> 8) & 0x3F]);
		fVal = fVal | (sp4[(((usqInt)(work)) >> 16) & 0x3F]);
		fVal = fVal | (sp2[(((usqInt)(work)) >> 24) & 0x3F]);
		left = left ^ fVal;
		work = (((usqInt)(left) << 28)) | (((usqInt)(left)) >> 4);
		work = work ^ (key[round + 2]);
		fVal = sp7[work & 0x3F];
		fVal = fVal | (sp5[(((usqInt)(work)) >> 8) & 0x3F]);
		fVal = fVal | (sp3[(((usqInt)(work)) >> 16) & 0x3F]);
		fVal = fVal | (sp1[(((usqInt)(work)) >> 24) & 0x3F]);
		work = left ^ (key[round + 3]);
		fVal = fVal | (sp8[work & 0x3F]);
		fVal = fVal | (sp6[(((usqInt)(work)) >> 8) & 0x3F]);
		fVal = fVal | (sp4[(((usqInt)(work)) >> 16) & 0x3F]);
		fVal = fVal | (sp2[(((usqInt)(work)) >> 24) & 0x3F]);
		right = right ^ fVal;
	}
	right = (((usqInt)(right) << 0x1F)) | (((usqInt)(right)) >> 1);
	work = (left ^ right) & 0xAAAAAAAAU;
	left = left ^ work;
	right = right ^ work;
	left = (((usqInt)(left) << 0x1F)) | (((usqInt)(left)) >> 1);
	work = ((((usqInt)(left)) >> 8) ^ right) & 0xFF00FF;
	right = right ^ work;
	left = left ^ (((usqInt)(work) << 8));
	work = ((((usqInt)(left)) >> 2) ^ right) & 0x33333333;
	right = right ^ work;
	left = left ^ (((usqInt)(work) << 2));
	work = ((((usqInt)(right)) >> 16) ^ left) & 0xFFFF;
	left = left ^ work;
	right = right ^ (((usqInt)(work) << 16));
	work = ((((usqInt)(right)) >> 4) ^ left) & 0xF0F0F0F;
	left = left ^ work;
	right = right ^ (((usqInt)(work) << 4));
	dataPtr[0] = right;
	dataPtr[1] = left;
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}


/*	preprocess the key to more useful format
	
	param1 = raw key: ByteArray[8]
	param2 = 1->encode 0->decode
	param3 = cooked key: WordArray[32] */

	/* DESPlugin>>#primitiveDESCookKey */
EXPORT(sqInt)
primitiveDESCookKey(void)
{
    sqInt cookedOop;
    sqInt encode;
    sqInt rawOop;

	if (!((methodArgumentCount()) == 3)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	rawOop = stackValue(2);
	if (!((isBytes(rawOop))
		 && ((stSizeOf(rawOop)) == 8))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	encode = stackIntegerValue(1);
	cookedOop = stackValue(0);
	if (!((isWords(cookedOop))
		 && ((stSizeOf(cookedOop)) == 32))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	processKeymodeto(firstIndexableField(rawOop), encode != 0, firstIndexableField(cookedOop));
	pop(3);
	return 0;
}

	/* DESPlugin>>#primitiveDESPluginAvailable */
EXPORT(sqInt)
primitiveDESPluginAvailable(void)
{
	methodReturnBool(1);
	return 0;
}


/*	encrypt/decrypt some data
	
	param1 = data key: ByteArray[8]
	param2 = cooked key: WordArray[32] */

	/* DESPlugin>>#primitiveDESTransform */
EXPORT(sqInt)
primitiveDESTransform(void)
{
    sqInt cookedOop;
    unsigned char *data;
    sqInt dataOop;
    unsigned int fVal;
    unsigned int *key;
    unsigned int left;
    unsigned int right;
    sqInt round;
    unsigned int work[2];
    unsigned int work1;

	/* Hi ho, Hi ho...*/;
	if (!((methodArgumentCount()) == 2)) {
		return primitiveFailFor(PrimErrBadNumArgs);
	}
	dataOop = stackValue(1);
	if (!((isBytes(dataOop))
		 && ((stSizeOf(dataOop)) == 8))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	cookedOop = stackValue(0);
	if (!((isWords(cookedOop))
		 && ((stSizeOf(cookedOop)) == 32))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	data = firstIndexableField(dataOop);
	/* begin scrunch:to: */
	work[0] = ((((((usqInt)((data[0])) << 24)) + (((usqInt)((data[1])) << 16))) + (((usqInt)((data[2])) << 8))) + (data[3]));
	work[1] = ((((((usqInt)((data[4])) << 24)) + (((usqInt)((data[5])) << 16))) + (((usqInt)((data[6])) << 8))) + (data[7]));
	/* begin encrypt:with: */
	key = firstIndexableField(cookedOop);
	left = work[0];

	/* perform required but otherwise pointless bit twizzling */
	right = work[1];
	work1 = ((((usqInt)(left)) >> 4) ^ right) & 0xF0F0F0F;
	right = right ^ work1;
	left = left ^ (((usqInt)(work1) << 4));
	work1 = ((((usqInt)(left)) >> 16) ^ right) & 0xFFFF;
	right = right ^ work1;
	left = left ^ (((usqInt)(work1) << 16));
	work1 = ((((usqInt)(right)) >> 2) ^ left) & 0x33333333;
	left = left ^ work1;
	right = right ^ (((usqInt)(work1) << 2));
	work1 = ((((usqInt)(right)) >> 8) ^ left) & 0xFF00FF;
	left = left ^ work1;
	right = right ^ (((usqInt)(work1) << 8));
	right = ((((usqInt)(right) << 1)) | ((((usqInt)(right)) >> 0x1F) & 1)) & 0xFFFFFFFFU;
	work1 = (left ^ right) & 0xAAAAAAAAU;
	left = left ^ work1;
	right = right ^ work1;

	/* perform the 8 rounds of real encryption */
	left = ((((usqInt)(left) << 1)) | ((((usqInt)(left)) >> 0x1F) & 1)) & 0xFFFFFFFFU;
	for (round = 0; round <= 28; round += 4) {
		work1 = (((usqInt)(right) << 28)) | (((usqInt)(right)) >> 4);
		work1 = work1 ^ (key[round]);
		fVal = sp7[work1 & 0x3F];
		fVal = fVal | (sp5[(((usqInt)(work1)) >> 8) & 0x3F]);
		fVal = fVal | (sp3[(((usqInt)(work1)) >> 16) & 0x3F]);
		fVal = fVal | (sp1[(((usqInt)(work1)) >> 24) & 0x3F]);
		work1 = right ^ (key[round + 1]);
		fVal = fVal | (sp8[work1 & 0x3F]);
		fVal = fVal | (sp6[(((usqInt)(work1)) >> 8) & 0x3F]);
		fVal = fVal | (sp4[(((usqInt)(work1)) >> 16) & 0x3F]);
		fVal = fVal | (sp2[(((usqInt)(work1)) >> 24) & 0x3F]);
		left = left ^ fVal;
		work1 = (((usqInt)(left) << 28)) | (((usqInt)(left)) >> 4);
		work1 = work1 ^ (key[round + 2]);
		fVal = sp7[work1 & 0x3F];
		fVal = fVal | (sp5[(((usqInt)(work1)) >> 8) & 0x3F]);
		fVal = fVal | (sp3[(((usqInt)(work1)) >> 16) & 0x3F]);
		fVal = fVal | (sp1[(((usqInt)(work1)) >> 24) & 0x3F]);
		work1 = left ^ (key[round + 3]);
		fVal = fVal | (sp8[work1 & 0x3F]);
		fVal = fVal | (sp6[(((usqInt)(work1)) >> 8) & 0x3F]);
		fVal = fVal | (sp4[(((usqInt)(work1)) >> 16) & 0x3F]);
		fVal = fVal | (sp2[(((usqInt)(work1)) >> 24) & 0x3F]);
		right = right ^ fVal;
	}
	right = (((usqInt)(right) << 0x1F)) | (((usqInt)(right)) >> 1);
	work1 = (left ^ right) & 0xAAAAAAAAU;
	left = left ^ work1;
	right = right ^ work1;
	left = (((usqInt)(left) << 0x1F)) | (((usqInt)(left)) >> 1);
	work1 = ((((usqInt)(left)) >> 8) ^ right) & 0xFF00FF;
	right = right ^ work1;
	left = left ^ (((usqInt)(work1) << 8));
	work1 = ((((usqInt)(left)) >> 2) ^ right) & 0x33333333;
	right = right ^ work1;
	left = left ^ (((usqInt)(work1) << 2));
	work1 = ((((usqInt)(right)) >> 16) ^ left) & 0xFFFF;
	left = left ^ work1;
	right = right ^ (((usqInt)(work1) << 16));
	work1 = ((((usqInt)(right)) >> 4) ^ left) & 0xF0F0F0F;
	left = left ^ work1;
	right = right ^ (((usqInt)(work1) << 4));
	work[0] = right;
	work[1] = left;
	/* begin unscrunch:to: */
	data[0] = ((((usqInt)((work[0]))) >> 24) & 0xFF);
	data[1] = ((((usqInt)((work[0]))) >> 16) & 0xFF);
	data[2] = ((((usqInt)((work[0]))) >> 8) & 0xFF);
	data[3] = ((work[0]) & 0xFF);
	data[4] = ((((usqInt)((work[1]))) >> 24) & 0xFF);
	data[5] = ((((usqInt)((work[1]))) >> 16) & 0xFF);
	data[6] = ((((usqInt)((work[1]))) >> 8) & 0xFF);
	data[7] = ((work[1]) & 0xFF);
	pop(2);
	return 0;
}

	/* DESPlugin>>#processKey:mode:to: */
static sqInt
processKeymodeto(unsigned char *keyPtr, sqInt encode, unsigned int *cookedPtr)
{
    unsigned int cook;
    sqInt i;
    sqInt i1;
    sqInt j;
    unsigned char l;
    sqInt m;
    sqInt n;
    unsigned char pc1m[56];
    unsigned char pcr[56];
    unsigned int raw0;
    unsigned int raw1;
    unsigned int rawKey[32];

	/* Who is Keyser Soze? */;
	for (j = 0; j <= 55; j += 1) {
		l = pc1[j];
		m = l & 7;
		if (((keyPtr[((usqInt)(l)) >> 3]) & (byteBit[m])) != 0) {
			pc1m[j] = 1;
		}
		else {
			pc1m[j] = 0;
		}
	}
	for (i = 0; i <= 15; i += 1) {
		if (encode) {
			m = ((sqInt)((usqInt)(i) << 1));
		}
		else {
			m = ((sqInt)((usqInt)((15 - i)) << 1));
		}
		n = m + 1;
		rawKey[m] = (rawKey[n] = 0);
		for (j = 0; j <= 27; j += 1) {
			l = j + (totRot[i]);
			if (l < 28) {
				pcr[j] = (pc1m[l]);
			}
			else {
				pcr[j] = (pc1m[l - 28]);
			}
		}
		for (j = 28; j <= 55; j += 1) {
			l = j + (totRot[i]);
			if (l < 56) {
				pcr[j] = (pc1m[l]);
			}
			else {
				pcr[j] = (pc1m[l - 28]);
			}
		}
		for (j = 0; j <= 23; j += 1) {
			if ((pcr[pc2[j]]) != 0) {
				rawKey[m] = ((rawKey[m]) | (bigByte[j]));
			}
			if ((pcr[pc2[j + 24]]) != 0) {
				rawKey[n] = ((rawKey[n]) | (bigByte[j]));
			}
		}
	}
	/* begin cookKey:to: */
	for (i1 = 0; i1 <= 15; i1 += 1) {
		raw0 = rawKey[i1 * 2];
		raw1 = rawKey[(i1 * 2) + 1];
		cook = ((usqInt)((raw0 & 0xFC0000)) << 6);
		cook = cook | (((usqInt)((raw0 & 0xFC0)) << 10));
		cook = cook | (((usqInt)((raw1 & 0xFC0000))) >> 10);
		cook = cook | (((usqInt)((raw1 & 0xFC0))) >> 6);
		cookedPtr[i1 * 2] = cook;
		cook = ((usqInt)((raw0 & 0x3F000)) << 12);
		cook = cook | (((usqInt)((raw0 & 0x3F)) << 16));
		cook = cook | (((usqInt)((raw1 & 0x3F000))) >> 4);
		cook = cook | (raw1 & 0x3F);
		cookedPtr[(i1 * 2) + 1] = cook;
	}
	return 0;
}

	/* DESPlugin>>#scrunch:to: */
static sqInt
scrunchto(unsigned char *bytePtr, unsigned int *wordPtr)
{
	wordPtr[0] = ((((((usqInt)((bytePtr[0])) << 24)) + (((usqInt)((bytePtr[1])) << 16))) + (((usqInt)((bytePtr[2])) << 8))) + (bytePtr[3]));
	wordPtr[1] = ((((((usqInt)((bytePtr[4])) << 24)) + (((usqInt)((bytePtr[5])) << 16))) + (((usqInt)((bytePtr[6])) << 8))) + (bytePtr[7]));
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		firstIndexableField = interpreterProxy->firstIndexableField;
		isBytes = interpreterProxy->isBytes;
		isWords = interpreterProxy->isWords;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		methodReturnBool = interpreterProxy->methodReturnBool;
		pop = interpreterProxy->pop;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* DESPlugin>>#unscrunch:to: */
static sqInt
unscrunchto(unsigned int *wordPtr, unsigned char *bytePtr)
{
	bytePtr[0] = ((((usqInt)((wordPtr[0]))) >> 24) & 0xFF);
	bytePtr[1] = ((((usqInt)((wordPtr[0]))) >> 16) & 0xFF);
	bytePtr[2] = ((((usqInt)((wordPtr[0]))) >> 8) & 0xFF);
	bytePtr[3] = ((wordPtr[0]) & 0xFF);
	bytePtr[4] = ((((usqInt)((wordPtr[1]))) >> 24) & 0xFF);
	bytePtr[5] = ((((usqInt)((wordPtr[1]))) >> 16) & 0xFF);
	bytePtr[6] = ((((usqInt)((wordPtr[1]))) >> 8) & 0xFF);
	bytePtr[7] = ((wordPtr[1]) & 0xFF);
	return 0;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "DESPlugin";
void* DESPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveDESCookKey\000\001", (void*)primitiveDESCookKey},
	{(void*)_m, "primitiveDESPluginAvailable\000\377", (void*)primitiveDESPluginAvailable},
	{(void*)_m, "primitiveDESTransform\000\001", (void*)primitiveDESTransform},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

EXPORT(signed char) primitiveDESCookKeyAccessorDepth = 1;
EXPORT(signed char) primitiveDESTransformAccessorDepth = 1;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
