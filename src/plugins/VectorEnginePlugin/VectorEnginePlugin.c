/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-eem.3328 uuid: a1c7c55f-8829-4fcc-9a66-55ba7d1a8cef
   from
	VectorEnginePlugin VectorEnginePlugin-mt.16 uuid: eb9cb5f6-37a7-e042-946d-a80971ef3451
 */
static char __buildInfo[] = "VectorEnginePlugin VectorEnginePlugin-mt.16 uuid: eb9cb5f6-37a7-e042-946d-a80971ef3451 " __DATE__ ;


#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stdint.h>

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#include "sqMemoryAccess.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif


/*** Function Prototypes ***/
static sqInt blendFillOnlyAtredIsInsidegreenIsInsideblueIsInsideantiAliasAlphasWord(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside, uint32_t antiAliasAlphasWord);
static sqInt blendFillOnlyWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits);
static sqInt blendStrokeAndFillAtredIsInsidegreenIsInsideblueIsInsideantiAliasAlphasWord(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside, uint32_t antiAliasAlphasWord);
static sqInt blendStrokeAndFillInsideWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits);
static sqInt blendStrokeAndFillOutsideWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits);
static sqInt blendStrokeOnlyAtantiAliasAlphasWord(sqInt pixelIndex, uint32_t antiAliasAlphasWord);
static sqInt blendStrokeOnlyWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits);
EXPORT(const char*) getModuleName(void);
static sqInt initializeTrajectoryFragment(void);
EXPORT(sqInt) pluginApiVersion(void);
EXPORT(sqInt) primAntiAliasingWidthsubPixelDeltaHopLength(void);
EXPORT(sqInt) primArc(void);
EXPORT(sqInt) primArcWP(void);
EXPORT(sqInt) primBlendFillOnly(void);
EXPORT(sqInt) primBlendFillOnlyWPOT(void);
EXPORT(sqInt) primBlendStrokeAndFill(void);
EXPORT(sqInt) primBlendStrokeAndFillWPOT(void);
EXPORT(sqInt) primBlendStrokeOnly(void);
EXPORT(sqInt) primBlendStrokeOnlyWPOT(void);
EXPORT(sqInt) primClipCurrentMorph(void);
EXPORT(sqInt) primClipLeftclipTopclipRightclipBottom(void);
EXPORT(sqInt) primCubicBezier(void);
EXPORT(sqInt) primCubicBezierWP(void);
EXPORT(sqInt) primCurrentMorphIdcurrentClipsSubmorphs(void);
EXPORT(sqInt) primDisplayString(void);
EXPORT(sqInt) primDisplayStringWP(void);
EXPORT(sqInt) primDisplayUtf32(void);
EXPORT(sqInt) primDisplayUtf32WP(void);
EXPORT(sqInt) primDisplayUtf8(void);
EXPORT(sqInt) primDisplayUtf8WP(void);
EXPORT(sqInt) primFillRGBA(void);
EXPORT(sqInt) primGeometryTxSet(void);
EXPORT(sqInt) primInitializePath(void);
EXPORT(sqInt) primLine(void);
EXPORT(sqInt) primLineWP(void);
EXPORT(sqInt) primNewTrajectoryFragment(void);
EXPORT(sqInt) primPathSequence(void);
EXPORT(sqInt) primPathSequenceWP(void);
EXPORT(sqInt) primQuadraticBezier(void);
EXPORT(sqInt) primQuadraticBezierWP(void);
EXPORT(sqInt) primReset2Contour(void);
EXPORT(sqInt) primSetTarget(void);
EXPORT(sqInt) primSetTargetWP(void);
EXPORT(sqInt) primSpanBottom(void);
EXPORT(sqInt) primSpanLeft(void);
EXPORT(sqInt) primSpanRight(void);
EXPORT(sqInt) primSpanTop(void);
EXPORT(sqInt) primStrokeRGBA(void);
EXPORT(sqInt) primStrokeWidth(void);
EXPORT(sqInt) primUpdate2ContourLastLine(void);
static sqInt pvt_cubicBezierFromXytoXycontrol1Xycontrol2Xy(float xFrom, float yFrom, float xTo, float yTo, float xControl1, float yControl1, float xControl2, float yControl2);
static sqInt pvt_cubicBezierWPFromXytoXycontrol1Xycontrol2Xy(float xFrom, float yFrom, float xTo, float yTo, float xControl1, float yControl1, float xControl2, float yControl2);
static sqInt pvt_lineFromXytoXy(float xFrom, float yFrom, float xTo, float yTo);
static sqInt pvt_lineWPFromXytoXy(float xFrom, float yFrom, float xTo, float yTo);
static sqInt pvt_quadraticBezierFromXytoXycontrolXy(float xFrom, float yFrom, float xTo, float yTo, float xControl, float yControl);
static sqInt pvt_quadraticBezierWPFromXytoXycontrolXy(float xFrom, float yFrom, float xTo, float yTo, float xControl, float yControl);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);
static sqInt updateAlphasForXy(float x, float y);
static sqInt updateAlphasWPForXy(float x, float y);
static sqInt updateAlphasWPZeroStrokeForXy(float x, float y);
static sqInt updateContourForXy(float x, float y);
static sqInt updateEdgeCountAtXy(float x, float y);
static sqInt updateEdgeCountWPAtXy(float x, float y);


/*** Variables ***/
static uint32_t * alphaMask;
static uint8_t * alphaMaskWP;
static sqInt clipBottom;
static sqInt clipCurrentMorph;
static sqInt clipLeft;
static sqInt clipRight;
static sqInt clipTop;
static float * contour;
static sqInt currentClipsSubmorphs;
static uint32_t * edgeCounts;
static uint8_t * edgeCountsWP;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*failed)(void);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*floatObjectOf)(double aFloat);
#if !defined(integerObjectOf)
static sqInt (*integerObjectOf)(sqInt value);
#endif
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
static sqInt (*isBooleanObject)(sqInt oop);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*isFloatObject)(sqInt oop);
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isWords)(sqInt oop);
static sqInt (*isWordsOrBytes)(sqInt oop);
static sqInt (*methodReturnValue)(sqInt oop);
static sqInt (*pop)(sqInt nItems);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static double (*stackFloatValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt failed(void);
extern void * firstIndexableField(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
#if !defined(integerObjectOf)
extern sqInt integerObjectOf(sqInt value);
#endif
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
extern sqInt isBooleanObject(sqInt oop);
#else
# define isBooleanObject(oop) 0
#endif
extern sqInt isBytes(sqInt oop);
extern sqInt isFloatObject(sqInt oop);
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
extern sqInt isWords(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt pop(sqInt nItems);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern double stackFloatValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "VectorEnginePlugin VectorEnginePlugin-mt.16 " INT_EXT;
static uint32_t * morphIds;
static sqInt prevYRounded;
static sqInt prevYTruncated;
static uint32_t * targetBits;
static sqInt targetHeight;
static sqInt targetWidth;
static uint32_t currentMorphId;
static float antiAliasingWidth;
static float auxAntiAliasingWidthScaledInverse;
static float auxStrokeWidthDilatedHalf;
static float auxStrokeWidthDilatedHalfSquared;
static float auxStrokeWidthErodedHalfSquared;
static float fillA;
static float fillB;
static float fillG;
static float fillR;
static float hop;
static float leftAtThisY;
static float rightAtThisY;
static float spanBottom;
static float spanLeft;
static float spanRight;
static float spanTop;
static float strokeA;
static float strokeB;
static float strokeG;
static float strokeR;
static float strokeWidth;
static float subPixelDelta;
static float txA11;
static float txA12;
static float txA13;
static float txA21;
static float txA22;
static float txA23;



/*	Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendFillOnlyAt:redIsInside:greenIsInside:blueIsInside:antiAliasAlphasWord: */
static sqInt
blendFillOnlyAtredIsInsidegreenIsInsideblueIsInsideantiAliasAlphasWord(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside, uint32_t antiAliasAlphasWord)
{
	float alphaB;
	float alphaG;
	float alphaR;
	float antiAliasBlueAlpha;
	uint32_t antiAliasBlueAlphaBits;
	float antiAliasGreenAlpha;
	uint32_t antiAliasGreenAlphaBits;
	uint32_t antiAliasGreenAlphaBitsShifted;
	float antiAliasRedAlpha;
	uint32_t antiAliasRedAlphaBits;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	uint32_t morphIdWord;
	float resultAlphaB;
	uint32_t resultAlphaBits;
	float resultAlphaG;
	float resultAlphaR;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	float targetAlpha;
	uint32_t targetWord;
	float unAlphaB;
	float unAlphaG;
	float unAlphaR;

	antiAliasRedAlphaBits = antiAliasAlphasWord & 0x7F0000;
	antiAliasGreenAlphaBits = antiAliasAlphasWord & 0x7F00;
	antiAliasBlueAlphaBits = antiAliasAlphasWord & 0x7F;
	if (isRedInside) {
		antiAliasRedAlphaBits = 0x7F0000 - antiAliasRedAlphaBits;
	}
	if (isGreenInside) {
		antiAliasGreenAlphaBits = 0x7F00 - antiAliasGreenAlphaBits;
	}
	if (isBlueInside) {
		antiAliasBlueAlphaBits = 0x7F - antiAliasBlueAlphaBits;
	}
	antiAliasRedAlpha = antiAliasRedAlphaBits * (1.0 / (8.323072e6));
	antiAliasGreenAlpha = antiAliasGreenAlphaBits * (1.0 / (32512.0));
	antiAliasBlueAlpha = antiAliasBlueAlphaBits * (1.0 / 127.0);
	alphaR = antiAliasRedAlpha * fillA;
	alphaG = antiAliasGreenAlpha * fillA;
	alphaB = antiAliasBlueAlpha * fillA;
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		morphIdWord = morphIds[pixelIndex];
		clippingAntiAliasBits = morphIdWord & 0x7F;
		
					antiAliasGreenAlphaBitsShifted = antiAliasGreenAlphaBits >> 8;
		if (antiAliasGreenAlphaBitsShifted > clippingAntiAliasBits) {
			clippingAntiAliasBits = antiAliasGreenAlphaBitsShifted;
		}
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;
			clippingAntiAlias = clippingAntiAliasBits * (1.0 / 127.0);
			alphaR = alphaR * clippingAntiAlias;
			alphaG = alphaG * clippingAntiAlias;
			alphaB = alphaB * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(((alphaR + alphaG) + alphaB) == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultAlphaBits = targetWord & 0xFF000000U;
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;

		/* These if are not really needed. just ignore them if we use simd instructions. */
		targetAlpha = resultAlphaBits * (1.0 / (4.27819008e9));
		if (!(alphaR == 0.0)) {
			unAlphaR = 1.0 - alphaR;
			resultAlphaR = alphaR + (unAlphaR * targetAlpha);
			
					resultR = (alphaR * fillR) + ((unAlphaR * (resultRBits >> 16)) * targetAlpha);
					resultRBits = (uint32_t)(resultR / resultAlphaR + 0.5) << 16;
		}
		if (!(alphaG == 0.0)) {
			unAlphaG = 1.0 - alphaG;
			resultAlphaG = alphaG + (unAlphaG * targetAlpha);
			
					resultG = (alphaG * fillG) + ((unAlphaG * (resultGBits >> 8)) * targetAlpha);
					resultGBits = (uint32_t)(resultG / resultAlphaG + 0.5) << 8;
					resultAlphaBits = (uint32_t)(resultAlphaG * 255.0 + 0.5) << 24;
		}
		if (!(alphaB == 0.0)) {
			unAlphaB = 1.0 - alphaB;
			resultAlphaB = alphaB + (unAlphaB * targetAlpha);
			
					resultB = (alphaB * fillB) + ((unAlphaB * resultBBits) * targetAlpha);
					resultBBits = (uint32_t)(resultB / resultAlphaB + 0.5);
		}
		targetWord = ((resultAlphaBits | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Blends fill color over background.
	WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendFillOnlyWPOTAt:antiAliasAlphaByte: */
static sqInt
blendFillOnlyWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits)
{
	float alpha;
	float antiAliasAlpha;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	uint32_t morphIdWord;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	uint32_t targetWord;
	float unAlpha;


	/* 1.0/127.0 */
	antiAliasAlpha = antiAliasAlphaBits * 0.007874;
	alpha = antiAliasAlpha * fillA;
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		morphIdWord = morphIds[pixelIndex];
		clippingAntiAliasBits = morphIdWord & 0x7F;
		if (antiAliasAlphaBits > clippingAntiAliasBits) {
			clippingAntiAliasBits = antiAliasAlphaBits;
		}
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;

			/* 1.0/127.0 */
			clippingAntiAlias = clippingAntiAliasBits * 0.007874;
			alpha = alpha * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(alpha == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;
		unAlpha = 1.0 - alpha;
		
				resultR = (alpha * fillR) + (unAlpha * (resultRBits >> 16));
				resultRBits = (uint32_t)(resultR + 0.5) << 16;
				resultG = (alpha * fillG) + (unAlpha * (resultGBits >> 8));
				resultGBits = (uint32_t)(resultG + 0.5) << 8;
				resultB = (alpha * fillB) + (unAlpha * resultBBits);
				resultBBits = (uint32_t)(resultB + 0.5);
		targetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Blends stroke color and fill color over background.
	Do an appropriate (anti aliased) gradient between stoke color and fill
	color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeAndFillAt:redIsInside:greenIsInside:blueIsInside:antiAliasAlphasWord: */
static sqInt
blendStrokeAndFillAtredIsInsidegreenIsInsideblueIsInsideantiAliasAlphasWord(sqInt pixelIndex, sqInt isRedInside, sqInt isGreenInside, sqInt isBlueInside, uint32_t antiAliasAlphasWord)
{
	float alphaB;
	float alphaG;
	float alphaR;
	float antiAliasBlueAlpha;
	uint32_t antiAliasBlueAlphaBits;
	float antiAliasGreenAlpha;
	uint32_t antiAliasGreenAlphaBits;
	uint32_t antiAliasGreenAlphaBitsShifted;
	float antiAliasRedAlpha;
	uint32_t antiAliasRedAlphaBits;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	float foreB;
	float foreG;
	float foreR;
	uint32_t morphIdWord;
	float resultAlphaB;
	uint32_t resultAlphaBits;
	float resultAlphaG;
	float resultAlphaR;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	float targetAlpha;
	uint32_t targetWord;
	float unAlphaB;
	float unAlphaG;
	float unAlphaR;

	antiAliasRedAlphaBits = antiAliasAlphasWord & 0x7F0000;
	antiAliasGreenAlphaBits = antiAliasAlphasWord & 0x7F00;
	antiAliasBlueAlphaBits = antiAliasAlphasWord & 0x7F;
	antiAliasRedAlpha = antiAliasRedAlphaBits * (1.0 / (8.323072e6));
	antiAliasGreenAlpha = antiAliasGreenAlphaBits * (1.0 / (32512.0));
	antiAliasBlueAlpha = antiAliasBlueAlphaBits * (1.0 / 127.0);
	if (isRedInside) {

		/* Do gradient between stroke and fill. Blend the result over background */
		alphaR = (antiAliasRedAlpha * strokeA) + ((1.0 - antiAliasRedAlpha) * fillA);
		foreR = (antiAliasRedAlpha * strokeR) + ((1.0 - antiAliasRedAlpha) * fillR);
	}
	else {

		/* Blend stroke over background */
		alphaR = antiAliasRedAlpha * strokeA;
		foreR = strokeR;
	}
	if (isGreenInside) {

		/* Do gradient between stroke and fill. Blend the result over background */
		alphaG = (antiAliasGreenAlpha * strokeA) + ((1.0 - antiAliasGreenAlpha) * fillA);
		foreG = (antiAliasGreenAlpha * strokeG) + ((1.0 - antiAliasGreenAlpha) * fillG);
	}
	else {

		/* Blend stroke over background */
		alphaG = antiAliasGreenAlpha * strokeA;
		foreG = strokeG;
	}
	if (isBlueInside) {

		/* Do gradient between stroke and fill. Blend the result over background */
		alphaB = (antiAliasBlueAlpha * strokeA) + ((1.0 - antiAliasBlueAlpha) * fillA);
		foreB = (antiAliasBlueAlpha * strokeB) + ((1.0 - antiAliasBlueAlpha) * fillB);
	}
	else {

		/* Blend stroke over background */
		alphaB = antiAliasBlueAlpha * strokeA;
		foreB = strokeB;
	}
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		if (isGreenInside) {
			clippingAntiAliasBits = 0x7F;
		}
		else {
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;
			
							antiAliasGreenAlphaBitsShifted = antiAliasGreenAlphaBits >> 8;
			if (antiAliasGreenAlphaBitsShifted > clippingAntiAliasBits) {
				clippingAntiAliasBits = antiAliasGreenAlphaBitsShifted;
			}
		}
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;
			clippingAntiAlias = clippingAntiAliasBits * (1.0 / 127.0);
			alphaR = alphaR * clippingAntiAlias;
			alphaG = alphaG * clippingAntiAlias;
			alphaB = alphaB * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(((alphaR + alphaG) + alphaB) == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultAlphaBits = targetWord & 0xFF000000U;
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;

		/* These if are not really needed. just ignore them if we use simd instructions. */
		targetAlpha = resultAlphaBits * (1.0 / (4.27819008e9));
		if (!(alphaR == 0.0)) {
			unAlphaR = 1.0 - alphaR;
			resultAlphaR = alphaR + (unAlphaR * targetAlpha);
			
					resultR = (alphaR * foreR) + ((unAlphaR * (resultRBits >> 16)) * targetAlpha);
					resultRBits = (uint32_t)(resultR / resultAlphaR + 0.5) << 16;
		}
		if (!(alphaG == 0.0)) {
			unAlphaG = 1.0 - alphaG;
			resultAlphaG = alphaG + (unAlphaG * targetAlpha);
			
					resultG = (alphaG * foreG) + ((unAlphaG * (resultGBits >> 8)) * targetAlpha);
					resultGBits = (uint32_t)(resultG / resultAlphaG + 0.5) << 8;
					resultAlphaBits = (uint32_t)(resultAlphaG * 255.0 + 0.5) << 24;
		}
		if (!(alphaB == 0.0)) {
			unAlphaB = 1.0 - alphaB;
			resultAlphaB = alphaB + (unAlphaB * targetAlpha);
			
					resultB = (alphaB * foreB) + ((unAlphaB * resultBBits) * targetAlpha);
					resultBBits = (uint32_t)(resultB / resultAlphaB + 0.5);
		}
		targetWord = ((resultAlphaBits | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Inside the shape: Do an appropriate (anti aliased) gradient between stoke
	color and fill color (or pick just stroke or just fill).
	Blend this over background.
	WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeAndFillInsideWPOTAt:antiAliasAlphaByte: */
static sqInt
blendStrokeAndFillInsideWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits)
{
	float alpha;
	float antiAliasAlpha;
	float antiAliasUnAlpha;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	float foreB;
	float foreG;
	float foreR;
	uint32_t morphIdWord;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	uint32_t targetWord;
	float unAlpha;


	/* 1.0/127.0 */
	antiAliasAlpha = antiAliasAlphaBits * 0.007874;

	/* We are inside the shape */
	antiAliasUnAlpha = 1.0 - antiAliasAlpha;
	alpha = (antiAliasAlpha * strokeA) + (antiAliasUnAlpha * fillA);
	foreR = (antiAliasAlpha * strokeR) + (antiAliasUnAlpha * fillR);
	foreG = (antiAliasAlpha * strokeG) + (antiAliasUnAlpha * fillG);
	foreB = (antiAliasAlpha * strokeB) + (antiAliasUnAlpha * fillB);
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		/* We are inside the shape */
		clippingAntiAliasBits = 0x7F;
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;

			/* 1.0/127.0 */
			clippingAntiAlias = clippingAntiAliasBits * 0.007874;
			alpha = alpha * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(alpha == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;
		unAlpha = 1.0 - alpha;
		
				resultR = (alpha * foreR) + (unAlpha * (resultRBits >> 16));
				resultRBits = (uint32_t)(resultR + 0.5) << 16;
				resultG = (alpha * foreG) + (unAlpha * (resultGBits >> 8));
				resultGBits = (uint32_t)(resultG + 0.5) << 8;
				resultB = (alpha * foreB) + (unAlpha * resultBBits);
				resultBBits = (uint32_t)(resultB + 0.5);
		targetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Outside the shape, but still in the stroke: Blend stroke color over
	background. WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeAndFillOutsideWPOTAt:antiAliasAlphaByte: */
static sqInt
blendStrokeAndFillOutsideWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits)
{
	float alpha;
	float antiAliasAlpha;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	float foreB;
	float foreG;
	float foreR;
	uint32_t morphIdWord;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	uint32_t targetWord;
	float unAlpha;


	/* 1.0/127.0 */
	/* In the stroke, outside the shape */
	antiAliasAlpha = antiAliasAlphaBits * 0.007874;
	alpha = antiAliasAlpha * strokeA;
	foreR = strokeR;
	foreG = strokeG;
	foreB = strokeB;
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		morphIdWord = morphIds[pixelIndex];
		clippingAntiAliasBits = morphIdWord & 0x7F;
		if (antiAliasAlphaBits > clippingAntiAliasBits) {
			clippingAntiAliasBits = antiAliasAlphaBits;
		}
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;

			/* 1.0/127.0 */
			clippingAntiAlias = clippingAntiAliasBits * 0.007874;
			alpha = alpha * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(alpha == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;
		unAlpha = 1.0 - alpha;
		
				resultR = (alpha * foreR) + (unAlpha * (resultRBits >> 16));
				resultRBits = (uint32_t)(resultR + 0.5) << 16;
				resultG = (alpha * foreG) + (unAlpha * (resultGBits >> 8));
				resultGBits = (uint32_t)(resultG + 0.5) << 8;
				resultB = (alpha * foreB) + (unAlpha * resultBBits);
				resultBBits = (uint32_t)(resultB + 0.5);
		targetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Blends stroke color over background. Target translucency computed
	correctly. For blending, alphas are in [0 .. 1.0] and R, G, B color
	components are in [0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeOnlyAt:antiAliasAlphasWord: */
static sqInt
blendStrokeOnlyAtantiAliasAlphasWord(sqInt pixelIndex, uint32_t antiAliasAlphasWord)
{
	float alphaB;
	float alphaG;
	float alphaR;
	float antiAliasBlueAlpha;
	uint32_t antiAliasBlueAlphaBits;
	float antiAliasGreenAlpha;
	uint32_t antiAliasGreenAlphaBits;
	uint32_t antiAliasGreenAlphaBitsShifted;
	float antiAliasRedAlpha;
	uint32_t antiAliasRedAlphaBits;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	uint32_t morphIdWord;
	float resultAlphaB;
	uint32_t resultAlphaBits;
	float resultAlphaG;
	float resultAlphaR;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	float targetAlpha;
	uint32_t targetWord;
	float unAlphaB;
	float unAlphaG;
	float unAlphaR;

	antiAliasRedAlphaBits = antiAliasAlphasWord & 0x7F0000;
	antiAliasGreenAlphaBits = antiAliasAlphasWord & 0x7F00;
	antiAliasBlueAlphaBits = antiAliasAlphasWord & 0x7F;
	antiAliasRedAlpha = antiAliasRedAlphaBits * (1.0 / (8.323072e6));
	antiAliasGreenAlpha = antiAliasGreenAlphaBits * (1.0 / (32512.0));
	antiAliasBlueAlpha = antiAliasBlueAlphaBits * (1.0 / 127.0);
	alphaR = antiAliasRedAlpha * strokeA;
	alphaG = antiAliasGreenAlpha * strokeA;
	alphaB = antiAliasBlueAlpha * strokeA;
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		morphIdWord = morphIds[pixelIndex];
		clippingAntiAliasBits = morphIdWord & 0x7F;
		
					antiAliasGreenAlphaBitsShifted = antiAliasGreenAlphaBits >> 8;
		if (antiAliasGreenAlphaBitsShifted > clippingAntiAliasBits) {
			clippingAntiAliasBits = antiAliasGreenAlphaBitsShifted;
		}
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;
			clippingAntiAlias = clippingAntiAliasBits * (1.0 / 127.0);
			alphaR = alphaR * clippingAntiAlias;
			alphaG = alphaG * clippingAntiAlias;
			alphaB = alphaB * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(((alphaR + alphaG) + alphaB) == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultAlphaBits = targetWord & 0xFF000000U;
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;

		/* These if are not really needed. just ignore them if we use simd instructions. */
		targetAlpha = resultAlphaBits * (1.0 / (4.27819008e9));
		if (!(alphaR == 0.0)) {
			unAlphaR = 1.0 - alphaR;
			resultAlphaR = alphaR + (unAlphaR * targetAlpha);
			
					resultR = (alphaR * strokeR) + ((unAlphaR * (resultRBits >> 16)) * targetAlpha);
					resultRBits = (uint32_t)(resultR / resultAlphaR + 0.5) << 16;
		}
		if (!(alphaG == 0.0)) {
			unAlphaG = 1.0 - alphaG;
			resultAlphaG = alphaG + (unAlphaG * targetAlpha);
			
					resultG = (alphaG * strokeG) + ((unAlphaG * (resultGBits >> 8)) * targetAlpha);
					resultGBits = (uint32_t)(resultG / resultAlphaG + 0.5) << 8;
					resultAlphaBits = (uint32_t)(resultAlphaG * 255.0 + 0.5) << 24;
		}
		if (!(alphaB == 0.0)) {
			unAlphaB = 1.0 - alphaB;
			resultAlphaB = alphaB + (unAlphaB * targetAlpha);
			
					resultB = (alphaB * strokeB) + ((unAlphaB * resultBBits) * targetAlpha);
					resultBBits = (uint32_t)(resultB / resultAlphaB + 0.5);
		}
		targetWord = ((resultAlphaBits | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Blends stroke color over background.
	WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeOnlyWPOTAt:antiAliasAlphaByte: */
static sqInt
blendStrokeOnlyWPOTAtantiAliasAlphaByte(sqInt pixelIndex, uint8_t antiAliasAlphaBits)
{
	float alpha;
	float antiAliasAlpha;
	float clippingAntiAlias;
	uint32_t clippingAntiAliasBits;
	uint32_t morphIdWord;
	float resultB;
	uint32_t resultBBits;
	float resultG;
	uint32_t resultGBits;
	float resultR;
	uint32_t resultRBits;
	uint32_t targetWord;
	float unAlpha;


	/* 1.0/127.0 */
	antiAliasAlpha = antiAliasAlphaBits * 0.007874;
	alpha = antiAliasAlpha * strokeA;
	if (currentClipsSubmorphs) {

		/* Don't clip us, but do clip submorphs */
		morphIdWord = morphIds[pixelIndex];
		clippingAntiAliasBits = morphIdWord & 0x7F;
		if (antiAliasAlphaBits > clippingAntiAliasBits) {
			clippingAntiAliasBits = antiAliasAlphaBits;
		}
	}
	else {
		if (clipCurrentMorph) {

			/* Clip ourselves to the border anti aliasing of the morph we are clipping at. Keep it for further use. */
			morphIdWord = morphIds[pixelIndex];
			clippingAntiAliasBits = morphIdWord & 0x7F;

			/* 1.0/127.0 */
			clippingAntiAlias = clippingAntiAliasBits * 0.007874;
			alpha = alpha * clippingAntiAlias;
		}
		else {

			/* Don't do any additional clipping or preparation for further clipping */
			clippingAntiAliasBits = 0;
		}
	}
	if (!(alpha == 0.0)) {
		targetWord = targetBits[pixelIndex];
		resultRBits = targetWord & 0xFF0000;
		resultGBits = targetWord & 0xFF00;
		resultBBits = targetWord & 0xFF;
		unAlpha = 1.0 - alpha;
		
				resultR = (alpha * strokeR) + (unAlpha * (resultRBits >> 16));
				resultRBits = (uint32_t)(resultR + 0.5) << 16;
				resultG = (alpha * strokeG) + (unAlpha * (resultGBits >> 8));
				resultGBits = (uint32_t)(resultG + 0.5) << 8;
				resultB = (alpha * strokeB) + (unAlpha * resultBBits);
				resultBBits = (uint32_t)(resultB + 0.5);
		targetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		targetBits[pixelIndex] = targetWord;
		morphIdWord = (((usqInt)(currentMorphId) << 8)) + clippingAntiAliasBits;
		morphIds[pixelIndex] = morphIdWord;
	}
	return 0;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* VectorEnginePlugin>>#initializeTrajectoryFragment */
static sqInt
initializeTrajectoryFragment(void)
{
	prevYTruncated = 0x7FFFFFFF;
	return 0;
}


/*	
	VectorEngineWithPlugin isPluginAvailable
	API version is a SmallInteger.
	Note: this is Api version, not package version. If no Api change, Api
	version doesn't change, regardless of changes in the Plugin or Smalltalk
	code. See senders and implementors.
	
 */

	/* VectorEnginePlugin>>#pluginApiVersion */
EXPORT(sqInt)
pluginApiVersion(void)
{
	methodReturnValue(integerObjectOf(6));
	return null;
}

	/* VectorEnginePlugin>>#antiAliasingWidth:subPixelDelta:hopLength: */
EXPORT(sqInt)
primAntiAliasingWidthsubPixelDeltaHopLength(void)
{
	double aFloat;
	double anotherFloat;
	double otherFloat;

	if (!((isFloatObject(stackValue(2)))
		 && ((isFloatObject(stackValue(1)))
		 && (isFloatObject(stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aFloat = stackFloatValue(2);
	otherFloat = stackFloatValue(1);
	anotherFloat = stackFloatValue(0);
	antiAliasingWidth = aFloat;
	auxAntiAliasingWidthScaledInverse = 127.0 / aFloat;
	subPixelDelta = otherFloat;
	hop = anotherFloat;
	if (!(failed())) {
		pop(3);
	}
	return null;
}

	/* VectorEnginePlugin>>#arcCenterX:centerY:radiusX:radiusY:start:sweep:rotationCos:rotationSin:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primArc(void)
{
	float *aFloat32Array;
	float angle;
	unsigned *anotherWordArray;
	double centerX;
	double centerY;
	float d;
	sqInt h;
	int hops;
	unsigned *otherWordArray;
	double radiusPointX;
	double radiusPointY;
	float scale;
	double startAngle;
	double sweepAngle;
	float tcx;
	float tcy;
	float trx;
	float try;
	double tthetaCos;
	double tthetaSin;
	float x;
	float xp;
	float y;
	float yp;

	if (!((isFloatObject(stackValue(10)))
		 && ((isFloatObject(stackValue(9)))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	centerX = stackFloatValue(10);
	centerY = stackFloatValue(9);
	radiusPointX = stackFloatValue(8);
	radiusPointY = stackFloatValue(7);
	startAngle = stackFloatValue(6);
	sweepAngle = stackFloatValue(5);
	tthetaCos = stackFloatValue(4);
	tthetaSin = stackFloatValue(3);
	otherWordArray = firstIndexableField(stackValue(2));
	anotherWordArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	tcx = ((centerX * txA11) + (centerY * txA12)) + txA13;
	tcy = ((centerX * txA21) + (centerY * txA22)) + txA23;
	scale = sqrt(txA11*txA11 + txA21*txA21);
	trx = radiusPointX * scale;
	try = radiusPointY * scale;
	hops = (((sqInt)(((((trx < try) ? try : trx)) * (fabs(sweepAngle))) / hop))) + 2;
	d = hops;
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	contour = aFloat32Array;
	for (h = 0; h <= hops; h += 1) {
		angle = ((float)h / d) * sweepAngle + startAngle;
		xp = (cos(angle)) * trx;
		yp = (sin(angle)) * try;
		x = ((tthetaCos * xp) - (tthetaSin * yp)) + tcx;
		y = ((tthetaSin * xp) + (tthetaCos * yp)) + tcy;
		spanLeft = ((spanLeft < x) ? spanLeft : x);
		spanTop = ((spanTop < y) ? spanTop : y);
		spanRight = ((spanRight < x) ? x : spanRight);
		spanBottom = ((spanBottom < y) ? y : spanBottom);
		updateAlphasForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountAtXy(x, y);
		}
		updateContourForXy(x, y);
	}
	if (!(failed())) {
		pop(11);
	}
	return null;
}

	/* VectorEnginePlugin>>#arcWPCenterX:centerY:radiusX:radiusY:start:sweep:rotationCos:rotationSin:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primArcWP(void)
{
	float *aFloat32Array;
	float angle;
	char *anotherByteArray;
	double centerX;
	double centerY;
	float d;
	sqInt h;
	int hops;
	char *otherByteArray;
	double radiusPointX;
	double radiusPointY;
	float scale;
	double startAngle;
	double sweepAngle;
	float tcx;
	float tcy;
	float trx;
	float try;
	double tthetaCos;
	double tthetaSin;
	float x;
	float xp;
	float y;
	float yp;

	if (!((isFloatObject(stackValue(10)))
		 && ((isFloatObject(stackValue(9)))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isBytes(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	centerX = stackFloatValue(10);
	centerY = stackFloatValue(9);
	radiusPointX = stackFloatValue(8);
	radiusPointY = stackFloatValue(7);
	startAngle = stackFloatValue(6);
	sweepAngle = stackFloatValue(5);
	tthetaCos = stackFloatValue(4);
	tthetaSin = stackFloatValue(3);
	otherByteArray = firstIndexableField(stackValue(2));
	anotherByteArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	tcx = ((centerX * txA11) + (centerY * txA12)) + txA13;
	tcy = ((centerX * txA21) + (centerY * txA22)) + txA23;
	scale = sqrt(txA11*txA11 + txA21*txA21);
	trx = radiusPointX * scale;
	try = radiusPointY * scale;
	hops = (((sqInt)(((((trx < try) ? try : trx)) * (fabs(sweepAngle))) / hop))) + 2;
	d = hops;
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	contour = aFloat32Array;
	for (h = 0; h <= hops; h += 1) {
		angle = ((float)h / d) * sweepAngle + startAngle;
		xp = (cos(angle)) * trx;
		yp = (sin(angle)) * try;
		x = ((tthetaCos * xp) - (tthetaSin * yp)) + tcx;
		y = ((tthetaSin * xp) + (tthetaCos * yp)) + tcy;
		spanLeft = ((spanLeft < x) ? spanLeft : x);
		spanTop = ((spanTop < y) ? spanTop : y);
		spanRight = ((spanRight < x) ? x : spanRight);
		spanBottom = ((spanBottom < y) ? y : spanBottom);
		updateAlphasWPForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountWPAtXy(x, y);
		}
		updateContourForXy(x, y);
	}
	if (!(failed())) {
		pop(11);
	}
	return null;
}


/*	Blends fill color over background. Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendFillOnlyLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: */
EXPORT(sqInt)
primBlendFillOnly(void)
{
	unsigned *aBitmap;
	unsigned *anotherWordArray;
	uint32_t antiAliasAlphasWord;
	unsigned *aWordArray;
	sqInt b;
	sqInt displayX;
	sqInt displayY;
	uint8_t edgesThisPixelB;
	uint8_t edgesThisPixelG;
	uint8_t edgesThisPixelR;
	uint32_t edgesThisPixelWord;
	uint8_t edgesUpToThisPixelB;
	uint8_t edgesUpToThisPixelG;
	uint8_t edgesUpToThisPixelR;
	int isBlueInside;
	int isGreenInside;
	int isRedInside;
	sqInt l;
	unsigned *otherWordArray;
	sqInt pixelIndex;
	sqInt r;
	sqInt t;

	if (!((isIntegerObject((l = stackValue(7))))
		 && ((isIntegerObject((t = stackValue(6))))
		 && ((isIntegerObject((r = stackValue(5))))
		 && ((isIntegerObject((b = stackValue(4))))
		 && ((isWords(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWords(stackValue(0))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	aBitmap = firstIndexableField(stackValue(3));
	aWordArray = firstIndexableField(stackValue(2));
	otherWordArray = firstIndexableField(stackValue(1));
	anotherWordArray = firstIndexableField(stackValue(0));
	targetBits = aBitmap;
	morphIds = aWordArray;
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	for (displayY = t; displayY <= b; displayY += 1) {
		edgesUpToThisPixelR = 0;
		edgesUpToThisPixelG = 0;
		edgesUpToThisPixelB = 0;
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			edgesThisPixelWord = edgeCounts[pixelIndex];
			if (!(edgesThisPixelWord == 0)) {
				edgeCounts[pixelIndex] = 0;
			}
			
					edgesThisPixelR = (uint32_t) (edgesThisPixelWord & 0xFF0000) >> 16;
					edgesThisPixelG = (uint32_t) (edgesThisPixelWord & 0xFF00) >> 8;
					edgesThisPixelB = (uint32_t) (edgesThisPixelWord & 0xFF);
			edgesUpToThisPixelR += edgesThisPixelR;
			edgesUpToThisPixelG += edgesThisPixelG;

			/* In C, integers already behave like booleans */
			edgesUpToThisPixelB += edgesThisPixelB;
			
					isRedInside = edgesUpToThisPixelR;
					isGreenInside = edgesUpToThisPixelG;
					isBlueInside = edgesUpToThisPixelB;
			antiAliasAlphasWord = alphaMask[pixelIndex];
			if (antiAliasAlphasWord != 0) {
				alphaMask[pixelIndex] = 0;
			}
			if ((antiAliasAlphasWord != 0)
			 || (isRedInside
			 || (isGreenInside
			 || (isBlueInside)))) {
				blendFillOnlyAtredIsInsidegreenIsInsideblueIsInsideantiAliasAlphasWord(pixelIndex, isRedInside, isGreenInside, isBlueInside, antiAliasAlphasWord);
			}
		}
	}
	if (!(failed())) {
		pop(8);
	}
	return null;
}


/*	Blends fill color over background.
	WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendFillOnlyWPOTLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: */
EXPORT(sqInt)
primBlendFillOnlyWPOT(void)
{
	unsigned *aBitmap;
	char *anotherByteArray;
	uint8_t antiAliasAlphaBits;
	unsigned *aWordArray;
	sqInt b;
	sqInt displayX;
	sqInt displayY;
	uint8_t edgesThisPixel;
	uint8_t edgesUpToThisPixel;
	sqInt l;
	uint32_t optimizedOpaqueMorphIdWord;
	uint32_t optimizedOpaqueTargetWord;
	char *otherByteArray;
	sqInt pixelIndex;
	sqInt r;
	uint32_t resultBBits;
	uint32_t resultGBits;
	uint32_t resultRBits;
	sqInt t;

	optimizedOpaqueMorphIdWord = 0;
	if (!((isIntegerObject((l = stackValue(7))))
		 && ((isIntegerObject((t = stackValue(6))))
		 && ((isIntegerObject((r = stackValue(5))))
		 && ((isIntegerObject((b = stackValue(4))))
		 && ((isWords(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isBytes(stackValue(0))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	aBitmap = firstIndexableField(stackValue(3));
	aWordArray = firstIndexableField(stackValue(2));
	otherByteArray = firstIndexableField(stackValue(1));
	anotherByteArray = firstIndexableField(stackValue(0));
	targetBits = aBitmap;
	morphIds = aWordArray;
	edgeCountsWP = otherByteArray;

	/* Optimize most common case: Fully opaque fill color, inside fill, away from stroke (no anti aliasing), no clipping at this point. */
	alphaMaskWP = anotherByteArray;
	optimizedOpaqueTargetWord = 0;
	if (fillA == 1.0) {
		
			resultRBits = (uint32_t)(fillR + 0.5) << 16;
			resultGBits = (uint32_t)(fillG + 0.5) << 8;
			resultBBits = (uint32_t)(fillB + 0.5);
		optimizedOpaqueTargetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		if (clipCurrentMorph
		 || (currentClipsSubmorphs)) {
			optimizedOpaqueMorphIdWord = (((usqInt)(currentMorphId) << 8)) + 0x7F;
		}
		else {
			optimizedOpaqueMorphIdWord = ((usqInt)(currentMorphId) << 8);
		}
	}
	for (displayY = t; displayY <= b; displayY += 1) {
		edgesUpToThisPixel = 0;
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			edgesThisPixel = edgeCountsWP[pixelIndex];
			if (!(edgesThisPixel == 0)) {
				edgeCountsWP[pixelIndex] = 0;
				edgesUpToThisPixel += edgesThisPixel;
			}
			antiAliasAlphaBits = alphaMaskWP[pixelIndex];
			if (edgesUpToThisPixel == 0) {

				/* Still in the anti aliasing area, but outside the shape, strictly speaking. */
				if (!(antiAliasAlphaBits == 0)) {
					alphaMaskWP[pixelIndex] = 0;
					blendFillOnlyWPOTAtantiAliasAlphaByte(pixelIndex, antiAliasAlphaBits);
				}
			}
			else {

				/* Inside the shape */
				if ((optimizedOpaqueTargetWord != 0)
				 && ((antiAliasAlphaBits == 0)
				 && ((!clipCurrentMorph)
				 || (((morphIds[pixelIndex]) & 0x7F) == 0x7F)))) {

					/* Optimize most common case: Fully opaque fill color, inside fill, away from stroke (no anti aliasing), no clipping at this point. */
					targetBits[pixelIndex] = optimizedOpaqueTargetWord;
					morphIds[pixelIndex] = optimizedOpaqueMorphIdWord;
				}
				else {
					if (!(antiAliasAlphaBits == 0)) {
						alphaMaskWP[pixelIndex] = 0;
					}
					antiAliasAlphaBits = 0x7F - antiAliasAlphaBits;
					blendFillOnlyWPOTAtantiAliasAlphaByte(pixelIndex, antiAliasAlphaBits);
				}
			}
		}
	}
	if (!(failed())) {
		pop(8);
	}
	return null;
}


/*	Blends stroke color and fill color over background.
	Do an appropriate (anti aliased) gradient between stoke color and fill
	color (or pick just stroke or just fill). Blend this over background.
	Target translucency computed correctly.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeAndFillLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: */
EXPORT(sqInt)
primBlendStrokeAndFill(void)
{
	unsigned *aBitmap;
	unsigned *anotherWordArray;
	uint32_t antiAliasAlphasWord;
	unsigned *aWordArray;
	sqInt b;
	sqInt displayX;
	sqInt displayY;
	uint8_t edgesThisPixelB;
	uint8_t edgesThisPixelG;
	uint8_t edgesThisPixelR;
	uint32_t edgesThisPixelWord;
	uint8_t edgesUpToThisPixelB;
	uint8_t edgesUpToThisPixelG;
	uint8_t edgesUpToThisPixelR;
	int isBlueInside;
	int isGreenInside;
	int isRedInside;
	sqInt l;
	unsigned *otherWordArray;
	sqInt pixelIndex;
	sqInt r;
	sqInt t;

	if (!((isIntegerObject((l = stackValue(7))))
		 && ((isIntegerObject((t = stackValue(6))))
		 && ((isIntegerObject((r = stackValue(5))))
		 && ((isIntegerObject((b = stackValue(4))))
		 && ((isWords(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWords(stackValue(0))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	aBitmap = firstIndexableField(stackValue(3));
	aWordArray = firstIndexableField(stackValue(2));
	otherWordArray = firstIndexableField(stackValue(1));
	anotherWordArray = firstIndexableField(stackValue(0));
	targetBits = aBitmap;
	morphIds = aWordArray;
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	for (displayY = t; displayY <= b; displayY += 1) {
		edgesUpToThisPixelR = 0;
		edgesUpToThisPixelG = 0;
		edgesUpToThisPixelB = 0;
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			edgesThisPixelWord = edgeCounts[pixelIndex];
			if (!(edgesThisPixelWord == 0)) {
				edgeCounts[pixelIndex] = 0;
			}
			
					edgesThisPixelR = (uint32_t) (edgesThisPixelWord & 0xFF0000) >> 16;
					edgesThisPixelG = (uint32_t) (edgesThisPixelWord & 0xFF00) >> 8;
					edgesThisPixelB = (uint32_t) (edgesThisPixelWord & 0xFF);
			edgesUpToThisPixelR += edgesThisPixelR;
			edgesUpToThisPixelG += edgesThisPixelG;

			/* In C, integers already behave like booleans */
			edgesUpToThisPixelB += edgesThisPixelB;
			
					isRedInside = edgesUpToThisPixelR;
					isGreenInside = edgesUpToThisPixelG;
					isBlueInside = edgesUpToThisPixelB;
			antiAliasAlphasWord = alphaMask[pixelIndex];
			if (antiAliasAlphasWord != 0) {
				alphaMask[pixelIndex] = 0;
			}
			if ((antiAliasAlphasWord != 0)
			 || (isRedInside
			 || (isGreenInside
			 || (isBlueInside)))) {
				blendStrokeAndFillAtredIsInsidegreenIsInsideblueIsInsideantiAliasAlphasWord(pixelIndex, isRedInside, isGreenInside, isBlueInside, antiAliasAlphasWord);
			}
		}
	}
	if (!(failed())) {
		pop(8);
	}
	return null;
}


/*	Blends stroke color and fill color over background.
	Do an appropriate (anti aliased) gradient between stoke color and fill
	color (or pick just stroke or just fill). Blend this over background.
	WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeAndFillWPOTLeft:top:right:bottom:targetBits:morphIds:edgeCounts:alphaMask: */
EXPORT(sqInt)
primBlendStrokeAndFillWPOT(void)
{
	unsigned *aBitmap;
	char *anotherByteArray;
	uint8_t antiAliasAlphaBits;
	unsigned *aWordArray;
	sqInt b;
	sqInt displayX;
	sqInt displayY;
	uint8_t edgesThisPixel;
	uint8_t edgesUpToThisPixel;
	sqInt l;
	uint32_t optimizedOpaqueMorphIdWord;
	uint32_t optimizedOpaqueTargetWord;
	char *otherByteArray;
	sqInt pixelIndex;
	sqInt r;
	uint32_t resultBBits;
	uint32_t resultGBits;
	uint32_t resultRBits;
	sqInt t;

	optimizedOpaqueMorphIdWord = 0;
	if (!((isIntegerObject((l = stackValue(7))))
		 && ((isIntegerObject((t = stackValue(6))))
		 && ((isIntegerObject((r = stackValue(5))))
		 && ((isIntegerObject((b = stackValue(4))))
		 && ((isWords(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isBytes(stackValue(0))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	aBitmap = firstIndexableField(stackValue(3));
	aWordArray = firstIndexableField(stackValue(2));
	otherByteArray = firstIndexableField(stackValue(1));
	anotherByteArray = firstIndexableField(stackValue(0));
	targetBits = aBitmap;
	morphIds = aWordArray;
	edgeCountsWP = otherByteArray;

	/* Optimize most common case: Fully opaque fill color, inside fill, away from stroke (no anti aliasing), no clipping at this point. */
	alphaMaskWP = anotherByteArray;
	optimizedOpaqueTargetWord = 0;
	if (fillA == 1.0) {
		
			resultRBits = (uint32_t)(fillR + 0.5) << 16;
			resultGBits = (uint32_t)(fillG + 0.5) << 8;
			resultBBits = (uint32_t)(fillB + 0.5);
		optimizedOpaqueTargetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		if (clipCurrentMorph
		 || (currentClipsSubmorphs)) {
			optimizedOpaqueMorphIdWord = (((usqInt)(currentMorphId) << 8)) + 0x7F;
		}
		else {
			optimizedOpaqueMorphIdWord = ((usqInt)(currentMorphId) << 8);
		}
	}
	for (displayY = t; displayY <= b; displayY += 1) {
		edgesUpToThisPixel = 0;
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			edgesThisPixel = edgeCountsWP[pixelIndex];
			if (!(edgesThisPixel == 0)) {
				edgeCountsWP[pixelIndex] = 0;
				edgesUpToThisPixel += edgesThisPixel;
			}
			antiAliasAlphaBits = alphaMaskWP[pixelIndex];
			if (edgesUpToThisPixel == 0) {

				/* Still in the stroke, but outside the shape, strictly speaking. */
				if (!(antiAliasAlphaBits == 0)) {
					alphaMaskWP[pixelIndex] = 0;
					if (!(antiAliasAlphaBits == 0)) {
						blendStrokeAndFillOutsideWPOTAtantiAliasAlphaByte(pixelIndex, antiAliasAlphaBits);
					}
				}
			}
			else {

				/* Inside the shape */
				if ((optimizedOpaqueTargetWord != 0)
				 && ((antiAliasAlphaBits == 0)
				 && ((!clipCurrentMorph)
				 || (((morphIds[pixelIndex]) & 0x7F) == 0x7F)))) {

					/* Optimize most common case: Fully opaque fill color, inside fill, away from stroke (no anti aliasing), no clipping at this point. */
					targetBits[pixelIndex] = optimizedOpaqueTargetWord;
					morphIds[pixelIndex] = optimizedOpaqueMorphIdWord;
				}
				else {
					if (!(antiAliasAlphaBits == 0)) {
						alphaMaskWP[pixelIndex] = 0;
					}
					blendStrokeAndFillInsideWPOTAtantiAliasAlphaByte(pixelIndex, antiAliasAlphaBits);
				}
			}
		}
	}
	if (!(failed())) {
		pop(8);
	}
	return null;
}


/*	Blends stroke color over background. Target translucency computed
	correctly. For blending, alphas are in [0 .. 1.0] and R, G, B color
	components are in [0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeOnlyLeft:top:right:bottom:targetBits:morphIds:alphaMask: */
EXPORT(sqInt)
primBlendStrokeOnly(void)
{
	unsigned *aBitmap;
	unsigned *anotherWordArray;
	uint32_t antiAliasAlphasWord;
	unsigned *aWordArray;
	sqInt b;
	sqInt displayX;
	sqInt displayY;
	sqInt l;
	sqInt pixelIndex;
	sqInt r;
	sqInt t;

	if (!((isIntegerObject((l = stackValue(6))))
		 && ((isIntegerObject((t = stackValue(5))))
		 && ((isIntegerObject((r = stackValue(4))))
		 && ((isIntegerObject((b = stackValue(3))))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWords(stackValue(0)))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	aBitmap = firstIndexableField(stackValue(2));
	aWordArray = firstIndexableField(stackValue(1));
	anotherWordArray = firstIndexableField(stackValue(0));
	targetBits = aBitmap;
	morphIds = aWordArray;
	alphaMask = anotherWordArray;
	for (displayY = t; displayY <= b; displayY += 1) {
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			antiAliasAlphasWord = alphaMask[pixelIndex];
			if (!(antiAliasAlphasWord == 0)) {
				alphaMask[pixelIndex] = 0;
				blendStrokeOnlyAtantiAliasAlphasWord(pixelIndex, antiAliasAlphasWord);
			}
		}
	}
	if (!(failed())) {
		pop(7);
	}
	return null;
}


/*	Blends stroke color over background.
	WP: Whole pixel anti aliasing.
	OT: Target ignored on input and set to opaque on output.
	For blending, alphas are in [0 .. 1.0] and R, G, B color components are in
	[0 .. 255]
 */

	/* VectorEnginePlugin>>#blendStrokeOnlyWPOTLeft:top:right:bottom:targetBits:morphIds:alphaMask: */
EXPORT(sqInt)
primBlendStrokeOnlyWPOT(void)
{
	unsigned *aBitmap;
	char *anotherByteArray;
	uint8_t antiAliasAlphaBits;
	unsigned *aWordArray;
	sqInt b;
	sqInt displayX;
	sqInt displayY;
	sqInt l;
	uint32_t optimizedOpaqueMorphIdWord;
	uint32_t optimizedOpaqueTargetWord;
	sqInt pixelIndex;
	sqInt r;
	uint32_t resultBBits;
	uint32_t resultGBits;
	uint32_t resultRBits;
	sqInt t;

	optimizedOpaqueMorphIdWord = 0;
	if (!((isIntegerObject((l = stackValue(6))))
		 && ((isIntegerObject((t = stackValue(5))))
		 && ((isIntegerObject((r = stackValue(4))))
		 && ((isIntegerObject((b = stackValue(3))))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isBytes(stackValue(0)))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	aBitmap = firstIndexableField(stackValue(2));
	aWordArray = firstIndexableField(stackValue(1));
	anotherByteArray = firstIndexableField(stackValue(0));
	targetBits = aBitmap;
	morphIds = aWordArray;

	/* Optimize inner part of a wide stroke: Fully opaque stroke color, inside stroke, away from stroke border (no anti aliasing), no clipping at this point. */
	alphaMaskWP = anotherByteArray;
	optimizedOpaqueTargetWord = 0;
	if (fillA == 1.0) {
		
			resultRBits = (uint32_t)(fillR + 0.5) << 16;
			resultGBits = (uint32_t)(fillG + 0.5) << 8;
			resultBBits = (uint32_t)(fillB + 0.5);
		optimizedOpaqueTargetWord = ((0xFF000000U | resultRBits) | resultGBits) | resultBBits;
		if (clipCurrentMorph
		 || (currentClipsSubmorphs)) {
			optimizedOpaqueMorphIdWord = (((usqInt)(currentMorphId) << 8)) + 0x7F;
		}
		else {
			optimizedOpaqueMorphIdWord = ((usqInt)(currentMorphId) << 8);
		}
	}
	for (displayY = t; displayY <= b; displayY += 1) {
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			antiAliasAlphaBits = alphaMaskWP[pixelIndex];
			if ((optimizedOpaqueTargetWord != 0)
			 && ((antiAliasAlphaBits == 0x7F)
			 && ((!clipCurrentMorph)
			 || (((morphIds[pixelIndex]) & 0x7F) == 0x7F)))) {

				/* Optimize inner part of a wide stroke: Fully opaque stroke color, inside stroke, away from stroke border (no anti aliasing), no clipping at this point. */
				targetBits[pixelIndex] = optimizedOpaqueTargetWord;
				morphIds[pixelIndex] = optimizedOpaqueMorphIdWord;
			}
			else {
				if (!(antiAliasAlphaBits == 0)) {

					/* In the stroke */
					alphaMaskWP[pixelIndex] = 0;
					blendStrokeOnlyWPOTAtantiAliasAlphaByte(pixelIndex, antiAliasAlphaBits);
				}
			}
		}
	}
	if (!(failed())) {
		pop(7);
	}
	return null;
}

	/* VectorEnginePlugin>>#clipCurrentMorph:morphIds: */
EXPORT(sqInt)
primClipCurrentMorph(void)
{
	sqInt aBoolean;
	unsigned *aWordArray;
	sqInt displayX;
	sqInt displayY;
	sqInt pixelIndex;

	if (!((isBooleanObject(stackValue(1)))
		 && (isWords(stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aBoolean = booleanValueOf(stackValue(1));
	aWordArray = firstIndexableField(stackValue(0));
	morphIds = aWordArray;
	if (clipCurrentMorph
	 && (!aBoolean)) {
		for (displayY = clipTop; displayY <= clipBottom; displayY += 1) {
			pixelIndex = (displayY * targetWidth) + clipLeft;
			for (displayX = clipLeft; displayX <= clipRight; displayX += 1) {
				morphIds[pixelIndex] = ((morphIds[pixelIndex]) & 0xFFFFFF00U);
				pixelIndex += 1;
			}
		}
	}
	clipCurrentMorph = aBoolean;
	if (!(failed())) {
		pop(2);
	}
	return null;
}

	/* VectorEnginePlugin>>#clipLeft:clipTop:clipRight:clipBottom: */
EXPORT(sqInt)
primClipLeftclipTopclipRightclipBottom(void)
{
	sqInt b;
	sqInt l;
	sqInt r;
	sqInt t;

	if (!((isIntegerObject((l = stackValue(3))))
		 && ((isIntegerObject((t = stackValue(2))))
		 && ((isIntegerObject((r = stackValue(1))))
		 && (isIntegerObject((b = stackValue(0)))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	l = integerValueOf(l);
	t = integerValueOf(t);
	r = integerValueOf(r);
	b = integerValueOf(b);
	clipLeft = l;
	clipTop = t;
	clipRight = r;
	clipBottom = b;
	if (!(failed())) {
		pop(4);
	}
	return null;
}

	/* VectorEnginePlugin>>#cubicBezierFromX:y:toX:y:control1X:y:control2X:y:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primCubicBezier(void)
{
	float *aFloat32Array;
	unsigned *anotherWordArray;
	unsigned *otherWordArray;
	double xControl1;
	double xControl2;
	double xFrom;
	double xTo;
	double yControl1;
	double yControl2;
	double yFrom;
	double yTo;

	if (!((isFloatObject(stackValue(10)))
		 && ((isFloatObject(stackValue(9)))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	xFrom = stackFloatValue(10);
	yFrom = stackFloatValue(9);
	xTo = stackFloatValue(8);
	yTo = stackFloatValue(7);
	xControl1 = stackFloatValue(6);
	yControl1 = stackFloatValue(5);
	xControl2 = stackFloatValue(4);
	yControl2 = stackFloatValue(3);
	otherWordArray = firstIndexableField(stackValue(2));
	anotherWordArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	contour = aFloat32Array;
	pvt_cubicBezierFromXytoXycontrol1Xycontrol2Xy(xFrom, yFrom, xTo, yTo, xControl1, yControl1, xControl2, yControl2);
	if (!(failed())) {
		pop(11);
	}
	return null;
}

	/* VectorEnginePlugin>>#cubicBezierWPFromX:y:toX:y:control1X:y:control2X:y:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primCubicBezierWP(void)
{
	float *aFloat32Array;
	char *anotherByteArray;
	char *otherByteArray;
	double xControl1;
	double xControl2;
	double xFrom;
	double xTo;
	double yControl1;
	double yControl2;
	double yFrom;
	double yTo;

	if (!((isFloatObject(stackValue(10)))
		 && ((isFloatObject(stackValue(9)))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isBytes(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	xFrom = stackFloatValue(10);
	yFrom = stackFloatValue(9);
	xTo = stackFloatValue(8);
	yTo = stackFloatValue(7);
	xControl1 = stackFloatValue(6);
	yControl1 = stackFloatValue(5);
	xControl2 = stackFloatValue(4);
	yControl2 = stackFloatValue(3);
	otherByteArray = firstIndexableField(stackValue(2));
	anotherByteArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	contour = aFloat32Array;
	pvt_cubicBezierWPFromXytoXycontrol1Xycontrol2Xy(xFrom, yFrom, xTo, yTo, xControl1, yControl1, xControl2, yControl2);
	if (!(failed())) {
		pop(11);
	}
	return null;
}


/*	Bound it someway to 31 or 32 bits (SmallInteger in 32 bits, or uint in 32
	bits, etc...)
 */

	/* VectorEnginePlugin>>#currentMorphId:currentClipsSubmorphs: */
EXPORT(sqInt)
primCurrentMorphIdcurrentClipsSubmorphs(void)
{
	sqInt aBoolean;
	sqInt aNumber;

	if (!((isIntegerObject((aNumber = stackValue(1))))
		 && (isBooleanObject(stackValue(0))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aNumber = integerValueOf(aNumber);
	aBoolean = booleanValueOf(stackValue(0));
	currentMorphId = aNumber;
	if (currentMorphId == 0) {
		clipCurrentMorph = 0;
	}
	currentClipsSubmorphs = aBoolean;
	if (!(failed())) {
		pop(2);
	}
	return null;
}

	/* VectorEnginePlugin>>#displayString:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: */
EXPORT(sqInt)
primDisplayString(void)
{
	sqInt aBoolean;
	float advanceWidth;
	unsigned *anotherWordArray;
	double answer;
	char *aString;
	sqInt charIndex;
	float *contourData;
	int *contourDataIndexes;
	float contourStartX;
	float contourStartY;
	float controlX;
	float controlY;
	float correction;
	double destX;
	double destY;
	float dx;
	float dy;
	float endX;
	float endY;
	float f1;
	float f2;
	float f3;
	int i;
	sqInt idx;
	sqInt idx2;
	float increment;
	uint8_t iso8859s15;
	float length;
	float nextGlyphX;
	float nextGlyphY;
	sqInt numBeziers;
	sqInt numContours;
	float oneLessT;
	unsigned *otherWordArray;
	sqInt startIndex;
	float startX;
	float startY;
	sqInt stopIndex;
	double sx;
	double sy;
	float t;
	float t0;
	float ttControlX;
	float ttControlY;
	float ttEndX;
	float ttEndY;
	float ttMoveToX;
	float ttMoveToY;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;
	sqInt _return_value;

	if (!((isBytes(stackValue(11)))
		 && ((isIntegerObject((startIndex = stackValue(10))))
		 && ((isIntegerObject((stopIndex = stackValue(9))))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isWordsOrBytes(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isBooleanObject(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWords(stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aString = firstIndexableField(stackValue(11));
	startIndex = integerValueOf(startIndex);
	stopIndex = integerValueOf(stopIndex);
	destX = stackFloatValue(8);
	destY = stackFloatValue(7);
	sx = stackFloatValue(6);
	sy = stackFloatValue(5);
	contourData = firstIndexableField(stackValue(4));
	contourDataIndexes = firstIndexableField(stackValue(3));
	aBoolean = booleanValueOf(stackValue(2));
	otherWordArray = firstIndexableField(stackValue(1));
	anotherWordArray = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	txA11 = txA11 * sx;
	txA12 = txA12 * sy;
	txA21 = txA21 * sx;
	txA22 = txA22 * sy;
	nextGlyphX = destX / sx;
	nextGlyphY = destY / sy;
	for (charIndex = (startIndex - 1); charIndex < stopIndex; charIndex += 1) {
		iso8859s15 = aString[charIndex];
		if (aBoolean) {
			if (iso8859s15 == 95) {
				iso8859s15 = 28;
			}
			if (iso8859s15 == 94) {
				iso8859s15 = 30;
			}
		}
		i = contourDataIndexes[iso8859s15];
		i -= 1;
		advanceWidth = contourData[i];
		i += 5;
		numContours = ((sqInt)(contourData[i]));
		i += 1;
		for (idx = 1; idx <= numContours; idx += 1) {
			numBeziers = ((sqInt)(contourData[i]));
			i += 1;
			ttMoveToX = (contourData[i]) + nextGlyphX;
			i += 1;
			ttMoveToY = (contourData[i]) + nextGlyphY;
			i += 1;
			startX = ((ttMoveToX * txA11) + (ttMoveToY * txA12)) + txA13;
			startY = ((ttMoveToX * txA21) + (ttMoveToY * txA22)) + txA23;
			contourStartX = startX;
			contourStartY = startY;
			/* begin initializeTrajectoryFragment */
			prevYTruncated = 0x7FFFFFFF;
			for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
				ttEndX = contourData[i];
				i += 1;
				ttEndY = contourData[i];
				i += 1;
				ttControlX = contourData[i];
				i += 1;
				ttControlY = contourData[i];
				i += 1;
				endX = ((ttEndX * txA11) + (ttEndY * txA12)) + startX;
				endY = ((ttEndX * txA21) + (ttEndY * txA22)) + startY;
				controlX = ((ttControlX * txA11) + (ttControlY * txA12)) + startX;

				/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
				controlY = ((ttControlX * txA21) + (ttControlY * txA22)) + startY;
				xMinEnd = ((startX < endX) ? startX : endX);
				xMaxEnd = ((startX < endX) ? endX : startX);
				yMinEnd = ((startY < endY) ? startY : endY);
				yMaxEnd = ((startY < endY) ? endY : startY);
				spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
				spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
				spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));

				/* Compute Quadratic Bezier Curve, */
				/* Case t = 0.0 */
				spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
				x = startX;
				y = startY;
				updateAlphasForXy(x, y);
				updateEdgeCountAtXy(x, y);
				dx = fabs(endX-startX); dy = fabs(endY-startY);
				increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
				t = 0.0;
				while (1) {
					t0 = t;
					x0 = x;

					/* Compute next point */
					y0 = y;
					t = t0 + increment;
					oneLessT = 1.0 - t;
					f1 = oneLessT * oneLessT;
					f2 = (2.0 * oneLessT) * t;
					f3 = t * t;
					x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);

					/* Now adjust the increment to aim at the required hop length, and recompute next point. */
					y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
					dx = x - x0;
					dy = y - y0;
					
						length = sqrt(dx*dx + dy*dy);
					correction = hop / length;
					do {
						increment = (increment / length) * hop;
						t = t0 + increment;
						oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT;
						f2 = (2.0 * oneLessT) * t;
						f3 = t * t;
						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
						dx = x - x0;
						dy = y - y0;
						
							length = sqrt(dx*dx + dy*dy);
						correction = hop / length;
					} while(correction < 1.0);
					if (!(t < 1.0)) break;
					updateAlphasForXy(x, y);
					updateEdgeCountAtXy(x, y);
				}
				startX = endX;
				startY = endY;
			}
			updateAlphasForXy(endX, endY);
			updateEdgeCountAtXy(endX, endY);
			updateEdgeCountAtXy(contourStartX, contourStartY);
		}
		nextGlyphX += advanceWidth;
	}
	txA11 = txA11 / sx;
	txA12 = txA12 / sy;
	txA21 = txA21 / sx;
	txA22 = txA22 / sy;
	answer = nextGlyphX * sx;
	if (!(failed())) {
		_return_value = floatObjectOf(answer);
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}

	/* VectorEnginePlugin>>#displayStringWP:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: */
EXPORT(sqInt)
primDisplayStringWP(void)
{
	sqInt aBoolean;
	float advanceWidth;
	char *anotherByteArray;
	double answer;
	char *aString;
	sqInt charIndex;
	float *contourData;
	int *contourDataIndexes;
	float contourStartX;
	float contourStartY;
	float controlX;
	float controlY;
	float correction;
	double destX;
	double destY;
	float dx;
	float dy;
	float endX;
	float endY;
	float f1;
	float f2;
	float f3;
	int i;
	sqInt idx;
	sqInt idx2;
	float increment;
	uint8_t iso8859s15;
	float length;
	float nextGlyphX;
	float nextGlyphY;
	sqInt numBeziers;
	sqInt numContours;
	float oneLessT;
	char *otherByteArray;
	sqInt startIndex;
	float startX;
	float startY;
	sqInt stopIndex;
	double sx;
	double sy;
	float t;
	float t0;
	float ttControlX;
	float ttControlY;
	float ttEndX;
	float ttEndY;
	float ttMoveToX;
	float ttMoveToY;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;
	sqInt _return_value;

	if (!((isBytes(stackValue(11)))
		 && ((isIntegerObject((startIndex = stackValue(10))))
		 && ((isIntegerObject((stopIndex = stackValue(9))))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isWordsOrBytes(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isBooleanObject(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isBytes(stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aString = firstIndexableField(stackValue(11));
	startIndex = integerValueOf(startIndex);
	stopIndex = integerValueOf(stopIndex);
	destX = stackFloatValue(8);
	destY = stackFloatValue(7);
	sx = stackFloatValue(6);
	sy = stackFloatValue(5);
	contourData = firstIndexableField(stackValue(4));
	contourDataIndexes = firstIndexableField(stackValue(3));
	aBoolean = booleanValueOf(stackValue(2));
	otherByteArray = firstIndexableField(stackValue(1));
	anotherByteArray = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	txA11 = txA11 * sx;
	txA12 = txA12 * sy;
	txA21 = txA21 * sx;
	txA22 = txA22 * sy;
	nextGlyphX = destX / sx;
	nextGlyphY = destY / sy;
	for (charIndex = (startIndex - 1); charIndex < stopIndex; charIndex += 1) {
		iso8859s15 = aString[charIndex];
		if (aBoolean) {
			if (iso8859s15 == 95) {
				iso8859s15 = 28;
			}
			if (iso8859s15 == 94) {
				iso8859s15 = 30;
			}
		}
		i = contourDataIndexes[iso8859s15];
		i -= 1;
		advanceWidth = contourData[i];
		i += 5;
		numContours = ((sqInt)(contourData[i]));
		i += 1;
		for (idx = 1; idx <= numContours; idx += 1) {
			numBeziers = ((sqInt)(contourData[i]));
			i += 1;
			ttMoveToX = (contourData[i]) + nextGlyphX;
			i += 1;
			ttMoveToY = (contourData[i]) + nextGlyphY;
			i += 1;
			startX = ((ttMoveToX * txA11) + (ttMoveToY * txA12)) + txA13;
			startY = ((ttMoveToX * txA21) + (ttMoveToY * txA22)) + txA23;
			contourStartX = startX;
			contourStartY = startY;
			/* begin initializeTrajectoryFragment */
			prevYTruncated = 0x7FFFFFFF;
			for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
				ttEndX = contourData[i];
				i += 1;
				ttEndY = contourData[i];
				i += 1;
				ttControlX = contourData[i];
				i += 1;
				ttControlY = contourData[i];
				i += 1;
				endX = ((ttEndX * txA11) + (ttEndY * txA12)) + startX;
				endY = ((ttEndX * txA21) + (ttEndY * txA22)) + startY;
				controlX = ((ttControlX * txA11) + (ttControlY * txA12)) + startX;

				/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
				controlY = ((ttControlX * txA21) + (ttControlY * txA22)) + startY;
				xMinEnd = ((startX < endX) ? startX : endX);
				xMaxEnd = ((startX < endX) ? endX : startX);
				yMinEnd = ((startY < endY) ? startY : endY);
				yMaxEnd = ((startY < endY) ? endY : startY);
				spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
				spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
				spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));

				/* Compute Quadratic Bezier Curve, */
				/* Case t = 0.0 */
				spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
				x = startX;
				y = startY;
				updateAlphasWPZeroStrokeForXy(x, y);
				updateEdgeCountWPAtXy(x, y);
				dx = fabs(endX-startX); dy = fabs(endY-startY);
				increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
				t = 0.0;
				while (1) {
					t0 = t;
					x0 = x;

					/* Compute next point */
					y0 = y;
					t = t0 + increment;
					oneLessT = 1.0 - t;
					f1 = oneLessT * oneLessT;
					f2 = (2.0 * oneLessT) * t;
					f3 = t * t;
					x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);

					/* Now adjust the increment to aim at the required hop length, and recompute next point. */
					y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
					dx = x - x0;
					dy = y - y0;
					
						length = sqrt(dx*dx + dy*dy);
					correction = hop / length;
					do {
						increment = (increment / length) * hop;
						t = t0 + increment;
						oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT;
						f2 = (2.0 * oneLessT) * t;
						f3 = t * t;
						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
						dx = x - x0;
						dy = y - y0;
						
							length = sqrt(dx*dx + dy*dy);
						correction = hop / length;
					} while(correction < 1.0);
					if (!(t < 1.0)) break;
					updateAlphasWPZeroStrokeForXy(x, y);
					updateEdgeCountWPAtXy(x, y);
				}
				startX = endX;
				startY = endY;
			}
			updateAlphasWPZeroStrokeForXy(endX, endY);
			updateEdgeCountWPAtXy(endX, endY);
			updateEdgeCountWPAtXy(contourStartX, contourStartY);
		}
		nextGlyphX += advanceWidth;
	}
	txA11 = txA11 / sx;
	txA12 = txA12 / sy;
	txA21 = txA21 / sx;
	txA22 = txA22 / sy;
	answer = nextGlyphX * sx;
	if (!(failed())) {
		_return_value = floatObjectOf(answer);
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}

	/* VectorEnginePlugin>>#displayUtf32:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: */
EXPORT(sqInt)
primDisplayUtf32(void)
{
	sqInt aBoolean;
	float advanceWidth;
	unsigned *anotherWordArray;
	double answer;
	unsigned *aWordArray;
	float *contourData;
	int *contourDataIndexes;
	float contourStartX;
	float contourStartY;
	float controlX;
	float controlY;
	float correction;
	double destX;
	double destY;
	float dx;
	float dy;
	float endX;
	float endY;
	float f1;
	float f2;
	float f3;
	int i;
	sqInt idx;
	sqInt idx2;
	float increment;
	float length;
	float nextGlyphX;
	float nextGlyphY;
	sqInt numBeziers;
	sqInt numContours;
	float oneLessT;
	unsigned *otherWordArray;
	sqInt startIndex;
	float startX;
	float startY;
	sqInt stopIndex;
	double sx;
	double sy;
	float t;
	float t0;
	float ttControlX;
	float ttControlY;
	float ttEndX;
	float ttEndY;
	float ttMoveToX;
	float ttMoveToY;
	unsigned utf32;
	sqInt utf32Index;
	unsigned utf8Byte;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;
	sqInt _return_value;

	if (!((isWords(stackValue(11)))
		 && ((isIntegerObject((startIndex = stackValue(10))))
		 && ((isIntegerObject((stopIndex = stackValue(9))))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isWordsOrBytes(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isBooleanObject(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWords(stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aWordArray = firstIndexableField(stackValue(11));
	startIndex = integerValueOf(startIndex);
	stopIndex = integerValueOf(stopIndex);
	destX = stackFloatValue(8);
	destY = stackFloatValue(7);
	sx = stackFloatValue(6);
	sy = stackFloatValue(5);
	contourData = firstIndexableField(stackValue(4));
	contourDataIndexes = firstIndexableField(stackValue(3));
	aBoolean = booleanValueOf(stackValue(2));
	otherWordArray = firstIndexableField(stackValue(1));
	anotherWordArray = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	txA11 = txA11 * sx;
	txA12 = txA12 * sy;
	txA21 = txA21 * sx;
	txA22 = txA22 * sy;
	nextGlyphX = destX / sx;
	nextGlyphY = destY / sy;
	for (utf32Index = (startIndex - 1); utf32Index < stopIndex; utf32Index += 1) {
		utf32 = aWordArray[utf32Index];
		if (aBoolean) {
			if (utf32 == 95) {
				utf32 = 8592;
			}
			if (utf32 == 94) {
				utf32 = 8593;
			}
		}
		if (utf32 <= 0x7F) {
			utf8Byte = utf32;
			i = contourDataIndexes[utf8Byte];
		}
		else {
			if (utf32 <= 0x7FF) {
				utf8Byte = ((((usqInt)(utf32)) >> 6)) | 192;
				i = contourDataIndexes[utf8Byte];
				utf8Byte = (utf32 & 0x3F) | 128;
				i = contourDataIndexes[utf8Byte - i];
			}
			else {
				if (utf32 <= 0xFFFF) {
					utf8Byte = ((((usqInt)(utf32)) >> 12)) | 224;
					i = contourDataIndexes[utf8Byte];
					utf8Byte = (((((usqInt)(utf32)) >> 6)) & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
					utf8Byte = (utf32 & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
				}
				else {
					utf8Byte = ((((usqInt)(utf32)) >> 18)) | 240;
					i = contourDataIndexes[utf8Byte];
					utf8Byte = (((((usqInt)(utf32)) >> 12)) & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
					utf8Byte = (((((usqInt)(utf32)) >> 6)) & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
					utf8Byte = (utf32 & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
				}
			}
		}
		i -= 1;
		advanceWidth = contourData[i];
		i += 5;
		numContours = ((sqInt)(contourData[i]));
		i += 1;
		for (idx = 1; idx <= numContours; idx += 1) {
			numBeziers = ((sqInt)(contourData[i]));
			i += 1;
			ttMoveToX = (contourData[i]) + nextGlyphX;
			i += 1;
			ttMoveToY = (contourData[i]) + nextGlyphY;
			i += 1;
			startX = ((ttMoveToX * txA11) + (ttMoveToY * txA12)) + txA13;
			startY = ((ttMoveToX * txA21) + (ttMoveToY * txA22)) + txA23;
			contourStartX = startX;
			contourStartY = startY;
			/* begin initializeTrajectoryFragment */
			prevYTruncated = 0x7FFFFFFF;
			for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
				ttEndX = contourData[i];
				i += 1;
				ttEndY = contourData[i];
				i += 1;
				ttControlX = contourData[i];
				i += 1;
				ttControlY = contourData[i];
				i += 1;
				endX = ((ttEndX * txA11) + (ttEndY * txA12)) + startX;
				endY = ((ttEndX * txA21) + (ttEndY * txA22)) + startY;
				controlX = ((ttControlX * txA11) + (ttControlY * txA12)) + startX;

				/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
				controlY = ((ttControlX * txA21) + (ttControlY * txA22)) + startY;
				xMinEnd = ((startX < endX) ? startX : endX);
				xMaxEnd = ((startX < endX) ? endX : startX);
				yMinEnd = ((startY < endY) ? startY : endY);
				yMaxEnd = ((startY < endY) ? endY : startY);
				spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
				spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
				spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));

				/* Compute Quadratic Bezier Curve, */
				/* Case t = 0.0 */
				spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
				x = startX;
				y = startY;
				updateAlphasForXy(x, y);
				updateEdgeCountAtXy(x, y);
				dx = fabs(endX-startX); dy = fabs(endY-startY);
				increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
				t = 0.0;
				while (1) {
					t0 = t;
					x0 = x;

					/* Compute next point. Only C version to avoid hitting a limit in Smalltalk compiler. */
					y0 = y;
					
						t = t0 + increment; oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT; f2 = 2.0 * oneLessT * t; f3 = t * t;
						x = (f1 * startX) + (f2 * controlX) + (f3 * endX);
						y = (f1 * startY) + (f2 * controlY) + (f3 * endY);
						dx = x-x0; dy = y-y0;
						length = sqrt(dx*dx + dy*dy);

					/* Now adjust the increment to aim at the required hop length, and recompute next point. */
					correction = hop / length;
					do {
						increment = (increment / length) * hop;
						t = t0 + increment;
						oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT;
						f2 = (2.0 * oneLessT) * t;
						f3 = t * t;
						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
						dx = x - x0;
						dy = y - y0;
						
							length = sqrt(dx*dx + dy*dy);
						correction = hop / length;
					} while(correction < 1.0);
					if (!(t < 1.0)) break;
					updateAlphasForXy(x, y);
					updateEdgeCountAtXy(x, y);
				}
				startX = endX;
				startY = endY;
			}
			updateAlphasForXy(endX, endY);
			updateEdgeCountAtXy(endX, endY);
			updateEdgeCountAtXy(contourStartX, contourStartY);
		}
		nextGlyphX += advanceWidth;
	}
	txA11 = txA11 / sx;
	txA12 = txA12 / sy;
	txA21 = txA21 / sx;
	txA22 = txA22 / sy;
	answer = nextGlyphX * sx;
	if (!(failed())) {
		_return_value = floatObjectOf(answer);
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}

	/* VectorEnginePlugin>>#displayUtf32WP:from:to:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: */
EXPORT(sqInt)
primDisplayUtf32WP(void)
{
	sqInt aBoolean;
	float advanceWidth;
	char *anotherByteArray;
	double answer;
	unsigned *aWordArray;
	float *contourData;
	int *contourDataIndexes;
	float contourStartX;
	float contourStartY;
	float controlX;
	float controlY;
	float correction;
	double destX;
	double destY;
	float dx;
	float dy;
	float endX;
	float endY;
	float f1;
	float f2;
	float f3;
	int i;
	sqInt idx;
	sqInt idx2;
	float increment;
	float length;
	float nextGlyphX;
	float nextGlyphY;
	sqInt numBeziers;
	sqInt numContours;
	float oneLessT;
	char *otherByteArray;
	sqInt startIndex;
	float startX;
	float startY;
	sqInt stopIndex;
	double sx;
	double sy;
	float t;
	float t0;
	float ttControlX;
	float ttControlY;
	float ttEndX;
	float ttEndY;
	float ttMoveToX;
	float ttMoveToY;
	unsigned utf32;
	sqInt utf32Index;
	unsigned utf8Byte;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;
	sqInt _return_value;

	if (!((isWords(stackValue(11)))
		 && ((isIntegerObject((startIndex = stackValue(10))))
		 && ((isIntegerObject((stopIndex = stackValue(9))))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isWordsOrBytes(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isBooleanObject(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isBytes(stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aWordArray = firstIndexableField(stackValue(11));
	startIndex = integerValueOf(startIndex);
	stopIndex = integerValueOf(stopIndex);
	destX = stackFloatValue(8);
	destY = stackFloatValue(7);
	sx = stackFloatValue(6);
	sy = stackFloatValue(5);
	contourData = firstIndexableField(stackValue(4));
	contourDataIndexes = firstIndexableField(stackValue(3));
	aBoolean = booleanValueOf(stackValue(2));
	otherByteArray = firstIndexableField(stackValue(1));
	anotherByteArray = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	txA11 = txA11 * sx;
	txA12 = txA12 * sy;
	txA21 = txA21 * sx;
	txA22 = txA22 * sy;
	nextGlyphX = destX / sx;
	nextGlyphY = destY / sy;
	for (utf32Index = (startIndex - 1); utf32Index < stopIndex; utf32Index += 1) {
		utf32 = aWordArray[utf32Index];
		if (aBoolean) {
			if (utf32 == 95) {
				utf32 = 8592;
			}
			if (utf32 == 94) {
				utf32 = 8593;
			}
		}
		if (utf32 <= 0x7F) {
			utf8Byte = utf32;
			i = contourDataIndexes[utf8Byte];
		}
		else {
			if (utf32 <= 0x7FF) {
				utf8Byte = ((((usqInt)(utf32)) >> 6)) | 192;
				i = contourDataIndexes[utf8Byte];
				utf8Byte = (utf32 & 0x3F) | 128;
				i = contourDataIndexes[utf8Byte - i];
			}
			else {
				if (utf32 <= 0xFFFF) {
					utf8Byte = ((((usqInt)(utf32)) >> 12)) | 224;
					i = contourDataIndexes[utf8Byte];
					utf8Byte = (((((usqInt)(utf32)) >> 6)) & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
					utf8Byte = (utf32 & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
				}
				else {
					utf8Byte = ((((usqInt)(utf32)) >> 18)) | 240;
					i = contourDataIndexes[utf8Byte];
					utf8Byte = (((((usqInt)(utf32)) >> 12)) & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
					utf8Byte = (((((usqInt)(utf32)) >> 6)) & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
					utf8Byte = (utf32 & 0x3F) | 128;
					i = contourDataIndexes[utf8Byte - i];
				}
			}
		}
		i -= 1;
		advanceWidth = contourData[i];
		i += 5;
		numContours = ((sqInt)(contourData[i]));
		i += 1;
		for (idx = 1; idx <= numContours; idx += 1) {
			numBeziers = ((sqInt)(contourData[i]));
			i += 1;
			ttMoveToX = (contourData[i]) + nextGlyphX;
			i += 1;
			ttMoveToY = (contourData[i]) + nextGlyphY;
			i += 1;
			startX = ((ttMoveToX * txA11) + (ttMoveToY * txA12)) + txA13;
			startY = ((ttMoveToX * txA21) + (ttMoveToY * txA22)) + txA23;
			contourStartX = startX;
			contourStartY = startY;
			/* begin initializeTrajectoryFragment */
			prevYTruncated = 0x7FFFFFFF;
			for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
				ttEndX = contourData[i];
				i += 1;
				ttEndY = contourData[i];
				i += 1;
				ttControlX = contourData[i];
				i += 1;
				ttControlY = contourData[i];
				i += 1;
				endX = ((ttEndX * txA11) + (ttEndY * txA12)) + startX;
				endY = ((ttEndX * txA21) + (ttEndY * txA22)) + startY;
				controlX = ((ttControlX * txA11) + (ttControlY * txA12)) + startX;

				/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
				controlY = ((ttControlX * txA21) + (ttControlY * txA22)) + startY;
				xMinEnd = ((startX < endX) ? startX : endX);
				xMaxEnd = ((startX < endX) ? endX : startX);
				yMinEnd = ((startY < endY) ? startY : endY);
				yMaxEnd = ((startY < endY) ? endY : startY);
				spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
				spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
				spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));

				/* Compute Quadratic Bezier Curve, */
				/* Case t = 0.0 */
				spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
				x = startX;
				y = startY;
				updateAlphasWPZeroStrokeForXy(x, y);
				updateEdgeCountWPAtXy(x, y);
				dx = fabs(endX-startX); dy = fabs(endY-startY);
				increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
				t = 0.0;
				while (1) {
					t0 = t;
					x0 = x;

					/* Compute next point. Only C version to avoid hitting a limit in Smalltalk compiler. */
					y0 = y;
					
						t = t0 + increment; oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT; f2 = 2.0 * oneLessT * t; f3 = t * t;
						x = (f1 * startX) + (f2 * controlX) + (f3 * endX);
						y = (f1 * startY) + (f2 * controlY) + (f3 * endY);
						dx = x-x0; dy = y-y0;
						length = sqrt(dx*dx + dy*dy);

					/* Now adjust the increment to aim at the required hop length, and recompute next point. */
					correction = hop / length;
					do {
						increment = (increment / length) * hop;
						t = t0 + increment;
						oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT;
						f2 = (2.0 * oneLessT) * t;
						f3 = t * t;
						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
						dx = x - x0;
						dy = y - y0;
						
							length = sqrt(dx*dx + dy*dy);
						correction = hop / length;
					} while(correction < 1.0);
					if (!(t < 1.0)) break;
					updateAlphasWPZeroStrokeForXy(x, y);
					updateEdgeCountWPAtXy(x, y);
				}
				startX = endX;
				startY = endY;
			}
			updateAlphasWPZeroStrokeForXy(endX, endY);
			updateEdgeCountWPAtXy(endX, endY);
			updateEdgeCountWPAtXy(contourStartX, contourStartY);
		}
		nextGlyphX += advanceWidth;
	}
	txA11 = txA11 / sx;
	txA12 = txA12 / sy;
	txA21 = txA21 / sx;
	txA22 = txA22 / sy;
	answer = nextGlyphX * sx;
	if (!(failed())) {
		_return_value = floatObjectOf(answer);
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}

	/* VectorEnginePlugin>>#displayUtf8:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: */
EXPORT(sqInt)
primDisplayUtf8(void)
{
	sqInt aBoolean;
	char *aByteArray;
	float advanceWidth;
	unsigned *anotherWordArray;
	double answer;
	int baseIndex;
	uint8_t byte;
	sqInt byteIndex;
	sqInt byteStartIndex;
	sqInt byteStopIndex;
	float *contourData;
	int *contourDataIndexes;
	float contourStartX;
	float contourStartY;
	float controlX;
	float controlY;
	float correction;
	double destX;
	double destY;
	float dx;
	float dy;
	float endX;
	float endY;
	float f1;
	float f2;
	float f3;
	int i;
	sqInt idx;
	sqInt idx2;
	float increment;
	float length;
	float nextGlyphX;
	float nextGlyphY;
	sqInt numBeziers;
	sqInt numContours;
	float oneLessT;
	unsigned *otherWordArray;
	float startX;
	float startY;
	double sx;
	double sy;
	float t;
	float t0;
	float ttControlX;
	float ttControlY;
	float ttEndX;
	float ttEndY;
	float ttMoveToX;
	float ttMoveToY;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;
	sqInt _return_value;

	if (!((isBytes(stackValue(11)))
		 && ((isIntegerObject((byteStartIndex = stackValue(10))))
		 && ((isIntegerObject((byteStopIndex = stackValue(9))))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isWordsOrBytes(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isBooleanObject(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWords(stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aByteArray = firstIndexableField(stackValue(11));
	byteStartIndex = integerValueOf(byteStartIndex);
	byteStopIndex = integerValueOf(byteStopIndex);
	destX = stackFloatValue(8);
	destY = stackFloatValue(7);
	sx = stackFloatValue(6);
	sy = stackFloatValue(5);
	contourData = firstIndexableField(stackValue(4));
	contourDataIndexes = firstIndexableField(stackValue(3));
	aBoolean = booleanValueOf(stackValue(2));
	otherWordArray = firstIndexableField(stackValue(1));
	anotherWordArray = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	txA11 = txA11 * sx;
	txA12 = txA12 * sy;
	txA21 = txA21 * sx;
	txA22 = txA22 * sy;
	nextGlyphX = destX / sx;
	nextGlyphY = destY / sy;
	baseIndex = 0;
	for (byteIndex = (byteStartIndex - 1); byteIndex < byteStopIndex; byteIndex += 1) {
		byte = aByteArray[byteIndex];
		i = contourDataIndexes[baseIndex + byte];
		if (aBoolean) {
			if (byte == 95) {
				i = contourDataIndexes[226];
				i = contourDataIndexes[134 - i];
				i = contourDataIndexes[144 - i];
			}
			if (byte == 94) {
				i = contourDataIndexes[226];
				i = contourDataIndexes[134 - i];
				i = contourDataIndexes[145 - i];
			}
		}
		if (i < 0) {
			baseIndex = 0 - i;
		}
		else {
			i -= 1;
			advanceWidth = contourData[i];
			i += 5;
			numContours = ((sqInt)(contourData[i]));
			i += 1;
			for (idx = 1; idx <= numContours; idx += 1) {
				numBeziers = ((sqInt)(contourData[i]));
				i += 1;
				ttMoveToX = (contourData[i]) + nextGlyphX;
				i += 1;
				ttMoveToY = (contourData[i]) + nextGlyphY;
				i += 1;
				startX = ((ttMoveToX * txA11) + (ttMoveToY * txA12)) + txA13;
				startY = ((ttMoveToX * txA21) + (ttMoveToY * txA22)) + txA23;
				contourStartX = startX;
				contourStartY = startY;
				/* begin initializeTrajectoryFragment */
				prevYTruncated = 0x7FFFFFFF;
				for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
					ttEndX = contourData[i];
					i += 1;
					ttEndY = contourData[i];
					i += 1;
					ttControlX = contourData[i];
					i += 1;
					ttControlY = contourData[i];
					i += 1;
					endX = ((ttEndX * txA11) + (ttEndY * txA12)) + startX;
					endY = ((ttEndX * txA21) + (ttEndY * txA22)) + startY;
					controlX = ((ttControlX * txA11) + (ttControlY * txA12)) + startX;

					/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
					controlY = ((ttControlX * txA21) + (ttControlY * txA22)) + startY;
					xMinEnd = ((startX < endX) ? startX : endX);
					xMaxEnd = ((startX < endX) ? endX : startX);
					yMinEnd = ((startY < endY) ? startY : endY);
					yMaxEnd = ((startY < endY) ? endY : startY);
					spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
					spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
					spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));

					/* Case t = 0.0 */
					spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
					x = startX;
					y = startY;
					updateAlphasForXy(x, y);
					updateEdgeCountAtXy(x, y);
					dx = fabs(endX-startX); dy = fabs(endY-startY);

					/* Compute Quadratic Bezier Curve, */
					increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
					t = 0.0;
					while (1) {
						t0 = t;
						x0 = x;

						/* Compute next point */
						y0 = y;
						t = t0 + increment;
						oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT;
						f2 = (2.0 * oneLessT) * t;
						f3 = t * t;
						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);

						/* Now adjust the increment to aim at the required hop length, and recompute next point. */
						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
						dx = x - x0;
						dy = y - y0;
						
								length = sqrt(dx*dx + dy*dy);
						correction = hop / length;
						do {
							increment = (increment / length) * hop;
							t = t0 + increment;
							oneLessT = 1.0 - t;
							f1 = oneLessT * oneLessT;
							f2 = (2.0 * oneLessT) * t;
							f3 = t * t;
							x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
							y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
							dx = x - x0;
							dy = y - y0;
							
									length = sqrt(dx*dx + dy*dy);
							correction = hop / length;
						} while(correction < 1.0);
						if (!(t < 1.0)) break;
						updateAlphasForXy(x, y);
						updateEdgeCountAtXy(x, y);
					}
					startX = endX;
					startY = endY;
				}
				updateAlphasForXy(endX, endY);
				updateEdgeCountAtXy(endX, endY);
				updateEdgeCountAtXy(contourStartX, contourStartY);
			}
			nextGlyphX += advanceWidth;
			baseIndex = 0;
		}
	}
	txA11 = txA11 / sx;
	txA12 = txA12 / sy;
	txA21 = txA21 / sx;
	txA22 = txA22 / sy;
	answer = nextGlyphX * sx;
	if (!(failed())) {
		_return_value = floatObjectOf(answer);
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}

	/* VectorEnginePlugin>>#displayUtf8WP:fromByte:toByte:atx:y:scalex:y:contourData:contourDataIndexes:useST80Glyphs:edgeCounts:alphaMask: */
EXPORT(sqInt)
primDisplayUtf8WP(void)
{
	sqInt aBoolean;
	char *aByteArray;
	float advanceWidth;
	char *anotherByteArray;
	double answer;
	int baseIndex;
	uint8_t byte;
	sqInt byteIndex;
	sqInt byteStartIndex;
	sqInt byteStopIndex;
	float *contourData;
	int *contourDataIndexes;
	float contourStartX;
	float contourStartY;
	float controlX;
	float controlY;
	float correction;
	double destX;
	double destY;
	float dx;
	float dy;
	float endX;
	float endY;
	float f1;
	float f2;
	float f3;
	int i;
	sqInt idx;
	sqInt idx2;
	float increment;
	float length;
	float nextGlyphX;
	float nextGlyphY;
	sqInt numBeziers;
	sqInt numContours;
	float oneLessT;
	char *otherByteArray;
	float startX;
	float startY;
	double sx;
	double sy;
	float t;
	float t0;
	float ttControlX;
	float ttControlY;
	float ttEndX;
	float ttEndY;
	float ttMoveToX;
	float ttMoveToY;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;
	sqInt _return_value;

	if (!((isBytes(stackValue(11)))
		 && ((isIntegerObject((byteStartIndex = stackValue(10))))
		 && ((isIntegerObject((byteStopIndex = stackValue(9))))
		 && ((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isWordsOrBytes(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isBooleanObject(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isBytes(stackValue(0))))))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aByteArray = firstIndexableField(stackValue(11));
	byteStartIndex = integerValueOf(byteStartIndex);
	byteStopIndex = integerValueOf(byteStopIndex);
	destX = stackFloatValue(8);
	destY = stackFloatValue(7);
	sx = stackFloatValue(6);
	sy = stackFloatValue(5);
	contourData = firstIndexableField(stackValue(4));
	contourDataIndexes = firstIndexableField(stackValue(3));
	aBoolean = booleanValueOf(stackValue(2));
	otherByteArray = firstIndexableField(stackValue(1));
	anotherByteArray = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	txA11 = txA11 * sx;
	txA12 = txA12 * sy;
	txA21 = txA21 * sx;
	txA22 = txA22 * sy;
	nextGlyphX = destX / sx;
	nextGlyphY = destY / sy;
	baseIndex = 0;
	for (byteIndex = (byteStartIndex - 1); byteIndex < byteStopIndex; byteIndex += 1) {
		byte = aByteArray[byteIndex];
		i = contourDataIndexes[baseIndex + byte];
		if (aBoolean) {
			if (byte == 95) {
				i = contourDataIndexes[226];
				i = contourDataIndexes[134 - i];
				i = contourDataIndexes[144 - i];
			}
			if (byte == 94) {
				i = contourDataIndexes[226];
				i = contourDataIndexes[134 - i];
				i = contourDataIndexes[145 - i];
			}
		}
		if (i < 0) {
			baseIndex = 0 - i;
		}
		else {
			i -= 1;
			advanceWidth = contourData[i];
			i += 5;
			numContours = ((sqInt)(contourData[i]));
			i += 1;
			for (idx = 1; idx <= numContours; idx += 1) {
				numBeziers = ((sqInt)(contourData[i]));
				i += 1;
				ttMoveToX = (contourData[i]) + nextGlyphX;
				i += 1;
				ttMoveToY = (contourData[i]) + nextGlyphY;
				i += 1;
				startX = ((ttMoveToX * txA11) + (ttMoveToY * txA12)) + txA13;
				startY = ((ttMoveToX * txA21) + (ttMoveToY * txA22)) + txA23;
				contourStartX = startX;
				contourStartY = startY;
				/* begin initializeTrajectoryFragment */
				prevYTruncated = 0x7FFFFFFF;
				for (idx2 = 1; idx2 <= numBeziers; idx2 += 1) {
					ttEndX = contourData[i];
					i += 1;
					ttEndY = contourData[i];
					i += 1;
					ttControlX = contourData[i];
					i += 1;
					ttControlY = contourData[i];
					i += 1;
					endX = ((ttEndX * txA11) + (ttEndY * txA12)) + startX;
					endY = ((ttEndX * txA21) + (ttEndY * txA22)) + startY;
					controlX = ((ttControlX * txA11) + (ttControlY * txA12)) + startX;

					/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
					controlY = ((ttControlX * txA21) + (ttControlY * txA22)) + startY;
					xMinEnd = ((startX < endX) ? startX : endX);
					xMaxEnd = ((startX < endX) ? endX : startX);
					yMinEnd = ((startY < endY) ? startY : endY);
					yMaxEnd = ((startY < endY) ? endY : startY);
					spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + controlX) / 2.0)) ? xMinEnd : ((xMinEnd + controlX) / 2.0))));
					spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + controlX) / 2.0)) ? ((xMaxEnd + controlX) / 2.0) : xMaxEnd)) : spanRight);
					spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + controlY) / 2.0)) ? yMinEnd : ((yMinEnd + controlY) / 2.0))));

					/* Case t = 0.0 */
					spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + controlY) / 2.0)) ? ((yMaxEnd + controlY) / 2.0) : yMaxEnd)) : spanBottom);
					x = startX;
					y = startY;
					updateAlphasWPZeroStrokeForXy(x, y);
					updateEdgeCountWPAtXy(x, y);
					dx = fabs(endX-startX); dy = fabs(endY-startY);

					/* Compute Quadratic Bezier Curve, */
					increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
					t = 0.0;
					while (1) {
						t0 = t;
						x0 = x;

						/* Compute next point */
						y0 = y;
						t = t0 + increment;
						oneLessT = 1.0 - t;
						f1 = oneLessT * oneLessT;
						f2 = (2.0 * oneLessT) * t;
						f3 = t * t;
						x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);

						/* Now adjust the increment to aim at the required hop length, and recompute next point. */
						y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
						dx = x - x0;
						dy = y - y0;
						
								length = sqrt(dx*dx + dy*dy);
						correction = hop / length;
						do {
							increment = (increment / length) * hop;
							t = t0 + increment;
							oneLessT = 1.0 - t;
							f1 = oneLessT * oneLessT;
							f2 = (2.0 * oneLessT) * t;
							f3 = t * t;
							x = ((f1 * startX) + (f2 * controlX)) + (f3 * endX);
							y = ((f1 * startY) + (f2 * controlY)) + (f3 * endY);
							dx = x - x0;
							dy = y - y0;
							
									length = sqrt(dx*dx + dy*dy);
							correction = hop / length;
						} while(correction < 1.0);
						if (!(t < 1.0)) break;
						updateAlphasWPZeroStrokeForXy(x, y);
						updateEdgeCountWPAtXy(x, y);
					}
					startX = endX;
					startY = endY;
				}
				updateAlphasWPZeroStrokeForXy(endX, endY);
				updateEdgeCountWPAtXy(endX, endY);
				updateEdgeCountWPAtXy(contourStartX, contourStartY);
			}
			nextGlyphX += advanceWidth;
			baseIndex = 0;
		}
	}
	txA11 = txA11 / sx;
	txA12 = txA12 / sy;
	txA21 = txA21 / sx;
	txA22 = txA22 / sy;
	answer = nextGlyphX * sx;
	if (!(failed())) {
		_return_value = floatObjectOf(answer);
		if (!(failed())) {
			methodReturnValue(_return_value);
		}
	}
	return null;
}

	/* VectorEnginePlugin>>#fillR:g:b:a: */
EXPORT(sqInt)
primFillRGBA(void)
{
	double a;
	double b;
	double g;
	double r;

	if (!((isFloatObject(stackValue(3)))
		 && ((isFloatObject(stackValue(2)))
		 && ((isFloatObject(stackValue(1)))
		 && (isFloatObject(stackValue(0))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	r = stackFloatValue(3);
	g = stackFloatValue(2);
	b = stackFloatValue(1);
	a = stackFloatValue(0);
	fillR = r * 255.0;
	fillG = g * 255.0;
	fillB = b * 255.0;
	fillA = a;
	if (!(failed())) {
		pop(4);
	}
	return null;
}

	/* VectorEnginePlugin>>#geometryTxA11:a12:a13:a21:a22:a23: */
EXPORT(sqInt)
primGeometryTxSet(void)
{
	double a11;
	double a12;
	double a13;
	double a21;
	double a22;
	double a23;

	if (!((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isFloatObject(stackValue(2)))
		 && ((isFloatObject(stackValue(1)))
		 && (isFloatObject(stackValue(0))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	a11 = stackFloatValue(5);
	a12 = stackFloatValue(4);
	a13 = stackFloatValue(3);
	a21 = stackFloatValue(2);
	a22 = stackFloatValue(1);
	a23 = stackFloatValue(0);
	txA11 = a11;
	txA12 = a12;
	txA13 = a13;
	txA21 = a21;
	txA22 = a22;
	txA23 = a23;
	if (!(failed())) {
		pop(6);
	}
	return null;
}

	/* VectorEnginePlugin>>#initializePath */
EXPORT(sqInt)
primInitializePath(void)
{

	/* drawable right. Will later be refined. */
	spanLeft = targetWidth;

	/* drawable bottom. Will later be refined. */
	spanTop = targetHeight;

	/* drawable left. Will later be refined. */
	spanRight = 0;

	/* drawable top. Will later be refined. */
	spanBottom = 0;
	prevYRounded = 0x7FFFFFFF;
	return null;
}

	/* VectorEnginePlugin>>#lineFromX:y:toX:y:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primLine(void)
{
	float *aFloat32Array;
	unsigned *anotherWordArray;
	unsigned *otherWordArray;
	double xFrom;
	double xTo;
	double yFrom;
	double yTo;

	if (!((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	xFrom = stackFloatValue(6);
	yFrom = stackFloatValue(5);
	xTo = stackFloatValue(4);
	yTo = stackFloatValue(3);
	otherWordArray = firstIndexableField(stackValue(2));
	anotherWordArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	contour = aFloat32Array;
	pvt_lineFromXytoXy(xFrom, yFrom, xTo, yTo);
	if (!(failed())) {
		pop(7);
	}
	return null;
}

	/* VectorEnginePlugin>>#lineWPFromX:y:toX:y:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primLineWP(void)
{
	float *aFloat32Array;
	char *anotherByteArray;
	char *otherByteArray;
	double xFrom;
	double xTo;
	double yFrom;
	double yTo;

	if (!((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isBytes(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	xFrom = stackFloatValue(6);
	yFrom = stackFloatValue(5);
	xTo = stackFloatValue(4);
	yTo = stackFloatValue(3);
	otherByteArray = firstIndexableField(stackValue(2));
	anotherByteArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	contour = aFloat32Array;
	pvt_lineWPFromXytoXy(xFrom, yFrom, xTo, yTo);
	if (!(failed())) {
		pop(7);
	}
	return null;
}

	/* VectorEnginePlugin>>#newTrajectoryFragment */
EXPORT(sqInt)
primNewTrajectoryFragment(void)
{
	sqInt _return_value;

	_return_value = 0;
	/* begin initializeTrajectoryFragment */
	prevYTruncated = 0x7FFFFFFF;
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}

	/* VectorEnginePlugin>>#pathSequence:size:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primPathSequence(void)
{
	float *aFloat32Array;
	unsigned *anotherWordArray;
	sqInt commandType;
	float control1X;
	float control1Y;
	float control2X;
	float control2Y;
	float endX;
	float endY;
	sqInt i;
	float *otherFloat32Array;
	unsigned *otherWordArray;
	sqInt size;
	float startX;
	float startY;

	if (!((isWordsOrBytes(stackValue(4)))
		 && ((isIntegerObject((size = stackValue(3))))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aFloat32Array = firstIndexableField(stackValue(4));
	size = integerValueOf(size);
	otherWordArray = firstIndexableField(stackValue(2));
	anotherWordArray = firstIndexableField(stackValue(1));
	otherFloat32Array = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	contour = otherFloat32Array;
	i = 0;
	while (i < size) {
		commandType = ((sqInt)(aFloat32Array[i]));
		i += 1;
		switch (commandType) {
		case 0:
			if (!((i + 1) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			startX = aFloat32Array[i];
			i += 1;
			startY = aFloat32Array[i];
			i += 1;
			/* begin initializeTrajectoryFragment */
			prevYTruncated = 0x7FFFFFFF;
			break;
		case 1:
			if (!((i + 1) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			endX = aFloat32Array[i];
			i += 1;
			endY = aFloat32Array[i];
			i += 1;
			pvt_lineFromXytoXy(startX, startY, endX, endY);
			startX = endX;
			startY = endY;
			break;
		case 2:
			if (!((i + 3) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			endX = aFloat32Array[i];
			i += 1;
			endY = aFloat32Array[i];
			i += 1;
			control1X = aFloat32Array[i];
			i += 1;
			control1Y = aFloat32Array[i];
			i += 1;
			pvt_quadraticBezierFromXytoXycontrolXy(startX, startY, endX, endY, control1X, control1Y);
			startX = endX;
			startY = endY;
			break;
		case 3:
			if (!((i + 5) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			endX = aFloat32Array[i];
			i += 1;
			endY = aFloat32Array[i];
			i += 1;
			control1X = aFloat32Array[i];
			i += 1;
			control1Y = aFloat32Array[i];
			i += 1;
			control2X = aFloat32Array[i];
			i += 1;
			control2Y = aFloat32Array[i];
			i += 1;
			pvt_cubicBezierFromXytoXycontrol1Xycontrol2Xy(startX, startY, endX, endY, control1X, control1Y, control2X, control2Y);
			startX = endX;
			startY = endY;
			break;
		default:
			if (!(failed())) {
				pop(5);
			}
			return null;

		}
	}
	if (!(failed())) {
		pop(5);
	}
	return null;
}

	/* VectorEnginePlugin>>#pathSequenceWP:size:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primPathSequenceWP(void)
{
	float *aFloat32Array;
	char *anotherByteArray;
	sqInt commandType;
	float control1X;
	float control1Y;
	float control2X;
	float control2Y;
	float endX;
	float endY;
	sqInt i;
	char *otherByteArray;
	float *otherFloat32Array;
	sqInt size;
	float startX;
	float startY;

	if (!((isWordsOrBytes(stackValue(4)))
		 && ((isIntegerObject((size = stackValue(3))))
		 && ((isBytes(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aFloat32Array = firstIndexableField(stackValue(4));
	size = integerValueOf(size);
	otherByteArray = firstIndexableField(stackValue(2));
	anotherByteArray = firstIndexableField(stackValue(1));
	otherFloat32Array = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	contour = otherFloat32Array;
	i = 0;
	while (i < size) {
		commandType = ((sqInt)(aFloat32Array[i]));
		i += 1;
		switch (commandType) {
		case 0:
			if (!((i + 1) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			startX = aFloat32Array[i];
			i += 1;
			startY = aFloat32Array[i];
			i += 1;
			/* begin initializeTrajectoryFragment */
			prevYTruncated = 0x7FFFFFFF;
			break;
		case 1:
			if (!((i + 1) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			endX = aFloat32Array[i];
			i += 1;
			endY = aFloat32Array[i];
			i += 1;
			pvt_lineWPFromXytoXy(startX, startY, endX, endY);
			startX = endX;
			startY = endY;
			break;
		case 2:
			if (!((i + 3) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			endX = aFloat32Array[i];
			i += 1;
			endY = aFloat32Array[i];
			i += 1;
			control1X = aFloat32Array[i];
			i += 1;
			control1Y = aFloat32Array[i];
			i += 1;
			pvt_quadraticBezierWPFromXytoXycontrolXy(startX, startY, endX, endY, control1X, control1Y);
			startX = endX;
			startY = endY;
			break;
		case 3:
			if (!((i + 5) < size)) {
				if (!(failed())) {
					pop(5);
				}
				return null;
			}
			endX = aFloat32Array[i];
			i += 1;
			endY = aFloat32Array[i];
			i += 1;
			control1X = aFloat32Array[i];
			i += 1;
			control1Y = aFloat32Array[i];
			i += 1;
			control2X = aFloat32Array[i];
			i += 1;
			control2Y = aFloat32Array[i];
			i += 1;
			pvt_cubicBezierWPFromXytoXycontrol1Xycontrol2Xy(startX, startY, endX, endY, control1X, control1Y, control2X, control2Y);
			startX = endX;
			startY = endY;
			break;
		default:
			if (!(failed())) {
				pop(5);
			}
			return null;

		}
	}
	if (!(failed())) {
		pop(5);
	}
	return null;
}

	/* VectorEnginePlugin>>#quadraticBezierFromX:y:toX:y:controlX:y:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primQuadraticBezier(void)
{
	float *aFloat32Array;
	unsigned *anotherWordArray;
	unsigned *otherWordArray;
	double xControl;
	double xFrom;
	double xTo;
	double yControl;
	double yFrom;
	double yTo;

	if (!((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isWords(stackValue(2)))
		 && ((isWords(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	xFrom = stackFloatValue(8);
	yFrom = stackFloatValue(7);
	xTo = stackFloatValue(6);
	yTo = stackFloatValue(5);
	xControl = stackFloatValue(4);
	yControl = stackFloatValue(3);
	otherWordArray = firstIndexableField(stackValue(2));
	anotherWordArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	contour = aFloat32Array;
	pvt_quadraticBezierFromXytoXycontrolXy(xFrom, yFrom, xTo, yTo, xControl, yControl);
	if (!(failed())) {
		pop(9);
	}
	return null;
}

	/* VectorEnginePlugin>>#quadraticBezierWPFromX:y:toX:y:controlX:y:edgeCounts:alphaMask:contour: */
EXPORT(sqInt)
primQuadraticBezierWP(void)
{
	float *aFloat32Array;
	char *anotherByteArray;
	char *otherByteArray;
	double xControl;
	double xFrom;
	double xTo;
	double yControl;
	double yFrom;
	double yTo;

	if (!((isFloatObject(stackValue(8)))
		 && ((isFloatObject(stackValue(7)))
		 && ((isFloatObject(stackValue(6)))
		 && ((isFloatObject(stackValue(5)))
		 && ((isFloatObject(stackValue(4)))
		 && ((isFloatObject(stackValue(3)))
		 && ((isBytes(stackValue(2)))
		 && ((isBytes(stackValue(1)))
		 && (isWordsOrBytes(stackValue(0)))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	xFrom = stackFloatValue(8);
	yFrom = stackFloatValue(7);
	xTo = stackFloatValue(6);
	yTo = stackFloatValue(5);
	xControl = stackFloatValue(4);
	yControl = stackFloatValue(3);
	otherByteArray = firstIndexableField(stackValue(2));
	anotherByteArray = firstIndexableField(stackValue(1));
	aFloat32Array = firstIndexableField(stackValue(0));
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	contour = aFloat32Array;
	pvt_quadraticBezierWPFromXytoXycontrolXy(xFrom, yFrom, xTo, yTo, xControl, yControl);
	if (!(failed())) {
		pop(9);
	}
	return null;
}

	/* VectorEnginePlugin>>#resetContourTop:bottom:contour: */
EXPORT(sqInt)
primReset2Contour(void)
{
	float *aFloat32Array;
	sqInt b;
	sqInt t;
	sqInt y;

	if (!((isIntegerObject((t = stackValue(2))))
		 && ((isIntegerObject((b = stackValue(1))))
		 && (isWordsOrBytes(stackValue(0)))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	t = integerValueOf(t);
	b = integerValueOf(b);
	aFloat32Array = firstIndexableField(stackValue(0));
	contour = aFloat32Array;
	leftAtThisY = targetWidth;
	rightAtThisY = 0;
	for (y = t; y <= b; y += 1) {
		contour[y * 2] = targetWidth;
		contour[(y * 2) + 1] = 0;
	}
	if (!(failed())) {
		pop(3);
	}
	return null;
}


/*	All arrays could be pinned instead of passing them every time! */

	/* VectorEnginePlugin>>#targetBits:morphIds:edgeCounts:alphaMask:contour:targetWidth:targetHeight: */
EXPORT(sqInt)
primSetTarget(void)
{
	unsigned *aBitmap;
	float *aFloat32Array;
	sqInt aNumber;
	unsigned *anotherWordArray;
	unsigned *aWordArray;
	sqInt otherNumber;
	unsigned *otherWordArray;

	if (!((isWords(stackValue(6)))
		 && ((isWords(stackValue(5)))
		 && ((isWords(stackValue(4)))
		 && ((isWords(stackValue(3)))
		 && ((isWordsOrBytes(stackValue(2)))
		 && ((isIntegerObject((aNumber = stackValue(1))))
		 && (isIntegerObject((otherNumber = stackValue(0))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aBitmap = firstIndexableField(stackValue(6));
	aWordArray = firstIndexableField(stackValue(5));
	otherWordArray = firstIndexableField(stackValue(4));
	anotherWordArray = firstIndexableField(stackValue(3));
	aFloat32Array = firstIndexableField(stackValue(2));
	aNumber = integerValueOf(aNumber);
	otherNumber = integerValueOf(otherNumber);
	targetBits = aBitmap;
	morphIds = aWordArray;
	edgeCounts = otherWordArray;
	alphaMask = anotherWordArray;
	contour = aFloat32Array;
	targetWidth = aNumber;
	targetHeight = otherNumber;
	if (!(failed())) {
		pop(7);
	}
	return null;
}


/*	All arrays could be pinned instead of passing them every time! */

	/* VectorEnginePlugin>>#targetBits:morphIds:edgeCountsWP:alphaMaskWP:contour:targetWidth:targetHeight: */
EXPORT(sqInt)
primSetTargetWP(void)
{
	unsigned *aBitmap;
	float *aFloat32Array;
	sqInt aNumber;
	char *anotherByteArray;
	unsigned *aWordArray;
	char *otherByteArray;
	sqInt otherNumber;

	if (!((isWords(stackValue(6)))
		 && ((isWords(stackValue(5)))
		 && ((isBytes(stackValue(4)))
		 && ((isBytes(stackValue(3)))
		 && ((isWordsOrBytes(stackValue(2)))
		 && ((isIntegerObject((aNumber = stackValue(1))))
		 && (isIntegerObject((otherNumber = stackValue(0))))))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aBitmap = firstIndexableField(stackValue(6));
	aWordArray = firstIndexableField(stackValue(5));
	otherByteArray = firstIndexableField(stackValue(4));
	anotherByteArray = firstIndexableField(stackValue(3));
	aFloat32Array = firstIndexableField(stackValue(2));
	aNumber = integerValueOf(aNumber);
	otherNumber = integerValueOf(otherNumber);
	targetBits = aBitmap;
	morphIds = aWordArray;
	edgeCountsWP = otherByteArray;
	alphaMaskWP = anotherByteArray;
	contour = aFloat32Array;
	targetWidth = aNumber;
	targetHeight = otherNumber;
	if (!(failed())) {
		pop(7);
	}
	return null;
}

	/* VectorEnginePlugin>>#spanBottom */
EXPORT(sqInt)
primSpanBottom(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf((((sqInt)(spanBottom + auxStrokeWidthDilatedHalf))));
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}

	/* VectorEnginePlugin>>#spanLeft */
EXPORT(sqInt)
primSpanLeft(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf((((sqInt)(((spanLeft - auxStrokeWidthDilatedHalf) - subPixelDelta) + 1))));
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}

	/* VectorEnginePlugin>>#spanRight */
EXPORT(sqInt)
primSpanRight(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf(((((sqInt)((spanRight + auxStrokeWidthDilatedHalf) + subPixelDelta))) + 1));
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}

	/* VectorEnginePlugin>>#spanTop */
EXPORT(sqInt)
primSpanTop(void)
{
	sqInt _return_value;

	_return_value = integerObjectOf((((sqInt)((spanTop - auxStrokeWidthDilatedHalf) + 1))));
	if (!(failed())) {
		methodReturnValue(_return_value);
	}
	return null;
}

	/* VectorEnginePlugin>>#strokeR:g:b:a: */
EXPORT(sqInt)
primStrokeRGBA(void)
{
	double a;
	double b;
	double g;
	double r;

	if (!((isFloatObject(stackValue(3)))
		 && ((isFloatObject(stackValue(2)))
		 && ((isFloatObject(stackValue(1)))
		 && (isFloatObject(stackValue(0))))))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	r = stackFloatValue(3);
	g = stackFloatValue(2);
	b = stackFloatValue(1);
	a = stackFloatValue(0);
	strokeR = r * 255.0;
	strokeG = g * 255.0;
	strokeB = b * 255.0;
	strokeA = a;
	if (!(failed())) {
		pop(4);
	}
	return null;
}

	/* VectorEnginePlugin>>#strokeWidth: */
EXPORT(sqInt)
primStrokeWidth(void)
{
	double aNumber;
	float swErodedHalf;

	if (!(isFloatObject(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aNumber = stackFloatValue(0);
	strokeWidth = aNumber;
	auxStrokeWidthDilatedHalf = (strokeWidth + antiAliasingWidth) * 0.5;
	auxStrokeWidthDilatedHalfSquared = auxStrokeWidthDilatedHalf * auxStrokeWidthDilatedHalf;
	swErodedHalf = (strokeWidth - antiAliasingWidth) * 0.5;
	auxStrokeWidthErodedHalfSquared = swErodedHalf * fabs(swErodedHalf);
	if (!(failed())) {
		pop(1);
	}
	return null;
}

	/* VectorEnginePlugin>>#updateContourLastLine: */
EXPORT(sqInt)
primUpdate2ContourLastLine(void)
{
	float *aFloat32Array;

	if (!(isWordsOrBytes(stackValue(0)))) {
		return primitiveFailFor(PrimErrBadArgument);
	}
	aFloat32Array = firstIndexableField(stackValue(0));
	contour = aFloat32Array;
	if (!(prevYRounded == 0x7FFFFFFF)) {
		contour[prevYRounded * 2] = leftAtThisY;
		contour[(prevYRounded * 2) + 1] = rightAtThisY;
	}
	if (!(failed())) {
		pop(1);
	}
	return null;
}

	/* VectorEnginePlugin>>#pvt_cubicBezierFromX:y:toX:y:control1X:y:control2X:y: */
static sqInt
pvt_cubicBezierFromXytoXycontrol1Xycontrol2Xy(float xFrom, float yFrom, float xTo, float yTo, float xControl1, float yControl1, float xControl2, float yControl2)
{
	float dx;
	float dx2;
	float dx3;
	float dy;
	float dy2;
	float dy3;
	float f1;
	float f2;
	float f23;
	float f3;
	float f4;
	int hops;
	float increment;
	float oneLessT;
	float t;
	float txControl1;
	float txControl2;
	float txFrom;
	float txTo;
	float tyControl1;
	float tyControl2;
	float tyFrom;
	float tyTo;
	float x;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float yMaxEnd;
	float yMinEnd;

	txFrom = ((xFrom * txA11) + (yFrom * txA12)) + txA13;
	tyFrom = ((xFrom * txA21) + (yFrom * txA22)) + txA23;
	txTo = ((xTo * txA11) + (yTo * txA12)) + txA13;
	tyTo = ((xTo * txA21) + (yTo * txA22)) + txA23;
	txControl1 = ((xControl1 * txA11) + (yControl1 * txA12)) + txA13;
	tyControl1 = ((xControl1 * txA21) + (yControl1 * txA22)) + txA23;
	txControl2 = ((xControl2 * txA11) + (yControl2 * txA12)) + txA13;
	tyControl2 = ((xControl2 * txA21) + (yControl2 * txA22)) + txA23;
	
		dx = fabs(txControl1-txFrom);
		dx2 = fabs(txTo-txControl2);
		dx3 = fabs(txControl2-txControl1);
		dy = fabs(tyControl1-tyFrom);
		dy2 = fabs(tyTo-tyControl2);
		dy3 = fabs(tyControl2-tyControl1);
	dx = ((((((dx < dx2) ? dx2 : dx)) * 3) < (dx3 * 1.5)) ? (dx3 * 1.5) : ((((dx < dx2) ? dx2 : dx)) * 3));
	dy = ((((((dy < dy2) ? dy2 : dy)) * 3) < (dy3 * 1.5)) ? (dy3 * 1.5) : ((((dy < dy2) ? dy2 : dy)) * 3));

	/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
	hops = (((sqInt)((((dx < dy) ? dy : dx)) / hop))) + 1;
	xMinEnd = ((txFrom < txTo) ? txFrom : txTo);
	xMaxEnd = ((txFrom < txTo) ? txTo : txFrom);
	yMinEnd = ((tyFrom < tyTo) ? tyFrom : tyTo);
	yMaxEnd = ((tyFrom < tyTo) ? tyTo : tyFrom);
	spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75))) ? xMinEnd : ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75))))) ? spanLeft : (((xMinEnd < ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75))) ? xMinEnd : ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75)))));
	spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75))) ? ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75)) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75))) ? ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75)) : xMaxEnd)) : spanRight);
	spanTop = ((spanTop < (((yMinEnd < ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75))) ? yMinEnd : ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75))))) ? spanTop : (((yMinEnd < ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75))) ? yMinEnd : ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75)))));
	spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75))) ? ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75)) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75))) ? ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75)) : yMaxEnd)) : spanBottom);
	t = 0.0;
	increment = 1.0 / hops;
	while (t < 1.0) {
		oneLessT = 1.0 - t;
		f1 = (oneLessT * oneLessT) * oneLessT;
		f23 = (3.0 * oneLessT) * t;
		f2 = f23 * oneLessT;
		f3 = f23 * t;
		f4 = (t * t) * t;
		x = (((f1 * txFrom) + (f2 * txControl1)) + (f3 * txControl2)) + (f4 * txTo);
		y = (((f1 * tyFrom) + (f2 * tyControl1)) + (f3 * tyControl2)) + (f4 * tyTo);
		updateAlphasForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountAtXy(x, y);
		}
		updateContourForXy(x, y);
		t += increment;
	}
	updateAlphasForXy(txTo, tyTo);
	if (!(fillA == 0.0)) {
		updateEdgeCountAtXy(txTo, tyTo);
	}
	updateContourForXy(txTo, tyTo);
	return 0;
}

	/* VectorEnginePlugin>>#pvt_cubicBezierWPFromX:y:toX:y:control1X:y:control2X:y: */
static sqInt
pvt_cubicBezierWPFromXytoXycontrol1Xycontrol2Xy(float xFrom, float yFrom, float xTo, float yTo, float xControl1, float yControl1, float xControl2, float yControl2)
{
	float dx;
	float dx2;
	float dx3;
	float dy;
	float dy2;
	float dy3;
	float f1;
	float f2;
	float f23;
	float f3;
	float f4;
	int hops;
	float increment;
	float oneLessT;
	float t;
	float txControl1;
	float txControl2;
	float txFrom;
	float txTo;
	float tyControl1;
	float tyControl2;
	float tyFrom;
	float tyTo;
	float x;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float yMaxEnd;
	float yMinEnd;

	txFrom = ((xFrom * txA11) + (yFrom * txA12)) + txA13;
	tyFrom = ((xFrom * txA21) + (yFrom * txA22)) + txA23;
	txTo = ((xTo * txA11) + (yTo * txA12)) + txA13;
	tyTo = ((xTo * txA21) + (yTo * txA22)) + txA23;
	txControl1 = ((xControl1 * txA11) + (yControl1 * txA12)) + txA13;
	tyControl1 = ((xControl1 * txA21) + (yControl1 * txA22)) + txA23;
	txControl2 = ((xControl2 * txA11) + (yControl2 * txA12)) + txA13;
	tyControl2 = ((xControl2 * txA21) + (yControl2 * txA22)) + txA23;
	
		dx = fabs(txControl1-txFrom);
		dx2 = fabs(txTo-txControl2);
		dx3 = fabs(txControl2-txControl1);
		dy = fabs(tyControl1-tyFrom);
		dy2 = fabs(tyTo-tyControl2);
		dy3 = fabs(tyControl2-tyControl1);
	dx = ((((((dx < dx2) ? dx2 : dx)) * 3) < (dx3 * 1.5)) ? (dx3 * 1.5) : ((((dx < dx2) ? dx2 : dx)) * 3));
	dy = ((((((dy < dy2) ? dy2 : dy)) * 3) < (dy3 * 1.5)) ? (dy3 * 1.5) : ((((dy < dy2) ? dy2 : dy)) * 3));

	/* This computed span of the Bezier curve is a bit pessimistic (larger than strict bounds), but safe. */
	hops = (((sqInt)((((dx < dy) ? dy : dx)) / hop))) + 1;
	xMinEnd = ((txFrom < txTo) ? txFrom : txTo);
	xMaxEnd = ((txFrom < txTo) ? txTo : txFrom);
	yMinEnd = ((tyFrom < tyTo) ? tyFrom : tyTo);
	yMaxEnd = ((tyFrom < tyTo) ? tyTo : tyFrom);
	spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75))) ? xMinEnd : ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75))))) ? spanLeft : (((xMinEnd < ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75))) ? xMinEnd : ((xMinEnd * 0.25) + ((((txControl1 < txControl2) ? txControl1 : txControl2)) * 0.75)))));
	spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75))) ? ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75)) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75))) ? ((xMaxEnd * 0.25) + ((((txControl1 < txControl2) ? txControl2 : txControl1)) * 0.75)) : xMaxEnd)) : spanRight);
	spanTop = ((spanTop < (((yMinEnd < ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75))) ? yMinEnd : ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75))))) ? spanTop : (((yMinEnd < ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75))) ? yMinEnd : ((yMinEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl1 : tyControl2)) * 0.75)))));
	spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75))) ? ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75)) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75))) ? ((yMaxEnd * 0.25) + ((((tyControl1 < tyControl2) ? tyControl2 : tyControl1)) * 0.75)) : yMaxEnd)) : spanBottom);
	t = 0.0;
	increment = 1.0 / hops;
	while (t < 1.0) {
		oneLessT = 1.0 - t;
		f1 = (oneLessT * oneLessT) * oneLessT;
		f23 = (3.0 * oneLessT) * t;
		f2 = f23 * oneLessT;
		f3 = f23 * t;
		f4 = (t * t) * t;
		x = (((f1 * txFrom) + (f2 * txControl1)) + (f3 * txControl2)) + (f4 * txTo);
		y = (((f1 * tyFrom) + (f2 * tyControl1)) + (f3 * tyControl2)) + (f4 * tyTo);
		updateAlphasWPForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountWPAtXy(x, y);
		}
		updateContourForXy(x, y);
		t += increment;
	}
	updateAlphasWPForXy(txTo, tyTo);
	if (!(fillA == 0.0)) {
		updateEdgeCountWPAtXy(txTo, tyTo);
	}
	updateContourForXy(txTo, tyTo);
	return 0;
}

	/* VectorEnginePlugin>>#pvt_lineFromX:y:toX:y: */
static sqInt
pvt_lineFromXytoXy(float xFrom, float yFrom, float xTo, float yTo)
{
	float dx;
	float dy;
	int hops;
	float increment;
	float oneLessT;
	float t;
	float txFrom;
	float txTo;
	float tyFrom;
	float tyTo;
	float x;
	float y;

	txFrom = ((xFrom * txA11) + (yFrom * txA12)) + txA13;
	tyFrom = ((xFrom * txA21) + (yFrom * txA22)) + txA23;
	txTo = ((xTo * txA11) + (yTo * txA12)) + txA13;
	tyTo = ((xTo * txA21) + (yTo * txA22)) + txA23;
	dx = txTo - txFrom;
	dy = tyTo - tyFrom;
	
		dx = fabs(dx);
		dy = fabs(dy);
	hops = (((sqInt)((((dx < dy) ? dy : dx)) / hop))) + 1;
	spanLeft = ((spanLeft < (((txFrom < txTo) ? txFrom : txTo))) ? spanLeft : (((txFrom < txTo) ? txFrom : txTo)));
	spanRight = ((spanRight < (((txFrom < txTo) ? txTo : txFrom))) ? (((txFrom < txTo) ? txTo : txFrom)) : spanRight);
	spanTop = ((spanTop < (((tyFrom < tyTo) ? tyFrom : tyTo))) ? spanTop : (((tyFrom < tyTo) ? tyFrom : tyTo)));
	spanBottom = ((spanBottom < (((tyFrom < tyTo) ? tyTo : tyFrom))) ? (((tyFrom < tyTo) ? tyTo : tyFrom)) : spanBottom);
	t = 0.0;
	increment = 1.0 / hops;
	while (t < 1.0) {
		oneLessT = 1.0 - t;
		x = (oneLessT * txFrom) + (t * txTo);
		y = (oneLessT * tyFrom) + (t * tyTo);
		updateAlphasForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountAtXy(x, y);
		}
		updateContourForXy(x, y);
		t += increment;
	}
	updateAlphasForXy(txTo, tyTo);
	if (!(fillA == 0.0)) {
		updateEdgeCountAtXy(txTo, tyTo);
	}
	updateContourForXy(txTo, tyTo);
	return 0;
}

	/* VectorEnginePlugin>>#pvt_lineWPFromX:y:toX:y: */
static sqInt
pvt_lineWPFromXytoXy(float xFrom, float yFrom, float xTo, float yTo)
{
	float dx;
	float dy;
	int hops;
	float increment;
	float oneLessT;
	float t;
	float txFrom;
	float txTo;
	float tyFrom;
	float tyTo;
	float x;
	float y;

	txFrom = ((xFrom * txA11) + (yFrom * txA12)) + txA13;
	tyFrom = ((xFrom * txA21) + (yFrom * txA22)) + txA23;
	txTo = ((xTo * txA11) + (yTo * txA12)) + txA13;
	tyTo = ((xTo * txA21) + (yTo * txA22)) + txA23;
	dx = txTo - txFrom;
	dy = tyTo - tyFrom;
	
		dx = fabs(dx);
		dy = fabs(dy);
	hops = (((sqInt)((((dx < dy) ? dy : dx)) / hop))) + 1;
	spanLeft = ((spanLeft < (((txFrom < txTo) ? txFrom : txTo))) ? spanLeft : (((txFrom < txTo) ? txFrom : txTo)));
	spanRight = ((spanRight < (((txFrom < txTo) ? txTo : txFrom))) ? (((txFrom < txTo) ? txTo : txFrom)) : spanRight);
	spanTop = ((spanTop < (((tyFrom < tyTo) ? tyFrom : tyTo))) ? spanTop : (((tyFrom < tyTo) ? tyFrom : tyTo)));
	spanBottom = ((spanBottom < (((tyFrom < tyTo) ? tyTo : tyFrom))) ? (((tyFrom < tyTo) ? tyTo : tyFrom)) : spanBottom);
	t = 0.0;
	increment = 1.0 / hops;
	while (t < 1.0) {
		oneLessT = 1.0 - t;
		x = (oneLessT * txFrom) + (t * txTo);
		y = (oneLessT * tyFrom) + (t * tyTo);
		updateAlphasWPForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountWPAtXy(x, y);
		}
		updateContourForXy(x, y);
		t += increment;
	}
	updateAlphasWPForXy(txTo, tyTo);
	if (!(fillA == 0.0)) {
		updateEdgeCountWPAtXy(txTo, tyTo);
	}
	updateContourForXy(txTo, tyTo);
	return 0;
}

	/* VectorEnginePlugin>>#pvt_quadraticBezierFromX:y:toX:y:controlX:y: */
static sqInt
pvt_quadraticBezierFromXytoXycontrolXy(float xFrom, float yFrom, float xTo, float yTo, float xControl, float yControl)
{
	float correction;
	float dx;
	float dx2;
	float dy;
	float dy2;
	float f1;
	float f2;
	float f3;
	float increment;
	float length;
	float oneLessT;
	float t;
	float t0;
	float txControl;
	float txFrom;
	float txTo;
	float tyControl;
	float tyFrom;
	float tyTo;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;

	if ((xControl == xTo)
	 && (yControl == yTo)) {
		return pvt_lineFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	if ((xControl == xFrom)
	 && (yControl == yFrom)) {
		return pvt_lineFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	txFrom = ((xFrom * txA11) + (yFrom * txA12)) + txA13;
	tyFrom = ((xFrom * txA21) + (yFrom * txA22)) + txA23;
	txTo = ((xTo * txA11) + (yTo * txA12)) + txA13;
	tyTo = ((xTo * txA21) + (yTo * txA22)) + txA23;
	txControl = ((xControl * txA11) + (yControl * txA12)) + txA13;
	tyControl = ((xControl * txA21) + (yControl * txA22)) + txA23;
	
		dx = fabs(txTo-txFrom);
		dx2 = fabs(txControl-txFrom);
		dy = fabs(tyTo-tyFrom);
		dy2 = fabs(tyControl-tyFrom);
	if ((dx < 1.0)
	 && (dx2 < 1.0)) {
		return pvt_lineFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	if ((dy < 1.0)
	 && (dy2 < 1.0)) {
		return pvt_lineFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	xMinEnd = ((txFrom < txTo) ? txFrom : txTo);
	xMaxEnd = ((txFrom < txTo) ? txTo : txFrom);
	yMinEnd = ((tyFrom < tyTo) ? tyFrom : tyTo);
	yMaxEnd = ((tyFrom < tyTo) ? tyTo : tyFrom);
	spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + txControl) / 2.0)) ? xMinEnd : ((xMinEnd + txControl) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + txControl) / 2.0)) ? xMinEnd : ((xMinEnd + txControl) / 2.0))));
	spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + txControl) / 2.0)) ? ((xMaxEnd + txControl) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + txControl) / 2.0)) ? ((xMaxEnd + txControl) / 2.0) : xMaxEnd)) : spanRight);
	spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + tyControl) / 2.0)) ? yMinEnd : ((yMinEnd + tyControl) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + tyControl) / 2.0)) ? yMinEnd : ((yMinEnd + tyControl) / 2.0))));

	/* Case t = 0.0 */
	spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + tyControl) / 2.0)) ? ((yMaxEnd + tyControl) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + tyControl) / 2.0)) ? ((yMaxEnd + tyControl) / 2.0) : yMaxEnd)) : spanBottom);
	x = txFrom;
	y = tyFrom;
	updateAlphasForXy(x, y);
	if (!(fillA == 0.0)) {
		updateEdgeCountAtXy(x, y);
	}
	updateContourForXy(x, y);
	increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
	t = 0.0;
	while (1) {
		t0 = t;
		x0 = x;

		/* Compute next point */
		y0 = y;
		t = t0 + increment;
		oneLessT = 1.0 - t;
		f1 = oneLessT * oneLessT;
		f2 = (2.0 * oneLessT) * t;
		f3 = t * t;
		x = ((f1 * txFrom) + (f2 * txControl)) + (f3 * txTo);

		/* Now adjust the increment to aim at the required hop length, and recompute next point. */
		y = ((f1 * tyFrom) + (f2 * tyControl)) + (f3 * tyTo);
		dx = x - x0;
		dy = y - y0;
		
			length = sqrt(dx*dx + dy*dy);
		correction = hop / length;
		do {
			increment = (increment / length) * hop;
			t = t0 + increment;
			oneLessT = 1.0 - t;
			f1 = oneLessT * oneLessT;
			f2 = (2.0 * oneLessT) * t;
			f3 = t * t;
			x = ((f1 * txFrom) + (f2 * txControl)) + (f3 * txTo);
			y = ((f1 * tyFrom) + (f2 * tyControl)) + (f3 * tyTo);
			dx = x - x0;
			dy = y - y0;
			
				length = sqrt(dx*dx + dy*dy);
			correction = hop / length;
		} while(correction < 1.0);
		if (!(t < 1.0)) break;
		updateAlphasForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountAtXy(x, y);
		}
		updateContourForXy(x, y);
	}
	updateAlphasForXy(txTo, tyTo);
	if (!(fillA == 0.0)) {
		updateEdgeCountAtXy(txTo, tyTo);
	}
	updateContourForXy(txTo, tyTo);
	return 0;
}

	/* VectorEnginePlugin>>#pvt_quadraticBezierWPFromX:y:toX:y:controlX:y: */
static sqInt
pvt_quadraticBezierWPFromXytoXycontrolXy(float xFrom, float yFrom, float xTo, float yTo, float xControl, float yControl)
{
	float correction;
	float dx;
	float dx2;
	float dy;
	float dy2;
	float f1;
	float f2;
	float f3;
	float increment;
	float length;
	float oneLessT;
	float t;
	float t0;
	float txControl;
	float txFrom;
	float txTo;
	float tyControl;
	float tyFrom;
	float tyTo;
	float x;
	float x0;
	float xMaxEnd;
	float xMinEnd;
	float y;
	float y0;
	float yMaxEnd;
	float yMinEnd;

	if ((xControl == xTo)
	 && (yControl == yTo)) {
		return pvt_lineWPFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	if ((xControl == xFrom)
	 && (yControl == yFrom)) {
		return pvt_lineWPFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	txFrom = ((xFrom * txA11) + (yFrom * txA12)) + txA13;
	tyFrom = ((xFrom * txA21) + (yFrom * txA22)) + txA23;
	txTo = ((xTo * txA11) + (yTo * txA12)) + txA13;
	tyTo = ((xTo * txA21) + (yTo * txA22)) + txA23;
	txControl = ((xControl * txA11) + (yControl * txA12)) + txA13;
	tyControl = ((xControl * txA21) + (yControl * txA22)) + txA23;
	
		dx = fabs(txTo-txFrom);
		dx2 = fabs(txControl-txFrom);
		dy = fabs(tyTo-tyFrom);
		dy2 = fabs(tyControl-tyFrom);
	if ((dx < 1.0)
	 && (dx2 < 1.0)) {
		return pvt_lineWPFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	if ((dy < 1.0)
	 && (dy2 < 1.0)) {
		return pvt_lineWPFromXytoXy(xFrom, yFrom, xTo, yTo);
	}
	xMinEnd = ((txFrom < txTo) ? txFrom : txTo);
	xMaxEnd = ((txFrom < txTo) ? txTo : txFrom);
	yMinEnd = ((tyFrom < tyTo) ? tyFrom : tyTo);
	yMaxEnd = ((tyFrom < tyTo) ? tyTo : tyFrom);
	spanLeft = ((spanLeft < (((xMinEnd < ((xMinEnd + txControl) / 2.0)) ? xMinEnd : ((xMinEnd + txControl) / 2.0)))) ? spanLeft : (((xMinEnd < ((xMinEnd + txControl) / 2.0)) ? xMinEnd : ((xMinEnd + txControl) / 2.0))));
	spanRight = ((spanRight < (((xMaxEnd < ((xMaxEnd + txControl) / 2.0)) ? ((xMaxEnd + txControl) / 2.0) : xMaxEnd))) ? (((xMaxEnd < ((xMaxEnd + txControl) / 2.0)) ? ((xMaxEnd + txControl) / 2.0) : xMaxEnd)) : spanRight);
	spanTop = ((spanTop < (((yMinEnd < ((yMinEnd + tyControl) / 2.0)) ? yMinEnd : ((yMinEnd + tyControl) / 2.0)))) ? spanTop : (((yMinEnd < ((yMinEnd + tyControl) / 2.0)) ? yMinEnd : ((yMinEnd + tyControl) / 2.0))));

	/* Case t = 0.0 */
	spanBottom = ((spanBottom < (((yMaxEnd < ((yMaxEnd + tyControl) / 2.0)) ? ((yMaxEnd + tyControl) / 2.0) : yMaxEnd))) ? (((yMaxEnd < ((yMaxEnd + tyControl) / 2.0)) ? ((yMaxEnd + tyControl) / 2.0) : yMaxEnd)) : spanBottom);
	x = txFrom;
	y = tyFrom;
	updateAlphasWPForXy(x, y);
	if (!(fillA == 0.0)) {
		updateEdgeCountWPAtXy(x, y);
	}
	updateContourForXy(x, y);
	increment = (((0.5 / (((dx < dy) ? dy : dx))) < 0.5) ? (0.5 / (((dx < dy) ? dy : dx))) : 0.5);
	t = 0.0;
	while (1) {
		t0 = t;
		x0 = x;

		/* Compute next point */
		y0 = y;
		t = t0 + increment;
		oneLessT = 1.0 - t;
		f1 = oneLessT * oneLessT;
		f2 = (2.0 * oneLessT) * t;
		f3 = t * t;
		x = ((f1 * txFrom) + (f2 * txControl)) + (f3 * txTo);

		/* Now adjust the increment to aim at the required hop length, and recompute next point. */
		y = ((f1 * tyFrom) + (f2 * tyControl)) + (f3 * tyTo);
		dx = x - x0;
		dy = y - y0;
		
			length = sqrt(dx*dx + dy*dy);
		correction = hop / length;
		do {
			increment = (increment / length) * hop;
			t = t0 + increment;
			oneLessT = 1.0 - t;
			f1 = oneLessT * oneLessT;
			f2 = (2.0 * oneLessT) * t;
			f3 = t * t;
			x = ((f1 * txFrom) + (f2 * txControl)) + (f3 * txTo);
			y = ((f1 * tyFrom) + (f2 * tyControl)) + (f3 * tyTo);
			dx = x - x0;
			dy = y - y0;
			
				length = sqrt(dx*dx + dy*dy);
			correction = hop / length;
		} while(correction < 1.0);
		if (!(t < 1.0)) break;
		updateAlphasWPForXy(x, y);
		if (!(fillA == 0.0)) {
			updateEdgeCountWPAtXy(x, y);
		}
		updateContourForXy(x, y);
	}
	updateAlphasWPForXy(txTo, tyTo);
	if (!(fillA == 0.0)) {
		updateEdgeCountWPAtXy(txTo, tyTo);
	}
	updateContourForXy(txTo, tyTo);
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
	sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		failed = interpreterProxy->failed;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatObjectOf = interpreterProxy->floatObjectOf;
#if !defined(integerObjectOf)
		integerObjectOf = interpreterProxy->integerObjectOf;
#endif
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
#if VM_PROXY_MAJOR > 1 || (VM_PROXY_MAJOR == 1 && VM_PROXY_MINOR >= 15)
		isBooleanObject = interpreterProxy->isBooleanObject;
#else
#if !defined(isBooleanObject)
		isBooleanObject = 0;
#endif
#endif
		isBytes = interpreterProxy->isBytes;
		isFloatObject = interpreterProxy->isFloatObject;
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
		isWords = interpreterProxy->isWords;
		isWordsOrBytes = interpreterProxy->isWordsOrBytes;
		methodReturnValue = interpreterProxy->methodReturnValue;
		pop = interpreterProxy->pop;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		stackFloatValue = interpreterProxy->stackFloatValue;
		stackValue = interpreterProxy->stackValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

	/* VectorEnginePlugin>>#updateAlphasForX:y: */
static sqInt
updateAlphasForXy(float x, float y)
{
	uint32_t alphaWord;
	sqInt b;
	uint32_t blueAlpha;
	uint32_t candidateAlpha;
	sqInt displayX;
	sqInt displayY;
	float distanceToAxisSquared;
	sqInt doUpdate;
	float dx;
	float dxp;
	float dy;
	float dySquared;
	uint32_t greenAlpha;
	sqInt l;
	sqInt pixelIndex;
	sqInt r;
	uint32_t redAlpha;
	sqInt t;


	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
	t = ((sqInt)((y - auxStrokeWidthDilatedHalf) + 1));
	if (t < clipTop) {
		t = clipTop;
	}
	b = ((sqInt)(y + auxStrokeWidthDilatedHalf));
	if (b > clipBottom) {
		b = clipBottom;
	}

	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
	l = ((sqInt)(((x - auxStrokeWidthDilatedHalf) - subPixelDelta) + 1));
	if (l < clipLeft) {
		l = clipLeft;
	}
	r = ((sqInt)((x + auxStrokeWidthDilatedHalf) + subPixelDelta));
	if (r > clipRight) {
		r = clipRight;
	}
	for (displayY = t; displayY <= b; displayY += 1) {
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		dy = displayY - y;
		dySquared = dy * dy;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			alphaWord = alphaMask[pixelIndex];
			if (!(alphaWord == 0x7F7F7F)) {
				redAlpha = alphaWord & 0x7F0000;
				greenAlpha = alphaWord & 0x7F00;
				blueAlpha = alphaWord & 0x7F;
				doUpdate = 0;

				/* Red */
				dx = displayX - x;
				dxp = dx - subPixelDelta;
				distanceToAxisSquared = (dxp * dxp) + dySquared;
				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
						candidateAlpha = 0x7F0000;
					}
					else {
						
										candidateAlpha = (uint32_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
										candidateAlpha = candidateAlpha << 16;
					}
					if (candidateAlpha > redAlpha) {
						doUpdate = 1;
						redAlpha = candidateAlpha;
					}
				}
				distanceToAxisSquared = (dx * dx) + dySquared;
				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
						candidateAlpha = 0x7F00;
					}
					else {
						
										candidateAlpha = (uint32_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
										candidateAlpha = candidateAlpha << 8;
					}
					if (candidateAlpha > greenAlpha) {
						doUpdate = 1;
						greenAlpha = candidateAlpha;
					}
				}
				dxp = dx + subPixelDelta;
				distanceToAxisSquared = (dxp * dxp) + dySquared;
				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
						candidateAlpha = 0x7F;
					}
					else {
						
										candidateAlpha = (uint32_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
					}
					if (candidateAlpha > blueAlpha) {
						doUpdate = 1;
						blueAlpha = candidateAlpha;
					}
				}
				if (doUpdate) {
					alphaWord = (redAlpha | greenAlpha) | blueAlpha;
					alphaMask[pixelIndex] = alphaWord;
				}
			}
		}
	}
	return 0;
}

	/* VectorEnginePlugin>>#updateAlphasWPForX:y: */
static sqInt
updateAlphasWPForXy(float x, float y)
{
	uint8_t alphaByte;
	sqInt b;
	uint8_t candidateAlpha;
	sqInt displayX;
	sqInt displayY;
	float distanceToAxisSquared;
	float dx;
	float dxSquared;
	float dy;
	float dySquared;
	sqInt l;
	sqInt pixelIndex;
	sqInt r;
	sqInt t;


	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
	t = ((sqInt)((y - auxStrokeWidthDilatedHalf) + 1));
	if (t < clipTop) {
		t = clipTop;
	}
	b = ((sqInt)(y + auxStrokeWidthDilatedHalf));
	if (b > clipBottom) {
		b = clipBottom;
	}

	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
	l = ((sqInt)((x - auxStrokeWidthDilatedHalf) + 1));
	if (l < clipLeft) {
		l = clipLeft;
	}
	r = ((sqInt)(x + auxStrokeWidthDilatedHalf));
	if (r > clipRight) {
		r = clipRight;
	}
	for (displayY = t; displayY <= b; displayY += 1) {
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		dy = displayY - y;
		dySquared = dy * dy;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			alphaByte = alphaMaskWP[pixelIndex];
			if (!(alphaByte == 0x7F)) {
				dx = displayX - x;
				dxSquared = dx * dx;
				distanceToAxisSquared = dxSquared + dySquared;
				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
					if (distanceToAxisSquared <= auxStrokeWidthErodedHalfSquared) {
						candidateAlpha = 0x7F;
					}
					else {
						
										candidateAlpha = (uint8_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
					}
					if (candidateAlpha > alphaByte) {
						alphaMaskWP[pixelIndex] = candidateAlpha;
					}
				}
			}
		}
	}
	return 0;
}


/*	slight optimization possible when we know width = 0:
	- we know candidateAlpha is never 127
	- we know distanceToEdge is always > erodedHalfWidth. */

	/* VectorEnginePlugin>>#updateAlphasWPZeroStrokeForX:y: */
static sqInt
updateAlphasWPZeroStrokeForXy(float x, float y)
{
	uint8_t alphaByte;
	sqInt b;
	uint8_t candidateAlpha;
	sqInt displayX;
	sqInt displayY;
	float distanceToAxisSquared;
	float dx;
	float dy;
	float dySquared;
	sqInt l;
	sqInt pixelIndex;
	sqInt r;
	sqInt t;


	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
	t = ((sqInt)((y - auxStrokeWidthDilatedHalf) + 1));
	if (t < clipTop) {
		t = clipTop;
	}
	b = ((sqInt)(y + auxStrokeWidthDilatedHalf));
	if (b > clipBottom) {
		b = clipBottom;
	}

	/* (int(z+1)) works equally well than the more intuitive but slower (int(ceil(z)) */
	l = ((sqInt)((x - auxStrokeWidthDilatedHalf) + 1));
	if (l < clipLeft) {
		l = clipLeft;
	}
	r = ((sqInt)(x + auxStrokeWidthDilatedHalf));
	if (r > clipRight) {
		r = clipRight;
	}
	for (displayY = t; displayY <= b; displayY += 1) {
		pixelIndex = ((displayY * targetWidth) + l) - 1;
		dy = displayY - y;
		dySquared = dy * dy;
		for (displayX = l; displayX <= r; displayX += 1) {
			pixelIndex += 1;
			alphaByte = alphaMaskWP[pixelIndex];
			if (!(alphaByte == 0x7F)) {
				dx = displayX - x;
				distanceToAxisSquared = (dx * dx) + dySquared;
				if (distanceToAxisSquared < auxStrokeWidthDilatedHalfSquared) {
					
								candidateAlpha = (uint8_t)((auxStrokeWidthDilatedHalf - (sqrt(distanceToAxisSquared))) * auxAntiAliasingWidthScaledInverse);
					if (candidateAlpha > alphaByte) {
						alphaMaskWP[pixelIndex] = candidateAlpha;
					}
				}
			}
		}
	}
	return 0;
}


/*	The Contour of the current morph is the pixel area affected, but without
	holes. For each y line where a pixel is affected, record the leftmost and
	rightmost affected pixels.
	Note: Only includes pen trajectory, but not stroke width. */

	/* VectorEnginePlugin>>#updateContourForX:y: */
static sqInt
updateContourForXy(float x, float y)
{
	sqInt thisYRounded;

	thisYRounded = ((sqInt)(y + 0.5));
	if (((thisYRounded >= 0) && (thisYRounded <= (targetHeight - 1)))) {
		if (!(thisYRounded == prevYRounded)) {
			if (!(prevYRounded == 0x7FFFFFFF)) {
				contour[prevYRounded * 2] = leftAtThisY;
				contour[(prevYRounded * 2) + 1] = rightAtThisY;
			}
			leftAtThisY = contour[thisYRounded * 2];
			rightAtThisY = contour[(thisYRounded * 2) + 1];
			prevYRounded = thisYRounded;
		}
		leftAtThisY = ((leftAtThisY < x) ? leftAtThisY : x);
		rightAtThisY = ((rightAtThisY < x) ? x : rightAtThisY);
	}
	return 0;
}


/*	Compute edges intersecting with this horizontal line, for fills. */

	/* VectorEnginePlugin>>#updateEdgeCountAtX:y: */
static sqInt
updateEdgeCountAtXy(float x, float y)
{
	uint32_t blueCount;
	uint32_t blueIncrement;
	sqInt blueOffset;
	sqInt bluePixelIndex;
	uint32_t countWord;
	uint32_t greenCount;
	uint32_t greenIncrement;
	sqInt greenOffset;
	sqInt greenPixelIndex;
	sqInt pixelIndexBase;
	sqInt pixelY;
	uint32_t redCount;
	uint32_t redIncrement;
	sqInt redOffset;
	sqInt redPixelIndex;
	uint32_t rest;
	sqInt thisYTruncated;


	/* truncated, both in C and Smalltalk */
	thisYTruncated = ((sqInt)y);
	if (thisYTruncated == prevYTruncated) {
		return 0;
	}
	if (!(((thisYTruncated >= (clipTop - 1)) && (thisYTruncated <= clipBottom)))) {
		return 0;
	}
	if (prevYTruncated == 0x7FFFFFFF) {
		prevYTruncated = thisYTruncated;
		return 0;
	}
	if (thisYTruncated > prevYTruncated) {
		pixelY = thisYTruncated;
		redIncrement = 0x10000;
		greenIncrement = 0x100;
		blueIncrement = 1;
	}
	else {
		pixelY = prevYTruncated;
		redIncrement = 0xFF0000;
		greenIncrement = 0xFF00;
		blueIncrement = 0xFF;
	}

	/* All edge count at the left of the clipRect are added there (at the left of the clipRect).
	   The effect is the same, and we need to clean up less stuff afterwards.
	   More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses. */
	prevYTruncated = thisYTruncated;
	pixelIndexBase = pixelY * targetWidth;

	/* take the next red subpixel center to the right of x */
	redOffset = (((((sqInt)((x + subPixelDelta) + 1))) < clipLeft) ? clipLeft : (((sqInt)((x + subPixelDelta) + 1))));

	/* take the next green subpixel center to the right of x */
	greenOffset = (((((sqInt)(x + 1))) < clipLeft) ? clipLeft : (((sqInt)(x + 1))));

	/* take the next blue subpixel center to the right of x */
	blueOffset = (((((sqInt)((x - subPixelDelta) + 1))) < clipLeft) ? clipLeft : (((sqInt)((x - subPixelDelta) + 1))));
	redPixelIndex = pixelIndexBase + redOffset;
	greenPixelIndex = pixelIndexBase + greenOffset;

	/* Three possible cases here: RGB in one word (pixel); RG in one, and G in another; R in one, GB in another */
	bluePixelIndex = pixelIndexBase + blueOffset;
	if (redPixelIndex == bluePixelIndex) {

		/* First case: RGB in the same word */
		if (redOffset <= clipRight) {
			countWord = edgeCounts[redPixelIndex];
			redCount = (countWord + redIncrement) & 0xFF0000;
			greenCount = (countWord + greenIncrement) & 0xFF00;
			blueCount = (countWord + blueIncrement) & 0xFF;
			countWord = (redCount | greenCount) | blueCount;
			edgeCounts[redPixelIndex] = countWord;
		}
	}
	else {
		if (redPixelIndex == greenPixelIndex) {

			/* Second case: RG in one word, B in previous */
			if (redOffset <= clipRight) {
				countWord = edgeCounts[redPixelIndex];
				redCount = (countWord + redIncrement) & 0xFF0000;
				greenCount = (countWord + greenIncrement) & 0xFF00;
				rest = countWord & 0xFF;
				countWord = (redCount | greenCount) | rest;
				edgeCounts[redPixelIndex] = countWord;
			}
			if (blueOffset <= clipRight) {
				countWord = edgeCounts[bluePixelIndex];
				rest = countWord & 0xFFFF00;
				blueCount = (countWord + blueIncrement) & 0xFF;
				countWord = rest | blueCount;
				edgeCounts[bluePixelIndex] = countWord;
			}
		}
		else {

			/* Third case: R in one word, GB in the previous */
			if (redOffset <= clipRight) {
				countWord = edgeCounts[redPixelIndex];
				redCount = (countWord + redIncrement) & 0xFF0000;
				rest = countWord & 0xFFFF;
				countWord = redCount | rest;
				edgeCounts[redPixelIndex] = countWord;
			}
			if (blueOffset <= clipRight) {
				countWord = edgeCounts[bluePixelIndex];
				rest = countWord & 0xFF0000;
				greenCount = (countWord + greenIncrement) & 0xFF00;
				blueCount = (countWord + blueIncrement) & 0xFF;
				countWord = (rest | greenCount) | blueCount;
				edgeCounts[bluePixelIndex] = countWord;
			}
		}
	}
	return 0;
}


/*	Compute edges intersecting with this horizontal line, for fills. */

	/* VectorEnginePlugin>>#updateEdgeCountWPAtX:y: */
static sqInt
updateEdgeCountWPAtXy(float x, float y)
{
	uint8_t count;
	uint8_t increment;
	sqInt pixelIndex;
	sqInt pixelOffset;
	sqInt pixelY;
	sqInt thisYTruncated;


	/* truncated, both in C and Smalltalk */
	thisYTruncated = ((sqInt)y);
	if (thisYTruncated == prevYTruncated) {
		return 0;
	}
	if (!(((thisYTruncated >= (clipTop - 1)) && (thisYTruncated <= clipBottom)))) {
		return 0;
	}
	if (prevYTruncated == 0x7FFFFFFF) {
		prevYTruncated = thisYTruncated;
		return 0;
	}
	if (thisYTruncated > prevYTruncated) {
		pixelY = thisYTruncated;
		increment = 1;
	}
	else {
		pixelY = prevYTruncated;
		increment = 0xFF;
	}

	/* All edge count at the left of the clipRect are added there (at the left of the clipRect).
	   The effect is the same, and we need to clean up less stuff afterwards.
	   More important, it avoids trying to acess pixels outside our form, i.e. invalid array acesses. */
	prevYTruncated = thisYTruncated;

	/* take the next pixel center to the right of x */
	pixelOffset = (((((sqInt)(x + 1))) < clipLeft) ? clipLeft : (((sqInt)(x + 1))));
	if (pixelOffset <= clipRight) {
		pixelIndex = (pixelY * targetWidth) + pixelOffset;
		count = edgeCountsWP[pixelIndex];
		count += increment;
		edgeCountsWP[pixelIndex] = count;
	}
	return 0;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "VectorEnginePlugin";
void* VectorEnginePlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "pluginApiVersion\000\377\000", (void*)pluginApiVersion},
	{(void*)_m, "primAntiAliasingWidthsubPixelDeltaHopLength\000\000\000", (void*)primAntiAliasingWidthsubPixelDeltaHopLength},
	{(void*)_m, "primArc\000\000\000", (void*)primArc},
	{(void*)_m, "primArcWP\000\000\000", (void*)primArcWP},
	{(void*)_m, "primBlendFillOnly\000\000\000", (void*)primBlendFillOnly},
	{(void*)_m, "primBlendFillOnlyWPOT\000\000\000", (void*)primBlendFillOnlyWPOT},
	{(void*)_m, "primBlendStrokeAndFill\000\000\000", (void*)primBlendStrokeAndFill},
	{(void*)_m, "primBlendStrokeAndFillWPOT\000\000\000", (void*)primBlendStrokeAndFillWPOT},
	{(void*)_m, "primBlendStrokeOnly\000\000\000", (void*)primBlendStrokeOnly},
	{(void*)_m, "primBlendStrokeOnlyWPOT\000\000\000", (void*)primBlendStrokeOnlyWPOT},
	{(void*)_m, "primClipCurrentMorph\000\000\000", (void*)primClipCurrentMorph},
	{(void*)_m, "primClipLeftclipTopclipRightclipBottom\000\000\000", (void*)primClipLeftclipTopclipRightclipBottom},
	{(void*)_m, "primCubicBezier\000\000\000", (void*)primCubicBezier},
	{(void*)_m, "primCubicBezierWP\000\000\000", (void*)primCubicBezierWP},
	{(void*)_m, "primCurrentMorphIdcurrentClipsSubmorphs\000\000\000", (void*)primCurrentMorphIdcurrentClipsSubmorphs},
	{(void*)_m, "primDisplayString\000\000\000", (void*)primDisplayString},
	{(void*)_m, "primDisplayStringWP\000\000\000", (void*)primDisplayStringWP},
	{(void*)_m, "primDisplayUtf32\000\000\000", (void*)primDisplayUtf32},
	{(void*)_m, "primDisplayUtf32WP\000\000\000", (void*)primDisplayUtf32WP},
	{(void*)_m, "primDisplayUtf8\000\000\000", (void*)primDisplayUtf8},
	{(void*)_m, "primDisplayUtf8WP\000\000\000", (void*)primDisplayUtf8WP},
	{(void*)_m, "primFillRGBA\000\000\000", (void*)primFillRGBA},
	{(void*)_m, "primGeometryTxSet\000\000\000", (void*)primGeometryTxSet},
	{(void*)_m, "primInitializePath\000\377\000", (void*)primInitializePath},
	{(void*)_m, "primLine\000\000\000", (void*)primLine},
	{(void*)_m, "primLineWP\000\000\000", (void*)primLineWP},
	{(void*)_m, "primNewTrajectoryFragment\000\377\000", (void*)primNewTrajectoryFragment},
	{(void*)_m, "primPathSequence\000\000\000", (void*)primPathSequence},
	{(void*)_m, "primPathSequenceWP\000\000\000", (void*)primPathSequenceWP},
	{(void*)_m, "primQuadraticBezier\000\000\000", (void*)primQuadraticBezier},
	{(void*)_m, "primQuadraticBezierWP\000\000\000", (void*)primQuadraticBezierWP},
	{(void*)_m, "primReset2Contour\000\000\000", (void*)primReset2Contour},
	{(void*)_m, "primSetTarget\000\000\000", (void*)primSetTarget},
	{(void*)_m, "primSetTargetWP\000\000\000", (void*)primSetTargetWP},
	{(void*)_m, "primSpanBottom\000\377\000", (void*)primSpanBottom},
	{(void*)_m, "primSpanLeft\000\377\000", (void*)primSpanLeft},
	{(void*)_m, "primSpanRight\000\377\000", (void*)primSpanRight},
	{(void*)_m, "primSpanTop\000\377\000", (void*)primSpanTop},
	{(void*)_m, "primStrokeRGBA\000\000\000", (void*)primStrokeRGBA},
	{(void*)_m, "primStrokeWidth\000\000\000", (void*)primStrokeWidth},
	{(void*)_m, "primUpdate2ContourLastLine\000\000\000", (void*)primUpdate2ContourLastLine},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else // ifdef SQ_BUILTIN_PLUGIN

#if SPURVM
EXPORT(signed short) primAntiAliasingWidthsubPixelDeltaHopLengthMetadata = 0;
EXPORT(signed short) primArcMetadata = 0;
EXPORT(signed short) primArcWPMetadata = 0;
EXPORT(signed short) primBlendFillOnlyMetadata = 0;
EXPORT(signed short) primBlendFillOnlyWPOTMetadata = 0;
EXPORT(signed short) primBlendStrokeAndFillMetadata = 0;
EXPORT(signed short) primBlendStrokeAndFillWPOTMetadata = 0;
EXPORT(signed short) primBlendStrokeOnlyMetadata = 0;
EXPORT(signed short) primBlendStrokeOnlyWPOTMetadata = 0;
EXPORT(signed short) primClipCurrentMorphMetadata = 0;
EXPORT(signed short) primClipLeftclipTopclipRightclipBottomMetadata = 0;
EXPORT(signed short) primCubicBezierMetadata = 0;
EXPORT(signed short) primCubicBezierWPMetadata = 0;
EXPORT(signed short) primCurrentMorphIdcurrentClipsSubmorphsMetadata = 0;
EXPORT(signed short) primDisplayStringMetadata = 0;
EXPORT(signed short) primDisplayStringWPMetadata = 0;
EXPORT(signed short) primDisplayUtf32Metadata = 0;
EXPORT(signed short) primDisplayUtf32WPMetadata = 0;
EXPORT(signed short) primDisplayUtf8Metadata = 0;
EXPORT(signed short) primDisplayUtf8WPMetadata = 0;
EXPORT(signed short) primFillRGBAMetadata = 0;
EXPORT(signed short) primGeometryTxSetMetadata = 0;
EXPORT(signed short) primLineMetadata = 0;
EXPORT(signed short) primLineWPMetadata = 0;
EXPORT(signed short) primPathSequenceMetadata = 0;
EXPORT(signed short) primPathSequenceWPMetadata = 0;
EXPORT(signed short) primQuadraticBezierMetadata = 0;
EXPORT(signed short) primQuadraticBezierWPMetadata = 0;
EXPORT(signed short) primReset2ContourMetadata = 0;
EXPORT(signed short) primSetTargetMetadata = 0;
EXPORT(signed short) primSetTargetWPMetadata = 0;
EXPORT(signed short) primStrokeRGBAMetadata = 0;
EXPORT(signed short) primStrokeWidthMetadata = 0;
EXPORT(signed short) primUpdate2ContourLastLineMetadata = 0;
#endif // SPURVM

#endif // ifdef SQ_BUILTIN_PLUGIN
