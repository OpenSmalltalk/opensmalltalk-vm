/* This file has been post-processed for GNU C */


/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.3455 uuid: 3fb5350e-7e08-4a76-8b1b-7755e8e0811f
   from
	CoInterpreter VMMaker.oscog-eem.3455 uuid: 3fb5350e-7e08-4a76-8b1b-7755e8e0811f
 */
static char __buildInfo[] = "CoInterpreter VMMaker.oscog-eem.3455 uuid: 3fb5350e-7e08-4a76-8b1b-7755e8e0811f " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include "sqGnu.h"
#include <stdio.h> /* for printf */
#include <stdlib.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "sqImageFileAccess.h"
#include "sqSetjmpShim.h"
#include "dispdbg.h"
#include "sqCogStackAlignment.h"
#include "cogmethod.h"
#include "cointerp.h"
#include "cogit.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
EXPORT(void)
warning(const char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
EXPORT(void)
warningat(const char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

/* end StackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AlternateHeaderHasPrimFlag 0x80000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 245
#define BecameActiveClassFlag 8
#define BecameCompiledMethodFlag 2
#define BecameJittedCompiledMethodFlag 16
#define BecamePointerObjectFlag 1
#define CacheProbeMax 3
#define CharacterTable null
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBitmapCompactIndex 53
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassCharacter 19
#define ClassDoubleByteArray 31
#define ClassDoubleWordArray 33
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMessage 15
#define ClassMessageCompactIndex 35
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWordArray 32
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CMBlock 4
#define CMClosedPIC 2
#define CMMethod 5
#define CMMethodFlaggedForBecome 6
#define CMOpenPIC 3
#define ConstMinusOne 0xFFFFFFFFFFFFFFF9ULL
#define ConstOne 9
#define ConstTwo 17
#define ConstZero 1
#define CrossedX 258
#define CSEnterCriticalSection 5
#define CSExitCriticalSection 6
#define CSResume 7
#define CSSignal 8
#define CSSuspend 9
#define CSWait 10
#define CSYield 11
#define CtxtTempFrameStart 6
#define DisownVMForFFICall 16
#define DisownVMForThreading 32
#define DisownVMFromCallback 64
#define EncounteredUnknownBytecode -6
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalCallLiteralFlagsIndex 2
#define ExternalCallLiteralFunctionNameIndex 1
#define ExternalCallLiteralModuleNameIndex 0
#define ExternalCallLiteralTargetFunctionIndex 3
#define ExternalObjectsArray 38
#define ExtraRootsSize 64
#define FailImbalancedPrimitives 1
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerSavedIP 8
#define FoxIFReceiver -40
#define FoxIFrameFlags -24
#define FoxIFSavedIP -32
#define FoxMethod -8
#define FoxMFReceiver -24
#define FoxSavedFP 0
#define FoxThisContext -16
#define FullClosureCompiledBlockIndex 1
#define FullClosureFirstCopiedValueIndex 4
#define FullClosureReceiverIndex 3
#define GCCheckFreeSpace 32
#define GCCheckImageSegment 16
#define GCCheckPrimCall 128
#define GCCheckShorten 64
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define HasBeenReturnedFromMCPC -1
#define HasBeenReturnedFromMCPCOop 0xFFFFFFFFFFFFFFF9ULL
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#define IFrameSlots 7
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x100000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongStoreBytecode 129
#define MarkOnTenure 5
#define MarkStackRootIndex 0x1000
#define MaxExternalPrimitiveTableSize 4096
#define MaxLiteralCountForCompile 60
#define MaxNegativeErrorCode -8
#define MaxPrimitiveIndex 582
#define MaxQuickPrimitiveIndex 519
#define MaxRTRefCount 7
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 27
#define MethodHeaderFlagBitPosition 31
#define MethodHeaderTempCountShift 21
#define MethodIndex 3
#define MethodTooBig -4
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define MFMethodFlagsMask 0x7
#define MFMethodMask -0x8
#define MFrameSlots 5
#define MillisecondClockMask 0x1FFFFFFF
#define MinBackwardJumpCountForCompile 40
#define MournQueueRootIndex 4098
#define MultipleBytecodeSetsBitmask 0x200
#define MyListIndex 3
#define NextLinkIndex 0
#define NilObject 0
#define NotFullyInitialized -1
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define OldBecameNewFlag 4
#define PrimCallCollectsProfileSamples 16
#define PrimCallIsExternalCall 32
#define PrimCallNeedsNewMethod 4
#define PrimCallOnSmalltalkStack 1
#define PrimCallOnSmalltalkStackAlign2x 2
#define PrimitiveErrorTableIndex 51
#define PrimNumberDoExternalCall 218
#define PrimNumberDoPrimitive 118
#define PrimNumberExternalCall 117
#define PrimNumberFFICall 120
#define PrimNumberHandlerMarker 199
#define PrimNumberNoContextSwitchMarker 123
#define PrimNumberUnwindMarker 198
#define PrimNumberVMParameter 254
#define PrimTraceLogSize 256
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetRootIndex 4099
#define ReturnToInterpreter 1
#define ScavengeInProgress 1
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorAttemptToAssign 50
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define ShouldNotJIT -8
#define SlidingCompactionInProgress 2
#define SmallContextSlots 22
#define SpecialSelectors 23
#define SpurPrimitiveAccessorDepthShift 8
#define SpurPrimitiveFlagsMask 0xFF
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TenureByAge 1
#define TenureByClass 2
#define TenureToShrinkRT 3
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TopHashBit 0x200000
#define TopOopBit 0x8000000000000000ULL
#define TraceBlockActivation 17
#define TraceBlockCreation 25
#define TraceBufferSize 768
#define TraceCodeCompaction 49
#define TraceContextSwitch 9
#define TraceFullGC 41
#define TraceIncrementalGC 33
#define TraceIsFromInterpreter 2
#define TraceIsFromMachineCode 1
#define TracePrimitiveFailure 113
#define TracePrimitiveRetry 121
#define TraceStackOverflow 105
#define TrueObject 2
#define ValidatedClassDoubleByteArrayFlag 1
#define ValidatedClassDoubleWordArrayFlag 4
#define ValidatedClassWordArrayFlag 2
#define ValueIndex 1
#define WeaklingStackRootIndex 0x1001
#define XIndex 0
#define YIndex 1

typedef struct {
	usqInt	sEdenBytes;
	usqInt	sPastBytes;
	usqInt	sRememberedSetSize;
	usqInt	sRememberedSetRedZone;
	usqInt	sRememberedSetLimit;
	usqInt	sStatTenures;
	usqInt	tTenureCriterion;
	usqInt	tTenureThreshold;
	usqInt	tRefCountToShrinkRT;
	usqInt	eSurvivorBytes;
	usqInt	eRememberedSetSize;
	usqInt	eStatTenures;
 } SpurScavengeLogRecord;


typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
	usqInt	savedSegSize;
	usqInt	lastFreeObject;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	int	padToWord;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static NoDbgRegParms CogMethod * cmHomeMethod(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMBlock(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMClosedPIC(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMMethodEtAl(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMMethodFlaggedForBecome(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMOpenPIC(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms sqInt addressIsInPage(StackPage *self_in_CogStackPage, char *address);
static NoDbgRegParms int isFree(StackPage *self_in_CogStackPage);
static NoDbgRegParms sqInt freeStackPageNoAssert(StackPage *aPage);
static NoDbgRegParms void freeStackPage(StackPage *aPage);
static NoDbgRegParms sqInt markStackPageMostRecentlyUsed(StackPage *page);
static NoDbgRegParms sqInt markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static NoDbgRegParms StackPage * stackPageAt(sqInt index);
static NoDbgRegParms StackPage * stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
extern sqInt accessorDepthForPrimitiveIndex(sqInt primIndex);
static NoDbgRegParms void activateNewCogMethodinInterpreter(CogMethod *cogMethod, sqInt inInterpreter);
static void activateNewMethod(void);
static NoDbgRegParms void addNewMethodToCache(sqInt classObj);
extern usqInt argumentCountAddress(void);
static NoDbgRegParms CogMethod * asCogHomeMethod(CogBlockMethod *aCogMethod);
static NoDbgRegParms void assertValidExecutionPointersimbarline(usqInt lip, char *lifp, char *lisp, sqInt inInterpreter, sqInt ln);
static NoDbgRegParms sqInt assertValidStackedInstructionPointersInline(StackPage *aStackPage, sqInt ln);
static NoDbgRegParms void assertValidStackedInstructionPointers(sqInt ln);
static NoDbgRegParms void attemptToSwitchToMachineCode(sqInt bcpc);
static NoDbgRegParms void backupContexttoBlockingSendTo(sqInt suspendedContext, sqInt conditionVariable);
extern void callForCogCompiledCodeCompaction(void);
static NoDbgRegParms void callRegisterArgCogMethodatreceiver(CogMethod *cogMethod, sqInt entryOffset, sqInt rcvr);
extern void ceActivateFailingPrimitiveMethod(sqInt aPrimitiveMethod);
extern sqInt ceBaseFrameReturn(sqInt returnValue);
#if IMMUTABILITY
extern sqInt ceCannotAssignTowithIndexvalueToAssign(sqInt immutableObject, sqInt index, sqInt valueToAssign);
#endif /* IMMUTABILITY */
extern sqInt ceCannotResume(void);
extern void ceCheckAndMaybeRetryPrimitive(sqInt primIndex);
extern void ceCheckForInterrupt(void);
extern sqInt ceContextinstVar(sqInt maybeContext, sqInt slotIndex);
extern sqInt ceContextinstVarvalue(sqInt maybeMarriedContext, sqInt slotIndex, sqInt anOop);
extern sqInt ceInterpretMethodFromPICreceiver(sqInt aMethodObj, sqInt rcvr);
extern sqInt ceMNUFromPICMNUMethodreceiver(sqInt aMethodObj, sqInt rcvr);
extern sqInt ceNewHashOf(sqInt anObject);
extern sqInt ceNonLocalReturn(sqInt returnValue);
extern void ceReapAndResetErrorCodeFor(CogMethod *cogMethod);
static NoDbgRegParms sqInt ceSendAborttonumArgs(sqInt selector, sqInt rcvr, sqInt numArgs);
extern sqInt ceSendFromInLineCacheMiss(CogMethod *cogMethodOrPIC);
extern sqInt ceSendMustBeBooleanTointerpretingAtDelta(sqInt aNonBooleanObject, sqInt jumpSize);
extern sqInt ceSendMustBeBoolean(sqInt anObject);
extern void ceSendaboveClassBindingtonumArgs(sqInt selector, sqInt methodClassBinding, sqInt rcvr, sqInt numArgs);
extern sqInt ceSendabovetonumArgs(sqInt selector, sqInt methodClass, sqInt rcvr, sqInt numArgs);
extern sqInt ceSendsupertonumArgs(sqInt selector, sqInt superNormalBar, sqInt rcvr, sqInt numArgs);
extern void ceStackOverflow(sqInt contextSwitchIfNotNil);
extern void ceTakeProfileSample(CogMethod *aCogMethodOrNil);
extern void ceTraceBlockActivation(void);
extern void ceTraceLinkedSend(sqInt theReceiver);
extern void ceTraceStoreOfinto(sqInt aValue, sqInt anObject);
extern usqInt cFramePointerAddress(void);
extern void checkAssertsEnabledInCoInterpreter(void);
static NoDbgRegParms sqInt checkCodeIntegrity(sqInt gcModes);
extern sqInt checkForAndFollowForwardedPrimitiveState(void);
extern sqInt checkIfCFramePointerInUse(void);
#if LRPCheck
extern int checkingLongRunningPrimitives(void);
#endif /* LRPCheck */
static sqInt checkLogIntegrity(void);
static NoDbgRegParms sqInt checkOkayFields(sqInt oop);
static sqInt checkStackIntegrity(void);
extern void clearTraceLog(void);
extern int cogMethodHasTooManyLiterals(CogMethod *aCogMethod);
extern CogMethod * cogMethodOf(sqInt aMethodOop);
static void commenceCogCompiledCodeCompaction(void);
extern void compilationBreakpointFor(sqInt selectorOop);
static NoDbgRegParms sqInt contextInstructionPointerframe(sqInt theIP, char *theFP);
static NoDbgRegParms void convertFrametoInterpreterFrame(char *theFP, sqInt pcDelta);
extern usqInt cReturnAddressAddress(void);
extern usqInt cStackPointerAddress(void);
extern sqInt defaultNativeStackFrameSize(void);
static NoDbgRegParms sqInt deferStackLimitSmashAroundwith(void (*functionSymbol)(sqInt), sqInt arg);
static NoDbgRegParms sqInt divorceAFrameIfin(sqInt (*criterion)(char *fp), StackPage *aStackPage);
static NoDbgRegParms sqInt divorceAllFramesSuchThat(sqInt (*criterion)(char *fp));
static NoDbgRegParms sqInt divorceAMachineCodeFrameWithCogMethodin(CogMethod *cogMethod, StackPage *aStackPage);
static NoDbgRegParms void ensureAllContextsHaveBytecodePCsIf(sqInt (*criterion)(sqInt methodOop));
static NoDbgRegParms void ensureContextHasBytecodePC(sqInt aContext);
static NoDbgRegParms void ensureContextIsExecutionSafeAfterAssignToStackPointer(sqInt aContext);
static sqInt enterSmalltalkExecutiveImplementation(void);
extern void executeCogMethodfromLinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr);
static NoDbgRegParms void executeCogMethodfromUnlinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr);
extern void executeCogPICfromLinkedSendWithReceiverandCacheTag(CogMethod *cogPIC, sqInt rcvr, sqInt cacheTag);
static sqInt executeNewMethod(void);
static sqInt executeNewMethodJitting(void);
static NoDbgRegParms sqInt externalInstVarofContext(sqInt offset, sqInt aContext);
static NoDbgRegParms void findNewMethodInClassTag(sqInt classTagArg);
static void flushExternalPrimitives(void);
static NoDbgRegParms void flushMethodsWithMachineCodePrimitivesAndContinueAnswering(sqInt result);
static void followForwardedFieldsInCurrentMethod(void);
static void followForwardingPointersOfReceiverAndTemporariesInStackZone(void);
static void followForwardingPointersOfReceiversInStackZone(void);
extern void forceInterruptCheckFromHeartbeat(void);
static NoDbgRegParms sqInt frameCallerContext(char *theFP);
static NoDbgRegParms int frameHasContext(char *theFP);
static NoDbgRegParms int frameIsBlockActivation(char *theFP);
static NoDbgRegParms sqInt frameMethodObject(char *theFP);
static NoDbgRegParms sqInt frameNumArgs(char *theFP);
extern usqInt framePointerAddress(void);
static NoDbgRegParms sqInt frameReceiver(char *theFP);
extern void (*functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(sqInt methodObj, sqInt primitiveIndex, sqInt *flagsPtr))(void);
extern sqInt getCurrentBytecode(void);
static sqInt getImageHeaderFlags(void);
static NoDbgRegParms sqInt handleForwardedSendFaultForReceiverstackDelta(sqInt forwardedReceiver, sqInt stackDelta);
static NoDbgRegParms sqInt handleMNUInMachineCodeToclassForMessage(sqInt selectorIndex, sqInt rcvr, sqInt classForMessage);
static NoDbgRegParms int iframeIsBlockActivation(char *theFP);
static NoDbgRegParms sqInt iframeReceiver(char *theFP);
static NoDbgRegParms usqInt iframeSavedIP(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
extern usqInt instructionPointerAddress(void);
static NoDbgRegParms sqInt instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
static NeverInline sqInt interpreterAllocationReserveBytes(void);
static sqInt interpretMethodFromMachineCode(void);
extern int isCogMethodReference(sqInt methodHeader);
static NoDbgRegParms sqInt isExternalMethodInPlugin(sqInt methodObj);
extern sqInt isFullBlockMethod(sqInt aMethodObj);
static NoDbgRegParms sqInt isMachineCodeFrameForCogMethodFlaggedForBecome(char *theFP);
static NoDbgRegParms sqInt isMachineCodeFrameForCogMethodWithMachineCodePrim(char *theFP);
static NoDbgRegParms sqInt isMachineCodeFrameForCogMethodWithTooManyLiterals(char *theFP);
static NoDbgRegParms sqInt isMachineCodeFrameForExternalPrimitiveMethod(char *theFP);
static NoDbgRegParms int isMachineCodeFrame(char *theFP);
#if LRPCheck
extern usqInt longRunningPrimitiveStopUsecsAddress(void);
#endif /* LRPCheck */
extern sqInt lookupMNUreceiver(sqInt selector, sqInt rcvr);
extern sqInt lookupOrdinaryreceiver(sqInt selector, sqInt rcvr);
static NoDbgRegParms StackPage * makeBaseFrameFor(sqInt aContext);
static NeverInline void mapStackPages(void);
static void mapTraceLog(void);
extern void markActiveMethodsAndReferents(void);
static NoDbgRegParms void markAndTraceStackPage(StackPage *thePage);
static void markAndTraceTraceLog(void);
static NoDbgRegParms void markCogMethodsAndReferentsOnPage(StackPage *thePage);
extern sqInt marryFrameCopiesTemps(void);
extern sqInt maxLookupNoMNUErrorCode(void);
static NoDbgRegParms void maybeFlagMethodAsInterpreted(sqInt aMethod);
extern usqInt methodCacheAddress(void);
extern int methodHasCogMethod(sqInt aMethodOop);
static NoDbgRegParms sqInt methodHasMachineCodePrimitiveMethod(sqInt methodObj);
static NoDbgRegParms NeverInline sqInt methodHasPrimitiveInPrimTracePlugin(sqInt aMethodObj);
static NoDbgRegParms int methodHasTooManyLiterals(sqInt methodObj);
extern int methodNeedsLargeContext(sqInt methodObj);
extern sqInt methodShouldBeCogged(sqInt aMethodObj);
static NoDbgRegParms int methodWithHeaderShouldBeCogged(sqInt methodHeader);
static NoDbgRegParms CogBlockMethod * mframeCogMethod(char *theFP);
extern CogMethod * mframeHomeMethodExport(void);
static NoDbgRegParms CogMethod * mframeHomeMethod(char *theFP);
static NoDbgRegParms int mframeIsBlockActivation(char *theFP);
static NoDbgRegParms sqInt mframeReceiver(char *theFP);
static NeverInline int minimumUnusedHeadroom(void);
static NoDbgRegParms sqInt mnuMethodOrNilFor(sqInt rcvr);
static NoDbgRegParms char * moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static NoDbgRegParms sqInt mustMapMachineCodePCcontext(sqInt theIP, sqInt aOnceMarriedContext);
extern usqInt newMethodAddress(void);
extern usqInt nextProfileTickAddress(void);
extern sqInt noAssertHeaderOf(sqInt methodPointer);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern unsigned int positive32BitValueOf(sqInt oop);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
extern usqLong positive64BitValueOf(sqInt oop);
static NoDbgRegParms void postGCAction(sqInt gcModeArg);
static NoDbgRegParms void preGCAction(sqInt gcModeArg);
extern usqInt primFailCodeAddress(void);
static NoDbgRegParms void primitiveBecomeReturn(sqInt ec);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
extern int primitivePropertyFlagsnumArgs(sqInt primIndex, sqInt numArgs);
extern void * primTraceLogAddress(void);
extern usqInt primTraceLogIndexAddress(void);
extern void printCogMethod(CogMethod *cogMethod);
static NoDbgRegParms void printFrameFlagsForFP(char *theFP);
static NoDbgRegParms void printFrameMethodFor(char *theFP);
static NoDbgRegParms void printFrameThingatextra(char *name, char *address, sqInt extraValue);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
extern void printMethodCacheFor(sqInt thing);
extern sqInt quickPrimitiveConstantFor(sqInt aQuickPrimitiveIndex);
extern sqInt (*quickPrimitiveGeneratorFor(sqInt aQuickPrimitiveIndex))(void);
extern sqInt quickPrimitiveInstVarIndexFor(sqInt primIndex);
extern sqInt rawHeaderOf(sqInt methodPointer);
extern void rawHeaderOfput(sqInt methodOop, sqInt cogMethodOrMethodHeader);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
extern sqInt recordFastCCallPrimTraceForMethod(sqInt aMethodObj);
extern sqInt recordPrimTraceForMethod(sqInt aMethodObj);
static NeverInline void reloadPrimitiveCalloutPointer(void);
extern void reportMinimumUnusedHeadroom(void);
extern void reportMinimumUnusedHeadroomOn(FILE *aStdioStream);
static NoDbgRegParms sqInt resumepreemptedYieldingIffrom(sqInt aProcess, sqInt yieldImplicitly, sqInt sourceCode);
static NoDbgRegParms sqInt returnToExecutivepostContextSwitch(sqInt inInterpreter, sqInt switchedContext);
static NoDbgRegParms sqInt returntoExecutive(sqInt returnValue, sqInt inInterpreter);
extern sqInt sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
static NoDbgRegParms sqInt shortPrintFrame(char *theFP);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern int signed32BitValueOf(sqInt oop);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqInt specialSelectorNumArgs(sqInt index);
extern usqInt stackLimitAddress(void);
static sqInt stackLimitOffset(void);
static sqInt stackPageHeadroom(void);
extern usqInt stackPointerAddress(void);
extern sqInt startPCOfMethodHeader(sqInt aCompiledMethodHeader);
extern sqInt startPCOrNilOfLiteralin(sqInt lit, sqInt aMethodObj);
static NoDbgRegParms sqInt synchronousSignal(sqInt aSemaphore);
static NoDbgRegParms void tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(sqInt contextToReturnFrom, sqInt contextToReturnTo, sqInt returnValue);
static NoDbgRegParms sqInt temporaryin(sqInt offset, char *theFP);
static NoDbgRegParms sqInt temporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static NoDbgRegParms void transferTofrom(sqInt newProc, sqInt sourceCode);
extern void updateStackZoneReferencesToCompiledCodePreCompaction(void);
static NoDbgRegParms void updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
extern sqInt validInstructionPointerinMethodframePointer(usqInt instrPointer, usqInt aMethod, char *fp);
static NoDbgRegParms sqInt validStackPageBaseFrame(StackPage *aPage);
static NoDbgRegParms sqInt voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
extern char * whereIs(sqInt anOop);
static NoDbgRegParms NeverInline void widowOrForceToBytecodePC(sqInt ctxt);
static NoDbgRegParms int frameIsMarked(sqInt theFPInt);
#if VMBenchmarks
EXPORT(void) primitiveBenchmarkFollowForwardersInStackZone(void);
#endif /* VMBenchmarks */
#if VMBenchmarks
EXPORT(void) primitiveBenchmarkFollowForwardersOfReceiverAndTemporariesInStackZone(void);
#endif /* VMBenchmarks */
#if VMBenchmarks
EXPORT(sqInt) primitiveBenchmarkJITReceiver(void);
#endif /* VMBenchmarks */
#if VMBenchmarks
EXPORT(void) primitiveBenchmarkScavenge(void);
#endif /* VMBenchmarks */
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveCollectCogCodeConstituents(void);
static void primitiveContextXray(void);
static void primitiveEnterCriticalSection(void);
static void primitiveExitCriticalSection(void);
EXPORT(void) primitiveExternalCallNoOp(void);
EXPORT(void) primitiveFastCNoOp(void);
EXPORT(void) primitiveFastCNoOpAlignedForFloats(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
extern usqInt primitiveFunctionPointerAddress(void);
#if LRPCheck
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
#endif /* LRPCheck */
EXPORT(sqInt) primitiveMethodPCData(void);
static void primitiveMethodXray(void);
EXPORT(void) primitiveMinimumUnusedHeadroom(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
static void primitiveResume(void);
static void primitiveSignal(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSuspend(void);
static void primitiveSuspendBackingUpV1(void);
EXPORT(void) primitiveSuspendBackingUpV2(void);
static void primitiveTerminateTo(void);
static void primitiveUnloadModule(void);
static void primitiveVoidVMState(void);
static void primitiveVoidVMStateForMethod(void);
static void primitiveWait(void);
static void primitiveYield(void);
static void unmarkAllFrames(void);
static NoDbgRegParms void initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static NoDbgRegParms sqInt pageIndexFor(void *pointer);
#if IMMUTABILITY
static NoDbgRegParms sqInt canBeImmutable(sqInt oop);
#endif /* IMMUTABILITY */
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
extern sqInt identityHashOf(sqInt anOop);
static NoDbgRegParms sqInt isNegativeIntegerValueOf(sqInt oop);
extern sqInt isPositiveMachineIntegerObject(sqInt oop);
static NoDbgRegParms sqInt magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static NoDbgRegParms usqLong magnitude64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHashArg(void);
static void primitiveArrayBecomeOneWayNoCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
EXPORT(sqInt) primitiveBytecodeSetsAvailable(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
static void primitiveCoarseLocalMicrosecondClock(void);
static void primitiveCoarseUTCMicrosecondClock(void);
EXPORT(sqInt) primitiveCompareBytes(void);
EXPORT(void) primitiveCompareWith(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
static void primitiveCosine(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc);
extern sqInt primitiveFailForOSError(sqLong osErrorCode);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailForwithSecondary(sqInt reasonCode, sqLong extraErrorCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFetchNextMourner(void);
static void primitiveFloatAdd(void);
static void primitiveFloatArrayAt(void);
static void primitiveFloatArrayAtPut(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveFullClosureValue(void);
extern void primitiveFullClosureValueNoContextSwitch(void);
static void primitiveFullClosureValueWithArgs(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetenv(void);
#if IMMUTABILITY
static void primitiveGetImmutability(void);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveGrowMemoryByAtLeast(void);
static void primitiveHashMultiply(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
static void primitiveHighBit(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveImmediateAsInteger(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
static void primitiveIsPinned(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
EXPORT(sqInt) primitiveMultipleBytecodeSetsActive(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectsAccessibleFromRoots(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
static void primitivePinnedNew(void);
static void primitivePinnedNewWithArg(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
EXPORT(sqInt) primitiveScreenScaleFactor(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
#if IMMUTABILITY
static void primitiveSetImmutability(void);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSizeInBytes(void);
static void primitiveSizeInBytesOfInstance(void);
static void primitiveSmallFloatAdd(void);
static void primitiveSmallFloatArctan(void);
static void primitiveSmallFloatCosine(void);
static void primitiveSmallFloatDivide(void);
static void primitiveSmallFloatEqual(void);
static void primitiveSmallFloatExp(void);
static void primitiveSmallFloatExponent(void);
static void primitiveSmallFloatFractionalPart(void);
static void primitiveSmallFloatGreaterOrEqual(void);
static void primitiveSmallFloatGreaterThan(void);
static void primitiveSmallFloatLessOrEqual(void);
static void primitiveSmallFloatLessThan(void);
static void primitiveSmallFloatLogN(void);
static void primitiveSmallFloatMultiply(void);
static void primitiveSmallFloatNotEqual(void);
static void primitiveSmallFloatSine(void);
static void primitiveSmallFloatSquareRoot(void);
static void primitiveSmallFloatSubtract(void);
static void primitiveSmallFloatTimesTwoPower(void);
static void primitiveSmallFloatTruncated(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
#if TestingPrimitives
EXPORT(sqInt) primitiveTestShortenIndexableSize(void);
#endif /* TestingPrimitives */
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUninitializedNewWithArg(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveUtcAndTimezoneOffset(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
extern int signalNoResume(sqInt aSemaphore);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static NoDbgRegParms int becomeEffectFlagsFor(sqInt objOop);
extern void ceScheduleScavenge(void);
extern sqInt classSmallFloat(void);
static void clearLeakMapAndMapAccessibleObjects(void);
extern void ensureNoForwardedLiteralsIn(sqInt aMethodObj);
static NoDbgRegParms sqInt followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth);
extern usqInt freeStartAddress(void);
extern usqInt getScavengeThreshold(void);
static NoDbgRegParms sqLong headerWhileForwardingOf(sqInt aCompiledMethodObjOop);
extern sqInt isForwardedClassIndex(sqInt maybeClassIndex);
extern int isImmediateClass(sqInt classObj);
extern sqInt isReallyYoungObject(sqInt objOop);
extern sqInt methodHeaderOf(sqInt methodObj);
extern usqInt needGCFlagAddress(void);
extern sqLong nullHeaderForMachineCodeMethod(void);
extern usqInt scavengeThresholdAddress(void);
extern usqInt specialObjectsOopAddress(void);
extern sqInt withoutForwardingOnandwithsendToCogit(sqInt obj1, sqInt obj2, sqInt aBool, sqInt (*selector)(sqInt,sqInt,sqInt));
static NoDbgRegParms usqInt addressAfter(sqInt objOop);
static NoDbgRegParms sqInt allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
static NoDbgRegParms sqInt allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
extern sqInt byteSwapped(sqInt w);
static NoDbgRegParms usqInt bytesInBody(sqInt objOop);
static int defaultEdenBytes(void);
extern sqInt fetchClassTagOf(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
static NoDbgRegParms sqLong floatValueBitsOf(sqInt floatOop);
extern double floatValueOf(sqInt oop);
static NoDbgRegParms void hackSlimBridgeToat(sqInt objOop, sqInt startAddress);
extern int headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
static NoDbgRegParms sqInt initFreeChunkWithBytesat(usqLong numBytes, sqInt address);
static NoDbgRegParms void initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address);
extern sqInt instantiateClassindexableSize(sqInt classObj, usqInt nElements);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt oop);
static NoDbgRegParms int isFloatInstance(sqInt oop);
static NoDbgRegParms int isImmediateFloat(sqInt oop);
extern int isIntegerObject(sqInt oop);
extern int isIntegerValue(sqInt intValue);
static NoDbgRegParms int isLilliputianSize(sqInt chunkBytes);
extern int isMarked(sqInt objOop);
static NoDbgRegParms int isSmallFloatValueBits(usqLong rawFloatBits);
static NoDbgRegParms int isSmallFloatValue(double aFloat);
static NoDbgRegParms int isWordsNonImm(sqInt objOop);
static NoDbgRegParms double loadFloatOrIntFrom(sqInt floatOrIntOop);
static sqInt maxSlotsForAlloc(void);
extern double noFailFloatValueOf(sqInt aFloatOop);
static sqInt numFreeLists(void);
static NoDbgRegParms sqInt objectAfterMaybeSlimBridgelimit(sqInt objOop, sqInt limit);
static NoDbgRegParms double smallFloatValueOf(sqInt oop);
extern usqInt smallObjectBytesForSlots(sqInt numSlots);
static sqInt wordIndexableFormat(void);
static sqInt wordSizeClassIndexPun(void);
static NoDbgRegParms NeverInline void addToEphemeronList(sqInt ephemeronCorpse);
static NoDbgRegParms NeverInline void addToWeakList(sqInt weakCorpse);
static sqInt allNewSpaceObjectsHaveZeroRTRefCount(void);
static sqInt allWeakSurvivorsOnWeakList(void);
static NeverInline void computeRefCountToShrinkRT(void);
static NoDbgRegParms sqInt copyAndForwardMourner(sqInt mourner);
static NoDbgRegParms sqInt copyAndForward(sqInt survivor);
static NoDbgRegParms NeverInline sqInt copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor);
static NoDbgRegParms usqInt firstCorpse(sqInt headOfCorpseList);
static void growRememberedSet(void);
static NoDbgRegParms sqInt isInRememberedSet(sqInt objOop);
static NoDbgRegParms sqInt isMaybeOldScavengeSurvivor(sqInt oop);
static NoDbgRegParms sqInt isScavengeSurvivor(sqInt oop);
static NoDbgRegParms sqInt isonWeaklingList(sqInt oop, sqInt listHead);
static usqInt newSpaceCapacity(void);
static sqInt noUnfiredEphemeronsAtEndOfRememberedSet(void);
extern void openScavengeLog(void);
extern void printRememberedSet(void);
static void processEphemerons(void);
static void processWeaklings(void);
static NoDbgRegParms sqInt processWeakSurvivor(sqInt weakObj);
extern sqInt remember(sqInt objOop);
static NoDbgRegParms void scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress);
static void scavengeLoop(void);
static NoDbgRegParms sqInt scavengeReferentsOf(sqInt referrer);
static NoDbgRegParms void scavengeRememberedSetStartingAt(sqInt n);
static float scavengerTenuringThreshold(void);
static sqInt scavengeUnfiredEphemeronsOnEphemeronList(void);
static NeverInline void writeScavengeLog(void);
static NoDbgRegParms sqInt accessibleObjectAfter(sqInt objOop);
static NoDbgRegParms NeverInline sqInt activeAndDeferredScan(sqInt anEphemeron);
static NoDbgRegParms void addFreeSubTree(sqInt freeTree);
extern sqInt addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeObj(sqInt address);
extern sqInt addressCouldBeOop(sqInt address);
static NoDbgRegParms sqInt addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes);
static NoDbgRegParms sqInt allInstancesOf(sqInt aClass);
static sqInt allObjects(void);
static sqInt allObjectsUnmarked(void);
static sqInt allOldMarkedWeakObjectsOnWeaklingStack(void);
static sqInt allocateLargestFreeChunk(void);
static NoDbgRegParms usqInt allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static NoDbgRegParms sqInt allocateOldSpaceChunkOfBytes(usqInt chunkBytes);
extern sqInt allocatePinnedSlots(sqInt nSlots);
static sqInt allocationUnit(void);
static NoDbgRegParms sqInt allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling);
static sqInt allUnscannedEphemeronsAreActive(void);
static NoDbgRegParms NeverInline sqInt assertInnerValidFreeObject(sqInt objOop);
extern sqInt becomewith(sqInt array1, sqInt array2);
static NoDbgRegParms sqInt becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern void beRootIfOld(sqInt oop);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(void);
static sqInt bridgeSize(void);
static NoDbgRegParms sqInt byteFormatForNumBytes(sqInt numBytes);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern unsigned char bytesPerElement(sqInt oop);
static NoDbgRegParms sqInt changeClassOfto(sqInt rcvr, sqInt argClass);
extern sqInt characterObjectOf(sqInt characterCode);
extern usqInt characterValueOf(sqInt oop);
static NoDbgRegParms sqInt cheapAddressCouldBeInHeap(sqInt address);
extern sqInt checkedLongAt(sqInt byteAddress);
static sqInt checkHeapFreeSpaceIntegrity(void);
static NoDbgRegParms sqInt checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid);
extern sqInt checkOkayOop(usqInt oop);
extern sqInt checkOopHasOkayClass(usqInt obj);
static NoDbgRegParms sqInt checkOopIntegritynamed(sqInt obj, char *name);
static NoDbgRegParms sqInt checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classAtIndex(sqInt classIndex);
static NoDbgRegParms sqInt classAtIndexput(sqInt classIndex, sqInt objOop);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classDoubleByteArray(void);
extern sqInt classDoubleWordArray(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
extern sqInt classFloat32Array(void);
extern sqInt classFloat64Array(void);
static NoDbgRegParms sqInt classForClassTag(sqInt classIndex);
static NoDbgRegParms sqInt classFormatFromInstFormat(sqInt instFormat);
static sqInt classIndexFieldWidth(void);
extern sqInt classIndexOf(sqInt objOop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classOrNilAtIndex(sqInt classIndex);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classTableMinorIndexMask(void);
extern sqInt classTablePageSize(void);
extern sqInt classTableRootObj(void);
static sqInt classTableRootSlots(void);
extern sqInt classTagForClass(sqInt classObj);
extern sqInt classUnsafeAlien(void);
extern sqInt classWordArray(void);
static void clearLeakMapAndMapAccessibleFreeSpace(void);
static NoDbgRegParms sqInt cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning);
extern sqInt cloneObject(sqInt objOop);
static NoDbgRegParms usqInt copyObjtoAddrstopAtsavedFirstFieldsindex(sqInt objOop, sqInt segAddr, sqInt endSeg, sqInt savedFirstFields, sqInt i);
extern void countMarkedAndUnmarkdObjects(sqInt printFlags);
static usqLong currentAllocatedBytes(void);
extern sqInt displayObject(void);
static NoDbgRegParms void doScavenge(sqInt tenuringCriterion);
static NoDbgRegParms sqInt doShortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern usqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots);
static NoDbgRegParms void enableObjectEnumerationFrom(sqInt initialObject);
static NoDbgRegParms sqInt ensureRoomOnObjStackAt(sqInt objStackRootIndex);
static NoDbgRegParms sqInt enterIntoClassTable(sqInt aBehavior);
static sqInt ephemeronFormat(void);
static NoDbgRegParms sqInt existInstancesInNewSpaceOf(sqInt classObj);
static NoDbgRegParms void expungeFromClassTable(sqInt aBehavior);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop);
static NoDbgRegParms NeverInline sqInt fetchClassOfNonImm(sqInt objOop);
extern sqInt fetchClassOf(sqInt oop);
static NoDbgRegParms sqInt fetchClassTagOfNonImm(sqInt obj);
extern int fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static NoDbgRegParms sqInt fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop);
static sqInt findLargestFreeChunk(void);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
static sqInt firstAccessibleObject(void);
static NoDbgRegParms void * firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt objOop);
extern void * firstIndexableField(sqInt objOop);
extern sqInt fixedFieldsOfClassFormatMask(void);
extern sqInt fixedFieldsOfClassFormat(sqInt classFormat);
static NoDbgRegParms sqInt fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength);
static NoDbgRegParms NeverInline sqInt fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue);
static NoDbgRegParms sqInt followFieldofObject(sqInt fieldIndex, sqInt anObject);
extern sqInt followForwarded(sqInt objOop);
static NoDbgRegParms sqInt followMaybeForwarded(sqInt objOop);
static NoDbgRegParms sqInt followObjFieldofObject(sqInt fieldIndex, sqInt anObject);
extern sqInt formatOfClass(sqInt classPointer);
static NoDbgRegParms sqInt formatOf(sqInt objOop);
static sqInt forwardedFormat(void);
static NoDbgRegParms sqInt forwardersIn(sqInt anObject);
static sqInt freeChunkNextIndex(void);
static sqInt freeChunkParentIndex(void);
static sqInt freeChunkPrevIndex(void);
static NoDbgRegParms sqInt freeChunkWithBytesat(sqInt bytes, sqInt address);
extern sqInt freeObject(sqInt objOop);
extern NeverInline usqLong fullGC(void);
static float getHeapGrowthToSizeGCRatio(void);
static NoDbgRegParms sqInt goodContextSize(sqInt oop);
static NoDbgRegParms usqInt growOldSpaceByAtLeast(sqInt minAmmount);
static NoDbgRegParms sqInt hasPointerFieldsNonImm(sqInt oop);
extern usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static NoDbgRegParms usqLong headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex);
static sqInt hiddenRootSlots(void);
static sqInt hiddenRootsObject(void);
static sqInt imageSegmentVersion(void);
#if IMMUTABILITY
extern sqInt immutableBitMask(void);
#endif /* IMMUTABILITY */
static NoDbgRegParms void inFreeTreeReplacewith(sqInt treeNode, sqInt newNode);
static NoDbgRegParms sqInt initialInstanceOf(sqInt classObj);
static NeverInline void initializeNewSpaceVariables(void);
static NoDbgRegParms void initializeObjectMemory(sqInt bytesToShift);
extern void inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList);
static NoDbgRegParms NeverInline void inPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag);
extern sqInt instanceSizeOf(sqInt classObj);
static NoDbgRegParms sqInt instantiateClass(sqInt classObj);
extern sqInt instSpecOfClassFormat(sqInt classFormat);
static NoDbgRegParms sqInt instSpecOfClass(sqInt classPointer);
static NoDbgRegParms void invalidCompactClassError(const char *className);
extern sqInt isArray(sqInt oop);
static NoDbgRegParms int isBridgeOrEnumerableObjectNoAssert(sqInt objOop);
extern sqInt isBytes(sqInt oop);
extern int isCharacterObject(sqInt oop);
extern int isCharacterValue(sqInt anInteger);
static NoDbgRegParms sqInt isClassAtUniqueIndex(sqInt aClass);
static NoDbgRegParms int isCompiledMethodFormat(sqInt format);
static NoDbgRegParms int isCompiledMethodHeader(sqInt objHeader);
extern int isCompiledMethod(sqInt objOop);
static NoDbgRegParms int isContextHeader(sqInt aHeader);
static NoDbgRegParms sqInt isContext(sqInt oop);
static NoDbgRegParms int isCopiedIntoSegment(sqInt anObjectInTheHeap);
static NoDbgRegParms sqInt isEmptyObjStack(sqInt objStack);
static NoDbgRegParms sqInt isEnumerableObjectNoAssert(sqInt objOop);
static NoDbgRegParms int isEphemeron(sqInt objOop);
extern sqInt isFixedSizePointerFormat(sqInt format);
static NoDbgRegParms int isForwardedClassTag(sqInt classIndex);
extern int isForwarded(sqInt objOop);
static NoDbgRegParms int isFreeObject(sqInt objOop);
static NoDbgRegParms sqInt isFreeOop(sqInt oop);
extern int isImmediate(sqInt oop);
static NoDbgRegParms sqInt isInClassTable(sqInt objOop);
extern sqInt isIndexable(sqInt objOop);
static NoDbgRegParms sqInt isInEden(sqInt objOop);
static NoDbgRegParms sqInt isInFutureSpace(sqInt address);
extern sqInt isInMemory(sqInt address);
static NoDbgRegParms sqInt isInNewSpace(sqInt objOop);
extern sqInt isInOldSpace(sqInt address);
static NoDbgRegParms sqInt isInPastSpace(sqInt address);
static NoDbgRegParms int isLargeFreeObject(sqInt objOop);
extern sqInt isLong64s(sqInt oop);
static NoDbgRegParms sqInt isMaybeFiredEphemeron(sqInt objOop);
extern int isNonImmediate(sqInt oop);
static NoDbgRegParms int isObjEphemeron(sqInt objOop);
static NoDbgRegParms sqInt isObjImmutable(sqInt anOop);
static NoDbgRegParms int isOldObject(sqInt objOop);
extern sqInt isOopCompiledMethod(sqInt oop);
extern sqInt isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt oop);
extern sqInt isOopMutable(sqInt oop);
extern int isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static NoDbgRegParms sqInt isPureBitsFormat(sqInt format);
static NoDbgRegParms sqInt isPureBitsNonImm(sqInt objOop);
static NoDbgRegParms int isRemembered(sqInt objOop);
static NoDbgRegParms int isSegmentBridge(sqInt objOop);
static NoDbgRegParms sqInt isSemaphoreOop(sqInt anOop);
extern sqInt isShorts(sqInt oop);
static NoDbgRegParms int isUnambiguouslyForwarder(sqInt objOop);
extern int isUnmarked(sqInt objOop);
extern sqInt isValidClassTag(sqInt classIndex);
static NoDbgRegParms sqInt isValidObjStackAt(sqInt objStackRootIndex);
static NoDbgRegParms sqInt isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx);
static NoDbgRegParms sqInt isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage);
static NoDbgRegParms sqInt isValidObjStack(sqInt objStack);
static NoDbgRegParms int isWeakNonImm(sqInt objOop);
extern sqInt isWeak(sqInt oop);
static NoDbgRegParms sqInt isWordsOrBytesNonImm(sqInt objOop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWordsOrShorts(sqInt oop);
extern sqInt isWords(sqInt oop);
extern int isYoungObject(sqInt objOop);
extern sqInt isYoung(sqInt oop);
static NoDbgRegParms sqInt isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static NoDbgRegParms sqInt isonObjStack(sqInt oop, sqInt objStack);
static NoDbgRegParms sqInt keyOfEphemeron(sqInt objOop);
static NoDbgRegParms sqInt knownClassAtIndex(sqInt classIndex);
static sqInt lastPointerFormat(void);
static NoDbgRegParms sqInt lastPointerOfWhileSwizzling(sqInt objOop);
static NoDbgRegParms sqInt lastPointerOf(sqInt objOop);
extern int leakCheckFullGC(void);
extern int leakCheckNewSpaceGC(void);
static NoDbgRegParms sqInt lengthOfMaybeImmediate(sqInt oop);
static NoDbgRegParms sqInt lengthOf(sqInt objOop);
extern sqInt literalCountOfMethodHeader(sqInt header);
extern sqInt literalCountOf(sqInt methodPointer);
static NoDbgRegParms NeverInline sqInt loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintInstancesOf(sqInt aClassOop);
extern void longPrintInstancesWithClassIndex(sqInt classIndex);
extern void longPrintReferencesTo(sqInt anOop);
static void mapExtraRoots(void);
static NeverInline void mapMournQueue(void);
static NoDbgRegParms sqInt mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes);
static NoDbgRegParms void markAndTraceClassOf(sqInt objOop);
static NoDbgRegParms void markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents);
extern NeverInline void markAndTrace(sqInt objOop);
static sqInt markInactiveEphemerons(void);
static NoDbgRegParms NeverInline void markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged);
static void markWeaklingsAndMarkAndFireEphemerons(void);
extern sqInt maxSlotsForNewSpaceAlloc(void);
extern sqInt maybeMethodClassOfseemsToBeInstantiating(sqInt methodObj, sqInt format);
extern sqInt minSlotsForShortening(void);
static NoDbgRegParms usqInt newHashBitsOf(sqInt objOop);
static usqInt newObjectHash(void);
static sqInt newSpaceIsEmpty(void);
extern sqInt nilObject(void);
static NeverInline void nilUnmarkedWeaklingSlots(void);
static NoDbgRegParms sqInt noCheckClassAtIndex(sqInt classIndex);
static NoDbgRegParms sqInt noCheckPushonObjStack(sqInt objOop, sqInt objStack);
static NoDbgRegParms sqInt noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject);
static NoDbgRegParms NeverInline sqInt noInlineAllocateSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
extern sqInt nonIndexablePointerFormat(void);
static int noUnscannedEphemerons(void);
static NoDbgRegParms sqInt numBytesOfBitsformat(sqInt objOop, sqInt format);
static NoDbgRegParms sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
static NoDbgRegParms usqInt numPointerSlotsOf(sqInt objOop);
static NoDbgRegParms sqInt numSlotsForBytes(sqInt numBytes);
static NoDbgRegParms usqInt numSlotsOfAny(sqInt objOop);
extern usqInt numSlotsOf(sqInt objOop);
static NoDbgRegParms sqInt numStrongSlotsOfInephemeral(sqInt objOop);
static NoDbgRegParms sqInt numStrongSlotsOfWeakling(sqInt objOop);
extern sqInt objectAfter(sqInt objOop);
extern sqInt objectBefore(sqInt objOop);
static NoDbgRegParms sqInt objectInPastSpaceBefore(sqInt objOop);
static NoDbgRegParms sqInt objectStartingAt(sqInt address);
static NoDbgRegParms sqInt objectsAccessibleFromRoots(sqInt arrayOfRootsArg);
static NoDbgRegParms NeverInline sqInt objectsReachableFromRoots(sqInt arrayOfRoots);
static NoDbgRegParms sqInt okayOop(sqInt signedOop);
extern sqInt oldSpaceObjectAfter(sqInt objOop);
static NoDbgRegParms NeverInline void outOfPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag);
extern sqInt pinObject(sqInt objOop);
static NoDbgRegParms sqInt popObjStack(sqInt objStack);
extern sqInt popRemappableOop(void);
static NoDbgRegParms void postBecomeScanClassTable(sqInt effectsFlags);
extern sqInt primitiveErrorTable(void);
extern void printActivationsOf(sqInt aMethodObj);
extern void printBogons(void);
static NoDbgRegParms void printBridgeon(sqInt oop, FILE *aStream);
static NoDbgRegParms void printCantBeObjecton(sqInt oop, FILE *aStream);
extern void printContextReferencesTo(sqInt anOop);
extern void printEntity(sqInt oop);
extern void printForwarders(void);
static NoDbgRegParms void printForwarderon(sqInt oop, FILE *aStream);
extern void printFreeChunks(void);
extern void printFreeChunk(sqInt freeChunk);
static NoDbgRegParms void printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode);
extern void printFreeListHeads(void);
extern sqInt printFreeList(sqInt chunkOrIndex);
static NoDbgRegParms void printFreeObjecton(sqInt oop, FILE *aStream);
extern void printFreeTree(void);
static NoDbgRegParms void printFreeTreeChunk(sqInt chunkOrZero);
extern void printHeaderOf(sqInt objOop);
static NoDbgRegParms void printImmediateObjecton(sqInt oop, FILE *aStream);
extern void printInstancesOf(sqInt aClassOop);
extern void printInstancesWithClassIndex(sqInt classIndex);
extern void printInvalidClassTableEntries(void);
#if LLDB
extern void printMarkedOops(void);
#endif /* LLDB */
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
static NoDbgRegParms void printNonPointerDataOfon(sqInt oop, FILE *aStream);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printObjectsWithHash(sqInt hash);
extern void printObjStackAndContents(sqInt objStack);
static NoDbgRegParms void printObjStackPagemyIndexpageTypeprintContents(sqInt objStackPage, sqInt myx, sqInt pageType, sqInt printContents);
static NoDbgRegParms void printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType);
extern void printObjStack(sqInt objStack);
extern NeverInline void printOopsExcept(sqInt (*function)(sqInt));
extern void printOopsFromto(sqInt startAddress, sqInt endAddress);
extern NeverInline void printOopsSuchThat(sqInt (*function)(sqInt));
extern void printReferencesTo(sqInt anOop);
static NoDbgRegParms void printStringDataOfon(sqInt oop, FILE *aStream);
#if LLDB
extern void printUnmarkedOops(void);
#endif /* LLDB */
static NoDbgRegParms sqInt pushOnUnscannedEphemeronsStack(sqInt anEphemeron);
extern void pushRemappableOop(sqInt oop);
static NoDbgRegParms void queueMourner(sqInt anEphemeronOrWeakArray);
extern sqInt rawHashBitsOf(sqInt objOop);
extern sqInt receiverTagBitsForMethod(sqInt aMethodObj);
static NoDbgRegParms sqInt relocateObjStackForPlanningCompactorandContents(sqInt objStack, sqInt relocateContents);
extern sqInt removeGCRoot(sqInt *varLoc);
static NoDbgRegParms sqInt returnrestoringObjectsInsavedFirstFieldsandsavedHashes(sqInt errCode, sqInt firstArray, sqInt savedFirstFields, sqInt secondArray, sqInt savedHashes);
static NoDbgRegParms sqInt returnrestoringObjectsInupTosavedFirstFields(sqInt errCode, sqInt firstArray, sqInt limitOrTag, sqInt savedFirstFields);
static NoDbgRegParms NeverInline void reverseBytesIn32BitWordsIn(sqInt segmentWordArray);
static NoDbgRegParms void runLeakCheckerForFreeSpaceignoring(sqInt gcModes, sqInt anOopOrNil);
static NoDbgRegParms void runLeakCheckerFor(sqInt gcModes);
static NoDbgRegParms void runLeakCheckerForexcludeUnmarkedObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid);
static NoDbgRegParms void scavengingGCTenuringIf(sqInt tenuringCriterion);
static NoDbgRegParms NeverInline sqInt setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd);
extern sqInt shortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress);
extern sqInt shouldRemapOop(sqInt oop);
static NoDbgRegParms sqInt sizeOfObjStack(sqInt objStack);
static int slidingCompactionInProgress(void);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
static NoDbgRegParms usqInt startOfObject(sqInt objOop);
extern sqInt statNumGCs(void);
extern usqInt storeCheckBoundary(void);
static NoDbgRegParms sqInt storeImageSegmentIntooutPointersroots(sqInt segmentWordArrayArg, sqInt outPointerArrayArg, sqInt arrayOfRootsArg);
extern int storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt obj, sqInt valueWord);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
static NoDbgRegParms sqInt sufficientSpaceAfterGC(sqInt numBytes);
static NoDbgRegParms sqInt swizzleObjStackAt(sqInt objStackRootIndex);
extern void tenuringIncrementalGC(void);
static NoDbgRegParms sqInt topOfObjStack(sqInt objStack);
extern sqInt topRemappableOop(void);
static sqInt totalFreeListBytes(void);
extern sqInt trueObject(void);
static NoDbgRegParms sqInt unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes);
static NoDbgRegParms NeverInline sqInt unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index);
static NoDbgRegParms void unlinkSolitaryFreeTreeNode(sqInt freeTreeNode);
extern sqInt unpinObject(sqInt objOop);
static NoDbgRegParms void updateListStartingAt(sqInt freeNode);
static sqInt validClassTableHashes(void);
static sqInt validClassTableRootPages(void);
extern int validFreeTree(void);
static NoDbgRegParms sqInt validFreeTreeChunk(sqInt chunk);
static NoDbgRegParms const char * validFreeTreeChunkparent(sqInt chunk, sqInt parent);
static sqInt validObjStacks(void);
static NoDbgRegParms sqInt validPostBecomeArrayContents(sqInt anArray);
extern sqInt vmEndianness(void);
static NeverInline void compact(void);
static NeverInline sqInt copyAndUnmarkMobileObjects(void);
static NoDbgRegParms NeverInline void copyAndUnmark(sqInt firstPass);
static void endCompaction(void);
static NoDbgRegParms void freeFromupTonextObject(usqInt initialToFinger, usqInt limit, sqInt nextObject);
static int initializeScanCheckingForFullyCompactedHeap(void);
static NoDbgRegParms sqInt isMobile(sqInt obj);
static NoDbgRegParms sqInt isPostMobile(sqInt obj);
static NeverInline sqInt planCompactSavingForwarders(void);
static NoDbgRegParms void reinitializeScanFrom(sqInt initialObject);
extern sqInt remapObj(sqInt objOop);
static sqInt savedFirstFieldsSpaceWasAllocated(void);
static NoDbgRegParms sqInt scanForFirstFreeAndFirstMobileObjectFrom(sqInt initialObject);
extern sqInt shouldRemapObj(sqInt objOop);
static void unmarkObjectsFromFirstFreeObject(void);
static NeverInline void updatePointers(void);
static NoDbgRegParms void updatePointersInsavedFirstFieldPointer(sqInt obj, sqInt firstFieldPtr);
static NoDbgRegParms sqInt useSegmentForSavedFirstFieldsSpace(sqInt spaceEstimate);
static NoDbgRegParms sqInt validRelocationPlanInPass(sqInt onePass);
static NoDbgRegParms usqInt segLimit(SpurSegmentInfo *self_in_SpurSegmentInfo);
static NoDbgRegParms SpurSegmentInfo * addSegmentOfSize(sqInt ammount);
static NoDbgRegParms void adjustSegmentSwizzlesBy(sqInt firstSegmentShift);
static sqInt allBridgesMarked(void);
static void allocateOrExtendSegmentInfos(void);
static NoDbgRegParms sqInt bridgeAt(sqInt segIndex);
static NoDbgRegParms sqInt bridgeFor(SpurSegmentInfo *aSegment);
static NoDbgRegParms void bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil);
static void checkSegments(void);
static void collapseSegmentsPostSwizzle(void);
static NoDbgRegParms void * firstGapOfSizeAtLeast(sqInt size);
static NoDbgRegParms sqInt isEmptySegment(SpurSegmentInfo *seg);
static NoDbgRegParms sqInt isInSegments(usqInt address);
static NoDbgRegParms sqInt isValidSegmentBridge(sqInt objOop);
static NoDbgRegParms SpurSegmentInfo * nextNonEmptySegmentAfter(sqInt i);
static void postSnapshot(void);
static NeverInline void prepareForSnapshot(void);
static NoDbgRegParms sqInt readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes);
extern SpurSegmentInfo * segmentContainingObj(sqInt objOop);
static sqInt segmentOverlap(void);
static NoDbgRegParms int shrinkObjectMemory(usqInt delta);
static sqInt someSegmentContainsPinned(void);
static NoDbgRegParms sqInt swizzleObj(sqInt objOop);
static usqInt totalBytesInSegments(void);
static NoDbgRegParms sqInt writeImageSegmentsToFile(sqImageFile aBinaryStream);
static NoDbgRegParms sqInt writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream);
extern sqInt accessorDepthForPrimitiveMethod(sqInt aMethodObj);
extern sqInt activeProcess(void);
extern void addIdleUsecs(sqInt idleUsecs);
static NoDbgRegParms void addLastLinktoList(sqInt proc, sqInt aList);
static NoDbgRegParms sqInt addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static NoDbgRegParms sqInt asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static NoDbgRegParms void assertValidStackLimits(sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
extern sqInt callbackEnter(sqInt *callbackID);
extern sqInt callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
#if LRPCheck
static NeverInline sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
#endif /* LRPCheck */
extern sqInt checkedIntegerValueOf(sqInt intOop);
static NoDbgRegParms sqInt checkForEventsMayContextSwitch(sqInt mayContextSwitch);
extern sqInt checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize);
static NoDbgRegParms sqInt checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr);
static sqInt checkInterpreterIntegrity(void);
static NoDbgRegParms sqInt checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static NoDbgRegParms sqInt checkOkayStackPage(StackPage *thePage);
static NoDbgRegParms sqInt checkOkayStackZone(sqInt writeBack);
static NoDbgRegParms void checkProfileTick(sqInt aPrimitiveMethod);
static NoDbgRegParms sqInt checkStackPointerForMaybeMarriedContext(sqInt aContext);
static NoDbgRegParms sqInt checkStackPointerIndexForFrame(char *theFP);
static NoDbgRegParms sqInt classNameOfIs(sqInt aClass, char *className);
static NoDbgRegParms int contexthasSender(sqInt thisCntx, sqInt aContext);
static NoDbgRegParms sqInt contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern usqInt copiedValueCountOfClosure(sqInt closureObj);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static NoDbgRegParms NeverInline sqInt couldBeProcess(sqInt oop);
static NoDbgRegParms void createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
extern void * disownVM(sqInt flags);
static sqInt divorceAllFrames(void);
static NoDbgRegParms void divorceFramesIn(StackPage *aStackPage);
static NoDbgRegParms sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg);
static NoDbgRegParms sqInt doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
extern struct VirtualMachine * * dummyReferToProxy(void);
extern void dumpPrimTraceLog(void);
extern void dumpPrimTraceLogOn(FILE *aStdioStream);
extern NeverInline void eekcr(void);
static NoDbgRegParms sqInt ensureCallerContext(char *theFP);
static NoDbgRegParms void ensureImageFormatIsUpToDate(sqInt swapBytes);
static NoDbgRegParms char * establishFrameForContextToReturnTo(sqInt contextToReturnTo);
static NoDbgRegParms void externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static NoDbgRegParms char * externalEnsureIsBaseFrame(char *aFramePtr);
static NoDbgRegParms sqInt externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static NoDbgRegParms sqInt fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static NoDbgRegParms sqInt fetchStackPointerOf(sqInt aContext);
extern int fileTimesInUTC(void);
static NoDbgRegParms sqInt findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static NoDbgRegParms char * findFrameAboveinPage(char *theFP, StackPage *thePage);
static NoDbgRegParms sqInt findHomeForContext(sqInt aContext);
static NoDbgRegParms sqInt findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
extern sqInt findSelectorOfMethod(sqInt meth);
static NoDbgRegParms char * findSPOfon(char *theFP, StackPage *thePage);
static NoDbgRegParms sqInt findUnwindThroughContext(sqInt homeContext);
extern void flush(void);
static NoDbgRegParms sqInt flushExternalPrimitiveOf(sqInt methodObj);
static NoDbgRegParms void flushMethodCacheForMethod(sqInt oldMethod);
static NoDbgRegParms void followForwardedFrameContentsstackPointer(char *theFP, char *theSP);
extern sqInt forceInterruptCheck(void);
static NoDbgRegParms sqInt frameContext(char *theFP);
static NoDbgRegParms char * frameOfMarriedContext(sqInt aContext);
static NoDbgRegParms void framePrintDescription(sqInt it);
static NoDbgRegParms sqInt frameStackedReceiverOffset(char *theFP);
static NoDbgRegParms sqInt frameStackedReceivernumArgs(char *theFP, sqInt numArgs);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
static NoDbgRegParms void (*functionPointerForinClass(sqInt primIdx, sqInt theClass))(void);
static sqInt getCogVMFeatureFlags(void);
static sqInt getErrorObjectFromPrimFailCode(void);
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
static NoDbgRegParms sqInt getShortFromFileswap(sqImageFile aFile, sqInt swapFlag);
static sqInt getSnapshotScreenSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
extern FILE * getTranscript(void);
static NoDbgRegParms sqInt handleForwardedSelectorFaultFor(sqInt selectorOop);
static NoDbgRegParms sqInt handleForwardedSendFaultForTag(sqInt classTag);
static NoDbgRegParms sqInt handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP);
static NeverInline void handleStackOverflow(void);
static NoDbgRegParms sqInt handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern sqInt highBit(usqInt anUnsignedValue);
static NoDbgRegParms sqInt ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static NoDbgRegParms usqInt iframeMethod(char *theFP);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
extern void initStackPagesAndContinueIntowith(void (*continuation)(void *), void *argument);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static NoDbgRegParms int isBaseFrame(char *theFP);
extern sqInt isBooleanObject(sqInt oop);
extern int isFloatObject(sqInt oop);
static NoDbgRegParms sqInt isFrameonPage(char *aFrame, StackPage *aPage);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
static NoDbgRegParms sqInt isLinkedExternalPrimitive(sqInt methodObj);
static NoDbgRegParms sqInt isLiveContext(sqInt oop);
static NoDbgRegParms int isMarriedOrWidowedContext(sqInt aContext);
static NoDbgRegParms sqInt isMetaPrimitiveIndex(sqInt primIndex);
static NoDbgRegParms sqInt isNullExternalPrimitiveCall(sqInt aMethodObj);
static int isPrimitiveFunctionPointerAnIndex(void);
extern int isQuickPrimitiveIndex(sqInt anInteger);
extern int isReadMediatedContextInstVarIndex(sqInt index);
static NoDbgRegParms int isSingleContext(sqInt aContext);
static NoDbgRegParms sqInt isStillMarriedContext(sqInt aContext);
static NoDbgRegParms int isVanillaBlockClosure(sqInt aClosure);
static NoDbgRegParms sqInt isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static NoDbgRegParms sqInt isWidowedContextNoConvert(sqInt aOnceMarriedContext);
static NoDbgRegParms sqInt isWidowedContext(sqInt aOnceMarriedContext);
extern int isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static NoDbgRegParms sqInt lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static NoDbgRegParms sqInt lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static NoDbgRegParms sqInt lookupMethodInClass(sqInt class);
static NoDbgRegParms sqInt lookupMNUInClass(sqInt class);
static NoDbgRegParms sqInt lookupOrdinaryNoMNUEtcInClass(sqInt class);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static NoDbgRegParms void makeContextSnapshotSafe(sqInt ctxt);
extern usqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void mapPrimTraceLog(void);
static void markAndTracePrimTraceLog(void);
static NoDbgRegParms sqInt markAndTraceStackPages(sqInt fullGCFlag);
static void markAndTraceUntracedReachableStackPages(void);
static NoDbgRegParms sqInt marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static NoDbgRegParms void marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static NoDbgRegParms usqInt marryFrameSP(char *theFP, char *theSP);
static NoDbgRegParms sqInt maybeLeakCheckExternalPrimCall(sqInt aMethodObj);
extern sqInt maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
static NoDbgRegParms int methodHeaderIndicatesLargeFrame(sqInt methodHeader);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnBool(sqInt boolean);
extern sqInt methodReturnFloat(double aFloat);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnReceiver(void);
extern NeverInline sqInt methodReturnString(char *aCString);
extern sqInt methodReturnValue(sqInt oop);
extern int methodUsesAlternateBytecodeSet(sqInt aMethodObj);
static NoDbgRegParms sqInt methodUsesPrimitiveErrorCode(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static NoDbgRegParms char * nameOfClass(sqInt classOop);
static NoDbgRegParms char * nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr);
static NoDbgRegParms sqInt noMarkedContextsOnPage(StackPage *thePage);
static NoDbgRegParms sqInt numSlotsOfMarriedContext(sqInt aContext);
static sqInt numStkPages(void);
extern sqInt objCouldBeClassObj(sqInt objOop);
static NoDbgRegParms sqInt objectequalsString(sqInt anOop, char *aCString);
extern sqInt ownVM(void *vmHandle);
extern sqInt pcPreviousToinSqueakV3PlusClosuresOrSistaV1Method(sqInt theIP, sqInt aMethod);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
static NoDbgRegParms sqInt positiveMachineIntegerFor(usqIntptr_t value);
static sqInt postGCUpdateDisplayBits(void);
EXPORT(void) primitiveEventProcessingControl(void);
static NoDbgRegParms int primitiveFloatEqualtoArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatGreaterOrEqualtoArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatGreaterthanArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatLessOrEqualtoArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatLessthanArg(sqInt rcvrOop, sqInt argOop);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static NoDbgRegParms void printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static NoDbgRegParms void printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printAllStacksOn(FILE *aStdioStream);
extern void printCallStack(void);
static NoDbgRegParms sqInt printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static NoDbgRegParms sqInt printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printCallStackOn(FILE *aStdioStream);
static NoDbgRegParms sqInt printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
static NoDbgRegParms void printDecodeMethodHeaderOop(sqInt methodHeaderOop);
extern void printExternalHeadFrame(void);
static NoDbgRegParms sqInt printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static NoDbgRegParms void printFrameOopat(char *name, char *address);
static NoDbgRegParms void printFrameOopindexat(char *name, sqInt idx, char *address);
extern void printFramesInPage(StackPage *thePage);
extern void printFramesOnStackPageListInUse(void);
static NoDbgRegParms void printFrameThingandFrameat(char *name, char *theFP, char *address);
static NoDbgRegParms void printFrameThingatextraString(char *name, char *address, char *extraStringOrNil);
extern sqInt printFrame(char *theFP);
static NoDbgRegParms sqInt printHexPtrnp(void *p);
extern void printHex(usqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static NoDbgRegParms void printNameOfClasscount(sqInt classOop, sqInt cnt);
static NoDbgRegParms void printOopShortInner(sqInt oop);
extern void printOop(sqInt oop);
static NoDbgRegParms sqInt printPrimLogEntryAthasParameter(sqInt i, sqInt hasParameter);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static NoDbgRegParms void printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static NoDbgRegParms void printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static NoDbgRegParms sqInt pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static NoDbgRegParms void putLongtoFile(sqInt aLong, sqImageFile aFile);
static NoDbgRegParms void putShorttoFile(short aShort, sqImageFile aFile);
static NoDbgRegParms void putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static NoDbgRegParms void putWord32toFile(int aWord32, sqImageFile aFile);
extern sqInt readableFormat(sqInt imageVersion);
static NoDbgRegParms NeverInline void reapAndResetErrorCodeToheader(char *theSP, sqInt methodHeader);
extern sqInt reestablishContextPriorToCallback(sqInt callbackContext);
static NoDbgRegParms sqInt removeFirstLinkOfList(sqInt aList);
static NoDbgRegParms sqInt removeProcessfromList(sqInt aProcess, sqInt aList);
static sqInt retryPrimitiveOnFailure(void);
extern sqInt returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static NoDbgRegParms void reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static NoDbgRegParms void rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)());
static NoDbgRegParms sqInt safeMethodClassOf(sqInt methodPointer);
static NoDbgRegParms sqInt saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
extern void * setInterruptCheckChain(void (*aFunction)());
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static NoDbgRegParms void setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static NoDbgRegParms sqInt shortPrintContext(sqInt aContext);
static NoDbgRegParms sqInt shortPrintFrameAndCallers(char *theFP);
extern void shortPrintFramesInPage(StackPage *thePage);
extern void shortPrintFramesOnStackPageListInUse(void);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static NoDbgRegParms void shortPrintOop(sqInt oop);
static NoDbgRegParms sqInt shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static int slowPrimitiveResponse(void);
static NoDbgRegParms sqInt snapshot(sqInt embedded);
extern sqInt specialSelector(sqInt index);
static NoDbgRegParms void spurPostBecomeAction(sqInt theBecomeEffectsFlags);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static NoDbgRegParms sqInt stackPointerForMaybeMarriedContext(sqInt aContext);
static NoDbgRegParms sqInt stackPointerIndexForFrame(char *theFP);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static NoDbgRegParms char * storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static NoDbgRegParms sqInt unfollowFirstLiteralOfMaybeCalloutMethodprimitiveIndex(sqInt methodObj, sqInt primIndex);
static NoDbgRegParms sqInt updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b);
static NoDbgRegParms sqInt validBCPCinMethod(sqInt thePC, usqInt aMethod);
static NoDbgRegParms sqInt validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
static sqInt validStackPageBaseFrames(void);
#if LRPCheck
static NoDbgRegParms NeverInline void voidLongRunningPrimitive(char *reason);
#endif /* LRPCheck */
static sqInt wakeHighestPriority(void);
static NeverInline sqInt writeImageFileIO(void);
static NoDbgRegParms usqInt cloneContext(sqInt aContext);
static NoDbgRegParms sqInt fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static NoDbgRegParms sqInt fieldofFrame(sqInt index, char *theFP);
static NoDbgRegParms sqInt isAppropriateForCopyObject(sqInt oop);
static NoDbgRegParms void (*linkExternalCallerrInto(sqInt externalCallLiteral, sqInt *failPtr))();
static void primitiveClone(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFullGC(void);
static void primitiveGetSetFFIExceptionHandling(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
#if LRPCheck
EXPORT(void) primitiveLongRunningPrimitive(void);
#endif /* LRPCheck */
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static NoDbgRegParms void pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackLimit;
_iss char * stackPointer;
_iss char * framePointer;
_iss volatile usqIntptr_t CStackPointer;
_iss volatile usqIntptr_t CFramePointer;
_iss volatile usqIntptr_t CReturnAddress;
_iss usqInt scavengeThreshold;
_iss usqInt freeStart;
_iss sqInt needGCFlag;
_iss sqInt specialObjectsOop;
_iss sqInt primFailCode;
_iss unsigned char primTraceLogIndex;
_iss usqInt newMethod;
_iss usqInt instructionPointer;
_iss sqInt argumentCount;
_iss sqLong nextProfileTick;
_iss sqInt primTraceLog[256];
_iss FILE * transcript;
_iss StackPage * stackPage;
_iss sqInt nilObj;
_iss usqInt oldSpaceStart;
_iss usqInt method;
_iss sqInt bytecodeSetSelector;
_iss usqInt endOfMemory;
_iss sqInt messageSelector;
_iss usqInt pastSpaceStart;
_iss StackPage * pages;
_iss char * stackBasePlus1;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss usqInt totalFreeOldSpace;
_iss usqInt newSpaceStart;
_iss SpurSegmentInfo * segments;
_iss sqInt hiddenRootsObj;
_iss sqInt bytesPerPage;
_iss sqInt numSegments;
_iss sqInt traceLogIndex;
_iss sqInt * freeLists;
_iss sqInt markStack;
_iss sqInt weaklingStack;
_iss sqInt numClassTablePages;
_iss sqInt classTableFirstPage;
_iss sqInt rememberedSetSize;
_iss sqInt * rememberedSet;
_iss usqInt firstFreeObject;
_iss usqInt freeListsMask;
_iss StackPage * mostRecentlyUsedPage;
_iss sqInt remapBufferCount;
_iss usqInt totalHeapSizeIncludingBridges;
_iss sqInt numStackPages;
_iss sqInt classTableIndex;
_iss sqInt tempOop;
_iss usqInt lastMobileObject;
_iss sqInt profileProcess;
_iss sqInt futureSurvivorStart;
_iss sqInt lkupClass;
_iss sqInt becomeEffectsFlags;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSemaphore;
#endif
_iss sqInt mournQueue;
_iss sqInt numRememberedEphemerons;
_iss sqInt mobileStart;
_iss sqInt performWithArgumentsRecursionGuard;
_iss sqInt profileMethod;
_iss sqInt profileSemaphore;
_iss sqInt growHeadroom;
_iss sqInt tenureThreshold;
_iss sqInt lastCoggableInterpretedBlockMethod;
_iss sqInt lastUncoggableInterpretedBlockMethod;
_iss sqInt ephemeronList;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckMethod;
#endif
_iss char * objStackInvalidBecause;
_iss sqInt tenureCriterion;
_iss sqInt classNameIndex;
_iss usqInt freeOldSpaceStart;
_iss sqInt extraRootCount;
_iss sqInt gcPhaseInProgress;
_iss sqInt invalidObjStackPage;
_iss sqInt metaAccessorDepth;
_iss usqInt objectAfterLastMobileObject;
_iss sqInt previousRememberedSetSize;
_iss sqInt tempOop2;
_iss sqInt cogCompiledCodeCompactionCalledFor;
_iss sqInt imageHeaderFlags;
_iss sqInt pendingFinalizationSignals;
_iss sqInt validatedIntegerClassFlags;
_iss usqInt firstMobileObject;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt numSegInfos;
_iss sqInt savedFirstFieldsSpaceNotInOldSpace;
_iss sqInt gcMode;
_iss sqInt highestRunnableProcessPriority;
#if LRPCheck
_iss usqLong longRunningPrimitiveStopUsecs;
#endif
_iss usqLong nextWakeupUsecs;
_iss usqLong statGCEndUsecs;
_iss sqInt thisClassIndex;
_iss usqInt cogCodeSize;
#if LRPCheck
_iss usqLong longRunningPrimitiveStartUsecs;
#endif
_iss sqInt metaclassNumSlots;
_iss sqInt shrinkThreshold;
_iss usqLong statCheckForEvents;
_iss sqInt statTenures;
_iss sqInt weakList;
_iss usqLong gcStartUsecs;
_iss sqInt marking;
_iss sqLong oldSpaceUsePriorToScavenge;
_iss sqInt rememberedSetLimit;
_iss sqInt statSurvivorCount;
_iss sqInt firstFieldOfRememberedSet;
_iss sqInt firstSegmentSize;
_iss sqInt multipleBytecodeSetsActive;
_iss sqInt preemptionYields;
_iss FILE * scavengeLog;
_iss sqInt statMaxAllocSegmentTime;
_iss sqInt statScavenges;
_iss sqInt statShrinkMemory;
_iss sqInt biasForGC;
_iss sqInt fullScreenFlag;
_iss usqInt lastHash;
_iss usqInt lowSpaceThreshold;
_iss sqInt newFinalization;
_iss sqInt rememberedSetRedZone;
_iss sqLong secondaryErrorCode;
_iss usqLong statAllocatedBytes;
_iss sqInt statFullGCs;
_iss sqInt statNumMaps;
_iss sqInt the2ndUnknownShort;
_iss sqInt anomaly;
_iss sqInt edenBytes;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss void * ffiCalloutVMHandle;
_iss sqInt flagInterpretedMethods;
_iss sqInt freeSpaceCheckOopToIgnore;
_iss usqInt heapSizeAtPreviousGC;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
#endif
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt oldImageBaseAddress;
_iss sqInt savedWindowSize;
_iss sqInt statCodeCompactionCount;
_iss usqLong statCodeCompactionUsecs;
_iss usqLong statCompactionUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss sqInt statGrowMemory;
_iss usqLong statIOProcessEvents;
_iss usqLong statIdleUsecs;
_iss usqLong statMarkUsecs;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statPageCountWhenMappingSum;
_iss usqLong statProcessSwitch;
_iss usqLong statScavengeGCUsecs;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss usqLong statSweepUsecs;
_iss sqInt canSwizzle;
_iss sqInt classLinkedListClassTag;
_iss sqInt deferSmash;
_iss sqInt deferredSmash;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
#if LRPCheck
_iss sqInt longRunningPrimitiveSignalUndelivered;
#endif
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt primCalloutIsExternal;
_iss sqInt refCountToShrinkRT;
_iss sqInt signalLowSpace;
_iss sqInt statMarkCount;
_iss sqInt statRootTableCount;
_iss usqLong statSGCDeltaUsecs;
_iss sqInt bogon;
_iss sqInt classByteArrayCompactIndex;
_iss usqInt exceptionPC;
_iss sqInt gcSemaphoreIndex;
_iss usqLong gcSweepEndUsecs;
#if LRPCheck
_iss usqLong longRunningPrimitiveGCUsecs;
#endif
_iss usqLong nextPollUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt statCompactPassCount;
_iss usqLong statIGCDeltaUsecs;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statRootTableOverflows;
_iss sqInt tenuringClassIndex;
_iss sqInt statIncrGCs;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt traceLog[TraceBufferSize /* 768 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 65 */];
_iss usqLong byteCount;
_iss sqInt printSends;
_iss sqInt theUnknownShort;
_iss SpurContiguousObjStack savedFirstFieldsSpace;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss SpurNewSpaceSpace pastSpace;
_iss SpurScavengeLogRecord scavengeLogRecord;
_iss SpurNewSpaceSpace futureSpace;
_iss SpurNewSpaceSpace eden;
_iss float heapGrowthToSizeGCRatio;
_iss double tenuringProportion;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
# if SQ_USE_GLOBAL_STRUCT_REG
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# else
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
# endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
# if SQ_USE_GLOBAL_STRUCT_REG
#	define fooxstr(s) foostr(s)
#	define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
# else
static struct foo * foo = &fum;
# endif
#endif
static void (*primitiveFunctionPointer)();
static void *primitiveCalloutPointer = (void *)-1;
static signed short primitiveMetadataTable[MaxPrimitiveIndex + 2 /* 584 */] = {
//       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
/*0*/	-256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-256,
/*20*/	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0x101, 0x101,
/*40*/	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 3, 3, 3, 3,
/*60*/	 0, 0, 0, 0, 0,-256,-256,-256, 0x100, 0x100, 0, 0, 0, 268, 0x100, 0, 0x100, 0,
/*78*/	 0, 0,
/*80*/	-256,-256,-256, 4, 4, 0, 0x100, 0, 0x200,-256,-256, 0, 0, 0, 0x100,-256, 0,-256,
/*98*/	 0, 0,
/*100*/	 260, 0x200, 0x200, 0x200,-256, 513,-256,-256,-256,-256, 0, 0x100, 0, 0,-256,
/*115*/	 0x100, 0, 12, 260, 0,
/*120*/	 524, 0x100,-256,-256, 1, 0, 0, 0, 0,-255,-256, 0, 0, 0, 0,-256, 0,-256,-256,
/*139*/	 0,
/*140*/	-256, 0x100,-256, 0x101, 0x101, 0x101,-256,-256, 12, 0, 3,-256,-256,-256,-256,
/*155*/	-256,-256,-256, 0x100, 0x100,
/*160*/	 0, 0,-256, 1, 1, 0x100, 0x100,-256, 0x101, 0, 0, 0,-256, 268, 0x100, 0,-256,
/*177*/	 0,-256,-256,
/*180*/	 0, 1, 1, 1, 0x100, 0x100, 0x100, 0x100, 0x200, 0x100,-256,-256,-256,-256,-256,
/*195*/	 0x100, 0x200, 0,-256,-256,
/*200*/	-256, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x100, 0x100, 0x100, 0x100, 0x100,
/*212*/	 0x100, 0x100,-256, 0, 0,-256, 772,-256,
/*220*/	 0, 0x200, 0x200,-256,-256,-256,-256,-256,-256,-256, 0,-256, 0x200, 0,-256,-256,
/*236*/	-256,-256,-253,-253,
/*240*/	-256,-256, 0,-256, 0x100,-256,-256,-256, 0, 0,-256, 0, 0x100, 0, 0,-256,-256,
/*257*/	-256,-256,-256,
/*260*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*276*/	-256,-256,-256,-256,
/*280*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*296*/	-256,-256,-256,-256,
/*300*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*316*/	-256,-256,-256,-256,
/*320*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*336*/	-256,-256,-256,-256,
/*340*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*356*/	-256,-256,-256,-256,
/*360*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*376*/	-256,-256,-256,-256,
/*380*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*396*/	-256,-256,-256,-256,
/*400*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*416*/	-256,-256,-256,-256,
/*420*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*436*/	-256,-256,-256,-256,
/*440*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*456*/	-256,-256,-256,-256,
/*460*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*476*/	-256,-256,-256,-256,
/*480*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*496*/	-256,-256,-256,-256,
/*500*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*516*/	-256,-256,-256,-256,
/*520*/	-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,-256,
/*536*/	-256,-256,-256,-256,
/*540*/	-256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 1, 3, 3, 3, 3, 3, 3,
/*560*/	 3,-256,-256,-256,-256,-256,-256,-256, 0x200,-256,-244, 0x100, 0, 0,-256, 0,
/*576*/	-256,-256, 0x200,-256,
/*580*/	 0, 0, 0
	};
static char * traceSources[] = {
		"?", "m", "i", "callbackEnter", "callbackLeave", "enterCritical", "exitCritical",
		"resume", "signal", "suspend", "wait", "yield", "eventcheck", "threadsched",
		"ownVM", "bindToThread", "switchIfNecessary", "tryToExecteSmalltalk"
	};
static sqInt (* const pcPreviousToFunction)(sqInt,sqInt) = pcPreviousToinSqueakV3PlusClosuresOrSistaV1Method;
static void (*interruptCheckChain)(void) = 0;
static int (*sHEAFn)() = 0;
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 584 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ (void (*)(void))0,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ primitiveObjectsAccessibleFromRoots,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ (void (*)(void))0,
	/* 108 */ (void (*)(void))0,
	/* 109 */ (void (*)(void))0,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ primitiveCosine,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ primitiveCompareWith,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ primitiveImmediateAsInteger,
	/* 172 */ primitiveFetchNextMourner,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ primitiveGrowMemoryByAtLeast,
	/* 181 */ primitiveSizeInBytesOfInstance,
	/* 182 */ primitiveSizeInBytes,
	/* 183 */ primitiveIsPinned,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ primitiveFullClosureValue,
	/* 208 */ primitiveFullClosureValueWithArgs,
	/* 209 */ primitiveFullClosureValueNoContextSwitch,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveVoidVMStateForMethod,
	/* 216 */ primitiveMethodXray,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ primitiveGetSetFFIExceptionHandling,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ primitiveFloatArrayAt,
	/* 239 */ primitiveFloatArrayAtPut,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ primitiveCoarseUTCMicrosecondClock,
	/* 246 */ primitiveCoarseLocalMicrosecondClock,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ primitiveArrayBecomeOneWayNoCopyHash,
	/* 249 */ primitiveArrayBecomeOneWayCopyHashArg,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ primitiveCollectCogCodeConstituents,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ primitiveSmallFloatAdd,
	/* 542 */ primitiveSmallFloatSubtract,
	/* 543 */ primitiveSmallFloatLessThan,
	/* 544 */ primitiveSmallFloatGreaterThan,
	/* 545 */ primitiveSmallFloatLessOrEqual,
	/* 546 */ primitiveSmallFloatGreaterOrEqual,
	/* 547 */ primitiveSmallFloatEqual,
	/* 548 */ primitiveSmallFloatNotEqual,
	/* 549 */ primitiveSmallFloatMultiply,
	/* 550 */ primitiveSmallFloatDivide,
	/* 551 */ primitiveSmallFloatTruncated,
	/* 552 */ primitiveSmallFloatFractionalPart,
	/* 553 */ primitiveSmallFloatExponent,
	/* 554 */ primitiveSmallFloatTimesTwoPower,
	/* 555 */ primitiveSmallFloatSquareRoot,
	/* 556 */ primitiveSmallFloatSine,
	/* 557 */ primitiveSmallFloatArctan,
	/* 558 */ primitiveSmallFloatLogN,
	/* 559 */ primitiveSmallFloatExp,
	/* 560 */ primitiveSmallFloatCosine,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ primitiveSuspendBackingUpV1,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ primitiveHighBit,
	/* 576 */ (void (*)(void))0,
	/* 577 */ (void (*)(void))0,
	/* 578 */ primitiveSuspendBackingUpV2,
	/* 579 */ (void (*)(void))0,
	/* 580 */ primitivePinnedNew,
	/* 581 */ primitivePinnedNewWithArg,
	/* 582 */ primitiveUninitializedNewWithArg,
 0 };
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
sqInt checkForLeaks;
sqInt maxLiteralCountForCompile = MaxLiteralCountForCompile /* 60 */;
sqInt debugCallbackPath;
char * primTracePluginName;
sqInt breakLookupClassTag;
sqInt breakSelectorLength = MinSmallInteger;
void * displayBits;
sqInt primitiveDoMixedArithmetic = -1;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
sqInt desiredCogCodeSize;
sqInt eventTraceMask;
char * breakSelector;
usqInt maxOldSpaceSize;
sqInt suppressHeartbeatFlag;
sqInt ffiExceptionResponse;
usqInt heapBase;
sqInt inIOProcessEvents;
sqInt upscaleDisplayIfHighDPI = -1;
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
sqInt sendWheelEvents;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
sqInt cannotDeferDisplayUpdates;
sqInt checkedPluginName;
const char *interpreterVersion = "Open Smalltalk Cog[Spur] VM [CoInterpreterPrimitives VMMaker.oscog-eem.3455]";
sqInt minBackwardJumpCountForCompile = MinBackwardJumpCountForCompile /* 40 */;
int displayWidth;
int displayDepth;
int displayHeight;
char expensiveAsserts = 0;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);
volatile int sendTrace;


/*** Macros ***/
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define compilationBreakpointclassTagisMNUCase(sel, classTag, isMNU) do { \
	if (numBytesOf(sel) == (isMNU ? -breakSelectorLength : breakSelectorLength) \
	 && !strncmp((char *)((sel) + BaseHeaderSize), breakSelector, (isMNU ? -breakSelectorLength : breakSelectorLength))) { \
		suppressHeartbeatFlag = 1; \
		compilationBreakpointFor(sel); \
	} \
} while (0)
#define compilationBreakpointisMNUCase(sel, isMNU) do { \
	if (numBytesOf(sel) == (isMNU ? -breakSelectorLength : breakSelectorLength) \
	 && !strncmp((char *)((sel) + BaseHeaderSize), breakSelector, (isMNU ? -breakSelectorLength : breakSelectorLength))) { \
		suppressHeartbeatFlag = 1; \
		compilationBreakpointFor(sel); \
	} \
} while (0)
#define getDesiredCogCodeSize() integerObjectOf(desiredCogCodeSize)
#define heapBase() heapBase
#define pageIndexForstackBasePlus1bytesPerPage(pointer,stkBasePlus1,pageByteSize) (((char *)(pointer) - (stkBasePlus1)) / (pageByteSize))
#define startOfMemory() heapBase
#define numTagBits() 3
#define shiftForWord() 3
#define smallFloatExponentBits() 8
#define smallFloatExponentOffset() 896
#define smallFloatMantissaBits() 52
#define smallFloatTag() 4
#define tagMask() 0x7
#define wordSize() 8
#define eden() GIV(eden)
#define futureSpace() GIV(futureSpace)
#define futureSurvivorStart() GIV(futureSurvivorStart)
#define pastSpace() GIV(pastSpace)
#define rememberedSetLimit() GIV(rememberedSetLimit)
#define rememberedSetSize() GIV(rememberedSetSize)
#define arrayClassIndexPun() 16
#define arrayFormat() 2
#define characterTag() 2
#define classIndexMask() 0x3FFFFF
#define classIsItselfClassIndexPun() 31
#define classTableFirstPage() classTableFirstPage
#define classTableMajorIndexShift() 10
#define endOfMemory() GIV(endOfMemory)
#define extraAlignedBitShift() 24
#define firstByteFormat() 16
#define firstClassIndexPun() 16
#define firstCompiledMethodFormat() 24
#define firstLongFormat() 10
#define firstShortFormat() 12
#define fixedFieldsFieldWidth() 16
#define formatFieldWidthShift() 5
#define formatMask() 0x1F
#define formatShift() 24
#define freeStart() GIV(freeStart)
#define greyBitShift() 31
#define identityHashFullWordShift() 32
#define identityHashHalfWordMask() 0x3FFFFF
#define immutableBitShift() 23
#define indexablePointersFormat() 3
#define isForwardedObjectClassIndexPun() 8
#define isFreeObjectClassIndexPun() 0
#define lastClassIndexPun() 31
#define markedBitFullShift() 55
#define markedBitHalfShift() 23
#define maxOldSpaceSize() maxOldSpaceSize
#define numSlotsFullShift() 56
#define numSlotsHalfShift() 24
#define numSlotsMask() 0xFF
#define oldSpaceStart() GIV(oldSpaceStart)
#define pastSpaceStart() GIV(pastSpaceStart)
#define pinnedBitShift() 30
#define remapBufferCount() GIV(remapBufferCount)
#define rememberedBitShift() 29
#define rootTableCapacity() GIV(rememberedSetLimit)
#define rootTableCount() GIV(rememberedSetSize)
#define segmentBridgePun() 3
#define sixtyFourBitIndexableFormat() 9
#define sixtyFourBitLongsClassIndexPun() 19
#define smallIntegerTag() 1
#define specialObjectsOop() specialObjectsOop
#define thirtyTwoBitLongsClassIndexPun() 18
#define weakArrayClassIndexPun() 17
#define weakArrayFormat() 4
#define numSegments() GIV(numSegments)
#define segments() GIV(segments)
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define cr() fputc('\n',transcript)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define enterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define initialEnterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define primitiveDoMixedArithmetic() primitiveDoMixedArithmetic
#define primTraceLogIndex(aValue) (GIV(primTraceLogIndex) = (aValue))
#define printChar(aCharacter) fputc(aCharacter,transcript)
#define remoteIsInstVarAccess() 128
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


/*** Methods ***/


/*	This is the main interpreter loop.
	In a pure interpreter it loops forever, fetching and executing bytecodes.
	With the Cogit JIT executing code as well, the interpreter is reentered
	from machine code
	whenever the machine code wants to interpret a method instead of executing
	its machine
	code. Entry into the interpreter is done via a ''jump call'' in machine
	code that uses
	CFramePointer and CStackPointer to find the base of the C stack (set in
	CoInterpreter>> enterSmalltalkExecutiveImplementation) and substitutes
	CReturnAddress as the return
	address in the code so it always appears that interpret has been called
	from CoInterpreter>>enterSmalltalkExecutiveImplementation, which may be
	important to,
	for example, C exception handling inside the VM.
	
	When running in the context of a browser plugin VM the interpreter must
	return control
	to the browser periodically. This should done only when the state of the
	currently running
	Squeak thread is safely stored in the object heap. Since this is the case
	at the moment
	that a check for interrupts is performed, that is when we return to the
	browser if it is time
	to do so. Interrupt checks happen quite frequently. */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* CoInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
	register sqInt currentBytecode CB_REG;
    sqInt extA;
    sqInt extB;
    sqInt lkupClassTag;
	register char *localFP FP_REG;
	register char *localIP IP_REG;
    sqInt localReturnValue;
	register char *localSP SP_REG;
    sqInt numExtB;
    sqInt stackPageBytes;
    sqInt stackZoneBytes;
    void *theStackMemory;
    JUMP_TABLE;

#if MULTIPLEBYTECODESETS
	if(!asserta((sizeof(jumpTable)/sizeof(jumpTable[0])) >= 512))
		error("bytecode jumpTable too small");
#endif

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		if (!GIV(pages)) {
			stackPageBytes = stackPageByteSize();
			stackZoneBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
			theStackMemory = alloca(stackZoneBytes);
			memset(theStackMemory, 0, stackZoneBytes);
			initializeStacknumSlotspageSize(theStackMemory, stackZoneBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		}
		loadInitialContext();
		ioInitHeartbeat();
		initialEnterSmalltalkExecutive();
		return null;
	}
	assert((!GIV(CReturnAddress))
	 || (GIV(CReturnAddress) == (((usqIntptr_t) (getReturnAddress())))));
	GIV(CReturnAddress) = ((usqIntptr_t) (getReturnAddress()));
	browserPluginInitialiseIfNeeded();
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	/* begin setMethod: */
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	assert(!((GIV(instructionPointer) == (ceReturnToInterpreterPC()))));
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1, __LINE__);
	/* begin internalizeIPandSP */
	assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin initExtensions */
	extA = (numExtB = (extB = 0));
	currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
	while (1) {
		/* begin dispatchBytecode */
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		CASE(0)   // pushReceiverVariableBytecode
		CASE(256) // 0	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize));
			}
			BREAK;
		CASE(1)   // pushReceiverVariableBytecode
		CASE(257) // 1	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(2)   // pushReceiverVariableBytecode
		CASE(258) // 2	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 16 /* 2 << 3 */));
			}
			BREAK;
		CASE(3)   // pushReceiverVariableBytecode
		CASE(259) // 3	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 24 /* 3 << 3 */));
			}
			BREAK;
		CASE(4)   // pushReceiverVariableBytecode
		CASE(260) // 4	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 32 /* 4 << 3 */));
			}
			BREAK;
		CASE(5)   // pushReceiverVariableBytecode
		CASE(261) // 5	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 40 /* 5 << 3 */));
			}
			BREAK;
		CASE(6)   // pushReceiverVariableBytecode
		CASE(262) // 6	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 48 /* 6 << 3 */));
			}
			BREAK;
		CASE(7)   // pushReceiverVariableBytecode
		CASE(263) // 7	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 56 /* 7 << 3 */));
			}
			BREAK;
		CASE(8)   // pushReceiverVariableBytecode
		CASE(264) // 8	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 64 /* 8 << 3 */));
			}
			BREAK;
		CASE(9)   // pushReceiverVariableBytecode
		CASE(265) // 9	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 72 /* 9 << 3 */));
			}
			BREAK;
		CASE(10)  // pushReceiverVariableBytecode
		CASE(266) // 10	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 80 /* 10 << 3 */));
			}
			BREAK;
		CASE(11)  // pushReceiverVariableBytecode
		CASE(267) // 11	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 88 /* 11 << 3 */));
			}
			BREAK;
		CASE(12)  // pushReceiverVariableBytecode
		CASE(268) // 12	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 96 /* 12 << 3 */));
			}
			BREAK;
		CASE(13)  // pushReceiverVariableBytecode
		CASE(269) // 13	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 104 /* 13 << 3 */));
			}
			BREAK;
		CASE(14)  // pushReceiverVariableBytecode
		CASE(270) // 14	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 112 /* 14 << 3 */));
			}
			BREAK;
		CASE(15)  // pushReceiverVariableBytecode
		CASE(271) // 15	pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + 120 /* 15 << 3 */));
			}
			BREAK;
		CASE(16)  // pushTemporaryVariableBytecode
		CASE(320) // 64	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (0 /* 16 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + (frameNumArgs * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + (frameNumArgs * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(17)  // pushTemporaryVariableBytecode
		CASE(321) // 65	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (1 /* 17 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* 17 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* 17 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(18)  // pushTemporaryVariableBytecode
		CASE(322) // 66	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (2 /* 18 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* 18 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* 18 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(19)  // pushTemporaryVariableBytecode
		CASE(323) // 67	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (3 /* 19 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* 19 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* 19 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(20)  // pushTemporaryVariableBytecode
		CASE(324) // 68	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (4 /* 20 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* 20 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* 20 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(21)  // pushTemporaryVariableBytecode
		CASE(325) // 69	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (5 /* 21 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* 21 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* 21 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(22)  // pushTemporaryVariableBytecode
		CASE(326) // 70	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (6 /* 22 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* 22 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* 22 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(23)  // pushTemporaryVariableBytecode
		CASE(327) // 71	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (7 /* 23 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* 23 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* 23 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(24)  // pushTemporaryVariableBytecode
		CASE(328) // 72	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (8 /* 24 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* 24 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* 24 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(25)  // pushTemporaryVariableBytecode
		CASE(329) // 73	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (9 /* 25 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* 25 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* 25 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(26)  // pushTemporaryVariableBytecode
		CASE(330) // 74	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (10 /* 26 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* 26 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* 26 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(27)  // pushTemporaryVariableBytecode
		CASE(331) // 75	pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (11 /* 27 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* 27 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* 27 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(28)  // pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (12 /* 28 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* 28 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* 28 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(29)  // pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (13 /* 29 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* 29 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* 29 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(30)  // pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (14 /* 30 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* 30 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* 30 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(31)  // pushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (15 /* 31 bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* 31 bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* 31 bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(32)  // pushLiteralConstantBytecode
		CASE(288) // 32	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* 1 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(33)  // pushLiteralConstantBytecode
		CASE(289) // 33	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* 2 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(34)  // pushLiteralConstantBytecode
		CASE(290) // 34	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* 3 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(35)  // pushLiteralConstantBytecode
		CASE(291) // 35	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* 4 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(36)  // pushLiteralConstantBytecode
		CASE(292) // 36	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* 5 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(37)  // pushLiteralConstantBytecode
		CASE(293) // 37	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* 6 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(38)  // pushLiteralConstantBytecode
		CASE(294) // 38	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* 7 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(39)  // pushLiteralConstantBytecode
		CASE(295) // 39	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* 8 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(40)  // pushLiteralConstantBytecode
		CASE(296) // 40	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* 9 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(41)  // pushLiteralConstantBytecode
		CASE(297) // 41	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* 10 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(42)  // pushLiteralConstantBytecode
		CASE(298) // 42	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* 11 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(43)  // pushLiteralConstantBytecode
		CASE(299) // 43	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* 12 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(44)  // pushLiteralConstantBytecode
		CASE(300) // 44	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* 13 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(45)  // pushLiteralConstantBytecode
		CASE(301) // 45	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* 14 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(46)  // pushLiteralConstantBytecode
		CASE(302) // 46	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* 15 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(47)  // pushLiteralConstantBytecode
		CASE(303) // 47	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* 16 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(48)  // pushLiteralConstantBytecode
		CASE(304) // 48	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 136 /* 17 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(49)  // pushLiteralConstantBytecode
		CASE(305) // 49	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 144 /* 18 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(50)  // pushLiteralConstantBytecode
		CASE(306) // 50	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 152 /* 19 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(51)  // pushLiteralConstantBytecode
		CASE(307) // 51	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 160 /* 20 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(52)  // pushLiteralConstantBytecode
		CASE(308) // 52	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 168 /* 21 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(53)  // pushLiteralConstantBytecode
		CASE(309) // 53	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 176 /* 22 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(54)  // pushLiteralConstantBytecode
		CASE(310) // 54	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 184 /* 23 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(55)  // pushLiteralConstantBytecode
		CASE(311) // 55	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 192 /* 24 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(56)  // pushLiteralConstantBytecode
		CASE(312) // 56	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 200 /* 25 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(57)  // pushLiteralConstantBytecode
		CASE(313) // 57	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 208 /* 26 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(58)  // pushLiteralConstantBytecode
		CASE(314) // 58	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 216 /* 27 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(59)  // pushLiteralConstantBytecode
		CASE(315) // 59	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 224 /* 28 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(60)  // pushLiteralConstantBytecode
		CASE(316) // 60	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 232 /* 29 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(61)  // pushLiteralConstantBytecode
		CASE(317) // 61	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 240 /* 30 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(62)  // pushLiteralConstantBytecode
		CASE(318) // 62	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* 31 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(63)  // pushLiteralConstantBytecode
		CASE(319) // 63	pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 0x100 /* 32 << 3 */);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(64)  // pushLiteralVariableBytecode
		CASE(272) // 16	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 8 /* 1 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(1 /* 0 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(65)  // pushLiteralVariableBytecode
		CASE(273) // 17	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 16 /* 2 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(2 /* 1 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(66)  // pushLiteralVariableBytecode
		CASE(274) // 18	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 24 /* 3 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(3 /* 2 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(67)  // pushLiteralVariableBytecode
		CASE(275) // 19	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 32 /* 4 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(4 /* 3 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(68)  // pushLiteralVariableBytecode
		CASE(276) // 20	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 40 /* 5 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(5 /* 4 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(69)  // pushLiteralVariableBytecode
		CASE(277) // 21	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 48 /* 6 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(6 /* 5 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(70)  // pushLiteralVariableBytecode
		CASE(278) // 22	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 56 /* 7 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(7 /* 6 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(71)  // pushLiteralVariableBytecode
		CASE(279) // 23	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 64 /* 8 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(8 /* 7 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(72)  // pushLiteralVariableBytecode
		CASE(280) // 24	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 72 /* 9 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(9 /* 8 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(73)  // pushLiteralVariableBytecode
		CASE(281) // 25	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 80 /* 10 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(10 /* 9 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(74)  // pushLiteralVariableBytecode
		CASE(282) // 26	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 88 /* 11 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(11 /* 10 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(75)  // pushLiteralVariableBytecode
		CASE(283) // 27	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 96 /* 12 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(12 /* 11 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(76)  // pushLiteralVariableBytecode
		CASE(284) // 28	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 104 /* 13 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(13 /* 12 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(77)  // pushLiteralVariableBytecode
		CASE(285) // 29	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 112 /* 14 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(14 /* 13 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(78)  // pushLiteralVariableBytecode
		CASE(286) // 30	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 120 /* 15 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(15 /* 14 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(79)  // pushLiteralVariableBytecode
		CASE(287) // 31	pushLiteralVariable16CasesBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 128 /* 16 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(16 /* 15 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(80)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 136 /* 17 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(17 /* 16 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(81)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 144 /* 18 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(18 /* 17 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(82)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 152 /* 19 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(19 /* 18 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(83)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 160 /* 20 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(20 /* 19 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(84)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 168 /* 21 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(21 /* 20 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(85)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 176 /* 22 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(22 /* 21 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(86)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 184 /* 23 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(23 /* 22 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(87)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 192 /* 24 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(24 /* 23 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(88)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 200 /* 25 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(25 /* 24 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(89)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 208 /* 26 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(26 /* 25 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(90)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 216 /* 27 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(27 /* 26 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(91)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 224 /* 28 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(28 /* 27 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(92)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 232 /* 29 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(29 /* 28 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(93)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 240 /* 30 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(30 /* 29 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(94)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 0xF8 /* 31 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(0x1F /* 30 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(95)  // pushLiteralVariableBytecode
			{
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				objOop = longAt((GIV(method) + BaseHeaderSize) + 0x100 /* 32 << 3 */);
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(32 /* 31 + 1 */, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 8 /* 1 << 3 */));
			}
			BREAK;
		CASE(96)  // storeAndPopReceiverVariableBytecode
		CASE(97)  // storeAndPopReceiverVariableBytecode
		CASE(98)  // storeAndPopReceiverVariableBytecode
		CASE(99)  // storeAndPopReceiverVariableBytecode
		CASE(100) // storeAndPopReceiverVariableBytecode
		CASE(101) // storeAndPopReceiverVariableBytecode
		CASE(102) // storeAndPopReceiverVariableBytecode
		CASE(103) // storeAndPopReceiverVariableBytecode
		CASE(456) // 200	storeAndPopReceiverVariableBytecode
		CASE(457) // 201	storeAndPopReceiverVariableBytecode
		CASE(458) // 202	storeAndPopReceiverVariableBytecode
		CASE(459) // 203	storeAndPopReceiverVariableBytecode
		CASE(460) // 204	storeAndPopReceiverVariableBytecode
		CASE(461) // 205	storeAndPopReceiverVariableBytecode
		CASE(462) // 206	storeAndPopReceiverVariableBytecode
		CASE(463) // 207	storeAndPopReceiverVariableBytecode
			{
				sqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				rcvr = longAt(localFP + FoxIFReceiver);
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
#        if IMMUTABILITY
				assert(!((isImmediate(rcvr))));
				if (((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					longAtPointerput((localSP -= BytesPerOop), top);
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(instVarIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l2;
				}
#        endif // IMMUTABILITY

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(rcvr)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(top & (tagMask()))))
					 && (oopisLessThan(top, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(instVarIndex) << (shiftForWord())))), top);
	l2:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(104) // storeAndPopTemporaryVariableBytecode
		CASE(464) // 208	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (0 /* 104 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + (frameNumArgs * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + (frameNumArgs * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(105) // storeAndPopTemporaryVariableBytecode
		CASE(465) // 209	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (1 /* 105 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* 105 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* 105 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(106) // storeAndPopTemporaryVariableBytecode
		CASE(466) // 210	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (2 /* 106 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* 106 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* 106 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(107) // storeAndPopTemporaryVariableBytecode
		CASE(467) // 211	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (3 /* 107 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* 107 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* 107 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(108) // storeAndPopTemporaryVariableBytecode
		CASE(468) // 212	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (4 /* 108 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* 108 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* 108 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(109) // storeAndPopTemporaryVariableBytecode
		CASE(469) // 213	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (5 /* 109 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* 109 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* 109 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(110) // storeAndPopTemporaryVariableBytecode
		CASE(470) // 214	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (6 /* 110 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* 110 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* 110 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(111) // storeAndPopTemporaryVariableBytecode
		CASE(471) // 215	storeAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (7 /* 111 bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* 111 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* 111 bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(112) // pushReceiverBytecode
		CASE(332) // 76	pushReceiverBytecode
			{
				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), longAt(localFP + FoxIFReceiver));
			}
			BREAK;
		CASE(113) // pushConstantTrueBytecode
		CASE(333) // 77	pushConstantTrueBytecode
			{
				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
			BREAK;
		CASE(114) // pushConstantFalseBytecode
		CASE(334) // 78	pushConstantFalseBytecode
			{
				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
			BREAK;
		CASE(115) // pushConstantNilBytecode
		CASE(335) // 79	pushConstantNilBytecode
			{
				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
			}
			BREAK;
		CASE(116) // pushConstantMinusOneBytecode
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			BREAK;
		CASE(117) // pushConstantZeroBytecode
		CASE(336) // 80	pushConstantZeroBytecode
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			BREAK;
		CASE(118) // pushConstantOneBytecode
		CASE(337) // 81	pushConstantOneBytecode
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			BREAK;
		CASE(119) // pushConstantTwoBytecode
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			BREAK;
		CASE(120) // returnReceiver
			{
				VM_LABEL(returnReceiver);
				localReturnValue = longAt(localFP + FoxIFReceiver);
				/* goto commonReturn */;
			}
			
		commonReturn:
			/* commonReturn */
			{
				sqInt aMethodObj;
				sqInt callerContextOrNil;
				sqInt callerContextOrNil1;
				sqInt callerContextOrNil2;
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt objOop;
				sqInt objOop1;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt ourContext3;
				sqInt senderOop;
				sqInt senderOop1;
				char *theFP;
				char *theFP1;
				char *theFP2;
				StackPage *thePage;
				StackPage *thePage1;
				StackPage *thePage2;
				StackPage *thePage3;
				sqInt unwindContextOrNilOrZero;

				VM_LABEL(commonReturn);
				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = ((char *) 0);
				if (!((byteAt((localFP + FoxIFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l210;
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				closure = longAt(localFP + (frameStackedReceiverOffset(localFP)));
				/* avoid compiler warning */
				/* Walk the closure's lexical chain to find the context or frame to return from (home).
				   If home is missing (Sista closures) then throw cannotReturn rather than crash. */
				home = null;
				while (closure != GIV(nilObj)) {
					/* begin followObjField:ofObject: */
					objOop = longAt((closure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
					assert(isNonImmediate(objOop));
					if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, closure, objOop);
					}
					home = objOop;
					if (!(						/* begin isContext: */
							((!(home & (tagMask()))))
						 && (((longAt(home)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
						/* begin internalCannotReturn: */
						if (						/* begin frameHasContext: */
							((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
							? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
							: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
							assert(isContext(frameContext(localFP)));
							ourContext = longAt(localFP + FoxThisContext);
							goto l215;
						}
						ourContext = marryFrameSP(localFP, localSP);
	l215:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext);
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l210;
					}
					/* begin followObjField:ofObject: */
					objOop1 = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))));
					assert(isNonImmediate(objOop1));
					if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, home, objOop1);
					}
					closure = objOop1;
				}
				unwindContextOrNilOrZero = findUnwindThroughContext(home);
				if (unwindContextOrNilOrZero == GIV(nilObj)) {
					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					if (					/* begin frameHasContext: */
						((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l227;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
	l227:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l210;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					if (					/* begin frameHasContext: */
						((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						ourContext2 = longAt(localFP + FoxThisContext);
						goto l216;
					}
					ourContext2 = marryFrameSP(localFP, localSP);
	l216:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext2);
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAboutToReturn) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l210;
				}
				contextToReturnTo = null;
				if (((((longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - (smallIntegerTag()));
					if ((longAt(theFP + FoxSavedFP)) == 0) {
						/* begin frameCallerContext: */
						assert(isBaseFrame(theFP));
						thePage1 = stackPageAtpages(
							(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
						callerContextOrNil = longAt((thePage1->baseAddress));
						assert(addressCouldBeObj(callerContextOrNil));
						assert((callerContextOrNil == (nilObject()))
						 || (isContext(followMaybeForwarded(callerContextOrNil))));
						contextToReturnTo = callerContextOrNil;
					}
					else {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
					if ((					/* begin isContext: */
						((!(contextToReturnTo & (tagMask()))))
					 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))
					 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop1) & 7) == 1));
						frameToReturnTo = pointerForOop(senderOop1 - (smallIntegerTag()));
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					frameToReturnTo = establishFrameForContextToReturnTo(contextToReturnTo);
					if (frameToReturnTo == 0) {
						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						if (						/* begin frameHasContext: */
							((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
							? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
							: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
							assert(isContext(frameContext(localFP)));
							ourContext3 = longAt(localFP + FoxThisContext);
							goto l218;
						}
						ourContext3 = marryFrameSP(localFP, localSP);
	l218:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext3);
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l210;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				newPage = stackPageAtpages(
					(assert((((((char *) frameToReturnTo)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) frameToReturnTo)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(frameToReturnTo, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				if (newPage != GIV(stackPage)) {
					theFP1 = (GIV(stackPage)->baseFP);
					/* begin frameCallerContext: */
					assert(isBaseFrame(theFP1));
					thePage2 = stackPageAtpages(
						(assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages)))))),
						pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage))),
						GIV(pages));
					callerContextOrNil1 = longAt((thePage2->baseAddress));
					assert(addressCouldBeObj(callerContextOrNil1));
					assert((callerContextOrNil1 == (nilObject()))
					 || (isContext(followMaybeForwarded(callerContextOrNil1))));
					currentCtx = callerContextOrNil1;
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
							/* begin stackPageFor: */
							thePage = stackPageAtpages(
								(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
								pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
								GIV(pages));
							if (theFP != ((thePage->headFP))) {
								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							theFP2 = (thePage->baseFP);
							/* begin frameCallerContext: */
							assert(isBaseFrame(theFP2));
							thePage3 = stackPageAtpages(
								(assert((((((char *) theFP2)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP2)) <= (((char *) GIV(pages)))))),
								pageIndexForstackBasePlus1bytesPerPage(theFP2, GIV(stackBasePlus1), GIV(bytesPerPage))),
								GIV(pages));
							callerContextOrNil2 = longAt((thePage3->baseAddress));
							assert(addressCouldBeObj(callerContextOrNil2));
							assert((callerContextOrNil2 == (nilObject()))
							 || (isContext(followMaybeForwarded(callerContextOrNil2))));
							currentCtx = callerContextOrNil2;
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							assert(!(isOopForwarded(currentCtx)));
							longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isOopForwarded(currentCtx)));
							longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {
					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((/* begin frameCallerSP: */
	assert(!(isBaseFrame(callerFP))),
(callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord)) - BytesPerWord;
				}
				/* begin maybeReturnToMachineCodeFrame */
				if ((((usqInt)localIP)) < (startOfMemory())) {
					if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {
						/* localIP in the cog method zone indicates a return to machine code. */
						/* begin returnToMachineCodeFrame */
						assertCStackWellAligned();
						assert((((usqInt)localIP)) < (startOfMemory()));
						assert(isMachineCodeFrame(localFP));
						assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 0, __LINE__);
						/* begin internalStackTopPut: */
						longAtPointerput(localSP, localIP);
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						ceEnterCogCodePopReceiverReg();
						goto l214;
					}
					localIP = pointerForOop(((usqInt)(longAt(localFP + FoxIFSavedIP))));
				}
	l214:	/* end maybeReturnToMachineCodeFrame */;
				aMethodObj = longAt(localFP + FoxMethod);
				/* begin setMethod: */
				assert((((usqInt)aMethodObj)) >= (startOfMemory()));
				GIV(method) = aMethodObj;
				assert(isOopCompiledMethod(GIV(method)));
				if (methodUsesAlternateBytecodeSet(GIV(method))) {
					GIV(bytecodeSetSelector) = 0x100;
				}
				else {
					GIV(bytecodeSetSelector) = 0;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput(localSP, localReturnValue);
			}
	l210:;
			BREAK;
		CASE(121) // returnTrue
		CASE(345) // 89	returnTrue
			{
				VM_LABEL(returnTrue);
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			BREAK;
		CASE(122) // returnFalse
		CASE(346) // 90	returnFalse
			{
				VM_LABEL(returnFalse);
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			BREAK;
		CASE(123) // returnNil
		CASE(347) // 91	returnNil
			{
				VM_LABEL(returnNil);
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			BREAK;
		CASE(124) // returnTopFromMethod
		CASE(348) // 92	returnTopFromMethod
			{
				VM_LABEL(returnTopFromMethod);
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			BREAK;
		CASE(125) // returnTopFromBlock
			{
				VM_LABEL(returnTopFromBlock);
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */;
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				sqInt aMethodObj;
				sqInt aMethodObj1;
				sqInt callerContextOrNil;
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnFrom;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				StackPage *lruOrFree;
				StackPage *newPage;
				sqInt retToContext;
				sqInt senderOop;
				char *sp;
				char *sp1;
				char *sp2;
				char *theFP;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				/* TODO: Store/restore the nativeSP more properly, when it exists */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {
					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					assert(isBaseFrame(localFP));
					thePage1 = stackPageAtpages(
						(assert((((((char *) localFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) localFP)) <= (((char *) GIV(pages)))))),
						pageIndexForstackBasePlus1bytesPerPage(localFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
						GIV(pages));
					callerContextOrNil = longAt((thePage1->baseAddress));
					assert(addressCouldBeObj(callerContextOrNil));
					assert((callerContextOrNil == (nilObject()))
					 || (isContext(followMaybeForwarded(callerContextOrNil))));
					contextToReturnTo = callerContextOrNil;
					freeStackPageNoAssert(GIV(stackPage));
					retToContext = 
					/* begin isContext: */
((!(contextToReturnTo & (tagMask()))))
					 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex);
					if (retToContext
					 && (					/* begin isStillMarriedContext: */
						(((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop) & 7) == 1));
						theFP = pointerForOop(senderOop - (smallIntegerTag()));
						/* begin stackPageFor: */
						thePage = stackPageAtpages(
							(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
						}
						else {
							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l230;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l230;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
	l230:	/* end findFrameAbove:inPage: */;
							/* begin newStackPage */
							lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
							if (((lruOrFree->baseFP)) == 0) {
								newPage = lruOrFree;
								goto l233;
							}
							divorceFramesIn(lruOrFree);
							newPage = lruOrFree;
	l233:	/* end newStackPage */;
							assert(newPage == GIV(stackPage));
							moveFramesInthroughtoPage(thePage, frameAbove, newPage);
							markStackPageMostRecentlyUsed(newPage);
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(retToContext
							 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1)))) {
							contextToReturnFrom = longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord);
							tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(contextToReturnFrom, contextToReturnTo, localReturnValue);
							/* begin externalCannotReturn:from: */
							longAtput((sp = GIV(stackPointer) - BytesPerWord), contextToReturnFrom);
							GIV(stackPointer) = sp;
							/* begin push: */
							longAtput((sp1 = GIV(stackPointer) - BytesPerWord), localReturnValue);
							GIV(stackPointer) = sp1;
							/* begin push: */
							longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
							GIV(stackPointer) = sp2;
							ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), contextToReturnFrom, 1);
							goto l228;
						}
						GIV(instructionPointer) = 0;
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
					}
					/* begin setStackPageAndLimit: */
					assert(thePage);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					localIP = pointerForOop(longAtPointer(localSP));
					if ((((usqInt)localIP)) < (startOfMemory())) {
						if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {
							/* localIP in the cog method zone indicates a return to machine code. */
							/* begin returnToMachineCodeFrame */
							assertCStackWellAligned();
							assert((((usqInt)localIP)) < (startOfMemory()));
							assert(isMachineCodeFrame(localFP));
							assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 0, __LINE__);
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, localIP);
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							assert((localSP < ((GIV(stackPage)->baseAddress)))
							 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							ceEnterCogCodePopReceiverReg();
							goto l228;
						}
						localIP = pointerForOop(((usqInt)(longAt(localFP + FoxIFSavedIP))));
					}
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					aMethodObj1 = longAt(localFP + FoxMethod);
					/* begin setMethod: */
					assert((((usqInt)aMethodObj1)) >= (startOfMemory()));
					GIV(method) = aMethodObj1;
					assert(isOopCompiledMethod(GIV(method)));
					GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
						? 0x100
						: 0);
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, localReturnValue);
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l228;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + (frameStackedReceiverOffset(localFP));
				localFP = callersFPOrNull;
				if ((((usqInt)localIP)) < (startOfMemory())) {
					if ((((usqInt)localIP)) != (ceReturnToInterpreterPC())) {
						/* localIP in the cog method zone indicates a return to machine code. */
						/* begin returnToMachineCodeFrame */
						assertCStackWellAligned();
						assert((((usqInt)localIP)) < (startOfMemory()));
						assert(isMachineCodeFrame(localFP));
						assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 0, __LINE__);
						/* begin internalStackTopPut: */
						longAtPointerput(localSP, localIP);
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						ceEnterCogCodePopReceiverReg();
						goto l228;
					}
					localIP = pointerForOop(((usqInt)(longAt(localFP + FoxIFSavedIP))));
				}
				aMethodObj = longAt(localFP + FoxMethod);
				/* begin setMethod: */
				assert((((usqInt)aMethodObj)) >= (startOfMemory()));
				GIV(method) = aMethodObj;
				assert(isOopCompiledMethod(GIV(method)));
				if (methodUsesAlternateBytecodeSet(GIV(method))) {
					GIV(bytecodeSetSelector) = 0x100;
				}
				else {
					GIV(bytecodeSetSelector) = 0;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput(localSP, localReturnValue);
			}
	l228:;
			BREAK;
		CASE(126) // unknownBytecode
		CASE(127) // unknownBytecode
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */;
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				usqInt numSlots;
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = 
				/* begin maybeSplObj: */
(SelectorUnknownBytecode < ((assert((classIndexOf(GIV(specialObjectsOop))) > (isForwardedObjectClassIndexPun())),
				(((numSlots = byteAt(GIV(specialObjectsOop) + 7))) == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(GIV(specialObjectsOop) - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorUnknownBytecode) << (shiftForWord())))))
					: 0);
				if ((!GIV(messageSelector))
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l235;
				}
				ourContext = marryFrameSP(localFP, localSP);
	l235:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			BREAK;
		CASE(128) // extendedPushBytecode
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt object;
				sqInt object1;
				sqInt objOop;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				variableType = (((usqInt)(descriptor)) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxIFReceiver)) + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord()))))));
					goto l4;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l4;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l4;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					objOop = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));
					assert(isNonImmediate(objOop));
					if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop = fixFollowedFieldofObjectwithInitialValue(variableIndex + LiteralStart, GIV(method), objOop);
					}
					litVar = objOop;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord()))))));
					goto l4;
				}
			}
	l4:	/* end case */;
			BREAK;
		CASE(129) // extendedStoreBytecode
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				usqInt methodPointer;
				sqInt objOop;
				sqInt objOop1;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				switch ((((usqInt)(descriptor)) >> 6) & 3) {
				case 0:
					objOop = longAt(localFP + FoxIFReceiver);
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(objOop))));
					if (((((usqInt)((longAt(objOop)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), objOop);
						longAtPointerput((localSP -= BytesPerOop), value);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l10;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(objOop)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(objOop)),
					oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(value & (tagMask()))))
						 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(objOop);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
	l10:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					break;
				case 1:
					/* begin itemporary:in:put: */
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					break;
				case 2:
					error("illegal store");
					break;
				case 3:
					/* begin storeLiteralVariable:withValue: */
					methodPointer = GIV(method);
					/* begin followObjField:ofObject: */
					objOop1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));
					assert(isNonImmediate(objOop1));
					if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(variableIndex + LiteralStart, methodPointer, objOop1);
					}
					litVar = objOop1;
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(litVar))));
					if (((((usqInt)((longAt(litVar)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						longAtPointerput((localSP -= BytesPerOop), value);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l7;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(litVar)),
					oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(value & (tagMask()))))
						 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(litVar)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))), value);
	l7:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					break;
				default:
					error("Case not found and no otherwise clause");
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(130) // extendedStoreAndPopBytecode
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				usqInt methodPointer;
				sqInt objOop;
				sqInt objOop1;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				localSP += 1 * BytesPerOop;
				switch ((((usqInt)(descriptor)) >> 6) & 3) {
				case 0:
					objOop = longAt(localFP + FoxIFReceiver);
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(objOop))));
					if (((((usqInt)((longAt(objOop)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), objOop);
						longAtPointerput((localSP -= BytesPerOop), value);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l15;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(objOop)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(objOop)),
					oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(value & (tagMask()))))
						 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(objOop);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
	l15:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					break;
				case 1:
					/* begin itemporary:in:put: */
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					break;
				case 2:
					error("illegal store");
					break;
				case 3:
					/* begin storeLiteralVariable:withValue: */
					methodPointer = GIV(method);
					/* begin followObjField:ofObject: */
					objOop1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));
					assert(isNonImmediate(objOop1));
					if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(variableIndex + LiteralStart, methodPointer, objOop1);
					}
					litVar = objOop1;
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(litVar))));
					if (((((usqInt)((longAt(litVar)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar);
						longAtPointerput((localSP -= BytesPerOop), value);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l12;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(litVar)),
					oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(value & (tagMask()))))
						 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(litVar)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))), value);
	l12:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					break;
				default:
					error("Case not found and no otherwise clause");
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(131) // singleExtendedSendBytecode
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));
				GIV(argumentCount) = ((usqInt)(descriptor)) >> 5;
				/* goto normalSend */;
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(normalSend);
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				lkupClassTag = 
				/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(lkupClassTag != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt classOrInteger;
					sqInt classTablePage;
					sqInt classTablePage1;
					CogMethod *cogMethod;
					CogMethod *cogMethod1;
					sqInt fieldIndex;
					sqInt fieldIndex1;
					sqInt fieldIndex11;
					sqInt fieldIndex2;
					sqInt hash;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt methodHeader1;
					sqInt methodHeader11;
					sqInt methodHeader2;
					sqInt nArgs;
					sqInt numTemps;
					sqInt object;
					sqInt ok;
					sqInt probe;
					sqInt rcvr;
					sqInt rcvr1;
					char *savedFramePointer;
					char *savedStackPointer;
					int succeeded;
					sqInt switched;
					sqInt tagBits;

					VM_LABEL(commonSendOrdinary);
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					/* begin sendBreakpoint:receiver: */
					sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), (((tagBits = rcvr & (tagMask()))) != 0
						? tagBits
						: (longAt(rcvr)) & (classIndexMask())));
					if (recordSendTrace()) {
						/* begin classForClassTag: */
						assert((lkupClassTag >= 0)
						 && ((lkupClassTag <= (tagMask()))
						 || ((lkupClassTag >= (arrayClassIndexPun()))
						 && (lkupClassTag <= (classIndexMask())))));
						fieldIndex = ((usqInt)(lkupClassTag)) >> (classTableMajorIndexShift());
						/* begin fetchPointer:ofObject: */
						classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
						if (classTablePage == GIV(nilObj)) {
							classOrInteger = null;
							goto l243;
						}
						fieldIndex1 = lkupClassTag & ((1U << (classTableMajorIndexShift())) - 1);
						classOrInteger = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l243:	/* end classForClassTag: */;
						/* begin recordTrace:thing:source: */
						GIV(traceLog)[GIV(traceLogIndex)] = classOrInteger;
						GIV(traceLog)[GIV(traceLogIndex) + 1] = GIV(messageSelector);
						GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
						GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
						if (printOnTrace()) {
							printActivationNameForSelectorstartClass(GIV(messageSelector), classForClassTag(lkupClassTag));
							cr();
						}
					}
					/* begin internalFindNewMethodOrdinary */
					/* shift drops two low-order zeros from addresses */
					hash = GIV(messageSelector) ^ (((sqInt)((usqInt)(lkupClassTag) << 2)));
					/* first probe */
					probe = hash & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						ok = 1;
						goto l241;
					}
					/* second probe */
					probe = (((usqInt)(hash)) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						ok = 1;
						goto l241;
					}
					probe = (((usqInt)(hash)) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						ok = 1;
						goto l241;
					}
					ok = 0;
	l241:	/* end inlineLookupInMethodCacheSel:classTag: */;
					if (ok) {
						/* begin ifAppropriateCompileToNativeCode:selector: */
						methodHeader2 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
						if ((						/* begin isCogMethodReference: */
							assert(((((methodHeader2) & 7) == 1))
							 || (((((usqInt)methodHeader2)) < (startOfMemory()))
							 && ((((usqInt)methodHeader2)) >= (minCogMethodAddress())))),
						/* begin isNonIntegerObject: */
(!(methodHeader2 & (smallIntegerTag()))))) {
							/* makeBaseFrame: can create cog methods with nil selectors. */
							cogMethod = ((CogMethod *) methodHeader2);
							if (((cogMethod->selector)) == GIV(nilObj)) {
								setSelectorOfto(cogMethod, GIV(messageSelector));
							}
						}
						else {
							if (((							/* begin literalCountOfMethodHeader: */
								assert((((methodHeader2) & 7) == 1)),
							((methodHeader2 >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
								cogselector(GIV(newMethod), GIV(messageSelector));
							}
							else {
								maybeFlagMethodAsInterpreted(GIV(newMethod));
							}
						}
					}
					else {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						if ((						/* begin isOopForwarded: */
							((!(GIV(messageSelector) & (tagMask()))))
						 && ((!((longAt(GIV(messageSelector))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))
						 || (lkupClassTag == (isForwardedObjectClassIndexPun()))) {
							if (							/* begin isOopForwarded: */
								((!(GIV(messageSelector) & (tagMask()))))
							 && ((!((longAt(GIV(messageSelector))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
								GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
							}
							if (lkupClassTag == (isForwardedObjectClassIndexPun())) {
								lkupClassTag = handleForwardedSendFaultForTag(lkupClassTag);
							}
							if (lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag)) {
								/* begin ifAppropriateCompileToNativeCode:selector: */
								methodHeader11 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
								if ((								/* begin isCogMethodReference: */
									assert(((((methodHeader11) & 7) == 1))
									 || (((((usqInt)methodHeader11)) < (startOfMemory()))
									 && ((((usqInt)methodHeader11)) >= (minCogMethodAddress())))),
								/* begin isNonIntegerObject: */
(!(methodHeader11 & (smallIntegerTag()))))) {
									/* makeBaseFrame: can create cog methods with nil selectors. */
									cogMethod1 = ((CogMethod *) methodHeader11);
									if (((cogMethod1->selector)) == GIV(nilObj)) {
										setSelectorOfto(cogMethod1, GIV(messageSelector));
									}
								}
								else {
									if (((									/* begin literalCountOfMethodHeader: */
										assert((((methodHeader11) & 7) == 1)),
									((methodHeader11 >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
										cogselector(GIV(newMethod), GIV(messageSelector));
									}
									else {
										maybeFlagMethodAsInterpreted(GIV(newMethod));
									}
								}
								goto l240;
							}
						}
						/* begin classForClassTag: */
						assert((lkupClassTag >= 0)
						 && ((lkupClassTag <= (tagMask()))
						 || ((lkupClassTag >= (arrayClassIndexPun()))
						 && (lkupClassTag <= (classIndexMask())))));
						fieldIndex2 = ((usqInt)(lkupClassTag)) >> (classTableMajorIndexShift());
						/* begin fetchPointer:ofObject: */
						classTablePage1 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord())))));
						if (classTablePage1 == GIV(nilObj)) {
							GIV(lkupClass) = null;
							goto l237;
						}
						fieldIndex11 = lkupClassTag & ((1U << (classTableMajorIndexShift())) - 1);
						GIV(lkupClass) = longAt((classTablePage1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex11) << (shiftForWord())))));
	l237:	/* end classForClassTag: */;
						assert((GIV(lkupClass))
						 && (addressCouldBeClassObj(GIV(lkupClass))));
						lookupMethodInClass(GIV(lkupClass));
						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						addNewMethodToCache(GIV(lkupClass));
					}
	l240:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord()))))));
								goto l242;
							}
							if (localPrimIndex == 0x100) {
								goto l242;
							}
							if (localPrimIndex == 0x101) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l242;
							}
							if (localPrimIndex == 258) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l242;
							}
							if (localPrimIndex == 259) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l242;
							}
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 3) | 1));
							goto l242;
						}
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						nArgs = GIV(argumentCount);
						savedStackPointer = GIV(stackPointer);
						savedFramePointer = GIV(framePointer);
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						if (						/* begin recordPrimTraceForMethod: */
							(recordPrimTrace())
						 && ((primTracePluginName == null
							? 1
							: methodHasPrimitiveInPrimTracePlugin(GIV(newMethod))))) {
							/* begin fastLogPrim: */
							GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(newMethod);
							primTraceLogIndex(GIV(primTraceLogIndex) + 1);
						}
						dispatchFunctionPointer(primitiveFunctionPointer);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
						/* begin maybeRetryPrimitiveOnFailure */
						if (GIV(primFailCode)) {
							retryPrimitiveOnFailure();
						}
						if ((!GIV(primFailCode))
						 && ((GIV(framePointer) == savedFramePointer)
						 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))))) {
							/* Don't fail if primitive has done something radical, e.g. perform: */
							if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
								flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
								failUnbalancedPrimitive();
								GIV(stackPointer) = savedStackPointer;
							}
						}
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						succeeded = !GIV(primFailCode);
						if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
							GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
						}
						/* begin internalizeIPandSP */
						assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							returntoExecutive(popStack(), 1);
							browserPluginReturnIfNeeded();
							goto l242;
						}
					}
					/* if not primitive, or primitive failed, activate the method */
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					if (!((						/* begin isCogMethodReference: */
							assert(((((methodHeader) & 7) == 1))
							 || (((((usqInt)methodHeader)) < (startOfMemory()))
							 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
						/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag())))))) {
						/* begin internalActivateNewMethod */
						methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
						assert(!(isCogMethodReference(methodHeader1)));
						numTemps = (((usqInt)(methodHeader1)) >> MethodHeaderTempCountShift) & 0x3F;
						assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader1)));
						/* could new rcvr be set at point of send? */
						rcvr1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
						assert(!(isOopForwarded(rcvr1)));
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localIP);
						longAtPointerput((localSP -= BytesPerOop), localFP);
						localFP = localSP;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
						GIV(method) = GIV(newMethod);
						assert(isOopCompiledMethod(GIV(method)));
						assert((methodHeaderOf(GIV(method))) == methodHeader1);
						GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
							? 0x100
							: 0);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
						object = 
						/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
							? ((1 + (((sqInt)((usqInt)(((((usqInt)(methodHeader1)) >> MethodHeaderArgCountShift) & 15)) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
							: ((1 + (((sqInt)((usqInt)(((((usqInt)(methodHeader1)) >> MethodHeaderArgCountShift) & 15)) << 8)))) + (0)) + (0));
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), object);
						longAtPointerput((localSP -= BytesPerOop), 0);
						longAtPointerput((localSP -= BytesPerOop), rcvr1);
						for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
						}
						localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1);
						if (((methodHeader1 & AlternateHeaderHasPrimFlag) != 0)) {
							/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
							   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
							localIP += 3 /* begin sizeOfCallPrimitiveBytecode: */;
							if (GIV(primFailCode) != 0) {
								reapAndResetErrorCodeToheader(localSP, methodHeader1);
							}
						}
						assert((frameNumArgs(localFP)) == GIV(argumentCount));
						assert(!(frameIsBlockActivation(localFP)));
						assert(!(frameHasContext(localFP)));
						if (localSP < GIV(stackLimit)) {
							/* begin externalizeIPandSP */
							assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader1));
							returnToExecutivepostContextSwitch(1, switched);
							/* begin internalizeIPandSP */
							assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
							localIP = pointerForOop(GIV(instructionPointer));
							localSP = pointerForOop(GIV(stackPointer));
							localFP = pointerForOop(GIV(framePointer));
						}
						goto l242;
					}
					/* begin iframeSavedIP:put: */
					assert(!(isMachineCodeFrame(localFP)));
					longAtput(localFP + FoxIFSavedIP, ((sqInt)localIP));
					GIV(instructionPointer) = ceReturnToInterpreterPC();
					/* begin externalizeFPandSP */
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					activateNewCogMethodinInterpreter(((CogMethod *) methodHeader), 1);
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
	l242:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
			}
			BREAK;
		CASE(132) // doubleExtendedDoAnythingBytecode
			{
				sqInt byte2;
				sqInt byte3;
				sqInt callerContextOrNil;
				char *callerFP;
				sqInt litVar;
				sqInt litVar1;
				usqInt methodPointer;
				sqInt obj;
				sqInt obj1;
				sqInt object;
				sqInt object1;
				sqInt objOop;
				sqInt objOop1;
				int onCurrentPage;
				sqInt opType;
				sqInt result;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char *theFP;
				StackPage *thePage;
				StackPage *thePage1;
				sqInt thePC;
				sqInt thePC1;
				char *theSP;
				sqInt top;
				sqInt value;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt)(byte2)) >> 5;
				if (opType == 0) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l16;
				}
				if (opType == 1) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l16;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					obj = longAt(localFP + FoxIFReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
						/* begin instVar:ofContext: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj));
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (!(((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))) {
							value = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							if ((byte3 == InstructionPointerIndex)
							 && (((((value) & 7) == 1))
							 && ((((int) value)) < 0))) {
								/* begin internalMustMapMachineCodePC:context: */
								assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
								GIV(instructionPointer) = oopForPointer(localIP);
								GIV(stackPointer) = localSP;
								GIV(framePointer) = localFP;
								result = mustMapMachineCodePCcontext((value >> 3), obj);
								/* begin internalizeIPandSP */
								assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
								localIP = pointerForOop(GIV(instructionPointer));
								localSP = pointerForOop(GIV(stackPointer));
								localFP = pointerForOop(GIV(framePointer));
								value = result;
							}
							object1 = value;
							goto l18;
						}
						if (isWidowedContext(obj)) {
							object1 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))));
							goto l18;
						}
						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop) & 7) == 1));
						spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {
								/* base frame, context in saved ip slot (or base of stack in Cog) */
								/* begin frameCallerContext: */
								assert(isBaseFrame(spouseFP));
								thePage = stackPageAtpages(
									(assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages)))))),
									pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
									GIV(pages));
								callerContextOrNil = longAt((thePage->baseAddress));
								assert(addressCouldBeObj(callerContextOrNil));
								assert((callerContextOrNil == (nilObject()))
								 || (isContext(followMaybeForwarded(callerContextOrNil))));
								object1 = callerContextOrNil;
								goto l18;
							}
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(spouseFP)));
							theSP = (spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord;
							/* begin ensureFrameIsMarried:SP: */
							if (							/* begin frameHasContext: */
								((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
								? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
								: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
								assert(isContext(frameContext(callerFP)));
								object1 = longAt(callerFP + FoxThisContext);
								goto l18;
							}
							object1 = marryFrameSP(callerFP, theSP);
							goto l18;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
							object1 = (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 3) | 1);
							goto l18;
						}
						if (byte3 == InstructionPointerIndex) {
							object1 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l18;
						}
						error("bad index");
						object1 = 0;
	l18:	/* end instVar:ofContext: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), object1);
					}
					else {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord()))))));
					}
					goto l16;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l16;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					objOop = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					assert(isNonImmediate(objOop));
					if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop = fixFollowedFieldofObjectwithInitialValue(byte3 + LiteralStart, GIV(method), objOop);
					}
					litVar = objOop;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord()))))));
					goto l16;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */
					methodPointer = GIV(method);
					/* begin followObjField:ofObject: */
					objOop1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					assert(isNonImmediate(objOop1));
					if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(byte3 + LiteralStart, methodPointer, objOop1);
					}
					litVar1 = objOop1;
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(litVar1))));
					if (((((usqInt)((longAt(litVar1)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), litVar1);
						longAtPointerput((localSP -= BytesPerOop), top);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l25;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar1)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(litVar1)),
					oopisGreaterThanOrEqualTo(litVar1, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(top & (tagMask()))))
						 && (oopisLessThan(top, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(litVar1)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar1);
							}
						}
					}
					longAtput((litVar1 + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))), top);
	l25:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l16;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				obj1 = longAt(localFP + FoxIFReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && ((((((longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
				 || (				/* begin is:methodAssignmentToContextWithMachineCodePC: */
					(byte3 == MethodIndex)
				 && (((((int) ((thePC = longAt((top + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
				 && ((((thePC) & 7) == 1))))))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj1));
					assert(!((isObjImmutable(obj1))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!(						/* begin isStillMarriedContext: */
							(((((longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
						 && (!(isWidowedContext(obj1))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(obj1)));
						if ((						/* begin isOldObject: */
							assert(isNonImmediate(obj1)),
						oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart)))) {
							/* most stores into young objects */
							if (							/* begin isYoung: */
								((!(top & (tagMask()))))
							 && (oopisLessThan(top, GIV(oldSpaceStart)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt)((longAt(obj1)))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(obj1);
								}
							}
						}
						longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
						if (byte3 == StackPointerIndex) {
							ensureContextIsExecutionSafeAfterAssignToStackPointer(obj1);
						}
						goto l26;
					}
					/* begin frameOfMarriedContext: */
					senderOop1 = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop1) & 7) == 1));
					theFP = pointerForOop(senderOop1 - (smallIntegerTag()));
					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						thePage1 = stackPageAtpages(
							(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage1 == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l26;
					}
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj1);
					if (					/* begin is:methodAssignmentToContextWithMachineCodePC: */
						(byte3 == MethodIndex)
					 && (((((int) ((thePC1 = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
					 && ((((thePC1) & 7) == 1)))) {
						ensureContextHasBytecodePC(obj1);
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj1)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(obj1)),
					oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(top & (tagMask()))))
						 && (oopisLessThan(top, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(obj1)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(obj1);
							}
						}
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
					if (byte3 == StackPointerIndex) {
						ensureContextIsExecutionSafeAfterAssignToStackPointer(obj1);
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
	l26:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(obj1))));
					if (((((usqInt)((longAt(obj1)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), obj1);
						longAtPointerput((localSP -= BytesPerOop), top);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(byte3 + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l29;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj1)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(obj1)),
					oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(top & (tagMask()))))
						 && (oopisLessThan(top, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(obj1)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(obj1);
							}
						}
					}
					longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(byte3) << (shiftForWord())))), top);
	l29:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
	l16:;
			BREAK;
		CASE(133) // singleExtendedSuperBytecode
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x1F) + LiteralStart)) << (shiftForWord())))));
				GIV(argumentCount) = ((usqInt)(descriptor)) >> 5;
				/* goto superclassSend */;
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt aValue;
				sqInt classPointer;
				sqInt err;
				sqInt hash;
				sqInt literal;
				usqInt methodPointer;
				sqInt objOop;
				sqInt objOop1;
				sqInt objOop11;
				sqInt objOop2;
				sqInt offset;
				sqInt referent;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				methodPointer = GIV(method);
				/* begin followLiteral:ofMethod: */
				offset = (literalCountOf(methodPointer)) - 1;
				/* begin followField:ofObject: */
				objOop2 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop2 & (tagMask()))))
				 && ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodPointer, objOop2);
				}
				literal = objOop2;
				if ((literal != GIV(nilObj))
				 && (				/* begin isPointers: */
					((!(literal & (tagMask()))))
				 && (((((usqInt)((longAt(literal)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))) {
					/* filters out fullBlock last literal */
					assert((numSlotsOf(literal)) > ValueIndex);
					/* begin followField:ofObject: */
					objOop11 = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
					if (					/* begin isOopForwarded: */
						((!(objOop11 & (tagMask()))))
					 && ((!((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						objOop11 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop11);
					}
					classPointer = objOop11;
				}
				else {
					classPointer = GIV(nilObj);
				}
				/* begin followObjField:ofObject: */
				objOop = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
				}
				superclass = objOop;
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				flag("todo");
				if (((hash = (long32At(superclass + 4)) & (identityHashHalfWordMask()))) != 0) {
					lkupClassTag = hash;
				}
				else {
					if (objCouldBeClassObj(superclass)) {
						if (((err = enterIntoClassTable(superclass))) != 0) {
							lkupClassTag = -err;
						}
						else {
							lkupClassTag = (long32At(superclass + 4)) & (identityHashHalfWordMask());
						}
					}
					else {
						lkupClassTag = -PrimErrBadReceiver;
					}
				}
				/* begin ensureReceiverUnforwarded */
				if (				/* begin isOopForwarded: */
					((!((longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop))) & (tagMask()))))
				 && ((!((longAt(longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(objOop1));
					referent = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					aValue = referent;
					/* begin internalStackValue:put: */
					longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), aValue);
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(134) // secondExtendedSendBytecode
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((descriptor & 0x3F) + LiteralStart)) << (shiftForWord())))));
				GIV(argumentCount) = ((usqInt)(descriptor)) >> 6;
				goto normalSend;
			}
			BREAK;
		CASE(135) // popStackBytecode
		CASE(472) // 216	popStackBytecode
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(136) // duplicateTopBytecode
		CASE(339) // 83	duplicateTopBytecode
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = longAtPointer(localSP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(137) // pushActiveContextBytecode
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l32;
				}
				ourContext = marryFrameSP(localFP, localSP);
	l32:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			BREAK;
		CASE(138) // pushNewArrayBytecode
		CASE(487) // 231	pushNewArrayBytecode
			{
				usqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				sqInt objFormat;
				int popValues;
				sqInt size;

				VM_LABEL(pushNewArrayBytecode);
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				objFormat = arrayFormat();
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && ((knownClassAtIndex(ClassArrayCompactIndex)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat())
					? objFormat
					: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size < 1
	? 8 /* begin allocationUnit */
	: size * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l33;
					}
				}
				long64Atput(newObj, (((((usqLong) size)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
	l33:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				if (popValues) {
					for (i = 0; i < size; i += 1) {
						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(array)));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(array)));
						longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			BREAK;
		CASE(139) // callPrimitiveBytecode
		CASE(504) // 248	callPrimitiveBytecode
			{
				sqInt header;
				sqInt header1;

				VM_LABEL(callPrimitiveBytecode);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method)));
				header1 = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
				header = ((((header1) & 7) == 1)
					? header1
					: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
						assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
						((((CogMethod *) header1))->methodHeader)));
				if ((((header & AlternateHeaderHasPrimFlag) != 0))
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + 3 /* begin sizeOfCallPrimitiveBytecode: */) - 1;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l34;
				}
				goto respondToUnknownBytecode;
			}
	l34:	/* end case */;
			BREAK;
		CASE(140) // pushRemoteTempLongBytecode
		CASE(507) // 251	pushRemoteTempLongBytecode
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVector1;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				tempVector1 = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				tempVector = tempVector1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord()))))));
			}
			BREAK;
		CASE(141) // storeRemoteTempLongBytecode
		CASE(508) // 252	storeRemoteTempLongBytecode
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVector1;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				tempVector1 = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				tempVector = tempVector1;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(tempVector)),
				oopisGreaterThanOrEqualTo(tempVector, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!((longAtPointer(localSP)) & (tagMask()))))
					 && (oopisLessThan(longAtPointer(localSP), GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(tempVector)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(tempVector);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
			}
			BREAK;
		CASE(142) // storeAndPopRemoteTempLongBytecode
		CASE(509) // 253	storeAndPopRemoteTempLongBytecode
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVector1;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				tempVector1 = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				tempVector = tempVector1;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(tempVector)),
				oopisGreaterThanOrEqualTo(tempVector, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!((longAtPointer(localSP)) & (tagMask()))))
					 && (oopisLessThan(longAtPointer(localSP), GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(tempVector)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(tempVector);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (((sqInt)((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(143) // pushClosureCopyCopiedValuesBytecode
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				usqInt newClosure;
				usqInt newClosure1;
				usqInt newObj;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				usqInt numBytes;
				sqInt numCopied;
				sqInt numSlots;
				sqInt objFormat;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;
				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = (((usqInt)(numArgsNumCopied)) >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l45;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
	l45:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
								objFormat = indexablePointersFormat();
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((numSlots >= 0)
				 && ((knownClassAtIndex(ClassBlockClosureCompactIndex)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat())
					? objFormat
					: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l44;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
	l44:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)(((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize)) << 3) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 3) | 1));
				newClosure = newClosure1;
				if (recordSendTrace()) {
					/* begin recordTrace:thing:source: */
					GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
					GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
					GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
					GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
				}
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {
						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			BREAK;
		CASE(144) // shortUnconditionalJump
		CASE(432) // 176	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				offset = 1 /* 0 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(145) // shortUnconditionalJump
		CASE(433) // 177	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				offset = 2 /* 1 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(146) // shortUnconditionalJump
		CASE(434) // 178	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				offset = 3 /* 2 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(147) // shortUnconditionalJump
		CASE(435) // 179	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				offset = 4 /* 3 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(148) // shortUnconditionalJump
		CASE(436) // 180	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				offset = 5 /* 4 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(149) // shortUnconditionalJump
		CASE(437) // 181	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				offset = 6 /* 5 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(150) // shortUnconditionalJump
		CASE(438) // 182	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				offset = 7 /* 6 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(151) // shortUnconditionalJump
		CASE(439) // 183	shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				offset = 8 /* 7 + 1 */;
				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(152) // shortConditionalJumpFalse
		CASE(153) // shortConditionalJumpFalse
		CASE(154) // shortConditionalJumpFalse
		CASE(155) // shortConditionalJumpFalse
		CASE(156) // shortConditionalJumpFalse
		CASE(157) // shortConditionalJumpFalse
		CASE(158) // shortConditionalJumpFalse
		CASE(159) // shortConditionalJumpFalse
		CASE(448) // 192	shortConditionalJumpFalse
		CASE(449) // 193	shortConditionalJumpFalse
		CASE(450) // 194	shortConditionalJumpFalse
		CASE(451) // 195	shortConditionalJumpFalse
		CASE(452) // 196	shortConditionalJumpFalse
		CASE(453) // 197	shortConditionalJumpFalse
		CASE(454) // 198	shortConditionalJumpFalse
		CASE(455) // 199	shortConditionalJumpFalse
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				offset = (currentBytecode & 7) + 1;
				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l48;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				localSP += 1 * BytesPerOop;
	l48:;
			}
			BREAK;
		CASE(160) // longUnconditionalJump
		CASE(161) // longUnconditionalJump
		CASE(162) // longUnconditionalJump
		CASE(163) // longUnconditionalJump
		CASE(164) // longUnconditionalJump
		CASE(165) // longUnconditionalJump
		CASE(166) // longUnconditionalJump
		CASE(167) // longUnconditionalJump
			{
				sqInt backwardJumpCountByte;
				sqInt offset;
				sqInt switched;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 0x100) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if (offset >= 0) {
					goto l49;
				}
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					switched = checkForEventsMayContextSwitch(1);
					returnToExecutivepostContextSwitch(1, switched);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (switched) {
						goto l49;
					}
				}
				backwardJumpCountByte = byteAt(localFP + ((VMBIGENDIAN
	? (FoxIFrameFlags + BytesPerWord) - 1
	: FoxIFrameFlags)));
				if (((backwardJumpCountByte -= 2)) == 1) {
					if (methodWithHeaderShouldBeCogged(methodHeaderOf(GIV(method)))) {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						attemptToSwitchToMachineCode(((((oopForPointer(localIP)) - offset) - GIV(method)) - BaseHeaderSize) - 1);
					}
					backwardJumpCountByte = 0x7F;
				}
				else {
					if (backwardJumpCountByte == -1) {
						/* initialize the count */
						assert(minBackwardJumpCountForCompile <= 128);
						backwardJumpCountByte = (((sqInt)((usqInt)((minBackwardJumpCountForCompile - 1)) << 1))) + 1;
					}
				}
				/* begin iframeBackwardBranchByte:put: */
				byteAtput(localFP + ((VMBIGENDIAN
	? (FoxIFrameFlags + BytesPerWord) - 1
	: FoxIFrameFlags)), backwardJumpCountByte);
	l49:	/* end ifBackwardsCheckForEvents: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(168) // longJumpIfTrue
		CASE(169) // longJumpIfTrue
		CASE(170) // longJumpIfTrue
		CASE(171) // longJumpIfTrue
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				offset = ((currentBytecode & 3) * 0x100) + (byteAtPointer(++localIP));
				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l50;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				localSP += 1 * BytesPerOop;
	l50:;
			}
			BREAK;
		CASE(172) // longJumpIfFalse
		CASE(173) // longJumpIfFalse
		CASE(174) // longJumpIfFalse
		CASE(175) // longJumpIfFalse
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				offset = ((currentBytecode & 3) * 0x100) + (byteAtPointer(++localIP));
				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l51;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				localSP += 1 * BytesPerOop;
	l51:;
			}
			BREAK;
		CASE(176) // bytecodePrimAdd
		CASE(352) // 96	bytecodePrimAdd
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					result = ((rcvr >> 3)) + ((arg >> 3));
					if ((((((usqInt)(result)) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (1) * BytesPerOop), (((usqInt)result << 3) | 1));
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l52;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l56;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits == (smallIntegerTag()))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l56;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l56;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l56:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l55;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits1 == (smallIntegerTag()))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l55;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l55;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l55:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l52;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((0)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l52:	/* end case */;
			BREAK;
		CASE(177) // bytecodePrimSubtract
		CASE(353) // 97	bytecodePrimSubtract
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					result = ((rcvr >> 3)) - ((arg >> 3));
					if ((((((usqInt)(result)) >> 60) + 1) & 15) <= 1) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (1) * BytesPerOop), (((usqInt)result << 3) | 1));
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l57;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l61;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits == (smallIntegerTag()))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l61;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l61;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l61:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l60;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits1 == (smallIntegerTag()))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l60;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l60;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l60:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l57;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((2)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l57:	/* end case */;
			BREAK;
		CASE(178) // bytecodePrimLessThan
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l62;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatLessthanArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l62;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((4)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l62:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {
						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l249;
					}
					if (bytecode == 172) {
						/* long jumpIfFalse */
						/* begin fetchByte */
						byteAtPointer(++localIP);
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l249;
					}
					if (bytecode > 167) {
						/* long jumpIfTrue 168 - 171 */
						offset = (((sqInt)((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
						goto l249;
					}
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
	l249:;
			BREAK;
		CASE(179) // bytecodePrimGreaterThan
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */;
					}
					goto l63;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatGreaterthanArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l63;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((6)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l63:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {
					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
					goto l250;
				}
				if (bytecode == 172) {
					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
					goto l250;
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
	l250:;
			BREAK;
		CASE(180) // bytecodePrimLessOrEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l64;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatLessOrEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l64;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((8)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l64:	/* end case */;
			BREAK;
		CASE(181) // bytecodePrimGreaterOrEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l65;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatGreaterOrEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l65;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((10)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l65:	/* end case */;
			BREAK;
		CASE(182) // bytecodePrimEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l66;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l66;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((12)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l66:	/* end case */;
			BREAK;
		CASE(183) // bytecodePrimNotEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l67;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l67;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((14)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l67:	/* end case */;
			BREAK;
		CASE(184) // bytecodePrimMultiply
		CASE(360) // 104	bytecodePrimMultiply
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt oop;
				sqInt overflow;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					overflow = (rcvr > 0
						? (arg > 0
								? rcvr > ((MaxSmallInteger) / arg)
								: arg < ((MinSmallInteger) / rcvr))
						: (arg > 0
								? rcvr < ((MinSmallInteger) / arg)
								: (rcvr < 0)
									 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 3) | 1);
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (1) * BytesPerOop), oop);
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l68;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l72;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits == (smallIntegerTag()))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l72;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l72;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l72:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l71;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits1 == (smallIntegerTag()))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l71;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l71;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l71:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l68;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((16)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l68:	/* end case */;
			BREAK;
		CASE(185) // bytecodePrimDivide
		CASE(361) // 105	bytecodePrimDivide
			{
				sqInt arg;
				double arg1;
				usqLong bits;
				usqLong bits1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				usqLong rot;
				usqLong rot1;
				char *sp;
				sqInt tagBits;
				sqInt tagBits1;
				double value;
				double value1;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					rcvr = (rcvr >> 3);
					arg = (arg >> 3);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {
						/* generates C / operation */
						result = rcvr / arg;
						if ((((((usqInt)(result)) >> 60) + 1) & 15) <= 1) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (1) * BytesPerOop), (((usqInt)result << 3) | 1));
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
							goto l73;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					if (((tagBits = rcvr & (tagMask()))) != 0) {
						if (tagBits == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(rcvr));
							rot = ((((usqInt)rcvr))) >> (numTagBits());
							if (rot > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
							bits = rot;
							memcpy((&value), (&bits), sizeof(value));
							rcvr1 = value;
							goto l77;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits == (smallIntegerTag()))) {
							rcvr1 = ((double) ((rcvr >> 3)) );
							goto l77;
						}
					}
					else {
						if (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(rcvr + BaseHeaderSize, result2);
							rcvr1 = result2;
							goto l77;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
	l77:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if (((tagBits1 = arg & (tagMask()))) != 0) {
						if (tagBits1 == (smallFloatTag())) {
							/* begin smallFloatValueOf: */
							assert(isImmediateFloat(arg));
							rot1 = ((((usqInt)arg))) >> (numTagBits());
							if (rot1 > 1) {
								/* a.k.a. ~= +/-0.0 */
								rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
							}
							rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
							bits1 = rot1;
							memcpy((&value1), (&bits1), sizeof(value1));
							arg1 = value1;
							goto l76;
						}
						if ((primitiveDoMixedArithmetic())
						 && (tagBits1 == (smallIntegerTag()))) {
							arg1 = ((double) ((arg >> 3)) );
							goto l76;
						}
					}
					else {
						if (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex) {
							fetchFloatAtinto(arg + BaseHeaderSize, result1);
							arg1 = result1;
							goto l76;
						}
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
	l76:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {
						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l73;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((18)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l73:	/* end case */;
			BREAK;
		CASE(186) // bytecodePrimMod
		CASE(362) // 106	bytecodePrimMod
			{
				sqInt mod;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (1) * BytesPerOop), (((usqInt)mod << 3) | 1));
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l78;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((20)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l78:	/* end case */;
			BREAK;
		CASE(187) // bytecodePrimMakePoint
		CASE(363) // 107	bytecodePrimMakePoint
			{
				sqInt arg;
				sqInt classObj;
				sqInt knownClassIndex;
				usqInt newObj;
				usqInt numBytes;
				sqInt numSlots;
				sqInt objFormat;
				usqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((				/* begin isFloatOrInt: */
					(((rcvr & (tagMask())) != 0)
					? !(((rcvr & (characterTag())) != 0))
					: ((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex))
				 && ((((arg & (tagMask())) != 0)
					? !(((arg & (characterTag())) != 0))
					: ((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex))) {
					classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))));
					numSlots = YIndex + 1;
					/* begin eeInstantiateSmallClass:numSlots: */
					assert((rawHashBitsOf(classObj)) != 0);
					knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
					objFormat = (((usqInt)((((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
					/* begin eeInstantiateSmallClassIndex:format:numSlots: */
					assert((numSlots >= 0)
					 && ((knownClassIndex != 0)
					 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
					assert(((objFormat < (firstByteFormat())
						? objFormat
						: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
					/* begin allocateSmallNewSpaceSlots:format:classIndex: */
					assert(numSlots < (numSlotsMask()));
					newObj = GIV(freeStart);
					numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
					assert((numBytes % (allocationUnit())) == 0);
					assert((newObj % (allocationUnit())) == 0);
					if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
						if (!GIV(needGCFlag)) {
							/* begin scheduleScavenge */
							GIV(needGCFlag) = 1;
							forceInterruptCheck();
						}
						if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
							error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
							pt = 0;
							goto l80;
						}
					}
					long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
					GIV(freeStart) += numBytes;
					pt = newObj;
	l80:	/* end eeInstantiateSmallClass:numSlots: */;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(pt)));
					longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord())))), rcvr);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(pt)));
					longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord())))), arg);
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (1) * BytesPerOop), pt);
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l79;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((22)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l79:	/* end case */;
			BREAK;
		CASE(188) // bytecodePrimBitShift
		CASE(364) // 108	bytecodePrimBitShift
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((((integerArgument) & 7) == 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l82;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = signed64BitValueOf(integerReceiver);
				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 3))) >= 0) {
						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 61 /* begin numSmallIntegerBits */)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l82;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == ((shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l82;
						}
					}
					else {
						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-61 /* begin numSmallIntegerBits */))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l82;
						}
						shifted = (integerReceiver) >> (0 - integerArgument);
					}
					shifted = ((((((usqInt)(shifted)) >> 60) + 1) & 15) <= 1
						? (((usqInt)shifted << 3) | 1)
						: signed64BitIntegerFor(shifted));
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
	l82:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l81;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((24)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l81:	/* end case */;
			BREAK;
		CASE(189) // bytecodePrimDiv
		CASE(365) // 109	bytecodePrimDiv
			{
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (1) * BytesPerOop), (((usqInt)quotient << 3) | 1));
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l83;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((26)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l83:	/* end case */;
			BREAK;
		CASE(190) // bytecodePrimBitAnd
		CASE(366) // 110	bytecodePrimBitAnd
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (1) * BytesPerOop), arg & rcvr);
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l84;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l84;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((28)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l84:	/* end case */;
			BREAK;
		CASE(191) // bytecodePrimBitOr
		CASE(367) // 111	bytecodePrimBitOr
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((((arg) & 7) == 1))
				 && ((((rcvr) & 7) == 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (1) * BytesPerOop), arg | rcvr);
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l85;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l85;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((30)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l85:	/* end case */;
			BREAK;
		CASE(192) // bytecodePrimAt
		CASE(368) // 112	bytecodePrimAt
			{
				VM_LABEL(bytecodePrimAt);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((32)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			BREAK;
		CASE(193) // bytecodePrimAtPut
		CASE(369) // 113	bytecodePrimAtPut
			{
				VM_LABEL(bytecodePrimAtPut);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((34)) << (shiftForWord())))));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
			BREAK;
		CASE(194) // bytecodePrimSize
		CASE(370) // 114	bytecodePrimSize
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				if (((rcvr & (tagMask())) != 0)) {
					isString = 0;
					goto l87;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isString = ClassByteStringCompactIndex == ccIndex;
	l87:	/* end isInstanceOfClassByteString: */;
				if (isString) {
					/* begin lengthOf: */
					fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots1);
					if (fmt <= 5 /* begin ephemeronFormat */) {
						sz = numSlots;
						goto l92;
					}
					if (fmt >= (firstByteFormat())) {
						/* bytes, including CompiledMethod */
						sz = (numSlots << (shiftForWord())) - (fmt & 7);
						goto l92;
					}
					if (fmt >= (firstShortFormat())) {
						sz = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
						goto l92;
					}
					if (fmt >= (firstLongFormat())) {
						sz = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
						goto l92;
					}
					if (fmt == (sixtyFourBitIndexableFormat())) {
						sz = numSlots;
						goto l92;
					}
					sz = 0;
	l92:	/* end lengthOf: */;
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, (((usqInt)sz << 3) | 1));
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l86;
				}
				/* begin isInstanceOfClassArray: */
				if (((rcvr & (tagMask())) != 0)) {
					isArray = 0;
					goto l90;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex1 = (longAt(rcvr)) & (classIndexMask());
				isArray = ClassArrayCompactIndex == ccIndex1;
	l90:	/* end isInstanceOfClassArray: */;
				if (isArray) {
					/* begin lengthOf: */
					fmt1 = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots11);
					if (fmt1 <= 5 /* begin ephemeronFormat */) {
						sz = numSlots2;
						goto l91;
					}
					if (fmt1 >= (firstByteFormat())) {
						/* bytes, including CompiledMethod */
						sz = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
						goto l91;
					}
					if (fmt1 >= (firstShortFormat())) {
						sz = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
						goto l91;
					}
					if (fmt1 >= (firstLongFormat())) {
						sz = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
						goto l91;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat())) {
						sz = numSlots2;
						goto l91;
					}
					sz = 0;
	l91:	/* end lengthOf: */;
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, (((usqInt)sz << 3) | 1));
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l86;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((36)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l86:	/* end case */;
			BREAK;
		CASE(195) // bytecodePrimNext
		CASE(371) // 115	bytecodePrimNext
			{
				VM_LABEL(bytecodePrimNext);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((38)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject(39, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 3);
				goto normalSend;
			}
			BREAK;
		CASE(196) // bytecodePrimNextPut
		CASE(372) // 116	bytecodePrimNextPut
			{
				VM_LABEL(bytecodePrimNextPut);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((40)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject(41, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 3);
				goto normalSend;
			}
			BREAK;
		CASE(197) // bytecodePrimAtEnd
		CASE(373) // 117	bytecodePrimAtEnd
			{
				VM_LABEL(bytecodePrimAtEnd);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((42)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject(43, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 3);
				goto normalSend;
			}
			BREAK;
		CASE(198) // bytecodePrimIdentical
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (				/* begin isOopForwarded: */
					((!(rcvr & (tagMask()))))
				 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (				/* begin isOopForwarded: */
					((!(arg & (tagMask()))))
				 && ((!((longAt(arg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			BREAK;
		CASE(199) // bytecodePrimClass
		CASE(375) // 119	bytecodePrimClass
			{
				sqInt aValue;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				if (				/* begin isOopForwarded: */
					((!(rcvr & (tagMask()))))
				 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				aValue = 
				/* begin fetchClassOf: */
(((tagBits = rcvr & (tagMask()))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
					: fetchClassOfNonImm(rcvr));
				longAtPointerput(localSP, aValue);
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(200) // bytecodePrimNotIdentical
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (				/* begin isOopForwarded: */
					((!(rcvr & (tagMask()))))
				 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (				/* begin isOopForwarded: */
					((!(arg & (tagMask()))))
				 && ((!((longAt(arg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheat: */
				if (rcvr != arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			BREAK;
		CASE(201) // bytecodePrimValue
		CASE(377) // 121	bytecodePrimValue
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin isInstanceOfClassBlockClosure: */
				if (((rcvr & (tagMask())) != 0)) {
					isBlock = 0;
					goto l95;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
	l95:	/* end isInstanceOfClassBlockClosure: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l94;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((50)) << (shiftForWord())))));
				goto normalSend;
			}
	l94:	/* end case */;
			BREAK;
		CASE(202) // bytecodePrimValueWithArg
		CASE(378) // 122	bytecodePrimValueWithArg
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin isInstanceOfClassBlockClosure: */
				if (((rcvr & (tagMask())) != 0)) {
					isBlock = 0;
					goto l97;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
	l97:	/* end isInstanceOfClassBlockClosure: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l96;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((52)) << (shiftForWord())))));
				goto normalSend;
			}
	l96:	/* end case */;
			BREAK;
		CASE(203) // bytecodePrimDo
		CASE(379) // 123	bytecodePrimDo
			{
				VM_LABEL(bytecodePrimDo);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((54)) << (shiftForWord())))));
				GIV(argumentCount) = ((fetchPointerofObject(55, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 3);
				goto normalSend;
			}
			BREAK;
		CASE(204) // bytecodePrimNew
		CASE(380) // 124	bytecodePrimNew
			{
				VM_LABEL(bytecodePrimNew);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((56)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			BREAK;
		CASE(205) // bytecodePrimNewWithArg
		CASE(381) // 125	bytecodePrimNewWithArg
			{
				VM_LABEL(bytecodePrimNewWithArg);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((58)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			BREAK;
		CASE(206) // bytecodePrimPointX
		CASE(382) // 126	bytecodePrimPointX
			{
				int ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				if ((!(rcvr & (tagMask())))) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))))) + 4)) & (identityHashHalfWordMask()));
					if (ok) {
						longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord()))))));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l98;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((60)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l98:	/* end case */;
			BREAK;
		CASE(207) // bytecodePrimPointY
		CASE(383) // 127	bytecodePrimPointY
			{
				int ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				if ((!(rcvr & (tagMask())))) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))))) + 4)) & (identityHashHalfWordMask()));
					if (ok) {
						longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord()))))));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l100;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((0x3E)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
	l100:	/* end case */;
			BREAK;
		CASE(208) // sendLiteralSelector0ArgsBytecode
		CASE(209) // sendLiteralSelector0ArgsBytecode
		CASE(210) // sendLiteralSelector0ArgsBytecode
		CASE(211) // sendLiteralSelector0ArgsBytecode
		CASE(212) // sendLiteralSelector0ArgsBytecode
		CASE(213) // sendLiteralSelector0ArgsBytecode
		CASE(214) // sendLiteralSelector0ArgsBytecode
		CASE(215) // sendLiteralSelector0ArgsBytecode
		CASE(216) // sendLiteralSelector0ArgsBytecode
		CASE(217) // sendLiteralSelector0ArgsBytecode
		CASE(218) // sendLiteralSelector0ArgsBytecode
		CASE(219) // sendLiteralSelector0ArgsBytecode
		CASE(220) // sendLiteralSelector0ArgsBytecode
		CASE(221) // sendLiteralSelector0ArgsBytecode
		CASE(222) // sendLiteralSelector0ArgsBytecode
		CASE(223) // sendLiteralSelector0ArgsBytecode
		CASE(384) // 128	sendLiteralSelector0ArgsBytecode
		CASE(385) // 129	sendLiteralSelector0ArgsBytecode
		CASE(386) // 130	sendLiteralSelector0ArgsBytecode
		CASE(387) // 131	sendLiteralSelector0ArgsBytecode
		CASE(388) // 132	sendLiteralSelector0ArgsBytecode
		CASE(389) // 133	sendLiteralSelector0ArgsBytecode
		CASE(390) // 134	sendLiteralSelector0ArgsBytecode
		CASE(391) // 135	sendLiteralSelector0ArgsBytecode
		CASE(392) // 136	sendLiteralSelector0ArgsBytecode
		CASE(393) // 137	sendLiteralSelector0ArgsBytecode
		CASE(394) // 138	sendLiteralSelector0ArgsBytecode
		CASE(395) // 139	sendLiteralSelector0ArgsBytecode
		CASE(396) // 140	sendLiteralSelector0ArgsBytecode
		CASE(397) // 141	sendLiteralSelector0ArgsBytecode
		CASE(398) // 142	sendLiteralSelector0ArgsBytecode
		CASE(399) // 143	sendLiteralSelector0ArgsBytecode
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				lkupClassTag = 
				/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(224) // sendLiteralSelector1ArgBytecode
		CASE(225) // sendLiteralSelector1ArgBytecode
		CASE(226) // sendLiteralSelector1ArgBytecode
		CASE(227) // sendLiteralSelector1ArgBytecode
		CASE(228) // sendLiteralSelector1ArgBytecode
		CASE(229) // sendLiteralSelector1ArgBytecode
		CASE(230) // sendLiteralSelector1ArgBytecode
		CASE(231) // sendLiteralSelector1ArgBytecode
		CASE(232) // sendLiteralSelector1ArgBytecode
		CASE(233) // sendLiteralSelector1ArgBytecode
		CASE(234) // sendLiteralSelector1ArgBytecode
		CASE(235) // sendLiteralSelector1ArgBytecode
		CASE(236) // sendLiteralSelector1ArgBytecode
		CASE(237) // sendLiteralSelector1ArgBytecode
		CASE(238) // sendLiteralSelector1ArgBytecode
		CASE(239) // sendLiteralSelector1ArgBytecode
		CASE(400) // 144	sendLiteralSelector1ArgBytecode
		CASE(401) // 145	sendLiteralSelector1ArgBytecode
		CASE(402) // 146	sendLiteralSelector1ArgBytecode
		CASE(403) // 147	sendLiteralSelector1ArgBytecode
		CASE(404) // 148	sendLiteralSelector1ArgBytecode
		CASE(405) // 149	sendLiteralSelector1ArgBytecode
		CASE(406) // 150	sendLiteralSelector1ArgBytecode
		CASE(407) // 151	sendLiteralSelector1ArgBytecode
		CASE(408) // 152	sendLiteralSelector1ArgBytecode
		CASE(409) // 153	sendLiteralSelector1ArgBytecode
		CASE(410) // 154	sendLiteralSelector1ArgBytecode
		CASE(411) // 155	sendLiteralSelector1ArgBytecode
		CASE(412) // 156	sendLiteralSelector1ArgBytecode
		CASE(413) // 157	sendLiteralSelector1ArgBytecode
		CASE(414) // 158	sendLiteralSelector1ArgBytecode
		CASE(415) // 159	sendLiteralSelector1ArgBytecode
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				lkupClassTag = 
				/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(240) // sendLiteralSelector2ArgsBytecode
		CASE(241) // sendLiteralSelector2ArgsBytecode
		CASE(242) // sendLiteralSelector2ArgsBytecode
		CASE(243) // sendLiteralSelector2ArgsBytecode
		CASE(244) // sendLiteralSelector2ArgsBytecode
		CASE(245) // sendLiteralSelector2ArgsBytecode
		CASE(246) // sendLiteralSelector2ArgsBytecode
		CASE(247) // sendLiteralSelector2ArgsBytecode
		CASE(248) // sendLiteralSelector2ArgsBytecode
		CASE(249) // sendLiteralSelector2ArgsBytecode
		CASE(250) // sendLiteralSelector2ArgsBytecode
		CASE(251) // sendLiteralSelector2ArgsBytecode
		CASE(252) // sendLiteralSelector2ArgsBytecode
		CASE(253) // sendLiteralSelector2ArgsBytecode
		CASE(254) // sendLiteralSelector2ArgsBytecode
		CASE(255) // sendLiteralSelector2ArgsBytecode
		CASE(416) // 160	sendLiteralSelector2ArgsBytecode
		CASE(417) // 161	sendLiteralSelector2ArgsBytecode
		CASE(418) // 162	sendLiteralSelector2ArgsBytecode
		CASE(419) // 163	sendLiteralSelector2ArgsBytecode
		CASE(420) // 164	sendLiteralSelector2ArgsBytecode
		CASE(421) // 165	sendLiteralSelector2ArgsBytecode
		CASE(422) // 166	sendLiteralSelector2ArgsBytecode
		CASE(423) // 167	sendLiteralSelector2ArgsBytecode
		CASE(424) // 168	sendLiteralSelector2ArgsBytecode
		CASE(425) // 169	sendLiteralSelector2ArgsBytecode
		CASE(426) // 170	sendLiteralSelector2ArgsBytecode
		CASE(427) // 171	sendLiteralSelector2ArgsBytecode
		CASE(428) // 172	sendLiteralSelector2ArgsBytecode
		CASE(429) // 173	sendLiteralSelector2ArgsBytecode
		CASE(430) // 174	sendLiteralSelector2ArgsBytecode
		CASE(431) // 175	sendLiteralSelector2ArgsBytecode
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(((currentBytecode & 15) + LiteralStart)) << (shiftForWord())))));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				lkupClassTag = 
				/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(338) // 82	extPushPseudoVariable
			{
				sqInt objOop;
				sqInt theThingToPush;

				VM_LABEL(extPushPseudoVariable);
				switch (extB) {
				case 0:
					/* begin ensureFrameIsMarried:SP: */
					if (					/* begin frameHasContext: */
						((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						theThingToPush = longAt(localFP + FoxThisContext);
						goto l103;
					}
					theThingToPush = marryFrameSP(localFP, localSP);
	l103:	/* end ensureFrameIsMarried:SP: */;
					break;
				case 1:
					/* begin activeProcess */
					objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
					theThingToPush = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
					break;
				default:
					goto respondToUnknownBytecode;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), theThingToPush);
				extB = 0;
				numExtB = 0;
			}
			BREAK;
		CASE(340) // 84	unknownBytecode
		CASE(341) // 85	unknownBytecode
		CASE(342) // 86	unknownBytecode
		CASE(343) // 87	unknownBytecode
		CASE(473) // 217	unconditionalTrapBytecode
		CASE(474) // 218	unknownBytecode
		CASE(475) // 219	unknownBytecode
		CASE(476) // 220	unknownBytecode
		CASE(477) // 221	unknownBytecode
		CASE(478) // 222	unknownBytecode
		CASE(479) // 223	unknownBytecode
		CASE(486) // 230	unknownBytecode
		CASE(502) // 246	unknownBytecode
		CASE(503) // 247	unknownBytecode
		CASE(510) // 254	unknownBytecode
		CASE(511) // 255	unknownBytecode
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			BREAK;
		CASE(344) // 88	returnReceiver
			{
				VM_LABEL(returnReceiver1);
				localReturnValue = longAt(localFP + FoxIFReceiver);
				goto commonReturn;
			}
			BREAK;
		CASE(349) // 93	returnNilFromBlock
			{
				VM_LABEL(returnNilFromBlock);
				localReturnValue = GIV(nilObj);
				goto commonCallerReturn;
			}
			BREAK;
		CASE(350) // 94	returnTopFromBlock
			{
				VM_LABEL(returnTopFromBlock1);
				localReturnValue = longAtPointer(localSP);
				goto commonCallerReturn;
			}
			BREAK;
		CASE(351) // 95	extNopBytecode
			{
				VM_LABEL(extNopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				numExtB = (extA = (extB = 0));
			}
			BREAK;
		CASE(354) // 98	bytecodePrimLessThanSistaV1
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimLessThanSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr < arg) {
						/* goto booleanCheatTrueSistaV1 */;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l115;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatLessthanArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l115;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((4)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l115:	/* end case */;
			
		booleanCheatTrueSistaV1:
			/* booleanCheatTrueSistaV1 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrueSistaV1);
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if (bytecode >= 192) {
					if (bytecode <= 199) {
						/* short jumpIfFalse 192 - 199 */
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l251;
					}
					if (bytecode == 239) {
						/* long jumpIfFalse */
						/* begin fetchByte */
						byteAtPointer(++localIP);
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
						goto l251;
					}
					if (bytecode == 238) {
						/* long jumpIfTrue 238 */
						offset = byteAtPointer(++localIP);
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
						goto l251;
					}
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
	l251:;
			BREAK;
		CASE(355) // 99	bytecodePrimGreaterThanSistaV1
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimGreaterThanSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr > arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						/* goto booleanCheatFalseSistaV1 */;
					}
					goto l116;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatGreaterthanArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l116;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((6)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l116:	/* end case */;
			
		booleanCheatFalseSistaV1:
			/* booleanCheatFalseSistaV1 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalseSistaV1);
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 199)
				 && (bytecode > 191)) {
					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 191)) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
					goto l252;
				}
				if (bytecode == 239) {
					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
					goto l252;
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
	l252:;
			BREAK;
		CASE(356) // 100	bytecodePrimLessOrEqualSistaV1
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimLessOrEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr <= arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l117;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatLessOrEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l117;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((8)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l117:	/* end case */;
			BREAK;
		CASE(357) // 101	bytecodePrimGreaterOrEqualSistaV1
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimGreaterOrEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheatSistaV1: */
					if (rcvr >= arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l118;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatGreaterOrEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l118;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((10)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l118:	/* end case */;
			BREAK;
		CASE(358) // 102	bytecodePrimEqualSistaV1
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* begin booleanCheatSistaV1: */
					if (rcvr == arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l119;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l119;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((12)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l119:	/* end case */;
			BREAK;
		CASE(359) // 103	bytecodePrimNotEqualSistaV1
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotEqualSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
					/* begin booleanCheatSistaV1: */
					if (rcvr != arg) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l120;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheatSistaV1: */
					if (!aBool) {
						goto booleanCheatTrueSistaV1;
					}
					else {
						goto booleanCheatFalseSistaV1;
					}
					goto l120;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((14)) << (shiftForWord())))));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
	l120:	/* end case */;
			BREAK;
		CASE(374) // 118	bytecodePrimIdenticalSistaV1
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdenticalSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (				/* begin isOopForwarded: */
					((!(rcvr & (tagMask()))))
				 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				if (				/* begin isOopForwarded: */
					((!(arg & (tagMask()))))
				 && ((!((longAt(arg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheatSistaV1: */
				if (rcvr == arg) {
					goto booleanCheatTrueSistaV1;
				}
				else {
					goto booleanCheatFalseSistaV1;
				}
			}
			BREAK;
		CASE(376) // 120	bytecodePrimNotIdenticalSistaV1
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdenticalSistaV1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (				/* begin isOopForwarded: */
					((!(rcvr & (tagMask()))))
				 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				if (				/* begin isOopForwarded: */
					((!(arg & (tagMask()))))
				 && ((!((longAt(arg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheatSistaV1: */
				if (rcvr != arg) {
					goto booleanCheatTrueSistaV1;
				}
				else {
					goto booleanCheatFalseSistaV1;
				}
			}
			BREAK;
		CASE(440) // 184	shortConditionalJumpTrue
		CASE(441) // 185	shortConditionalJumpTrue
		CASE(442) // 186	shortConditionalJumpTrue
		CASE(443) // 187	shortConditionalJumpTrue
		CASE(444) // 188	shortConditionalJumpTrue
		CASE(445) // 189	shortConditionalJumpTrue
		CASE(446) // 190	shortConditionalJumpTrue
		CASE(447) // 191	shortConditionalJumpTrue
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpTrue);
				offset = (currentBytecode & 7) + 1;
				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l155;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				localSP += 1 * BytesPerOop;
	l155:;
			}
			BREAK;
		CASE(480) // 224	extABytecode
			{
				VM_LABEL(extABytecode);
				extA = ((((sqInt)((usqInt)(extA) << 8)))) + (byteAtPointer(++localIP));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(481) // 225	extBBytecode
			{
				sqInt byte;

				VM_LABEL(extBBytecode);
				byte = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extB = ((numExtB == 0)
				 && (byte > 0x7F)
					? byte - 0x100
					: ((((sqInt)((usqInt)(extB) << 8)))) + byte);
				numExtB += 1;
			}
			BREAK;
		CASE(482) // 226	extPushReceiverVariableBytecode
			{
				sqInt callerContextOrNil;
				char *callerFP;
				sqInt index;
				sqInt obj;
				sqInt object;
				sqInt result;
				sqInt senderOop;
				char *spouseFP;
				StackPage *thePage;
				char *theSP;
				sqInt value;

				VM_LABEL(extPushReceiverVariableBytecode);
				index = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extA = 0;
				/* begin pushMaybeContextReceiverVariable: */
				obj = longAt(localFP + FoxIFReceiver);
				if ((index <= StackPointerIndex)
				 && (((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* begin instVar:ofContext: */
					assert(index < MethodIndex);
					assert(isContext(obj));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!(((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))) {
						value = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
						if ((index == InstructionPointerIndex)
						 && (((((value) & 7) == 1))
						 && ((((int) value)) < 0))) {
							/* begin internalMustMapMachineCodePC:context: */
							assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
							GIV(instructionPointer) = oopForPointer(localIP);
							GIV(stackPointer) = localSP;
							GIV(framePointer) = localFP;
							result = mustMapMachineCodePCcontext((value >> 3), obj);
							/* begin internalizeIPandSP */
							assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
							localIP = pointerForOop(GIV(instructionPointer));
							localSP = pointerForOop(GIV(stackPointer));
							localFP = pointerForOop(GIV(framePointer));
							value = result;
						}
						object = value;
						goto l161;
					}
					if (isWidowedContext(obj)) {
						object = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
						goto l161;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
					if (index == SenderIndex) {
						/* begin ensureCallerContext: */
						callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
						if (callerFP == 0) {
							/* base frame, context in saved ip slot (or base of stack in Cog) */
							/* begin frameCallerContext: */
							assert(isBaseFrame(spouseFP));
							thePage = stackPageAtpages(
								(assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages)))))),
								pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
								GIV(pages));
							callerContextOrNil = longAt((thePage->baseAddress));
							assert(addressCouldBeObj(callerContextOrNil));
							assert((callerContextOrNil == (nilObject()))
							 || (isContext(followMaybeForwarded(callerContextOrNil))));
							object = callerContextOrNil;
							goto l161;
						}
						/* begin frameCallerStackPointer: */
						assert(!(isBaseFrame(spouseFP)));
						theSP = (spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord;
						/* begin ensureFrameIsMarried:SP: */
						if (						/* begin frameHasContext: */
							((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
							? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
							: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
							assert(isContext(frameContext(callerFP)));
							object = longAt(callerFP + FoxThisContext);
							goto l161;
						}
						object = marryFrameSP(callerFP, theSP);
						goto l161;
					}
					if (index == StackPointerIndex) {
						assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
						object = (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 3) | 1);
						goto l161;
					}
					if (index == InstructionPointerIndex) {
						object = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
						goto l161;
					}
					error("bad index");
					object = 0;
	l161:	/* end instVar:ofContext: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), object);
				}
				else {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord()))))));
				}
			}
			BREAK;
		CASE(483) // 227	extPushLiteralVariableBytecode
			{
				sqInt index;
				sqInt litVar;
				sqInt objOop;

				VM_LABEL(extPushLiteralVariableBytecode);
				index = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extA = 0;
				/* begin pushLiteralVariable: */
				objOop = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((index + LiteralStart)) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(index + LiteralStart, GIV(method), objOop);
				}
				litVar = objOop;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord()))))));
			}
			BREAK;
		CASE(484) // 228	extPushLiteralBytecode
			{
				sqInt index;
				sqInt object;

				VM_LABEL(extPushLiteralBytecode);
				index = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extA = 0;
				/* begin pushLiteralConstant: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((index + LiteralStart)) << (shiftForWord())))));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(485) // 229	longPushTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt index;
				sqInt object;

				VM_LABEL(longPushTemporaryVariableBytecode);
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = 
				/* begin itemporary:in: */
(index < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord))
					: longAt(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			BREAK;
		CASE(488) // 232	extPushIntegerBytecode
			{
				sqInt value;

				VM_LABEL(extPushIntegerBytecode);
				value = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extB) << 8)));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				extB = 0;
				numExtB = 0;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), (((usqInt)value << 3) | 1));
			}
			BREAK;
		CASE(489) // 233	extPushCharacterBytecode
			{
				sqInt object;
				sqInt value;

				VM_LABEL(extPushCharacterBytecode);
				value = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				object = (((sqInt)((usqInt)(value) << (numTagBits())))) + (characterTag());
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
				extA = 0;
			}
			BREAK;
		CASE(490) // 234	extSendBytecode
			{
				sqInt byte;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(extSendBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((((((usqInt)(byte)) >> 3) + (((sqInt)((usqInt)(extA) << 5)))) + LiteralStart)) << (shiftForWord())))));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (((sqInt)((usqInt)(extB) << 3)));
				extB = 0;
				numExtB = 0;
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				lkupClassTag = 
				/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
					? tagBits
					: (longAt(rcvr)) & (classIndexMask()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(491) // 235	extSendSuperBytecode
			{
				sqInt byte;

				VM_LABEL(extSendSuperBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)((((((usqInt)(byte)) >> 3) + (((sqInt)((usqInt)(extA) << 5)))) + LiteralStart)) << (shiftForWord())))));
				extA = 0;
				if (extB >= 64) {
					GIV(argumentCount) = (byte & 7) + (((sqInt)((usqInt)((extB - 64)) << 3)));
					extB = 0;
					numExtB = 0;
					/* goto directedSuperclassSend */
					goto l165;
				}
				GIV(argumentCount) = (byte & 7) + (((sqInt)((usqInt)(extB) << 3)));
				extB = 0;
				numExtB = 0;
				goto superclassSend;
			}
	l165:	/* end case */;
			
		directedSuperclassSend:
			/* directedSuperclassSend */
			{
				sqInt aValue;
				sqInt class;
				sqInt err;
				sqInt hash;
				sqInt objOop;
				sqInt objOop1;
				sqInt referent;
				sqInt referent1;
				sqInt superclass;
				sqInt top;

				VM_LABEL(directedSuperclassSend);
				/* begin internalPopStack */
				top = longAt(localSP);
				localSP += BytesPerOop;
				class = top;
				if ((!((longAt(class)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(class));
					referent = longAt((class + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					class = referent;
				}
				/* begin superclassOf: */
				objOop = longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, class, objOop);
				}
				superclass = objOop;
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				flag("todo");
				/* To maintain the invariant that all receivers are unforwarded we need an explicit
				   read barrier in the super send cases.  Even though we always follow receivers
				   on become  e.g. super doSomethingWith: (self become: other) forwards the receiver
				   self pushed on the stack. */
				lkupClassTag = (((hash = (long32At(superclass + 4)) & (identityHashHalfWordMask()))) != 0
					? hash
					: (objCouldBeClassObj(superclass)
							? (((err = enterIntoClassTable(superclass))) != 0
									? -err
									: (long32At(superclass + 4)) & (identityHashHalfWordMask()))
							: -PrimErrBadReceiver));
				/* begin ensureReceiverUnforwarded */
				if (				/* begin isOopForwarded: */
					((!((longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop))) & (tagMask()))))
				 && ((!((longAt(longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(objOop1));
					referent1 = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent1 & (tagMask()))))
					 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					aValue = referent1;
					/* begin internalStackValue:put: */
					longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), aValue);
				}
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			BREAK;
		CASE(492) // 236	callMappedInlinedPrimitive
			{
				VM_LABEL(callMappedInlinedPrimitive);
				localIP -= 2;
				goto respondToUnknownBytecode;
			}
			BREAK;
		CASE(493) // 237	extUnconditionalJump
			{
				sqInt backwardJumpCountByte;
				sqInt bcpcDelta;
				sqInt byte;
				sqInt offset;
				sqInt switched;

				VM_LABEL(extUnconditionalJump);
				byte = byteAtPointer(++localIP);
				offset = byte + (((sqInt)((usqInt)(extB) << 8)));
				bcpcDelta = (offset < 0
					? numExtB * 2
					: 0);
				extB = 0;
				numExtB = 0;
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset + bcpcDelta) >= 0) {
					goto l166;
				}
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					switched = checkForEventsMayContextSwitch(1);
					returnToExecutivepostContextSwitch(1, switched);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (switched) {
						goto l166;
					}
				}
				backwardJumpCountByte = byteAt(localFP + ((VMBIGENDIAN
	? (FoxIFrameFlags + BytesPerWord) - 1
	: FoxIFrameFlags)));
				if (((backwardJumpCountByte -= 2)) == 1) {
					if (methodWithHeaderShouldBeCogged(methodHeaderOf(GIV(method)))) {
						/* begin externalizeIPandSP */
						assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						attemptToSwitchToMachineCode(((((oopForPointer(localIP)) - (offset + bcpcDelta)) - GIV(method)) - BaseHeaderSize) - 1);
					}
					backwardJumpCountByte = 0x7F;
				}
				else {
					if (backwardJumpCountByte == -1) {
						/* initialize the count */
						assert(minBackwardJumpCountForCompile <= 128);
						backwardJumpCountByte = (((sqInt)((usqInt)((minBackwardJumpCountForCompile - 1)) << 1))) + 1;
					}
				}
				/* begin iframeBackwardBranchByte:put: */
				byteAtput(localFP + ((VMBIGENDIAN
	? (FoxIFrameFlags + BytesPerWord) - 1
	: FoxIFrameFlags)), backwardJumpCountByte);
	l166:	/* end ifBackwardsCheckForEvents: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(494) // 238	extJumpIfTrue
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfTrue);
				byte = byteAtPointer(++localIP);
				offset = byte + (((sqInt)((usqInt)(extB) << 8)));
				numExtB = (extB = (extA = 0));
				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l167;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				localSP += 1 * BytesPerOop;
	l167:;
			}
			BREAK;
		CASE(495) // 239	extJumpIfFalse
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfFalse);
				byte = byteAtPointer(++localIP);
				offset = byte + (((sqInt)((usqInt)(extB) << 8)));
				numExtB = (extB = (extA = 0));
				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l168;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				}
				localSP += 1 * BytesPerOop;
	l168:;
			}
			BREAK;
		CASE(496) // 240	extStoreAndPopReceiverVariableBytecode
			{
				sqInt obj;
				int onCurrentPage;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				sqInt thePC;
				sqInt thePC1;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				obj = longAt(localFP + FoxIFReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && ((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
				 || (				/* begin is:methodAssignmentToContextWithMachineCodePC: */
					(variableIndex == MethodIndex)
				 && (((((int) ((thePC = longAt((value + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
				 && ((((thePC) & 7) == 1))))))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj));
					assert(!((isObjImmutable(obj))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!(						/* begin isStillMarriedContext: */
							(((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
						 && (!(isWidowedContext(obj))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(obj)));
						if ((						/* begin isOldObject: */
							assert(isNonImmediate(obj)),
						oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart)))) {
							/* most stores into young objects */
							if (							/* begin isYoung: */
								((!(value & (tagMask()))))
							 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt)((longAt(obj)))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(obj);
								}
							}
						}
						longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
						if (variableIndex == StackPointerIndex) {
							ensureContextIsExecutionSafeAfterAssignToStackPointer(obj);
						}
						goto l170;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - (smallIntegerTag()));
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						thePage = stackPageAtpages(
							(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, value);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l170;
					}
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj);
					if (					/* begin is:methodAssignmentToContextWithMachineCodePC: */
						(variableIndex == MethodIndex)
					 && (((((int) ((thePC1 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
					 && ((((thePC1) & 7) == 1)))) {
						ensureContextHasBytecodePC(obj);
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(obj)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(value & (tagMask()))))
						 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(obj)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(obj);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
					if (variableIndex == StackPointerIndex) {
						ensureContextIsExecutionSafeAfterAssignToStackPointer(obj);
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
	l170:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(obj))));
					if (((((usqInt)((longAt(obj)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), obj);
						longAtPointerput((localSP -= BytesPerOop), value);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l169;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(obj)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(value & (tagMask()))))
						 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(obj)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(obj);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), value);
	l169:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(497) // 241	extStoreAndPopLiteralVariableBytecode
			{
				sqInt litVar;
				usqInt methodPointer;
				sqInt objOop;
				sqInt value;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				value = longAtPointer(localSP);
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				methodPointer = GIV(method);
				/* begin followObjField:ofObject: */
				objOop = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(variableIndex + LiteralStart, methodPointer, objOop);
				}
				litVar = objOop;
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#        if IMMUTABILITY
				assert(!((isImmediate(litVar))));
				if (((((usqInt)((longAt(litVar)))) >> (immutableBitShift())) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), litVar);
					longAtPointerput((localSP -= BytesPerOop), value);
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l177;
				}
#        endif // IMMUTABILITY

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(litVar)),
				oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(value & (tagMask()))))
					 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(litVar)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(litVar);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))), value);
	l177:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(498) // 242	longStoreAndPopTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreAndPopTemporaryVariableBytecode);
				/* begin longStoreTemporaryVariableBytecode */
				index = byteAtPointer(++localIP);
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (index < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			BREAK;
		CASE(499) // 243	extStoreReceiverVariableBytecode
			{
				sqInt anObject;
				sqInt obj;
				int onCurrentPage;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				sqInt thePC;
				sqInt thePC1;
				sqInt variableIndex;

				VM_LABEL(extStoreReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				anObject = longAtPointer(localSP);
				/* begin storeMaybeContextReceiverVariable:withValue: */
				obj = longAt(localFP + FoxIFReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && ((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
				 || (				/* begin is:methodAssignmentToContextWithMachineCodePC: */
					(variableIndex == MethodIndex)
				 && (((((int) ((thePC = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
				 && ((((thePC) & 7) == 1))))))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj));
					assert(!((isObjImmutable(obj))));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!(						/* begin isStillMarriedContext: */
							(((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
						 && (!(isWidowedContext(obj))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(obj)));
						if ((						/* begin isOldObject: */
							assert(isNonImmediate(obj)),
						oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart)))) {
							/* most stores into young objects */
							if (							/* begin isYoung: */
								((!(anObject & (tagMask()))))
							 && (oopisLessThan(anObject, GIV(oldSpaceStart)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt)((longAt(obj)))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(obj);
								}
							}
						}
						longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), anObject);
						if (variableIndex == StackPointerIndex) {
							ensureContextIsExecutionSafeAfterAssignToStackPointer(obj);
						}
						goto l180;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
					/* begin withoutSmallIntegerTags: */
					assert((((senderOop) & 7) == 1));
					theFP = pointerForOop(senderOop - (smallIntegerTag()));
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						thePage = stackPageAtpages(
							(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, anObject);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l180;
					}
					/* begin externalizeIPandSP */
					assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj);
					if (					/* begin is:methodAssignmentToContextWithMachineCodePC: */
						(variableIndex == MethodIndex)
					 && (((((int) ((thePC1 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
					 && ((((thePC1) & 7) == 1)))) {
						ensureContextHasBytecodePC(obj);
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(obj)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(anObject & (tagMask()))))
						 && (oopisLessThan(anObject, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(obj)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(obj);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), anObject);
					if (variableIndex == StackPointerIndex) {
						ensureContextIsExecutionSafeAfterAssignToStackPointer(obj);
					}
					/* begin internalizeIPandSP */
					assert(GIV(instructionPointer) != (ceReturnToInterpreterPC()));
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
	l180:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#          if IMMUTABILITY
					assert(!((isImmediate(obj))));
					if (((((usqInt)((longAt(obj)))) >> (immutableBitShift())) & 1) != 0) {
						/* begin cannotAssign:to:withIndex: */
						longAtPointerput((localSP -= BytesPerOop), obj);
						longAtPointerput((localSP -= BytesPerOop), anObject);
						longAtPointerput((localSP -= BytesPerOop), (((usqInt)(variableIndex + 1) << 3) | 1));
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
						GIV(argumentCount) = 2;
						goto normalSend;
						goto l179;
					}
#          endif // IMMUTABILITY

					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(obj)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(obj)),
					oopisGreaterThanOrEqualTo(obj, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(anObject & (tagMask()))))
						 && (oopisLessThan(anObject, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(obj)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(obj);
							}
						}
					}
					longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(variableIndex) << (shiftForWord())))), anObject);
	l179:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(500) // 244	extStoreLiteralVariableBytecode
			{
				sqInt anObject;
				sqInt litVar;
				usqInt methodPointer;
				sqInt objOop;
				sqInt variableIndex;

				VM_LABEL(extStoreLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				anObject = longAtPointer(localSP);
				/* begin followObjLiteral:ofMethod: */
				methodPointer = GIV(method);
				/* begin followObjField:ofObject: */
				objOop = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((variableIndex + LiteralStart)) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(variableIndex + LiteralStart, methodPointer, objOop);
				}
				litVar = objOop;
				/* begin storePointerImmutabilityCheck:ofObject:withValue: */
#        if IMMUTABILITY
				assert(!((isImmediate(litVar))));
				if (((((usqInt)((longAt(litVar)))) >> (immutableBitShift())) & 1) != 0) {
					/* begin cannotAssign:to:withIndex: */
					longAtPointerput((localSP -= BytesPerOop), litVar);
					longAtPointerput((localSP -= BytesPerOop), anObject);
					longAtPointerput((localSP -= BytesPerOop), (((usqInt)(ValueIndex + 1) << 3) | 1));
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l187;
				}
#        endif // IMMUTABILITY

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(litVar)),
				oopisGreaterThanOrEqualTo(litVar, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(anObject & (tagMask()))))
					 && (oopisLessThan(anObject, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(litVar)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(litVar);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))), anObject);
	l187:	/* end storePointerImmutabilityCheck:ofObject:withValue: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
			}
			BREAK;
		CASE(501) // 245	longStoreTemporaryVariableBytecode
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreTemporaryVariableBytecode);
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				if (index < ((frameNumArgs = byteAt((localFP + FoxIFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
			}
			BREAK;
		CASE(505) // 249	extPushFullClosureBytecode
			{
				sqInt byte;
				sqInt compiledBlock;
				sqInt compiledBlockLiteralIndex;
				sqInt context;
				sqInt header;
				sqInt header1;
				sqInt i;
				int ignoreContext;
				usqInt methodPointer;
				usqInt newClosure;
				usqInt newClosure1;
				usqInt newObj;
				sqInt numArgs;
				usqInt numBytes;
				sqInt numCopied;
				sqInt numCopied1;
				sqInt numSlots;
				sqInt objFormat;
				sqInt objOop;
				int receiverIsOnStack;
				sqInt startIndex;

				VM_LABEL(extPushFullClosureBytecode);
				compiledBlockLiteralIndex = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extA) << 8)));
				extA = 0;
				/* begin followObjLiteral:ofMethod: */
				methodPointer = GIV(method);
				/* begin followObjField:ofObject: */
				objOop = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((compiledBlockLiteralIndex + LiteralStart)) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(compiledBlockLiteralIndex + LiteralStart, methodPointer, objOop);
				}
				compiledBlock = objOop;
				assert(isOopCompiledMethod(compiledBlock));
				/* begin argumentCountOf: */
				assert(isCompiledMethod(compiledBlock));
				header1 = longAt((compiledBlock + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
				header = ((((header1) & 7) == 1)
					? header1
					: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
						assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
						((((CogMethod *) header1))->methodHeader)));
				numArgs = (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
				byte = byteAtPointer(++localIP);
				numCopied = byte & (0x3F);
				receiverIsOnStack = ((byte & (128)) != 0);
				ignoreContext = ((byte & (64)) != 0);
				/* begin pushFullClosureNumArgs:copiedValues:compiledBlock:receiverIsOnStack:ignoreContext: */
				if (ignoreContext) {
					context = GIV(nilObj);
				}
				else {
					/* begin ensureFrameIsMarried:SP: */
					if (					/* begin frameHasContext: */
						((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
						? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
						: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
						assert(isContext(frameContext(localFP)));
						context = longAt(localFP + FoxThisContext);
						goto l195;
					}
					context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
	l195:	/* end ensureFrameIsMarried:SP: */;
				}
				/* begin fullClosureIn:numArgs:numCopiedValues:compiledBlock: */
								objFormat = indexablePointersFormat();
				numSlots = FullClosureFirstCopiedValueIndex + numCopied;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((numSlots >= 0)
				 && ((knownClassAtIndex(ClassFullBlockClosureCompactIndex)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat())
					? objFormat
					: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassFullBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l192;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassFullBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
	l192:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord())))), compiledBlock);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 3) | 1));
				newClosure = newClosure1;
				if (recordSendTrace()) {
					/* begin recordTrace:thing:source: */
					GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
					GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
					GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
					GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
				}
				if (receiverIsOnStack) {
					startIndex = FullClosureReceiverIndex;
					numCopied1 = numCopied + 1;
				}
				else {
					startIndex = FullClosureFirstCopiedValueIndex;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(newClosure)));
					longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord())))), longAt(localFP + FoxIFReceiver));
					numCopied1 = numCopied;
				}
				if (numCopied1 > 0) {
					for (i = 0; i < numCopied1; i += 1) {
						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + startIndex)) << (shiftForWord())))), longAtPointer(localSP + (((numCopied1 - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied1 * BytesPerOop;
				}
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			BREAK;
		CASE(506) // 250	extPushClosureBytecode
			{
				sqInt blockSize;
				sqInt byte;
				sqInt context;
				sqInt i;
				usqInt newClosure;
				usqInt newClosure1;
				usqInt newObj;
				sqInt numArgs;
				usqInt numBytes;
				sqInt numCopied;
				sqInt numSlots;
				sqInt objFormat;

				VM_LABEL(extPushClosureBytecode);
				byte = byteAtPointer(++localIP);
				numArgs = (byte & 7) + ((extA % 16) * 8);
				numCopied = ((((usqInt)(byte)) >> 3) & 7) + ((extA / 16) * 8);
				extA = 0;
				blockSize = (byteAtPointer(++localIP)) + (((sqInt)((usqInt)(extB) << 8)));
				numExtB = (extB = 0);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(localFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(localFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((localFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l199;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
	l199:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
								objFormat = indexablePointersFormat();
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((numSlots >= 0)
				 && ((knownClassAtIndex(ClassBlockClosureCompactIndex)) != GIV(nilObj)));
				assert(((objFormat < (firstByteFormat())
					? objFormat
					: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l198;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
	l198:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)(((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize)) << 3) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 3) | 1));
				newClosure = newClosure1;
				if (recordSendTrace()) {
					/* begin recordTrace:thing:source: */
					GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockCreation;
					GIV(traceLog)[GIV(traceLogIndex) + 1] = newClosure;
					GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromInterpreter;
					GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
				}
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {
						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			BREAK;
		}
	}
	/* undo the pre-increment of IP (in fetchByte in fetchNextBytecode) before returning */
	localIP -= 1;
	assert((((usqInt)localIP)) != (ceReturnToInterpreterPC()));
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}

	/* CogBlockMethod>>#cmHomeMethod */
static NoDbgRegParms CogMethod *
cmHomeMethod(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cpicHasMNUCaseOrCMIsFullBlock)
		? ((CogMethod *) self_in_CogBlockMethod)
		: ((CogMethod *) ((((usqInt)self_in_CogBlockMethod)) - ((self_in_CogBlockMethod->homeOffset)))));
}

	/* CogBlockMethod>>#isCMBlock */
static NoDbgRegParms int
isCMBlock(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMBlock;
}

	/* CogBlockMethod>>#isCMClosedPIC */
static NoDbgRegParms int
isCMClosedPIC(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMClosedPIC;
}

	/* CogBlockMethod>>#isCMMethodEtAl */
static NoDbgRegParms int
isCMMethodEtAl(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) >= CMMethod;
}

	/* CogBlockMethod>>#isCMMethodFlaggedForBecome */
static NoDbgRegParms int
isCMMethodFlaggedForBecome(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMMethodFlaggedForBecome;
}

	/* CogBlockMethod>>#isCMOpenPIC */
static NoDbgRegParms int
isCMOpenPIC(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMOpenPIC;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static NoDbgRegParms sqInt
addressIsInPage(StackPage *self_in_CogStackPage, char *address)
{
	return (((self_in_CogStackPage->lastAddress)) < address)
	 && (address < ((self_in_CogStackPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static NoDbgRegParms int
isFree(StackPage *self_in_CogStackPage)
{
	return ((self_in_CogStackPage->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static NoDbgRegParms sqInt
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return null;
	}
	if (isFree(prev = (aPage->prevPage))) {
		return null;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
	return 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static NoDbgRegParms void
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static NoDbgRegParms sqInt
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return null;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return null;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
	return 0;
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static NoDbgRegParms sqInt
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return null;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
	return 0;
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static NoDbgRegParms StackPage *
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static NoDbgRegParms StackPage *
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(
		(		/* begin pageIndexFor: */
			assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statNumMaps) == 0
		? 0.0
		: (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps));
}

	/* CoInterpreter>>#accessorDepthForPrimitiveIndex: */
sqInt
accessorDepthForPrimitiveIndex(sqInt primIndex)
{
	return ((sqInt)((primitiveMetadataTable[primIndex]))) >> SpurPrimitiveAccessorDepthShift;
}


/*	Activate newMethod when newMethod has been cogged, i.e. create a
	machine-code frame and (re)enter machine-code.
 */

	/* CoInterpreter>>#activateNewCogMethod:inInterpreter: */
static NoDbgRegParms void
activateNewCogMethodinInterpreter(CogMethod *cogMethod, sqInt inInterpreter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt i;
    sqInt methodHeader;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;

	assert((rawHeaderOf(GIV(newMethod))) == (((sqInt)cogMethod)));
	methodHeader = (cogMethod->methodHeader);
	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (((cogMethod->cmNumArgs)) * BytesPerWord));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	if (((cogMethod->stackCheckOffset)) == 0) {
		/* frameless method; nothing to activate... */
		if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
			callRegisterArgCogMethodatreceiver(cogMethod, noCheckEntryOffset(), rcvr);
		};
		object = (((sqInt)cogMethod)) + (noCheckEntryOffset());
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp2;
		ceCallCogCodePopReceiverReg();
		error("should not be reached");
	}
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp3;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), ((sqInt)cogMethod));
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = (((cogMethod->cmNumArgs)) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	if ((((methodHeader & AlternateHeaderHasPrimFlag) != 0))
	 && (GIV(primFailCode) != 0)) {
		reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
	}
	if (GIV(stackPointer) >= GIV(stackLimit)) {
		assert(((cogMethod->stackCheckOffset)) > (noCheckEntryOffset()));
		object1 = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
		/* begin push: */
		longAtput((sp8 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp8;
		/* begin push: */
		longAtput((sp9 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp9;
		ceEnterCogCodePopReceiverReg();
		error("should not be reached");
	}
	GIV(instructionPointer) = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	returnToExecutivepostContextSwitch(inInterpreter, switched);
}

	/* CoInterpreter>>#activateNewMethod */
static void
activateNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    int inInterpreter;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt switched;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;
	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp1;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp2;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
		? 0x100
		: 0);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp3;
	object = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & AlternateHeaderHasPrimFlag) != 0)) {
		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 3 /* begin sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}
	switched = 1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */
/*	Override to refuse to cache other than compiled methods.
	This protects open PICs against having to test for compiled methods. */

	/* CoInterpreter>>#addNewMethodToCache: */
static NoDbgRegParms void
addNewMethodToCache(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt err;
    sqInt err1;
    sqInt err2;
    sqInt firstBytecode;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt hash3;
    sqInt header;
    sqInt methodHeader;
    sqInt p;
    sqInt primitiveIndex;
    sqInt probe;

	if (!(		/* begin isOopCompiledMethod: */
			((!(GIV(newMethod) & (tagMask()))))
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
		return;
	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	flag("todo");
	if (((hash1 = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0) {
		classTag = hash1;
	}
	else {
		if (objCouldBeClassObj(classObj)) {
			if (((err = enterIntoClassTable(classObj))) != 0) {
				classTag = -err;
			}
			else {
				classTag = (long32At(classObj + 4)) & (identityHashHalfWordMask());
			}
		}
		else {
			classTag = -PrimErrBadReceiver;
		}
	}
	/* begin methodCacheHashOf:with: */
	hash = GIV(messageSelector) ^ (((sqInt)((usqInt)(classTag) << 2)));
	if (	/* begin isOopCompiledMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
		/* begin primitiveIndexOf: */
		assert(isCompiledMethod(GIV(newMethod)));
		header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		methodHeader = ((((header) & 7) == 1)
			? header
			: (assert((((usqInt)header)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header))->methodHeader)));
		primitiveIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod)))
		 && (isForwarded(GIV(newMethod)))));
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt)(hash)) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {
			/* Found an empty entry -- use it */
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = ((/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj)),
flag("todo"),
(((hash2 = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
		? hash2
		: (objCouldBeClassObj(classObj)
				? (((err1 = enterIntoClassTable(classObj))) != 0
						? -err1
						: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver))));
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));
			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}
	/* first probe */
	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = ((/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj)),
flag("todo"),
(((hash3 = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
		? hash3
		: (objCouldBeClassObj(classObj)
				? (((err2 = enterIntoClassTable(classObj))) != 0
						? -err2
						: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver))));
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));
	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */
	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt)(hash)) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}

	/* CoInterpreter>>#argumentCountAddress */
usqInt
argumentCountAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(argumentCount))));
}


/*	Coerce either a CMMethod or a CMBlock to the home CMMethod */

	/* CoInterpreter>>#asCogHomeMethod: */
static NoDbgRegParms CogMethod *
asCogHomeMethod(CogBlockMethod *aCogMethod)
{
	return (((aCogMethod->cmType)) >= CMMethod
		? ((CogMethod *) aCogMethod)
		: 
			/* begin cmHomeMethod */
((aCogMethod->cpicHasMNUCaseOrCMIsFullBlock)
				? ((CogMethod *) aCogMethod)
				: ((CogMethod *) ((((usqInt)aCogMethod)) - ((aCogMethod->homeOffset))))));
}

	/* CoInterpreter>>#assertValidExecutionPointe:r:s:imbar:line: */
static NoDbgRegParms void
assertValidExecutionPointersimbarline(usqInt lip, char *lifp, char *lisp, sqInt inInterpreter, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt methodField;
    sqInt methodField1;
    usqInt theIP;

	assertl(GIV(stackPage) == (mostRecentlyUsedPage()), ln);
	assertl(addressIsInPage(GIV(stackPage), lifp), ln);
	assert(deferStackLimitSmashAroundwith(assertValidStackLimits, ln));
	assertl(lisp < lifp, ln);
	assertl(lifp > lisp, ln);
	assertl(lisp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())), ln);
	assertl(((lifp - lisp) / BytesPerOop) < LargeContextSlots, ln);
	methodField = longAt(lifp + FoxMethod);
	if (inInterpreter) {
		assertl(!(isMachineCodeFrame(lifp)), ln);
		assertl(GIV(method) == methodField, ln);
		assertl((methodUsesAlternateBytecodeSet(GIV(method))) == (GIV(bytecodeSetSelector) == 0x100), ln);
		if (assertal(cheapAddressCouldBeInHeap(methodField), ln)) {
			theIP = (lip == (ceReturnToInterpreterPC())
				? ((usqInt)(longAt(lifp + FoxIFSavedIP)))
				: lip);
			assertl((theIP >= (methodField + (lastPointerOf(methodField))))
			 && (theIP < (((methodField + (numBytesOfBytes(methodField))) + BaseHeaderSize) - 1)), ln);
		}
		assertl((iframeIsBlockActivation(lifp))
		 || ((pushedReceiverOrClosureOfFrame(lifp)) == (iframeReceiver(lifp))), ln);
	}
	else {
		assertl(isMachineCodeFrame(lifp), ln);
		if ((assertal((((usqInt)methodField)) >= (minCogMethodAddress()), ln))
		 && (assertal((((usqInt)methodField)) < (maxCogMethodAddress()), ln))) {
			/* begin mframeHomeMethod: */
			methodField1 = longAt(lifp + FoxMethod);
			if ((methodField1 & MFMethodFlagIsBlockFlag) != 0) {
				cogMethod = 
				/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField1 & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
					? ((CogMethod *) (((CogBlockMethod *) (methodField1 & MFMethodMask))))
					: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField1 & MFMethodMask))))) - (((((CogBlockMethod *) (methodField1 & MFMethodMask)))->homeOffset)))));
				goto l1;
			}
			cogMethod = ((CogMethod *) (methodField1 & MFMethodMask));
	l1:	/* end mframeHomeMethod: */;
			assertl((lip > (methodField + ((mframeIsBlockActivation(lifp)
	? sizeof(CogBlockMethod)
	: sizeof(CogMethod)))))
			 && (lip < (methodField + ((cogMethod->blockSize)))), ln);
		}
		assertl((mframeIsBlockActivation(lifp))
		 || ((pushedReceiverOrClosureOfFrame(lifp)) == (mframeReceiver(lifp))), ln);
	}
	if ((longAt(lifp + FoxSavedFP)) == 0) {
		assertl(frameHasContext(lifp), ln);
		assertl((frameContext(lifp)) == (longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord)), ln);
	}
}


/*	Check that the stacked instruction pointers in the given page are correct.
	Checks the interpreter sender/machine code callee contract. */

	/* CoInterpreter>>#assertValidStackedInstructionPointersIn:line: */
static NoDbgRegParms sqInt
assertValidStackedInstructionPointersInline(StackPage *aStackPage, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt methodField;
    usqInt methodObj;
    sqInt prevFrameWasCogged;
    char *theFP;
    usqInt theIP;
    CogMethod *theMethod;

	if (!(assertal(!(isFree(aStackPage)), ln))) {
		return 0;
	}
	/* The top of stack of an inactive page is always the instructionPointer.
	   The top of stack of the active page may be the instructionPointer if it has been pushed,
	   which is indicated by a 0 instructionPointer. */
	prevFrameWasCogged = 0;
	if ((GIV(stackPage) == aStackPage)
	 && (GIV(instructionPointer) != 0)) {
		theIP = GIV(instructionPointer);
		theFP = GIV(framePointer);
	}
	else {
		theIP = ((usqInt)(longAt((aStackPage->headSP))));
		theFP = (aStackPage->headFP);
		if (GIV(stackPage) == aStackPage) {
			assertl(GIV(framePointer) == theFP, ln);
		}
	}
	while (1) {
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			/* begin mframeHomeMethod: */
			methodField = longAt(theFP + FoxMethod);
			if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
				theMethod = 
				/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
					? ((CogMethod *) (((CogBlockMethod *) (methodField & MFMethodMask))))
					: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset)))));
				goto l1;
			}
			theMethod = ((CogMethod *) (methodField & MFMethodMask));
	l1:	/* end mframeHomeMethod: */;
			assertl((theIP == (ceCannotResumePC()))
			 || ((theIP >= (((usqInt)theMethod)))
			 && (theIP < ((((usqInt)theMethod)) + ((theMethod->blockSize))))), ln);
			prevFrameWasCogged = 1;
		}
		else {
			/* assert-check the interpreter frame. */
			methodObj = longAt(theFP + FoxMethod);
			if (prevFrameWasCogged) {
				assertl(theIP == (ceReturnToInterpreterPC()), ln);
			}
			if (theIP == (ceReturnToInterpreterPC())) {
				theIP = ((usqInt)(longAt(theFP + FoxIFSavedIP)));
			}
			assertl((theIP >= (methodObj + (lastPointerOf(methodObj))))
			 && (theIP < (((methodObj + (numBytesOfBytes(methodObj))) + BaseHeaderSize) - 1)), ln);
			prevFrameWasCogged = 0;
		}
		theIP = ((usqInt)(longAt(theFP + FoxCallerSavedIP)));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theFP = callerFP;
	}
	assertl(theIP == (ceBaseFrameReturnPC()), ln);
	return 1;
}


/*	Check that the stacked instruction pointers in all pages are correct.
	Checks the interpreter sender/machine code callee contract.
	Written so it will be optimized away if not in an assert VM. */

	/* CoInterpreter>>#assertValidStackedInstructionPointers: */
static NoDbgRegParms void
assertValidStackedInstructionPointers(sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			assertl(assertValidStackedInstructionPointersInline(thePage, ln), ln);
		}
	}
}


/*	Attempt to convert the current interpreted activation into a machine code
	activation, and if this is popssible, jump into machine code. bcpc is the
	0-relative pc of the backward branch bytecode (not any preceding
	extension).  */

	/* CoInterpreter>>#attemptToSwitchToMachineCode: */
static NoDbgRegParms void
attemptToSwitchToMachineCode(sqInt bcpc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closure;
    sqInt cls;
    CogMethod *cogMethod;
    CogBlockMethod *cogMethod1;
    CogBlockMethod *cogMethod2;
    CogMethod *homeMethod;
    sqInt methodField;
    sqInt methodHeader;
    char *p;
    usqInt pc;
    usqInt pc1;
    char *sp;
    char *sp1;
    sqInt startBcpc;
    char *theFP;

	if (!(methodHasCogMethod(GIV(method)))) {
		if (((byteAt((GIV(framePointer) + FoxIFrameFlags) + 3)) != 0)
		 && (!(isVanillaBlockClosure((cls = frameStackedReceivernumArgs(GIV(framePointer), 
		/* begin frameNumArgs: */
((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? ((mframeCogMethod(GIV(framePointer)))->cmNumArgs)
			: byteAt((GIV(framePointer) + FoxIFrameFlags) + 1)))))))) {
			/* Compiled block / full closure */
			cogFullBlockMethodnumCopied(GIV(method), (numPointerSlotsOf(cls)) - FullClosureFirstCopiedValueIndex);
		}
		else {
			/* Compiled method */
			cogselector(GIV(method), GIV(nilObj));
		}
	}
	if (methodHasCogMethod(GIV(method))) {
		/* begin cogMethodOf: */
		methodHeader = longAt((GIV(method) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader))
		 && ((((usqInt)methodHeader)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader);
		/* begin convertToMachineCodeFrame:bcpc: */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		if ((longAt(GIV(framePointer) + FoxSavedFP)) == 0) {
			longAtput(GIV(framePointer) + FoxCallerSavedIP, ceBaseFrameReturnPC());
		}
		else {
			if (!((((usqInt)(longAt((pointerForOop(longAt(GIV(framePointer) + FoxSavedFP))) + FoxMethod)))) < (startOfMemory()))) {
				theFP = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				/* begin iframeSavedIP:put: */
				assert(!(isMachineCodeFrame(theFP)));
				longAtput(theFP + FoxIFSavedIP, ((sqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP)))));
				longAtput(GIV(framePointer) + FoxCallerSavedIP, ceReturnToInterpreterPC());
			}
		}
		if ((byteAt((GIV(framePointer) + FoxIFrameFlags) + 3)) != 0) {
			closure = longAt(GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer))));
			if (((((longAt((closure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1)) {
				startBcpc = (((longAt((closure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))))) >> 3)) - 1;
				cogMethod2 = findMethodForStartBcpcinHomeMethod(startBcpc, cogMethod);
			}
			else {
				startBcpc = (((/* begin literalCountOfMethodHeader: */
	assert((((((cogMethod->methodHeader))) & 7) == 1)),
((((cogMethod->methodHeader)) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
				cogMethod2 = ((CogBlockMethod *) cogMethod);
			}
			methodField = (((sqInt)cogMethod2)) + MFMethodFlagIsBlockFlag;
		}
		else {
			startBcpc = (((/* begin literalCountOfMethodHeader: */
	assert((((((cogMethod->methodHeader))) & 7) == 1)),
((((cogMethod->methodHeader)) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
			cogMethod2 = ((CogBlockMethod *) cogMethod);
			methodField = ((sqInt)cogMethod);
		}
		pc1 = mcPCForBackwardBranchstartBcpcin(bcpc, startBcpc, cogMethod2);
		assert(pc1 > ((((usqInt)cogMethod2)) + (noCheckEntryOffset())));
		assert(bcpc == (bytecodePCForstartBcpcin(pc1, startBcpc, cogMethod2)));
		longAtput(GIV(framePointer) + FoxMethod, methodField + (((byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0
	? MFMethodFlagHasContextFlag
	: 0)));
		for (p = (GIV(framePointer) + FoxIFReceiver); p >= GIV(stackPointer); p += (-BytesPerWord)) {
			longAtput((p + FoxMFReceiver) - FoxIFReceiver, longAt(p));
		}
		GIV(stackPointer) = (GIV(stackPointer) + FoxMFReceiver) - FoxIFReceiver;
		pc = pc1;
		/* begin assertValidMachineCodeFrame: */
		assert(isMachineCodeFrame(GIV(framePointer)));
		cogMethod1 = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
		homeMethod = 
		/* begin asCogHomeMethod: */
(((cogMethod1->cmType)) >= CMMethod
			? ((CogMethod *) cogMethod1)
			: ((cogMethod1->cpicHasMNUCaseOrCMIsFullBlock)
					? ((CogMethod *) cogMethod1)
					: ((CogMethod *) ((((usqInt)cogMethod1)) - ((cogMethod1->homeOffset))))));
		assert((methodFor(cogMethod1)) == homeMethod);
		assert((pc > (((sqInt)cogMethod1)))
		 && (pc < ((((sqInt)homeMethod)) + ((homeMethod->blockSize)))));
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), pc);
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
}


/*	Support for primitiveSuspend.
	Assume suspendedContext is that of a process waiting on a condition
	variable. Backup the PC of suspendedContext to the send that entered the
	wait state.
	primitiveEnterCriticalSection pushes false for blocked waiters. false must
	be replaced by the condition variable. */
/*	The suspendedContext is in one of six states, hence six cases:
	1 & 2: single context with bytecode pc or single context with machine code
	pc 3 & 4: married to machine code frame in embedded (v3) block or machine
	code frame in method/full block
	5 & 6: married to interpreter frame with saved ip or interpreter frame
	with pushed pc */

	/* CoInterpreter>>#backupContext:toBlockingSendTo: */
static NoDbgRegParms void
backupContexttoBlockingSendTo(sqInt suspendedContext, sqInt conditionVariable)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *cogMethod;
    sqInt mcpc;
    sqInt pc;
    sqInt senderOop;
    sqInt sp;
    sqInt startBcpc;
    char *theFP;
    sqInt theIP;
    sqInt theMethod;
    sqInt theNewIP;
    StackPage *thePage;

	startBcpc = 0;
	assert(isContext(suspendedContext));
	/* cases 1 & 2 */
	theMethod = longAt((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	if ((!((longAt((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())))) {
		pc = longAt((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		sp = longAt((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		assert(((((pc) & 7) == 1))
		 && (((pc >> 3)) != 0));
		assert(((((sp) & 7) == 1))
		 && (((sp >> 3)) > 0));
		if (((pc = (pc >> 3))) < 0) {
			/* context with machine code pc; must map... */
			pc = ((mustMapMachineCodePCcontext(pc, suspendedContext)) >> 3);
		}
		theIP = ((theMethod + BaseHeaderSize) + pc) - 1;
		theNewIP = pcPreviousToFunction(theIP, theMethod);
		assert((theNewIP < theIP)
		 && ((theIP - theNewIP) <= 3));
		pc = ((theNewIP - theMethod) - BaseHeaderSize) + 1;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(suspendedContext)));
		longAtput((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), (((usqInt)pc << 3) | 1));
		/* implicitly converts to 0 relative */
		sp = ((sp >> 3)) + ReceiverIndex;
		assert(((fetchPointerofObject(sp, suspendedContext)) == (falseObject()))
		 || ((fetchPointerofObject(sp, suspendedContext)) == conditionVariable));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(suspendedContext)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(suspendedContext)),
		oopisGreaterThanOrEqualTo(suspendedContext, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(conditionVariable & (tagMask()))))
			 && (oopisLessThan(conditionVariable, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(suspendedContext)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(suspendedContext);
				}
			}
		}
		longAtput((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(sp) << (shiftForWord())))), conditionVariable);
		return;
	}
	assert(isMarriedOrWidowedContext(suspendedContext));
	assert(!((isWidowedContextNoConvert(suspendedContext))));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	assert(!((thePage == GIV(stackPage))));
	assert(theFP == ((thePage->headFP)));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		/* cases 3 & 4 */
		/* a machine code pc... it must be converted... */
		mcpc = longAt((thePage->headSP));
		/* begin mframeCogMethod: */
		cogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
		if (((cogMethod->cmType)) == CMBlock) {
			/* case 3 */
			assert((frameStackedReceivernumArgs(theFP, (cogMethod->cmNumArgs))) == (fetchPointerofObject(ClosureIndex, suspendedContext)));
			(((longAt(((longAt((suspendedContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))))) >> 3)) - 1;
		}
		else {
			startBcpc = ((literalCountOf(theMethod)) + LiteralStart) * BytesPerOop;
		}
		theIP = bytecodePCForstartBcpcin(mcpc, startBcpc, cogMethod);
		theIP = (theIP + theMethod) + BaseHeaderSize;
		theNewIP = pcPreviousToFunction(theIP, theMethod);
		assert((theNewIP < theIP)
		 && ((theIP - theNewIP) <= 3));
		convertFrametoInterpreterFrame(theFP, theIP - theNewIP);
	}
	else {
		/* cases 5&6 */
		theIP = longAt((thePage->headSP));
		if (theIP == (ceReturnToInterpreterPC())) {
			/* case 5 */
			/* fetchByte uses pre-increment; must + 1 to point at correct bytecode... */
			theIP = (((usqInt)(longAt(theFP + FoxIFSavedIP)))) + 1;
			theNewIP = pcPreviousToFunction(theIP, theMethod);
			assert((theNewIP < theIP)
			 && ((theIP - theNewIP) <= 3));
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(theFP)));
			longAtput(theFP + FoxIFSavedIP, theNewIP - 1);
		}
		else {
			/* case 6 */
			/* fetchByte uses pre-increment; must + 1 to point at correct bytecode... */
			theIP += 1;
			assert(validInstructionPointerinMethodframePointer(theIP, theMethod, theFP));
			theNewIP = pcPreviousToFunction(theIP, theMethod);
			assert((theNewIP < theIP)
			 && ((theIP - theNewIP) <= 3));
			longAtput((thePage->headSP), theNewIP - 1);
		}
	}
	assert(((longAt(((thePage->headSP)) + BytesPerWord)) == (falseObject()))
	 || ((longAt(((thePage->headSP)) + BytesPerWord)) == conditionVariable));
	longAtput(((thePage->headSP)) + BytesPerWord, conditionVariable);
}

	/* CoInterpreter>>#callForCogCompiledCodeCompaction */
void
callForCogCompiledCodeCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(cogCompiledCodeCompactionCalledFor) = 1;
	forceInterruptCheck();
}


/*	convert
	rcvr	base
	arg(s)
	retpc	<- sp
	to
	retpc	base
	entrypc
	rcvr
	arg(s)	<- sp
	and then enter at either the checked or the unchecked entry-point. */

	/* CoInterpreter>>#callRegisterArgCogMethod:at:receiver: */
static NoDbgRegParms void
callRegisterArgCogMethodatreceiver(CogMethod *cogMethod, sqInt entryOffset, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt object1;
    char *sp;
    char *sp1;
    char *sp2;

	assert(((cogMethod->cmNumArgs)) <= (numRegArgs()));
	if (((cogMethod->cmNumArgs)) == 2) {
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (3 * BytesPerWord), longAt(GIV(stackPointer)));
		object = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (1 * BytesPerWord), longAt(GIV(stackPointer) + (3 * BytesPerWord)));
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), rcvr);
		longAtput(GIV(stackPointer) + (3 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
		ceCallCogCodePopReceiverArg1Arg0Regs();
	}
	if (((cogMethod->cmNumArgs)) == 1) {
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), longAt(GIV(stackPointer)));
		object1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (1 * BytesPerWord), rcvr);
		longAtput(GIV(stackPointer) + (2 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
		ceCallCogCodePopReceiverArg0Regs();
	}
	assert(((cogMethod->cmNumArgs)) == 0);
	/* begin stackValue:put: */
	longAtput(GIV(stackPointer) + (1 * BytesPerWord), longAt(GIV(stackPointer)));
	longAtput(GIV(stackPointer) + (0 * BytesPerWord), (((sqInt)cogMethod)) + entryOffset);
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	ceCallCogCodePopReceiverReg();
}


/*	An external call or FFI primitive has failed. Build the frame and
	activate as appropriate. Enter either the interpreter or machine
	code depending on whether aPrimitiveMethod has been or is still
	cogged. Note that we could always interpret but want the efficiency
	of executing machine code if it is available. */

	/* CoInterpreter>>#ceActivateFailingPrimitiveMethod: */
void
ceActivateFailingPrimitiveMethod(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodHeader;
    sqInt result;
    char *sp;

	assert(GIV(primFailCode) != 0);
	assert(GIV(newMethod) == aPrimitiveMethod);
	primitiveFunctionPointer = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(aPrimitiveMethod, primitiveIndexOf(aPrimitiveMethod), null);
	retryPrimitiveOnFailure();
	if (!GIV(primFailCode)) {
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && ((ioHighResClock()) >= GIV(nextProfileTick))) {
			ceTakeProfileSample(null);
		}
		result = longAt(GIV(stackPointer));
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(instructionPointer));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), result);
		GIV(stackPointer) = sp;
		ceEnterCogCodePopReceiverReg();
	}
	methodHeader = longAt((aPrimitiveMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		activateNewCogMethodinInterpreter(((CogMethod *) methodHeader), 0);
	}
	else {
		activateNewMethod();
	}
}


/*	Return across a page boundary. The context to return to (which may be
	married) is stored in the first word of the stack. We get here when a
	return instruction jumps
	to the ceBaseFrameReturn: address that is the return pc for base frames. A
	consequence of this is that the current frame is no longer valid since an
	interrupt may have overwritten
	its state as soon as the stack pointer has been cut-back beyond the return
	pc. So to have
	a context to send the cannotReturn: message to we also store the base
	frame's context
	in the second word of the stack page. */

	/* CoInterpreter>>#ceBaseFrameReturn: */
sqInt
ceBaseFrameReturn(sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    char *callerFP;
    sqInt contextToReturnFrom;
    sqInt contextToReturnTo;
    char *fp;
    char *frameAbove;
    sqInt isAContext;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt senderOop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    StackPage *thePage;

	assert((stackPageFor(GIV(stackPointer))) == GIV(stackPage));
	assert((mostRecentlyUsedPage()) == GIV(stackPage));
	assertCStackWellAligned();
	assert(GIV(framePointer) == 0);
	assert(GIV(stackPointer) <= (((GIV(stackPage)->baseAddress)) - BytesPerWord));
	assert((((GIV(stackPage)->baseFP)) + (2 * BytesPerWord)) < ((GIV(stackPage)->baseAddress)));
	assert((addressCouldBeObj(longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord)))
	 && (isContext(longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord))));
	contextToReturnTo = longAt((GIV(stackPage)->baseAddress));
	assert(addressCouldBeObj(contextToReturnTo));
	freeStackPageNoAssert(GIV(stackPage));
	isAContext = 
	/* begin isContext: */
((!(contextToReturnTo & (tagMask()))))
	 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex);
	if (isAContext
	 && (	/* begin isStillMarriedContext: */
		(((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(contextToReturnTo))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		GIV(framePointer) = pointerForOop(senderOop - (smallIntegerTag()));
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) GIV(framePointer))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) GIV(framePointer))) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(GIV(framePointer), GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		if (GIV(framePointer) == ((thePage->headFP))) {
			GIV(stackPointer) = (thePage->headSP);
		}
		else {
			/* Returning to some interior frame, presumably because of a sender assignment.
			   Move the frames above to another page (they may be in use, e.g. via coroutining).
			   Make the interior frame the top frame. */
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == GIV(framePointer)) {
				frameAbove = 0;
				goto l3;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == GIV(framePointer)) {
					frameAbove = fp;
					goto l3;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			frameAbove = 0;
	l3:	/* end findFrameAbove:inPage: */;
			/* begin newStackPage */
			lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
			if (((lruOrFree->baseFP)) == 0) {
				newPage = lruOrFree;
				goto l4;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
	l4:	/* end newStackPage */;
			assert(newPage == GIV(stackPage));
			moveFramesInthroughtoPage(thePage, frameAbove, newPage);
			markStackPageMostRecentlyUsed(newPage);
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (thePage->headSP);
			GIV(framePointer) = (thePage->headFP);
		}
	}
	else {
		if (!(isAContext
			 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1)))) {
			contextToReturnFrom = longAt(((GIV(stackPage)->baseAddress)) - BytesPerWord);
			tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(contextToReturnFrom, contextToReturnTo, returnValue);
			/* begin externalCannotReturn:from: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), contextToReturnFrom);
			GIV(stackPointer) = sp;
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), returnValue);
			GIV(stackPointer) = sp1;
			/* begin push: */
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp2;
			return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), contextToReturnFrom, 1);
		}
		GIV(instructionPointer) = 0;
		thePage = makeBaseFrameFor(contextToReturnTo);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	assert((stackPageFor(GIV(framePointer))) == GIV(stackPage));
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp3;
		ceEnterCogCodePopReceiverReg();
	}
	GIV(instructionPointer) = longAt(GIV(stackPointer));
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
	}
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	/* begin setMethod: */
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), returnValue);
	assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, GIV(framePointer)));
	ceInvokeInterpret();
	return null;
}


/*	index is unboxed and 0-based. The call-back expects 1-based value (to
	perform the operation with instVarAt:put:
 */

	/* CoInterpreter>>#ceCannotAssignTo:withIndex:valueToAssign: */
#if IMMUTABILITY
sqInt
ceCannotAssignTowithIndexvalueToAssign(sqInt immutableObject, sqInt index, sqInt valueToAssign)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    sqInt top;


	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), immutableObject);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), valueToAssign);
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), (((usqInt)(index + 1) << 3) | 1));
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp3;
	return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAttemptToAssign) << (shiftForWord()))))), immutableObject, 2);
}
#endif /* IMMUTABILITY */


/*	A context that has been returned from, or otherwise has an invalid pc has
	been reentered.
	Until we have a cannotResume: selector, simply resend cannotReturn:. */

	/* CoInterpreter>>#ceCannotResume */
sqInt
ceCannotResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    sqInt resultOop;
    char *sp;
    char *sp1;
    char *sp2;

	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(frameHasContext(GIV(framePointer)));
	resultOop = longAt(GIV(stackPointer));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt(GIV(framePointer) + FoxThisContext));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), resultOop);
	GIV(stackPointer) = sp1;
	object = ceCannotResumePC();
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp2;
	return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), longAt(GIV(framePointer) + FoxThisContext), 1);
}


/*	Log failure and then retry if there's an accessorDepth or failure due to
	no memory.
 */

	/* CoInterpreter>>#ceCheckAndMaybeRetryPrimitive: */
void
ceCheckAndMaybeRetryPrimitive(sqInt primIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodSelectorOrImmediate;
    sqInt retried;
    sqInt tagBits;

	if ((recordPrimTrace())
	 && (!primTracePluginName)) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TracePrimitiveFailure;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
		aMethodSelectorOrImmediate = 
		/* begin fetchClassOf: */
(((tagBits = (longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord))) & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
			: fetchClassOfNonImm(longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord))));
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = aMethodSelectorOrImmediate;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	retried = retryPrimitiveOnFailure();
	if (retried
	 && (recordPrimTrace())) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TracePrimitiveRetry;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
}

	/* CoInterpreter>>#ceCheckForInterrupt */
void
ceCheckForInterrupt(void)
{
    sqInt switched;

	switched = checkForEventsMayContextSwitch(1);
	returnToExecutivepostContextSwitch(0, switched);
}

	/* CoInterpreter>>#ceContext:instVar: */
sqInt
ceContextinstVar(sqInt maybeContext, sqInt slotIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt result;
    char *sp;
    sqInt top;

	if (((longAt(maybeContext)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		result = externalInstVarofContext(slotIndex, maybeContext);
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
	}
	else {
		result = longAt((maybeContext + BaseHeaderSize) + (((sqInt)((usqInt)(slotIndex) << (shiftForWord())))));
	}
	return result;
}


/*	genStorePop:MaybeContextReceiverVariable: filters out unmarried contexts
	but not arbitrary objects in subclasses. It answers maybeMarriedContext so
	that the StackToRegisterMappingCogit can keep ReceiverResultReg live. */

	/* CoInterpreter>>#ceContext:instVar:value: */
sqInt
ceContextinstVarvalue(sqInt maybeMarriedContext, sqInt slotIndex, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    sqInt top;

	if ((((longAt(maybeMarriedContext)) & (classIndexMask())) == ClassMethodContextCompactIndex)
	 && (((((longAt((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		externalInstVarofContextput(slotIndex, maybeMarriedContext, anOop);
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(maybeMarriedContext)),
		oopisGreaterThanOrEqualTo(maybeMarriedContext, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(anOop & (tagMask()))))
			 && (oopisLessThan(anOop, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(maybeMarriedContext)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(maybeMarriedContext);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(slotIndex) << (shiftForWord())))), anOop);
	}
	return maybeMarriedContext;
}

	/* CoInterpreter>>#ceInterpretMethodFromPIC:receiver: */
sqInt
ceInterpretMethodFromPICreceiver(sqInt aMethodObj, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt methodHeader;
    CogMethod *pic;
    sqInt primitiveIndex;
    sqInt top;


	/* pop off inner return and locate open or closed PIC */
	pic = ((CogMethod *) ((popStack()) - (interpretOffset())));
	assert((isCMOpenPIC(((CogBlockMethod *) pic)))
	 || (isCMClosedPIC(((CogBlockMethod *) pic))));
	if (((pic->cmType)) == CMOpenPIC) {
		assert(!(methodHasCogMethod(aMethodObj)));
		if (methodShouldBeCogged(aMethodObj)) {
			cogselector(aMethodObj, (pic->selector));
		}
	}
	if (methodHasCogMethod(aMethodObj)) {
		executeCogMethodfromUnlinkedSendWithReceiver(cogMethodOf(aMethodObj), rcvr);
	}
	GIV(messageSelector) = (pic->selector);
	GIV(newMethod) = aMethodObj;
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(aMethodObj));
	header = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	primitiveIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (aMethodObj + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = (pic->cmNumArgs);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	return interpretMethodFromMachineCode();
}

	/* CoInterpreter>>#ceMNUFromPICMNUMethod:receiver: */
sqInt
ceMNUFromPICMNUMethodreceiver(sqInt aMethodObj, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cPIC;
    sqInt firstBytecode;
    sqInt header;
    sqInt methodHeader;
    sqInt primitiveIndex;
    sqInt selector;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt tagBits2;
    sqInt top;

	assert(addressCouldBeOop(rcvr));
	assert((aMethodObj == 0)
	 || ((addressCouldBeObj(aMethodObj))
	 && (isOopCompiledMethod(aMethodObj))));
	selector = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), (((tagBits2 = rcvr & (tagMask()))) != 0
		? tagBits2
		: (longAt(rcvr)) & (classIndexMask())));
	cPIC = ((CogMethod *) ((popStack()) - (mnuOffset())));
	assert((isCMClosedPIC(((CogBlockMethod *) cPIC)))
	 || (isCMOpenPIC(((CogBlockMethod *) cPIC))));
	GIV(argumentCount) = (cPIC->cmNumArgs);
	GIV(messageSelector) = (cPIC->selector);
	if (aMethodObj != 0) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		createActualMessageTo(		/* begin fetchClassOf: */
			(((tagBits = rcvr & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
			: fetchClassOfNonImm(rcvr)));
		if (		/* begin maybeMethodHasCogMethod: */
			((!(aMethodObj & (tagMask()))))
		 && ((((((usqInt)((longAt(aMethodObj)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
		 && (isCogMethodReference(longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp;
			executeCogMethodfromUnlinkedSendWithReceiver(cogMethodOf(aMethodObj), rcvr);
			assert(0);
		}
		GIV(newMethod) = aMethodObj;
		/* begin primitiveIndexOf: */
		assert(isCompiledMethod(aMethodObj));
		header = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		methodHeader = ((((header) & 7) == 1)
			? header
			: (assert((((usqInt)header)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header))->methodHeader)));
		primitiveIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (aMethodObj + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
		return interpretMethodFromMachineCode();
	}
	handleMNUInMachineCodeToclassForMessage(SelectorDoesNotUnderstand, rcvr, 
	/* begin fetchClassOf: */
(((tagBits1 = rcvr & (tagMask()))) != 0
		? (GIV(lkupClass) = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits1) << (shiftForWord()))))))
		: (GIV(lkupClass) = fetchClassOfNonImm(rcvr))));
	assert(0);
	return 0;
}


/*	We know anObject has not a hash yet (or this trampoline would not be
	called. Sets the hash, then answers it as a smallinteger */

	/* CoInterpreter>>#ceNewHashOf: */
sqInt
ceNewHashOf(sqInt anObject)
{
	assert((isNonImmediate(anObject))
	 && ((rawHashBitsOf(anObject)) == 0));
	return (((newHashBitsOf(anObject)) << 3) | 1);
}

	/* CoInterpreter>>#ceNonLocalReturn: */
sqInt
ceNonLocalReturn(sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt callerContextOrNil1;
    sqInt callerContextOrNil2;
    char *callerFP;
    sqInt closure;
    sqInt contextToReturnTo;
    sqInt currentCtx;
    char *frameToReturnTo;
    sqInt home;
    StackPage *newPage;
    sqInt nextCntx;
    sqInt objOop;
    sqInt objOop1;
    sqInt ourContext;
    sqInt ourContext1;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp2;
    char *sp21;
    char *sp22;
    char *sp23;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *theFP;
    char *theFP1;
    char *theFP2;
    StackPage *thePage;
    StackPage *thePage1;
    StackPage *thePage2;
    StackPage *thePage3;
    sqInt top;
    sqInt unwindContextOrNilOrZero;


	/* self shortPrintFrameAndCallers: framePointer.
	   self printOop: returnValue.
	   self halt. */
	frameToReturnTo = ((char *) 0);
	assert(isMachineCodeFrame(GIV(framePointer)));
	assert(frameIsBlockActivation(GIV(framePointer)));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	closure = longAt(GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer))));
	/* avoid compiler warning */
	/* Walk the closure's lexical chain to find the context or frame to return from (home). */
	home = null;
	while (closure != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((closure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, closure, objOop);
		}
		home = objOop;
		if (!(			/* begin isContext: */
				((!(home & (tagMask()))))
			 && (((longAt(home)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
			/* error: can't find home on chain; cannot return */
			if (			/* begin frameHasContext: */
				((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
				? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(GIV(framePointer))));
				ourContext = longAt(GIV(framePointer) + FoxThisContext);
				goto l2;
			}
			ourContext = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l2:	/* end ensureFrameIsMarried:SP: */;
			/* begin externalCannotReturn:from: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), ourContext);
			GIV(stackPointer) = sp;
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), returnValue);
			GIV(stackPointer) = sp1;
			/* begin push: */
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp2;
			return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), ourContext, 1);
		}
		/* begin followObjField:ofObject: */
		objOop1 = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop1));
		if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, home, objOop1);
		}
		closure = objOop1;
	}
	unwindContextOrNilOrZero = findUnwindThroughContext(home);
	if (unwindContextOrNilOrZero == GIV(nilObj)) {
		/* error: can't find home on chain; cannot return */
		/* begin ensureFrameIsMarried:SP: */
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(GIV(framePointer))));
			ourContext = longAt(GIV(framePointer) + FoxThisContext);
			goto l4;
		}
		ourContext = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l4:	/* end ensureFrameIsMarried:SP: */;
		/* begin externalCannotReturn:from: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), ourContext);
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput((sp11 = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp11;
		/* begin push: */
		longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp21;
		return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), ourContext, 1);
	}
	if (unwindContextOrNilOrZero != 0) {
		/* begin externalAboutToReturn:through: */
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(GIV(framePointer))));
			ourContext1 = longAt(GIV(framePointer) + FoxThisContext);
			goto l5;
		}
		ourContext1 = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l5:	/* end ensureFrameIsMarried:SP: */;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), ourContext1);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp12 = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp12;
		/* begin push: */
		longAtput((sp22 = GIV(stackPointer) - BytesPerWord), unwindContextOrNilOrZero);
		GIV(stackPointer) = sp22;
		/* begin push: */
		longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp31;
		return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorAboutToReturn) << (shiftForWord()))))), ourContext1, 2);
	}
	contextToReturnTo = null;
	if (((((longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(home, GIV(framePointer)));
		/* begin frameOfMarriedContext: */
		senderOop = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - (smallIntegerTag()));
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			/* begin frameCallerContext: */
			assert(isBaseFrame(theFP));
			thePage1 = stackPageAtpages(
				(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
				GIV(pages));
			callerContextOrNil = longAt((thePage1->baseAddress));
			assert(addressCouldBeObj(callerContextOrNil));
			assert((callerContextOrNil == (nilObject()))
			 || (isContext(followMaybeForwarded(callerContextOrNil))));
			contextToReturnTo = callerContextOrNil;
		}
		else {
			frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
		}
	}
	else {
		contextToReturnTo = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		if ((		/* begin isContext: */
			((!(contextToReturnTo & (tagMask()))))
		 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))) {
			assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, GIV(framePointer)));
			/* begin frameOfMarriedContext: */
			senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop1) & 7) == 1));
			frameToReturnTo = pointerForOop(senderOop1 - (smallIntegerTag()));
			contextToReturnTo = null;
		}
	}
	if (contextToReturnTo != null) {
		frameToReturnTo = establishFrameForContextToReturnTo(contextToReturnTo);
		if (frameToReturnTo == 0) {
			/* error: home's sender is dead; cannot return */
			/* begin ensureFrameIsMarried:SP: */
			if (			/* begin frameHasContext: */
				((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
				? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(GIV(framePointer))));
				ourContext = longAt(GIV(framePointer) + FoxThisContext);
				goto l8;
			}
			ourContext = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l8:	/* end ensureFrameIsMarried:SP: */;
			/* begin externalCannotReturn:from: */
			longAtput((sp5 = GIV(stackPointer) - BytesPerWord), ourContext);
			GIV(stackPointer) = sp5;
			/* begin push: */
			longAtput((sp13 = GIV(stackPointer) - BytesPerWord), returnValue);
			GIV(stackPointer) = sp13;
			/* begin push: */
			longAtput((sp23 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp23;
			return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotReturn) << (shiftForWord()))))), ourContext, 1);
		}
	}
	assert(pageListIsWellFormed());
	/* begin stackPageFor: */
	newPage = stackPageAtpages(
		(assert((((((char *) frameToReturnTo)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) frameToReturnTo)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(frameToReturnTo, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	if (newPage != GIV(stackPage)) {
		theFP1 = (GIV(stackPage)->baseFP);
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP1));
		thePage2 = stackPageAtpages(
			(assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil1 = longAt((thePage2->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil1));
		assert((callerContextOrNil1 == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil1))));
		currentCtx = callerContextOrNil1;
		assert(isContext(currentCtx));
		freeStackPage(GIV(stackPage));
		while (1) {
			assert(isContext(currentCtx));
			if ((((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
			if (((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
				/* begin stackPageFor: */
				thePage = stackPageAtpages(
					(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				theFP2 = (thePage->baseFP);
				/* begin frameCallerContext: */
				assert(isBaseFrame(theFP2));
				thePage3 = stackPageAtpages(
					(assert((((((char *) theFP2)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP2)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(theFP2, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				callerContextOrNil2 = longAt((thePage3->baseAddress));
				assert(addressCouldBeObj(callerContextOrNil2));
				assert((callerContextOrNil2 == (nilObject()))
				 || (isContext(followMaybeForwarded(callerContextOrNil2))));
				currentCtx = callerContextOrNil2;
				freeStackPage(thePage);
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				assert(!(isOopForwarded(currentCtx)));
				longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(currentCtx)));
				longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
		/* begin setStackPageAndLimit: */
		assert(newPage);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (newPage->headSP);
		GIV(framePointer) = (newPage->headFP);
	}
	if (GIV(framePointer) == frameToReturnTo) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
	}
	else {
		do {
			callerFP = GIV(framePointer);
			GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
		} while(GIV(framePointer) != frameToReturnTo);
		GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(callerFP + FoxCallerSavedIP))));
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(callerFP)));
		GIV(stackPointer) = (callerFP + (frameStackedReceiverOffset(callerFP))) + BytesPerWord;
	}
	return returntoExecutive(returnValue, 0);
}

	/* CoInterpreter>>#ceReapAndResetErrorCodeFor: */
void
ceReapAndResetErrorCodeFor(CogMethod *cogMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(GIV(primFailCode) != 0);
	GIV(newMethod) = (cogMethod->methodObject);
	reapAndResetErrorCodeToheader(GIV(stackPointer) + BytesPerWord, (cogMethod->methodHeader));
}


/*	Entry-point for an abort send in a CogMethod (aboutToReturn:through:,
	cannotReturn: et al).
	Try and dispatch the send, but the send may turn into an MNU in which case
	defer to
	handleMNUInMachineCodeTo:... which will dispatch the MNU.
	
	Continue execution via either executeMethod or
	interpretMethodFromMachineCode: depending on whether the target method is
	cogged or not. */

	/* CoInterpreter>>#ceSendAbort:to:numArgs: */
static NoDbgRegParms sqInt
ceSendAborttonumArgs(sqInt selector, sqInt rcvr, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt classTablePage;
    sqInt classTag;
    CogMethod *cogMethod;
    sqInt errSelIdx;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt methodHeader;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt top;


	/* self printExternalHeadFrame */
	/* self printStringOf: selector */
	assertCStackWellAligned();
	assert(addressCouldBeOop(rcvr));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), (((tagBits1 = rcvr & (tagMask()))) != 0
		? tagBits1
		: (longAt(rcvr)) & (classIndexMask())));
	GIV(argumentCount) = numArgs;
	classTag = 
	/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask()));
	if (lookupInMethodCacheSelclassTag(selector, classTag)) {
		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((			/* begin literalCountOfMethodHeader: */
				assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), selector);
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		GIV(messageSelector) = selector;
		/* begin classForClassTag: */
		assert((classTag >= 0)
		 && ((classTag <= (tagMask()))
		 || ((classTag >= (arrayClassIndexPun()))
		 && (classTag <= (classIndexMask())))));
		fieldIndex = ((usqInt)(classTag)) >> (classTableMajorIndexShift());
		/* begin fetchPointer:ofObject: */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
		if (classTablePage == GIV(nilObj)) {
			classObj = null;
			goto l3;
		}
		fieldIndex1 = classTag & ((1U << (classTableMajorIndexShift())) - 1);
		classObj = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l3:	/* end classForClassTag: */;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	if (	/* begin maybeMethodHasCogMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && ((((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		executeNewMethod();
		assert(0);
	}
	return interpretMethodFromMachineCode();
}


/*	Send from an Open PIC when the first-level method lookup probe has failed,
	or to continue when PIC creation has failed (e.g. because we're out of
	code space),
	or when a send has failed due to a forwarded receiver. */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

	/* CoInterpreter>>#ceSendFromInLineCacheMiss: */
sqInt
ceSendFromInLineCacheMiss(CogMethod *cogMethodOrPIC)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt classTablePage;
    sqInt classTag;
    CogMethod *cogMethod;
    sqInt errSelIdx;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt methodHeader;
    usqInt numArgs;
    sqInt rcvr;
    sqInt selector;
    sqInt tagBits;
    sqInt top;

	numArgs = (cogMethodOrPIC->cmNumArgs);
	/* skip return pc */
	rcvr = longAt(GIV(stackPointer) + ((numArgs + 1) * BytesPerWord));
	assert(addressCouldBeOop(rcvr));
	classTag = 
	/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask()));
	GIV(argumentCount) = numArgs;
	if (lookupInMethodCacheSelclassTag((cogMethodOrPIC->selector), classTag)) {
		/* check for coggability because method is in the cache */
		selector = (cogMethodOrPIC->selector);
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, selector);
			}
		}
		else {
			if (((			/* begin literalCountOfMethodHeader: */
				assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), selector);
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		if (		/* begin isOopForwarded: */
			((!(((cogMethodOrPIC->selector)) & (tagMask()))))
		 && ((!((longAt((cogMethodOrPIC->selector))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			handleForwardedSelectorFaultFor((cogMethodOrPIC->selector));
			return ceSendFromInLineCacheMiss(cogMethodOrPIC);
		}
		if (classTag == (isForwardedObjectClassIndexPun())) {
			handleForwardedSendFaultForReceiverstackDelta(rcvr, 1);
			return ceSendFromInLineCacheMiss(cogMethodOrPIC);
		}
		GIV(messageSelector) = (cogMethodOrPIC->selector);
		/* begin classForClassTag: */
		assert((classTag >= 0)
		 && ((classTag <= (tagMask()))
		 || ((classTag >= (arrayClassIndexPun()))
		 && (classTag <= (classIndexMask())))));
		fieldIndex = ((usqInt)(classTag)) >> (classTableMajorIndexShift());
		/* begin fetchPointer:ofObject: */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
		if (classTablePage == GIV(nilObj)) {
			classObj = null;
			goto l3;
		}
		fieldIndex1 = classTag & ((1U << (classTableMajorIndexShift())) - 1);
		classObj = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l3:	/* end classForClassTag: */;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	if (	/* begin maybeMethodHasCogMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && ((((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		executeNewMethod();
		assert(0);
	}
	return interpretMethodFromMachineCode();
}


/*	For RegisterAllocatingCogit we want the pc following a conditional branch
	not to be reachable, so
	we don't have to generate code to reload registers. But notionally the pc
	following a conditional
	branch is reached when continuing from a mustBeBoolean error. Instead of
	supporting this in the
	JIT, simply convert to an interpreter frame, backup the pc to the branch,
	reenter the interpreter
	and hence retry the mustBeBoolean send therein. N.B. We could do this for
	immutability violations
	too, but immutability is used in actual applications and so should be
	performant, whereas
	mustBeBoolean errors are extremely rare and so we choose brevity over
	performance in this case. */

	/* CoInterpreter>>#ceSendMustBeBooleanTo:interpretingAtDelta: */
sqInt
ceSendMustBeBooleanTointerpretingAtDelta(sqInt aNonBooleanObject, sqInt jumpSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    sqInt top;

	assert(addressCouldBeOop(aNonBooleanObject));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	convertFrametoInterpreterFrame(GIV(framePointer), jumpSize);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), aNonBooleanObject);
	GIV(stackPointer) = sp;
	ceInvokeInterpret();
	return null;
}

	/* CoInterpreter>>#ceSendMustBeBoolean: */
sqInt
ceSendMustBeBoolean(sqInt anObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    char *sp1;
    sqInt top;


	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), anObject);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	return ceSendAborttonumArgs(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorMustBeBoolean) << (shiftForWord()))))), anObject, 0);
}


/*	Entry-point for an unlinked directed super send in a CogMethod. Smalltalk
	stack looks like
	receiver
	args
	head sp ->	sender return pc
	methodClassBinding is an association whose value is the class above which
	to start the lookup. */

	/* CoInterpreter>>#ceSend:aboveClassBinding:to:numArgs: */
void
ceSendaboveClassBindingtonumArgs(sqInt selector, sqInt methodClassBinding, sqInt rcvr, sqInt numArgs)
{
	ceSendabovetonumArgs(selector, fetchPointerofObject(ValueIndex, 
	/* begin followMaybeForwarded: */
(((!(methodClassBinding & (tagMask()))))
	 && ((!((longAt(methodClassBinding)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
		? followForwarded(methodClassBinding)
		: methodClassBinding)), rcvr, numArgs);
}


/*	Entry-point for an unlinked directed super send in a CogMethod. Smalltalk
	stack looks like
	receiver
	args
	head sp ->	sender return pc
	methodClass is the class above which to start the lookup.
	
	If an MNU then defer to handleMNUInMachineCodeTo:... which will dispatch
	the MNU and
	may choose to allocate a closed PIC with a fast MNU dispatch for this
	send. Otherwise
	attempt to link the send site as efficiently as possible. All link
	attempts may fail; e.g.
	because we're out of code memory.
	
	Continue execution via either executeMethod or
	interpretMethodFromMachineCode: depending on whether the target method is
	cogged or not. */

	/* CoInterpreter>>#ceSend:above:to:numArgs: */
sqInt
ceSendabovetonumArgs(sqInt selector, sqInt methodClass, sqInt rcvr, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt classObj1;
    sqInt classPointer;
    sqInt classTablePage;
    sqInt classTag;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt err;
    sqInt errSelIdx;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt hash;
    sqInt methodHeader;
    sqInt methodHeader1;
    CogMethod *newCogMethod;
    sqInt objOop;
    sqInt tagBits;
    sqInt top;
    sqInt top1;


	/* self printExternalHeadFrame */
	/* self printStringOf: selector */
	assertCStackWellAligned();
	assert(addressCouldBeOop(rcvr));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), (((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask())));
	classPointer = 
	/* begin followMaybeForwarded: */
(((!(methodClass & (tagMask()))))
	 && ((!((longAt(methodClass)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
		? followForwarded(methodClass)
		: methodClass);
	objOop = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
	}
	classObj1 = objOop;
	/* begin classTagForClass: */
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj1));
	flag("todo");
	if (((hash = (long32At(classObj1 + 4)) & (identityHashHalfWordMask()))) != 0) {
		classTag = hash;
	}
	else {
		if (objCouldBeClassObj(classObj1)) {
			if (((err = enterIntoClassTable(classObj1))) != 0) {
				classTag = -err;
			}
			else {
				classTag = (long32At(classObj1 + 4)) & (identityHashHalfWordMask());
			}
		}
		else {
			classTag = -PrimErrBadReceiver;
		}
	}
	GIV(argumentCount) = numArgs;
	if (lookupInMethodCacheSelclassTag(selector, classTag)) {
		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod1 = ((CogMethod *) methodHeader);
			if (((cogMethod1->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod1, selector);
			}
		}
		else {
			if (((			/* begin literalCountOfMethodHeader: */
				assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), selector);
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		assert(!((isForwardedClassTag(classTag))));
		if (		/* begin isOopForwarded: */
			((!(selector & (tagMask()))))
		 && ((!((longAt(selector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			return ceSendabovetonumArgs(handleForwardedSelectorFaultFor(selector), methodClass, rcvr, numArgs);
		}
		GIV(messageSelector) = selector;
		/* begin classForClassTag: */
		assert((classTag >= 0)
		 && ((classTag <= (tagMask()))
		 || ((classTag >= (arrayClassIndexPun()))
		 && (classTag <= (classIndexMask())))));
		fieldIndex = ((usqInt)(classTag)) >> (classTableMajorIndexShift());
		/* begin fetchPointer:ofObject: */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
		if (classTablePage == GIV(nilObj)) {
			classObj = null;
			goto l7;
		}
		fieldIndex1 = classTag & ((1U << (classTableMajorIndexShift())) - 1);
		classObj = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l7:	/* end classForClassTag: */;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			if ((errSelIdx == SelectorDoesNotUnderstand)
			 && ((((usqInt)((cogMethod = cogMNUPICSelectorreceivermethodOperandnumArgs(GIV(messageSelector), rcvr, mnuMethodOrNilFor(rcvr), GIV(argumentCount)))))) > (minCogMethodAddress()))) {
				linkSendAtintooffsetreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, noCheckEntryOffset(), rcvr);
			}
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	if (	/* begin maybeMethodHasCogMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && ((((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		if (((cogMethod->selector)) == GIV(nilObj)) {
			setSelectorOfto(cogMethod, selector);
		}
		else {
			/* Deal with anonymous accessors, e.g. in Newspeak.  The cogMethod may not have the
			   correct selector.  If not, try and compile a new method with the correct selector. */
			if (((cogMethod->selector)) != selector) {
				newCogMethod = cogselector(GIV(newMethod), selector);
				if (!(newCogMethod == null)) {
					cogMethod = newCogMethod;
				}
			}
		}
		if (((cogMethod->selector)) == selector) {
			linkSendAtintooffsetreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, noCheckEntryOffset(), rcvr);
		}
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		executeNewMethod();
		assert(0);
	}
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top1;
	return interpretMethodFromMachineCode();
}


/*	Entry-point for an unlinked send in a CogMethod. Smalltalk stack looks
	like receiver
	args
	head sp ->	sender return pc
	
	If an MNU then defer to handleMNUInMachineCodeTo:... which will dispatch
	the MNU and
	may choose to allocate a closed PIC with a fast MNU dispatch for this
	send. Otherwise
	attempt to link the send site as efficiently as possible. All link
	attempts may fail; e.g.
	because we're out of code memory.
	
	Continue execution via either executeMethod or
	interpretMethodFromMachineCode: depending on whether the target method is
	cogged or not. */

	/* CoInterpreter>>#ceSend:super:to:numArgs: */
sqInt
ceSendsupertonumArgs(sqInt selector, sqInt superNormalBar, sqInt rcvr, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt classObj1;
    sqInt classPointer;
    sqInt classTablePage;
    sqInt classTag;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt err;
    sqInt errSelIdx;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt hash;
    sqInt literal;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodPointer;
    CogMethod *newCogMethod;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt offset;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt top;
    sqInt top1;


	/* self printExternalHeadFrame */
	/* self printStringOf: selector */
	assertCStackWellAligned();
	assert(addressCouldBeOop(rcvr));
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(selector), lengthOfMaybeImmediate(selector), (((tagBits1 = rcvr & (tagMask()))) != 0
		? tagBits1
		: (longAt(rcvr)) & (classIndexMask())));
	if (superNormalBar == 0) {
		classTag = 
		/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
			? tagBits
			: (longAt(rcvr)) & (classIndexMask()));
	}
	else {
		/* begin superclassOf: */
		methodPointer = 
		/* begin frameMethodObject: */
((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? ((mframeHomeMethod(GIV(framePointer)))->methodObject)
			: longAt(GIV(framePointer) + FoxMethod));
		offset = (literalCountOf(methodPointer)) - 1;
		/* begin followField:ofObject: */
		objOop2 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop2 & (tagMask()))))
		 && ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodPointer, objOop2);
		}
		literal = objOop2;
		if ((literal != GIV(nilObj))
		 && (		/* begin isPointers: */
			((!(literal & (tagMask()))))
		 && (((((usqInt)((longAt(literal)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))) {
			/* filters out fullBlock last literal */
			assert((numSlotsOf(literal)) > ValueIndex);
			/* begin followField:ofObject: */
			objOop1 = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop1 & (tagMask()))))
			 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop1);
			}
			classPointer = objOop1;
		}
		else {
			classPointer = GIV(nilObj);
		}
		/* begin followObjField:ofObject: */
		objOop = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
		}
		classObj1 = objOop;
		/* begin classTagForClass: */
		/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(classObj1));
		flag("todo");
		if (((hash = (long32At(classObj1 + 4)) & (identityHashHalfWordMask()))) != 0) {
			classTag = hash;
		}
		else {
			if (objCouldBeClassObj(classObj1)) {
				if (((err = enterIntoClassTable(classObj1))) != 0) {
					classTag = -err;
				}
				else {
					classTag = (long32At(classObj1 + 4)) & (identityHashHalfWordMask());
				}
			}
			else {
				classTag = -PrimErrBadReceiver;
			}
		}
	}
	GIV(argumentCount) = numArgs;
	if (lookupInMethodCacheSelclassTag(selector, classTag)) {
		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod1 = ((CogMethod *) methodHeader);
			if (((cogMethod1->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod1, selector);
			}
		}
		else {
			if (((			/* begin literalCountOfMethodHeader: */
				assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), selector);
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		if (		/* begin isOopForwarded: */
			((!(selector & (tagMask()))))
		 && ((!((longAt(selector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			return ceSendsupertonumArgs(handleForwardedSelectorFaultFor(selector), superNormalBar, rcvr, numArgs);
		}
		if (classTag == (isForwardedObjectClassIndexPun())) {
			assert(superNormalBar == 0);
			return ceSendsupertonumArgs(selector, superNormalBar, handleForwardedSendFaultForReceiverstackDelta(rcvr, 1), numArgs);
		}
		GIV(messageSelector) = selector;
		/* begin classForClassTag: */
		assert((classTag >= 0)
		 && ((classTag <= (tagMask()))
		 || ((classTag >= (arrayClassIndexPun()))
		 && (classTag <= (classIndexMask())))));
		fieldIndex = ((usqInt)(classTag)) >> (classTableMajorIndexShift());
		/* begin fetchPointer:ofObject: */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
		if (classTablePage == GIV(nilObj)) {
			classObj = null;
			goto l9;
		}
		fieldIndex1 = classTag & ((1U << (classTableMajorIndexShift())) - 1);
		classObj = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l9:	/* end classForClassTag: */;
		if (((errSelIdx = lookupOrdinaryNoMNUEtcInClass(classObj))) != 0) {
			if ((errSelIdx == SelectorDoesNotUnderstand)
			 && ((((usqInt)((cogMethod = cogMNUPICSelectorreceivermethodOperandnumArgs(GIV(messageSelector), rcvr, mnuMethodOrNilFor(rcvr), GIV(argumentCount)))))) > (minCogMethodAddress()))) {
				linkSendAtintooffsetreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, (superNormalBar == 0
					? entryOffset()
					: noCheckEntryOffset()), rcvr);
			}
			handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classObj);
			assert(0);
		}
	}
	if (	/* begin maybeMethodHasCogMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && ((((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		if (((cogMethod->selector)) == GIV(nilObj)) {
			setSelectorOfto(cogMethod, selector);
		}
		else {
			/* Deal with anonymous accessors, e.g. in Newspeak.  The cogMethod may not have the
			   correct selector.  If not, try and compile a new method with the correct selector. */
			if (((cogMethod->selector)) != selector) {
				newCogMethod = cogselector(GIV(newMethod), selector);
				if (!(newCogMethod == null)) {
					cogMethod = newCogMethod;
				}
			}
		}
		if (((cogMethod->selector)) == selector) {
			linkSendAtintooffsetreceiver(longAt(GIV(stackPointer)), mframeHomeMethod(GIV(framePointer)), cogMethod, (superNormalBar == 0
				? entryOffset()
				: noCheckEntryOffset()), rcvr);
		}
		else {
			/* If patchToOpenPICFor:.. returns we're out of code memory */
			if (superNormalBar == 0) {
				/* Open PICs perform normal sends. Can't patch if this is a super send. */
				patchToOpenPICFornumArgsreceiver(selector, numArgs, rcvr);
			}
		}
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		executeNewMethod();
		assert(0);
	}
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top1;
	return interpretMethodFromMachineCode();
}


/*	If contextSwitchIfNotNil is nil we can't context switch.
	contextSwitchIfNotNil is set to nil by
	- the special primitiveClosureValueNoContextSwitch entry-point in block
	dispatch - the stack check in methods with primitive 198.
	In a normal method contextSwitchIfNotNil will be the method (see e.g.
	SimpleStackBasedCogit>>compileFrameBuild). In a block it will be the
	closure (see e.g. SimpleStackBasedCogit>>compileMethodBody). */

	/* CoInterpreter>>#ceStackOverflow: */
void
ceStackOverflow(sqInt contextSwitchIfNotNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cesoRetAddr;
    CogBlockMethod *cogMethod;
    sqInt switched;
    sqInt top;


	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	cesoRetAddr = top;
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
	assert((cesoRetAddr - (abortOffset())) == (((sqInt)(asCogHomeMethod(cogMethod)))));
	GIV(instructionPointer) = (((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	GIV(method) = (GIV(newMethod) = (GIV(messageSelector) = GIV(nilObj)));
	switched = handleStackOverflowOrEventAllowContextSwitch(contextSwitchIfNotNil != 0);
	returnToExecutivepostContextSwitch(0, switched);
	error("should not be reached");
}


/*	A primitive has succeeded and the nextProfileTick has been reached (all
	done in machine code).
	If aCogMethodOrNil is not nil then it is the cog method containing the
	primitive call.
	If aCogMethodOrNil is nil then this has been called from
	primReturnEnterCogCode and newMethod
	Now take a sample. c.f. checkProfileTick: */
/*	Slang type inferrence can't deal with self ceTakeProfileSample: nil... */

	/* CoInterpreter>>#ceTakeProfileSample: */
void
ceTakeProfileSample(CogMethod *aCogMethodOrNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;


	/* begin activeProcess */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	GIV(profileMethod) = (aCogMethodOrNil == null
		? GIV(newMethod)
		: (aCogMethodOrNil->methodObject));
	forceInterruptCheck();
	/* begin zeroNextProfileTick */
	GIV(nextProfileTick) = 0;
}

	/* CoInterpreter>>#ceTraceBlockActivation */
void
ceTraceBlockActivation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt selector;

	if (recordBlockTrace()) {
		selector = ((mframeHomeMethod(GIV(framePointer)))->methodObject);
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceBlockActivation;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = selector;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
		if (printOnTrace()) {
			printActivationNameForreceiverisBlockfirstTemporary(((mframeHomeMethod(GIV(framePointer)))->methodObject), 
			/* begin frameReceiver: */
((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
				? longAt(GIV(framePointer) + FoxMFReceiver)
				: longAt(GIV(framePointer) + FoxIFReceiver)), 1, null);
			cr();
		}
	}
}

	/* CoInterpreter>>#ceTraceLinkedSend: */
void
ceTraceLinkedSend(sqInt theReceiver)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrInteger;
    CogMethod *cogMethod;
    sqInt selector;
    sqInt selector1;
    sqInt tagBits;
    sqInt tagBits1;

	cogMethod = ((CogMethod *) ((longAt(GIV(stackPointer))) - (traceLinkedSendOffset())));
	classOrInteger = 
	/* begin fetchClassOf: */
(((tagBits = theReceiver & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
		: fetchClassOfNonImm(theReceiver));
	selector = (cogMethod->selector);
	/* begin recordTrace:thing:source: */
	GIV(traceLog)[GIV(traceLogIndex)] = classOrInteger;
	GIV(traceLog)[GIV(traceLogIndex) + 1] = selector;
	GIV(traceLog)[GIV(traceLogIndex) + 2] = TraceIsFromMachineCode;
	GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	if (printOnTrace()) {
		printActivationNameForreceiverisBlockfirstTemporary((cogMethod->methodObject), theReceiver, 0, null);
		cr();
	}
	selector1 = (cogMethod->selector);
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(selector1), lengthOfMaybeImmediate(selector1), (((tagBits1 = theReceiver & (tagMask()))) != 0
		? tagBits1
		: (longAt(theReceiver)) & (classIndexMask())));
}


/*	For assertion checking. */

	/* CoInterpreter>>#ceTraceStoreOf:into: */
void
ceTraceStoreOfinto(sqInt aValue, sqInt anObject)
{
	assert((isImmediate(aValue))
	 || (addressCouldBeObj(aValue)));
	assert(addressCouldBeObj(anObject));
}

	/* CoInterpreter>>#cFramePointerAddress */
usqInt
cFramePointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(CFramePointer))));
}

	/* CoInterpreter>>#checkAssertsEnabledInCoInterpreter */
void
checkAssertsEnabledInCoInterpreter(void)
{
    sqInt assertsAreEnabledInCoInterpreter;

	assertsAreEnabledInCoInterpreter = 0;
	assert(assertsAreEnabledInCoInterpreter);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all object references in machine
	code are valid. Answer if all checks pass. */

	/* CoInterpreter>>#checkCodeIntegrity: */
static NoDbgRegParms sqInt
checkCodeIntegrity(sqInt gcModes)
{
	return checkIntegrityOfObjectReferencesInCode(gcModes);
}


/*	In Spur a primitive may fail due to encountering a forwarder. On failure,
	check the accessorDepth for the
	primitive and if non-negative scan the args to the depth, following any
	forwarders. Answer if any are found
	so the prim can be retried. The primitive index is derived from newMethod.
	
	See
	http://www.mirandabanda.org/cogblog/2014/02/08/primitives-and-the-partial-read-barrier/
	and SpurMemoryManager's class comment. */
/*	Override to log and export to Cogit */

	/* CoInterpreter>>#checkForAndFollowForwardedPrimitiveState */
sqInt
checkForAndFollowForwardedPrimitiveState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt accessorDepth;
    sqInt aMethodSelectorOrImmediate;
    sqInt firstBytecode;
    sqInt firstBytecode1;
    sqInt flags;
    sqInt found;
    sqInt found1;
    sqInt header;
    sqInt header1;
    sqInt index;
    sqInt lit;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt oop;
    sqInt primIndex;
    sqInt primIndex1;
    sqInt referent;
    sqInt scannedStackFrame;
    sqInt tagBits;

	if ((recordPrimTrace())
	 && (!primTracePluginName)) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TracePrimitiveFailure;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
		/* begin fetchClassOf: */
		if (((tagBits = (longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord))) & (tagMask()))) != 0) {
			aMethodSelectorOrImmediate = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))));
		}
		else {
			aMethodSelectorOrImmediate = fetchClassOfNonImm(longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord)));
		}
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = aMethodSelectorOrImmediate;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	assert(failed());
	found1 = 0;
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	primIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	assert((GIV(argumentCount) == (argumentCountOf(GIV(newMethod))))
	 || (isMetaPrimitiveIndex(primIndex)));
	if (((	/* begin isCalloutPrimitiveIndex: */
		(primIndex == PrimNumberExternalCall)
	 || (primIndex == PrimNumberFFICall))
	 || (primIndex == PrimNumberDoExternalCall))
	 && (unfollowFirstLiteralOfMaybeCalloutMethodprimitiveIndex(GIV(newMethod), primIndex))) {
		found1 = 1;
	}
	if ((	/* begin isMetaPrimitiveIndex: */
		(primIndex == PrimNumberDoPrimitive)
	 || (primIndex == PrimNumberDoExternalCall))
	 && (GIV(metaAccessorDepth) > -2)) {
		accessorDepth = GIV(metaAccessorDepth);
	}
	else {
		/* begin accessorDepthForPrimitiveMethod: */
		assert(isCompiledMethod(GIV(newMethod)));
		header1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		methodHeader1 = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		primIndex1 = (((methodHeader1 & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode1 = (GIV(newMethod) + ((LiteralStart + (((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode1 + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode1 + 2))) << 8))))
			: 0);
		if ((primIndex1 == PrimNumberExternalCall)
		 && (isLinkedExternalPrimitive(GIV(newMethod)))) {
			/* begin accessorDepthForExternalPrimitiveMethod: */
			assert(isLinkedExternalPrimitive(GIV(newMethod)));
			lit = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
			flags = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))));
			accessorDepth = (((flags >> 3))) >> SpurPrimitiveAccessorDepthShift;
		}
		else {
			accessorDepth = ((sqInt)((primitiveMetadataTable[primIndex1]))) >> SpurPrimitiveAccessorDepthShift;
		}
	}
	assert(((accessorDepth >= -1) && (accessorDepth <= 5)));
	if (accessorDepth >= 0) {
		scannedStackFrame = 0;
		for (index = 0; index <= GIV(argumentCount); index += 1) {
			oop = longAt(GIV(stackPointer) + (index * BytesPerWord));
			if ((!(oop & (tagMask())))) {
				if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					assert(index < GIV(argumentCount));
					found1 = 1;
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(oop));
					referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					oop = referent;
					/* begin stackValue:put: */
					longAtput(GIV(stackPointer) + (index * BytesPerWord), oop);
					if (!scannedStackFrame) {
						scannedStackFrame = 1;
						followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord));
					}
				}
				if ((accessorDepth > 0)
				 && ((				/* begin hasPointerFields: */
					((!(oop & (tagMask()))))
				 && (hasPointerFieldsNonImm(oop)))
				 && (followForwardedObjectFieldstoDepth(oop, accessorDepth)))) {
					found1 = 1;
				}
			}
		}
	}
	found = found1;
	if (found
	 && (recordPrimTrace())) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TracePrimitiveRetry;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	return found;
}


/*	Necessary because we very much want CStackPointer and CFramePointer to be
	static/private and grouped
	with other interpreter variables which will hence be accessed via
	VarBaseReg on platforms that have one.
 */

	/* CoInterpreter>>#checkIfCFramePointerInUse */
sqInt
checkIfCFramePointerInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return isCFramePointerInUse((&GIV(CFramePointer)), (&GIV(CStackPointer)));
}

	/* CoInterpreter>>#checkingLongRunningPrimitives */
#if LRPCheck
int
checkingLongRunningPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(longRunningPrimitiveCheckSemaphore);
}
#endif /* LRPCheck */


/*	Check the log for leaks. The trace log is a circular buffer of pairs of
	entries. If there is an entry at traceLogIndex - 3 \\ TraceBufferSize it
	has entries. If
	there is something at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#checkLogIntegrity */
static sqInt
checkLogIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt ok;
    sqInt oop;
    sqInt remainder;

	limit = 
	/* begin safe:mod: */
(((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return 1;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	ok = 1;
	for (i = 0; i <= limit; i += 3) {
		oop = GIV(traceLog)[i];
		if (!(((oop & (tagMask())) != 0))) {
			if (!(checkOopIntegritynamedindex(oop, "traceLog", i))) {
				ok = 0;
			}
		}
		oop = GIV(traceLog)[i + 1];
		if (!(((oop & (tagMask())) != 0))) {
			if (!(checkOopIntegritynamedindex(oop, "traceLog", i + 1))) {
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

	/* CoInterpreter>>#checkOkayFields: */
static NoDbgRegParms sqInt
checkOkayFields(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;
    sqInt i1;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((((oop) & 7) == 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
		 || (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return 1;
	}
	hasYoung = 0;
	if (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		i = ((literalCountOf(oop)) + LiteralStart) - 1;
	}
	else {
		if (		/* begin isContext: */
			((!(oop & (tagMask()))))
		 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOf(oop)) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((!(fieldOop & (smallIntegerTag())))) {
			if ((i == 0)
			 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
				if (!(methodFor(pointerForOop(fieldOop)))) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"method ");
					printHex(oop);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" has an invalid cog method reference");
					return 0;
				}
			}
			else {
				hasYoung = hasYoung
				 || (				/* begin isYoung: */
					((!(fieldOop & (tagMask()))))
				 && (oopisLessThan(fieldOop, GIV(oldSpaceStart))));
				if (!(checkOkayOop(fieldOop))) {
					return 0;
				}
				if (!(checkOopHasOkayClass(fieldOop))) {
					return 0;
				}
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if (oopisLessThan(oop, GIV(oldSpaceStart))) {
			return 1;
		}
		if (!(((((usqInt)((longAt(oop)))) >> (rememberedBitShift())) & 1) != 0)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"remembered bit is not set in ");
			printHex(oop);
			cr();
			return 0;
		}
		/* begin isInRememberedSet: */
		for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
			if ((GIV(rememberedSet)[i1]) == oop) {
				return 1;
			}
		}
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has remembered bit set but is not in remembered set");
		cr();
		return 0;
	}
	return 1;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

	/* CoInterpreter>>#checkStackIntegrity */
static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    CogMethod *cogMethod;
    char *frameRcvrOffset;
    sqInt i;
    sqInt methodField;
    sqInt ok;
    usqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				frameRcvrOffset = 
				/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (((!(oop & (tagMask()))))
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					oop = longAt(theFP + FoxThisContext);
					if ((((oop & (tagMask())) != 0))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!(						/* begin isContext: */
							((!(oop & (tagMask()))))
						 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((						/* begin isContext: */
							((!(oop & (tagMask()))))
						 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))
						 && (((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((						/* begin isContext: */
							((!(oop & (tagMask()))))
						 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))
						 && ((frameOfMarriedContext(oop)) == theFP))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext);
						ok = 0;
					}
				}
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
					/* begin mframeHomeMethod: */
					methodField = longAt(theFP + FoxMethod);
					if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
						cogMethod = 
						/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
							? ((CogMethod *) (((CogBlockMethod *) (methodField & MFMethodMask))))
							: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset)))));
						goto l2;
					}
					cogMethod = ((CogMethod *) (methodField & MFMethodMask));
	l2:	/* end mframeHomeMethod: */;
					if ((heapMapAtWord(pointerForOop(cogMethod))) == 0) {
						printFrameThingandFrameat("object leak in mframe mthd", theFP, theFP + FoxMethod);
						ok = 0;
					}
				}
				else {
					oop = longAt(theFP + FoxMethod);
					if ((((oop & (tagMask())) != 0))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in iframe mthd", theFP, theFP + FoxMethod);
						ok = 0;
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((!(oop & (tagMask()))))
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}

	/* CoInterpreter>>#clearTraceLog */
void
clearTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	GIV(traceLogIndex) = 0;
	for (i = 0; i < TraceBufferSize; i += 1) {
		GIV(traceLog)[i] = 0;
	}
}

	/* CoInterpreter>>#cogMethodHasTooManyLiterals: */
int
cogMethodHasTooManyLiterals(CogMethod *aCogMethod)
{
	return !(((	/* begin literalCountOfMethodHeader: */
		assert((((((aCogMethod->methodHeader))) & 7) == 1)),
	((((aCogMethod->methodHeader)) >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile);
}

	/* CoInterpreter>>#cogMethodOf: */
CogMethod *
cogMethodOf(sqInt aMethodOop)
{
    sqInt methodHeader;

	methodHeader = longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	assert((isNonImmediate(methodHeader))
	 && ((((usqInt)methodHeader)) < (startOfMemory())));
	return ((CogMethod *) methodHeader);
}

	/* CoInterpreter>>#commenceCogCompiledCodeCompaction */
static void
commenceCogCompiledCodeCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    usqLong startTime;
    sqInt top;

	GIV(cogCompiledCodeCompactionCalledFor) = 0;
	if (recordEventTrace()) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceCodeCompaction;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = TraceCodeCompaction;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = 0;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if (recordPrimTrace()) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TraceCodeCompaction;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	/* This can be called in a number of circumstances.  The instructionPointer
	   may contain a native pc that must be relocated.  There may already be a
	   pushed instructionPointer on stack.  Clients ensure that instructionPointer
	   is 0 if it should not be pushed and/or relocated.  Pushing twice is a mistake
	   because only the top one will be relocated. */
	startTime = ioUTCMicrosecondsNow();
	if (GIV(instructionPointer) != 0) {
		/* better not have already been pushed */
		assert((((usqInt)(stackTop()))) != GIV(instructionPointer));
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin externalWriteBackHeadStackPointer */
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		(GIV(stackPage)->headSP = GIV(stackPointer));
	}
	assertValidStackedInstructionPointers(__LINE__);
	compactCogCompiledCode();
	/* begin nilUncoggableMethods */
	GIV(lastCoggableInterpretedBlockMethod) = (GIV(lastUncoggableInterpretedBlockMethod) = null);
	if (GIV(instructionPointer) != 0) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(instructionPointer) = top;
		/* begin externalWriteBackHeadStackPointer */
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		(GIV(stackPage)->headSP = GIV(stackPointer));
	}
	assertValidStackedInstructionPointers(__LINE__);
	GIV(statCodeCompactionCount) += 1;
	GIV(statCodeCompactionUsecs) += (ioUTCMicrosecondsNow()) - startTime;
	if (checkForLeaks != 0) {
		clearLeakMapAndMapAccessibleObjects();
		asserta(checkCodeIntegrity(0));
	}
}

	/* CoInterpreter>>#compilationBreakpointFor: */
void
compilationBreakpointFor(sqInt selectorOop)
{
	suppressHeartbeatFlag = 1;
	warning("compilation send break (heartbeat suppressed)");
}


/*	Answer a value to store in the InstructionPointer index of a context
	object for theIP and theFP.
	Mapping native pcs to bytecode pcs is quite expensive, requiring a search
	through the method
	map. We mitigate this cost by deferring mapping until we really have to,
	which is when a context's
	instruction pointer is accessed by Smalltalk code (either direct inst var
	access or through the
	instVarAt: primitive). But to defer mapping we have to be able to
	distinguish machine code from
	bytecode pcs, which we do by using negative values for machine code pcs.
	So if the frame is a
	machine code one answer the negation of the offset in the cog method.
	
	As a whorish performance hack we also include the block method offset in
	the pc of a block.
	The least significant 16 bits are the native pc and the most significant
	14 bits are the block
	start, in block alignment units. So when mapping back we can find the
	start of the block.
	
	See mustMapMachineCodePC:context: for the code that does the actual
	mapping.  */

	/* CoInterpreter>>#contextInstructionPointer:frame: */
static NoDbgRegParms sqInt
contextInstructionPointerframe(sqInt theIP, char *theFP)
{
    sqInt blockOffset;
    CogBlockMethod *cogMethod;
    CogMethod *homeMethod;

	assert(validInstructionPointerinFrame(theIP, theFP));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		/* begin mframeCogMethod: */
		cogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
		if (theIP == (ceCannotResumePC())) {
			return HasBeenReturnedFromMCPCOop;
		}
		if (((cogMethod->cmType)) >= CMMethod) {
			return (((usqInt)((((sqInt)cogMethod)) - theIP) << 3) | 1);
		}
		homeMethod = 
		/* begin cmHomeMethod */
((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)
			? ((CogMethod *) cogMethod)
			: ((CogMethod *) ((((usqInt)cogMethod)) - ((cogMethod->homeOffset)))));
		blockOffset = ((((sqInt)homeMethod)) - (((sqInt)cogMethod))) / (blockAlignment());
		return (((usqInt)(((((sqInt)((usqInt)(blockOffset) << 16)))) | (((((sqInt)cogMethod)) - theIP) & 0xFFFF)) << 3) | 1);
	}
	return (((usqInt)(((((theIP == (ceReturnToInterpreterPC())
	? ((usqInt)(longAt(theFP + FoxIFSavedIP)))
	: theIP)) - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 3) | 1);
}


/*	Convert the given machine code frame to an interpreter frame. Back up the
	pc by
	pcDelta. Support for backing up the pc in primitiveSuspend for processes
	waiting on condition variables. Support for mustBeBoolean in the
	RegisterAllocatingCogit and
	for cloneContext: in shallowCopy when a code compaction is caused by
	machine code
	to bytecode pc mapping. */

	/* CoInterpreter>>#convertFrame:toInterpreterFrame: */
static NoDbgRegParms void
convertFrametoInterpreterFrame(char *theFP, sqInt pcDelta)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *cogMethod;
    CogMethod *homeMethod;
    sqInt methodHeader;
    sqInt methodObj;
    sqInt oop;
    char *p;
    sqInt startBcpc;
    usqInt theIP;
    char *theNewSP;
    StackPage *thePage;
    char *theSP;

	thePage = ((StackPage *) 0);
	assert(isMachineCodeFrame(theFP));
	if (theFP == GIV(framePointer)) {
		theIP = GIV(instructionPointer);
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		assert(theFP == ((thePage->headFP)));
		theSP = (thePage->headSP);
		theIP = longAt(theSP);
	}
	/* begin mframeCogMethod: */
	cogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
	if ((((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0)
	 && (!((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)))) {
		homeMethod = 
		/* begin cmHomeMethod */
((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)
			? ((CogMethod *) cogMethod)
			: ((CogMethod *) ((((usqInt)cogMethod)) - ((cogMethod->homeOffset)))));
		methodHeader = (homeMethod->methodHeader);
		methodObj = (homeMethod->methodObject);
		startBcpc = (cogMethod->startpc);
	}
	else {
		methodHeader = ((((CogMethod *) cogMethod))->methodHeader);
		methodObj = ((((CogMethod *) cogMethod))->methodObject);
		startBcpc = (((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
	}
	theIP = bytecodePCForstartBcpcin(theIP, startBcpc, cogMethod);
	/* fetchByte uses pre-increment, so pre decrement */
	theIP = (((methodObj + BaseHeaderSize) + theIP) - pcDelta) - 1;
	assert(validInstructionPointerinMethodframePointer(theIP, methodObj, theFP));
	for (p = theSP; p <= (theFP + FoxMFReceiver); p += BytesPerWord) {
		oop = longAt(p);
		longAtput((p - BytesPerWord) - BytesPerWord, longAt(p));
	}
	longAtput(theFP + FoxIFrameFlags, 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((cogMethod->cmNumArgs)) << ((BytesPerWord * 8) - 8))) + ((((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
	? 1ULL << ((BytesPerWord * 8) - 16)
	: 0))) + ((((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
	? 1ULL << ((BytesPerWord * 8) - 24)
	: 0))
		: ((1 + (((cogMethod->cmNumArgs)) << 8)) + ((((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
	? 0x10000
	: 0))) + ((((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
	? 0x1000000
	: 0))));
	longAtput(theFP + FoxIFSavedIP, theIP);
	longAtput(theFP + FoxMethod, methodObj);
	if (theFP == GIV(framePointer)) {
		/* If the frame is the top frame, update the top frame... */
		GIV(stackPointer) = (GIV(stackPointer) - BytesPerWord) - BytesPerWord;
		GIV(instructionPointer) = theIP;
		/* begin setMethod:methodHeader: */
		GIV(method) = methodObj;
		assert(isOopCompiledMethod(GIV(method)));
		assert((methodHeaderOf(GIV(method))) == methodHeader);
		GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
			? 0x100
			: 0);
	}
	else {
		/* otherwise update the stack pointer and instruction pointer of the top frame... */
		theNewSP = (theSP - BytesPerWord) - BytesPerWord;
		(thePage->headSP = theNewSP);
		longAtput(theNewSP, ceReturnToInterpreterPC());
	}
}

	/* CoInterpreter>>#cReturnAddressAddress */
usqInt
cReturnAddressAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(CReturnAddress))));
}

	/* CoInterpreter>>#cStackPointerAddress */
usqInt
cStackPointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(CStackPointer))));
}


/*	default native stack frame size */

	/* CoInterpreter>>#defaultNativeStackFrameSize */
sqInt
defaultNativeStackFrameSize(void)
{
	return 0x100;
}


/*	Defer smashes of the stackLimit around the call of functionSymbol (for
	assert checks)
 */

	/* CoInterpreter>>#deferStackLimitSmashAround:with: */
static NoDbgRegParms sqInt
deferStackLimitSmashAroundwith(void (*functionSymbol)(sqInt), sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(deferSmash) = 1;
	sqLowLevelMFence();
	functionSymbol(arg);
	GIV(deferSmash) = 0;
	sqLowLevelMFence();
	if (GIV(deferredSmash)) {
		GIV(deferredSmash) = 0;
		sqLowLevelMFence();
		forceInterruptCheck();
	}
	return 1;
}


/*	Divorce at most one frame in the current page (since the divorce may cause
	the page to be split)
	and answer whether a frame was divorced. */

	/* CoInterpreter>>#divorceAFrameIf:in: */
static NoDbgRegParms sqInt
divorceAFrameIfin(sqInt (*criterion)(char *fp), StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    char *theSP;

	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	while (1) {
		if (criterion(theFP)) {
			/* begin ensureFrameIsMarried:SP: */
			if (			/* begin frameHasContext: */
				((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(theFP)));
				theContext = longAt(theFP + FoxThisContext);
				goto l1;
			}
			theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
			externalDivorceFrameandContext(theFP, theContext);
			if (theFP == GIV(framePointer)) {
				GIV(framePointer) = 0;
			}
			return 1;
		}
		calleeFP = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;
		/* theSP points at stacked hottest item on frame's stack */
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + (frameStackedReceiverOffset(calleeFP))) + BytesPerWord;
	}
	return 0;
}


/*	Divorce all frames that satisfy criterion and answer the current
	activeContext. 
 */

	/* CoInterpreter>>#divorceAllFramesSuchThat: */
static NoDbgRegParms sqInt
divorceAllFramesSuchThat(sqInt (*criterion)(char *fp))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt divorcedSome;
    sqInt divorcedSome1;
    sqInt i;
    sqInt object;
    char *sp;
    char *sp1;


	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin ensurePushedInstructionPointer */
	if (GIV(instructionPointer) >= (startOfMemory())) {
		/* invoked directly from the interpreter */
		/* begin iframeSavedIP:put: */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
		object = ceReturnToInterpreterPC();
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* instructionPointer == cogit ceReturnToInterpreterPC
		   ifTrue: [invoked from the interpreter via a machine code primitive]
		   ifFalse: [invoked from machine code].
		   If in the first case the bytecode instructionPointer has already been
		   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp1;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	do {
		if (!(GIV(stackPage) == null)) {
			/* This is needed for the assert in externalDivorceFrame:andContext: */
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
		/* begin divorceSomeFramesIf: */
		divorcedSome1 = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			aPage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(aPage))) {
				/* this to avoid assert in externalDivorceFrame:andContext: */
				markStackPageMostRecentlyUsed(GIV(stackPage));
				if (divorceAFrameIfin(criterion, aPage)) {
					divorcedSome1 = 1;
				}
			}
		}
		divorcedSome = divorcedSome1;
	} while(divorcedSome);
	return activeContext;
}


/*	Divorce at most one frame in the current page (since the divorce may cause
	the page to be split)
	and answer whether a frame was divorced. */

	/* CoInterpreter>>#divorceAMachineCodeFrameWithCogMethod:in: */
static NoDbgRegParms sqInt
divorceAMachineCodeFrameWithCogMethodin(CogMethod *cogMethod, StackPage *aStackPage)
{
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    char *theSP;

	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	while (1) {
		if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
		 && (cogMethod == (mframeHomeMethod(theFP)))) {
			/* begin ensureFrameIsMarried:SP: */
			if (			/* begin frameHasContext: */
				((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(theFP)));
				theContext = longAt(theFP + FoxThisContext);
				goto l1;
			}
			theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
			externalDivorceFrameandContext(theFP, theContext);
			return 1;
		}
		calleeFP = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;
		/* theSP points at stacked hottest item on frame's stack */
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + (frameStackedReceiverOffset(calleeFP))) + BytesPerWord;
	}
	return 0;
}


/*	Map all native pcs to bytecoded pcs in all contexts whose method matches
	criterion. 
 */

	/* CoInterpreter>>#ensureAllContextsHaveBytecodePCsIf: */
static NoDbgRegParms void
ensureAllContextsHaveBytecodePCsIf(sqInt (*criterion)(sqInt methodOop))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt oop;
    sqInt pc;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	oop = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if ((((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)
			 && (((((((pc = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))))) & 7) == 1))
			 && ((pc < 0)
			 && (criterion((followObjFieldofObject(MethodIndex, obj))))))) {
				widowOrForceToBytecodePC(obj);
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
}


/*	Make sure the context has a byetcode pc. Can only be used on single
	contexts. 
 */

	/* CoInterpreter>>#ensureContextHasBytecodePC: */
static NoDbgRegParms void
ensureContextHasBytecodePC(sqInt aContext)
{
    sqInt pc;

	assert(!(isMarriedOrWidowedContext(aContext)));
	pc = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	if (((((pc) & 7) == 1))
	 && (((pc = (pc >> 3))) < 0)) {
		pc = mustMapMachineCodePCcontext(pc, aContext);
		assert(validBCPCinMethod((pc >> 3), fetchPointerofObject(MethodIndex, aContext)));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(aContext)));
		longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), pc);
	}
}


/*	Safety to give the JIT lattitude in calling convention. Conceptually,
	returning a value to a context involves pushing that value onto the stack.
	This is used
	in Squeak methods such as ContextPart>>jump
	jump
	| top |
	thisContext sender push: nil.
	stackp = 0 ifTrue: [self stepToSendOrReturn].
	stackp = 0 ifTrue: [self push: nil].
	top := self pop.
	thisContext privSender: self.
	^top
	Here jump may pop the value of a temporary variable off the stack which
	will, conceptually and, in the interpreter, actually, get pushed back on
	return. But
	if the JIT is mapping the stack to registers disaster may ensue since the
	value may not get pushed to the stack and code may access an invalid value
	(e.g. a pc).
	
	The solution is to fall back on the interpreter. If the stack pointer is
	changed we
	also ensure the pc is a bytecode pc (+ive) which will cause
	makeBaseFrameFor: to create an interpreter frame if the context is
	executed again. */

	/* CoInterpreter>>#ensureContextIsExecutionSafeAfterAssignToStackPointer: */
static NoDbgRegParms void
ensureContextIsExecutionSafeAfterAssignToStackPointer(sqInt aContext)
{
	ensureContextHasBytecodePC(aContext);
}


/*	Main entry-point into the interpreter at each execution level, where an
	execution level is either the start of execution or reentry for a
	callback. Capture the C stack
	pointers so that calls from machine-code into the C run-time occur at this
	level. This is the actual implementation, separated from
	enterSmalltalkExecutive so the
	simulator can wrap it in an exception handler and hence simulate the
	Cogit's jump
	back into C code on interpreting; see ceInvokeInterpret.
	
	Conceptually, an invocation of interpret exists at each level of execution
	from the
	initial invocation through each callback. Entry to each execution level is
	through this function. It captures the C stack & frame pointers for this
	level of execution
	and then either invokes machine code or interpret, depending on whether
	the current frame (the effective entry-point into Smalltalk execution) is
	a machine code
	or interpreted frame. In addition, interpret captures the return address
	of its caller
	(this function). The Cogit then uses the captured C stack pointers and
	return address to invoke interpret as if it had been called from this
	function.  */

	/* CoInterpreter>>#enterSmalltalkExecutiveImplementation */
static sqInt
enterSmalltalkExecutiveImplementation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertCStackWellAligned();
	ceCaptureCStackPointers();
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		returnToExecutivepostContextSwitch(0, 1);
	}
	interpret();
	return 0;
}


/*	Execute a CogMethod from a linked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

	/* CoInterpreter>>#executeCogMethod:fromLinkedSendWithReceiver: */
void
executeCogMethodfromLinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbarline(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		callRegisterArgCogMethodatreceiver(cogMethod, entryOffset(), rcvr);
	};
	object = (((sqInt)cogMethod)) + (entryOffset());
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp1;
	ceCallCogCodePopReceiverReg();
}


/*	Execute a CogMethod from an unlinked send. The receiver,
	arguments and return address are on the Smalltalk stack. First
	push the entry-point and finally the register argument(s). Then write
	back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

	/* CoInterpreter>>#executeCogMethod:fromUnlinkedSendWithReceiver: */
static NoDbgRegParms void
executeCogMethodfromUnlinkedSendWithReceiver(CogMethod *cogMethod, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbarline(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	if (((cogMethod->cmNumArgs)) <= (numRegArgs())) {
		callRegisterArgCogMethodatreceiver(cogMethod, noCheckEntryOffset(), rcvr);
	};
	object = (((sqInt)cogMethod)) + (noCheckEntryOffset());
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp1;
	ceCallCogCodePopReceiverReg();
}


/*	Execute a closed PIC from a linked send, to redispatch based on the rcvr.
	The receiver, arguments and return address are on the Smalltalk stack.
	First push the entry-point and finally the register argument(s). Then
	write back the frame pointers and call the routine that will pop off the
	register argument(s) and jump to the entry by executing a return
	instruction. 
	In the simple jit only the receiver gets passed in registers, so only the
	receiver gets pushed. */

	/* CoInterpreter>>#executeCogPIC:fromLinkedSendWithReceiver:andCacheTag: */
void
executeCogPICfromLinkedSendWithReceiverandCacheTag(CogMethod *cogPIC, sqInt rcvr, sqInt cacheTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	assertCStackWellAligned();
	assert(isMachineCodeFrame(GIV(framePointer)));
	assertValidExecutionPointersimbarline(longAt(GIV(stackPointer)), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
	object = (((sqInt)cogPIC)) + (entryOffset());
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	if (((cogPIC->cmNumArgs)) <= (numRegArgs())) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), cacheTag);
		GIV(stackPointer) = sp1;
		switch ((cogPIC->cmNumArgs)) {
		case 0:
			ceCall0ArgsPIC();
			break;
		case 1:
			ceCall1ArgsPIC();
			break;
		case 2:
			ceCall2ArgsPIC();
			break;
		default:
;
		}
		error("not reached");
	};
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), cacheTag);
	GIV(stackPointer) = sp3;
	ceCallCogCodePopReceiverAndClassRegs();
}


/*	Execute newMethod - either primitiveFunctionPointer must be set directly
	(i.e. from primitiveExecuteMethod et al), or it would have been set
	probing the method cache (i.e. primitivePerform et al). */

	/* CoInterpreter>>#executeNewMethod */
static sqInt
executeNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;
    sqInt methodHeader;

	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			returntoExecutive(popStack(), inInterpreter);
			return null;
		}
		if (slowPrimitiveResponse()) {
			returntoExecutive(popStack(), inInterpreter);
			return null;
		}
	}
	/* if not primitive, or primitive failed, activate the method */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, ((sqInt)GIV(instructionPointer)));
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
		activateNewCogMethodinInterpreter(((CogMethod *) methodHeader), inInterpreter);
	}
	else {
		activateNewMethod();
	}
	return 0;
}


/*	Execute newMethod - either primitiveFunctionPointer must be set directly
	(i.e. from primitiveExecuteMethod et al), or it would have been set
	probing the method cache (i.e. primitivePerform et al).
	Eagerly compile it if appropriate so that doits are fast. */

	/* CoInterpreter>>#executeNewMethodJitting */
static sqInt
executeNewMethodJitting(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;
    sqInt methodHeader;

	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	if (primitiveFunctionPointer != 0) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			returntoExecutive(popStack(), inInterpreter);
			return null;
		}
		if (slowPrimitiveResponse()) {
			returntoExecutive(popStack(), inInterpreter);
			return null;
		}
	}
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if (!((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag())))))) {
		if (((		/* begin literalCountOfMethodHeader: */
			assert((((methodHeader) & 7) == 1)),
		((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
			cogselector(GIV(newMethod), GIV(nilObj));
			methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		}
		else {
			maybeFlagMethodAsInterpreted(GIV(newMethod));
		}
	}
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, ((sqInt)GIV(instructionPointer)));
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
		activateNewCogMethodinInterpreter(((CogMethod *) methodHeader), inInterpreter);
	}
	else {
		activateNewMethod();
	}
	return 0;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state.
	
	If the context is single but has a negative instruction pointer
	recognise that the instruction pointer is actually into machine
	code and convert it to the corresponding bytecode pc. */

	/* CoInterpreter>>#externalInstVar:ofContext: */
static NoDbgRegParms sqInt
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt value;

	assert(isContext(aContext));
	assert(offset <= (ReceiverIndex + (checkStackPointerForMaybeMarriedContext(aContext))));
	if (!(offset <= StackPointerIndex)) {
		return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (	/* begin isStillMarriedContext: */
		(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(aContext)))) {
		return fetchPointerofMarriedContext(offset, aContext);
	}
	/* Why not update the slot to refer to the mapped pc?  We're damned if we do, and damned if
	   we don't.  If it is and the context is live and is returned to, then the pc will be mapped back
	   to machine code.  If we don't then the mapping will be repeated on every access.  What we
	   need are stats that show whether or not a read here predicts one or other outcome with any
	   certainty.  For now, we keep it as it has been for a long time and do not update the slot. */
	value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
	if ((offset == InstructionPointerIndex)
	 && (((((value) & 7) == 1))
	 && ((((int) value)) < 0))) {
		return mustMapMachineCodePCcontext((value >> 3), aContext);
	}
	return value;
}


/*	Find the compiled method to be run when the current messageSelector is
	sent to the given classTag, setting the values of newMethod and
	primitiveIndex. 
 */

	/* CoInterpreter>>#findNewMethodInClassTag: */
static NoDbgRegParms void
findNewMethodInClassTag(sqInt classTagArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt classTag;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt ok;

	ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTagArg);
	if (ok) {
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, GIV(messageSelector));
			}
		}
		else {
			if (((			/* begin literalCountOfMethodHeader: */
				assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), GIV(messageSelector));
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		/* entry was not found in the cache; perhaps soemthing was forwarded. */
		classTag = classTagArg;
		if ((		/* begin isOopForwarded: */
			((!(GIV(messageSelector) & (tagMask()))))
		 && ((!((longAt(GIV(messageSelector))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))
		 || (classTag == (isForwardedObjectClassIndexPun()))) {
			if (			/* begin isOopForwarded: */
				((!(GIV(messageSelector) & (tagMask()))))
			 && ((!((longAt(GIV(messageSelector))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
			}
			if (classTag == (isForwardedObjectClassIndexPun())) {
				classTag = handleForwardedSendFaultForTag(classTag);
			}
			ok = lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag);
			if (ok) {
				/* begin ifAppropriateCompileToNativeCode:selector: */
				methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
				if ((				/* begin isCogMethodReference: */
					assert(((((methodHeader1) & 7) == 1))
					 || (((((usqInt)methodHeader1)) < (startOfMemory()))
					 && ((((usqInt)methodHeader1)) >= (minCogMethodAddress())))),
				/* begin isNonIntegerObject: */
(!(methodHeader1 & (smallIntegerTag()))))) {
					/* makeBaseFrame: can create cog methods with nil selectors. */
					cogMethod1 = ((CogMethod *) methodHeader1);
					if (((cogMethod1->selector)) == GIV(nilObj)) {
						setSelectorOfto(cogMethod1, GIV(messageSelector));
					}
				}
				else {
					if (((					/* begin literalCountOfMethodHeader: */
						assert((((methodHeader1) & 7) == 1)),
					((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
						cogselector(GIV(newMethod), GIV(messageSelector));
					}
					else {
						maybeFlagMethodAsInterpreted(GIV(newMethod));
					}
				}
				return;
			}
		}
		/* begin classForClassTag: */
		assert((classTag >= 0)
		 && ((classTag <= (tagMask()))
		 || ((classTag >= (arrayClassIndexPun()))
		 && (classTag <= (classIndexMask())))));
		fieldIndex = ((usqInt)(classTag)) >> (classTableMajorIndexShift());
		/* begin fetchPointer:ofObject: */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
		if (classTablePage == GIV(nilObj)) {
			GIV(lkupClass) = null;
			goto l2;
		}
		fieldIndex1 = classTag & ((1U << (classTableMajorIndexShift())) - 1);
		GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l2:	/* end classForClassTag: */;
		lookupMethodInClass(GIV(lkupClass));
		addNewMethodToCache(GIV(lkupClass));
	}
}


/*	Flush the references to external functions from plugin primitives.
	Then continue execution answering self.
	This will force a reload of those primitives when accessed next. 
	Note: We must flush the method cache here also, so that any failed
	primitives are looked up again.
	Override to ensure that any and all activations of an external method
	have a bytecode pc so that if code generation changes (e.g. a primitive
	method is used, unloaded, and the reloaded primitive is marked with
	the FastCPrimitiveFlag) stale machine code pcs have been eliminated.
	THIS MUST BE INVOKED IN THE CONTEXT OF A PRIMITIVE. */

	/* CoInterpreter>>#flushExternalPrimitives */
static void
flushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt i1;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt oop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt senderOop;
    sqInt senderOop1;
    sqInt startObject;
    char *theFP;
    char *theFrame;
    StackPage *thePage;
    sqInt top;
    sqInt top1;

	oop = 0;
	activeContext = divorceAllFramesSuchThat(isMachineCodeFrameForExternalPrimitiveMethod);
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (((((usqInt)((longAt(obj)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
				flushExternalPrimitiveOf(obj);
			}
			else {
				if (				/* begin isContext: */
					((!(obj & (tagMask()))))
				 && (((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* begin mapToBytecodePCIfActivationOfExternalMethod: */
					if (isExternalMethodInPlugin(longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord()))))))) {
						if (((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
							if (isWidowedContext(obj)) {
								goto l8;
							}
							/* begin frameOfMarriedContext: */
							senderOop1 = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
							/* begin withoutSmallIntegerTags: */
							assert((((senderOop1) & 7) == 1));
							theFP = pointerForOop(senderOop1 - (smallIntegerTag()));
							if (!((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))) {
								goto l8;
							}
						}
						ensureContextHasBytecodePC(obj);
					}
	l8:	/* end mapToBytecodePCIfActivationOfExternalMethod: */;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l10;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l10:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	unlinkSendsToMethodsSuchThatAndFreeIf(cogMethodHasExternalPrim, 1);
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
	/* begin flushExternalPrimitiveTable */
	for (i1 = 0; i1 < MaxExternalPrimitiveTableSize; i1 += 1) {
		externalPrimitiveTable[i1] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(activeContext))))) {
		/* begin nilStackPage */
		assert((!GIV(stackPage))
		 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
		 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
		GIV(stackPage) = null;
		marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		ceInvokeInterpret();
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	assert(((thePage->headFP)) == theFrame);
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top1;
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Arrange that any and all cog methods with machine code primitives can be
	and are discarded.
	Hence scan contexts and map their PCs to bytecode PCs if required, and
	scan frames, divorcing
	the frames of activations if required. Then continue execution answering
	result. THIS MUST BE
	INVOKED IN THE CONTEXT OF A PRIMITIVE. It exists to support
	vmParameterAt:put:.  */

	/* CoInterpreter>>#flushMethodsWithMachineCodePrimitivesAndContinueAnswering: */
static NoDbgRegParms void
flushMethodsWithMachineCodePrimitivesAndContinueAnswering(sqInt result)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt senderOop;
    char *sp;
    char *sp1;
    char *theFrame;
    StackPage *thePage;
    sqInt top;

	activeContext = divorceAllFramesSuchThat(isMachineCodeFrameForCogMethodWithMachineCodePrim);
	ensureAllContextsHaveBytecodePCsIf(methodHasMachineCodePrimitiveMethod);
	unlinkSendsToMethodsSuchThatAndFreeIf(cogMethodHasMachineCodePrim, 1);
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(activeContext))))) {
		/* begin nilStackPage */
		assert((!GIV(stackPage))
		 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
		 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
		GIV(stackPage) = null;
		marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 2) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		ceInvokeInterpret();
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	assert(((thePage->headFP)) == theFrame);
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
	}
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp1;
}

	/* CoInterpreter>>#followForwardedFieldsInCurrentMethod */
static void
followForwardedFieldsInCurrentMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt methodField;

	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		/* begin mframeHomeMethod: */
		methodField = longAt(GIV(framePointer) + FoxMethod);
		if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
			cogMethod = 
			/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
				? ((CogMethod *) (((CogBlockMethod *) (methodField & MFMethodMask))))
				: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset)))));
			goto l1;
		}
		cogMethod = ((CogMethod *) (methodField & MFMethodMask));
	l1:	/* end mframeHomeMethod: */;
		followForwardedObjectFieldstoDepth((cogMethod->methodObject), 0);
		followForwardedLiteralsIn(cogMethod);
	}
	else {
		followForwardedObjectFieldstoDepth(GIV(method), 0);
	}
}


/*	A more thorough version of followForwardingPointersInStackZone that also
	follows all temporaries (but not stack contents after the temps).
	This allows removal of the TempVectReadBarrier in the IGC */

	/* CoInterpreter>>#followForwardingPointersOfReceiverAndTemporariesInStackZone */
static void
followForwardingPointersOfReceiverAndTemporariesInStackZone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt header;
    sqInt i;
    sqInt methodHeader;
    sqInt newOop;
    sqInt numArgs;
    sqInt offset;
    usqInt oop;
    sqInt referent;
    sqInt referent1;
    char *theFP;
    usqInt theIPPtr;
    StackPage *thePage;
    char *theSP;

	if (!GIV(stackPage)) {
		/* the system must be snapshotting; nothing to do... */
		assert((!(mostRecentlyUsedPage()))
		 || (isFree(mostRecentlyUsedPage())));
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			theIPPtr = (!(thePage == GIV(stackPage))
				? ((usqInt)((thePage->headSP)))
				: 0);
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert((!theIPPtr)
				 || (addressIsInPage(thePage, ((void *)theIPPtr))));
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
					oop = longAt(theFP + FoxMFReceiver);
					if (					/* begin isOopForwarded: */
						((!(oop & (tagMask()))))
					 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						longAtput(theFP + FoxMFReceiver, followForwarded(oop));
					}
					assert(!(isForwarded(((mframeHomeMethod(theFP))->methodObject))));
					frameRcvrOffset = theFP + FoxMFReceiver;
					methodHeader = ((mframeHomeMethod(theFP))->methodHeader);
				}
				else {
					oop = longAt(theFP + FoxIFReceiver);
					if (					/* begin isOopForwarded: */
						((!(oop & (tagMask()))))
					 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						longAtput(theFP + FoxIFReceiver, followForwarded(oop));
					}
					oop = longAt(theFP + FoxMethod);
					if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(oop));
						referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent & (tagMask()))))
						 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						newOop = referent;
						offset = newOop - oop;
						if ((theIPPtr)
						 && ((longAt(theIPPtr)) > oop)) {
							longAtput(theIPPtr, (longAt(theIPPtr)) + offset);
						}
						longAtput(theFP + FoxIFSavedIP, (longAt(theFP + FoxIFSavedIP)) + offset);
						longAtput(theFP + FoxMethod, (oop = newOop));
					}
					frameRcvrOffset = theFP + FoxIFReceiver;
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(oop));
					header = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					methodHeader = ((((header) & 7) == 1)
						? header
						: (assert((((usqInt)header)) < GIV(newSpaceStart)),
							assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
							((((CogMethod *) header))->methodHeader)));
				}
				theSP = frameRcvrOffset - (((((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F) * BytesPerWord);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (					/* begin isOopForwarded: */
						((!(oop & (tagMask()))))
					 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(oop));
						referent1 = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent1 & (tagMask()))))
						 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						oop = referent1;
						longAtput(theSP, oop);
					}
					theSP += BytesPerWord;
				}
				if ((				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
				 && ((!((longAt(longAt(theFP + FoxThisContext))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					longAtput(theFP + FoxThisContext, followForwarded(longAt(theFP + FoxThisContext)));
				}
				/* begin frameStackedReceiverOffset: */
				numArgs = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((mframeCogMethod(theFP))->cmNumArgs)
					: byteAt((theFP + FoxIFrameFlags) + 1));
				offset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
				oop = longAt(theFP + offset);
				if (				/* begin isOopForwarded: */
					((!(oop & (tagMask()))))
				 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					longAtput(theFP + offset, followForwarded(oop));
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theIPPtr = ((usqInt)(theFP + FoxCallerSavedIP));
				theFP = callerFP;
			}
			theSP = ((thePage->baseAddress)) - BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					longAtput(theSP, followForwarded(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
}


/*	Spur's become: is lazy, turning the becommed object into a forwarding
	object to the other.
	The read-barrier is minimised by arranging that forwarding pointers will
	fail a method cache
	probe, since notionally objects' internals are accessed only via sending
	messages to them,
	the exception is primitives that access the internals of the non-receiver
	argument(s). 
	To avoid a read barrier on bytecode, literal and inst var fetch and
	non-local return, we scan
	the receivers (including the stacked receiver for non-local return) and
	method references
	in the stack zone and follow any forwarded ones. This is of course way
	cheaper than
	scanning all of memory as in the old become.
	
	Override to handle machine code frames */

	/* CoInterpreter>>#followForwardingPointersOfReceiversInStackZone */
static void
followForwardingPointersOfReceiversInStackZone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt newOop;
    sqInt numArgs;
    sqInt offset;
    usqInt oop;
    sqInt referent;
    char *theFP;
    usqInt theIPPtr;
    StackPage *thePage;
    char *theSP;

	if (!GIV(stackPage)) {
		/* the system must be snapshotting; nothing to do... */
		assert((!(mostRecentlyUsedPage()))
		 || (isFree(mostRecentlyUsedPage())));
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			theIPPtr = (!(thePage == GIV(stackPage))
				? ((usqInt)((thePage->headSP)))
				: 0);
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert((!theIPPtr)
				 || (addressIsInPage(thePage, ((void *)theIPPtr))));
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
					oop = longAt(theFP + FoxMFReceiver);
					if (					/* begin isOopForwarded: */
						((!(oop & (tagMask()))))
					 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						longAtput(theFP + FoxMFReceiver, followForwarded(oop));
					}
					assert(!(isForwarded(((mframeHomeMethod(theFP))->methodObject))));
				}
				else {
					oop = longAt(theFP + FoxIFReceiver);
					if (					/* begin isOopForwarded: */
						((!(oop & (tagMask()))))
					 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						longAtput(theFP + FoxIFReceiver, followForwarded(oop));
					}
					oop = longAt(theFP + FoxMethod);
					if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(oop));
						referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent & (tagMask()))))
						 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						newOop = referent;
						offset = newOop - oop;
						if ((theIPPtr)
						 && ((longAt(theIPPtr)) > oop)) {
							longAtput(theIPPtr, (longAt(theIPPtr)) + offset);
						}
						longAtput(theFP + FoxIFSavedIP, (longAt(theFP + FoxIFSavedIP)) + offset);
						longAtput(theFP + FoxMethod, (oop = newOop));
					}
				}
				if ((				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
				 && ((!((longAt(longAt(theFP + FoxThisContext))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					longAtput(theFP + FoxThisContext, followForwarded(longAt(theFP + FoxThisContext)));
				}
				/* begin frameStackedReceiverOffset: */
				numArgs = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((mframeCogMethod(theFP))->cmNumArgs)
					: byteAt((theFP + FoxIFrameFlags) + 1));
				offset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
				oop = longAt(theFP + offset);
				if (				/* begin isOopForwarded: */
					((!(oop & (tagMask()))))
				 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					longAtput(theFP + offset, followForwarded(oop));
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theIPPtr = ((usqInt)(theFP + FoxCallerSavedIP));
				theFP = callerFP;
			}
			theSP = ((thePage->baseAddress)) - BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					longAtput(theSP, followForwarded(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

	/* CoInterpreter>>#forceInterruptCheckFromHeartbeat */
void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
#    if LRPCheck
		if (!GIV(longRunningPrimitiveCheckSemaphore)) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
#    endif // LRPCheck

	l1:	/* end checkForLongRunningPrimitive */;
		sqLowLevelMFence();
		if (GIV(deferSmash)) {
			GIV(deferredSmash) = 1;
			sqLowLevelMFence();
		}
		else {
			forceInterruptCheck();
		}
	}
}


/*	In the StackInterpreter the saved ip field of a base frame holds the
	base frame's caller context. But in the Cog VM the first word on the
	stack holds the base frame's caller context, which is immediately
	above the stacked receiver. */

	/* CoInterpreter>>#frameCallerContext: */
static NoDbgRegParms sqInt
frameCallerContext(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    StackPage *thePage;

	assert(isBaseFrame(theFP));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(followMaybeForwarded(callerContextOrNil))));
	return callerContextOrNil;
}

	/* CoInterpreter>>#frameHasContext: */
static NoDbgRegParms int
frameHasContext(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0);
}


/*	<Integer> */

	/* CoInterpreter>>#frameIsBlockActivation: */
static NoDbgRegParms int
frameIsBlockActivation(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0);
}

	/* CoInterpreter>>#frameMethodObject: */
static NoDbgRegParms sqInt
frameMethodObject(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeHomeMethod(theFP))->methodObject)
		: longAt(theFP + FoxMethod));
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* CoInterpreter>>#frameNumArgs: */
static NoDbgRegParms sqInt
frameNumArgs(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeCogMethod(theFP))->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1));
}

	/* CoInterpreter>>#framePointerAddress */
usqInt
framePointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(framePointer))));
}

	/* CoInterpreter>>#frameReceiver: */
static NoDbgRegParms sqInt
frameReceiver(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? longAt(theFP + FoxMFReceiver)
		: longAt(theFP + FoxIFReceiver));
}

	/* CoInterpreter>>#functionPointerForCompiledMethod:primitiveIndex:primitivePropertyFlagsInto: */
void
(*functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(sqInt methodObj, sqInt primitiveIndex, sqInt *flagsPtr))(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt firstLiteral;
    int flags;
    void (*functionPointer)(void);
    sqInt header;
    sqInt header1;
    sqInt index;
    sqInt lit;
    sqInt lit1;
    sqInt metadata;
    sqInt metadataFlags;
    sqInt primIdx;
    sqInt targetFunctionIndex;

	flags = 0;
	if (!(flagsPtr == null)) {
		flagsPtr[0] = ((flags = primitivePropertyFlagsnumArgs(primitiveIndex, argumentCountOf(methodObj))));
	}
	if (primitiveIndex == PrimNumberFFICall) {
		/* begin functionForPrimitiveCallout */
		if ((((sqInt)primitiveCalloutPointer)) == -1) {
			reloadPrimitiveCalloutPointer();
		}
		if (!(flagsPtr == null)) {
			if (GIV(primCalloutIsExternal)) {
				flagsPtr[0] = (flags | PrimCallIsExternalCall);
			}
		}
		return primitiveCalloutPointer;
	}
	if (primitiveIndex == PrimNumberExternalCall) {
		/* begin attemptToLinkExternalPrimitive: */
		assert(isCompiledMethod(methodObj));
		header1 = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		header = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		primIdx = 
		/* begin primitiveIndexOfMethod:header: */
(((header & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (methodObj + ((LiteralStart + (((header >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
		firstLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		assert((primIdx == PrimNumberExternalCall)
		 && (((literalCountOfMethodHeader(header)) > 0)
		 && ((isArray(firstLiteral))
		 && ((numSlotsOf(firstLiteral)) == 4))));
		targetFunctionIndex = longAt((firstLiteral + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))));
		assert((((targetFunctionIndex) & 7) == 1));
		if (((targetFunctionIndex >> 3)) == 0) {
			linkExternalCallerrInto(firstLiteral, null);
		}
		lit = firstLiteral;
		if (!(flagsPtr == null)) {
			/* N.B. We only support the FastCPrimitiveFlag on Spur because Spur will not run a GC to
			   satisfy an allocation in a primitive. The V3 ObjectMemory will and hence the depth of
			   stack needed in a V3 primitive is probably too large to safely execute on a stack page. */
			metadata = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))));
			if ((((metadata) & 7) == 1)) {
				/* combine the specific external primitive's flags with the base flags.
				   Hence e.g. if profiling is in effect (as indicated by PrimCallCollectsProfileSamples
				   in the base flags) it remains in effect after combining the specific flags. */
				metadataFlags = ((metadata >> 3)) & SpurPrimitiveFlagsMask;
				flags = flags | metadataFlags;
			}
			if (!((numBytesOf(longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralModuleNameIndex) << (shiftForWord()))))))) == 0)) {
				flags = flags | PrimCallIsExternalCall;
			}
			flagsPtr[0] = flags;
		}
		/* begin functionForPrimitiveExternalCall: */
		if (!((literalCountOf(methodObj)) > 0)) {
			return primitiveExternalCall;
		}
		/* Check if it's an array of length 4 */
		lit1 = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		if (!((			/* begin isArray: */
				((!(lit1 & (tagMask()))))
			 && (((((usqInt)((longAt(lit1)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
			 && ((lengthOf(lit1)) == 4))) {
			return primitiveExternalCall;
		}
		index = longAt((lit1 + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))));
		if (!(((((index) & 7) == 1))
			 && ((((index = (index >> 3))) > 0)
			 && (index <= MaxExternalPrimitiveTableSize)))) {
			return primitiveExternalCall;
		}
		functionPointer = externalPrimitiveTable[index - 1];
		if (functionPointer == 0) {
			return primitiveExternalCall;
		}
		return functionPointer;
	}
	/* begin functionPointerFor:inClass: */
	return (primitiveIndex > MaxPrimitiveIndex
		? 0
		: primitiveTable[primitiveIndex]);
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. Override to answer -1 if we're not in an interpreter frame. */

	/* CoInterpreter>>#getCurrentBytecode */
sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((	/* begin couldBeFramePointer: */
		(GIV(stackBasePlus1))
	 && ((((((usqInt)GIV(framePointer))) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)GIV(framePointer))) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)GIV(framePointer))) <= (((usqInt)GIV(pages))))))))
	 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())))
		? byteAt(GIV(instructionPointer))
		: -1);
}


/*	Answer the flags that are contained in the 7th long of the image header. */

	/* CoInterpreter>>#getImageHeaderFlags */
static sqInt
getImageHeaderFlags(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((((((GIV(fullScreenFlag) + ((VMBIGENDIAN
	? 0
	: 2))) + ((GIV(flagInterpretedMethods)
	? 8
	: 0))) + ((GIV(preemptionYields)
	? 0
	: 16))) + ((GIV(newFinalization)
	? 64
	: 0))) + ((sendWheelEvents
	? 128
	: 0))) + ((primitiveDoMixedArithmetic
	? 0
	: 0x100))) + ((upscaleDisplayIfHighDPI
	? 0
	: 0x400))) + (((GIV(imageHeaderFlags) | (1499)) - (1499)));
}


/*	Handle a send fault that may be due to a send to a forwarded object.
	Unforward the receiver on the stack and answer it. */

	/* CoInterpreter>>#handleForwardedSendFaultForReceiver:stackDelta: */
static NoDbgRegParms sqInt
handleForwardedSendFaultForReceiverstackDelta(sqInt forwardedReceiver, sqInt stackDelta)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt rcvrStackIndex;
    sqInt referent;


	/* should *not* be a super send, so the receiver should be forwarded. */
	assert(isOopForwarded(forwardedReceiver));
	rcvrStackIndex = GIV(argumentCount) + stackDelta;
	assert((stackValue(rcvrStackIndex)) == forwardedReceiver);
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(forwardedReceiver));
	referent = longAt((forwardedReceiver + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent & (tagMask()))))
	 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	rcvr = referent;
	/* begin stackValue:put: */
	longAtput(GIV(stackPointer) + (rcvrStackIndex * BytesPerWord), rcvr);
	followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((rcvrStackIndex + 1) * BytesPerWord));
	if (isPointers(	/* begin frameReceiver: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? longAt(GIV(framePointer) + FoxMFReceiver)
		: longAt(GIV(framePointer) + FoxIFReceiver)))) {
		followForwardedObjectFieldstoDepth(		/* begin frameReceiver: */
			((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? longAt(GIV(framePointer) + FoxMFReceiver)
			: longAt(GIV(framePointer) + FoxIFReceiver)), 0);
	}
	followForwardedFieldsInCurrentMethod();
	return rcvr;
}


/*	A message send from either an open PIC or an unlinked send has not been
	understood. Create a message and execute the relevant resulting MNU
	method. messageSelector is an implicit argument (yuck). */

	/* CoInterpreter>>#handleMNU:InMachineCodeTo:classForMessage: */
static NoDbgRegParms sqInt
handleMNUInMachineCodeToclassForMessage(sqInt selectorIndex, sqInt rcvr, sqInt classForMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classForThisMessage;
    CogMethod *cogMethod;
    sqInt err;
    sqInt errSelIdx;
    sqInt hash;
    sqInt methodHeader;
    char *sp;
    char *sp1;
    sqInt top;

	assert(addressCouldBeOop(rcvr));
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	createActualMessageTo(classForMessage);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(selectorIndex) << (shiftForWord())))));
	if (lookupInMethodCacheSelclassTag(
		GIV(messageSelector),
		(		/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(GIV(lkupClass))),
		flag("todo"),
		(((hash = (long32At(GIV(lkupClass) + 4)) & (identityHashHalfWordMask()))) != 0
				? hash
				: (objCouldBeClassObj(GIV(lkupClass))
						? (((err = enterIntoClassTable(GIV(lkupClass)))) != 0
								? -err
								: (long32At(GIV(lkupClass) + 4)) & (identityHashHalfWordMask()))
						: -PrimErrBadReceiver))))) {
		/* check for coggability because method is in the cache */
		/* begin ifAppropriateCompileToNativeCode:selector: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* makeBaseFrame: can create cog methods with nil selectors. */
			cogMethod = ((CogMethod *) methodHeader);
			if (((cogMethod->selector)) == GIV(nilObj)) {
				setSelectorOfto(cogMethod, GIV(messageSelector));
			}
		}
		else {
			if (((			/* begin literalCountOfMethodHeader: */
				assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
				cogselector(GIV(newMethod), GIV(messageSelector));
			}
			else {
				maybeFlagMethodAsInterpreted(GIV(newMethod));
			}
		}
	}
	else {
		errSelIdx = lookupMNUInClass((classForThisMessage = GIV(lkupClass)));
		if (errSelIdx != 0) {
			if (selectorIndex == SelectorDoesNotUnderstand) {
				error("Recursive not understood error encountered");
			}
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp;
			return handleMNUInMachineCodeToclassForMessage(errSelIdx, rcvr, classForThisMessage);
		}
	}
	if (	/* begin maybeMethodHasCogMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && ((((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp1;
		executeCogMethodfromUnlinkedSendWithReceiver(cogMethodOf(GIV(newMethod)), rcvr);
		assert(0);
	}
	return interpretMethodFromMachineCode();
}


/*	<Integer> */

	/* CoInterpreter>>#iframeIsBlockActivation: */
static NoDbgRegParms int
iframeIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxIFrameFlags) + 3)) != 0;
}

	/* CoInterpreter>>#iframeReceiver: */
static NoDbgRegParms sqInt
iframeReceiver(char *theFP)
{
	return longAt(theFP + FoxIFReceiver);
}

	/* CoInterpreter>>#iframeSavedIP: */
static NoDbgRegParms usqInt
iframeSavedIP(char *theFP)
{
	return ((usqInt)(longAt(theFP + FoxIFSavedIP)));
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null. */

	/* CoInterpreter>>#ifValidWriteBackStack:Pointers:Save:To: */
void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (savedFPP != 0) {
		savedFPP[0] = GIV(framePointer);
	}
	if (savedSPP != 0) {
		savedSPP[0] = GIV(stackPointer);
	}
	if (	/* begin couldBeFramePointer: */
		(GIV(stackBasePlus1))
	 && ((((((usqInt)theCFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theCFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theCFP)) <= (((usqInt)GIV(pages)))))))) {
		GIV(framePointer) = theCFP;
	}
	if (	/* begin couldBeFramePointer: */
		(GIV(stackBasePlus1))
	 && ((((((usqInt)theCSP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theCSP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theCSP)) <= (((usqInt)GIV(pages)))))))) {
		GIV(stackPointer) = theCSP;
	}
}

	/* CoInterpreter>>#instructionPointerAddress */
usqInt
instructionPointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(instructionPointer))));
}


/*	Answer the bytecode pc object (i.e. SmallInteger) for an active frame. The
	bytecode pc is derived from the frame's pc. If the frame is the top frame
	on the current stack
	the frame pc is whatever the current instruction pointer is. If the frame
	is the top
	frame on some other stack the frame pc is the value on top of stack.
	Otherwise the
	frame pc is the saved pc of the frame above. Once the frame pc is found it
	must be
	mapped to a bytecode pc. */

	/* CoInterpreter>>#instructionPointerForFrame:currentFP:currentIP: */
static NoDbgRegParms sqInt
instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *fp;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;
    sqInt value;

	if (spouseFP == currentFP) {
		theIP = oopForPointer(instrPtr);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		/* begin findFrameAbove:inPage: */
		fp = (thePage->headFP);
		if (fp == spouseFP) {
			theFPAbove = 0;
			goto l2;
		}
		while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
			if (callerFP == spouseFP) {
				theFPAbove = fp;
				goto l2;
			}
			fp = callerFP;
		}
		error("did not find theFP in stack page");
		theFPAbove = 0;
	l2:	/* end findFrameAbove:inPage: */;
		theIP = (theFPAbove == 0
			? longAt((thePage->headSP))
			: oopForPointer(pointerForOop(longAt(theFPAbove + FoxCallerSavedIP))));
	}
	value = contextInstructionPointerframe(theIP, spouseFP);
	return ((((int) value)) < 0
		? mustMapMachineCodePCcontext((value >> 3), longAt(spouseFP + FoxThisContext))
		: value);
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

	/* CoInterpreter>>#interpreterAllocationReserveBytes */
static NeverInline sqInt
interpreterAllocationReserveBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;

	maxUsedBytesPerPage = (stackPageFrameBytes()) + ((IFrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / MFrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	Execute a method interpretively from machine code. We assume (require)
	that newMethod
	messageSelector, primitiveFunctionPointer and argumentCount have been set
	in the caller.
	Once evaluated either continue in the interpreter via a jongjmp or in
	machine code via an
	enilopmart (a form of longjmp - a stinking rose by any other name). */

	/* CoInterpreter>>#interpretMethodFromMachineCode */
static sqInt
interpretMethodFromMachineCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nArgs;
    char *savedFramePointer;
    char *savedStackPointer;

	assertCStackWellAligned();
	assert(validInstructionPointerinFrame(GIV(instructionPointer), GIV(framePointer)));
	if (primitiveFunctionPointer != 0) {
		if (primitiveFunctionPointer == primitiveInvokeObjectAsMethod) {
			assert(!(isOopCompiledMethod(GIV(newMethod))));
		}
		else {
			assert((isOopCompiledMethod(GIV(newMethod)))
			 && ((primitiveIndexOf(GIV(newMethod))) != 0));
		}
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			GIV(primFailCode) = 0;
		}
		else {
			/* begin slowPrimitiveResponse */
			assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
			assert((remapBufferCount()) == 0);
			nArgs = GIV(argumentCount);
			savedStackPointer = GIV(stackPointer);
			savedFramePointer = GIV(framePointer);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			if (			/* begin recordPrimTraceForMethod: */
				(recordPrimTrace())
			 && ((primTracePluginName == null
				? 1
				: methodHasPrimitiveInPrimTracePlugin(GIV(newMethod))))) {
				/* begin fastLogPrim: */
				GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(newMethod);
				primTraceLogIndex(GIV(primTraceLogIndex) + 1);
			}
			dispatchFunctionPointer(primitiveFunctionPointer);
			assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
			/* begin maybeRetryPrimitiveOnFailure */
			if (GIV(primFailCode)) {
				retryPrimitiveOnFailure();
			}
			if ((!GIV(primFailCode))
			 && ((GIV(framePointer) == savedFramePointer)
			 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))))) {
				/* Don't fail if primitive has done something radical, e.g. perform: */
				if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
					flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
					failUnbalancedPrimitive();
					GIV(stackPointer) = savedStackPointer;
				}
			}
			if (GIV(nextProfileTick) > 0) {
				checkProfileTick(GIV(newMethod));
			}
			/* begin successful */
		}
		if (!GIV(primFailCode)) {
			returntoExecutive(popStack(), 0);
		}
	}
	else {
		assert((isOopCompiledMethod(GIV(newMethod)))
		 && (((primitiveIndexOf(GIV(newMethod))) == 0)
		 || (((functionPointerForinClass(primitiveIndexOf(GIV(newMethod)), nilObject())) == 0)
		 || (isNullExternalPrimitiveCall(GIV(newMethod))))));
	}
	activateNewMethod();
	ceInvokeInterpret();
	return null;
}

	/* CoInterpreter>>#isCogMethodReference: */
int
isCogMethodReference(sqInt methodHeader)
{
	assert(((((methodHeader) & 7) == 1))
	 || (((((usqInt)methodHeader)) < (startOfMemory()))
	 && ((((usqInt)methodHeader)) >= (minCogMethodAddress()))));
	return (!(methodHeader & (smallIntegerTag())));
}

	/* CoInterpreter>>#isExternalMethodInPlugin: */
static NoDbgRegParms sqInt
isExternalMethodInPlugin(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt header1;
    sqInt literal;
    usqInt numSlots;
    sqInt primIdx;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj));
	header1 = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	primIdx = 
	/* begin primitiveIndexOfMethod:header: */
(((header & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (methodObj + ((LiteralStart + (((header >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	return (primIdx == PrimNumberExternalCall)
	 && ((((	/* begin literalCountOfMethodHeader: */
		assert((((header) & 7) == 1)),
	((header >> 3)) & AlternateHeaderNumLiteralsMask)) > 0)
	 && ((isArray((literal = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord()))))))))
	 && ((((	/* begin numSlotsOf: */
		assert((classIndexOf(literal)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(literal + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(literal - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) == 4)
	 && ((isBytes(longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralModuleNameIndex) << (shiftForWord())))))))
	 && (!((numBytesOf(longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralModuleNameIndex) << (shiftForWord()))))))) == 0))))));
}


/*	Answer if the argument is a full block method or not. Full block methods
	(as introduced by the SistaV1BytecodeSet) are used to implement block
	closures and have a reference to their enclosing block or method as their
	last literal. Compiled methods have a class association as their last
	literal.  */

	/* CoInterpreter>>#isFullBlockMethod: */
sqInt
isFullBlockMethod(sqInt aMethodObj)
{
    sqInt offset;
    sqInt oop;


	/* begin ultimateLiteralOf: */
	assert(isOopCompiledMethod(aMethodObj));
	offset = (literalCountOf(aMethodObj)) - 1;
	oop = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	/* begin isOopCompiledMethod: */
	return ((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()));
}

	/* CoInterpreter>>#isMachineCodeFrameForCogMethodFlaggedForBecome: */
static NoDbgRegParms sqInt
isMachineCodeFrameForCogMethodFlaggedForBecome(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
	 && (isCMMethodFlaggedForBecome(((CogBlockMethod *) (mframeHomeMethod(theFP)))));
}

	/* CoInterpreter>>#isMachineCodeFrameForCogMethodWithMachineCodePrim: */
static NoDbgRegParms sqInt
isMachineCodeFrameForCogMethodWithMachineCodePrim(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
	 && (cogMethodHasMachineCodePrim(mframeHomeMethod(theFP)));
}

	/* CoInterpreter>>#isMachineCodeFrameForCogMethodWithTooManyLiterals: */
static NoDbgRegParms sqInt
isMachineCodeFrameForCogMethodWithTooManyLiterals(char *theFP)
{
	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
	 && (!(methodWithHeaderShouldBeCogged(((mframeHomeMethod(theFP))->methodHeader))));
}

	/* CoInterpreter>>#isMachineCodeFrameForExternalPrimitiveMethod: */
static NoDbgRegParms sqInt
isMachineCodeFrameForExternalPrimitiveMethod(char *theFP)
{
    CogMethod *homeMethod;

	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
	 && ((cogMethodHasMachineCodePrim((homeMethod = mframeHomeMethod(theFP))))
	 && (isExternalMethodInPlugin((homeMethod->methodObject))));
}

	/* CoInterpreter>>#isMachineCodeFrame: */
static NoDbgRegParms int
isMachineCodeFrame(char *theFP)
{
	return (((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory());
}

	/* CoInterpreter>>#longRunningPrimitiveStopUsecsAddress */
#if LRPCheck
usqInt
longRunningPrimitiveStopUsecsAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(longRunningPrimitiveStopUsecs))));
}
#endif /* LRPCheck */


/*	Lookup selector in rcvr, without doing MNU processing, and answer either a
	method or an error code if the message was not understood. Used to
	populate closed PICs. */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

	/* CoInterpreter>>#lookupMNU:receiver: */
sqInt
lookupMNUreceiver(sqInt selector, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt erridx;
    sqInt inCache;
    sqInt tagBits;

	classTag = 
	/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask()));
	inCache = lookupInMethodCacheSelclassTag(selector, classTag);
	if (!inCache) {
		GIV(messageSelector) = selector;
		erridx = lookupMNUInClass(classForClassTag(classTag));
		if (erridx != 0) {
			assert(erridx <= (maxLookupNoMNUErrorCode()));
			return erridx;
		}
	}
	return GIV(newMethod);
}


/*	Lookup selector in rcvr, without doing MNU processing, and answer either a
	method or an error code if the message was not understood. Used to
	populate closed PICs. */
/*	self printFrame: stackPage headFP WithSP: stackPage headSP */
/*	self printStringOf: selector */

	/* CoInterpreter>>#lookupOrdinary:receiver: */
sqInt
lookupOrdinaryreceiver(sqInt selector, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt erridx;
    sqInt tagBits;

	classTag = 
	/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask()));
	if (!(lookupInMethodCacheSelclassTag(selector, classTag))) {
		GIV(messageSelector) = selector;
		if (((erridx = lookupOrdinaryNoMNUEtcInClass(classForClassTag(classTag)))) != 0) {
			assert(erridx <= (maxLookupNoMNUErrorCode()));
			return erridx;
		}
	}
	return GIV(newMethod);
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. Override to
	hold the caller context in a different place, In the StackInterpreter we
	use the caller saved ip, but in the Cog VM caller saved ip is the
	ceBaseReturn: trampoline. Simply hold the caller context in the first word
	of the stack. */

	/* CoInterpreter>>#makeBaseFrameFor: */
static NoDbgRegParms StackPage *
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt header;
    sqInt header1;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt numArgs;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt rawHeader;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt yetToCompact;


	/* theIP must be typed as signed because it is assigned ceCannotResumePC and so maybe implicitly typed as unsigned. */
	assert(isContext(aContext));
	assert(isSingleContext(aContext));
	assert(goodContextSize(aContext));
	theIP = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	assert(HasBeenReturnedFromMCPC < 0);
	theIP = ((((theIP) & 7) == 1)
		? (theIP >> 3)
		: HasBeenReturnedFromMCPC);
	/* begin followObjField:ofObject: */
	objOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(MethodIndex, aContext, objOop);
	}
	theMethod = objOop;
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		page = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	page = lruOrFree;
	l2:	/* end newStackPage */;
	longAtput((pointer = (page->baseAddress)), followObjFieldofObject(SenderIndex, aContext));
	longAtput((pointer -= BytesPerWord), aContext);
	/* begin followField:ofObject: */
	objOop1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop1 & (tagMask()))))
	 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, aContext, objOop1);
	}
	rcvr = objOop1;
	maybeClosure = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))));
	if (maybeClosure != GIV(nilObj)) {
		if ((!((longAt(maybeClosure)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			maybeClosure = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, aContext, maybeClosure);
		}
		/* begin argumentCountOfClosure: */
		oop1 = longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
		assert((((oop1) & 7) == 1));
		numArgs = (oop1 >> 3);
		longAtput((pointer -= BytesPerWord), maybeClosure);
	}
	else {
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(theMethod));
		header1 = longAt((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		header = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		/* If this is a synthetic context its IP could be pointing at the CallPrimitive opcode.  If so, skip it. */
		numArgs = (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
		if ((((header & AlternateHeaderHasPrimFlag) != 0))
		 && (theIP == (1 + ((((/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop)))) {
			theIP += 3 /* begin sizeOfCallPrimitiveBytecode: */;
		}
		longAtput((pointer -= BytesPerWord), rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
	longAtput((pointer -= BytesPerWord), ceBaseFrameReturnPC());
	longAtput((pointer -= BytesPerWord), 0);
	(page->headFP = pointer);
	if (theIP < 0) {
		/* Since we would have to generate a machine-code method to be able to map
		   the native pc anyway we should create a native method and native frame. */
		/* begin ensureMethodIsCogged:maybeClosure: */
		rawHeader = longAt((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((rawHeader) & 7) == 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))) {
			cogMethod = ((CogMethod *) rawHeader);
			goto l5;
		}
		yetToCompact = 1;
		while (1) {
			if ((maybeClosure != GIV(nilObj))
			 && (!(((((longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1)))) {
				cogMethod1 = cogFullBlockMethodnumCopied(
					theMethod,
					(					/* begin copiedValueCountOfFullClosure: */
						assert(!((isVanillaBlockClosure(maybeClosure)))),
					((/* begin numSlotsOf: */
	assert((classIndexOf(maybeClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(maybeClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(maybeClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - FullClosureFirstCopiedValueIndex));
			}
			else {
				cogMethod1 = cogselector(theMethod, GIV(nilObj));
			}
			if (!((cogMethod1 == null)
			 && (GIV(cogCompiledCodeCompactionCalledFor)
			 && (yetToCompact)))) break;
			yetToCompact = 0;
			commenceCogCompiledCodeCompaction();
		}
		if (!(asserta(cogMethod1 != null))) {
			error("could not compile method that should have been compiled");
		}
		cogMethod = cogMethod1;
	l5:	/* end ensureMethodIsCogged:maybeClosure: */;
		theMethod = ((sqInt)cogMethod);
		if (maybeClosure != GIV(nilObj)) {
			if (((((longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1)) {
				/* If the pc is the special HasBeenReturnedFromMCPC pc set the pc
				   appropriately so that the frame stays in the cannotReturn: state. */
				if (theIP == HasBeenReturnedFromMCPC) {
					theMethod = ((sqInt)(findMethodForStartBcpcinHomeMethod((((longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))))) >> 3)) - 1, ((CogMethod *) theMethod))));
					if (theMethod == 0) {
						error("cannot find machine code block matching closure's startpc");
					}
					theIP = ceCannotResumePC();
				}
				else {
					assert((((theIP) >> 16)) < -1);
					theMethod -= (((theIP) >> 16)) * (blockAlignment());
					theIP = theMethod - (((short)theIP));
				}
			}
			else {
				assert((((theIP) >> 16)) >= -1);
				theIP = (theIP == HasBeenReturnedFromMCPC
					? ceCannotResumePC()
					: (((sqInt)theMethod)) - theIP);
			}
			longAtput((pointer -= BytesPerWord), (theMethod + MFMethodFlagHasContextFlag) + MFMethodFlagIsBlockFlag);
		}
		else {
			assert((((theIP) >> 16)) >= -1);
			theIP = (theIP == HasBeenReturnedFromMCPC
				? ceCannotResumePC()
				: (((sqInt)theMethod)) - theIP);
			longAtput((pointer -= BytesPerWord), theMethod + MFMethodFlagHasContextFlag);
		}
		longAtput((pointer -= BytesPerWord), aContext);
	}
	else {
		longAtput((pointer -= BytesPerWord), theMethod);
		longAtput((pointer -= BytesPerWord), aContext);
		longAtput((pointer -= BytesPerWord), 
		/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
			? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (1ULL << ((BytesPerWord * 8) - 16))) + ((maybeClosure != GIV(nilObj)
	? 1ULL << ((BytesPerWord * 8) - 24)
	: 0))
			: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0x10000)) + ((maybeClosure != GIV(nilObj)
	? 0x1000000
	: 0))));
		longAtput((pointer -= BytesPerWord), 0);
		/* begin iframeInstructionPointerForIndex:method: */
		assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod)))));
		theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;
	}
	(page->baseFP = (page->headFP));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput((pointer -= BytesPerWord), rcvr);
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	stackPtrIndex = (oop >> 3);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(aContext)));
		longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), GIV(nilObj));
	}
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP)));
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer((page->baseFP))) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer((page->baseFP))) + (smallIntegerTag());
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(aContext)));
	longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(0)) + (smallIntegerTag());
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(aContext)));
	longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	assert(((((fetchPointerofObject(SenderIndex, aContext))) & 7) == 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page));
	return page;
}

	/* CoInterpreter>>#mapStackPages */
static NeverInline void
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt i;
    sqInt numLivePages;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	theIP = 0;
	numLivePages = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			numLivePages += 1;
			theSP = (thePage->headSP);
			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
				 || ((((usqInt)(longAt(theFP + FoxIFSavedIP)))) == 0)
					? 0
					: theFP + FoxIFSavedIP);
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				frameRcvrOffset = 
				/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver);
				while (theSP <= frameRcvrOffset) {
					oop = longAt(theSP);
					if (					/* begin shouldRemapOop: */
						((!(oop & (tagMask()))))
					 && (shouldRemapObj(oop))) {
						longAtput(theSP, remapObj(oop));
					}
					theSP += BytesPerWord;
				}
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					if (shouldRemapObj(longAt(theFP + FoxThisContext))) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext)));
					}
					if (!((GIV(gcPhaseInProgress) == SlidingCompactionInProgress)
					 || (GIV(gcPhaseInProgress) == ScavengeInProgress))) {
						assert((isMarriedOrWidowedContext(frameContext(theFP)))
						 && ((frameOfMarriedContext(frameContext(theFP))) == theFP));
					}
				}
				if (!((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))) {
					if (shouldRemapObj(longAt(theFP + FoxMethod))) {
						if (theIPPtr != 0) {
							theIP = longAt(theIPPtr);
							if (theIP == (ceReturnToInterpreterPC())) {
								assert((iframeSavedIP(theFP)) > (iframeMethod(theFP)));
								theIPPtr = theFP + FoxIFSavedIP;
								theIP = longAt(theIPPtr);
							}
							else {
								assert(theIP > (iframeMethod(theFP)));
							}
							theIP -= longAt(theFP + FoxMethod);
						}
						longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod)));
						if (theIPPtr != 0) {
							longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
						}
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (				/* begin shouldRemapOop: */
					((!(oop & (tagMask()))))
				 && (shouldRemapObj(oop))) {
					longAtput(theSP, remapObj(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
	/* begin recordLivePagesOnMapping: */
	GIV(statNumMaps) += 1;
	GIV(statPageCountWhenMappingSum) += numLivePages;
	GIV(statMaxPageCountWhenMapping) = ((GIV(statMaxPageCountWhenMapping) < numLivePages) ? numLivePages : GIV(statMaxPageCountWhenMapping));
}


/*	The trace log is a circular buffer of pairs of entries. If there is
	an entry at traceLogIndex - 3 \\ TraceBufferSize it has entries.
	If there is something at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#mapTraceLog */
static void
mapTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt intOrClass;
    sqInt limit;
    sqInt remainder;
    sqInt selectorOrMethod;

	limit = 
	/* begin safe:mod: */
(((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	for (i = 0; i <= limit; i += 3) {
		intOrClass = GIV(traceLog)[i];
		if (		/* begin shouldRemapOop: */
			((!(intOrClass & (tagMask()))))
		 && (shouldRemapObj(intOrClass))) {
			GIV(traceLog)[i] = (remapObj(intOrClass));
		}
		selectorOrMethod = GIV(traceLog)[i + 1];
		if (		/* begin shouldRemapOop: */
			((!(selectorOrMethod & (tagMask()))))
		 && (shouldRemapObj(selectorOrMethod))) {
			GIV(traceLog)[i + 1] = (remapObj(selectorOrMethod));
		}
	}
}


/*	If instructionPointer is referring to machine code, as it will be if a
	primitive is in progress
	(see isCodeCompactingPrimitiveIndex:) it may refer to a method, and if so
	that method
	must be retained. */

	/* CoInterpreter>>#markActiveMethodsAndReferents */
void
markActiveMethodsAndReferents(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    CogMethod *primCogMethod;
    StackPage *thePage;

	if (GIV(instructionPointer) != 0) {
		primCogMethod = cogMethodContaining(GIV(instructionPointer));
		if (!(primCogMethod == null)) {
			markMethodAndReferents(((CogBlockMethod *) primCogMethod));
		}
	}
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			markCogMethodsAndReferentsOnPage(thePage);
		}
	}
}

	/* CoInterpreter>>#markAndTraceStackPage: */
static NoDbgRegParms void
markAndTraceStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogBlockMethod *aCogMethod;
    char *callerFP;
    char *frameRcvrOffset;
    CogMethod *homeMethod;
    sqInt oop;
    sqInt referent;
    sqInt referent1;
    char *theFP;
    char *theSP;

	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);
	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = 
		/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? theFP + FoxMFReceiver
			: theFP + FoxIFReceiver);
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (			/* begin isOopForwarded: */
				((!(oop & (tagMask()))))
			 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent & (tagMask()))))
				 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				oop = referent;
				longAtput(theSP, oop);
			}
			if (!(((oop & (tagMask())) != 0))) {
				markAndTrace(oop);
			}
			theSP += BytesPerWord;
		}
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			markAndTrace(frameContext(theFP));
		}
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			/* begin mframeCogMethod: */
			aCogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
			homeMethod = (((aCogMethod->cmType)) >= CMMethod
				? ((CogMethod *) aCogMethod)
				: ((aCogMethod->cpicHasMNUCaseOrCMIsFullBlock)
						? ((CogMethod *) aCogMethod)
						: ((CogMethod *) ((((usqInt)aCogMethod)) - ((aCogMethod->homeOffset))))));
			markAndTrace((homeMethod->methodObject));
		}
		else {
			markAndTrace(iframeMethod(theFP));
		}
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}
	/* caller ip is ceBaseReturnPC */
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (		/* begin isOopForwarded: */
			((!(oop & (tagMask()))))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop));
			referent1 = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent1 & (tagMask()))))
			 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			oop = referent1;
			longAtput(theSP, oop);
		}
		if (!(((oop & (tagMask())) != 0))) {
			markAndTrace(oop);
		}
		theSP += BytesPerWord;
	}
}


/*	The trace log is a circular buffer of pairs of entries. If there is an
	entry at
	traceLogIndex - 3 \\ TraceBufferSize it has entries. If there is something
	at traceLogIndex it has wrapped. */

	/* CoInterpreter>>#markAndTraceTraceLog */
static void
markAndTraceTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt limit;
    sqInt oop;
    sqInt remainder;

	limit = 
	/* begin safe:mod: */
(((remainder = (GIV(traceLogIndex) - 3) % TraceBufferSize)) < 0
		? remainder + TraceBufferSize
		: remainder);
	if ((GIV(traceLog)[limit]) == 0) {
		return;
	}
	if ((GIV(traceLog)[GIV(traceLogIndex)]) != 0) {
		limit = TraceBufferSize - 3;
	}
	for (i = 0; i <= limit; i += 3) {
		oop = GIV(traceLog)[i];
		if (!(((oop & (tagMask())) != 0))) {
			markAndTrace(oop);
		}
		oop = GIV(traceLog)[i + 1];
		if (!(((oop & (tagMask())) != 0))) {
			markAndTrace(oop);
		}
	}
}

	/* CoInterpreter>>#markCogMethodsAndReferentsOnPage: */
static NoDbgRegParms void
markCogMethodsAndReferentsOnPage(StackPage *thePage)
{
    char *callerFP;
    char *theFP;

	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));
	theFP = (thePage->headFP);
	while (1) {
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			markMethodAndReferents(mframeCogMethod(theFP));
		}
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theFP = callerFP;
	}
}


/*	Answer whether marryFrame:SP: copies non-argument temporaries. */

	/* CoInterpreter>>#marryFrameCopiesTemps */
sqInt
marryFrameCopiesTemps(void)
{
	return 0;
}

	/* CoInterpreter>>#maxLookupNoMNUErrorCode */
sqInt
maxLookupNoMNUErrorCode(void)
{
	return ((SelectorCannotInterpret < SelectorDoesNotUnderstand) ? SelectorDoesNotUnderstand : SelectorCannotInterpret);
}


/*	The flag bit can be used to flag methods that are interpreted, if it has
	been requested
	from the image header flags. */

	/* CoInterpreter>>#maybeFlagMethodAsInterpreted: */
static NoDbgRegParms void
maybeFlagMethodAsInterpreted(sqInt aMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rawHeader;
    sqInt realHeader;

	if (GIV(flagInterpretedMethods)) {
		rawHeader = longAt((aMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		realHeader = ((		/* begin isCogMethodReference: */
			assert(((((rawHeader) & 7) == 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))
			? ((((CogMethod *) rawHeader))->methodHeader)
			: rawHeader);
		realHeader = realHeader | ((((usqInt)(1U << MethodHeaderFlagBitPosition) << 3) | 1));
		if ((		/* begin isCogMethodReference: */
			assert(((((rawHeader) & 7) == 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))) {
			((((CogMethod *) rawHeader))->methodHeader = realHeader);
		}
		else {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(aMethod)));
			longAtput((aMethod + BaseHeaderSize) + (0U << (shiftForWord())), realHeader);
		}
	}
}

	/* CoInterpreter>>#methodCacheAddress */
usqInt
methodCacheAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)GIV(methodCache));
}

	/* CoInterpreter>>#methodHasCogMethod: */
int
methodHasCogMethod(sqInt aMethodOop)
{
    sqInt methodHeader;

	assert(isNonImmediate(aMethodOop));
	methodHeader = longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	/* begin isCogMethodReference: */
	assert(((((methodHeader) & 7) == 1))
	 || (((((usqInt)methodHeader)) < (startOfMemory()))
	 && ((((usqInt)methodHeader)) >= (minCogMethodAddress()))));
	return (!(methodHeader & (smallIntegerTag())));
}

	/* CoInterpreter>>#methodHasMachineCodePrimitiveMethod: */
static NoDbgRegParms sqInt
methodHasMachineCodePrimitiveMethod(sqInt methodObj)
{
    sqInt methodHeader;

	methodHeader = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	return ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag())))))
	 && (cogMethodHasMachineCodePrim(((CogMethod *) methodHeader)));
}

	/* CoInterpreter>>#methodHasPrimitiveInPrimTracePlugin: */
static NoDbgRegParms NeverInline sqInt
methodHasPrimitiveInPrimTracePlugin(sqInt aMethodObj)
{
    sqInt len;
    sqInt lit;
    usqInt numSlots;
    sqInt ok;
    sqInt pluginName;

	if (!(((primitiveIndexOf(aMethodObj)) == PrimNumberExternalCall)
		 && ((literalCountOf(aMethodObj)) > 0))) {
		return 0;
	}
	lit = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
	if (!((		/* begin isArray: */
			((!(lit & (tagMask()))))
		 && (((((usqInt)((longAt(lit)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((assert((classIndexOf(lit)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(lit + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(lit - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) == 4))) {
		return 0;
	}
	assert(primTracePluginName);
	pluginName = longAt((lit + BaseHeaderSize) + (0U << (shiftForWord())));
	if (!(		/* begin isBytes: */
			((!(pluginName & (tagMask()))))
		 && (((((usqInt)((longAt(pluginName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		return 0;
	}
	/* begin object:equalsString: */
	len = strlen(primTracePluginName);
	ok = 
	/* begin object:equalsString:ofSize: */
(((!(pluginName & (tagMask()))))
	 && (((((usqInt)((longAt(pluginName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
	 && ((!(((((usqInt)((longAt(pluginName)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && (((numBytesOfBytes(pluginName)) == len)
	 && ((strncmp(primTracePluginName, firstIndexableField(pluginName), len)) == 0)));
	return ok;
}

	/* CoInterpreter>>#methodHasTooManyLiterals: */
static NoDbgRegParms int
methodHasTooManyLiterals(sqInt methodObj)
{
	return !(methodWithHeaderShouldBeCogged(methodHeaderOf(methodObj)));
}

	/* CoInterpreter>>#methodNeedsLargeContext: */
int
methodNeedsLargeContext(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodHeader;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj));
	header = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	/* begin methodHeaderIndicatesLargeFrame: */
	return (methodHeader & LargeContextBit) != 0;
}

	/* CoInterpreter>>#methodShouldBeCogged: */
sqInt
methodShouldBeCogged(sqInt aMethodObj)
{
	if (methodWithHeaderShouldBeCogged(methodHeaderOf(aMethodObj))) {
		return 1;
	}
	maybeFlagMethodAsInterpreted(aMethodObj);
	return 0;
}


/*	At the moment jit any method with less than N literals, where N defaults
	to 60.
	See e.g. SimpleStackBasedCogit class>>initialize.
	In my dev image eem 2/22/2009 13:39
	(30 to: 100 by: 5) collect:
	[:n| n -> (SystemNavigation default allSelect: [:m| m numLiterals > n])
	size] #(30->1681 35->1150 40->765 45->523 50->389 55->289 60->206
	65->151 70->124 75->99 80->73 85->63 90->54 95->42 100->38).
	And running the CogVMSimulator with flagging of interpreted methods turned
	on reveals
	the following sizes of interpreted methods.
	| sizes |
	sizes := Bag new.
	SystemNavigation default allSelect: [:m| m flag ifTrue: [sizes add: m
	numLiterals]. false].
	sizes sortedElements asArray
	#(	40->4 41->1 42->2 44->1 45->3 46->1 47->2 48->1
	50->2 51->1 53->1 55->1 56->1
	87->1 108->1 171->1)
	literalCountOfHeader: does not include the header word. */

	/* CoInterpreter>>#methodWithHeaderShouldBeCogged: */
static NoDbgRegParms int
methodWithHeaderShouldBeCogged(sqInt methodHeader)
{
	return ((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile;
}


/*	Answer the Cog method for a machine code frame. This may be
	either a full CogMethod or merely a CogBlockMethod rump header. */

	/* CoInterpreter>>#mframeCogMethod: */
static NoDbgRegParms CogBlockMethod *
mframeCogMethod(char *theFP)
{
	return ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
}

	/* CoInterpreter>>#mframeHomeMethodExport */
CogMethod *
mframeHomeMethodExport(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodField;


	/* begin mframeHomeMethod: */
	methodField = longAt(GIV(framePointer) + FoxMethod);
	if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
		return 
		/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
			? ((CogMethod *) (((CogBlockMethod *) (methodField & MFMethodMask))))
			: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset)))));
	}
	return ((CogMethod *) (methodField & MFMethodMask));
}


/*	Answer the home method for a machine code frame. From a block frame we
	find the home method through the block's homeOffset field which is the
	delta to it.
	In both cases we need to strip the isBlock and isContext flags from the
	method field. */

	/* CoInterpreter>>#mframeHomeMethod: */
static NoDbgRegParms CogMethod *
mframeHomeMethod(char *theFP)
{
    sqInt methodField;

	methodField = longAt(theFP + FoxMethod);
	if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
		return 
		/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
			? ((CogMethod *) (((CogBlockMethod *) (methodField & MFMethodMask))))
			: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset)))));
	}
	return ((CogMethod *) (methodField & MFMethodMask));
}


/*	<Integer> */

	/* CoInterpreter>>#mframeIsBlockActivation: */
static NoDbgRegParms int
mframeIsBlockActivation(char *theFP)
{
	return ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0;
}

	/* CoInterpreter>>#mframeReceiver: */
static NoDbgRegParms sqInt
mframeReceiver(char *theFP)
{
	return longAt(theFP + FoxMFReceiver);
}


/*	Traverse all stack pages looking for non-zero bytes in the headroom part
	of each page.
	Answer the minimum size of unused headroom (zero bytes) in the pages. This
	is for
	checking that there is enough headroom allocated in stack pages. */

	/* CoInterpreter>>#minimumUnusedHeadroom */
static NeverInline int
minimumUnusedHeadroom(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    int minUnused;
    char *p;
    StackPage *page;
    int unused;

	minUnused = (((stackPageAt(0))->baseAddress)) - (((stackPageAt(0))->lastAddress));
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(i, GIV(pages));
		p = (page->lastAddress);
		do {
			p += BytesPerWord;
		} while(((longAtPointer(p)) == 0)
			 && (p <= ((page->baseAddress))));
		unused = (p - BytesPerWord) - ((page->lastAddress));
		if (unused < minUnused) {
			minUnused = unused;
		}
	}
	return minUnused;
}


/*	Lookup the doesNotUnderstand: selector in the class of the argument rcvr.
	Answer either the matching method (cogged if appropriate), or nil, if not
	found. 
 */

	/* CoInterpreter>>#mnuMethodOrNilFor: */
static NoDbgRegParms sqInt
mnuMethodOrNilFor(sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    usqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt methodHeader;
    sqInt mnuMethod;
    sqInt mnuSelector;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt tagBits;
    sqInt wrapAround;

	assert(!((isOopForwarded(rcvr))));
	/* begin fetchClassOf: */
	if (((tagBits = rcvr & (tagMask()))) != 0) {
		currentClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))));
	}
	else {
		currentClass = fetchClassOfNonImm(rcvr);
	}
	mnuSelector = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))));
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {
			return null;
		}
		/* begin lookupMethodFor:InDictionary: */
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		length = (((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		mask = (length - SelectorStart) - 1;
		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((((mnuSelector & (tagMask())) != 0)
	? (mnuSelector >> 3)
	: (long32At(mnuSelector + 4)) & (identityHashHalfWordMask()))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (index << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				mnuMethod = null;
				goto l2;
			}
			if (			/* begin isOopForwarded: */
				((!(nextSelector & (tagMask()))))
			 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == mnuSelector) {
				/* begin followObjField:ofObject: */
				objOop = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop));
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop);
				}
				methodArray = objOop;
				/* begin followField:ofObject: */
				objOop1 = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << (shiftForWord())));
				if (				/* begin isOopForwarded: */
					((!(objOop1 & (tagMask()))))
				 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop1);
				}
				mnuMethod = objOop1;
				goto l2;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					mnuMethod = null;
					goto l2;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		mnuMethod = null;
	l2:	/* end lookupMethodFor:InDictionary: */;
		if (!(mnuMethod == null)) {
			methodHeader = longAt((mnuMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			if ((!((			/* begin isCogMethodReference: */
				assert(((((methodHeader) & 7) == 1))
				 || (((((usqInt)methodHeader)) < (startOfMemory()))
				 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
			/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))))
			 && (((assert((((methodHeader) & 7) == 1)),
			((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile)) {
				cogselector(mnuMethod, mnuSelector);
			}
			return mnuMethod;
		}
		/* begin superclassOf: */
		objOop2 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop2));
		if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop2);
		}
		currentClass = objOop2;
	}
	return null;
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

	/* CoInterpreter>>#moveFramesIn:through:toPage: */
static NoDbgRegParms char *
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    usqInt callerIP;
    int delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    sqInt numArgs;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    char *theSP;
    sqInt valuePointer;
    sqInt valuePointer1;


	/* A base frame must have a context for cannotReturn: processing. */
	assert(!(isBaseFrame(theFP)));
	assert(validStackPageBaseFrames());
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(frameHasContext(callerFP));
	assert(isContext(frameContext(callerFP)));
	theSP = theFP + (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
	? FoxMFReceiver
	: FoxIFReceiver));
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(theFP)));
		theContext = longAt(theFP + FoxThisContext);
		goto l1;
	}
	theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
	longAtput((newSP = (newPage->baseAddress)), longAt(callerFP + FoxThisContext));
	longAtput((newSP -= BytesPerWord), theContext);
	/* begin frameStackedReceiverOffset: */
	numArgs = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeCogMethod(theFP))->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1));
	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = (((newPage->baseAddress)) - stackedReceiverOffset) - (2 * BytesPerWord);
	theFP1 = ((oldPage->headFP)) + delta;
	/* begin setHeadFP:andSP:inPage: */
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
	if ((((usqInt)callerIP)) >= (startOfMemory())) {
		/* begin iframeSavedIP:put: */
		assert(!(isMachineCodeFrame(callerFP)));
		longAtput(callerFP + FoxIFSavedIP, callerIP);
		callerIP = ceReturnToInterpreterPC();
	}
	longAtput(theFP + stackedReceiverOffset, callerIP);
	assert((callerFP < ((oldPage->baseAddress)))
	 && (callerFP > (((oldPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerSavedIP, ceBaseFrameReturnPC());
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP != 0) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(fpInNewPage + FoxMethod)))) < (startOfMemory())
			? ((longAt(fpInNewPage + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((fpInNewPage + FoxIFrameFlags) + 2)) != 0)) {
			theContext = longAt(fpInNewPage + FoxThisContext);
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0);
			valuePointer = (oopForPointer(fpInNewPage)) + (smallIntegerTag());
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(theContext)));
			longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0);
			valuePointer1 = (oopForPointer(offsetCallerFP)) + (smallIntegerTag());
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(theContext)));
			longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	assert(validStackPageBaseFrames());
	return newFP;
}


/*	Map the native pc theIP into a bytecode pc integer object and answer it.
	See contextInstructionPointer:frame: for the explanation. */

	/* CoInterpreter>>#mustMapMachineCodePC:context: */
static NoDbgRegParms sqInt
mustMapMachineCodePCcontext(sqInt theIP, sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bcpc;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    CogBlockMethod *cogMethodForIP;
    sqInt maybeClosure;
    sqInt mcpc;
    sqInt methodObj;
    usqInt numSlots;
    sqInt rawHeader;
    sqInt startBcpc;
    sqInt yetToCompact;

	if (theIP == HasBeenReturnedFromMCPC) {
		return GIV(nilObj);
	}
	maybeClosure = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))));
	methodObj = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	if ((maybeClosure != GIV(nilObj))
	 && (((((longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1))) {
		assert((((theIP) >> 16)) < -1);
		startBcpc = (((longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))))) >> 3)) - 1;
	}
	else {
		assert((((theIP) >> 16)) == -1);
		startBcpc = ((literalCountOf(methodObj)) + LiteralStart) * BytesPerOop;
	}
	/* begin ensureMethodIsCogged:maybeClosure: */
	rawHeader = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((rawHeader) & 7) == 1))
		 || (((((usqInt)rawHeader)) < (startOfMemory()))
		 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))) {
		cogMethod = ((CogMethod *) rawHeader);
		goto l1;
	}
	yetToCompact = 1;
	while (1) {
		if ((maybeClosure != GIV(nilObj))
		 && (!(((((longAt((maybeClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1)))) {
			cogMethod1 = cogFullBlockMethodnumCopied(
				methodObj,
				(				/* begin copiedValueCountOfFullClosure: */
					assert(!((isVanillaBlockClosure(maybeClosure)))),
				((/* begin numSlotsOf: */
	assert((classIndexOf(maybeClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(maybeClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(maybeClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - FullClosureFirstCopiedValueIndex));
		}
		else {
			cogMethod1 = cogselector(methodObj, GIV(nilObj));
		}
		if (!((cogMethod1 == null)
		 && (GIV(cogCompiledCodeCompactionCalledFor)
		 && (yetToCompact)))) break;
		yetToCompact = 0;
		commenceCogCompiledCodeCompaction();
	}
	if (!(asserta(cogMethod1 != null))) {
		error("could not compile method that should have been compiled");
	}
	cogMethod = cogMethod1;
	l1:	/* end ensureMethodIsCogged:maybeClosure: */;
	/* begin bytecodePCFor:cogMethod:startBcpc: */
	assert(theIP < 0);
	if ((((theIP) >> 16)) < -1) {
		/* See contextInstructionPointer:frame: */
		cogMethodForIP = ((CogBlockMethod *) ((((sqInt)cogMethod)) - ((((theIP) >> 16)) * (blockAlignment()))));
		assert(isCMBlock(cogMethodForIP));
		assert((cmHomeMethod(cogMethodForIP)) == cogMethod);
		mcpc = (((sqInt)cogMethodForIP)) - (((short)theIP));
	}
	else {
		cogMethodForIP = ((CogBlockMethod *) cogMethod);
		assert(isCMMethodEtAl(cogMethodForIP));
		/* map any pcs in primitive code (i.e. return addresses for interpreter primitive calls) to the initial pc */
		mcpc = (((sqInt)cogMethod)) - theIP;
		if ((((usqInt)mcpc)) < ((cogMethod->stackCheckOffset))) {
			bcpc = startBcpc;
			goto l2;
		}
	}
	assert(((mcpc >= (((sqInt)cogMethod))) && (mcpc <= ((((sqInt)cogMethod)) + ((cogMethod->blockSize))))));
	bcpc = bytecodePCForstartBcpcin(mcpc, startBcpc, cogMethodForIP);
	l2:	/* end bytecodePCFor:cogMethod:startBcpc: */;
	assert(bcpc >= (startPCOfMethod(methodObj)));
	if ((bcpc == startBcpc)
	 && ((maybeClosure == GIV(nilObj))
	 && (((((cogMethod->methodHeader)) & AlternateHeaderHasPrimFlag) != 0)))) {
		bcpc += 3 /* begin sizeOfCallPrimitiveBytecode: */;
	}
	return (((usqInt)(bcpc + 1) << 3) | 1);
}

	/* CoInterpreter>>#newMethodAddress */
usqInt
newMethodAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(newMethod))));
}


/*	N.B. nextProfileTick is 64-bits */

	/* CoInterpreter>>#nextProfileTickAddress */
usqInt
nextProfileTickAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(nextProfileTick))));
}

	/* CoInterpreter>>#noAssertHeaderOf: */
sqInt
noAssertHeaderOf(sqInt methodPointer)
{
    sqInt methodHeader;

	methodHeader = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	return ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))
		? ((((CogMethod *) methodHeader))->methodHeader)
		: methodHeader);
}


/*	integerValue is interpreted as POSITIVE, e.g. as the result of Bitmap>at:.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* CoInterpreter>>#positive32BitIntegerFor: */
sqInt
positive32BitIntegerFor(unsigned int integerValue)
{
	return ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* CoInterpreter>>#positive32BitValueOf: */
unsigned int
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt value64;

	if ((((oop) & 7) == 1)) {
		value64 = (oop >> 3);
		if ((value64 < 0)
		 || ((((unsigned int) value64)) != value64)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value64 = 0;
		}
		return value64;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Answer a Large Positive Integer object for the given integer value. N.B.
	will *not* cause a GC. */

	/* CoInterpreter>>#positive64BitIntegerFor: */
sqInt
positive64BitIntegerFor(usqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt sz;

	if (integerValue <= (MaxSmallInteger)) {
		return ((integerValue << 3) | 1);
	}
	sz = 8;
	objFormat = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
	numSlots = 8 / BytesPerOop;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassLargePositiveIntegerCompactIndex)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
	l1:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	/* begin storeLong64:ofObject:withValue: */
	long64Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_8_BYTES_IF_BIGENDIAN(integerValue));
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or up to an eight-byte
	LargePositiveInteger. 
 */

	/* CoInterpreter>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fmt;
    usqInt numSlots;
    int ok;
    sqInt smallIntValue;
    sqInt sz;

	if ((((oop) & 7) == 1)) {
		smallIntValue = (oop >> 3);
		if (smallIntValue < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return smallIntValue;
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}


/*	Signal the gc semaphore, and inform the display subsystem if the display
	bitmap has moved.
 */
/*	Attempt to shrink free memory, signal the gc semaphore and let the Cogit
	do its post GC thang
 */

	/* CoInterpreter>>#postGCAction: */
static NoDbgRegParms void
postGCAction(sqInt gcModeArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(gcModeArg == GIV(gcMode));
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	postGCUpdateDisplayBits();
	cogitPostGCAction(gcModeArg);
	/* begin nilUncoggableMethods */
	GIV(lastCoggableInterpretedBlockMethod) = (GIV(lastUncoggableInterpretedBlockMethod) = null);
	GIV(gcMode) = 0;
}


/*	Need to write back the frame pointers unless all pages are free (as in
	snapshot) 
 */
/*	Need to write back the frame pointers unless all pages are free (as in
	snapshot). Need to set gcMode var (to avoid passing the flag through a lot
	of the updating code) */

	/* CoInterpreter>>#preGCAction: */
static NoDbgRegParms void
preGCAction(sqInt gcModeArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodSelectorOrImmediate;
    sqInt i;
    int traceType;

	if (!(GIV(stackPage) == null)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	if (recordPrimTrace()) {
		aMethodSelectorOrImmediate = (gcModeArg == GCModeFull
			? TraceFullGC
			: TraceIncrementalGC);
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = aMethodSelectorOrImmediate;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	if ((gcModeArg == GCModeFull)) {
		/* begin flushMethodCache */
		for (i = 1; i <= MethodCacheSize; i += 1) {
			GIV(methodCache)[i] = 0;
		}
		/* this for primitiveExternalMethod */
		GIV(lastMethodCacheProbeWrite) = 0;
		unlinkAllSends();
	}
	GIV(gcMode) = gcModeArg;
	if (recordEventTrace()) {
		traceType = (gcModeArg == GCModeFull
			? TraceFullGC
			: TraceIncrementalGC);
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = traceType;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = traceType;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = 0;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
}

	/* CoInterpreter>>#primFailCodeAddress */
usqInt
primFailCodeAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(primFailCode))));
}


/*	Return from a become primitive after invoking
	become:with:twoWay:copyHash:. If succeeding and the top frame has been
	divorced then continue in the interpreter.
	See the comment in primitiveArrayBecome. */

	/* CoInterpreter>>#primitiveBecomeReturn: */
static NoDbgRegParms void
primitiveBecomeReturn(sqInt ec)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContextOrNil;
    sqInt activeProc;
    sqInt objOop;

	if (ec == PrimNoErr) {
		/* begin activeProcess */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		activeContextOrNil = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
		if (GIV(framePointer) == 0) {
			/* If the top frame was divorced then continue in the interpreter. */
			assert(isContext(activeContextOrNil));
			/* begin nilStackPage */
			assert((!GIV(stackPage))
			 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
			 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
			GIV(stackPage) = null;
			marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContextOrNil);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(activeProc)));
			longAtput((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), GIV(nilObj));
			/* begin pop: */
			GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
			ceInvokeInterpret();
		}
		if (!(activeContextOrNil == GIV(nilObj))) {
			/* divorcing should not have disturbed the topFrame if it wasn;t divorced */
			assert(isContext(activeContextOrNil));
			assert(GIV(framePointer) == (frameOfMarriedContext(activeContextOrNil)));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(activeProc)));
			longAtput((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), GIV(nilObj));
		}
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

	/* CoInterpreter>>#primitiveExecuteMethod */
static void
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt primitiveIndex;
    sqInt top;

	methodArgument = longAt(GIV(stackPointer));
	if (!(		/* begin isOopCompiledMethod: */
			((!(methodArgument & (tagMask()))))
		 && (((((usqInt)((longAt(methodArgument)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (!((GIV(argumentCount) - 1) == (argumentCountOf(methodArgument)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	primitiveIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) -= 1;
	executeNewMethodJitting();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

	/* CoInterpreter>>#primitiveExecuteMethodArgsArray */
static void
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt firstBytecode;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    usqInt numSlots;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *sp;

	methodArgument = longAt(GIV(stackPointer));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((		/* begin isOopCompiledMethod: */
			((!(methodArgument & (tagMask()))))
		 && (((((usqInt)((longAt(methodArgument)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
		 && (((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat()))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin argumentCountOf: */
	assert(isCompiledMethod(methodArgument));
	header1 = longAt((methodArgument + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	argCnt = (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
	if (!(argCnt == ((		/* begin numSlotsOf: */
			assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	if (GIV(argumentCount) > 2) {
		/* CompiledMethod class>>receiver:withArguments:executeMethod:
		   SqueakObjectPrimitives class>>receiver:withArguments:apply:
		   VMMirror>>ifFail:object:with:executeMethod: et al */
		rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		if ((GIV(argumentCount) > 4)
		 || (		/* begin isOopForwarded: */
			((!(rcvr & (tagMask()))))
		 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return;
		}
		/* begin stackValue:put: */
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	}
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	for (i = 0; i < argCnt; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header2 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header2) & 7) == 1)
		? header2
		: (assert((((usqInt)header2)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header2))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header2))->methodHeader)));
	primitiveIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = argCnt;
	executeNewMethodJitting();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer any special requirements of the given primitive */

	/* CoInterpreter>>#primitivePropertyFlags:numArgs: */
int
primitivePropertyFlagsnumArgs(sqInt primIndex, sqInt numArgs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int baseFlags;


	/* begin primitivePropertyFlagsForSpur:numArgs: */
	baseFlags = (GIV(profileSemaphore) == GIV(nilObj)
		? 0
		: PrimCallCollectsProfileSamples + PrimCallNeedsNewMethod);
#  if LRPCheck
	if (!(GIV(longRunningPrimitiveCheckSemaphore) == null)) {
		baseFlags = baseFlags | PrimCallNeedsNewMethod;
	}
#  endif

	if ((primIndex == PrimNumberVMParameter)
	 && (numArgs == 1)) {
		/* vmParameterAt: */
		return (baseFlags + PrimCallOnSmalltalkStack) + PrimCallOnSmalltalkStackAlign2x;
	}
	return baseFlags | ((primitiveMetadataTable[primIndex]) & SpurPrimitiveFlagsMask);
}

	/* CoInterpreter>>#primTraceLogAddress */
void *
primTraceLogAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primTraceLog);
}


/*	N.B. primTraceLogIndex is 8-bits */

	/* CoInterpreter>>#primTraceLogIndexAddress */
usqInt
primTraceLogIndexAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(primTraceLogIndex))));
}

	/* CoInterpreter>>#printCogMethod: */
void
printCogMethod(CogMethod *cogMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt firstBytecode;
    sqInt primitive;
    sqInt s;

	address = ((sqInt)cogMethod);
	printHex(address);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" <-> ");
	printHex(address + ((cogMethod->blockSize)));
	if (((cogMethod->cmType)) >= CMMethod) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				": method: ");
		printHex((cogMethod->methodObject));
		primitive = 
		/* begin primitiveIndexOfMethod:header: */
(((((cogMethod->methodHeader)) & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (((cogMethod->methodObject)) + ((LiteralStart + (((((cogMethod->methodHeader)) >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
		if (primitive != 0) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" prim ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)primitive));
		}
		if (addressCouldBeObj((cogMethod->methodObject))) {
			if ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" [full]");
			}
			else {
				if (addressCouldBeObj(methodClassOf((cogMethod->methodObject)))) {
					/* begin space */
					printChar(' ');
					printNameOfClasscount(methodClassOf((cogMethod->methodObject)), 2);
				}
			}
		}
	}
	if (((cogMethod->cmType)) == CMBlock) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				": block home: ");
		printHex(((usqInt)(/* begin cmHomeMethod */
	(((((CogBlockMethod *) cogMethod))->cpicHasMNUCaseOrCMIsFullBlock)
	? ((CogMethod *) (((CogBlockMethod *) cogMethod)))
	: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) cogMethod)))) - (((((CogBlockMethod *) cogMethod))->homeOffset))))))));
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				": Closed PIC N: ");
		printHex((cogMethod->cPICNumCases));
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				": Open PIC ");
	}
	fprintf(GIV(transcript),
			"%s",
			" selector: ");
	printHex((cogMethod->selector));
	if (((cogMethod->selector)) == GIV(nilObj)) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (((s = maybeSelectorOfMethod((cogMethod->methodObject)))))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" (nil: ");
			printStringOf(s);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					")");
		}
		else {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" (nil)");
		}
	}
	else {
		/* begin space */
		printChar(' ');
		printStringOf((cogMethod->selector));
	}
	cr();
}

	/* CoInterpreter>>#printFrameFlagsForFP: */
static NoDbgRegParms void
printFrameFlagsForFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *address;
    sqInt it;

	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		address = theFP + FoxMethod;
		it = (longAt(address)) & 7;
	}
	else {
		address = theFP + FoxIFrameFlags;
		it = longAt(address);
	}
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%3sfrm flags: %p",
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? "mc"
		: "int"),
			((void *)it));
	if (it != 0) {
		fprintf(GIV(transcript),
				"=%d",
				((int) it));
	}
	fprintf(GIV(transcript),
			"  numArgs: %d %sContext %sBlock\n",
			((int) (/* begin frameNumArgs: */
	((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
	? ((mframeCogMethod(theFP))->cmNumArgs)
	: byteAt((theFP + FoxIFrameFlags) + 1)))),
			(	/* begin frameHasContext: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)
		? "is"
		: "no"),
			(	/* begin frameIsBlockActivation: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)
		? "is"
		: "not"));
}

	/* CoInterpreter>>#printFrameMethodFor: */
static NoDbgRegParms void
printFrameMethodFor(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *address;
    sqInt it;

	address = theFP + FoxMethod;
	it = longAt(address);
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"      method: %16p\t" /* begin pst: */,
			((void *)it));
	if (((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))
	 && (((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0)) {
		fprintf(GIV(transcript),
				"hm: %p\t",
				((void *)(mframeHomeMethod(theFP))));
	}
	shortPrintOop(	/* begin frameMethodObject: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeHomeMethod(theFP))->methodObject)
		: longAt(theFP + FoxMethod)));
}

	/* CoInterpreter>>#printFrameThing:at:extra: */
static NoDbgRegParms void
printFrameThingatextra(char *name, char *address, sqInt extraValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %16p" /* begin pst: */,
			name,
			((void *)it));
	framePrintDescription(it);
	fprintf(GIV(transcript),
			" %" PRIdSQINT "\n",
			extraValue);
}


/*	useful for VM debugging */

	/* CoInterpreter>>#printFrame:WithSP: */
sqInt
printFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *addr;
    CogBlockMethod *cogMethod;
    sqInt header;
    sqInt header1;
    CogMethod *homeMethod;
    usqInt i;
    usqInt index;
    sqInt methodField;
    usqInt numArgs;
    usqInt numSlots;
    usqInt numTemps;
    char *rcvrAddress;
    sqInt rcvrOrClosure;
    sqInt theMethod;
    sqInt theMethodEnd;
    sqInt topThing;

	if (!(		/* begin couldBeFramePointer: */
			(GIV(stackBasePlus1))
		 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages))))))))) {
		fprintf(GIV(transcript),
				"%p is not in the stack zone?!\n",
				theFP);
		return null;
	}
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		/* begin mframeCogMethod: */
		cogMethod = ((CogBlockMethod *) ((longAt(theFP + FoxMethod)) & MFMethodMask));
		methodField = longAt(theFP + FoxMethod);
		if ((methodField & MFMethodFlagIsBlockFlag) != 0) {
			homeMethod = 
			/* begin cmHomeMethod */
(((((CogBlockMethod *) (methodField & MFMethodMask)))->cpicHasMNUCaseOrCMIsFullBlock)
				? ((CogMethod *) (((CogBlockMethod *) (methodField & MFMethodMask))))
				: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (methodField & MFMethodMask))))) - (((((CogBlockMethod *) (methodField & MFMethodMask)))->homeOffset)))));
			goto l2;
		}
		homeMethod = ((CogMethod *) (methodField & MFMethodMask));
	l2:	/* end mframeHomeMethod: */;
		theMethod = ((sqInt)homeMethod);
		theMethodEnd = (((sqInt)homeMethod)) + ((homeMethod->blockSize));
		numArgs = (cogMethod->cmNumArgs);
		numTemps = (((usqInt)(((homeMethod->methodHeader)))) >> MethodHeaderTempCountShift) & 0x3F;
	}
	else {
		/* begin frameMethodObject: */
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			theMethod = ((mframeHomeMethod(theFP))->methodObject);
		}
		else {
			theMethod = longAt(theFP + FoxMethod);
		}
		theMethodEnd = theMethod + ((((/* begin numSlotsOf: */
	assert((classIndexOf(theMethod)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(theMethod + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(theMethod - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) + BaseHeaderSize);
		numArgs = byteAt((theFP + FoxIFrameFlags) + 1);
		/* begin tempCountOf: */
		assert(isCompiledMethod(theMethod));
		header1 = longAt((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		header = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		numTemps = (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
	}
	if (	/* begin frameIsBlockActivation: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)) {
		/* No BlockLocalTempCounter in the Cogit's C code, so quick hack is to use numCopied + numArgs */
		rcvrOrClosure = longAt(theFP + (frameStackedReceiverOffset(theFP)));
		if (((!(rcvrOrClosure & (tagMask()))))
		 && ((addressCouldBeObj(rcvrOrClosure))
		 && ((fetchClassOfNonImm(rcvrOrClosure)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord()))))))))) {
			numTemps = numArgs + (stSizeOf(rcvrOrClosure));
		}
		else {
			numTemps = numArgs;
		}
	}
	shortPrintFrame(theFP);
	rcvrAddress = theFP + ((FoxCallerSavedIP + BytesPerWord) + (numArgs << (shiftForWord())));
	if ((longAt(theFP + FoxSavedFP)) == 0) {
		/* begin frameRange:to: */
		rcvrAddress + (2 * BytesPerWord);
		printFrameOopat("(caller ctxt", rcvrAddress + (2 * BytesPerWord));
		printFrameOopat("(saved ctxt", rcvrAddress + (1 * BytesPerWord));
	}
	else {
	}
	printFrameOopat("rcvr/clsr", rcvrAddress);
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopindexat("arg", numArgs - i, (theFP + FoxCallerSavedIP) + (i * BytesPerWord));
	}
	printFrameThingatextraString("caller ip", theFP + FoxCallerSavedIP, ((longAt(theFP + FoxCallerSavedIP)) == (ceReturnToInterpreterPC())
		? "ceReturnToInterpreter"
		: 0));
	/* begin printFrameThing:at: */
	printFrameThingatextraString("saved fp", theFP + FoxSavedFP, ((char *)null));
	printFrameMethodFor(theFP);
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		printFrameFlagsForFP(theFP);
	}
	printFrameOopat("context", theFP + FoxThisContext);
	if (!((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory()))) {
		printFrameFlagsForFP(theFP);
	}
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		rcvrAddress = theFP + FoxMFReceiver;
	}
	else {
		printFrameThingatextra("saved ip", theFP + FoxIFSavedIP, ((((usqInt)(longAt(theFP + FoxIFSavedIP)))) == 0
			? 0
			: (((((usqInt)(longAt(theFP + FoxIFSavedIP)))) - theMethod) + 2) - BaseHeaderSize));
		rcvrAddress = theFP + FoxIFReceiver;
	}
	printFrameOopat("receiver", rcvrAddress);
	topThing = longAt(theSP);
	if (oopisGreaterThanOrEqualToandLessThan(topThing, theMethod, theMethodEnd)) {
		for (addr = (rcvrAddress - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			index = ((rcvrAddress - addr) / BytesPerWord) + numArgs;
			if (index <= numTemps) {
				printFrameOopindexat("temp", index - 1, addr);
			}
			else {
				printFrameOopat((				/* begin frameIsBlockActivation: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)
					? "temp/stck"
					: "stck"), addr);
			}
		}
		printFrameThingatextra("frame ip", theSP, ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? topThing - theMethod
			: ((topThing - theMethod) + 2) - BaseHeaderSize));
	}
	else {
		for (addr = (rcvrAddress - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			index = ((rcvrAddress - addr) / BytesPerWord) + numArgs;
			if (index <= numTemps) {
				printFrameOopindexat("temp", index - 1, addr);
			}
			else {
				printFrameOopat((				/* begin frameIsBlockActivation: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)
					? "temp/stck"
					: "stck"), addr);
			}
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* CoInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    sqInt i;
    sqIntptr_t m;
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;

	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || ((m == thing)
		 || ((addressCouldBeObj(m))
		 && ((		/* begin maybeMethodHasCogMethod: */
			((!(m & (tagMask()))))
		 && ((((((usqInt)((longAt(m)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
		 && (isCogMethodReference(longAt((m + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))))))))
		 && ((((sqInt)(cogMethodOf(m)))) == thing))))))))
		 && ((		/* begin addressCouldBeOop: */
			(((s & (tagMask())) != 0))
		 || (addressCouldBeObj(s)))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(classForClassTag(c))))))) {
			n += 1;
			fprintf(GIV(transcript),
					"%" PRIdSQINT " %" PRIxSQINT "\n\t",
					i,
					i);
			if (((((usqInt)((longAt(s)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())) {
				fprintf(GIV(transcript),
						"%p %.*s\n",
						((void *)s),
						((int) (numBytesOfBytes(s))),
						((char *)(firstIndexableField(s))));
			}
			else {
				shortPrintOop(s);
			}
			/* begin tab */
			printChar('\t');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)c));
				printChar(' ');
				fprintf(GIV(transcript),
						"%p",
						((void *)c));
				printChar(' ');
				shortPrintOop(classForClassTag(c));
			}
			/* begin tab */
			printChar('\t');
			shortPrintOop(m);
			/* begin tab */
			printChar('\t');
			if (p > 0x400) {
				/* begin printHexnp: */
				fprintf(GIV(transcript),
						"%p",
						((void *)p));
			}
			else {
				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)p));
			}
			cr();
		}
	}
	if (n > 1) {
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
		cr();
	}
}

	/* CoInterpreter>>#quickPrimitiveConstantFor: */
sqInt
quickPrimitiveConstantFor(sqInt aQuickPrimitiveIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	switch (aQuickPrimitiveIndex) {
	case 0x101:
		return GIV(trueObj);

	case 258:
		return GIV(falseObj);

	case 259:
		return GIV(nilObj);

	case 260:
		return ConstMinusOne;

	case 261:
		return ConstZero;

	case 262:
		return ConstOne;

	case 263:
		return ConstTwo;

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}

	/* CoInterpreter>>#quickPrimitiveGeneratorFor: */
sqInt
(*quickPrimitiveGeneratorFor(sqInt aQuickPrimitiveIndex))(void)
{
	switch (aQuickPrimitiveIndex) {
	case 0x100:
		return genQuickReturnSelf;

	case 0x101:
	case 258:
	case 259:
	case 260:
	case 261:
	case 262:
	case 263:
		return genQuickReturnConst;

	default:
		return genQuickReturnInstVar;
	}
	return 0;
}

	/* CoInterpreter>>#quickPrimitiveInstVarIndexFor: */
sqInt
quickPrimitiveInstVarIndexFor(sqInt primIndex)
{
	return primIndex - 264;
}

	/* CoInterpreter>>#rawHeaderOf: */
sqInt
rawHeaderOf(sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
}


/*	Since methods may be updated while forwarding during become, make the
	assert accomodate this.
 */

	/* CoInterpreter>>#rawHeaderOf:put: */
void
rawHeaderOfput(sqInt methodOop, sqInt cogMethodOrMethodHeader)
{
	assert(isCompiledMethodHeader(headerWhileForwardingOf(methodOop)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(methodOop)));
	longAtput((methodOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))), cogMethodOrMethodHeader);
}


/*	Read an image from the given file stream, allocating an amount of memory
	to its object heap.
	
	V3: desiredHeapSize is the total size of the heap. Fail if the image has
	an unknown format or
	requires more than the specified amount of memory.
	
	Spur: desiredHeapSize is ignored; this routine will attempt to provide at
	least extraVMMemory's
	ammount of free space after the image is loaded, taking any free space in
	the image into account.
	extraVMMemory is stored in the image header and is accessible as
	vmParameterAt: 23. If
	extraVMMemory is 0, the value defaults to the default grow headroom. Fail
	if the image has an
	unknown format or if sufficient memory cannot be allocated.
	
	Details: This method detects when the image was stored on a machine with
	the opposite byte
	ordering from this machine and swaps the bytes automatically. Furthermore,
	it allows the header
	information to start 512 bytes into the file, since some file transfer
	programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix
	area could also be used to store an exec command on Unix systems, allowing
	one to launch
	Smalltalk by invoking the image name as a command. */

	/* CoInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt bit;
    sqInt bytes;
    sqInt bytesRead;
    sqInt bytesToShift;
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt cogCodeBase;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt freeOldSpaceInImage;
    sqInt hdrCogCodeSize;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt headroom;
    sqInt headroom1;
    usqInt heapSize;
    usqInt heapSize1;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    usqInt mem;
    usqInt minimumMemory;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop;
    sqInt oop;
    sqInt rawVersion;
    sqInt seed;
    int swapBytes;
    sqInt version;
    int w;
    sqInt w1;
    sqInt w10;
    sqInt w11;
    sqInt w12;
    sqInt w13;
    sqInt w2;
    sqInt w3;
    sqInt w4;
    int w5;
    unsigned short w6;
    int w7;
    unsigned short w8;
    unsigned short w9;

	rawVersion = 0;
	/* stdout is not available at compile time.  this is the earliest available point. */
	GIV(transcript) = stdout;
	/* guess Metaclass instSize */
	GIV(metaclassNumSlots) = 6;
	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */
	GIV(classNameIndex) = 6;
	version = checkImageVersionFromstartingAtassignRawVersion(f, imageOffset, (&rawVersion));
	if (version == 0) {
		/* begin bailOutOfImageLoad: */
		fprintf(GIV(transcript),
				"%s",
				"This interpreter (vers. ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)68021 /* begin imageFormatVersion */));
		fprintf(GIV(transcript),
				"%s",
				") cannot read image file (vers. ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)rawVersion));
		fprintf(GIV(transcript),
				"%s",
				").");
		cr();
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"Press CR to quit...");
		getchar();
		ioExitWithErrorCode(1);
	}
	swapBytes = rawVersion != version;
	GIV(multipleBytecodeSetsActive) = ((version & MultipleBytecodeSetsBitmask) != 0);
	/* record header start position */
	headerStart = (sqImageFilePosition(f)) - 4;
	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	headerSize = (swapBytes
		? SQ_SWAP_4_BYTES(w)
		: w);
	/* begin getLongFromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(w1), 1, f);
	dataSize = ((sqInt) ((swapBytes
	? SQ_SWAP_8_BYTES(w1)
	: w1)));
	/* begin getLongFromFile:swap: */
	w2 = 0;
	sqImageFileRead((&w2), sizeof(w2), 1, f);
	GIV(oldImageBaseAddress) = (swapBytes
		? SQ_SWAP_8_BYTES(w2)
		: w2);
	/* begin getLongFromFile:swap: */
	w12 = 0;
	sqImageFileRead((&w12), sizeof(w12), 1, f);
	anObject = (swapBytes
		? SQ_SWAP_8_BYTES(w12)
		: w12);
	/* begin specialObjectsOop: */
	GIV(specialObjectsOop) = anObject;
	w13 = 0;
	sqImageFileRead((&w13), sizeof(w13), 1, f);
	seed = (swapBytes
		? SQ_SWAP_8_BYTES(w13)
		: w13);
	/* begin lastHash: */
	GIV(lastHash) = seed;
	w3 = 0;
	sqImageFileRead((&w3), sizeof(w3), 1, f);
	GIV(savedWindowSize) = (swapBytes
		? SQ_SWAP_8_BYTES(w3)
		: w3);
	/* begin getLongFromFile:swap: */
	w4 = 0;
	sqImageFileRead((&w4), sizeof(w4), 1, f);
	headerFlags = (swapBytes
		? SQ_SWAP_8_BYTES(w4)
		: w4);
	/* begin setImageHeaderFlagsFrom: */
	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;
	/* processHasThreadAffinity := headerFlags anyMask: 4. specific to CoInterpreterMT */
	GIV(imageFloatsBigEndian) = ((!(headerFlags & 2))
		? 1
		: 0);
	GIV(flagInterpretedMethods) = ((headerFlags & 8) != 0);
	/* noThreadingOfGUIThread := headerFlags anyMask: 32. specific to CoInterpreterMT */
	GIV(preemptionYields) = (!(headerFlags & 16));
	GIV(newFinalization) = ((headerFlags & 64) != 0);
	sendWheelEvents = ((headerFlags & 128) != 0);
	if (primitiveDoMixedArithmetic < 0) {
		/* i.e. has it not been set on the command line? */
		primitiveDoMixedArithmetic = (!(headerFlags & 0x100));
	}
	if (upscaleDisplayIfHighDPI < 0) {
		/* i.e. has it not been set on the command line? */
		upscaleDisplayIfHighDPI = (!(headerFlags & 0x400));
	}
	/* begin getWord32FromFile:swap: */
	w5 = 0;
	sqImageFileRead((&w5), sizeof(int), 1, f);
	extraVMMemory = (swapBytes
		? SQ_SWAP_4_BYTES(w5)
		: w5);
	/* begin getShortFromFile:swap: */
	w6 = 0;
	sqImageFileRead((&w6), sizeof(unsigned short), 1, f);
	hdrNumStackPages = (swapBytes
		? ((((usqInt)(w6)) >> 8) & 0xFF) | (((sqInt)((usqInt)((w6 & 0xFF)) << 8)))
		: w6);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
				? defaultNumStackPages()
				: hdrNumStackPages));
	/* This slot holds the size of the native method zone in 1k units. (pad to word boundary). */
	desiredNumStackPages = hdrNumStackPages;
	hdrCogCodeSize = (getShortFromFileswap(f, swapBytes)) * 0x400;
	/* set for vmParameter 47 */
	GIV(cogCodeSize) = (desiredCogCodeSize != 0
		? desiredCogCodeSize
		: (hdrCogCodeSize == 0
				? defaultCogCodeSize()
				: (desiredCogCodeSize = hdrCogCodeSize)));
	if (GIV(cogCodeSize) > (maxCogCodeSize())) {
		GIV(cogCodeSize) = maxCogCodeSize();
	}
	/* begin getWord32FromFile:swap: */
	w7 = 0;
	sqImageFileRead((&w7), sizeof(int), 1, f);
	hdrEdenBytes = (swapBytes
		? SQ_SWAP_4_BYTES(w7)
		: w7);
	bytes = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes()
				: hdrEdenBytes));
	/* begin edenBytes: */
	GIV(edenBytes) = bytes;
	desiredEdenBytes = hdrEdenBytes;
	/* begin getShortFromFile:swap: */
	w8 = 0;
	sqImageFileRead((&w8), sizeof(unsigned short), 1, f);
	hdrMaxExtSemTabSize = (swapBytes
		? ((((usqInt)(w8)) >> 8) & 0xFF) | (((sqInt)((usqInt)((w8 & 0xFF)) << 8)))
		: w8);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}
	/* begin getShortFromFile:swap: */
	w9 = 0;
	sqImageFileRead((&w9), sizeof(unsigned short), 1, f);
	GIV(the2ndUnknownShort) = (swapBytes
		? ((((usqInt)(w9)) >> 8) & 0xFF) | (((sqInt)((usqInt)((w9 & 0xFF)) << 8)))
		: w9);
	if (maxLiteralCountForCompile < 0) {
		maxLiteralCountForCompile = (GIV(the2ndUnknownShort) != 0
			? GIV(the2ndUnknownShort)
			: MaxLiteralCountForCompile);
	}
	/* begin getLongFromFile:swap: */
	w10 = 0;
	sqImageFileRead((&w10), sizeof(w10), 1, f);
	firstSegSize = (swapBytes
		? SQ_SWAP_8_BYTES(w10)
		: w10);
	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	allocationReserve = interpreterAllocationReserveBytes();
	/* no need to include the stackZone; this is alloca'ed */
	/* Compute how much space is needed for the initial heap allocation.
	   no need to include the stackZone; this is alloca'ed.
	   no need to include the JIT code zone size; this is allocated separately. */
	minimumMemory = ((GIV(cogCodeSize) + dataSize) + GIV(edenBytes)) + allocationReserve;
	/* begin getLongFromFile:swap: */
	w11 = 0;
	sqImageFileRead((&w11), sizeof(w11), 1, f);
	freeOldSpaceInImage = (swapBytes
		? SQ_SWAP_8_BYTES(w11)
		: w11);
	/* begin initialHeadroom:givenFreeOldSpaceInImage: */
	headroom1 = (extraVMMemory == 0
		? (!(GIV(growHeadroom))
				? 0x1000000
				: GIV(growHeadroom))
		: extraVMMemory);
	if (freeOldSpaceInImage >= headroom1) {
		headroom = 0;
		goto l14;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 7) / 8)) {
		headroom = headroom1 / 8;
		goto l14;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 3) / 4)) {
		headroom = headroom1 / 4;
		goto l14;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 5) / 8)) {
		headroom = (headroom1 * 3) / 8;
		goto l14;
	}
	if (freeOldSpaceInImage >= (headroom1 / 2)) {
		headroom = headroom1 / 2;
		goto l14;
	}
	headroom = headroom1;
	l14:	/* end initialHeadroom:givenFreeOldSpaceInImage: */;
	heapSize1 = ((dataSize + headroom) + GIV(edenBytes)) + ((headroom > allocationReserve
	? 0
	: allocationReserve));
	/* begin roundUpHeapSize: */
	bit = (((highBit(heapSize1)) - 1) * 3) / 4;
	heapSize = (((heapSize1 & ((1ULL << bit) - 1)) != 0)
		? (((heapSize1 | ((1ULL << bit) - 1)) - ((1ULL << bit) - 1))) + (1ULL << bit)
		: heapSize1);
	/* allocate a contiguous block of memory for the Squeak heap and ancilliary data structures */
	cogCodeBase = ((sqInt)(allocateJITMemory((&GIV(cogCodeSize)))));
	mem = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	if (mem == null) {
		insufficientMemoryAvailableError();
	}
	else {
		/* cannot clash with the variable memory still in use in NewCoObjectMemory and superclasses */
		setHeapBasememoryLimitendOfMemory((heapBase = mem), mem + heapSize, mem + dataSize);
	}
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(oldSpaceStart) - GIV(oldImageBaseAddress);
	/* begin initializeInterpreter: */
	interpreterProxy = sqGetInterpreterProxy();
	(&interpreterProxy);
	initializeObjectMemory(bytesToShift);
	/* begin checkAssumedCompactClasses */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord())))))) != ((	/* begin knownClassAtIndex: */
		assert(((ClassArrayCompactIndex >= 1) && (ClassArrayCompactIndex <= (classTablePageSize())))),
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArrayCompactIndex) << (shiftForWord())))))))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))))) != ((	/* begin knownClassAtIndex: */
		assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize())))),
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeIntegerCompactIndex) << (shiftForWord())))))))) {
		invalidCompactClassError("LargeNegativeInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))))) != ((	/* begin knownClassAtIndex: */
		assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize())))),
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveIntegerCompactIndex) << (shiftForWord())))))))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloat) << (shiftForWord())))))) != ((	/* begin knownClassAtIndex: */
		assert(((ClassFloatCompactIndex >= 1) && (ClassFloatCompactIndex <= (classTablePageSize())))),
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloatCompactIndex) << (shiftForWord())))))))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosure) << (shiftForWord())))))) != ((	/* begin knownClassAtIndex: */
		assert(((ClassBlockClosureCompactIndex >= 1) && (ClassBlockClosureCompactIndex <= (classTablePageSize())))),
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBlockClosureCompactIndex) << (shiftForWord())))))))) {
		invalidCompactClassError("BlockClosure");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContext) << (shiftForWord())))))) != ((	/* begin knownClassAtIndex: */
		assert(((ClassMethodContextCompactIndex >= 1) && (ClassMethodContextCompactIndex <= (classTablePageSize())))),
	longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContextCompactIndex) << (shiftForWord())))))))) {
		invalidCompactClassError("MethodContext");
	}
	objOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteArray) << (shiftForWord())))));
	/* begin compactIndexOfClass: */
	assert((rawHashBitsOf(objOop)) != 0);
	GIV(classByteArrayCompactIndex) = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	/* begin initializeExtraClassInstVarIndices */
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord())))));
	classArrayClass = fetchClassOfNonImm(classArrayObj);
	/* begin numSlotsOf: */
	assert((classIndexOf(classArrayClass)) > (isForwardedObjectClassIndexPun()));
	/* determine actual Metaclass instSize */
	GIV(metaclassNumSlots) = (((numSlots = byteAt(classArrayClass + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classArrayClass - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	/* default */
	GIV(thisClassIndex) = 5;
	for (i2 = (InstanceSpecificationIndex + 1), iLimiT = ((/* begin numSlotsOf: */
	assert((classIndexOf(classArrayClass)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(classArrayClass + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classArrayClass - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))); i2 <= iLimiT; i2 += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + (((sqInt)((usqInt)((i2 - 1)) << (shiftForWord())))))) == classArrayObj) {
			GIV(thisClassIndex) = i2 - 1;
		}
	}
	/* default */
	GIV(classNameIndex) = 6;
	for (i2 = (InstanceSpecificationIndex + 1), iLimiT = ((/* begin numSlotsOf: */
	assert((classIndexOf(classArrayObj)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(classArrayObj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classArrayObj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))); i2 <= iLimiT; i2 += 1) {
		oop = longAt((classArrayObj + BaseHeaderSize) + (((sqInt)((usqInt)((i2 - 1)) << (shiftForWord())))));
		if (objectequalsString(oop, "Array")) {
			GIV(classNameIndex) = i2 - 1;
		}
	}
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	/* begin initialCleanup */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
	/* begin flushExternalPrimitiveTable */
	for (i1 = 0; i1 < MaxExternalPrimitiveTableSize; i1 += 1) {
		externalPrimitiveTable[i1] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));
	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = ((time(NULL)) + (ioMSecs())) & 0x7FFFFFFF;
	}
	GIV(metaAccessorDepth) = -2;
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin");
	initializeCodeZoneFromupTo(cogCodeBase, cogCodeBase + GIV(cogCodeSize));
	return dataSize;
}


/*	This is a little elaborate. The primTraceLog is only useful if it is not
	full of noise.
	To reduce noise when debugging a specific plugin we allow a plugin name to
	be specified and will only generate the primTraceLog code for primitives
	in that plugin. */

	/* CoInterpreter>>#recordFastCCallPrimTraceForMethod: */
sqInt
recordFastCCallPrimTraceForMethod(sqInt aMethodObj)
{
	return (recordFastCCallPrimTrace())
	 && ((primTracePluginName == null
		? 1
		: methodHasPrimitiveInPrimTracePlugin(aMethodObj)));
}


/*	This is a little elaborate. The primTraceLog is only useful if it is not
	full of noise.
	To reduce noise when debugging a specific plugin we allow a plugin name to
	be specified and will only generate the primTraceLog code for primitives
	in that plugin. */

	/* CoInterpreter>>#recordPrimTraceForMethod: */
sqInt
recordPrimTraceForMethod(sqInt aMethodObj)
{
	return (recordPrimTrace())
	 && ((primTracePluginName == null
		? 1
		: methodHasPrimitiveInPrimTracePlugin(aMethodObj)));
}


/*	noop in the StackInterpreter */

	/* CoInterpreter>>#reloadPrimitiveCalloutPointer */
static NeverInline void
reloadPrimitiveCalloutPointer(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *moduleName;

	primitiveCalloutPointer = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	GIV(primCalloutIsExternal) = 1;
	index = 1;
	do {
		moduleName = ioListBuiltinModule(index);
		if (moduleName == null) {
			return;
		}
		else {
			if ((strcmp(moduleName, "SqueakFFIPrims")) == 0) {
				GIV(primCalloutIsExternal) = 0;
			}
		}
		index += 1;
	} while(1);
}


/*	Report the stack page size and minimum unused headroom to stdout. */

	/* CoInterpreter>>#reportMinimumUnusedHeadroom */
void
reportMinimumUnusedHeadroom(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"stack page bytes %" PRIdSQINT " available headroom %" PRIdSQINT " minimum unused headroom %" PRIdSQINT "\n",
			stackPageByteSize(),
			((stackPageByteSize()) - ((((stackPageFrameBytes()) < (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom()))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom()))))) - ((IFrameSlots + 64) * BytesPerWord),
			minimumUnusedHeadroom());
}


/*	Report the stack page size and minimum unused headroom to a stream. */

	/* CoInterpreter>>#reportMinimumUnusedHeadroomOn: */
void
reportMinimumUnusedHeadroomOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;


	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream == null
		? stdout
		: aStdioStream);
	/* begin reportMinimumUnusedHeadroom */
	fprintf(GIV(transcript),
			"stack page bytes %" PRIdSQINT " available headroom %" PRIdSQINT " minimum unused headroom %" PRIdSQINT "\n",
			stackPageByteSize(),
			((stackPageByteSize()) - ((((stackPageFrameBytes()) < (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom()))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom()))))) - ((IFrameSlots + 64) * BytesPerWord),
			minimumUnusedHeadroom());
	GIV(transcript) = savedTranscript;
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yeild to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect.
	Override to add tracing info. */

	/* CoInterpreter>>#resume:preemptedYieldingIf:from: */
static NoDbgRegParms sqInt
resumepreemptedYieldingIffrom(sqInt aProcess, sqInt yieldImplicitly, sqInt sourceCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;


	/* begin activeProcess */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	activePriority = (oop >> 3);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((((oop1) & 7) == 1));
	newPriority = (oop1 >> 3);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly);
	transferTofrom(aProcess, sourceCode);
	return 1;
}


/*	Return to the current frame, either by entering machine code, or
	longjmp-ing back to the
	interpreter or simply returning, depending on where we are. To know
	whether to return or
	enter machine code we have to know from whence we came. We could have come
	from the interpreter, either directly or via a machine code primitive. We
	could have come from
	machine code. The instructionPointer tells us where from. If it is above
	startOfMemory we're
	in the interpreter. If it is below, then we are in machine-code unless it
	is ceReturnToInterpreterPC,
	in which case we're in a machine-code primitive called from the
	interpreter.  */

	/* CoInterpreter>>#returnToExecutive:postContextSwitch: */
static NoDbgRegParms sqInt
returnToExecutivepostContextSwitch(sqInt inInterpreter, sqInt switchedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    CogBlockMethod *cogMethod;
    sqInt fullyInInterpreter;
    sqInt retValue;
    char *sp;
    char *sp1;
    sqInt top;

	assertCStackWellAligned();
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
		if (switchedContext) {
			/* begin mframeCogMethod: */
			cogMethod = ((CogBlockMethod *) ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodMask));
			assert((GIV(instructionPointer) > (minCogMethodAddress()))
			 && (GIV(instructionPointer) < (maxCogMethodAddress())));
			if ((GIV(instructionPointer) != ((((sqInt)cogMethod)) + ((cogMethod->stackCheckOffset))))
			 && (isSendReturnPC(GIV(instructionPointer)))) {
				assert(addressCouldBeOop(stackTop()));
				/* begin popStack */
				top = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				retValue = top;
			}
			else {
				retValue = longAt(GIV(framePointer) + FoxMFReceiver);
			}
		}
		else {
			retValue = longAt(GIV(framePointer) + FoxMFReceiver);
		}
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), retValue);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	/* begin setMethod: */
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	fullyInInterpreter = inInterpreter;
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		fullyInInterpreter = 0;
	}
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1, __LINE__);
	if (!fullyInInterpreter) {
		ceInvokeInterpret();
	}
	return null;
}


/*	We have made a context switch, either when interpreting or from machine
	code. Effectively return to the current frame, either by entering machine
	code, or
	longjmp-ing back to the interpreter or simply returning, depending on
	where we are. */

	/* CoInterpreter>>#return:toExecutive: */
static NoDbgRegParms sqInt
returntoExecutive(sqInt returnValue, sqInt inInterpreter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    char *sp;
    char *sp1;
    char *sp2;

	assertCStackWellAligned();
	if ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())) {
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 0, __LINE__);
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), returnValue);
		GIV(stackPointer) = sp1;
		ceEnterCogCodePopReceiverReg();
	}
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), returnValue);
	GIV(stackPointer) = sp2;
	aMethodObj = longAt(GIV(framePointer) + FoxMethod);
	/* begin setMethod: */
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1, __LINE__);
	if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
		GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
	}
	if (inInterpreter) {
		return null;
	}
	ceInvokeInterpret();
	return null;
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the 1 arg
	invokeCallbackContext: or the 4 arg invokeCallback:stack:registers:jmpbuf:
	message, depending on what selector is installed in the
	specialObjectsArray. Note that if invoking the
	legacy invokeCallback:stack:registers:jmpbuf: we pass the
	vmCallbackContext as the jmpbuf
	argument (see reestablishContextPriorToCallback:). The arguments are raw C
	addresses and
	are converted to integer objects on the way. sendInvokeCallbackContext: &
	returnAs:ThroughCallback:Context: along with ownVM: and disownVM: conspire
	to save and
	restore newMethod, argumentCount and primitiveFunctionPointer around a
	callback. The VM depends on argumentCount being correct to cut-back the
	correct number of
	arguments on primitive return. Since this is an implicit send we need to
	log it explicitly.
	The return side is done via a primitive so that gets logged normally. */
/*	Override check stack alignment.  */

	/* CoInterpreter>>#sendInvokeCallbackContext: */
sqInt
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt i;
    usqInt initialIP;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;

	classTag = 0;
	assertCStackWellAligned();
	if (recordPrimTrace()) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorInvokeCallback) << (shiftForWord()))))));
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	/* begin classIndexOf: */
	(longAt(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord()))))))) & (classIndexMask());
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorInvokeCallback) << (shiftForWord())))));
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupOrdinaryNoMNUEtcInClass(classForClassTag(classTag))) != 0) {
			return 0;
		}
	}
	assert(((debugCallbackInvokes += 1)) > 0);
	/* begin saveCStackStateForCallbackContext: */
	(vmCallbackContext->savedCStackPointer = ((void *)GIV(CStackPointer)));
	(vmCallbackContext->savedCFramePointer = ((void *)GIV(CFramePointer)));
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
	if ((argumentCountOf(GIV(newMethod))) == 4) {
		object = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp1;
		object1 = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		object2 = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp3;
	}
	object3 = positiveMachineIntegerFor(((usqInt)vmCallbackContext));
	/* begin push: */
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp4;
	/* begin ifAppropriateCompileToNativeCode:selector: */
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* makeBaseFrame: can create cog methods with nil selectors. */
		cogMethod = ((CogMethod *) methodHeader);
		if (((cogMethod->selector)) == GIV(nilObj)) {
			setSelectorOfto(cogMethod, GIV(messageSelector));
		}
	}
	else {
		if (((		/* begin literalCountOfMethodHeader: */
			assert((((methodHeader) & 7) == 1)),
		((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
			cogselector(GIV(newMethod), GIV(messageSelector));
		}
		else {
			maybeFlagMethodAsInterpreted(GIV(newMethod));
		}
	}
	/* begin justActivateNewMethod: */
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	cogMethod1 = null;
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader1) & 7) == 1))
		 || (((((usqInt)methodHeader1)) < (startOfMemory()))
		 && ((((usqInt)methodHeader1)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader1 & (smallIntegerTag()))))) {
		cogMethod1 = ((CogMethod *) methodHeader1);
		methodHeader1 = (cogMethod1->methodHeader);
	}
	numTemps = (((usqInt)(methodHeader1)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader1)) >> MethodHeaderArgCountShift) & 15;
	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	if ((cogMethod1)
	 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())))) {
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
		}
		GIV(instructionPointer) = ceReturnToInterpreterPC();
	}
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp10;
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp11;
	GIV(framePointer) = GIV(stackPointer);
	initialIP = (GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader1) & 7) == 1)),
((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize;
	if (cogMethod1 == null) {
		/* begin push: */
		longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp21;
		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method)));
		assert((methodHeaderOf(GIV(method))) == methodHeader1);
		GIV(bytecodeSetSelector) = ((((sqLong) methodHeader1)) < 0
			? 0x100
			: 0);
		/* begin push: */
		longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp31;
		object4 = 
		/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
			? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
			: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
		/* begin push: */
		longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object4);
		GIV(stackPointer) = sp41;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), 0);
		GIV(stackPointer) = sp5;
		GIV(instructionPointer) = initialIP - 1;
	}
	else {
		/* begin push: */
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), ((usqInt)cogMethod1));
		GIV(stackPointer) = sp6;
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
		GIV(instructionPointer) = (((usqInt)cogMethod1)) + ((cogMethod1->stackCheckOffset));
	}
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp8;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp9 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp9;
	}
	if (((methodHeader1 & AlternateHeaderHasPrimFlag) != 0)) {
		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		if (!cogMethod1) {
			GIV(instructionPointer) += 3 /* begin sizeOfCallPrimitiveBytecode: */;
		}
		if (GIV(primFailCode) != 0) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader1);
		}
	}
	if (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))) {
		maybeFlagMethodAsInterpreted(GIV(newMethod));
	}
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	assert((frameReceiver(GIV(framePointer))) == (splObj(ClassAlien)));
	/* begin enterSmalltalkExecutiveFromCallback */
	enterSmalltalkExecutive();
	return 1;
}

	/* CoInterpreter>>#shortPrintFrame: */
static NoDbgRegParms sqInt
shortPrintFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt mthd;
    sqInt rcvr;

	if (!(		/* begin couldBeFramePointer: */
			(GIV(stackBasePlus1))
		 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages))))))))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"invalid frame pointer");
		cr();
		return null;
	}
	rcvr = 
	/* begin frameReceiver: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? longAt(theFP + FoxMFReceiver)
		: longAt(theFP + FoxIFReceiver));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		mthd = ((mframeHomeMethod(theFP))->methodObject);
	}
	else {
		mthd = longAt(theFP + FoxMethod);
	}
	printHexPtrnp(theFP);
	/* begin space */
	printChar(' ');
	printChar(((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? 'M'
		: 'I'));
	/* begin space */
	printChar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(mthd, rcvr, 
	/* begin frameIsBlockActivation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0), ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? (0 < ((frameNumArgs = ((mframeCogMethod(theFP))->cmNumArgs)))
				? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
				: longAt(((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)))
		: 
			/* begin itemporary:in: */
(0 < ((frameNumArgs1 = byteAt((theFP + FoxIFrameFlags) + 1)))
				? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs1) * BytesPerWord))
				: longAt(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1) * BytesPerWord)))));
	printChar(' ');
	shortPrintOop(rcvr);
	return 0;
}


/*	Answer a full 32 bit integer object for the given integer value.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* CoInterpreter>>#signed32BitIntegerFor: */
sqInt
signed32BitIntegerFor(sqInt integerValue)
{
	return (((usqInt)(((int) integerValue)) << 3) | 1);
}


/*	Convert the given object into an integer value.
	The object may be either a SmallInteger or a four-byte LargeInteger. */

	/* CoInterpreter>>#signed32BitValueOf: */
int
signed32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt value64;

	if ((((oop) & 7) == 1)) {
		value64 = (oop >> 3);
		if ((((int) value64)) != value64) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value64 = 0;
		}
		return value64;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Answer a Large Integer object for the given integer value. N.B. will *not*
	cause a GC. */

	/* CoInterpreter>>#signed64BitIntegerFor: */
sqInt
signed64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt largeClass;
    usqLong magnitude;
    usqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt sz;

	if (integerValue < 0) {
		if (integerValue >= (MinSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 3) | 1);
		}
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = 0 - (((usqLong) integerValue));
	}
	else {
		if (integerValue <= (MaxSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 3) | 1);
		}
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	sz = 8;
	objFormat = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
	numSlots = (sz + 3) / BytesPerOop;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((largeClass != 0)
	 && ((knownClassAtIndex(largeClass)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(largeClass))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + largeClass);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
	l1:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	/* begin storeLong64:ofObject:withValue: */
	long64Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude));
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

	/* CoInterpreter>>#signed64BitValueOf: */
sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    usqLong magnitude;
    sqInt negative;
    usqInt numSlots;
    int ok;
    sqInt sz;

	if ((((oop) & 7) == 1)) {
		return ((sqLong) ((oop >> 3)));
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex1 = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (sz > 4) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
		if ((sz > (sizeof(sqLong)))
		 || ((negative
			? magnitude > 0x8000000000000000ULL
			: magnitude >= 0x8000000000000000ULL))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	else {
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	}
	return (negative
		? 0 - magnitude
		: magnitude);
}


/*	<SmallInteger> */

	/* CoInterpreter>>#specialSelectorNumArgs: */
sqInt
specialSelectorNumArgs(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((fetchPointerofObject((index * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 3);
}

	/* CoInterpreter>>#stackLimitAddress */
usqInt
stackLimitAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(stackLimit))));
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	context (uninitialized?)
	method header fields (interpreter only)
	saved method ip (uninitialized?; interpreter only)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

	/* CoInterpreter>>#stackLimitOffset */
static sqInt
stackLimitOffset(void)
{
	return (IFrameSlots + 64) * BytesPerWord;
}


/*	Return a minimum amount of headroom for each stack page (in bytes).
	In the interpreter we don't actually need any headroom. In a JIT the stack
	has to have room for interrupt handlers which will run on the stack.
	Defer to the platform for this one. */

	/* CoInterpreter>>#stackPageHeadroom */
static sqInt
stackPageHeadroom(void)
{
	return osCogStackPageHeadroom();
}

	/* CoInterpreter>>#stackPointerAddress */
usqInt
stackPointerAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(stackPointer))));
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* CoInterpreter>>#startPCOfMethodHeader: */
sqInt
startPCOfMethodHeader(sqInt aCompiledMethodHeader)
{
	return (((/* begin literalCountOfMethodHeader: */
	assert((((aCompiledMethodHeader) & 7) == 1)),
((aCompiledMethodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
}


/*	Answer the startPC of lit if it is a (clean) block in aMethodObj,
	otherwise answer nil.
 */

	/* CoInterpreter>>#startPCOrNilOfLiteral:in: */
sqInt
startPCOrNilOfLiteralin(sqInt lit, sqInt aMethodObj)
{
    usqInt numSlots;
    sqInt oop;
    sqInt outerContext;

	if (!(((!(lit & (tagMask()))))
		 && ((((((usqInt)((longAt(lit)))) >> (formatShift())) & (formatMask())) == (indexablePointersFormat()))
		 && (((		/* begin numSlotsOf: */
			assert((classIndexOf(lit)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(lit + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(lit - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) >= ClosureFirstCopiedValueIndex)))) {
		return null;
	}
	outerContext = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(		/* begin isContext: */
			((!(outerContext & (tagMask()))))
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return null;
	}
	if (aMethodObj != (longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord()))))))) {
		return null;
	}
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	return (oop >> 3);
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted.
	Override to add tracing info. */

	/* CoInterpreter>>#synchronousSignal: */
static NoDbgRegParms sqInt
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt excessSignals;
    sqInt proc;
    sqInt referent;

	if ((	/* begin isEmptyList: */
		assert(!(isForwarded(aSemaphore))),
	(longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* no process is waiting on this semaphore */
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt)((excessSignals + 1))) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(aSemaphore)));
			longAtput((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(ExcessSignalsIndex) << (shiftForWord())))), (((usqInt)(excessSignals + 1) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		return 0;
	}
	/* begin ensureSemaphoreUnforwardedThroughContext: */
	proc = longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	if ((!((longAt(proc)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		followForwardedObjectFieldstoDepth(aSemaphore, 1);
		proc = longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	}
	assert(!((isForwarded(proc))));
	ctxt = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if ((!((longAt(ctxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(ctxt));
		referent = longAt((ctxt + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		ctxt = referent;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(proc)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(proc)),
		oopisGreaterThanOrEqualTo(proc, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(ctxt & (tagMask()))))
			 && (oopisLessThan(ctxt, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(proc)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(proc);
				}
			}
		}
		longAtput((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), ctxt);
	}
	return resumepreemptedYieldingIffrom(removeFirstLinkOfList(aSemaphore), GIV(preemptionYields), CSSignal);
}


/*	Handle the cannot return response for a base frame return to an invalid
	context. Build a new base frame for the context in the cannot resume state
	ready for the
	send of cannotReturn:.
	
	Since we have returned from the base frame of the page the context is
	effectively widowed.
	But its sender needs to be contextToReturnTo, and its pc needs to be the
	HasBeenReturnedFromMCPC marker. So bereave it (as a side-effect of
	isWidowedContext:), assign contextToReturnTo to
	sender, and rebuild its frame, which will have the ceCannotResumePC as its
	pc. Finally push
	returnValue and set instructionPointer to ceCannotResumePC in preparation
	for the send. */

	/* CoInterpreter>>#tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFrom:to:returnValue: */
static NoDbgRegParms void
tearDownAndRebuildFrameForCannotReturnBaseFrameReturnFromtoreturnValue(sqInt contextToReturnFrom, sqInt contextToReturnTo, sqInt returnValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *newPage;

	assert((GIV(stackPage))
	 && (isFree(GIV(stackPage))));
	isWidowedContext(contextToReturnFrom);
	assert(!(isMarriedOrWidowedContext(contextToReturnFrom)));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(contextToReturnFrom)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(contextToReturnFrom)),
	oopisGreaterThanOrEqualTo(contextToReturnFrom, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(contextToReturnTo & (tagMask()))))
		 && (oopisLessThan(contextToReturnTo, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(contextToReturnFrom)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(contextToReturnFrom);
			}
		}
	}
	longAtput((contextToReturnFrom + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), contextToReturnTo);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(contextToReturnFrom)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(contextToReturnFrom)),
	oopisGreaterThanOrEqualTo(contextToReturnFrom, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(HasBeenReturnedFromMCPCOop & (tagMask()))))
		 && (oopisLessThan(HasBeenReturnedFromMCPCOop, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(contextToReturnFrom)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(contextToReturnFrom);
			}
		}
	}
	longAtput((contextToReturnFrom + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), HasBeenReturnedFromMCPCOop);
	GIV(instructionPointer) = 0;
	newPage = makeBaseFrameFor(contextToReturnFrom);
	assert(GIV(stackPage) == newPage);
	/* begin setStackPageAndLimit: */
	assert(newPage);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	assert((stackTop()) == (ceCannotResumePC()));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), returnValue);
	GIV(instructionPointer) = ceCannotResumePC();
}


/*	See StackInterpreter class>>initializeFrameIndices */

	/* CoInterpreter>>#temporary:in: */
static NoDbgRegParms sqInt
temporaryin(sqInt offset, char *theFP)
{
    sqInt frameNumArgs;
    sqInt frameNumArgs1;

	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? (offset < ((frameNumArgs = ((mframeCogMethod(theFP))->cmNumArgs)))
				? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord))
				: longAt(((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord)))
		: 
			/* begin itemporary:in: */
(offset < ((frameNumArgs1 = byteAt((theFP + FoxIFrameFlags) + 1)))
				? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs1 - offset) * BytesPerWord))
				: longAt(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - offset) * BytesPerWord))));
}

	/* CoInterpreter>>#temporary:in:put: */
static NoDbgRegParms sqInt
temporaryinput(sqInt offset, char *theFP, sqInt valueOop)
{
    sqInt frameNumArgs;
    sqInt frameNumArgs1;

	return ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? longAtput((offset < ((frameNumArgs1 = ((mframeCogMethod(theFP))->cmNumArgs)))
				? (theFP + FoxCallerSavedIP) + ((frameNumArgs1 - offset) * BytesPerWord)
				: ((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs1 - offset) * BytesPerWord)), valueOop)
		: 
			/* begin itemporary:in:put: */
(offset < ((frameNumArgs = byteAt((theFP + FoxIFrameFlags) + 1)))
				? longAtput((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord), valueOop)
				: longAtput(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord), valueOop)));
}


/*	Record a process to be awoken on the next interpreter cycle.
	Reimplement to record the source of the switch for debugging,
	and to cope with possible code compaction in makeBaseFrameFor:. */

	/* CoInterpreter>>#transferTo:from: */
static NoDbgRegParms void
transferTofrom(sqInt newProc, sqInt sourceCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt aMethodObj;
    StackPage *lastUsedPage;
    StackPage *lruOrFree;
    sqInt newContext;
    StackPage *newPage;
    sqInt oldProc;
    sqInt sched;
    sqInt senderOop;
    char *sp;
    char *theFrame;
    StackPage *thePage;
    sqInt top;

	GIV(statProcessSwitch) += 1;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
	GIV(instructionPointer) = 0;
	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	oldProc = longAt((sched + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin recordContextSwitchFrom:in: */
	if ((recordEventTrace())
	 && (!primTracePluginName)) {
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceContextSwitch;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = oldProc;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = sourceCode;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
	l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(oldProc)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(oldProc)),
	oopisGreaterThanOrEqualTo(oldProc, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(activeContext & (tagMask()))))
		 && (oopisLessThan(activeContext, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(oldProc)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(oldProc);
			}
		}
	}
	longAtput((oldProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(sched)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(sched)),
	oopisGreaterThanOrEqualTo(sched, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(newProc & (tagMask()))))
		 && (oopisLessThan(newProc, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(sched)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(sched);
			}
		}
	}
	longAtput((sched + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))), newProc);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(newProc)));
	longAtput((newProc + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))), GIV(nilObj));
	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	newContext = longAt((newProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	assert(isContext(newContext));
	if (((((longAt((newContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer)));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(newProc)));
	longAtput((newProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), GIV(nilObj));
	if (	/* begin isStillMarriedContext: */
		(((((longAt((newContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(newContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((newContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFrame = pointerForOop(senderOop - (smallIntegerTag()));
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		if (theFrame != ((thePage->headFP))) {
			/* explicit assignment of suspendedContext can cause switch to interior frame. */
			/* begin newStackPage */
			lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
			if (((lruOrFree->baseFP)) == 0) {
				newPage = lruOrFree;
				goto l6;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
	l6:	/* end newStackPage */;
			moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFrame, thePage), newPage);
			/* begin markStackPageLeastMostRecentlyUsed: */
			assert(newPage == ((GIV(mostRecentlyUsedPage)->nextPage)));
			lastUsedPage = (newPage->nextPage);
			while (((lastUsedPage->baseFP)) == 0) {
				lastUsedPage = (lastUsedPage->nextPage);
			}
			if (((lastUsedPage->nextPage)) == newPage) {
				goto l4;
			}
			(((newPage->prevPage))->nextPage = (newPage->nextPage));
			(((newPage->nextPage))->prevPage = (newPage->prevPage));
			(((lastUsedPage->prevPage))->nextPage = newPage);
			(newPage->prevPage = (lastUsedPage->prevPage));
			(newPage->nextPage = lastUsedPage);
			(lastUsedPage->prevPage = newPage);
			assert(pageListIsWellFormed());
	l4:	/* end markStackPageLeastMostRecentlyUsed: */;
		}
		assert(((thePage->headFP)) == theFrame);
	}
	else {
		thePage = makeBaseFrameFor(newContext);
		theFrame = (thePage->baseFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	if (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))) {
		aMethodObj = longAt(GIV(framePointer) + FoxMethod);
		/* begin setMethod: */
		assert((((usqInt)aMethodObj)) >= (startOfMemory()));
		GIV(method) = aMethodObj;
		assert(isOopCompiledMethod(GIV(method)));
		GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
			? 0x100
			: 0);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
}


/*	Go through all frames in the stack zone and mark their methods
	so that compaction does not free any methods that are in use. */
/*	If instructionPointer is referring to machine code, as it will be if a
	primitive is in progress
	(see isCodeCompactingPrimitiveIndex:) it must be updated if it is
	referring to a moved
	method. */

	/* CoInterpreter>>#updateStackZoneReferencesToCompiledCodePreCompaction */
void
updateStackZoneReferencesToCompiledCodePreCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    CogMethod *primCogMethod;
    sqInt theFlags;
    char *theFP;
    usqInt theIP;
    char *theIPPtr;
    CogMethod *theMethod;
    sqInt theMethodField;
    StackPage *thePage;

	if (GIV(instructionPointer) != 0) {
		primCogMethod = cogMethodContaining(GIV(instructionPointer));
		if (!(primCogMethod == null)) {
			GIV(instructionPointer) += (primCogMethod->objectHeader);
		}
	}
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			/* begin updateStackZoneReferencesToCompiledCodePreCompactionOnPage: */
			theIPPtr = (thePage->headSP);
			theFP = (thePage->headFP);
			while (1) {
				if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
					theMethodField = longAt(theFP + FoxMethod);
					theFlags = theMethodField & MFMethodFlagsMask;
					theMethod = ((CogMethod *) (theMethodField - theFlags));
					if (((theMethod->cmType)) == CMBlock) {
						theMethod = 
						/* begin cmHomeMethod */
(((((CogBlockMethod *) (theMethodField - theFlags)))->cpicHasMNUCaseOrCMIsFullBlock)
							? ((CogMethod *) (((CogBlockMethod *) (theMethodField - theFlags))))
							: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) (theMethodField - theFlags))))) - (((((CogBlockMethod *) (theMethodField - theFlags)))->homeOffset)))));
					}
					theIP = ((usqInt)(longAt(theIPPtr)));
					if ((theIP != (ceCannotResumePC()))
					 && (asserta((theIP >= (((usqInt)theMethod)))
					 && (theIP < ((((usqInt)theMethod)) + ((theMethod->blockSize))))))) {
						longAtput(theIPPtr, theIP + ((theMethod->objectHeader)));
					}
					longAtput(theFP + FoxMethod, theMethodField + ((theMethod->objectHeader)));
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theIPPtr = theFP + FoxCallerSavedIP;
				theFP = callerFP;
			}
		}
	}
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

	/* CoInterpreter>>#updateStateOfSpouseContextForFrame:WithSP: */
static NoDbgRegParms void
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *argsPointer;
    sqInt i;
    char *pointer;
    sqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP));
	theContext = longAt(theFP + FoxThisContext);
	assert(isContext(theContext));
	assert((frameReceiver(theFP)) == (noFixupFollowFieldofObject(ReceiverIndex, theContext)));
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		tempIndex = ((mframeCogMethod(theFP))->cmNumArgs);
		pointer = (theFP + FoxMFReceiver) - BytesPerWord;
	}
	else {
		tempIndex = byteAt((theFP + FoxIFrameFlags) + 1);
		pointer = (theFP + FoxIFReceiver) - BytesPerWord;
	}
	argsPointer = theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(tempIndex) << (shiftForWord())))));
	for (i = 1; i <= tempIndex; i += 1) {
		argsPointer -= BytesPerWord;
		assert(addressCouldBeOop(longAt(argsPointer)));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(theContext)),
		oopisGreaterThanOrEqualTo(theContext, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!((longAt(argsPointer)) & (tagMask()))))
			 && (oopisLessThan(longAt(argsPointer), GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(theContext)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(theContext);
				}
			}
		}
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), longAt(argsPointer));
	}
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer)));
		tempIndex += 1;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(theContext)),
		oopisGreaterThanOrEqualTo(theContext, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!((longAt(pointer)) & (tagMask()))))
			 && (oopisLessThan(longAt(pointer), GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(theContext)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(theContext);
				}
			}
		}
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + tempIndex)) << (shiftForWord())))), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)tempIndex << 3) | 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */
/*	-1 for pre-increment in fetchNextBytecode */

	/* CoInterpreter>>#validInstructionPointer:inMethod:framePointer: */
sqInt
validInstructionPointerinMethodframePointer(usqInt instrPointer, usqInt aMethod, char *fp)
{
    CogMethod *cogMethod;
    sqInt header;
    usqInt theInstrPointer;

	if (instrPointer == (ceCannotResumePC())) {
		return (((usqInt)(longAt(fp + FoxMethod)))) < (startOfMemory());
	}
	if (instrPointer == (ceReturnToInterpreterPC())) {
		if ((((usqInt)(longAt(fp + FoxMethod)))) < (startOfMemory())) {
			return 0;
		}
		theInstrPointer = ((usqInt)(longAt(fp + FoxIFSavedIP)));
	}
	else {
		theInstrPointer = instrPointer;
		header = longAt((aMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if (((		/* begin isCogMethodReference: */
			assert(((((header) & 7) == 1))
			 || (((((usqInt)header)) < (startOfMemory()))
			 && ((((usqInt)header)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(header & (smallIntegerTag())))))
		 && (theInstrPointer < (startOfMemory()))) {
			cogMethod = ((CogMethod *) header);
			return (theInstrPointer >= (header + (sizeof(CogMethod))))
			 && (theInstrPointer < (header + ((cogMethod->blockSize))));
		}
	}
	return (theInstrPointer >= (((aMethod + (lastPointerOf(aMethod))) + BytesPerOop) - 1))
	 && (theInstrPointer < (((aMethod + (numBytesOfBytes(aMethod))) + BaseHeaderSize) - 1));
}


/*	Check that the base frame in the stack page has a valid sender and saved
	context. 
 */

	/* CoInterpreter>>#validStackPageBaseFrame: */
static NoDbgRegParms sqInt
validStackPageBaseFrame(StackPage *aPage)
{
    sqInt savedThisContext;
    sqInt senderContextOrNil;

	senderContextOrNil = longAt((aPage->baseAddress));
	savedThisContext = longAt(((aPage->baseAddress)) - BytesPerWord);
	if (!(asserta(((((aPage->baseFP)) + (frameStackedReceiverOffset((aPage->baseFP)))) + (2 * BytesPerWord)) == ((aPage->baseAddress))))) {
		return 0;
	}
	if (!(asserta(addressCouldBeObj(senderContextOrNil)))) {
		return 0;
	}
	if (!(asserta(addressCouldBeObj(savedThisContext)))) {
		return 0;
	}
	if (!(asserta((senderContextOrNil == (nilObject()))
		 || (isContext(senderContextOrNil))))) {
		return 0;
	}
	if (!(asserta(isContext(savedThisContext)))) {
		return 0;
	}
	if (!(asserta((frameCallerContext((aPage->baseFP))) == senderContextOrNil))) {
		return 0;
	}
	if (!(asserta((frameContext((aPage->baseFP))) == savedThisContext))) {
		return 0;
	}
	return 1;
}


/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */
/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */

	/* CoInterpreter>>#voidVMStateForSnapshotFlushingExternalPrimitivesIf: */
static NoDbgRegParms sqInt
voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeContext1;
    sqInt address;
    sqInt classIndex;
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;


	/* in case of code compactions. */
	GIV(instructionPointer) = 0;
	activeContext1 = divorceAllFrames();
	/* begin bereaveAllMarriedContextsForSnapshotFlushingExternalPrimitivesIf: */
	obj = 0;
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			fmt = (((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask());
			if ((fmt == (indexablePointersFormat()))
			 && (((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
				makeContextSnapshotSafe(obj1);
			}
			if (flushExtPrims
			 && (fmt >= (firstCompiledMethodFormat()))) {
				flushExternalPrimitiveOf(obj1);
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	activeContext = activeContext1;
	voidCogCompiledCode();
	return activeContext;
}


/*	useful for VM debugging */

	/* CoInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *somewhere;
    char *where;

	somewhere = whereIsMaybeCodeThing(anOop);
	if (!(somewhere == null)) {
		return somewhere;
	}
	/* begin whereIsMaybeHeapThing: */
	if (	/* begin isInNewSpace: */
		(oopisLessThan(anOop, GIV(oldSpaceStart)))
	 && (oopisGreaterThanOrEqualTo(anOop, GIV(newSpaceStart)))) {
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((eden()).start), GIV(freeStart))) {
			where = " is in eden";
			goto l1;
		}
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((futureSpace()).start), futureSurvivorStart())) {
			where = " is in future space";
			goto l1;
		}
		if (oopisGreaterThanOrEqualToandLessThan(anOop, ((pastSpace()).start), GIV(pastSpaceStart))) {
			where = " is in past space";
			goto l1;
		}
		where = " is in new space";
		goto l1;
	}
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(oldSpaceStart), GIV(endOfMemory))) {
		if (!((segmentContainingObj(anOop)) == null)) {
			where = " is in old space";
			goto l1;
		}
		where = " is between old space segments";
		goto l1;
	}
	where = null;
	l1:	/* end whereIsMaybeHeapThing: */;
	if (!(where == null)) {
		return where;
	}
	/* begin whereIsMaybeStackThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(stackBasePlus1) - 1, GIV(pages))) {
		where = " is in the stack zone";
		goto l2;
	}
	where = null;
	l2:	/* end whereIsMaybeStackThing: */;
	if (!(where == null)) {
		return where;
	}
	return " is no where obvious";
}


/*	Either widow the context or map its pc to a bytecode one.
	Used to implement primitiveVoidVMStateForMethod. */
/*	for debugging & saving space */

	/* CoInterpreter>>#widowOrForceToBytecodePC: */
static NoDbgRegParms NeverInline void
widowOrForceToBytecodePC(sqInt ctxt)
{
	if (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		/* Since any machine-code frame activations of the method have been divorced
		   there should only be interpreted activations of marriecd contexts. */
		if (!(isWidowedContext(ctxt))) {
			assert(!((isMachineCodeFrame(frameOfMarriedContext(ctxt)))));
		}
	}
	else {
		ensureContextHasBytecodePC(ctxt);
	}
}

	/* CoInterpreterPrimitives>>#frameIsMarked: */
static NoDbgRegParms int
frameIsMarked(sqInt theFPInt)
{
    sqInt methodField;

	methodField = longAt(theFPInt + FoxMethod);
	return ((((usqInt)methodField)) < (startOfMemory())
		? (methodField & 4) != 0
		: ((longAt(theFPInt + FoxIFrameFlags)) & 2) != 0);
}

	/* CoInterpreterPrimitives>>#primitiveBenchmarkFollowForwardersInStackZone */
#if VMBenchmarks
EXPORT(void)
primitiveBenchmarkFollowForwardersInStackZone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    usqLong then;


	/* begin primitiveReturnTimeTakenFor: */
	then = ioHighResClock();
	followForwardingPointersOfReceiversInStackZone();
	oop = positive64BitIntegerFor((ioHighResClock()) - then);
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}
#endif /* VMBenchmarks */

	/* CoInterpreterPrimitives>>#primitiveBenchmarkFollowForwardersOfReceiverAndTemporariesInStackZone */
#if VMBenchmarks
EXPORT(void)
primitiveBenchmarkFollowForwardersOfReceiverAndTemporariesInStackZone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    usqLong then;


	/* begin primitiveReturnTimeTakenFor: */
	then = ioHighResClock();
	followForwardingPointersOfReceiverAndTemporariesInStackZone();
	oop = positive64BitIntegerFor((ioHighResClock()) - then);
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}
#endif /* VMBenchmarks */

	/* CoInterpreterPrimitives>>#primitiveBenchmarkJITReceiver */
#if VMBenchmarks
EXPORT(sqInt)
primitiveBenchmarkJITReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cloneMethod;
    sqInt oop;
    sqInt receiverMethod;
    char *sp;
    usqLong then;

	receiverMethod = longAt(GIV(stackPointer));
	if (!(		/* begin isOopCompiledMethod: */
			((!(receiverMethod & (tagMask()))))
		 && (((((usqInt)((longAt(receiverMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return (GIV(primFailCode) = PrimErrBadReceiver);
	}
	if (isFullBlockMethod(receiverMethod)) {
		return (GIV(primFailCode) = PrimErrUnsupported);
	}
	cloneMethod = cloneObject(receiverMethod);
	if (!cloneMethod) {
		return (GIV(primFailCode) = PrimErrNoMemory);
	}
	/* begin primitiveReturnTimeTakenFor: */
	then = ioHighResClock();
	if (!(cogselector(cloneMethod, maybeSelectorOfMethod(cloneMethod)))) {
		return (GIV(primFailCode) = PrimErrOperationFailed);
	}
	freeCogMethod(cogMethodOf(cloneMethod));
	oop = positive64BitIntegerFor((ioHighResClock()) - then);
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}
#endif /* VMBenchmarks */

	/* CoInterpreterPrimitives>>#primitiveBenchmarkScavenge */
#if VMBenchmarks
EXPORT(void)
primitiveBenchmarkScavenge(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    usqLong then;


	/* begin primitiveReturnTimeTakenFor: */
	then = ioHighResClock();
	scavengingGCTenuringIf(TenureByAge);
	(((usqInt)(((((GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart))) - (interpreterAllocationReserveBytes())) < 0) ? 0 : ((GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart))) - (interpreterAllocationReserveBytes())))) << 3) | 1);
	oop = positive64BitIntegerFor((ioHighResClock()) - then);
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}
#endif /* VMBenchmarks */


/*	This is optional old obsolete stuff tedious to implement in Cog because of
	the need to map from machine code pc to bytecode pc. So for now just fail. */

	/* CoInterpreterPrimitives>>#primitiveClosureCopyWithCopiedValues */
static void
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Answer the contents of the code zone as an array of pair-wise element,
	address in ascending
	address order. Answer a string for a runtime routine or abstract label
	(beginning, end, etc),
	a CompiledMethod for a CMMethod, or a selector (presumably a Symbol) for a
	PIC. If there is an argument and it is true, then collect inner
	information about the CogMethod. */

	/* CoInterpreterPrimitives>>#primitiveCollectCogCodeConstituents */
static void
primitiveCollectCogCodeConstituents(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt constituents;
    char *sp;
    sqInt withDetails;

	if (GIV(argumentCount) == 0) {
		withDetails = 0;
	}
	else {
		withDetails = longAt(GIV(stackPointer));
		if (!((withDetails == GIV(trueObj))
			 || (withDetails == GIV(falseObj)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		withDetails = withDetails == GIV(trueObj);
	}
	constituents = cogCodeConstituents(withDetails);
	if (!constituents) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), constituents);
	GIV(stackPointer) = sp;
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

	/* CoInterpreterPrimitives>>#primitiveContextXray */
static void
primitiveContextXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    sqInt pc;
    sqInt senderOop;
    char *sp;
    char *theFP;
    sqInt theMethod;

	context = longAt(GIV(stackPointer));
	pc = longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	if (((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			theFP = pointerForOop(senderOop - (smallIntegerTag()));
			if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
				flags = 7;
			}
			else {
				flags = 3;
			}
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}
	if (((((pc) & 7) == 1))
	 && (((pc >> 3)) < 0)) {
		flags = flags | 8;
	}
	theMethod = longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (	/* begin maybeMethodHasCogMethod: */
		((!(theMethod & (tagMask()))))
	 && ((((((usqInt)((longAt(theMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
	 && (isCogMethodReference(longAt((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))))) {
		flags = flags | 16;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)flags << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process. */

	/* CoInterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    int inInterpreter;
    sqInt objOop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin activeProcess */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}
	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(criticalSection)),
		oopisGreaterThanOrEqualTo(criticalSection, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(activeProc & (tagMask()))))
			 && (oopisLessThan(activeProc, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(criticalSection)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(criticalSection);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	addLastLinktoList(activeProc, criticalSection);
	transferTofrom(wakeHighestPriority(), CSEnterCriticalSection);
	/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	returnToExecutivepostContextSwitch(inInterpreter, 1);
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* CoInterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    int inInterpreter;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */
	criticalSection = longAt(GIV(stackPointer));
	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	if ((	/* begin isEmptyList: */
		assert(!(isForwarded(criticalSection))),
	(longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(criticalSection)));
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		/* We're going to switch process, either to an interpreted frame or a machine
		   code frame. To know whether to return or enter machine code we have to
		   know from whence we came.  We could have come from the interpreter,
		   either directly or via a machine code primitive.  We could have come from
		   machine code.  The instructionPointer tells us where from: */
		inInterpreter = GIV(instructionPointer) >= (startOfMemory());
		/* store check unnecessary because aSemaphore referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */
		owningProcess = removeFirstLinkOfList(criticalSection);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(criticalSection)));
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), owningProcess);
		if (resumepreemptedYieldingIffrom(owningProcess, GIV(preemptionYields), CSExitCriticalSection)) {
			/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
			if (GIV(nextProfileTick) > 0) {
				checkProfileTick(GIV(newMethod));
			}
			returnToExecutivepostContextSwitch(inInterpreter, 1);
		}
	}
}


/*	No-op for measuring performance of primitiveExternalCall/#117 linkage */

	/* CoInterpreterPrimitives>>#primitiveExternalCallNoOp */
EXPORT(void)
primitiveExternalCallNoOp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin methodReturnReceiver */
	assert(!((failed())));
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	No-op for measuring performance of FastCPrimitiveFlag linkage */

	/* CoInterpreterPrimitives>>#primitiveFastCNoOp */
EXPORT(void)
primitiveFastCNoOp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin methodReturnReceiver */
	assert(!((failed())));
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	No-op for measuring performance of
	FastCPrimitiveFlag+FastCPrimitiveAlignForFloatsFlag linkage
 */

	/* CoInterpreterPrimitives>>#primitiveFastCNoOpAlignedForFloats */
EXPORT(void)
primitiveFastCNoOpAlignedForFloats(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin methodReturnReceiver */
	assert(!((failed())));
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */
/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that
	refer to this method, presumably because it has been redefined, overridden
	or removed.
	Override to flush appropriate machine code caches also. */

	/* CoInterpreterPrimitives>>#primitiveFlushCacheByMethod */
static void
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	flushMethodCacheForMethod(longAt(GIV(stackPointer)));
	unlinkSendsToandFreeIf(longAt(GIV(stackPointer)), 0);
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined. Override to also flush machine code caches. */

	/* CoInterpreterPrimitives>>#primitiveFlushCacheBySelector */
static void
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt probe;
    sqInt selector;

	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((32)) << (shiftForWord())))))))
	 || (selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((34)) << (shiftForWord())))))))) {
	}
	unlinkSendsOfisMNUSelector(selector, selector == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))));
}

	/* CoInterpreterPrimitives>>#primitiveFunctionPointerAddress */
usqInt
primitiveFunctionPointerAddress(void)
{
	return ((usqInt)((&primitiveFunctionPointer)));
}


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

	/* CoInterpreterPrimitives>>#primitiveLongRunningPrimitiveSemaphore */
#if LRPCheck
EXPORT(sqInt)
primitiveLongRunningPrimitiveSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    int flushState;
    sqInt sema;
    char *sp;

	if (GIV(argumentCount) != 1) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (sema == GIV(nilObj)) {
		flushState = GIV(longRunningPrimitiveCheckSemaphore);
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		flushState = !GIV(longRunningPrimitiveCheckSemaphore);
		if (!(			/* begin isSemaphoreOop: */
				((!(sema & (tagMask()))))
			 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	if (flushState) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
		activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0);
		marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
		assert((((stackValue(0)) == (nilObject()))
		 && (!GIV(longRunningPrimitiveCheckSemaphore)))
		 || (((stackValue(0)) == GIV(longRunningPrimitiveCheckSemaphore))
		 && (isSemaphoreOop(sema))));
	}
	voidLongRunningPrimitive("install");
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	if (flushState) {
		ceInvokeInterpret();
	}
	return 0;
}
#endif /* LRPCheck */

	/* CoInterpreterPrimitives>>#primitiveMethodPCData */
EXPORT(sqInt)
primitiveMethodPCData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cm;
    CogMethod *cogMethod;
    sqInt data;
    sqInt data1;
    sqInt delta;
    sqInt methodHeader;
    sqInt methodReceiver;
    sqInt nEntries;
    sqInt nSlots;
    char *sp;

	if (GIV(argumentCount) != 0) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	methodReceiver = longAt(GIV(stackPointer));
	data = 0;
	if (methodHasCogMethod(methodReceiver)) {
		/* begin cogMethodOf: */
		methodHeader = longAt((methodReceiver + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader))
		 && ((((usqInt)methodHeader)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader);
		/* begin pcDataFor: */
		cm = (cogMethod->methodObject);
		nSlots = (((byteSizeOf(cm)) - ((((/* begin literalCountOfMethodHeader: */
	assert((((((cogMethod->methodHeader))) & 7) == 1)),
((((cogMethod->methodHeader)) >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop)) * 2) + ((16) / BytesPerOop);
		data1 = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), nSlots);
		if (!data1) {
			data = -1;
			goto l2;
		}
		nEntries = mapPCDataForinto(cogMethod, data1);
		if (nEntries == 0) {
			data = 0;
			goto l2;
		}
		if (nEntries < nSlots) {
			/* begin shorten:toIndexableSize: */
			assert((nEntries >= 0)
			 && (nEntries < (lengthOf(data1))));
			delta = doShortentoIndexableSize(data1, nEntries);
			assert((lengthOf(followMaybeForwarded(data1))) == nEntries);
			runLeakCheckerFor(GCCheckShorten);
		}
		data = data1;
	l2:	/* end pcDataFor: */;
		if (data == -1) {
			return (GIV(primFailCode) = PrimErrNoMemory);
		}
	}
	if (data == 0) {
		data = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), 0);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), data);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Lift the veil from a method and answer an integer describing the interior
	state of its machine code.
	Used for e.g. VM tests so they can verify they're testing what they think
	they're testing.
	0 implies a vanilla method.
	Bit 0 = method might be compiled to machine code
	Bit 1 = method is currently compiled to machine code
	Bit 2 = is compiled frameless.
	Bit 3 = method refers to young object.
	Bit 4 = method too big to be jitted (more than 64k of code, or needs more
	than 1.5Mb of stack space to compile)
	Bit 5 = method contains unknown/unjittable bytecode
	Bit 6 = method should not be jitted because it contains a primitive not to
	be called from machine code (unused) */

	/* CoInterpreterPrimitives>>#primitiveMethodXray */
static void
primitiveMethodXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt alreadyCogged;
    CogMethod *cogMethod;
    int flags;
    sqInt methodHeader;
    char *sp;

	if (methodWithHeaderShouldBeCogged(methodHeaderOf(longAt(GIV(stackPointer))))) {
		alreadyCogged = 
		/* begin maybeMethodHasCogMethod: */
((!((longAt(GIV(stackPointer))) & (tagMask()))))
		 && ((((((usqInt)((longAt(longAt(GIV(stackPointer)))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
		 && (isCogMethodReference(longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord()))))))));
		flags = 1;
		if (!alreadyCogged) {
			cogMethod = cogselector(longAt(GIV(stackPointer)), GIV(nilObj));
			if ((cogMethod == null)
			 && (GIV(cogCompiledCodeCompactionCalledFor))) {
				commenceCogCompiledCodeCompaction();
				cogMethod = cogselector(longAt(GIV(stackPointer)), GIV(nilObj));
			}
			switch (((sqInt)cogMethod)) {
			case MethodTooBig:
				flags = 17;
				break;
			case EncounteredUnknownBytecode:
				flags = 33;
				break;
			case ShouldNotJIT:
				flags = 65;
				break;
			default:
				assert(!(((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= NotFullyInitialized)))));
			}
		}
		if ((flags == 1)
		 && (		/* begin maybeMethodHasCogMethod: */
			((!((longAt(GIV(stackPointer))) & (tagMask()))))
		 && ((((((usqInt)((longAt(longAt(GIV(stackPointer)))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
		 && (isCogMethodReference(longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))))))))) {
			/* begin cogMethodOf: */
			methodHeader = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			assert((isNonImmediate(methodHeader))
			 && ((((usqInt)methodHeader)) < (startOfMemory())));
			cogMethod = ((CogMethod *) methodHeader);
			flags = (((cogMethod->stackCheckOffset)) == 0
				? 7
				: 3);
			if ((cogMethod->cmRefersToYoung)) {
				flags += 8;
			}
			if (!alreadyCogged) {
				freeCogMethod(cogMethod);
			}
		}
	}
	else {
		flags = 0;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)flags << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* CoInterpreterPrimitives>>#primitiveMinimumUnusedHeadroom */
EXPORT(void)
primitiveMinimumUnusedHeadroom(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    char *sp;

	integer = minimumUnusedHeadroom();
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

	/* CoInterpreterPrimitives>>#primitiveObjectAt */
static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    sqInt oop;
    sqInt rawHeader;
    sqInt realHeader;
    char *sp;
    sqInt thisReceiver;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rawHeader = longAt((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	realHeader = ((	/* begin isCogMethodReference: */
		assert(((((rawHeader) & 7) == 1))
		 || (((((usqInt)rawHeader)) < (startOfMemory()))
		 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))
		? ((((CogMethod *) rawHeader))->methodHeader)
		: rawHeader);
	if (!((index > 0)
		 && (index <= (((/* begin literalCountOfMethodHeader: */
	assert((((realHeader) & 7) == 1)),
((realHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	oop = (index == 1
		? realHeader
		: longAt((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
	We assume that if the user is using this on active code then they will use
	primitiveVoidVMStateForMethod to discard the machine code as required. */

	/* CoInterpreterPrimitives>>#primitiveObjectAtPut */
static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    sqInt rawHeader;
    sqInt realHeader;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((!(index & (smallIntegerTag())))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 3);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(thisReceiver)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	rawHeader = longAt((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	realHeader = ((	/* begin isCogMethodReference: */
		assert(((((rawHeader) & 7) == 1))
		 || (((((usqInt)rawHeader)) < (startOfMemory()))
		 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))
		? ((((CogMethod *) rawHeader))->methodHeader)
		: rawHeader);
	if (!((index > 0)
		 && (index <= (((/* begin literalCountOfMethodHeader: */
	assert((((realHeader) & 7) == 1)),
((realHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (index == 1) {
		if (((!(newValue & (smallIntegerTag()))))
		 || (((		/* begin literalCountOfMethodHeader: */
			assert((((newValue) & 7) == 1)),
		((newValue >> 3)) & AlternateHeaderNumLiteralsMask)) != ((assert((((realHeader) & 7) == 1)),
		((realHeader >> 3)) & AlternateHeaderNumLiteralsMask)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		if ((		/* begin isCogMethodReference: */
			assert(((((rawHeader) & 7) == 1))
			 || (((((usqInt)rawHeader)) < (startOfMemory()))
			 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))) {
			((((CogMethod *) rawHeader))->methodHeader = newValue);
		}
		else {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(thisReceiver)));
			longAtput((thisReceiver + BaseHeaderSize) + (0U << (shiftForWord())), newValue);
		}
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(thisReceiver)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(thisReceiver)),
		oopisGreaterThanOrEqualTo(thisReceiver, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(newValue & (tagMask()))))
			 && (oopisLessThan(newValue, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(thisReceiver)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(thisReceiver);
				}
			}
		}
		longAtput((thisReceiver + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))), newValue);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

	/* CoInterpreterPrimitives>>#primitiveProfileSemaphore */
EXPORT(sqInt)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int flushState;
    sqInt sema;

	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (sema == GIV(nilObj)) {
		flushState = GIV(profileSemaphore) != GIV(nilObj);
	}
	else {
		flushState = GIV(profileSemaphore) == GIV(nilObj);
		if (!(			/* begin isSemaphoreOop: */
				((!(sema & (tagMask()))))
			 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
	}
	GIV(profileSemaphore) = sema;
	/* If we've switched profiling on or off we must void machine code
	   (and machine code pcs in contexts) since we will start or stop
	   testing the profile clock in machine code primitive invocations,
	   and so generate slightly different code from here on in. */
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));
	if (flushState) {
		flushExternalPrimitives();
	}
	else {
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

	/* CoInterpreterPrimitives>>#primitiveResume */
static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    int inInterpreter;
    sqInt objOop;
    sqInt proc;


	/* rcvr */
	/* Alas in Spur we need a read barrier */
	proc = longAt(GIV(stackPointer));
	/* begin followObjField:ofObject: */
	objOop = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, proc, objOop);
	}
	ctxt = objOop;
	if (!(		/* begin isContext: */
			((!(ctxt & (tagMask()))))
		 && (((longAt(ctxt)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	if (resumepreemptedYieldingIffrom(proc, GIV(preemptionYields), CSResume)) {
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */
/*	We may be about to switch process, either to an interpreted frame or a
	machine code frame. To know whether to return or enter machine code
	we have to know from whence we came. We could have come from the
	interpreter, either directly or via a machine code primitive. We could
	have come from machine code. The instructionPointer tells us where from: */

	/* CoInterpreterPrimitives>>#primitiveSignal */
static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;

	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	if (synchronousSignal(longAt(GIV(stackPointer)))) {
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
	}
}


/*	Save a normal snapshot under the same name as it was loaded
	unless it has been renamed by the last primitiveImageName.
	Note that when executed this primitive answers false, but when the
	resulting image is run afresh, the primitive answers true.
	
	Override to jump to the interpreter because the machine code zone is now
	void. 
 */

	/* CoInterpreterPrimitives>>#primitiveSnapshot */
static void
primitiveSnapshot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	snapshot(0);
	if ((longAt(GIV(framePointer) + FoxMethod)) == GIV(newMethod)) {
		/* snapshot: has reached the end and built a frame.
		   In the JIT we need to back-up the pc before reentering the interpreter. */
		GIV(instructionPointer) -= 1;
	}
	ceInvokeInterpret();
}


/*	Save an embedded snapshot.
	Note that when executed this primitive answers false, but when the
	resulting image is run afresh, the primitive answers true.
	
	Override to jump to the interpreter because the machine code zone is now
	void. 
 */

	/* CoInterpreterPrimitives>>#primitiveSnapshotEmbedded */
static void
primitiveSnapshotEmbedded(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	snapshot(1);
	if ((longAt(GIV(framePointer) + FoxMethod)) == GIV(newMethod)) {
		/* snapshot: has reached the end and built a frame.
		   In the JIT we need to back-up the pc before reentering the interpreter. */
		GIV(instructionPointer) -= 1;
	}
	ceInvokeInterpret();
}


/*	Primitive #88. Suspend the receiver, aProcess, such that it can be
	executed again
	by sending #resume. If the given process is not the active process, take
	it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
	c.f. primitiveSuspendBackingUpV1,#568 & primitiveSuspendBackingUpV2,#578 */

	/* CoInterpreterPrimitives>>#primitiveSuspend */
static void
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;
    sqInt myContext;
    sqInt myList;
    usqInt numSlots;
    sqInt ok;
    sqInt process;

	process = longAt(GIV(stackPointer));
	if (process == (activeProcess())) {
		/* We're going to switch process, either to an interpreted frame or a machine
		   code frame. To know whether to return or enter machine code we have to
		   know from whence we came.  We could have come from the interpreter,
		   either directly or via a machine code primitive.  We could have come from
		   machine code.  The instructionPointer tells us where from: */
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
		inInterpreter = GIV(instructionPointer) >= (startOfMemory());
		transferTofrom(wakeHighestPriority(), CSSuspend);
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
		return;
	}
	myList = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))));
	myContext = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!((		/* begin isPointers: */
			((!(myList & (tagMask()))))
		 && (((((usqInt)((longAt(myList)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((((		/* begin numSlotsOf: */
			assert((classIndexOf(myList)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(myList + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(myList - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) > LastLinkIndex)
		 && ((		/* begin isContext: */
			((!(myContext & (tagMask()))))
		 && (((longAt(myContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && ((assert(isContext(myContext)),
		((((longAt((myContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	ok = removeProcessfromList(process, myList);
	if (!ok) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), myList);
}


/*	Primitive #568. Suspend the receiver, aProcess, such that it can be
	executed again
	by sending #resume. If the given process is not the active process, take
	it off
	its corresponding list. If the list was not its run queue assume it was on
	some condition variable (Semaphore, Mutex) and back up its pc to the send
	that invoked the wait state the process entered. Hence when the process
	resumes it will reenter the wait state. Answer the list the receiver was
	previously on,
	unless it was the activeProcess, in which case answer nil.
	c.f. primitiveSuspend,#88 & primitiveSuspendBackingUpV2,#578 */

	/* CoInterpreterPrimitives>>#primitiveSuspendBackingUpV1 */
static void
primitiveSuspendBackingUpV1(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;
    sqInt myContext;
    sqInt myList;
    usqInt numSlots;
    sqInt ok;
    sqInt process;

	process = longAt(GIV(stackPointer));
	if (process == (activeProcess())) {
		/* We're going to switch process, either to an interpreted frame or a machine
		   code frame. To know whether to return or enter machine code we have to
		   know from whence we came.  We could have come from the interpreter,
		   either directly or via a machine code primitive.  We could have come from
		   machine code.  The instructionPointer tells us where from: */
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
		inInterpreter = GIV(instructionPointer) >= (startOfMemory());
		transferTofrom(wakeHighestPriority(), CSSuspend);
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
		return;
	}
	myList = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))));
	myContext = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!((		/* begin isPointers: */
			((!(myList & (tagMask()))))
		 && (((((usqInt)((longAt(myList)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((((		/* begin numSlotsOf: */
			assert((classIndexOf(myList)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(myList + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(myList - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) > LastLinkIndex)
		 && ((		/* begin isContext: */
			((!(myContext & (tagMask()))))
		 && (((longAt(myContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && ((assert(isContext(myContext)),
		((((longAt((myContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	ok = removeProcessfromList(process, myList);
	if (!ok) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}
	if (((longAt(myList)) & (classIndexMask())) != GIV(classLinkedListClassTag)) {
		backupContexttoBlockingSendTo(myContext, myList);
	}
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), myList);
}


/*	Primitive #578. Suspend the receiver, aProcess, such that it can be
	executed again
	by sending #resume. If the given process is not the active process, take
	it off
	its corresponding list. If the list was not its run queue assume it was on
	some condition variable (Semaphore, Mutex) and back up its pc to the send
	that invoked the wait state the process entered. Hence when the process
	resumes it will reenter the wait state. Answer the list the receiver was
	previously on iff
	it was not active and not blocked, otherwise answer nil.
	c.f. primitiveSuspend,#88 & primitiveSuspendBackingUpV1,#568,
	which always answer the list the process was on, even if blocked. */

	/* CoInterpreterPrimitives>>#primitiveSuspendBackingUpV2 */
EXPORT(void)
primitiveSuspendBackingUpV2(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int inInterpreter;
    sqInt myContext;
    sqInt myList;
    usqInt numSlots;
    sqInt ok;
    sqInt process;

	process = longAt(GIV(stackPointer));
	if (process == (activeProcess())) {
		/* We're going to switch process, either to an interpreted frame or a machine
		   code frame. To know whether to return or enter machine code we have to
		   know from whence we came.  We could have come from the interpreter,
		   either directly or via a machine code primitive.  We could have come from
		   machine code.  The instructionPointer tells us where from: */
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
		inInterpreter = GIV(instructionPointer) >= (startOfMemory());
		transferTofrom(wakeHighestPriority(), CSSuspend);
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
		return;
	}
	myList = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))));
	myContext = longAt((process + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!((		/* begin isPointers: */
			((!(myList & (tagMask()))))
		 && (((((usqInt)((longAt(myList)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((((		/* begin numSlotsOf: */
			assert((classIndexOf(myList)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(myList + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(myList - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) > LastLinkIndex)
		 && ((		/* begin isContext: */
			((!(myContext & (tagMask()))))
		 && (((longAt(myContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && ((assert(isContext(myContext)),
		((((longAt((myContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	ok = removeProcessfromList(process, myList);
	if (!ok) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}
	if (((longAt(myList)) & (classIndexMask())) != GIV(classLinkedListClassTag)) {
		backupContexttoBlockingSendTo(myContext, myList);
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
	}
	else {
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), myList);
	}
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
	Override to ensure the caller's saved ip is correct, i.e. if an
	interpreter frame it may
	have to move to iframeSavedIP. */

	/* CoInterpreterPrimitives>>#primitiveTerminateTo */
static void
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    sqInt callerContextOrNil;
    sqInt callerContextOrNil1;
    char *callerFP;
    char *callerFP1;
    char *callerFP2;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *fp2;
    char *frameAbove;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    sqInt numArgs;
    StackPage *pageToStopOn;
    sqInt senderOop;
    sqInt senderOop1;
    sqInt senderOop2;
    sqInt senderOop3;
    sqInt senderOop4;
    sqInt senderOop5;
    char *source;
    sqInt stackedReceiverOffset;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    StackPage *thePage1;
    StackPage *thePage2;
    sqInt thisCtx;
    sqInt valuePointer;
    sqInt valuePointer1;

	contextsFP = ((char *) 0);
	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (		/* begin isContext: */
			((!(aContextOrNil & (tagMask()))))
		 && (((longAt(aContextOrNil)) & (classIndexMask())) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((aContextOrNil != GIV(nilObj))
	 && (	/* begin isStillMarriedContext: */
		(((((longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(aContextOrNil))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		contextsFP = pointerForOop(senderOop - (smallIntegerTag()));
		/* begin stackPageFor: */
		pageToStopOn = stackPageAtpages(
			(assert((((((char *) contextsFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) contextsFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(contextsFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
	}
	else {
		pageToStopOn = 0;
	}
	if (	/* begin isStillMarriedContext: */
		(((((longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(thisCtx)))) {
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - (smallIntegerTag()));
		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			assertValidStackedInstructionPointersInline(GIV(stackPage), __LINE__);
			if ((pointerForOop(longAt(theFP + FoxSavedFP))) != contextsFP) {
				/* begin frameStackedReceiverOffset: */
				numArgs = ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((mframeCogMethod(theFP))->cmNumArgs)
					: byteAt((theFP + FoxIFrameFlags) + 1));
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
				/* begin findFrameAbove:inPage: */
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l4;
				}
				while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l4;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
	l4:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(pointerForOop(longAt(frameAbove + FoxCallerSavedIP))));
				assert((((((usqInt)contextsIP)) >= (startOfMemory()))
				 || (contextsIP == (ceReturnToInterpreterPC()))) == (!(isMachineCodeFrame(contextsFP))));
				/* begin frameCallerSP: */
				assert(!(isBaseFrame(frameAbove)));
				newSP = (frameAbove + (frameStackedReceiverOffset(frameAbove))) + BytesPerWord;
				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				if (((((usqInt)(longAt(newFP + FoxMethod)))) < (startOfMemory()))
				 && (contextsIP >= (startOfMemory()))) {
					/* begin iframeSavedIP:put: */
					assert(!(isMachineCodeFrame(contextsFP)));
					longAtput(contextsFP + FoxIFSavedIP, contextsIP);
					contextsIP = ceReturnToInterpreterPC();
				}
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx));
				/* begin withSmallIntegerTags: */
				assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0);
				valuePointer = (oopForPointer(newFP)) + (smallIntegerTag());
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(thisCtx)));
				longAtput((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
				/* begin withSmallIntegerTags: */
				assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0);
				valuePointer1 = (oopForPointer(contextsFP)) + (smallIntegerTag());
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(thisCtx)));
				longAtput((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			assertValidStackedInstructionPointersInline(GIV(stackPage), __LINE__);
			assert(GIV(stackPage) == (mostRecentlyUsedPage()));
			return;
		}
		assertValidStackedInstructionPointers(__LINE__);
		/* May cause a GC!! */
		theFP = externalEnsureIsBaseFrame(theFP);
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		thePage1 = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil))));
		currentCtx = callerContextOrNil;
		if ((aContextOrNil != GIV(nilObj))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(aContextOrNil))))) {
			/* begin frameOfMarriedContext: */
			senderOop2 = longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop2) & 7) == 1));
			contextsFP = pointerForOop(senderOop2 - (smallIntegerTag()));
			/* begin stackPageFor: */
			pageToStopOn = stackPageAtpages(
				(assert((((((char *) contextsFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) contextsFP)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(contextsFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
				GIV(pages));
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		currentCtx = longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	assertValidStackedInstructionPointers(__LINE__);
	if (contexthasSender(thisCtx, aContextOrNil)) {
		/* Need to walk the stack freeing stack pages and nilling contexts. */
		while (!((currentCtx == aContextOrNil)
		 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx));
			if (((((longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
				/* begin frameOfMarriedContext: */
				senderOop3 = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
				/* begin withoutSmallIntegerTags: */
				assert((((senderOop3) & 7) == 1));
				theFP = pointerForOop(senderOop3 - (smallIntegerTag()));
				/* begin stackPageFor: */
				thePage = stackPageAtpages(
					(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					fp1 = (thePage->headFP);
					if (fp1 == theFP) {
						frameAbove = 0;
						goto l12;
					}
					while (((callerFP1 = pointerForOop(longAt(fp1 + FoxSavedFP)))) != 0) {
						if (callerFP1 == theFP) {
							frameAbove = fp1;
							goto l12;
						}
						fp1 = callerFP1;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
	l12:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);
					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */
					frameAbove = externalEnsureIsBaseFrame(frameAbove);
					if ((aContextOrNil != GIV(nilObj))
					 && (					/* begin isStillMarriedContext: */
						(((((longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
					 && (!(isWidowedContext(aContextOrNil))))) {
						/* begin frameOfMarriedContext: */
						senderOop4 = longAt((aContextOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
						/* begin withoutSmallIntegerTags: */
						assert((((senderOop4) & 7) == 1));
						contextsFP = pointerForOop(senderOop4 - (smallIntegerTag()));
						/* begin stackPageFor: */
						pageToStopOn = stackPageAtpages(
							(assert((((((char *) contextsFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) contextsFP)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(contextsFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {
						/* We're here.  Cut back the stack to aContextOrNil's frame,
						   push its instructionPointer if it's not already a head frame,
						   and we're done. */
						/* begin findFrameAbove:inPage: */
						fp2 = (thePage->headFP);
						if (fp2 == contextsFP) {
							frameAbove = 0;
							goto l15;
						}
						while (((callerFP2 = pointerForOop(longAt(fp2 + FoxSavedFP)))) != 0) {
							if (callerFP2 == contextsFP) {
								frameAbove = fp2;
								goto l15;
							}
							fp2 = callerFP2;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
	l15:	/* end findFrameAbove:inPage: */;
						if (frameAbove != 0) {
							contextsSP = ((/* begin frameCallerSP: */
	assert(!(isBaseFrame(frameAbove))),
(frameAbove + (frameStackedReceiverOffset(frameAbove))) + BytesPerWord)) - BytesPerWord;
							longAtput(contextsSP, pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {
						/* We can free the entire page without further ado. */
						theFP1 = (thePage->baseFP);
						/* begin frameCallerContext: */
						assert(isBaseFrame(theFP1));
						thePage2 = stackPageAtpages(
							(assert((((((char *) theFP1)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP1)) <= (((char *) GIV(pages)))))),
							pageIndexForstackBasePlus1bytesPerPage(theFP1, GIV(stackBasePlus1), GIV(bytesPerPage))),
							GIV(pages));
						callerContextOrNil1 = longAt((thePage2->baseAddress));
						assert(addressCouldBeObj(callerContextOrNil1));
						assert((callerContextOrNil1 == (nilObject()))
						 || (isContext(followMaybeForwarded(callerContextOrNil1))));
						currentCtx = callerContextOrNil1;
						freeStackPageNoAssert(thePage);
					}
				}
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				assert(!(isOopForwarded(currentCtx)));
				longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(currentCtx)));
				longAtput((currentCtx + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed());
	if (((((longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer)));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx)));
		/* begin frameOfMarriedContext: */
		senderOop5 = longAt((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop5) & 7) == 1));
		theFP = pointerForOop(senderOop5 - (smallIntegerTag()));
		/* begin frameCallerContext:put: */
		assert((aContextOrNil == (nilObject()))
		 || (isContext(aContextOrNil)));
		assert(isBaseFrame(theFP));
		assert(((theFP + (frameStackedReceiverOffset(theFP))) + (2 * BytesPerWord)) == (((stackPageFor(theFP))->baseAddress)));
		assert((longAt((theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord)) == (frameContext(theFP)));
		longAtput((theFP + (frameStackedReceiverOffset(theFP))) + (2 * BytesPerWord), aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(thisCtx)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(thisCtx)),
		oopisGreaterThanOrEqualTo(thisCtx, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(aContextOrNil & (tagMask()))))
			 && (oopisLessThan(aContextOrNil, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(thisCtx)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(thisCtx);
				}
			}
		}
		longAtput((thisCtx + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), aContextOrNil);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	assertValidStackedInstructionPointers(__LINE__);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
}


/*	Primitive. Unload the module with the given name.
	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is forced by invalidating all external
	primitive methods and activations in flushExternalPrimitives.
	N.B. since this is most likely a development time activity we don't care
	about performance. */

	/* CoInterpreterPrimitives>>#primitiveUnloadModule */
static void
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;

	moduleName = longAt(GIV(stackPointer));
	if (!(		/* begin isBytes: */
			((!(moduleName & (tagMask()))))
		 && (((((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	moduleLength = (((/* begin numSlotsOf: */
	assert((classIndexOf(moduleName)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(moduleName + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(moduleName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), moduleLength))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (	/* begin object:equalsString:ofSize: */
		(((!(moduleName & (tagMask()))))
	 && (((((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
	 && ((!(((((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && (((numBytesOfBytes(moduleName)) == moduleLength)
	 && ((strncmp("SqueakFFIPrims", firstIndexableField(moduleName), moduleLength)) == 0)))) {
		primitiveCalloutPointer = ((void *) -1);
	}
	forceInterruptCheck();
	flushExternalPrimitives();
}


/*	Void all internal VM state in the stack and machine code zones
	
	Override to jump to the interpreter because the machine code zone is now
	void. 
 */

	/* CoInterpreterPrimitives>>#primitiveVoidVMState */
static void
primitiveVoidVMState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    char *sp;


	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0);
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
	ceInvokeInterpret();
}


/*	The receiver (or first argument) must be a compiledMethod. The optional
	(or second) argument must be a
	boolean. Clear all VM state associated with the method, including any
	machine code, or machine code pcs
	in context objects. If the optional boolean argument is false do not scan
	the heap looking for contexts. */

	/* CoInterpreterPrimitives>>#primitiveVoidVMStateForMethod */
static void
primitiveVoidVMStateForMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt address;
    StackPage *aPage;
    sqInt classIndex;
    CogMethod *cogMethod;
    sqInt divorcedSome;
    sqInt divorcedSome1;
    sqInt followingWord;
    usqInt followingWordAddress;
    int hasCogMethod;
    sqInt i;
    sqInt methodHeader;
    sqInt methodObj;
    usqInt numSlots;
    sqInt obj;
    sqInt object;
    sqInt objOop;
    sqInt oop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt scanHeapForContexts;
    sqInt senderOop;
    char *sp;
    char *sp1;
    sqInt startObject;
    char *theFrame;
    StackPage *thePage;
    sqInt top;
    sqInt top1;


	/* See comment ''One might think...'' below */
	/* In Smalltalk allow both aMethod voidCogVMState and aMethod voidCogVMStateScanningContextsIf: aBoolean */
	scanHeapForContexts = 1;
	if (GIV(argumentCount) == 0) {
		methodObj = longAt(GIV(stackPointer));
	}
	else {
		methodObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			scanHeapForContexts = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			scanHeapForContexts = 0;
			goto l1;
		}
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		scanHeapForContexts = null;
	l1:	/* end booleanValueOf: */;
		if (GIV(primFailCode)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	if (GIV(argumentCount) > 1) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	flushMethodCacheForMethod(methodObj);
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l2;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer));
	l2:	/* end ensureFrameIsMarried:SP: */;
	/* begin ensurePushedInstructionPointer */
	if (GIV(instructionPointer) >= (startOfMemory())) {
		/* invoked directly from the interpreter */
		/* begin iframeSavedIP:put: */
		assert(!(isMachineCodeFrame(GIV(framePointer))));
		longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
		object = ceReturnToInterpreterPC();
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* instructionPointer == cogit ceReturnToInterpreterPC
		   ifTrue: [invoked from the interpreter via a machine code primitive]
		   ifFalse: [invoked from machine code].
		   If in the first case the bytecode instructionPointer has already been
		   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp1;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((hasCogMethod = methodHasCogMethod(methodObj))) {
		/* begin divorceMachineCodeFramesWithMethod: */
		methodHeader = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader))
		 && ((((usqInt)methodHeader)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader);
		do {
			if (!(GIV(stackPage) == null)) {
				/* This is needed for the assert in externalDivorceFrame:andContext: */
				markStackPageMostRecentlyUsed(GIV(stackPage));
			}
			/* begin divorceSomeMachineCodeFramesWithMethod: */
			divorcedSome1 = 0;
			for (i = 0; i < GIV(numStackPages); i += 1) {
				/* begin stackPageAt: */
				aPage = stackPageAtpages(i, GIV(pages));
				if (!(isFree(aPage))) {
					/* this to avoid assert in externalDivorceFrame:andContext: */
					markStackPageMostRecentlyUsed(GIV(stackPage));
					if (divorceAMachineCodeFrameWithCogMethodin(cogMethod, aPage)) {
						divorcedSome1 = 1;
					}
				}
			}
			divorcedSome = divorcedSome1;
		} while(divorcedSome);
	}
	if (scanHeapForContexts) {
		/* begin ensureAllContextsWithMethodHaveBytecodePCs: */
		oop = 0;
		objOop = 0;
		address = 
		/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		/* begin objectStartingAt: */
		numSlots = byteAt(address + 7);
		startObject = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		/* begin allEntitiesFrom:do: */
		prevPrevObj = (prevObj = null);
		obj = startObject;
		enableObjectEnumerationFrom(startObject);
		while (1) {
			assert((obj % (allocationUnit())) == 0);
			if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
			assert((long64At(obj)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex = (longAt(obj)) & (classIndexMask())),
			assert((classIndex == (segmentBridgePun()))
				 || ((classIndex == (isForwardedObjectClassIndexPun()))
				 || (((long64At(obj)) != 0)
				 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex >= (isForwardedObjectClassIndexPun()))) {
				if ((((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && ((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))))) == methodObj)) {
					widowOrForceToBytecodePC(obj);
				}
			}
			prevPrevObj = prevObj;
			prevObj = obj;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress = addressAfter(obj);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				obj = GIV(endOfMemory);
				goto l13;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(obj, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress + BaseHeaderSize)
				: followingWordAddress);
	l13:	/* end objectAfterMaybeSlimBridge:limit: */;
			assert(oopisGreaterThan(obj, prevObj));
		}
	}
	if (hasCogMethod) {
		unlinkSendsToandFreeIf(methodObj, 1);
	}
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(activeContext))))) {
		/* begin nilStackPage */
		assert((!GIV(stackPage))
		 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
		 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
		GIV(stackPage) = null;
		marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		assert((methodObj == (stackTop()))
		 || ((GIV(argumentCount) > 0)
		 && (methodObj == (stackValue(1)))));
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		ceInvokeInterpret();
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	assert(((thePage->headFP)) == theFrame);
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top1;
	assert((methodObj == (stackTop()))
	 || ((GIV(argumentCount) > 0)
	 && (methodObj == (stackValue(1)))));
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* CoInterpreterPrimitives>>#primitiveWait */
static void
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    int inInterpreter;
    sqInt objOop;
    sqInt sema;


	/* rcvr */
	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqInt)((excessSignals - 1))) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(sema)));
			longAtput((sema + BaseHeaderSize) + (((sqInt)((usqInt)(ExcessSignalsIndex) << (shiftForWord())))), (((usqInt)(excessSignals - 1) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* We're going to switch process, either to an interpreted frame or a machine
		   code frame. To know whether to return or enter machine code we have to
		   know from whence we came.  We could have come from the interpreter,
		   either directly or via a machine code primitive.  We could have come from
		   machine code.  The instructionPointer tells us where from: */
		inInterpreter = GIV(instructionPointer) >= (startOfMemory());
		/* begin activeProcess */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		addLastLinktoList(activeProc, sema);
		transferTofrom(wakeHighestPriority(), CSWait);
		/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		returnToExecutivepostContextSwitch(inInterpreter, 1);
	}
}


/*	primitively do the equivalent of Process>yield */

	/* CoInterpreterPrimitives>>#primitiveYield */
static void
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    int inInterpreter;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt scheduler;

	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	priority = (oop >> 3);
	processLists = longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	processList = longAt((processLists + BaseHeaderSize) + (((sqInt)((usqInt)((priority - 1)) << (shiftForWord())))));
	if ((	/* begin isEmptyList: */
		assert(!(isForwarded(processList))),
	(longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		return;
	}
	inInterpreter = GIV(instructionPointer) >= (startOfMemory());
	addLastLinktoList(activeProc, processList);
	transferTofrom(wakeHighestPriority(), CSYield);
	/* begin forProcessPrimitiveReturnToExecutivePostContextSwitch: */
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	returnToExecutivepostContextSwitch(inInterpreter, 1);
}

	/* CoInterpreterPrimitives>>#unmarkAllFrames */
static void
unmarkAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;
    sqInt methodField;
    char *theFP;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			theFP = (thePage->headFP);
			do {
				methodField = longAt(theFP + FoxMethod);
				if ((((usqInt)methodField)) < (startOfMemory())) {
					if ((methodField & 4) != 0) {
						longAtput(theFP + FoxMethod, methodField - 4);
					}
				}
				else {
					flags = longAt(theFP + FoxIFrameFlags);
					if ((flags & 2) != 0) {
						longAtput(theFP + FoxIFrameFlags, flags - 2);
					}
				}
			} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
		}
	}
}


/*	Initialize the stack pages. In the C VM theStackPages will be alloca'ed
	memory to hold the
	stack pages on the C stack. In the simulator they are housed in the memory
	between the
	cogMethodZone and the heap. */

	/* CoInterpreterStackPages>>#initializeStack:numSlots:pageSize: */
static NoDbgRegParms void
initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt index;
    sqInt numPages;
    StackPage *page;
    char *pageStructBase;
    usqIntptr_t structStackPageSize;
    sqInt theIndex;

	structStackPageSize = sizeof(CogStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;
	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	   subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	   push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */
	numPages = GIV(numStackPages);
	pageStructBase = (theStackPages + (numPages * GIV(bytesPerPage))) + BytesPerWord;
	/* make sure there's enough headroom */
	GIV(pages) = ((StackPage *) pageStructBase);
	assert((((stackPageByteSize()) - (stackLimitBytes())) - (stackLimitOffset())) >= (stackPageHeadroom()));
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		(page->lastAddress = theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = ((page->baseAddress)) - ((((stackPageFrameBytes()) < (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom()))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom())))));
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (numPages - 1)
			? 0
			: index + 1)));
		(page->prevPage = stackPageAt((index == 0
			? numPages - 1
			: index - 1)));
	}
	GIV(stackBasePlus1) = (((char *) theStackPages)) + 1;
	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages));
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		assert((pageIndexFor((page->baseAddress))) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord))) == index);
		assert((stackPageFor((page->baseAddress))) == page);
		assert((stackPageFor((page->stackLimit))) == page);
		/* begin initializePageTraceToInvalid: */
		(page->trace = StackPageTraceInvalid);
	}
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages));
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		/* begin pageIndexFor: */
		assert((((((char *) ((page->baseAddress)))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) ((page->baseAddress)))) <= (((char *) GIV(pages))))));
		theIndex = pageIndexForstackBasePlus1bytesPerPage((page->baseAddress), GIV(stackBasePlus1), GIV(bytesPerPage));
		assert((stackPageAt(theIndex)) == page);
		assert((pageIndexFor((page->baseAddress))) == theIndex);
		assert((pageIndexFor((page->stackLimit))) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + 1)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == numPages);
	assert(pageListIsWellFormed());
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

	/* CoInterpreterStackPages>>#pageIndexFor: */
static NoDbgRegParms sqInt
pageIndexFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages))))));
	return pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage));
}

	/* InterpreterPrimitives>>#canBeImmutable: */
#if IMMUTABILITY
static NoDbgRegParms sqInt
canBeImmutable(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt format;
    sqInt format1;
    sqInt processLists;
    sqInt scheduler;

	assert(isNonImmediate(oop));
	if (	/* begin isContext: */
		((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		return 0;
	}
	/* begin isEphemeron: */
	assert(isNonImmediate(oop));
	format = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if (format == 5 /* begin ephemeronFormat */) {
		return 0;
	}
	else {
		goto l1;
	}
	l1:;
	/* begin isWeakNonImm: */
	format1 = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if (format1 == (weakArrayFormat())) {
		return 0;
	}
	else {
		goto l2;
	}
	l2:;
	if (((longAt(oop)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))) {
		return 0;
	}
	/* begin fetchPointer:ofObject: */
	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	processLists = longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	if (oop == scheduler) {
		return 0;
	}
	if (oop == processLists) {
		return 0;
	}
	if ((classIndexOf(longAt((processLists + BaseHeaderSize) + (1U << (shiftForWord()))))) == ((longAt(oop)) & (classIndexMask()))) {
		return 0;
	}
	if ((classIndexOf(longAt((scheduler + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord()))))))) == ((longAt(oop)) & (classIndexMask()))) {
		return 0;
	}
	return 1;
}
#endif /* IMMUTABILITY */


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    char *cString;
    sqInt fmt;
    sqInt isString;
    sqInt len;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin isInstanceOfClassByteString: */
	if (((oop & (tagMask())) != 0)) {
		isString = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	isString = ClassByteStringCompactIndex == ccIndex;
	l3:	/* end isInstanceOfClassByteString: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		len = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		len = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		len = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		len = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		len = numSlots;
		goto l2;
	}
	len = 0;
	l2:	/* end lengthOf: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!cString) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer the identity hash of an object, assigning a hash if it doesn't have
	one. On Spur refuse to assign a hash to something that looks like a
	behavior. 
 */

	/* InterpreterPrimitives>>#identityHashOf: */
sqInt
identityHashOf(sqInt anOop)
{
    usqInt hash;
    usqInt hash1;

	if (((anOop & (tagMask())) != 0)) {
		/* begin immediateAsInteger:ifFail: */
		if ((((anOop) & 7) == 1)) {
			return (anOop >> 3);
		}
		if (((anOop & (characterTag())) != 0)) {
			return ((((usqInt)anOop))) >> (numTagBits());
		}
		if (((anOop & (smallFloatTag())) != 0)) {
			return (				/* begin rotatedFloatBitsOf: */
					assert(isImmediateFloat(anOop)),
				(((((usqInt)anOop))) >> ((numTagBits()) + 1)) + ((((anOop & (1U << (numTagBits()))) != 0)
	? (((usqInt)-1)) << ((64 - (numTagBits())) - 1)
	: 0)));
		}
		return -1;
	}
	if ((((long32At(anOop + 4)) & (identityHashHalfWordMask())) == 0)
	 && (objCouldBeClassObj(anOop))) {
		return -1;
	}
	/* begin hashBitsOf: */
	hash = (long32At(anOop + 4)) & (identityHashHalfWordMask());
	if (hash == 0) {
		/* cb 1/19/2017 18:34:
		   would like to assert
		   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
		   but instance-specific behaviors that are instances of themselves may
		   fail this test. */
		/* eem 12/28/2021 11:52 I'm not sure this is the issue. The issue is only validating objOop as a behavior. */
		flag("todo");
		/* begin newHashBitsOf: */
		hash1 = (newObjectHash()) & (identityHashHalfWordMask());
		assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
		long32Atput(anOop + 4, ((((long32At(anOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
		hash = hash1;
	}
	return hash;
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static NoDbgRegParms sqInt
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    int ok;
    sqInt smallInt;

	if ((((oop) & 7) == 1)) {
		smallInt = (oop >> 3);
		return smallInt < 0;
	}
	if ((!(oop & (tagMask())))) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		if (ok) {
			return 0;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex1 = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		if (ok) {
			return 1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Answer if oop is a value of an integer in address range, i.e up to the
	size of a machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

	/* InterpreterPrimitives>>#isPositiveMachineIntegerObject: */
sqInt
isPositiveMachineIntegerObject(sqInt oop)
{
    sqInt ccIndex;
    int ok;

	if ((((oop) & 7) == 1)) {
		return ((oop >> 3)) >= 0;
	}
	if (((oop & (tagMask())) != 0)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	return ok
	 && ((numBytesOfBytes(oop)) <= (sizeof(usqIntptr_t)));
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static NoDbgRegParms sqInt
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int isSmall;
    int largeClassIndex;
    usqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes1;
    sqInt numSlots;
    sqInt objFormat;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
		? magnitude <= ((MaxSmallInteger) + 1)
		: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return (((usqInt)smallVal << 3) | 1);
	}
	largeClassIndex = (isNegative
		? ClassLargeNegativeIntegerCompactIndex
		: ClassLargePositiveIntegerCompactIndex);
	sz = 8;
	objFormat = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
	/* begin eeInstantiateSmallClassIndex:format:numBytes: */
	assert((sz >= 0)
	 && ((largeClassIndex != 0)
	 && ((knownClassAtIndex(largeClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(largeClassIndex))));
	numSlots = ((sz + BytesPerWord) - 1) / BytesPerWord;
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes1 = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes1 % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes1) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + largeClassIndex);
	GIV(freeStart) += numBytes1;
	newLargeInteger = newObj;
	l1:	/* end eeInstantiateSmallClassIndex:format:numBytes: */;
	/* begin storeLong64:ofObject:withValue: */
	long64Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude));
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or up to an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static NoDbgRegParms usqLong
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    usqInt numSlots;
    int ok;
    sqInt smallIntValue;
    sqInt sz;

	if ((((oop) & 7) == 1)) {
		smallIntValue = (oop >> 3);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return smallIntValue;
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex1 = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
usqIntptr_t
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    usqInt numSlots;
    int ok;
    sqInt value;

	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt)(integerResult)) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {
		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((arg & (tagMask())) != 0))
	 || ((GIV(argumentCount) > 1)
	 && ((((rcvr & (tagMask())) != 0))
	 || (!(objCouldBeClassObj(rcvr)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {
		/* Flush at cache because rcvr's class has changed. */
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		/* changeClassOf:to: answers errors as if rcvr (the class) is an argument... */
		if (err == PrimErrBadReceiver) {
			err = PrimErrBadArgument;
		}
		else {
			if (err == PrimErrBadArgument) {
				err = PrimErrBadReceiver;
			}
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = err;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	result = allInstancesOf(longAt(GIV(stackPointer)));
	if ((((result) & 7) == 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 3)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)));
		result = allInstancesOf(longAt(GIV(stackPointer)));
		if ((((result) & 7) == 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	result = allObjects();
	if ((((result) & 7) == 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 3)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)));
		result = allObjects();
		if ((((result) & 7) == 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Computes arctan of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	aValue = floatObjectOf(atan(doubleValue));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Invoke the two-way become primitive.
	We must at least flush the method cache here, to eliminate stale
	references to mutated classes and/or selectors.
	
	If in the CoInterpreter, we must deal with jitted methods being becommed.
	In the conception of the abstract VM,
	unless a CompiledMethod is becommed to one with equivalent bytecode
	contexts referring to the becommed
	method will likely fetch invalid bytecodes on resumption. The
	responsibility for validity here lies with the user of
	the become primitive, not the VM. So one could imagine checking for
	methods becomming equivalent methods
	and updating Cog methods to refer to their becommed duals. But that
	requires machinery to compare two
	compiled methods to check if their code is equivalent. A much simpler
	approach, which also gets the VM to fail
	in a less confusing place if it is going to fail because the programmer
	has not ensured compiled code validity
	across become, is to simply divorce all frames and map context pcs back to
	bytecode pcs when becomming
	jitted methods. However, mapping native pcs in contexts whose methods are
	flagged for become will not ensure
	that pcs are mapped reliably. Consider this arc: a context on a method
	that has been jitted exists with a native pc.
	The method is unjitted to make room for other methods to be jitted. The
	method is becommed. So the scan is only
	effective for methods in the jit. Slowing down become so that a rare case
	may fail more comprehensibly, when its
	going to fail anyway, is a waste of effort. So we do divorce frames (since
	machine code frames refer to CogMethods,
	not methods), but don't scan the entire heap looking for native pcs in
	contexts. Hence the primitive must be
	prepared to have its calling frame divorced. We store the context for the
	top frame in activeProcess.
	BTW, as of late '22/early '23 this is only done for Spur.
	See preBecomeAction: and postBecomeAction: */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0);
	primitiveBecomeReturn(ec);
}


/*	Invoke the one-way become primitive.
	See the comment in primitiveArrayBecome for handling pervasive effects on
	method cacheing and jitting. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	primitiveBecomeReturn(ec);
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's elements identity hashes over the argument's elements
	identity hashes.
	See the comment in primitiveArrayBecome for handling pervasive effects on
	method cacheing and jitting.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHashArg */
static void
primitiveArrayBecomeOneWayCopyHashArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag);
	primitiveBecomeReturn(ec);
}


/*	Similar to primitiveArrayBecomeOneWay but does /not/ copy the receiver's
	elements identity hashes over the argument's elements identity hashes.
	See the comment in primitiveArrayBecome for handling pervasive effects on
	method cacheing and jitting. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayNoCopyHash */
static void
primitiveArrayBecomeOneWayNoCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 0);
	primitiveBecomeReturn(ec);
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((((characterCode) & 7) == 1))
		 && (((characterCode = (characterCode >> 3)),
		/* begin isInRangeCharacterCode: */
((characterCode >= 0) && (characterCode <= (0x3FFFFFFF))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		return;
	}
	characterObject = 
	/* begin characterForAscii: */
(((sqInt)((usqInt)(characterCode) << (numTagBits())))) + (characterTag());
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((((rcvr) & 7) == 1));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), floatObjectOf(((double) ((rcvr >> 3)) )));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l6;
	}
	if (((!(index & (smallIntegerTag()))))
	 || ((GIV(argumentCount) > 1)
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l6;
	}
	index = (index >> 3);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l4;
	}
	totalLength = 0;
	l4:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l1;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l1;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l1:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = temporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l5;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, 
	/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l5;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l5;
		}
		if (fmt >= (firstShortFormat())) {
			result = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
			goto l5;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			result = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))));
			goto l5;
		}
		result = ((((((usqInt)(long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))))))) & 0xFFFFFFFFU) << 3) | 1);
		goto l5;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	result = 0;
	l5:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	l6:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class1;
    sqInt fixedFields1;
    usqLong fmt1;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp11;
    sqInt sp3;
    sqInt stSize1;
    sqInt totalLength1;
    usqLong unsigned64BitValueToStore1;
    unsigned int unsignedValueToStore1;
    sqInt value;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l15;
	}
	if (((!(index & (smallIntegerTag()))))
	 || ((GIV(argumentCount) > 2)
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l15;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l15;
	}
	index = (index >> 3);
	/* begin stObject:at:put: */
	hdr1 = long64At(rcvr);
	fmt1 = (((usqLong)(hdr1)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots11 = byteAt(rcvr + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt1 <= 5 /* begin ephemeronFormat */) {
		totalLength1 = numSlots2;
		goto l13;
	}
	if (fmt1 >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength1 = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
		goto l13;
	}
	if (fmt1 >= (firstShortFormat())) {
		totalLength1 = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l13;
	}
	if (fmt1 >= (firstLongFormat())) {
		totalLength1 = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l13;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		totalLength1 = numSlots2;
		goto l13;
	}
	totalLength1 = 0;
	l13:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 >= (sixtyFourBitIndexableFormat()))
	 || (fmt1 == (arrayFormat()))) {
		fixedFields1 = 0;
		goto l9;
	}
	if (fmt1 < (arrayFormat())) {
		fixedFields1 = totalLength1;
		goto l9;
	}
	class1 = fetchClassOfNonImm(rcvr);
	fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l9:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == (indexablePointersFormat()))
	 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(rcvr)));
			stSize1 = sp3;
			goto l12;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp11) & 7) == 1))) {
			stSize1 = 0;
			goto l12;
		}
		assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(rcvr)));
		stSize1 = (sp11 >> 3);
	l12:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize1))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			temporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l14;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, 
	/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt1 >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize1))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 5 /* begin lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(rcvr)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(value & (tagMask()))))
				 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))), value);
			goto l11;
		}
		if (fmt1 >= (firstByteFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l11;
			}
			signedValueToStore1 = (value >> 3);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l11;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
			goto l11;
		}
		if (fmt1 >= (firstShortFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l11;
			}
			signedValueToStore1 = (value >> 3);
			if (!((signedValueToStore1 >= 0)
				 && (signedValueToStore1 <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l11;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 1))), signedValueToStore1);
			goto l11;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			unsigned64BitValueToStore1 = positive64BitValueOf(value);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 3))), unsigned64BitValueToStore1);
			}
			goto l11;
		}
		unsignedValueToStore1 = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
		}
	l11:;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
	}
	l14:	/* end stObject:at:put: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
	l15:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		successBoolean = (		/* begin isPointers: */
			((!(cursorObj & (tagMask()))))
		 && (((((usqInt)((longAt(cursorObj)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((lengthOf(cursorObj)) >= 5);
		if (!successBoolean) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0U << (shiftForWord())));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4U << (shiftForWord())));
		successBoolean1 = (		/* begin isPointers: */
			((!(offsetObj & (tagMask()))))
		 && (((((usqInt)((longAt(offsetObj)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((lengthOf(offsetObj)) >= 2);
		if (!successBoolean1) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {
			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */
			successBoolean2 = (extentX > 0)
			 && (extentY > 0);
			/* begin success: */
			if (!successBoolean2) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean3 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			/* begin success: */
			if (!successBoolean3) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean4 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			/* begin success: */
			if (!successBoolean4) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean5 = (			/* begin isWords: */
				((!(bitsObj & (tagMask()))))
			 && (((((((usqInt)((longAt(bitsObj)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(bitsObj)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1)))))
			 && ((lengthOf(bitsObj)) == (extentX * extentY));
			if (!successBoolean5) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
		else {
			successBoolean6 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			/* begin success: */
			if (!successBoolean6) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean7 = (offsetX >= -16)
			 && (offsetX <= 0);
			/* begin success: */
			if (!successBoolean7) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean8 = (offsetY >= -16)
			 && (offsetY <= 0);
			/* begin success: */
			if (!successBoolean8) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean9 = (			/* begin isWords: */
				((!(bitsObj & (tagMask()))))
			 && (((((((usqInt)((longAt(bitsObj)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(bitsObj)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1)))))
			 && ((lengthOf(bitsObj)) == 16);
			if (!successBoolean9) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (GIV(argumentCount) == 1) {
		successBoolean10 = (		/* begin isPointers: */
			((!(maskObj & (tagMask()))))
		 && (((((usqInt)((longAt(maskObj)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((lengthOf(maskObj)) >= 5);
		if (!successBoolean10) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0U << (shiftForWord())));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			successBoolean11 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			/* begin success: */
			if (!successBoolean11) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean12 = (			/* begin isWords: */
				((!(bitsObj & (tagMask()))))
			 && (((((((usqInt)((longAt(bitsObj)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(bitsObj)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1)))))
			 && ((lengthOf(bitsObj)) == 16);
			if (!successBoolean12) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					};
					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable,
	and if possible pin the display bitmap. Further, invoke ioBeDisplay
	to alow the VM to record the location, width heigth & depth of the bitmap. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsOop;
    void *bitsOrHandle;
    sqInt depthOop;
    sqInt heightOop;
    sqInt objOop;
    sqInt rcvr;
    sqInt widthOop;

	rcvr = longAt(GIV(stackPointer));
	if (!((		/* begin isPointers: */
			((!(rcvr & (tagMask()))))
		 && (((((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && (((lengthOf(rcvr)) >= 4)
		 && (((bitsOop = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())))),
		((			/* begin isWordsOrBytes: */
				((!(bitsOop & (tagMask()))))
			 && (isWordsOrBytesNonImm(bitsOop)))
			 || ((((bitsOop) & 7) == 1)))
			 && (((((((widthOop = longAt((rcvr + BaseHeaderSize) + (1U << (shiftForWord())))))) & 7) == 1))
			 && (((((((heightOop = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord())))))) & 7) == 1))
			 && ((((((depthOop = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord())))))) & 7) == 1))))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	/* begin splObj:put: */
	objOop = GIV(specialObjectsOop);
	assert(!(isForwarded(objOop)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(objOop)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(rcvr & (tagMask()))))
		 && (oopisLessThan(rcvr, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop);
			}
		}
	}
	longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord())))), rcvr);
	if (((!(bitsOop & (tagMask()))))
	 && (!(((((usqInt)((longAt(bitsOop)))) >> (pinnedBitShift())) & 1) != 0))) {
		/* Answers 0 if memory required to pin but not enough memory available. */
		rcvr = pinObject(bitsOop);
		if (rcvr != 0) {
			bitsOop = rcvr;
		}
	}
	if ((!(bitsOop & (tagMask())))) {
		bitsOrHandle = firstIndexableField(bitsOop);
	}
	else {
		bitsOrHandle = ((void *)bitsOop);
	}
	/* begin ioBeDisplay:width:height:depth: */
	displayBits = bitsOrHandle;
	displayWidth = (widthOop >> 3);
	displayHeight = (heightOop >> 3);
	displayDepth = (depthOop >> 3);
	ioNoteDisplayChangedwidthheightdepth(bitsOrHandle, (widthOop >> 3), (heightOop >> 3), (depthOop >> 3));
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(void)
{
	ioBeep();
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt err;
    sqInt hash;
    sqInt hashOrError;
    char *sp;

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(longAt(GIV(stackPointer))));
	flag("todo");
	hashOrError = (((hash = (long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(longAt(GIV(stackPointer)))
				? (((err = enterIntoClassTable(longAt(GIV(stackPointer))))) != 0
						? -err
						: (long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)hashOrError << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -hashOrError;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt fmt1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    usqInt numSlots;
    usqInt numSlots1;
    int ok;
    int ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;

	oop1 = longAt(GIV(stackPointer));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop1) & 7) == 1)) {
		value = (oop1 >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l3;
	}
	if (((oop1 & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1)));
	ccIndex = (longAt(oop1)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l3;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop1)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop1)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l3;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop1 + BaseHeaderSize))))));
		goto l3;
	}
	integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize))))))));
	l3:	/* end positiveMachineIntegerValueOf: */;
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop2) & 7) == 1)) {
		value1 = (oop2 >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l6;
	}
	if (((oop2 & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l6;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop2)));
	ccIndex1 = (longAt(oop2)) & (classIndexMask());
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l6;
	}
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt)((longAt(oop2)))) >> (formatShift())) & (formatMask());
	assert(fmt1 >= (firstByteFormat()));
	bs1 = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop2)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(oop2 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop2 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt1 & 7);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l6;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop2 + BaseHeaderSize))))));
		goto l6;
	}
	integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize))))))));
	l6:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		oop = positiveMachineIntegerFor(integerArgumentValue & integerReceiverValue);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt fmt1;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    usqInt numSlots;
    usqInt numSlots1;
    int ok;
    int ok1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    sqInt value;
    sqInt value1;

	oop1 = longAt(GIV(stackPointer));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop1) & 7) == 1)) {
		value = (oop1 >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l3;
	}
	if (((oop1 & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1)));
	ccIndex = (longAt(oop1)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l3;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop1)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop1)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l3;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop1 + BaseHeaderSize))))));
		goto l3;
	}
	integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop1 + BaseHeaderSize))))))));
	l3:	/* end positiveMachineIntegerValueOf: */;
	oop2 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop2) & 7) == 1)) {
		value1 = (oop2 >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) value1);
		goto l6;
	}
	if (((oop2 & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l6;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop2)));
	ccIndex1 = (longAt(oop2)) & (classIndexMask());
	ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	if (!ok1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l6;
	}
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt)((longAt(oop2)))) >> (formatShift())) & (formatMask());
	assert(fmt1 >= (firstByteFormat()));
	bs1 = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop2)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(oop2 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop2 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt1 & 7);
	if (bs1 > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l6;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs1 > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop2 + BaseHeaderSize))))));
		goto l6;
	}
	integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop2 + BaseHeaderSize))))))));
	l6:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		oop = positiveMachineIntegerFor(integerArgumentValue | integerReceiverValue);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt shifted;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	if (!((((integerArgument) & 7) == 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = signed64BitValueOf(integerReceiver);
	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 3))) >= 0) {
			/* Left shift -- must fail bits would be lost */
			if (!(integerArgument <= 61 /* begin numSmallIntegerBits */)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
			if (!(integerReceiver == ((shifted) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {
			/* Right shift -- OK to lose bits */
			if (!(integerArgument >= (-61 /* begin numSmallIntegerBits */))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = (integerReceiver) >> (0 - integerArgument);
		}
		shifted = ((((((usqInt)(shifted)) >> 60) + 1) & 15) <= 1
			? (((usqInt)shifted << 3) | 1)
			: signed64BitIntegerFor(shifted));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		shift = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
	}
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {
		/* Protect against overflow */
		/* This is to avoid undue (usqInt) cast */
		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > ((result) >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = (a) >> shift;
		}
		if (aIsNegative
		 && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt bs1;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt fmt1;
    sqInt integerArgument;
    usqInt integerArgumentValue;
    sqInt integerReceiver;
    usqInt integerReceiverValue;
    usqInt numSlots;
    usqInt numSlots1;
    int ok;
    int ok1;
    sqInt oop;
    sqInt oop1;
    char *sp;
    char *sp1;
    sqInt value;
    sqInt value1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((((integerArgument) & 7) == 1))
	 && ((((integerReceiver) & 7) == 1))) {
		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */
		oop = (integerArgument ^ integerReceiver) + (smallIntegerTag());
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin positiveMachineIntegerValueOf: */
		if ((((integerArgument) & 7) == 1)) {
			value = (integerArgument >> 3);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerArgumentValue = ((usqIntptr_t) null);
				goto l3;
			}
			integerArgumentValue = ((usqIntptr_t) value);
			goto l3;
		}
		if (((integerArgument & (tagMask())) != 0)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l3;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(integerArgument)));
		ccIndex = (longAt(integerArgument)) & (classIndexMask());
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l3;
		}
		/* begin numBytesOfBytes: */
		fmt = (((usqInt)((longAt(integerArgument)))) >> (formatShift())) & (formatMask());
		assert(fmt >= (firstByteFormat()));
		bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(integerArgument)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(integerArgument + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(integerArgument - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l3;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((integerArgument + BaseHeaderSize))))));
			goto l3;
		}
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerArgument + BaseHeaderSize))))))));
	l3:	/* end positiveMachineIntegerValueOf: */;
		/* begin positiveMachineIntegerValueOf: */
		if ((((integerReceiver) & 7) == 1)) {
			value1 = (integerReceiver >> 3);
			if (value1 < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerReceiverValue = ((usqIntptr_t) null);
				goto l6;
			}
			integerReceiverValue = ((usqIntptr_t) value1);
			goto l6;
		}
		if (((integerReceiver & (tagMask())) != 0)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l6;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(integerReceiver)));
		ccIndex1 = (longAt(integerReceiver)) & (classIndexMask());
		ok1 = ClassLargePositiveIntegerCompactIndex == ccIndex1;
		if (!ok1) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l6;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt)((longAt(integerReceiver)))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		bs1 = (((/* begin numSlotsOf: */
	assert((classIndexOf(integerReceiver)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(integerReceiver + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(integerReceiver - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt1 & 7);
		if (bs1 > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l6;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs1 > 4)) {
			integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((integerReceiver + BaseHeaderSize))))));
			goto l6;
		}
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerReceiver + BaseHeaderSize))))))));
	l6:	/* end positiveMachineIntegerValueOf: */;
		if (!GIV(primFailCode)) {
			oop1 = positiveMachineIntegerFor(integerArgumentValue ^ integerReceiverValue);
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Answer the encoder names for the supported bytecode sets. */

	/* InterpreterPrimitives>>#primitiveBytecodeSetsAvailable */
EXPORT(sqInt)
primitiveBytecodeSetsAvailable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt encoderNames;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	if (GIV(argumentCount) > 0) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	encoderNames = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), 3);
	valuePointer = stringForCString("EncoderForV3");
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(encoderNames)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(encoderNames)),
	oopisGreaterThanOrEqualTo(encoderNames, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer & (tagMask()))))
		 && (oopisLessThan(valuePointer, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(encoderNames)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(encoderNames);
			}
		}
	}
	longAtput((encoderNames + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
	valuePointer1 = stringForCString("EncoderForV3PlusClosures");
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(encoderNames)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(encoderNames)),
	oopisGreaterThanOrEqualTo(encoderNames, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer1 & (tagMask()))))
		 && (oopisLessThan(valuePointer1, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(encoderNames)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(encoderNames);
			}
		}
	}
	longAtput((encoderNames + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer1);
	valuePointer2 = stringForCString("EncoderForSistaV1");
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(encoderNames)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(encoderNames)),
	oopisGreaterThanOrEqualTo(encoderNames, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer2 & (tagMask()))))
		 && (oopisLessThan(valuePointer2, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(encoderNames)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(encoderNames);
			}
		}
	}
	longAtput((encoderNames + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer2);
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), encoderNames);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt chunk;
    sqInt freeChunk;
    sqInt i;
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) == 0) {
		/* old behavior - just return the size of free memory */
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), ((GIV(totalFreeOldSpace) << 3) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		/* Spur behavior; if argument is nil answer size of largest free chunk in oldSpace. */
		if ((longAt(GIV(stackPointer))) == GIV(nilObj)) {
			/* begin sizeOfLargestFreeChunk */
			freeChunk = findLargestFreeChunk();
			if (!freeChunk) {
				for (i = 0x3F; i >= 1; i += -1) {
					chunk = GIV(freeLists)[i];
					if (!(chunk == null)) {
						integerVal = bytesInBody(chunk);
						goto l2;
					}
				}
				integerVal = 0;
				goto l2;
			}
			integerVal = bytesInBody(freeChunk);
	l2:	/* end sizeOfLargestFreeChunk */;
			/* begin pop:thenPushInteger: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			integerVal1 = ((((GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart))) - (interpreterAllocationReserveBytes())) < 0) ? 0 : ((GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart))) - (interpreterAllocationReserveBytes())));
			/* begin pop:thenPushInteger: */
			longAtput((sp2 = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)integerVal1 << 3) | 1));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */
/*	Manually copied from primitiveCalloutAccessorDepth in the
	ThreadedFFIPlugins... 
 */
/*	since call may invoke a callback */
/*	since call signature is in first literal... */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*primitiveCallout)(void);


	/* begin functionForPrimitiveCallout */
	if ((((sqInt)primitiveCalloutPointer)) == -1) {
		reloadPrimitiveCalloutPointer();
	}
	primitiveCallout = ((void (*)(void)) primitiveCalloutPointer);
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		dispatchFunctionPointer(primitiveCallout);
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt err;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;


	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
	l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((oop1 & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
	l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	argClass = fetchClassOfNonImm(arg);
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {
		/* Flush at cache because rcvr's class has changed. */
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = err;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    sqInt oop;
    char *sp;
    sqInt tagBits;

	instance = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 0)
	 && (	/* begin isOopForwarded: */
		((!(instance & (tagMask()))))
	 && ((!((longAt(instance)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		oop = 
		/* begin fetchClassOf: */
(((tagBits = instance & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
			: fetchClassOfNonImm(instance));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(			/* begin isBytes: */
				((!(s & (tagMask()))))
			 && (((((usqInt)((longAt(s)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			/* begin numBytesOfBytes: */
			fmt = (((usqInt)((longAt(s)))) >> (formatShift())) & (formatMask());
			assert(fmt >= (firstByteFormat()));
			sz = (((/* begin numSlotsOf: */
	assert((classIndexOf(s)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(s + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(s - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		/* begin allocateBytes:classIndex: */
		assert(addressCouldBeClassObj(classAtIndex(ClassByteStringCompactIndex)));
		assert((instSpecOfClass(classAtIndex(ClassByteStringCompactIndex))) == (firstByteFormat()));
		s = noInlineAllocateSlotsformatclassIndex(((sz + BytesPerOop) - 1) / BytesPerOop, byteFormatForNumBytes(sz), ClassByteStringCompactIndex);
		if (!s) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;


	/* bypass type inference which would deduce int */
	midx = 0;
	msecs = ((void *) 0);
	uidx = 0;
	usecs = ((void *) 0);
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)runInNOut << 3) | 1));
	v1 = ((((((usqInt)(((usqInt)usecs)))) & 0xFFFFFFFFU) << 3) | 1);
	v2 = ((((((usqInt)(((usqInt)msecs)))) & 0xFFFFFFFFU) << 3) | 1);
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	objOop = GIV(remapBuffer)[GIV(remapBufferCount)];
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(objOop)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(objOop)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(v1 & (tagMask()))))
		 && (oopisLessThan(v1, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop);
			}
		}
	}
	longAtput((objOop + BaseHeaderSize) + (1U << (shiftForWord())), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (2U << (shiftForWord())), (((usqInt)uidx << 3) | 1));
	objOop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(objOop1)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(objOop1)),
	oopisGreaterThanOrEqualTo(objOop1, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(v2 & (tagMask()))))
		 && (oopisLessThan(v2, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(objOop1)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop1);
			}
		}
	}
	longAtput((objOop1 + BaseHeaderSize) + (3U << (shiftForWord())), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (4U << (shiftForWord())), (((usqInt)midx << 3) | 1));
	/* begin popRemappableOop */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt i;
    int inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    sqInt object;
    sqInt object1;
    sqInt object11;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfClosure: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(		/* begin isContext: */
			((!(outerContext & (tagMask()))))
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(		/* begin isOopCompiledMethod: */
			((!(closureMethod & (tagMask()))))
		 && (((((usqInt)((longAt(closureMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	assert(isVanillaBlockClosure(blockClosure));
	numCopied = ((/* begin numSlotsOf: */
	assert((classIndexOf(blockClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(blockClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(blockClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		/* begin executeCogBlock:closure:mayContextSwitch: */
		assertCStackWellAligned();
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* invoked directly from the interpreter */
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			object = ceReturnToInterpreterPC();
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp;
		}
		else {
			/* instructionPointer == cogit ceReturnToInterpreterPC
			   ifTrue: [invoked from the interpreter via a machine code primitive]
			   ifFalse: [invoked from machine code].
			   If in the first case the bytecode instructionPointer has already been
			   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp1;
		}
		object1 = (((sqInt)cogMethod)) + ((cogMethod->blockEntryOffset));
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), blockClosure);
		GIV(stackPointer) = sp3;
		ceCallCogCodePopReceiverReg();
		goto l6;
	}
	if (((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
		if ((GIV(instructionPointer) < (startOfMemory()))
		 || (closureMethod == GIV(lastCoggableInterpretedBlockMethod))) {
			/* If from interpreter and repeat block, attempt jitting */
			if (closureMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogselector(closureMethod, GIV(nilObj));
				if (methodHasCogMethod(closureMethod)) {
					/* begin cogMethodOf: */
					methodHeader2 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					assert((isNonImmediate(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					/* begin executeCogBlock:closure:mayContextSwitch: */
					assertCStackWellAligned();
					assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
					if (GIV(instructionPointer) >= (startOfMemory())) {
						/* invoked directly from the interpreter */
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						object2 = ceReturnToInterpreterPC();
						/* begin push: */
						longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object2);
						GIV(stackPointer) = sp4;
					}
					else {
						/* instructionPointer == cogit ceReturnToInterpreterPC
						   ifTrue: [invoked from the interpreter via a machine code primitive]
						   ifFalse: [invoked from machine code].
						   If in the first case the bytecode instructionPointer has already been
						   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
						/* begin push: */
						longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
						GIV(stackPointer) = sp11;
					}
					object11 = (((sqInt)cogMethod1)) + ((cogMethod1->blockEntryOffset));
					/* begin push: */
					longAtput((sp21 = GIV(stackPointer) - BytesPerWord), object11);
					GIV(stackPointer) = sp21;
					/* begin push: */
					longAtput((sp31 = GIV(stackPointer) - BytesPerWord), blockClosure);
					GIV(stackPointer) = sp31;
					ceCallCogCodePopReceiverReg();
					goto l6;
				}
				if (!GIV(cogCompiledCodeCompactionCalledFor)) {
					GIV(lastUncoggableInterpretedBlockMethod) = closureMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = closureMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(closureMethod);
	}
	assert(!(methodHasCogMethod(closureMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	object3 = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0x1000000));
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp10;
	/* begin followField:ofObject: */
	objOop = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext, objOop);
	}
	object4 = objOop;
	/* begin push: */
	longAtput((sp12 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp12;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp13 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp13;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod:methodHeader: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
		? 0x100
		: 0);
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(1);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
	l6:	/* end activateNewClosure:outer:method:numArgs:mayContextSwitch: */;
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt i;
    int inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    sqInt object;
    sqInt object1;
    sqInt object11;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfClosure: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(		/* begin isContext: */
			((!(outerContext & (tagMask()))))
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(		/* begin isOopCompiledMethod: */
			((!(closureMethod & (tagMask()))))
		 && (((((usqInt)((longAt(closureMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	assert(isVanillaBlockClosure(blockClosure));
	numCopied = ((/* begin numSlotsOf: */
	assert((classIndexOf(blockClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(blockClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(blockClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		/* begin executeCogBlock:closure:mayContextSwitch: */
		assertCStackWellAligned();
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* invoked directly from the interpreter */
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			object = ceReturnToInterpreterPC();
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp;
		}
		else {
			/* instructionPointer == cogit ceReturnToInterpreterPC
			   ifTrue: [invoked from the interpreter via a machine code primitive]
			   ifFalse: [invoked from machine code].
			   If in the first case the bytecode instructionPointer has already been
			   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp1;
		}
		object1 = (((sqInt)cogMethod)) + (((cogMethod->blockEntryOffset)) - (noContextSwitchBlockEntryOffset()));
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), blockClosure);
		GIV(stackPointer) = sp3;
		ceCallCogCodePopReceiverReg();
		goto l6;
	}
	if (((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
		if ((GIV(instructionPointer) < (startOfMemory()))
		 || (closureMethod == GIV(lastCoggableInterpretedBlockMethod))) {
			/* If from interpreter and repeat block, attempt jitting */
			if (closureMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogselector(closureMethod, GIV(nilObj));
				if (methodHasCogMethod(closureMethod)) {
					/* begin cogMethodOf: */
					methodHeader2 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					assert((isNonImmediate(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					/* begin executeCogBlock:closure:mayContextSwitch: */
					assertCStackWellAligned();
					assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
					if (GIV(instructionPointer) >= (startOfMemory())) {
						/* invoked directly from the interpreter */
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						object2 = ceReturnToInterpreterPC();
						/* begin push: */
						longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object2);
						GIV(stackPointer) = sp4;
					}
					else {
						/* instructionPointer == cogit ceReturnToInterpreterPC
						   ifTrue: [invoked from the interpreter via a machine code primitive]
						   ifFalse: [invoked from machine code].
						   If in the first case the bytecode instructionPointer has already been
						   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
						/* begin push: */
						longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
						GIV(stackPointer) = sp11;
					}
					object11 = (((sqInt)cogMethod1)) + (((cogMethod1->blockEntryOffset)) - (noContextSwitchBlockEntryOffset()));
					/* begin push: */
					longAtput((sp21 = GIV(stackPointer) - BytesPerWord), object11);
					GIV(stackPointer) = sp21;
					/* begin push: */
					longAtput((sp31 = GIV(stackPointer) - BytesPerWord), blockClosure);
					GIV(stackPointer) = sp31;
					ceCallCogCodePopReceiverReg();
					goto l6;
				}
				if (!GIV(cogCompiledCodeCompactionCalledFor)) {
					GIV(lastUncoggableInterpretedBlockMethod) = closureMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = closureMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(closureMethod);
	}
	assert(!(methodHasCogMethod(closureMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	object3 = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0x1000000));
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp10;
	/* begin followField:ofObject: */
	objOop = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext, objOop);
	}
	object4 = objOop;
	/* begin push: */
	longAtput((sp12 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp12;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp13 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp13;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod:methodHeader: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
		? 0x100
		: 0);
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(0);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
	l6:	/* end activateNewClosure:outer:method:numArgs:mayContextSwitch: */;
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt i;
    sqInt index;
    int inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt object;
    sqInt object1;
    sqInt object11;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(		/* begin isArray: */
			((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	arraySize = (((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfClosure: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(		/* begin isContext: */
			((!(outerContext & (tagMask()))))
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(		/* begin isOopCompiledMethod: */
			((!(closureMethod & (tagMask()))))
		 && (((((usqInt)((longAt(closureMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	assert(isVanillaBlockClosure(blockClosure));
	numCopied = ((/* begin numSlotsOf: */
	assert((classIndexOf(blockClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(blockClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(blockClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		/* begin executeCogBlock:closure:mayContextSwitch: */
		assertCStackWellAligned();
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* invoked directly from the interpreter */
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			object = ceReturnToInterpreterPC();
			/* begin push: */
			longAtput((sp14 = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp14;
		}
		else {
			/* instructionPointer == cogit ceReturnToInterpreterPC
			   ifTrue: [invoked from the interpreter via a machine code primitive]
			   ifFalse: [invoked from machine code].
			   If in the first case the bytecode instructionPointer has already been
			   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp1;
		}
		object1 = (((sqInt)cogMethod)) + ((cogMethod->blockEntryOffset));
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), blockClosure);
		GIV(stackPointer) = sp3;
		ceCallCogCodePopReceiverReg();
		goto l7;
	}
	if (((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
		if ((GIV(instructionPointer) < (startOfMemory()))
		 || (closureMethod == GIV(lastCoggableInterpretedBlockMethod))) {
			/* If from interpreter and repeat block, attempt jitting */
			if (closureMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogselector(closureMethod, GIV(nilObj));
				if (methodHasCogMethod(closureMethod)) {
					/* begin cogMethodOf: */
					methodHeader2 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					assert((isNonImmediate(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					/* begin executeCogBlock:closure:mayContextSwitch: */
					assertCStackWellAligned();
					assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
					if (GIV(instructionPointer) >= (startOfMemory())) {
						/* invoked directly from the interpreter */
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						object2 = ceReturnToInterpreterPC();
						/* begin push: */
						longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object2);
						GIV(stackPointer) = sp4;
					}
					else {
						/* instructionPointer == cogit ceReturnToInterpreterPC
						   ifTrue: [invoked from the interpreter via a machine code primitive]
						   ifFalse: [invoked from machine code].
						   If in the first case the bytecode instructionPointer has already been
						   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
						/* begin push: */
						longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
						GIV(stackPointer) = sp11;
					}
					object11 = (((sqInt)cogMethod1)) + ((cogMethod1->blockEntryOffset));
					/* begin push: */
					longAtput((sp21 = GIV(stackPointer) - BytesPerWord), object11);
					GIV(stackPointer) = sp21;
					/* begin push: */
					longAtput((sp31 = GIV(stackPointer) - BytesPerWord), blockClosure);
					GIV(stackPointer) = sp31;
					ceCallCogCodePopReceiverReg();
					goto l7;
				}
				if (!GIV(cogCompiledCodeCompactionCalledFor)) {
					GIV(lastUncoggableInterpretedBlockMethod) = closureMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = closureMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(closureMethod);
	}
	assert(!(methodHasCogMethod(closureMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	object3 = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0x1000000));
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp10;
	/* begin followField:ofObject: */
	objOop = longAt((outerContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext, objOop);
	}
	object4 = objOop;
	/* begin push: */
	longAtput((sp12 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp12;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp13 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp13;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((((oop1) & 7) == 1));
	closureIP = (oop1 >> 3);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod:methodHeader: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
		? 0x100
		: 0);
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(1);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
	l7:	/* end activateNewClosure:outer:method:numArgs:mayContextSwitch: */;
}


/*	Return the value of the microsecond clock in the local timezone, as
	updated by the heartbeat, as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseLocalMicrosecondClock */
static void
primitiveCoarseLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioLocalMicroseconds());
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the microsecond clock as updated by the heartbeat as
	an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseUTCMicrosecondClock */
static void
primitiveCoarseUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioUTCMicroseconds());
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(sqInt)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt fmt;
    sqInt i;
    sqInt len;
    usqInt numSlots;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* Quick identity test */
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (arg1 == arg2) {
		/* begin methodReturnBool: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return 0;
	}
	if (!((		/* begin isBytes: */
			((!(arg1 & (tagMask()))))
		 && (((((usqInt)((longAt(arg1)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
		 && (((!(arg2 & (tagMask()))))
		 && (((((usqInt)((longAt(arg2)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(arg1)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	len = (((/* begin numSlotsOf: */
	assert((classIndexOf(arg1)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(arg1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(arg1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (!(len == (numBytesOfBytes(arg2)))) {
		/* begin methodReturnBool: */
		assert(!((failed())));
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return 0;
	}
	for (i = 0; i < len; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin methodReturnBool: */
			assert(!((failed())));
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return 0;
		}
	}
	/* begin methodReturnBool: */
	assert(!((failed())));
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
	return 0;
}


/*	<string1> primitiveCompareWith: string2 [collated: order] */
/*	1 - fetch the parameters from the stack */

	/* InterpreterPrimitives>>#primitiveCompareWith */
EXPORT(void)
primitiveCompareWith(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt c1;
    sqInt c11;
    sqInt c2;
    sqInt c21;
    sqInt fmt;
    sqInt fmt1;
    sqInt i;
    sqInt i1;
    sqInt index;
    sqInt min;
    sqInt min1;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt order;
    sqInt result;
    char *sp;
    sqInt str;
    sqInt string1;
    sqInt string2;
    sqInt strLength1;
    sqInt strLength2;

	index = 0;
	order = 0;
	str = 0;
	if (!(GIV(argumentCount) == 1)) {
		if (GIV(argumentCount) != 2) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		order = longAt(GIV(stackPointer));
		if (!((			/* begin isBytes: */
				((!(order & (tagMask()))))
			 && (((((usqInt)((longAt(order)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
			 && ((numBytesOfBytes(order)) == 0x100))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	string1 = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* 2 - check their types - all parameters are ByteObject */
	string2 = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	if (!((		/* begin isBytes: */
			((!(string1 & (tagMask()))))
		 && (((((usqInt)((longAt(string1)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
		 && (((!(string2 & (tagMask()))))
		 && (((((usqInt)((longAt(string2)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(string1)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	strLength1 = (((/* begin numSlotsOf: */
	assert((classIndexOf(string1)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(string1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(string1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt)((longAt(string2)))) >> (formatShift())) & (formatMask());
	assert(fmt1 >= (firstByteFormat()));
	strLength2 = (((/* begin numSlotsOf: */
	assert((classIndexOf(string2)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(string2 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(string2 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt1 & 7);
	if (order == null) {
		/* begin rawCompare:length:with:length:accessBlock: */
		min = ((strLength1 < strLength2) ? strLength1 : strLength2);
		for (i = 0; i < min; i += 1) {
			c1 = byteAt((string1 + BaseHeaderSize) + i);
			c2 = byteAt((string2 + BaseHeaderSize) + i);
			if (!(c1 == c2)) {
				result = c1 - c2;
				goto l3;
			}
		}
		result = strLength1 - strLength2;
	l3:	/* end rawCompare:length:with:length:accessBlock: */;
	}
	else {
		/* begin rawCompare:length:with:length:accessBlock: */
		min1 = ((strLength1 < strLength2) ? strLength1 : strLength2);
		for (i1 = 0; i1 < min1; i1 += 1) {
			c11 = byteAt((order + BaseHeaderSize) + ((byteAt((string1 + BaseHeaderSize) + i1)) + 1));
			c21 = byteAt((order + BaseHeaderSize) + ((byteAt((string2 + BaseHeaderSize) + i1)) + 1));
			if (!(c11 == c21)) {
				result = c11 - c21;
				goto l4;
			}
		}
		result = strLength1 - strLength2;
	l4:	/* end rawCompare:length:with:length:accessBlock: */;
	}
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)result << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Fill the receiver, which must be an indexable non-pointer
	object, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    usqLong fillValue;
    sqInt format;
    usqInt i;
    sqInt oddBytes;
    sqInt rcvr;


	/* begin primitiveConstantFillSpur */
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l2;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((!(rcvr & (tagMask()))))
		 && (((format = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask()))) >= (sixtyFourBitIndexableFormat())))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l2;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l2;
	}
	fillValue = positive64BitValueOf(longAt(GIV(stackPointer)));
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l2;
	}
	if (format >= (firstShortFormat())) {
		if (format >= (firstByteFormat())) {
			if ((fillValue > 0xFF)
			 || (format >= (firstCompiledMethodFormat()))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = (fillValue > 0xFF
					? PrimErrBadArgument
					: PrimErrBadReceiver);
				goto l2;
			}
			fillValue = ((fillValue + (fillValue << 8)) + (fillValue << 16)) + (fillValue << 24);
			oddBytes = format & 7;
		}
		else {
			if (fillValue > 0xFFFF) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}
			fillValue += fillValue << 16;
			oddBytes = ((sqInt)((usqInt)((format & 3)) << 1));
		}
		fillValue += fillValue << 32;
	}
	else {
		if (format == (sixtyFourBitIndexableFormat())) {
			oddBytes = 0;
		}
		else {
			if (fillValue > 0xFFFFFFFFU) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}
			fillValue += fillValue << 32;
			oddBytes = ((sqInt)((usqInt)((format & 1)) << 2));
		}
	}
	end = addressAfter(rcvr);
	i = rcvr + BaseHeaderSize;
	while (i < end) {
		long64Atput(i, fillValue);
		i += 8;
	}
	if (oddBytes > 0) {
		flag("endianness");
		fillValue = (fillValue) >> (8 * oddBytes);
		long64Atput(i - 8, fillValue);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	l2:	/* end primitiveConstantFillSpur */;
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((((bufferSize) & 7) == 1))
			 && (((bufferSize = (bufferSize >> 3))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((2) * BytesPerWord)), (((usqInt)numSamples << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt fmt;
    sqInt i;
    usqInt length;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (((arg & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((longAt(rcvr)) & (classIndexMask())) != ((longAt(arg)) & (classIndexMask()))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (isWordsOrBytesNonImm(rcvr)) {
		/* begin numBytesOf: */
		fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numBytes = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		numBytes = numBytes << (shiftForWord());
		if (fmt >= (firstByteFormat())) {
			/* bytes (the common case), including CompiledMethod */
			length = numBytes - (fmt & 7);
			goto l1;
		}
		if (fmt <= (sixtyFourBitIndexableFormat())) {
			length = ((sqInt) numBytes);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			length = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
			goto l1;
		}
		length = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l1:	/* end numBytesOf: */;
		if (!((((((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask())) == ((((usqInt)((longAt(arg)))) >> (formatShift())) & (formatMask())))
			 && (length == (numBytesOf(arg))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		length = (((numSlots = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		if (!((isAppropriateForCopyObject(arg))
			 && (length == (lengthOf(arg))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		for (i = 0; i < length; i += 1) {
			valuePointer = longAt((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(rcvr)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(valuePointer & (tagMask()))))
				 && (oopisLessThan(valuePointer, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Computes cosine of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveCosine */
static void
primitiveCosine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	aValue = floatObjectOf(cos(doubleValue));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((((longAt(GIV(stackPointer)))) & 7) == 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 3);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		integer = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
	}
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt)(quotient)) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)quotient << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		integerReceiver = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		integerArgument = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
	}
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((((usqInt)((integerReceiver / integerArgument))) >> 60) + 1) & 15) <= 1) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)(integerReceiver / integerArgument) << 3) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				};
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			/* Round toward negative infinity */
			rem = a % b;
			if (!(rem == 0)) {
				/* This can not overflow, because b > 1, otherwise rem = 0 */
				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerReceiver & integerArgument) & (smallIntegerTag())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerReceiver == integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (signed64BitValueOf(integerReceiver)) == (signed64BitValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power.
	Receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	aValue = floatObjectOf(exp(doubleValue));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Exponent part of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    double doubleValue;
    int pwr;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	pwr = 0;
	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	frexp(doubleValue, (&pwr));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), (((usqInt)(pwr - 1) << 3) | 1));
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set PrimErrFFIException primitive failure and associated exceptionCode
	(a.k.a. 
	secondaryErrorCode) and exceptionPC. Under control of the
	ffiExceptionResponse flag,
	if in a primitive with an error code and ffiCalloutVMHandle indicates
	we're in an FFI call,
	then fail the primitive.
	ffiExceptionResponse < 0 never fail
	ffiExceptionResponse = 0 fail if method has a primitive error code
	(default) ffiExceptionResponse > 0 always fail */

	/* InterpreterPrimitives>>#primitiveFailForFFIException:at: */
sqInt
primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    CogMethod *cogMethod;
    sqInt i;
    usqInt initialIP;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;

	if ((!GIV(ffiCalloutVMHandle))
	 || (ffiExceptionResponse < 0)) {
		/* i.e. never fail */
		return 0;
	}
	GIV(secondaryErrorCode) = ((sqLong) exceptionCode);
	GIV(exceptionPC) = pc;
	GIV(primFailCode) = PrimErrFFIException;
	if ((ffiExceptionResponse > 0)
	 || ((	/* begin isOopCompiledMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && (methodUsesPrimitiveErrorCode(GIV(newMethod))))) {
		ownVM(GIV(ffiCalloutVMHandle));
		/* begin activateFailingPrimitiveMethod */
		assert(GIV(primFailCode) != 0);
		assert(addressCouldBeObj(GIV(newMethod)));
		assert(isCompiledMethod(GIV(newMethod)));
		assert((primitiveIndexOf(GIV(newMethod))) != 0);
		/* begin justActivateNewMethod: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		cogMethod = null;
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			cogMethod = ((CogMethod *) methodHeader);
			methodHeader = (cogMethod->methodHeader);
			cogMethod = null;
		}
		numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
		numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;
		/* could new rcvr be set at point of send? */
		rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr)));
		if ((cogMethod)
		 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())))) {
			if (GIV(instructionPointer) >= (startOfMemory())) {
				/* begin iframeSavedIP:put: */
				assert(!(isMachineCodeFrame(GIV(framePointer))));
				longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			}
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp1;
		GIV(framePointer) = GIV(stackPointer);
		initialIP = (GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize;
		if (cogMethod == null) {
			/* begin push: */
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
			GIV(stackPointer) = sp2;
			/* begin setMethod:methodHeader: */
			GIV(method) = GIV(newMethod);
			assert(isOopCompiledMethod(GIV(method)));
			assert((methodHeaderOf(GIV(method))) == methodHeader);
			GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
				? 0x100
				: 0);
			/* begin push: */
			longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp3;
			object = 
			/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
				? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
				: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
			/* begin push: */
			longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp4;
			/* begin push: */
			longAtput((sp5 = GIV(stackPointer) - BytesPerWord), 0);
			GIV(stackPointer) = sp5;
			GIV(instructionPointer) = initialIP - 1;
		}
		else {
			/* begin push: */
			longAtput((sp6 = GIV(stackPointer) - BytesPerWord), ((usqInt)cogMethod));
			GIV(stackPointer) = sp6;
			/* begin push: */
			longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp7;
			GIV(instructionPointer) = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
		}
		/* begin push: */
		longAtput((sp8 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp8;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp9 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp9;
		}
		if (((methodHeader & AlternateHeaderHasPrimFlag) != 0)) {
			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			if (!cogMethod) {
				GIV(instructionPointer) += 3 /* begin sizeOfCallPrimitiveBytecode: */;
			}
			if (GIV(primFailCode) != 0) {
				reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
			}
		}
		ceInvokeInterpret();
	}
	return 0;
}


/*	Set PrimErrOSError primitive failure and associated osErrorCode. */

	/* InterpreterPrimitives>>#primitiveFailForOSError: */
sqInt
primitiveFailForOSError(sqLong osErrorCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(secondaryErrorCode) = osErrorCode;
	return (GIV(primFailCode) = PrimErrOSError);
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}


/*	Set primFailCode primitive failure and associated secondaryErrorCode. */

	/* InterpreterPrimitives>>#primitiveFailFor:withSecondary: */
sqInt
primitiveFailForwithSecondary(sqInt reasonCode, sqLong extraErrorCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(secondaryErrorCode) = extraErrorCode;
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFetchNextMourner */
static void
primitiveFetchNextMourner(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mourner;
    char *sp;

	mourner = 
	/* begin dequeueMourner */
(GIV(mournQueue) != GIV(nilObj)
		? popObjStack(GIV(mournQueue))
		: 0);
	if (mourner == null) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNotFound;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), mourner);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Index the receiver, which must be an indexable non-pointer object, and
	yield a float.
 */

	/* InterpreterPrimitives>>#primitiveFloatArrayAt */
static void
primitiveFloatArrayAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    float aFloat;
    sqLong doubleBits;
    sqInt fmt;
    sqInt index;
    usqInt newFloatObj;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt numSlots1;
    sqInt objFormat;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;
    usqLong rot;
    char *sp;
    char *sp1;


	/* begin primitiveSpurFloatArrayAt */
	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l6;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l6;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			doubleBits = long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3))));
			/* begin floatObjectOfBits: */
			if (isSmallFloatValueBits(doubleBits)) {
				/* begin smallFloatObjectOfBits: */
				assert(isSmallFloatValueBits(doubleBits));
				rot = ((((usqLong)(doubleBits)) >> 0x3F) & 1) + (((sqLong)((usqLong)(doubleBits) << 1)));
				if (rot > 1) {
					/* a.k.a. ~= +/-0.0 */
					rot -= ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
					assert(rot > 0);
				}
				oop = (rot << (numTagBits())) + (smallFloatTag());
				goto l5;
			}
			objFormat = firstLongFormat();
			numSlots1 = (sizeof(double)) / BytesPerOop;
			/* begin eeInstantiateSmallClassIndex:format:numSlots: */
			assert((numSlots1 >= 0)
			 && ((knownClassAtIndex(ClassFloatCompactIndex)) != GIV(nilObj)));
			assert(((objFormat < (firstByteFormat())
				? objFormat
				: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex))));
			/* begin allocateSmallNewSpaceSlots:format:classIndex: */
			assert(numSlots1 < (numSlotsMask()));
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots1 < 1
	? 8 /* begin allocationUnit */
	: numSlots1 * BytesPerOop));
			assert((numBytes % (allocationUnit())) == 0);
			assert((newObj % (allocationUnit())) == 0);
			if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
				if (!GIV(needGCFlag)) {
					/* begin scheduleScavenge */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
				if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
					error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
					newFloatObj = 0;
					goto l4;
				}
			}
			long64Atput(newObj, (((((usqLong) numSlots1)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassFloatCompactIndex);
			GIV(freeStart) += numBytes;
			newFloatObj = newObj;
	l4:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
			/* begin storeLong64:ofObject:withValue: */
			long64Atput((newFloatObj + BaseHeaderSize), doubleBits);
			oop = newFloatObj;
	l5:	/* end floatObjectOfBits: */;
			/* begin methodReturnValue: */
			assert(!((failed())));
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp;
			goto l6;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l6;
	}
	if ((fmt >= (firstLongFormat()))
	 && (fmt <= ((firstLongFormat()) + 1))) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin fetchFloat32:ofObject: */
			aFloat = singleFloatAtPointer((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))));
			oop1 = floatObjectOf(aFloat);
			/* begin methodReturnValue: */
			assert(!((failed())));
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop1);
			GIV(stackPointer) = sp1;
			goto l6;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l6;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	l6:;
}


/*	Index the receiver, which must be an indexable non-pointer object, and
	store a float.
 */

	/* InterpreterPrimitives>>#primitiveFloatArrayAtPut */
static void
primitiveFloatArrayAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    float aFloat;
    usqLong bits;
    sqInt fmt;
    sqInt index;
    sqInt numSlots;
    sqInt rcvr;
    double result;
    usqLong rot;
    char *sp;
    char *sp1;
    sqInt tagBits;
    sqLong value;
    double value1;
    sqInt valueOop;


	/* begin primitiveSpurFloatArrayAtPut */
	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((		/* begin isFloatInstance: */
			(((tagBits = valueOop & (tagMask()))) != 0
			? tagBits == (smallFloatTag())
			: ((longAt(valueOop)) & (classIndexMask())) == ClassFloatCompactIndex))
		 && ((((index) & 7) == 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l8;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l8;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l8;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			value = floatValueBitsOf(valueOop);
			/* begin storeLong64:ofObject:withValue: */
			long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3))), value);
			assert(!((failed())));
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp;
			goto l8;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l8;
	}
	if ((fmt >= (firstLongFormat()))
	 && (fmt <= ((firstLongFormat()) + 1))) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin noFailFloatValueOf: */
			assert(isFloatInstance(valueOop));
			if ((valueOop & (tagMask())) != 0) {
				/* begin smallFloatValueOf: */
				assert(isImmediateFloat(valueOop));
				rot = ((((usqInt)valueOop))) >> (numTagBits());
				if (rot > 1) {
					/* a.k.a. ~= +/-0.0 */
					rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
				}
				rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
				bits = rot;
				memcpy((&value1), (&bits), sizeof(value1));
				result = value1;
			}
			else {
				fetchFloatAtinto(valueOop + BaseHeaderSize, result);
			}
			aFloat = result;
			/* begin storeFloat32:ofObject:withValue: */
			singleFloatAtPointerput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))), aFloat);
			assert(!((failed())));
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp1;
			goto l8;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l8;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	l8:;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    usqLong bits1;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    unsigned int integerValue;
    unsigned int integerValue1;
    sqInt rcvr;
    usqInt result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		/* begin fetchLong32:ofFloatObject: */
		if (!(((rcvr & (smallFloatTag())) != 0))) {
			integerValue = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
			goto l4;
		}
		/* begin smallFloatBitsOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		integerValue = ((unsigned int) ((fieldIndex == 0
	? bits & 0xFFFFFFFFU
	: (bits) >> 32)));
	l4:	/* end fetchLong32:ofFloatObject: */;
		/* begin positive32BitIntegerFor: */
		result = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		/* begin fetchLong32:ofFloatObject: */
		if (!(((rcvr & (smallFloatTag())) != 0))) {
			integerValue1 = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << 2))));
			goto l6;
		}
		/* begin smallFloatBitsOf: */
		assert(isImmediateFloat(rcvr));
		rot1 = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot1 > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
		bits1 = rot1;
		integerValue1 = ((unsigned int) ((fieldIndex1 == 0
	? bits1 & 0xFFFFFFFFU
	: (bits1) >> 32)));
	l6:	/* end fetchLong32:ofFloatObject: */;
		/* begin positive32BitIntegerFor: */
		result = ((((((usqInt)integerValue1)) & 0xFFFFFFFFU) << 3) | 1);
		longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = ((((index) & 7) == 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((rcvr & (smallFloatTag())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((VMBIGENDIAN
	? 0
	: 1))) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((VMBIGENDIAN
	? 1
	: 0))) << 2))), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = ((((index) & 7) == 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterOrEqual */
static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatGreaterOrEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterThan */
static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatGreaterthanArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessOrEqual */
static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatLessOrEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessThan */
static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatLessthanArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatMultiply */
static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatNotEqual */
static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatSubtract */
static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

	/* InterpreterPrimitives>>#primitiveFlushCache */
static void
primitiveFlushCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;


	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}
	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;
	unlinkAllSends();
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invocation.
 */

	/* InterpreterPrimitives>>#primitiveFlushExternalPrimitives */
static void
primitiveFlushExternalPrimitives(void)
{
	flushExternalPrimitives();
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

	/* InterpreterPrimitives>>#primitiveForceDisplayUpdate */
static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

	/* InterpreterPrimitives>>#primitiveFormPrint */
static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt depth;
    sqInt fmt;
    sqInt h;
    double hScale;
    sqInt landscapeFlag;
    usqInt numBytes;
    usqInt numSlots;
    sqInt pixelsPerWord;
    sqInt rcvr;
    sqInt successBoolean;
    double vScale;
    sqInt w;
    sqInt wordsPerLine;

	bitsArray = 0;
	depth = 0;
	h = 0;
	w = 0;
	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l1;
	}
	/* begin success: */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	};
	landscapeFlag = null;
	l1:	/* end booleanValueOf: */;
	vScale = floatValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	hScale = floatValueOf(longAt(GIV(stackPointer) + (2 * BytesPerWord)));
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if (!((		/* begin isPointers: */
			((!(rcvr & (tagMask()))))
		 && (((((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((lengthOf(rcvr)) >= 4))) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if (		/* begin isWordsOrBytes: */
			((!(bitsArray & (tagMask()))))
		 && (isWordsOrBytesNonImm(bitsArray))) {
			/* begin numBytesOf: */
			fmt = (((usqInt)((longAt(bitsArray)))) >> (formatShift())) & (formatMask());
			assert((classIndexOf(bitsArray)) > (isForwardedObjectClassIndexPun()));
			numBytes = (((numSlots = byteAt(bitsArray + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(bitsArray - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots);
			numBytes = numBytes << (shiftForWord());
			if (fmt >= (firstByteFormat())) {
				/* bytes (the common case), including CompiledMethod */
				bitsArraySize = numBytes - (fmt & 7);
				goto l2;
			}
			if (fmt <= (sixtyFourBitIndexableFormat())) {
				bitsArraySize = numBytes;
				goto l2;
			}
			if (fmt >= (firstShortFormat())) {
				bitsArraySize = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
				goto l2;
			}
			bitsArraySize = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l2:	/* end numBytesOf: */;
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {
				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
	}
	if (!GIV(primFailCode)) {
		successBoolean = ioFormPrint(bitsArray + BaseHeaderSize, w, h, depth, hScale, vScale, landscapeFlag);
		/* begin success: */
		if (!successBoolean) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			/* begin methodReturnReceiver */
			assert(!((failed())));
			GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		}
	}
}


/*	Fractional part of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveFractionalPart */
static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double trunc;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	aValue = floatObjectOf(modf(doubleValue, (&trunc)));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveFullClosureValue */
static void
primitiveFullClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt header;
    usqInt i;
    int inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object11;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt objOop;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfClosure: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	closureMethod = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord())))));
	if (!(		/* begin isOopCompiledMethod: */
			((!(closureMethod & (tagMask()))))
		 && (((((usqInt)((longAt(closureMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewFullClosure:method:numArgs:mayContextSwitch: */
	assert(closureMethod == (fetchPointerofObject(FullClosureCompiledBlockIndex, blockClosure)));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		/* begin executeFullCogBlock:closure:mayContextSwitch: */
		assertCStackWellAligned();
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* invoked directly from the interpreter */
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			object = ceReturnToInterpreterPC();
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp;
		}
		else {
			/* instructionPointer == cogit ceReturnToInterpreterPC
			   ifTrue: [invoked from the interpreter via a machine code primitive]
			   ifFalse: [invoked from machine code].
			   If in the first case the bytecode instructionPointer has already been
			   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp1;
		}
		object1 = (((sqInt)cogMethod)) + (fullBlockEntryOffset());
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), blockClosure);
		GIV(stackPointer) = sp3;
		ceCallCogCodePopReceiverReg();
		goto l6;
	}
	/* begin copiedValueCountOfFullClosure: */
	assert(!((isVanillaBlockClosure(blockClosure))));
	/* How do we know when to compile a block method?
	   One simple criterion is to check if the block is running within its inner context,
	   i.e. if the outerContext is married.
	   Even simpler is to remember the previous block entered via the interpreter and
	   compile if this is the same one.  But we can thrash trying to compile an uncoggable
	   method unless we try and remember which ones can't be cogged.  So also record
	   the last block method we failed to compile and avoid recompiling it. */
	numCopied = ((assert((classIndexOf(blockClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(blockClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(blockClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - FullClosureFirstCopiedValueIndex;
	if (((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
		if ((GIV(instructionPointer) < (startOfMemory()))
		 || (closureMethod == GIV(lastCoggableInterpretedBlockMethod))) {
			/* If from interpreter and repeat block, attempt jitting */
			if (closureMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogFullBlockMethodnumCopied(closureMethod, numCopied);
				if (methodHasCogMethod(closureMethod)) {
					/* begin cogMethodOf: */
					methodHeader2 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					assert((isNonImmediate(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					/* begin executeFullCogBlock:closure:mayContextSwitch: */
					assertCStackWellAligned();
					assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
					if (GIV(instructionPointer) >= (startOfMemory())) {
						/* invoked directly from the interpreter */
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						object2 = ceReturnToInterpreterPC();
						/* begin push: */
						longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object2);
						GIV(stackPointer) = sp4;
					}
					else {
						/* instructionPointer == cogit ceReturnToInterpreterPC
						   ifTrue: [invoked from the interpreter via a machine code primitive]
						   ifFalse: [invoked from machine code].
						   If in the first case the bytecode instructionPointer has already been
						   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
						/* begin push: */
						longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
						GIV(stackPointer) = sp11;
					}
					object11 = (((sqInt)cogMethod1)) + (fullBlockEntryOffset());
					/* begin push: */
					longAtput((sp21 = GIV(stackPointer) - BytesPerWord), object11);
					GIV(stackPointer) = sp21;
					/* begin push: */
					longAtput((sp31 = GIV(stackPointer) - BytesPerWord), blockClosure);
					GIV(stackPointer) = sp31;
					ceCallCogCodePopReceiverReg();
					goto l6;
				}
				if (!GIV(cogCompiledCodeCompactionCalledFor)) {
					GIV(lastUncoggableInterpretedBlockMethod) = closureMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = closureMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(closureMethod);
	}
	assert(!(methodHasCogMethod(closureMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	object3 = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0x1000000));
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp10;
	/* begin followField:ofObject: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FullClosureReceiverIndex, blockClosure, objOop);
	}
	object4 = objOop;
	/* begin push: */
	longAtput((sp12 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp12;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp13 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((i + FullClosureFirstCopiedValueIndex) << (shiftForWord()))));
		GIV(stackPointer) = sp13;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(closureMethod));
	header = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = ((numArgs + numCopied) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp14 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp14;
	}
	GIV(instructionPointer) = ((closureMethod + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	assert((((usqInt)closureMethod)) >= (startOfMemory()));
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(1);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
	l6:	/* end activateNewFullClosure:method:numArgs:mayContextSwitch: */;
}


/*	An exact clone of primitiveFullClosureValue except that this version will
	not check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveFullClosureValueNoContextSwitch */
void
primitiveFullClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt header;
    usqInt i;
    int inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object11;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt objOop;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfClosure: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	closureMethod = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord())))));
	if (!(		/* begin isOopCompiledMethod: */
			((!(closureMethod & (tagMask()))))
		 && (((((usqInt)((longAt(closureMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewFullClosure:method:numArgs:mayContextSwitch: */
	assert(closureMethod == (fetchPointerofObject(FullClosureCompiledBlockIndex, blockClosure)));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		/* begin executeFullCogBlock:closure:mayContextSwitch: */
		assertCStackWellAligned();
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* invoked directly from the interpreter */
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			object = ceReturnToInterpreterPC();
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp;
		}
		else {
			/* instructionPointer == cogit ceReturnToInterpreterPC
			   ifTrue: [invoked from the interpreter via a machine code primitive]
			   ifFalse: [invoked from machine code].
			   If in the first case the bytecode instructionPointer has already been
			   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp1;
		}
		object1 = (((sqInt)cogMethod)) + (fullBlockNoContextSwitchEntryOffset());
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), blockClosure);
		GIV(stackPointer) = sp3;
		ceCallCogCodePopReceiverReg();
		goto l6;
	}
	/* begin copiedValueCountOfFullClosure: */
	assert(!((isVanillaBlockClosure(blockClosure))));
	/* How do we know when to compile a block method?
	   One simple criterion is to check if the block is running within its inner context,
	   i.e. if the outerContext is married.
	   Even simpler is to remember the previous block entered via the interpreter and
	   compile if this is the same one.  But we can thrash trying to compile an uncoggable
	   method unless we try and remember which ones can't be cogged.  So also record
	   the last block method we failed to compile and avoid recompiling it. */
	numCopied = ((assert((classIndexOf(blockClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(blockClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(blockClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - FullClosureFirstCopiedValueIndex;
	if (((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
		if ((GIV(instructionPointer) < (startOfMemory()))
		 || (closureMethod == GIV(lastCoggableInterpretedBlockMethod))) {
			/* If from interpreter and repeat block, attempt jitting */
			if (closureMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogFullBlockMethodnumCopied(closureMethod, numCopied);
				if (methodHasCogMethod(closureMethod)) {
					/* begin cogMethodOf: */
					methodHeader2 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					assert((isNonImmediate(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					/* begin executeFullCogBlock:closure:mayContextSwitch: */
					assertCStackWellAligned();
					assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
					if (GIV(instructionPointer) >= (startOfMemory())) {
						/* invoked directly from the interpreter */
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						object2 = ceReturnToInterpreterPC();
						/* begin push: */
						longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object2);
						GIV(stackPointer) = sp4;
					}
					else {
						/* instructionPointer == cogit ceReturnToInterpreterPC
						   ifTrue: [invoked from the interpreter via a machine code primitive]
						   ifFalse: [invoked from machine code].
						   If in the first case the bytecode instructionPointer has already been
						   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
						/* begin push: */
						longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
						GIV(stackPointer) = sp11;
					}
					object11 = (((sqInt)cogMethod1)) + (fullBlockNoContextSwitchEntryOffset());
					/* begin push: */
					longAtput((sp21 = GIV(stackPointer) - BytesPerWord), object11);
					GIV(stackPointer) = sp21;
					/* begin push: */
					longAtput((sp31 = GIV(stackPointer) - BytesPerWord), blockClosure);
					GIV(stackPointer) = sp31;
					ceCallCogCodePopReceiverReg();
					goto l6;
				}
				if (!GIV(cogCompiledCodeCompactionCalledFor)) {
					GIV(lastUncoggableInterpretedBlockMethod) = closureMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = closureMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(closureMethod);
	}
	assert(!(methodHasCogMethod(closureMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	object3 = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0x1000000));
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp10;
	/* begin followField:ofObject: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FullClosureReceiverIndex, blockClosure, objOop);
	}
	object4 = objOop;
	/* begin push: */
	longAtput((sp12 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp12;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp13 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((i + FullClosureFirstCopiedValueIndex) << (shiftForWord()))));
		GIV(stackPointer) = sp13;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(closureMethod));
	header = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = ((numArgs + numCopied) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp14 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp14;
	}
	GIV(instructionPointer) = ((closureMethod + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	assert((((usqInt)closureMethod)) >= (startOfMemory()));
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(0);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
	l6:	/* end activateNewFullClosure:method:numArgs:mayContextSwitch: */;
}

	/* InterpreterPrimitives>>#primitiveFullClosureValueWithArgs */
static void
primitiveFullClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureMethod;
    CogMethod *cogMethod;
    CogMethod *cogMethod1;
    sqInt header;
    usqInt i;
    sqInt index;
    int inInterpreter;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object11;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt objOop;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp12;
    char *sp13;
    char *sp14;
    char *sp15;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt switched;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(		/* begin isArray: */
			((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	arraySize = (((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin argumentCountOfClosure: */
	oop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	numArgs = (oop >> 3);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	closureMethod = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureCompiledBlockIndex) << (shiftForWord())))));
	if (!(		/* begin isOopCompiledMethod: */
			((!(closureMethod & (tagMask()))))
		 && (((((usqInt)((longAt(closureMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewFullClosure:method:numArgs:mayContextSwitch: */
	assert(closureMethod == (fetchPointerofObject(FullClosureCompiledBlockIndex, blockClosure)));
	methodHeader = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	if ((	/* begin isCogMethodReference: */
		assert(((((methodHeader) & 7) == 1))
		 || (((((usqInt)methodHeader)) < (startOfMemory()))
		 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
	/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
		/* begin cogMethodOf: */
		methodHeader1 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		assert((isNonImmediate(methodHeader1))
		 && ((((usqInt)methodHeader1)) < (startOfMemory())));
		cogMethod = ((CogMethod *) methodHeader1);
		/* begin executeFullCogBlock:closure:mayContextSwitch: */
		assertCStackWellAligned();
		assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
		if (GIV(instructionPointer) >= (startOfMemory())) {
			/* invoked directly from the interpreter */
			/* begin iframeSavedIP:put: */
			assert(!(isMachineCodeFrame(GIV(framePointer))));
			longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			object = ceReturnToInterpreterPC();
			/* begin push: */
			longAtput((sp15 = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp15;
		}
		else {
			/* instructionPointer == cogit ceReturnToInterpreterPC
			   ifTrue: [invoked from the interpreter via a machine code primitive]
			   ifFalse: [invoked from machine code].
			   If in the first case the bytecode instructionPointer has already been
			   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
			/* begin push: */
			longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
			GIV(stackPointer) = sp1;
		}
		object1 = (((sqInt)cogMethod)) + (fullBlockEntryOffset());
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), blockClosure);
		GIV(stackPointer) = sp3;
		ceCallCogCodePopReceiverReg();
		goto l7;
	}
	/* begin copiedValueCountOfFullClosure: */
	assert(!((isVanillaBlockClosure(blockClosure))));
	/* How do we know when to compile a block method?
	   One simple criterion is to check if the block is running within its inner context,
	   i.e. if the outerContext is married.
	   Even simpler is to remember the previous block entered via the interpreter and
	   compile if this is the same one.  But we can thrash trying to compile an uncoggable
	   method unless we try and remember which ones can't be cogged.  So also record
	   the last block method we failed to compile and avoid recompiling it. */
	numCopied = ((assert((classIndexOf(blockClosure)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(blockClosure + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(blockClosure - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) - FullClosureFirstCopiedValueIndex;
	if (((	/* begin literalCountOfMethodHeader: */
		assert((((methodHeader) & 7) == 1)),
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) <= maxLiteralCountForCompile) {
		if ((GIV(instructionPointer) < (startOfMemory()))
		 || (closureMethod == GIV(lastCoggableInterpretedBlockMethod))) {
			/* If from interpreter and repeat block, attempt jitting */
			if (closureMethod != GIV(lastUncoggableInterpretedBlockMethod)) {
				cogFullBlockMethodnumCopied(closureMethod, numCopied);
				if (methodHasCogMethod(closureMethod)) {
					/* begin cogMethodOf: */
					methodHeader2 = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					assert((isNonImmediate(methodHeader2))
					 && ((((usqInt)methodHeader2)) < (startOfMemory())));
					cogMethod1 = ((CogMethod *) methodHeader2);
					/* begin executeFullCogBlock:closure:mayContextSwitch: */
					assertCStackWellAligned();
					assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
					if (GIV(instructionPointer) >= (startOfMemory())) {
						/* invoked directly from the interpreter */
						/* begin iframeSavedIP:put: */
						assert(!(isMachineCodeFrame(GIV(framePointer))));
						longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
						object2 = ceReturnToInterpreterPC();
						/* begin push: */
						longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object2);
						GIV(stackPointer) = sp4;
					}
					else {
						/* instructionPointer == cogit ceReturnToInterpreterPC
						   ifTrue: [invoked from the interpreter via a machine code primitive]
						   ifFalse: [invoked from machine code].
						   If in the first case the bytecode instructionPointer has already been
						   saved in iframeSavedIP so all we need to do is push the instructionPointer. */
						/* begin push: */
						longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
						GIV(stackPointer) = sp11;
					}
					object11 = (((sqInt)cogMethod1)) + (fullBlockEntryOffset());
					/* begin push: */
					longAtput((sp21 = GIV(stackPointer) - BytesPerWord), object11);
					GIV(stackPointer) = sp21;
					/* begin push: */
					longAtput((sp31 = GIV(stackPointer) - BytesPerWord), blockClosure);
					GIV(stackPointer) = sp31;
					ceCallCogCodePopReceiverReg();
					goto l7;
				}
				if (!GIV(cogCompiledCodeCompactionCalledFor)) {
					GIV(lastUncoggableInterpretedBlockMethod) = closureMethod;
				}
			}
		}
		else {
			GIV(lastCoggableInterpretedBlockMethod) = closureMethod;
		}
	}
	else {
		maybeFlagMethodAsInterpreted(closureMethod);
	}
	assert(!(methodHasCogMethod(closureMethod)));
	if (!((inInterpreter = GIV(instructionPointer) >= (startOfMemory())))) {
		if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
			GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
		}
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp6;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp7;
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp8;
	object3 = 
	/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
		? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (1ULL << ((BytesPerWord * 8) - 24))
		: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0x1000000));
	/* begin push: */
	longAtput((sp9 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp9;
	/* begin push: */
	longAtput((sp10 = GIV(stackPointer) - BytesPerWord), 0);
	GIV(stackPointer) = sp10;
	/* begin followField:ofObject: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (((sqInt)((usqInt)(FullClosureReceiverIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FullClosureReceiverIndex, blockClosure, objOop);
	}
	object4 = objOop;
	/* begin push: */
	longAtput((sp12 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp12;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp13 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((i + FullClosureFirstCopiedValueIndex) << (shiftForWord()))));
		GIV(stackPointer) = sp13;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(closureMethod));
	header = longAt((closureMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	for (i = ((numArgs + numCopied) + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp14 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp14;
	}
	GIV(instructionPointer) = ((closureMethod + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) - 1;
	assert((((usqInt)closureMethod)) >= (startOfMemory()));
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	switched = 0;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		switched = handleStackOverflowOrEventAllowContextSwitch(1);
	}
	returnToExecutivepostContextSwitch(inInterpreter, switched);
	l7:	/* end activateNewFullClosure:method:numArgs:mayContextSwitch: */;
}


/*	Fetch the system attribute with the given integer ID. The result is a
	string, or nil if the attribute is not defined.
 */

	/* InterpreterPrimitives>>#primitiveGetAttribute */
static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    const char *attributeString;
    char *sp;

	attr = longAt(GIV(stackPointer));
	if (!((((attr) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	attributeString = getAttributeString((attr >> 3));
	if (attributeString == null) {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	else {
		methodReturnString(attributeString);
	}
}


/*	Access to environment variables via getenv. No putenv or setenv as yet. */

	/* InterpreterPrimitives>>#primitiveGetenv */
EXPORT(sqInt)
primitiveGetenv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *key;
    sqInt oop;
    sqInt result;
    char *sp;
    char *var;

	result = 0;
	if (sHEAFn != 0) {
		/* secHasEnvironmentAccess */
		if (!(sHEAFn())) {
			return (GIV(primFailCode) = PrimErrInappropriate);
		}
	}
	key = cStringOrNullFor(longAt(GIV(stackPointer)));
	if (key == 0) {
		if (!GIV(primFailCode)) {
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
		return (GIV(primFailCode));
	}
	var = getenv(key);
	free(key);
	if (var != 0) {
		result = stringForCString(var);
		if (!result) {
			return (GIV(primFailCode) = PrimErrNoMemory);
		}
	}
	assert(GIV(primFailCode) == 0);
	oop = (var == 0
		? GIV(nilObj)
		: result);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGetImmutability */
#if IMMUTABILITY
static void
primitiveGetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt trueOrFalse;

	rcvr = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	trueOrFalse = 
	/* begin isOopImmutable: */
(((rcvr & (tagMask())) != 0))
	 || (((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Primitive. Answer the VM's current log directory */

	/* InterpreterPrimitives>>#primitiveGetLogDirectory */
EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (ptr == null) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	for (i = 0; i < sz; i += 1) {
		/* begin storeByte:ofObject:withValue: */
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), stringOop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Return the next input event from the VM event queue. */

	/* InterpreterPrimitives>>#primitiveGetNextEvent */
static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqIntptr_t eventTypeIs;
    static char * eventTypeNames[] = {
		"None", "Mouse", "Keyboard", "DragDropFiles", "Menu", "Window", "Complex", "MouseWheel",
		"Plugin"
	};
    sqIntptr_t evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqIntptr_t value;

	arg = longAt(GIV(stackPointer));
	if (!((		/* begin isArray: */
			((!(arg & (tagMask()))))
		 && (((((usqInt)((longAt(arg)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && ((slotSizeOf(arg)) == 8))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (GIV(primFailCode)) {
		return;
	}
	if ((eventTraceMask != 0)
	 && (((eventTraceMask & ((((evtBuf[0]) < 0) ? (((usqInt)(1)) >> (-(evtBuf[0]))) : (1ULL << (evtBuf[0]))))) != 0))) {
		fprintf(stderr,
				"Event%s/%" PRIdSQINT " @ %" PRIuSQINT "\t\t%" PRIdSQINT "/%" PRIxSQINT " %" PRIdSQINT "/%" PRIxSQINT "\n\t%" PRIdSQINT "/%" PRIxSQINT " %" PRIdSQINT "/%" PRIxSQINT "\t %" PRIdSQINT "/%" PRIxSQINT " %p\n",
				((((evtBuf[0]) >= 0) && ((evtBuf[0]) <= 8))
			? eventTypeNames[evtBuf[0]]
			: "?"),
				evtBuf[0],
				evtBuf[1],
				evtBuf[2],
				evtBuf[2],
				evtBuf[3],
				evtBuf[3],
				evtBuf[4],
				evtBuf[4],
				evtBuf[5],
				evtBuf[5],
				evtBuf[6],
				evtBuf[6],
				((void *)(evtBuf[7])));
	}
	eventTypeIs = evtBuf[0];
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqIntptr_t)((evtBuf[0]))) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(arg)));
		longAtput((arg + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)(evtBuf[0]) << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	if (eventTypeIs == 6) {
		/* Event is Complex, assume evtBuf is populated correctly and return */
		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(arg)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(arg)),
			oopisGreaterThanOrEqualTo(arg, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(value & (tagMask()))))
				 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(arg)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(arg);
					}
				}
			}
			longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), value);
		}
	}
	else {
		/* Event time stamp */
		/* begin storeInteger:ofObject:withValue: */
		if ((((((usqIntptr_t)(((evtBuf[1]) & MillisecondClockMask))) >> 60) + 1) & 15) <= 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(arg)));
			longAtput((arg + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)((evtBuf[1]) & MillisecondClockMask) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode)) {
			return;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if ((((((usqIntptr_t)(value)) >> 60) + 1) & 15) <= 1) {
				/* begin storeInteger:ofObject:withValue: */
				if ((((((usqIntptr_t)(value)) >> 60) + 1) & 15) <= 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(arg)));
					longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), (((usqInt)value << 3) | 1));
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
			}
			else {
				value = positiveMachineIntegerFor(value);
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(arg)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(arg)),
				oopisGreaterThanOrEqualTo(arg, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(value & (tagMask()))))
					 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(arg)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(arg);
						}
					}
				}
				longAtput((arg + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), value);
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's label */

	/* InterpreterPrimitives>>#primitiveGetWindowLabel */
EXPORT(sqInt)
primitiveGetWindowLabel(void)
{
	methodReturnString(ioGetWindowLabel());
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveGetWindowSize */
EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt h;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt object;
    sqInt objFormat;
    usqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin makePointwithxValue:yValue: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))));
	numSlots = YIndex + 1;
	/* begin eeInstantiateSmallClass:numSlots: */
	assert((rawHashBitsOf(classObj)) != 0);
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	objFormat = (((usqInt)((((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l2:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)w << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)h << 3) | 1));
	object = pointResult;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGreaterOrEqual */
static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerReceiver & integerArgument) & (smallIntegerTag())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterOrEqualLargeIntegers */
EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGreaterThan */
static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerReceiver & integerArgument) & (smallIntegerTag())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterThanLargeIntegers */
EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGrowMemoryByAtLeast */
static void
primitiveGrowMemoryByAtLeast(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ammount;
    usqInt segSize;
    char *sp;

	ammount = longAt(GIV(stackPointer));
	if (!((((ammount) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	segSize = growOldSpaceByAtLeast((ammount >> 3));
	if (segSize == null) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), ((segSize << 3) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* InterpreterPrimitives>>#primitiveHashMultiply */
static void
primitiveHashMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ok;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	if ((((value) & 7) == 1)) {
		value = (value >> 3);
	}
	else {
		/* begin is:instanceOf:compactClassIndex: */
		if (((value & (tagMask())) != 0)) {
			ok = 0;
			goto l1;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(value)));
		ccIndex = (longAt(value)) & (classIndexMask());
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	l1:	/* end is:instanceOf:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		value = SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((value + BaseHeaderSize))));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((((((usqInt) value)) * HashMultiplyConstant) & 0xFFFFFFF) << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

	/* InterpreterPrimitives>>#primitiveHeartbeatFrequency */
EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	integerValue = ((unsigned int) (ioHeartbeatFrequency(reset)));
	/* begin positive32BitIntegerFor: */
	oop = ((((((usqInt)integerValue)) & 0xFFFFFFFFU) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveHighBit */
static void
primitiveHighBit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt highestBitZeroBased;
    sqInt integerReceiverOop;
    sqInt leadingZeroCount;
    char *sp;
    char *sp1;


	/* Convert the receiver Oop to use a single tag bit */
	integerReceiverOop = longAt(GIV(stackPointer));
	integerReceiverOop = ((integerReceiverOop) >> (2)) | 1;
#  if defined(__GNUC__)
	/* Note: in gcc, result is undefined if input is zero (for compatibility with BSR fallback when no CLZ instruction available).
	   but input is never zero because we pass the oop with tag bits set, so we are safe */
	leadingZeroCount = __builtin_clzll(integerReceiverOop);
	if (leadingZeroCount == 0) {
		/* highBit is not defined for negative Integer */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)(leadingZeroCount ^ ((BytesPerWord * 8) - 1)) << 3) | 1));
	GIV(stackPointer) = sp;
#  elif (defined(_MSC_VER)) || (defined(__ICC))
	/* In MSVC, _lzcnt and _lzcnt64 builtins do not fallback to BSR when not supported by CPU
	   Instead of messing with __cpuid() we always use the BSR intrinsic */
	/* Trick: we test the oop sign rather than the integerValue. Assume oop are signed (so far, they are, sqInt are signed) */
	if (integerReceiverOop < 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* We do not even test the return value, because integerReceiverOop is never zero */
	highestBitZeroBased = 0;
	_BitScanReverse64((&highestBitZeroBased), integerReceiverOop);
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)highestBitZeroBased << 3) | 1));
	GIV(stackPointer) = sp1;
#  else // defined(__GNUC__) || (defined(_MSC_VER)) || (defined(__ICC))
	/* not gcc/clang, nor MSVC/ICC, you have to implement if your compiler provides useful builtins */
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
#  endif // defined(__GNUC__) || (defined(_MSC_VER)) || (defined(__ICC))
}


/*	Return the value of the high resolution clock if this system has any.
	The exact frequency of the high res clock is undefined specifically so
	that we can use
	processor dependent instructions (like RDTSC). The only use for the high
	res clock is for
	profiling where we can allocate time based on sub-msec resolution of the
	high res clock.
	If no high-resolution counter is available, the platform should return
	zero. ar 6/22/2007 */

	/* InterpreterPrimitives>>#primitiveHighResClock */
EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioHighResClock());
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveIdentical */
static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	thisObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	otherObject = longAt(GIV(stackPointer));
	if ((	/* begin isOopForwarded: */
		((!(otherObject & (tagMask()))))
	 && ((!((longAt(otherObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))
	 || ((GIV(argumentCount) > 1)
	 && (	/* begin isOopForwarded: */
		((!(thisObject & (tagMask()))))
	 && ((!((longAt(thisObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
	else {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject == otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveIdentityHash */
static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    usqInt hash1;
    sqInt integerVal;
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if ((((thisReceiver & (tagMask())) != 0))
	 || ((GIV(argumentCount) > 0)
	 && ((!((longAt(thisReceiver)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin hashBitsOf: */
		hash = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask());
		if (hash == 0) {
			/* cb 1/19/2017 18:34:
			   would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */
			/* eem 12/28/2021 11:52 I'm not sure this is the issue. The issue is only validating objOop as a behavior. */
			flag("todo");
			/* begin newHashBitsOf: */
			hash1 = (newObjectHash()) & (identityHashHalfWordMask());
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
			hash = hash1;
		}
		integerVal = hash;
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer an integer identifying the type of image. The image version number
	may identify the format of the image (e.g. 32 or 64-bit word size) or
	specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveImageFormatVersion */
EXPORT(sqInt)
primitiveImageFormatVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = ((((((usqInt)(/* begin imageFormatVersionForSnapshot */
	(GIV(multipleBytecodeSetsActive)
	? 68021 /* begin imageFormatVersion */ | MultipleBytecodeSetsBitmask
	: 68021 /* begin imageFormatVersion */)))) & 0xFFFFFFFFU) << 3) | 1);
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	When called with a single string argument, record the string as the
	current image file name.
	When called with zero arguments, return a string containing the current
	image file name.
 */

	/* InterpreterPrimitives>>#primitiveImageName */
static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt isString;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		/* begin isInstanceOfClassByteString: */
		if (((s & (tagMask())) != 0)) {
			isString = 0;
			goto l2;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(s)));
		ccIndex = (longAt(s)) & (classIndexMask());
		isString = ClassByteStringCompactIndex == ccIndex;
	l2:	/* end isInstanceOfClassByteString: */;
		if (!isString) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				return;
			}
		}
		imageNamePutLength(s + BaseHeaderSize, numBytesOf(s));
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		return;
	}
	sz = imageNameSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	imageNameGetLength(s + BaseHeaderSize, sz);
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	For a Smalllnteger, answer itself.
	For a Character, answer its code as an unsigned integer.
	For a SmallFloat, answer the signed, but unadjusted bit pattern (so as to
	keep the result a SmallInteger).
	This is a good value for an immediate's hash. */

	/* InterpreterPrimitives>>#primitiveImmediateAsInteger */
static void
primitiveImmediateAsInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    sqInt value;

	value = 0;
	oop = longAt(GIV(stackPointer));
	/* begin immediateAsInteger:ifFail: */
	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		goto l1;
	}
	if (((oop & (characterTag())) != 0)) {
		value = ((((usqInt)oop))) >> (numTagBits());
		goto l1;
	}
	if (((oop & (smallFloatTag())) != 0)) {
		/* begin rotatedFloatBitsOf: */
		assert(isImmediateFloat(oop));
		value = (((((usqInt)oop))) >> ((numTagBits()) + 1)) + ((((oop & (1U << (numTagBits()))) != 0)
	? (((usqInt)-1)) << ((64 - (numTagBits())) - 1)
	: 0));
		goto l1;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	return;
	l1:	/* end immediateAsInteger:ifFail: */;
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

	/* InterpreterPrimitives>>#primitiveInputSemaphore */
static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt objOop;

	arg = longAt(GIV(stackPointer));
	if ((((arg) & 7) == 1)) {
		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */
		ioSetInputSemaphore((arg >> 3));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((arg == GIV(nilObj))
	 || (	/* begin isSemaphoreOop: */
		((!(arg & (tagMask()))))
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
		/* begin splObj:put: */
		objOop = GIV(specialObjectsOop);
		assert(!(isForwarded(objOop)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(objOop)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(arg & (tagMask()))))
			 && (oopisLessThan(arg, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(TheInputSemaphore) << (shiftForWord())))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

	/* InterpreterPrimitives>>#primitiveInputWord */
static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;


	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)0 << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveIntegerAt */
static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt numFixed;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt oop;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp5;
    char *sp6;
    sqInt value;


	/* begin primitiveSpurIntegerAt */
	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l11;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l11;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			goto l11;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		numSlots = (((/* begin numSlotsOf: */
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(rcvr + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) << (shiftForWord())) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			value = byteAt((rcvr + BaseHeaderSize) + index);
			if (value > 0x7F) {
				value -= 0x100;
			}
			/* begin methodReturnInteger: */
			assert(!((failed())));
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
			GIV(stackPointer) = sp;
			goto l11;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l11;
	}
	if (fmt >= (firstShortFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			value = shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))));
			if (value > 0x7FFF) {
				value -= 0x10000;
			}
			/* begin methodReturnInteger: */
			assert(!((failed())));
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
			GIV(stackPointer) = sp1;
			goto l11;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l11;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			oop = signed64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3)))));
			/* begin methodReturnValue: */
			assert(!((failed())));
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp2;
			goto l11;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l11;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
						value = long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))));
			if (value > 0x7FFFFFFF) {
				value -= 0x100000000LL;
			}
			/* begin methodReturnInteger: */
			assert(!((failed())));
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)value << 3) | 1));
			GIV(stackPointer) = sp3;
			goto l11;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l11;
	}
	if ((fmt <= 5 /* begin lastPointerFormat */)
	 && (	/* begin isIndexableFormat: */
		(fmt >= (arrayFormat()))
	 && ((fmt <= (weakArrayFormat()))
	 || (fmt >= (sixtyFourBitIndexableFormat()))))) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt == (arrayFormat())) {
			if ((((usqInt)index)) < numSlots) {
				/* begin methodReturnValue: */
				assert(!((failed())));
				longAtput((sp5 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord()))))));
				GIV(stackPointer) = sp5;
				goto l11;
			}
		}
		/* begin numFixedSlotsOf: */
		classPointer = fetchClassOfNonImm(rcvr);
		classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
		numFixed = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
		if ((((index + 1) >= numFixed) && ((index + 1) <= numSlots))) {
			/* begin methodReturnValue: */
			assert(!((failed())));
			longAtput((sp6 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index + numFixed)) << (shiftForWord()))))));
			GIV(stackPointer) = sp6;
			goto l11;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l11;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	l11:;
}

	/* InterpreterPrimitives>>#primitiveIntegerAtPut */
static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt numFixed;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqLong value;
    sqInt valueOop;


	/* begin primitiveSpurIntegerAtPut */
	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	value = signed64BitValueOf(valueOop);
	if (!((!GIV(primFailCode))
		 && ((((index) & 7) == 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l12;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		goto l12;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l12;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			goto l12;
		}
		if (!((((usqInt)((((value) >> 7)) + 1))) <= 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l12;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		numSlots = (((/* begin numSlotsOf: */
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(rcvr + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) << (shiftForWord())) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + index, value);
			assert(!((failed())));
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp;
			goto l12;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l12;
	}
	if (fmt >= (firstShortFormat())) {
		if (!((((usqInt)((((value) >> 15)) + 1))) <= 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l12;
		}
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))), value);
			assert(!((failed())));
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp1;
			goto l12;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l12;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		/* No range check on value in this case because signed64BitValueOf: performed it above. */
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong64:ofObject:withValue: */
			long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3))), value);
			assert(!((failed())));
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp2;
			goto l12;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l12;
	}
	if (fmt >= (firstLongFormat())) {
		if (!((((usqInt)((((value) >> 0x1F)) + 1))) <= 1)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			goto l12;
		}
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))), value);
			assert(!((failed())));
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp3;
			goto l12;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l12;
	}
	if ((fmt <= 5 /* begin lastPointerFormat */)
	 && (	/* begin isIndexableFormat: */
		(fmt >= (arrayFormat()))
	 && ((fmt <= (weakArrayFormat()))
	 || (fmt >= (sixtyFourBitIndexableFormat()))))) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt == (arrayFormat())) {
			if ((((usqInt)index)) < numSlots) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(rcvr)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(valueOop & (tagMask()))))
					 && (oopisLessThan(valueOop, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), valueOop);
				/* begin methodReturnValue: */
				assert(!((failed())));
				longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
				GIV(stackPointer) = sp4;
				goto l12;
			}
		}
		/* begin numFixedSlotsOf: */
		classPointer = fetchClassOfNonImm(rcvr);
		classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
		numFixed = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
		if ((((index + 1) >= numFixed) && ((index + 1) <= numSlots))) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(rcvr)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(valueOop & (tagMask()))))
				 && (oopisLessThan(valueOop, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index + numFixed)) << (shiftForWord())))), valueOop);
			/* begin methodReturnValue: */
			assert(!((failed())));
			longAtput((sp5 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), valueOop);
			GIV(stackPointer) = sp5;
			goto l12;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l12;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	l12:;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

	/* InterpreterPrimitives>>#primitiveInterruptChecksPerMSec */
EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		return null;
	}
	oop = (((usqInt)(ioHeartbeatMilliseconds()) << 3) | 1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

	/* InterpreterPrimitives>>#primitiveInterruptSemaphore */
static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt objOop;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (	/* begin isSemaphoreOop: */
		((!(arg & (tagMask()))))
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
		/* begin splObj:put: */
		objOop = GIV(specialObjectsOop);
		assert(!(isForwarded(objOop)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(objOop)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(arg & (tagMask()))))
			 && (oopisLessThan(arg, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord())))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

	/* InterpreterPrimitives>>#primitiveInvokeObjectAsMethod */
static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt lookupClassTag;
    sqInt runArgs;
    sqInt runReceiver;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    sqInt tagBits;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;


	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && ((knownClassAtIndex(ClassArrayCompactIndex)) != GIV(nilObj)));
	assert((arrayFormat()) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	runArgs = allocateNewSpaceSlotsformatclassIndex(GIV(argumentCount), arrayFormat(), ClassArrayCompactIndex);
	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin popStack */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(runArgs)));
		longAtput((runArgs + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorRunWithIn) << (shiftForWord())))));
	GIV(argumentCount) = 3;
	lookupClassTag = 
	/* begin fetchClassTagOf: */
(((tagBits = GIV(newMethod) & (tagMask()))) != 0
		? tagBits
		: (longAt(GIV(newMethod))) & (classIndexMask()));
	findNewMethodInClassTag(lookupClassTag);
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer if running on a big endian machine. */

	/* InterpreterPrimitives>>#primitiveIsBigEnder */
EXPORT(sqInt)
primitiveIsBigEnder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;


	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (VMBIGENDIAN
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer if the receiver is pinned, i.e. immobile. */

	/* InterpreterPrimitives>>#primitiveIsPinned */
static void
primitiveIsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    char *sp;
    sqInt trueOrFalse;

	obj = longAt(GIV(stackPointer));
	if ((((obj & (tagMask())) != 0))
	 || ((!((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	trueOrFalse = ((((usqInt)((longAt(obj)))) >> (pinnedBitShift())) & 1) != 0;
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

	/* InterpreterPrimitives>>#primitiveIsWindowObscured */
EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;


	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	trueOrFalse = ioIsWindowObscured();
	/* begin pushBool: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveLessOrEqual */
static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerReceiver & integerArgument) & (smallIntegerTag())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessOrEqualLargeIntegers */
EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessThan */
static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerReceiver & integerArgument) & (smallIntegerTag())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessThanLargeIntegers */
EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

	/* InterpreterPrimitives>>#primitiveListBuiltinModule */
static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *moduleName;
    char *sp;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (GIV(primFailCode)
	 || (index <= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	else {
		methodReturnString(moduleName);
	}
}


/*	Primitive. Answer the n-th loaded external module name. */

	/* InterpreterPrimitives>>#primitiveListExternalModule */
static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *moduleName;
    char *sp;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (GIV(primFailCode)
	 || (index <= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	else {
		methodReturnString(moduleName);
	}
}


/*	This primitive is called from Smalltalk as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray.
	
	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well
	formed. It will return as its value the original array of roots, and the
	erstwhile segmentWordArray will have been truncated to a size of one word,
	i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to
	an unrecognizable and unusable jumble. But what more could you have done
	with it anyway?
	[How about saving it so the system functions as primitives are intended?
	eem 5/9/2017 16:31]
	
	In Spur, if the primitive succeeds, the segmentWordArray is also becomed
	into the array of loaded
	objects, to allow fixing up of loaded objects directly without nextObject,
	which Spur doesn't support. */

	/* InterpreterPrimitives>>#primitiveLoadImageSegment */
static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));
	/* Essential type checks */
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((		/* begin isArray: */
			((!(outPointerArray & (tagMask()))))
		 && (((((usqInt)((longAt(outPointerArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((!(segmentWordArray & (tagMask()))))
		 && (((((((usqInt)((longAt(segmentWordArray)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(segmentWordArray)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1))))))) {
		/* Must be indexable words */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray);
	if (oopisGreaterThan(result, segmentWordArray)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = result;
	}
}


/*	Return the value of the microsecond clock in the local timezone as an
	integer. This is the number of microseconds since the Smalltalk epoch,
	1901/1/1 12:00am.
	The microsecond clock is at least 60 bits wide which means it'll get to
	around August
	38435 before it wraps around. Be sure to put it on your calendar. This
	primitive accesses the time as answered by the OS. */

	/* InterpreterPrimitives>>#primitiveLocalMicrosecondClock */
static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioLocalMicrosecondsNow());
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveLogN */
static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	aValue = floatObjectOf(log(doubleValue));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

	/* InterpreterPrimitives>>#primitiveLowSpaceSemaphore */
static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt objOop;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (	/* begin isSemaphoreOop: */
		((!(arg & (tagMask()))))
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
		/* begin splObj:put: */
		objOop = GIV(specialObjectsOop);
		assert(!(isForwarded(objOop)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(objOop)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(arg & (tagMask()))))
			 && (oopisLessThan(arg, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveMakePoint */
static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    usqInt pt;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg = longAt(GIV(stackPointer));
	if (!(		/* begin isFloatOrInt: */
			(((arg & (tagMask())) != 0)
			? !(((arg & (characterTag())) != 0))
			: ((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))));
	numSlots = YIndex + 1;
	/* begin eeInstantiateSmallClass:numSlots: */
	assert((rawHashBitsOf(classObj)) != 0);
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	objFormat = (((usqInt)((((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pt = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pt = newObj;
	l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pt)));
	longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord())))), rcvr);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pt)));
	longAtput((pt + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord())))), arg);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMaxIdentityHash */
static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	integerVal = identityHashHalfWordMask();
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

	/* InterpreterPrimitives>>#primitiveMethod */
usqInt
primitiveMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

	/* InterpreterPrimitives>>#primitiveMillisecondClock */
static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = (((usqInt)((ioMSecs()) & MillisecondClockMask) << 3) | 1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

	/* InterpreterPrimitives>>#primitiveMillisecondClockMask */
EXPORT(sqInt)
primitiveMillisecondClockMask(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;


	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)MillisecondClockMask << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveMod */
static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt)(mod)) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)mod << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveModLargeIntegers */
EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	/* Handle remainder of same sign as argument */
	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Given one boolean parameter, set multipleBytecodeSetsActive to inform
	the VM that alternate bytecode sets such as SistaV1 are now in use and
	that the image format number should be updated accordingly. With zero
	parameters, answer the current value of multipleBytecodeSetsActive. */

	/* InterpreterPrimitives>>#primitiveMultipleBytecodeSetsActive */
EXPORT(sqInt)
primitiveMultipleBytecodeSetsActive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (GIV(argumentCount) > 1) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			GIV(multipleBytecodeSetsActive) = 1;
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				GIV(multipleBytecodeSetsActive) = 0;
			}
			else {
				return (GIV(primFailCode) = PrimErrBadArgument);
			}
		}
	}
	/* begin methodReturnBool: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (GIV(multipleBytecodeSetsActive)
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveMultiply */
static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    sqInt overflow;
    char *sp;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		integerRcvr = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		integerArg = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
	}
	if (!GIV(primFailCode)) {
		overflow = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr > ((MaxSmallInteger) / integerArg)
					: integerArg < ((MinSmallInteger) / integerRcvr))
			: (integerArg > 0
					? integerRcvr < ((MinSmallInteger) / integerArg)
					: (integerRcvr < 0)
						 && (integerArg < ((MaxSmallInteger) / integerRcvr))));
		if (overflow) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		else {
			integerResult = integerRcvr * integerArg;
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveMultiplyLargeIntegers */
EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNew */
static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    sqInt reasonCode;
    char *sp;

	obj = instantiateClass(longAt(GIV(stackPointer)));
	if (obj == null) {
		reasonCode = (isFixedSizePointerFormat((((usqInt)((((longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask()))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNewMethod */
static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt hash;
    sqInt header;
    sqInt i;
    sqInt instSpec;
    sqInt literalCount;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt p;
    sqInt reasonCode;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	bytecodeCount = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((header) & 7) == 1))
		 && (((((bytecodeCount) & 7) == 1))
		 && (((bytecodeCount = (bytecodeCount >> 3))) >= 0)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	literalCount = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	size = ((literalCount + LiteralStart) * BytesPerOop) + bytecodeCount;
	/* begin instantiateCompiledMethodClass:indexableSize: */
	classFormat = ((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (instSpec != (firstCompiledMethodFormat())) {
		theMethod = null;
		goto l3;
	}
	numSlots = (size + 7) / 8;
	instSpec += (8 - size) & 7;
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(class));
	flag("todo");
	classIndex = (((hash = (long32At(class + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(class)
				? (((err = enterIntoClassTable(class))) != 0
						? -err
						: (long32At(class + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -classIndex;
		theMethod = null;
		goto l3;
	}
	if (numSlots > ((1U << (fixedFieldsFieldWidth())) - 1)) {
		if (numSlots > (0x10000000000LL)) {
			theMethod = null;
			goto l3;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, 
		/* begin objectBytesForSlots: */
(numSlots == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if (((numSlots) >> 56) > 0) {
				newObj = null;
				goto l2;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
			goto l2;
		}
		if (numSlots >= (numSlotsMask())) {
			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
			longAtput(newObj1, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec) << (formatShift()))))) + classIndex);
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l2:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, 0);
		}
	}
	theMethod = newObj;
	l3:	/* end instantiateCompiledMethodClass:indexableSize: */;
	if (!theMethod) {
		reasonCode = (isCompiledMethodFormat((((usqInt)((((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask()))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = reasonCode;
		return;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theMethod)));
	longAtput((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))), header);
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(theMethod)));
		longAtput((theMethod + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2) * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveNewWithArg */
static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt instSpec;
    usqInt numSlots;
    sqInt obj;
    int ok;
    sqInt oop;
    sqInt reasonCode;
    usqIntptr_t size;
    char *sp;
    sqInt value;

	oop = longAt(GIV(stackPointer));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l4;
		}
		size = value;
		goto l4;
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l4;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l4;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l4;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
		goto l4;
	}
	size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	l4:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	obj = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size);
	if (obj == null) {
		instSpec = (((usqInt)((((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
		reasonCode = ((		/* begin isIndexableFormat: */
			(instSpec >= (arrayFormat()))
		 && ((instSpec <= (weakArrayFormat()))
		 || (instSpec >= (sixtyFourBitIndexableFormat()))))
		 && (!(instSpec >= (firstCompiledMethodFormat())))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNextInstance */
static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualObj;
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt numSlots;
    sqInt object;
    char *sp;
    sqInt subsequentObject;

	object = longAt(GIV(stackPointer));
	if (!(((object & (tagMask())) != 0))) {
		/* begin instanceAfter: */
		actualObj = object;
		classIndex = (longAt(object)) & (classIndexMask());
		if ((		/* begin isYoungObject: */
			assert(isNonImmediate(object)),
		oopisLessThan(object, GIV(oldSpaceStart)))) {
			/* it almost never is because usually this is preceded by a send of initialInstanceOf: */
			if (oopisGreaterThanOrEqualToandLessThan(object, ((eden()).start), GIV(freeStart))) {
				while (1) {
					/* begin objectAfter:limit: */
					followingWordAddress = addressAfter(actualObj);
					if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
						actualObj = GIV(freeStart);
						goto l1;
					}
					flag("endianness");
					followingWord = longAt(followingWordAddress);
					actualObj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
						? followingWordAddress + BaseHeaderSize
						: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
					if (!(oopisLessThan(actualObj, GIV(freeStart)))) break;
					if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
						subsequentObject = actualObj;
						goto l5;
					}
				}
				if (oopisGreaterThan(GIV(pastSpaceStart), ((pastSpace()).start))) {
					address = ((pastSpace()).start);
					/* begin objectStartingAt: */
					numSlots = byteAt(address + 7);
					actualObj = (numSlots == (numSlotsMask())
						? address + BaseHeaderSize
						: address);
				}
				else {
					actualObj = GIV(nilObj);
				}
			}
			if (oopisGreaterThanOrEqualToandLessThan(actualObj, ((pastSpace()).start), GIV(pastSpaceStart))) {
				while (1) {
					/* begin objectAfter:limit: */
					followingWordAddress1 = addressAfter(actualObj);
					if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
						actualObj = GIV(pastSpaceStart);
						goto l3;
					}
					flag("endianness");
					followingWord1 = longAt(followingWordAddress1);
					actualObj = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
						? followingWordAddress1 + BaseHeaderSize
						: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
					if (!(oopisLessThan(actualObj, GIV(pastSpaceStart)))) break;
					if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
						subsequentObject = actualObj;
						goto l5;
					}
				}
				actualObj = GIV(nilObj);
			}
		}
		while (1) {
			/* begin objectAfter:limit: */
			followingWordAddress2 = addressAfter(actualObj);
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
				actualObj = GIV(endOfMemory);
				goto l4;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			actualObj = ((((usqInt)(followingWord2)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
	l4:	/* end objectAfter:limit: */;
			if (!(oopisLessThan(actualObj, GIV(endOfMemory)))) break;
			if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
				subsequentObject = actualObj;
				goto l5;
			}
		}
		subsequentObject = null;
	l5:	/* end instanceAfter: */;
		if (!(subsequentObject == null)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

	/* InterpreterPrimitives>>#primitiveNextObject */
static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    char *sp;
    char *sp1;

	if ((((longAt(GIV(stackPointer))) & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	instance = accessibleObjectAfter(longAt(GIV(stackPointer)));
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)0 << 3) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		assert(isInMemory(instance));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp1;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

	/* InterpreterPrimitives>>#primitiveNoop */
static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveNotEqual */
static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerReceiver & integerArgument) & (smallIntegerTag())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerReceiver != integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (signedMachineIntegerValueOf(integerReceiver)) != (signedMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveNotEqualLargeIntegers */
EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */
/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveNotIdentical */
static void
primitiveNotIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	thisObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	otherObject = longAt(GIV(stackPointer));
	if ((	/* begin isOopForwarded: */
		((!(otherObject & (tagMask()))))
	 && ((!((longAt(otherObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))
	 || ((GIV(argumentCount) > 1)
	 && (	/* begin isOopForwarded: */
		((!(thisObject & (tagMask()))))
	 && ((!((longAt(thisObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
	else {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject != otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	This primitive is called from Squeak as...
	arrayOfRoots uniquelyAccessibleObjects */
/*	This primitive answers an array of the receiver and every object in its
	proper tree of subParts (ie, that is not refered to from anywhere else
	outside the tree).
 */
/*	This primitive could be used to implement the primitiveStoreImageSegment
	segment, thanks to a suggestion from Igor Stassenko. Currently it is
	used only to debug that primitive. */

	/* InterpreterPrimitives>>#primitiveObjectsAccessibleFromRoots */
static void
primitiveObjectsAccessibleFromRoots(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt result;
    char *sp;


	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer));
	if (!(		/* begin isArray: */
			((!(arrayOfRoots & (tagMask()))))
		 && (((((usqInt)((longAt(arrayOfRoots)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		/* Must be indexable pointers */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = objectsAccessibleFromRoots(arrayOfRoots);
	if (((((result) & 7) == 1))
	 && (((result >> 3)) == PrimErrNoMemory)) {
		fullGC();
		arrayOfRoots = longAt(GIV(stackPointer));
		result = objectsAccessibleFromRoots(arrayOfRoots);
	}
	if ((((result) & 7) == 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (result >> 3);
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
}


/*	primitivePathTo: anObject using: stack <Array> followWeak: boolean
	Answer a path to anObject from the root that does not pass through
	the current context */

	/* InterpreterPrimitives>>#primitivePathToUsing */
EXPORT(sqInt)
primitivePathToUsing(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt current;
    sqInt err;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    usqInt freeStartAtStart;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt index;
    sqInt methodField;
    sqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots13;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt path;
    char *sp;
    sqInt stack;
    sqInt stackp;
    sqInt stackSize;

	err = 0;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(GIV(argumentCount) >= 2)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (!(((longAt(GIV(stackPointer))) == GIV(trueObj))
		 || ((longAt(GIV(stackPointer))) == GIV(falseObj)))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	stack = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin pathTo:using:followWeak: */
	if (!(		/* begin isArray: */
			((!(stack & (tagMask()))))
		 && (((((usqInt)((longAt(stack)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		err = PrimErrBadArgument;
		goto l8;
	}
	assert(allObjectsUnmarked());
	/* check no allocations during search */
	freeStartAtStart = freeStart();
	beRootIfOld(stack);
	/* begin lengthOf: */
	fmt = (((usqInt)((longAt(stack)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(stack + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(stack - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		stackSize = numSlots2;
		goto l3;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		stackSize = (numSlots2 << (shiftForWord())) - (fmt & 7);
		goto l3;
	}
	if (fmt >= (firstShortFormat())) {
		stackSize = (numSlots2 << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l3;
	}
	if (fmt >= (firstLongFormat())) {
		stackSize = (numSlots2 << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l3;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		stackSize = numSlots2;
		goto l3;
	}
	stackSize = 0;
	l3:	/* end lengthOf: */;
	/* begin mark: */
	assert(!(isFreeObject(stack)));
	longAtput(stack, (longAt(stack)) | (1ULL << (markedBitFullShift())));
	current = specialObjectsOop();
	/* begin mark: */
	assert(!(isFreeObject(current)));
	longAtput(current, (longAt(current)) | (1ULL << (markedBitFullShift())));
	/* begin lengthOf: */
	fmt1 = (((usqInt)((longAt(current)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots12 = byteAt(current + 7);
	numSlots3 = (numSlots12 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(current - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots12);
	if (fmt1 <= 5 /* begin ephemeronFormat */) {
		index = numSlots3;
		goto l5;
	}
	if (fmt1 >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		index = (numSlots3 << (shiftForWord())) - (fmt1 & 7);
		goto l5;
	}
	if (fmt1 >= (firstShortFormat())) {
		index = (numSlots3 << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l5;
	}
	if (fmt1 >= (firstLongFormat())) {
		index = (numSlots3 << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l5;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		index = numSlots3;
		goto l5;
	}
	index = 0;
	l5:	/* end lengthOf: */;
	stackp = 0;
	while (1) {
		while (((index -= 1)) >= -1) {
			if (			/* begin couldBeFramePointer: */
				(GIV(stackBasePlus1))
			 && ((((((usqInt)current)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)current)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)current)) <= (((usqInt)GIV(pages)))))))) {
				next = (index >= 0
					? fieldofFrame(index, ((char *) current))
					: GIV(nilObj));
			}
			else {
				if (index >= 0) {
					if (((longAt(current)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						next = fieldOrSenderFPofContext(index, current);
					}
					else {
						next = longAt((current + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					}
				}
				else {
					next = fetchClassOfNonImm(current);
				}
			}
			if (			/* begin couldBeFramePointer: */
				(GIV(stackBasePlus1))
			 && ((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages)))))))) {
				assert(isFrameonPage(((char *) next), stackPageFor(((char *) next))));
			}
			else {
				if (next >= heapBase) {
					/* exclude Cog methods */
					assert(checkOkayOop(next));
				}
			}
			if (next == (longAt(GIV(stackPointer) + (2 * BytesPerWord)))) {
				assert(freeStartAtStart == (freeStart()));
				unmarkAfterPathTo();
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(stack)),
				oopisGreaterThanOrEqualTo(stack, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(current & (tagMask()))))
					 && (oopisLessThan(current, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(stack)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(stack);
						}
					}
				}
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(stackp) << (shiftForWord())))), current);
				pruneStackstackp(stack, stackp);
				err = 0;
				goto l8;
			}
			if (((!(next & (smallIntegerTag()))))
			 && ((			/* begin couldBeFramePointer: */
				(GIV(stackBasePlus1))
			 && ((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages)))))))
				? !(frameIsMarked(next))
				: (next >= heapBase)
					 && ((!(((((usqInt)((longAt(next)))) >> (markedBitFullShift())) & 1) != 0))
					 && (((					/* begin isPointers: */
						((!(next & (tagMask()))))
					 && (((((usqInt)((longAt(next)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
					 || (((((usqInt)((longAt(next)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
					 && (((longAt(GIV(stackPointer))) == GIV(trueObj))
					 || (!(isWeakNonImm(next))))))))) {
				if ((stackp + 2) > stackSize) {
					assert(freeStartAtStart == (freeStart()));
					unmarkAfterPathTo();
					/* begin nilFieldsOf: */
					for (i = 0, iLimiT = (((assert((classIndexOf(stack)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(stack + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(stack - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i <= iLimiT; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(stack)));
						longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
					}
					err = PrimErrBadIndex;
					goto l8;
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(stackp) << (shiftForWord())))), current);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp + 1)) << (shiftForWord())))), (((usqInt)index << 3) | 1));
				stackp += 2;
				if (				/* begin couldBeFramePointer: */
					(GIV(stackBasePlus1))
				 && ((((((usqInt)(((char *) next)))) & (BytesPerWord - 1)) == 0)
				 && ((((((usqInt)(((char *) next)))) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)(((char *) next)))) <= (((usqInt)GIV(pages)))))))) {
					/* begin markFrame: */
					methodField = longAt(next + FoxMethod);
					if ((((usqInt)methodField)) < (startOfMemory())) {
						longAtput(next + FoxMethod, methodField | 4);
					}
					else {
						longAtput(next + FoxIFrameFlags, (longAt(next + FoxIFrameFlags)) | 2);
					}
					index = CtxtTempFrameStart + (stackPointerIndexForFrame(((char *) next)));
				}
				else {
					/* begin mark: */
					assert(!(isFreeObject(next)));
					longAtput(next, (longAt(next)) | (1ULL << (markedBitFullShift())));
					if (((((usqInt)((longAt(next)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
						index = (literalCountOf(next)) + LiteralStart;
					}
					else {
						/* begin lengthOf: */
						fmt2 = (((usqInt)((longAt(next)))) >> (formatShift())) & (formatMask());
						/* begin numSlotsOfAny: */
						numSlots13 = byteAt(next + 7);
						numSlots4 = (numSlots13 == (numSlotsMask())
							? ((((usqInt)(((sqInt)((usqInt)((longAt(next - BaseHeaderSize))) << 8)))))) >> 8
							: numSlots13);
						if (fmt2 <= 5 /* begin ephemeronFormat */) {
							index = numSlots4;
							goto l7;
						}
						if (fmt2 >= (firstByteFormat())) {
							/* bytes, including CompiledMethod */
							index = (numSlots4 << (shiftForWord())) - (fmt2 & 7);
							goto l7;
						}
						if (fmt2 >= (firstShortFormat())) {
							index = (numSlots4 << ((shiftForWord()) - 1)) - (fmt2 & 3);
							goto l7;
						}
						if (fmt2 >= (firstLongFormat())) {
							index = (numSlots4 << ((shiftForWord()) - 2)) - (fmt2 & 1);
							goto l7;
						}
						if (fmt2 == (sixtyFourBitIndexableFormat())) {
							index = numSlots4;
							goto l7;
						}
						index = 0;
	l7:	/* end lengthOf: */;
					}
				}
				current = next;
			}
		}
		if (current == (specialObjectsOop())) {
			assert(freeStartAtStart == (freeStart()));
			unmarkAfterPathTo();
			/* begin nilFieldsOf: */
			for (i1 = 0, iLimiT1 = (((assert((classIndexOf(stack)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(stack + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(stack - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) - 1); i1 <= iLimiT1; i1 += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), GIV(nilObj));
			}
			err = PrimErrNotFound;
			goto l8;
		}
		index = ((longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp - 1)) << (shiftForWord())))))) >> 3);
		current = longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)((stackp - 2)) << (shiftForWord())))));
		stackp -= 2;
	}
	l8:	/* end pathTo:using:followWeak: */;
	if (err != 0) {
		return (GIV(primFailCode) = err);
	}
	path = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), path);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitivePerformInSuperclass */
static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argumentArray;
    usqInt arraySize;
    sqInt currentClass;
    sqInt delta;
    sqInt err;
    sqInt hash;
    sqInt index;
    sqInt lookupClass;
    usqInt numSlots;
    sqInt objOop;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    usqInt savedNewMethod;
    sqInt selector;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt tagBits2;
    sqInt tagBits3;
    sqInt top;

	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	lookupClass = longAt(GIV(stackPointer));
	if (GIV(argumentCount) != 3) {
		/* e.g. object:perform:withArguments:inClass: */
		if (GIV(argumentCount) != 4) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		if (		/* begin isOopForwarded: */
			((!(rcvr & (tagMask()))))
		 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	/* begin fetchClassOf: */
	if (((tagBits = rcvr & (tagMask()))) != 0) {
		currentClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))));
	}
	else {
		currentClass = fetchClassOfNonImm(rcvr);
	}
	while (currentClass != lookupClass) {
		/* begin superclassOf: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop);
		}
		currentClass = objOop;
		if (currentClass == GIV(nilObj)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	selector = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	if (!(		/* begin isArray: */
			((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		GIV(performWithArgumentsRecursionGuard) = null;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l7;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	arraySize = (((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(performWithArgumentsRecursionGuard) = null;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l7;
	}
	/* Recursion check:
	   | a |
	   a := Array with: #perform:withArguments: with: nil.
	   a at: 2 put: a.
	   a perform: a first withArguments: a.
	   | a |
	   a := Array with: #perform:withArguments: with: (Array with: #perform:withArguments: with: nil).
	   a last at: 2 put: a.
	   a perform: a first withArguments: a */
	performArgCount = GIV(argumentCount);
	if (!GIV(performWithArgumentsRecursionGuard)) {
		GIV(performWithArgumentsRecursionGuard) = (lookupClass == null
			? longAt(GIV(stackPointer))
			: longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	}
	savedNewMethod = GIV(newMethod);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp1;
	for (index = 1; index <= arraySize; index += 1) {
		arg = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
		if (arg == GIV(performWithArgumentsRecursionGuard)) {
			GIV(performWithArgumentsRecursionGuard) = null;
		}
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), arg);
		GIV(stackPointer) = sp2;
	}
	if (!GIV(performWithArgumentsRecursionGuard)) {
		/* begin pop: */
		GIV(stackPointer) += (2 + arraySize) * BytesPerWord;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l7;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), (((tagBits2 = rcvr & (tagMask()))) != 0
		? tagBits2
		: (longAt(rcvr)) & (classIndexMask())));
	if (printOnTrace()) {
		printActivationNameForSelectorstartClass(GIV(messageSelector), (lookupClass == null
			? 
				/* begin fetchClassOf: */
(((tagBits3 = rcvr & (tagMask()))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits3) << (shiftForWord())))))
					: fetchClassOfNonImm(rcvr))
			: lookupClass));
		cr();
	}
	findNewMethodInClassTag((lookupClass == null
		? 
			/* begin fetchClassTagOf: */
(((tagBits1 = rcvr & (tagMask()))) != 0
				? tagBits1
				: (longAt(rcvr)) & (classIndexMask()))
		: (assert(addressCouldBeClassObj(lookupClass)),
			flag("todo"),
			(((hash = (long32At(lookupClass + 4)) & (identityHashHalfWordMask()))) != 0
					? hash
					: (objCouldBeClassObj(lookupClass)
							? (((err = enterIntoClassTable(lookupClass))) != 0
									? -err
									: (long32At(lookupClass + 4)) & (identityHashHalfWordMask()))
							: -PrimErrBadReceiver)))));
	if ((	/* begin isOopCompiledMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {
		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
			? rcvr
			: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(argumentCount) = performArgCount;
		primitiveFunctionPointer = (lookupClass == null
			? primitivePerformWithArgs
			: primitivePerformInSuperclass);
		GIV(performWithArgumentsRecursionGuard) = null;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l7;
	}
	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	if ((primitiveFunctionPointer == primitivePerformWithArgs)
	 || (primitiveFunctionPointer == primitivePerformInSuperclass)) {
		/* This should of course be a tail call, which could be done via setjmp/longjmp.
		   But this is vanity code. After all how often is a recursive invocation of
		   primitivePerformWithArgs et al made? */
		GIV(newMethod) = savedNewMethod;
		GIV(argumentCount) = performArgCount;
		/* begin pop: */
		GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
		slowPrimitiveResponse();
		GIV(performWithArgumentsRecursionGuard) = null;
		goto l7;
	}
	GIV(performWithArgumentsRecursionGuard) = null;
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	l7:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePerformWithArgs */
static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualReceiver;
    sqInt arg;
    sqInt argumentArray;
    usqInt arraySize;
    sqInt delta;
    sqInt index;
    usqInt numSlots;
    sqInt offset;
    sqInt performArgCount;
    usqInt savedNewMethod;
    sqInt selector;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt tagBits2;
    sqInt top;

	actualReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	selector = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer));
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	if (!(		/* begin isArray: */
			((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		GIV(performWithArgumentsRecursionGuard) = null;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l6;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	arraySize = (((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(performWithArgumentsRecursionGuard) = null;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l6;
	}
	/* Recursion check:
	   | a |
	   a := Array with: #perform:withArguments: with: nil.
	   a at: 2 put: a.
	   a perform: a first withArguments: a.
	   | a |
	   a := Array with: #perform:withArguments: with: (Array with: #perform:withArguments: with: nil).
	   a last at: 2 put: a.
	   a perform: a first withArguments: a */
	performArgCount = GIV(argumentCount);
	if (!GIV(performWithArgumentsRecursionGuard)) {
		GIV(performWithArgumentsRecursionGuard) = longAt(GIV(stackPointer));
	}
	savedNewMethod = GIV(newMethod);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp1;
	for (index = 1; index <= arraySize; index += 1) {
		arg = longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
		if (arg == GIV(performWithArgumentsRecursionGuard)) {
			GIV(performWithArgumentsRecursionGuard) = null;
		}
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), arg);
		GIV(stackPointer) = sp2;
	}
	if (!GIV(performWithArgumentsRecursionGuard)) {
		/* begin pop: */
		GIV(stackPointer) += (2 + arraySize) * BytesPerWord;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l6;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), (((tagBits2 = actualReceiver & (tagMask()))) != 0
		? tagBits2
		: (longAt(actualReceiver)) & (classIndexMask())));
	if (printOnTrace()) {
		printActivationNameForSelectorstartClass(GIV(messageSelector), 
		/* begin fetchClassOf: */
(((tagBits = actualReceiver & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
			: fetchClassOfNonImm(actualReceiver)));
		cr();
	}
	findNewMethodInClassTag(	/* begin fetchClassTagOf: */
		(((tagBits1 = actualReceiver & (tagMask()))) != 0
		? tagBits1
		: (longAt(actualReceiver)) & (classIndexMask())));
	if ((	/* begin isOopCompiledMethod: */
		((!(GIV(newMethod) & (tagMask()))))
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {
		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
			? actualReceiver
			: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(argumentCount) = performArgCount;
		primitiveFunctionPointer = primitivePerformWithArgs;
		GIV(performWithArgumentsRecursionGuard) = null;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l6;
	}
	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	if ((primitiveFunctionPointer == primitivePerformWithArgs)
	 || (primitiveFunctionPointer == primitivePerformInSuperclass)) {
		/* This should of course be a tail call, which could be done via setjmp/longjmp.
		   But this is vanity code. After all how often is a recursive invocation of
		   primitivePerformWithArgs et al made? */
		GIV(newMethod) = savedNewMethod;
		GIV(argumentCount) = performArgCount;
		/* begin pop: */
		GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
		slowPrimitiveResponse();
		GIV(performWithArgumentsRecursionGuard) = null;
		goto l6;
	}
	GIV(performWithArgumentsRecursionGuard) = null;
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	l6:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePinnedNew */
static void
primitivePinnedNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt classObj;
    sqInt err;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    sqInt numSlots;
    sqInt obj;
    usqInt p;
    sqInt reasonCode;
    char *sp;

	classObj = longAt(GIV(stackPointer));
	/* begin inOldSpaceInstantiatePinnedClass: */
	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (!(		/* begin isFixedSizePointerFormat: */
			(instSpec <= 1 /* begin nonIndexablePointerFormat */)
		 || (instSpec == 5 /* begin ephemeronFormat */))) {
		obj = null;
		goto l1;
	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	flag("todo");
	classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(classObj)
				? (((err = enterIntoClassTable(classObj))) != 0
						? -err
						: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -classIndex;
		obj = null;
		goto l1;
	}
	numSlots = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
	newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, 
	/* begin objectBytesForSlots: */
(numSlots == 0
		? 8 /* begin allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(numSlots) << (shiftForWord())))) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec, classIndex);
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, GIV(nilObj));
		}
	}
	obj = newObj;
	l1:	/* end inOldSpaceInstantiatePinnedClass: */;
	if (obj == null) {
		reasonCode = (isFixedSizePointerFormat((((usqInt)((((longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask()))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}


/*	Allocate a new pinned indexable instance. Fail if the allocation would
	leave less than lowSpaceThreshold bytes free.
 */

	/* InterpreterPrimitives>>#primitivePinnedNewWithArg */
static void
primitivePinnedNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classFormat;
    sqInt classIndex;
    sqInt classObj;
    sqInt err;
    sqInt fillValue;
    sqInt fmt;
    sqInt hash;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt newObj;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    int ok;
    sqInt oop;
    usqInt p;
    sqInt reasonCode;
    usqIntptr_t size;
    char *sp;
    sqInt value;

	oop = longAt(GIV(stackPointer));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l5;
		}
		size = value;
		goto l5;
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l5;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l5;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
		goto l5;
	}
	size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	l5:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	classObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin inOldSpaceInstantiatePinnedClass:indexableSize: */
	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec1 = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	fillValue = 0;
	switch (instSpec1) {
	case arrayFormat():
		numSlots = size;
		fillValue = GIV(nilObj);
		break;
	case indexablePointersFormat():
	case weakArrayFormat():
		numSlots = (classFormat & ((1U << (fixedFieldsFieldWidth())) - 1)) + size;
		fillValue = GIV(nilObj);
		break;
	case sixtyFourBitIndexableFormat():
		numSlots = size;
		break;
	case firstLongFormat():
		if ((classIndex == ClassFloatCompactIndex)
		 && (size != 2)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			obj = null;
			goto l1;
		}
		numSlots = (size + 1) / 2;
		instSpec1 += size & 1;
		break;
	case firstShortFormat():
		numSlots = (size + 3) / 4;
		instSpec1 += (4 - size) & 3;
		break;
	case firstByteFormat():
		numSlots = (size + 7) / 8;
		instSpec1 += (8 - size) & 7;
		break;
	default:
		/* non-indexable */
		/* Some Squeak images include funky fixed subclasses of abstract variable
		   superclasses. e.g. DirectoryEntry as a subclass of ArrayedCollection.
		   The (Threaded)FFIPlugin expects to be able to instantiate ExternalData via
		   this method.
		   Hence allow fixed classes to be instantiated here iff nElements = 0. */
		if ((size != 0)
		 || (instSpec1 > 5 /* begin lastPointerFormat */)) {
			obj = null;
			goto l1;
		}
		numSlots = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
		fillValue = GIV(nilObj);
	}
	if (classIndex == 0) {
		/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(classObj));
		flag("todo");
		if (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0) {
			classIndex = hash;
		}
		else {
			if (objCouldBeClassObj(classObj)) {
				if (((err = enterIntoClassTable(classObj))) != 0) {
					classIndex = -err;
				}
				else {
					classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
				}
			}
			else {
				classIndex = -PrimErrBadReceiver;
			}
		}
		if (classIndex < 0) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = -classIndex;
			obj = null;
			goto l1;
		}
	}
	if (numSlots > (0x10000000000LL)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrUnsupported;
		obj = null;
		goto l1;
	}
	newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, 
	/* begin objectBytesForSlots: */
(numSlots == 0
		? 8 /* begin allocationUnit */ + BaseHeaderSize
		: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec1, classIndex);
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, fillValue);
		}
	}
	obj = newObj;
	l1:	/* end inOldSpaceInstantiatePinnedClass:indexableSize: */;
	if (obj == null) {
		instSpec = (((usqInt)((((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
		reasonCode = ((		/* begin isIndexableFormat: */
			(instSpec >= (arrayFormat()))
		 && ((instSpec <= (weakArrayFormat()))
		 || (instSpec >= (sixtyFourBitIndexableFormat()))))
		 && (!(instSpec >= (firstCompiledMethodFormat())))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

	/* InterpreterPrimitives>>#primitiveProfilePrimitive */
EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;


	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
	return 0;
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

	/* InterpreterPrimitives>>#primitiveProfileSample */
EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;


	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
	return 0;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

	/* InterpreterPrimitives>>#primitiveProfileStart */
EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;

	deltaTicks = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((deltaTicks) & 7) == 1)) {
		GIV(nextProfileTick) = (ioHighResClock()) + ((deltaTicks >> 3));
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		return 0;
	}
	return (GIV(primFailCode) = PrimErrBadArgument);
}

	/* InterpreterPrimitives>>#primitiveQuit */
static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 3)
		: 0));
}


/*	Rounds negative results towards zero. */

	/* InterpreterPrimitives>>#primitiveQuo */
static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	integerResult = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		integerRcvr = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		integerArg = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
	}
	/* begin success: */
	if (!(integerArg != 0)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		integerResult = 
		/* begin quot:ient: */
(integerRcvr > 0
			? (integerArg > 0
					? integerRcvr / integerArg
					: 0 - (integerRcvr / (0 - integerArg)))
			: (integerArg > 0
					? 0 - ((0 - integerRcvr) / integerArg)
					: (0 - integerRcvr) / (0 - integerArg)));
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt)(integerResult)) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveQuoLargeIntegers */
EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

	/* InterpreterPrimitives>>#primitiveRelinquishProcessor */
static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		microSecs = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
	}
	if (!GIV(primFailCode)) {
		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */
		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveRemLargeIntegers */
EXPORT(void)
primitiveRemLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	The character scanner primitive. */

	/* InterpreterPrimitives>>#primitiveScanCharacters */
static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		kernDelta = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
	}
	stops = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		scanRightX = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
	}
	sourceString = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	if ((((integerPointer2) & 7) == 1)) {
		scanStopIndex = (integerPointer2 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	if ((((integerPointer3) & 7) == 1)) {
		scanStartIndex = (integerPointer3 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
	}
	rcvr = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if (GIV(primFailCode)) {
		return;
	}
	if (!((		/* begin isArray: */
			((!(stops & (tagMask()))))
		 && (((((usqInt)((longAt(stops)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((slotSizeOf(stops)) >= 258)
		 && ((		/* begin isBytes: */
			((!(sourceString & (tagMask()))))
		 && (((((usqInt)((longAt(sourceString)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
		 && ((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && ((scanStopIndex <= (byteSizeOf(sourceString)))
		 && ((		/* begin isPointers: */
			((!(rcvr & (tagMask()))))
		 && (((((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((slotSizeOf(rcvr)) >= 4))))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord())));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord())));
	if (!((		/* begin isArray: */
			((!(scanXTable & (tagMask()))))
		 && (((((usqInt)((longAt(scanXTable)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && ((		/* begin isArray: */
			((!(scanMap & (tagMask()))))
		 && (((((usqInt)((longAt(scanMap)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((slotSizeOf(scanMap)) == 0x100)
		 && (!GIV(primFailCode)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */
	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {
		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */
		/* Known to be okay since stops size >= 258 */
		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)(ascii) << (shiftForWord()))))))) == nilOop)) {
			/* Store everything back and get out of here since some stop conditionn needs to be checked */
			if (!((((((usqInt)(scanDestX)) >> 60) + 1) & 15) <= 1)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt)(scanDestX)) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt)(scanLastIndex)) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanLastIndex << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((6) * BytesPerWord)), stopReason);
			GIV(stackPointer) = sp;
			return;
		}
		/* fail if the glyphIndex is out of range */
		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);
		/* Above may fail if non-integer entries in scanXTable */
		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {
			/* Store everything back and get out of here since we got to the right edge */
			if (!((((((usqInt)(scanDestX)) >> 60) + 1) & 15) <= 1)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt)(scanDestX)) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((((usqInt)(scanLastIndex)) >> 60) + 1) & 15) <= 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanLastIndex << 3) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((6) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)((CrossedX - 1)) << (shiftForWord()))))));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((((((usqInt)(scanDestX)) >> 60) + 1) & 15) <= 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt)(scanDestX)) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(rcvr)));
		longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((((usqInt)(scanStopIndex)) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(rcvr)));
		longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanStopIndex << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + ((6) * BytesPerWord)), longAt((stops + BaseHeaderSize) + (((sqInt)((usqInt)((EndOfRun - 1)) << (shiftForWord()))))));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

	/* InterpreterPrimitives>>#primitiveScreenDepth */
EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)depth << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer a float indicating the current scale factor for pixels of the
	Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveScreenScaleFactor */
EXPORT(sqInt)
primitiveScreenScaleFactor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double factor;
    char *sp;

	factor = ioScreenScaleFactor();
	if (!GIV(primFailCode)) {
		/* begin methodReturnFloat: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), floatObjectOf(factor));
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	Answer a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the
	point is encoded into a single 32bit value in the image header.
	This might well become a problem one day */

	/* InterpreterPrimitives>>#primitiveScreenSize */
static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    usqInt pointResult;
    sqInt pointWord;
    char *sp;

	pointWord = ioScreenSize();
	/* begin makePointwithxValue:yValue: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))));
	numSlots = YIndex + 1;
	/* begin eeInstantiateSmallClass:numSlots: */
	assert((rawHashBitsOf(classObj)) != 0);
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	objFormat = (((usqInt)((((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)((((usqInt)(pointWord)) >> 16) & 0xFFFF) << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)(pointWord & 0xFFFF) << 3) | 1));
	oop = pointResult;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

	/* InterpreterPrimitives>>#primitiveSecondsClock */
static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = ((((((usqInt)(ioSecondsNow()))) & 0xFFFFFFFFU) << 3) | 1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Ask the GUI to set the requested display mode.
	See DisplayScreen class depth:width:height:fullscreen: */

	/* InterpreterPrimitives>>#primitiveSetDisplayMode */
static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;


	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	};
	fsFlag = null;
	l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		h = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		w = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((((integerPointer2) & 7) == 1)) {
		d = (integerPointer2 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
	}
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	okay = ioSetDisplayMode(w, h, d, fsFlag);
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}
	/* begin methodReturnBool: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (okay
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

	/* InterpreterPrimitives>>#primitiveSetFullScreen */
static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin setFullScreenFlag: */
		GIV(fullScreenFlag) = argOop == GIV(trueObj);
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSetImmutability */
#if IMMUTABILITY
static void
primitiveSetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt wasImmutable;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	wasImmutable = 
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		if (!(canBeImmutable(rcvr))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			return;
		}
		/* begin setIsImmutableOf:to: */
		longAtput(rcvr, (longAt(rcvr)) | (1U << (immutableBitShift())));
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			/* begin setIsImmutableOf:to: */
			longAtput(rcvr, (longAt(rcvr)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
		}
		else {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (wasImmutable
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

	/* InterpreterPrimitives>>#primitiveSetInterruptKey */
static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		keycode = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
	}
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

	/* InterpreterPrimitives>>#primitiveSetLogDirectory */
EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(		/* begin isBytes: */
			((!(stringOop & (tagMask()))))
		 && (((((usqInt)((longAt(stringOop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		return null;
	}
	/* begin byteSizeOf: */
	if (((stringOop & (tagMask())) != 0)) {
		sz = 0;
		goto l2;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt)((longAt(stringOop)))) >> (formatShift())) & (formatMask());
	assert((classIndexOf(stringOop)) > (isForwardedObjectClassIndexPun()));
	numBytes = (((numSlots = byteAt(stringOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(stringOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {
		/* bytes (the common case), including CompiledMethod */
		sz = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		sz = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		sz = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l2;
	}
	sz = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l2:	/* end byteSizeOf: */;
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveSetOrHasIdentityHash */
static void
primitiveSetOrHasIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasHash;
    sqInt hash;
    usqInt hash1;
    usqInt hash2;
    sqInt isReceiverAClass;
    sqInt lastArg;
    usqInt oldHash;
    char *sp;
    char *sp1;
    sqInt thisReceiver;

	if (GIV(argumentCount) == 0) {
		hasHash = ((!((longAt(GIV(stackPointer))) & (tagMask()))))
		 && ((long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask()));
		/* begin methodReturnBool: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (hasHash
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	isReceiverAClass = 0;
	if (GIV(argumentCount) == 2) {
		lastArg = longAt(GIV(stackPointer));
		if ((((lastArg) & 7) == 1)) {
			/* e.g. Symbol primitiveSetIdentityHashOf: aSymbol to: hash */
			hash = lastArg;
			thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		}
		else {
			/* anObject primitiveSetIdentityHash: hashValue isBehavior: boolean */
			thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
			hash = longAt(GIV(stackPointer) + (1 * BytesPerWord));
			if (lastArg == GIV(trueObj)) {
				isReceiverAClass = 1;
			}
			else {
				if (!(lastArg == GIV(falseObj))) {
					/* begin primitiveFailFor: */
					GIV(primFailCode) = PrimErrBadArgument;
					return;
				}
			}
		}
	}
	else {
		/* anObject primitiveSetIdentityHashTo: hash */
		thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		hash = longAt(GIV(stackPointer));
	}
	if (!(((((hash) & 7) == 1))
		 && ((		/* if written naturally, clang warns: unsequenced modification and access to 'hash' */
			(hash = (hash >> 3)),
		(hash & (identityHashHalfWordMask())) == hash)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (!((!(thisReceiver & (tagMask()))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (thisReceiver == (longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord)))
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		return;
	}
	/* begin hashBitsOf: */
	hash2 = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask());
	if (hash2 == 0) {
		/* cb 1/19/2017 18:34:
		   would like to assert
		   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
		   but instance-specific behaviors that are instances of themselves may
		   fail this test. */
		/* eem 12/28/2021 11:52 I'm not sure this is the issue. The issue is only validating objOop as a behavior. */
		flag("todo");
		/* begin newHashBitsOf: */
		hash1 = (newObjectHash()) & (identityHashHalfWordMask());
		assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
		long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
		hash2 = hash1;
	}
	oldHash = hash2;
	/* begin setHashBitsOf:to: */
	assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
	long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
	if (isReceiverAClass) {
		classAtIndexput(hash, thisReceiver);
		allInstancesOf(thisReceiver);
	}
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((oldHash << 3) | 1));
	GIV(stackPointer) = sp1;
}


/*	Primitive. Set the OS window's label */

	/* InterpreterPrimitives>>#primitiveSetWindowLabel */
EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt labelOop;
    usqInt numBytes;
    usqInt numSlots;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(		/* begin isBytes: */
			((!(labelOop & (tagMask()))))
		 && (((((usqInt)((longAt(labelOop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		return null;
	}
	/* begin byteSizeOf: */
	if (((labelOop & (tagMask())) != 0)) {
		sz = 0;
		goto l2;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt)((longAt(labelOop)))) >> (formatShift())) & (formatMask());
	assert((classIndexOf(labelOop)) > (isForwardedObjectClassIndexPun()));
	numBytes = (((numSlots = byteAt(labelOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(labelOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {
		/* bytes (the common case), including CompiledMethod */
		sz = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		sz = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		sz = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l2;
	}
	sz = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l2:	/* end byteSizeOf: */;
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveSetWindowSize */
EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		h = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		w = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
	}
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as
	an array of signed 16-bit values. Answer the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word.  */

	/* InterpreterPrimitives>>#primitiveShortAt */
static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(		/* begin isWordsOrBytes: */
			((!(rcvr & (tagMask()))))
		 && (isWordsOrBytesNonImm(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 3);
	if (!((index >= 1)
		 && (index <= (((usqInt)((numBytesOf(rcvr)))) >> 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	value = shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

	/* InterpreterPrimitives>>#primitiveShortAtPut */
static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((value) & 7) == 1))
		 && (((((index) & 7) == 1))
		 && (((value = (value >> 3)),
		(value >= -32768)
			 && (value <= 0x7FFF)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(		/* begin isWordsOrBytes: */
			((!(rcvr & (tagMask()))))
		 && (isWordsOrBytesNonImm(rcvr)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	index = (index >> 3);
	if (!((index >= 1)
		 && (index <= (((usqInt)((numBytesOf(rcvr)))) >> 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin storeShort16:ofObject:withValue: */
	shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))), value);
	longAtput((sp = GIV(stackPointer) + ((2) * BytesPerWord)), (((usqInt)value << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

	/* InterpreterPrimitives>>#primitiveShowDisplayRect */
static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		bottom = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((integerPointer1) & 7) == 1)) {
		top = (integerPointer1 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((((integerPointer2) & 7) == 1)) {
		right = (integerPointer2 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
	}
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((((integerPointer3) & 7) == 1)) {
		left = (integerPointer3 >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
	}
	if (!GIV(primFailCode)) {
		updateDisplayLeftTopRightBottom(left, top, right, bottom);
		ioForceDisplayUpdate();
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Set the low-water mark for free space. When the free space falls
	below this level, the new and new: primitives fail and system attempts
	to allocate space (e.g., to create a method context) cause the low-space
	semaphore (if one is registered) to be signalled. */

	/* InterpreterPrimitives>>#primitiveSignalAtBytesLeft */
static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;

	bytes = longAt(GIV(stackPointer));
	if (((((bytes) & 7) == 1))
	 && (((bytes = (bytes >> 3))) >= 0)) {
		/* begin lowSpaceThreshold: */
		/* N.B. The threshold > 0 guard eliminates a warning when
		   self lowSpaceThreshold: 0
		   is inlined into setSignalLowSpaceFlagAndSaveProcess */
		GIV(lowSpaceThreshold) = bytes;
		if ((bytes > 0)
		 && (GIV(totalFreeOldSpace) < bytes)) {
			growOldSpaceByAtLeast(bytes - GIV(totalFreeOldSpace));
		}
		assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Computes sine of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveSine */
static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	aValue = floatObjectOf(sin(doubleValue));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSize */
static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if ((((rcvr & (tagMask())) != 0))
	 || (((hdr = long64At(rcvr)),
	(((fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask()))) < (arrayFormat()))
		 || (fmt == 7 /* begin forwardedFormat */)))) {
		/* And if Spur, this is a forwarder. */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		primitiveContextSize();
		return;
	}
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l2;
	}
	totalLength = 0;
	l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l3:	/* end fixedFieldsOf:format:length: */;
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(totalLength - fixedFields) << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSizeInBytes */
static void
primitiveSizeInBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong byteSize;
    sqInt oop;
    char *sp;


	/* begin totalByteSizeOf: */
	if ((((longAt(GIV(stackPointer))) & (tagMask())) != 0)) {
		byteSize = 0;
	}
	else {
		byteSize = bytesInBody(longAt(GIV(stackPointer)));
	}
	oop = positive64BitIntegerFor(byteSize);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer the byte size of an instance of the receiver. If num args > 0
	then the last argument is a variable size and the size answered is the
	size of an instance of the receiver with that many indexable elements. */

	/* InterpreterPrimitives>>#primitiveSizeInBytesOfInstance */
static void
primitiveSizeInBytesOfInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt byteSize;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt code;
    int code1;
    sqInt err;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt nElements;
    usqInt numSlots;
    sqInt numSlots1;
    sqInt oop;
    char *sp;
    char *sp1;

	code = 0;
	if (GIV(argumentCount) > 1) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	err = -1;
	if (GIV(argumentCount) >= 1) {
		if (!(((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		nElements = ((longAt(GIV(stackPointer))) >> 3);
		/* begin byteSizeOfInstanceOf:withIndexableSlots:errInto: */
		classFormat = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
		instSpec = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
		switch (instSpec) {
		case arrayFormat():
			numSlots = nElements;
			break;
		case indexablePointersFormat():
		case weakArrayFormat():
			numSlots = (classFormat & ((1U << (fixedFieldsFieldWidth())) - 1)) + nElements;
			break;
		case sixtyFourBitIndexableFormat():
			numSlots = nElements;
			break;
		case firstLongFormat():
			numSlots = (nElements + 1) / 2;
			break;
		case firstShortFormat():
			numSlots = (nElements + 3) / 4;
			break;
		case firstByteFormat():
			numSlots = (nElements + (BytesPerOop - 1)) / BytesPerOop;
			break;
		case firstCompiledMethodFormat():
			/* Assume nElements is derived from CompiledMethod>>basicSize. */
			numSlots = (nElements + (BytesPerOop - 1)) / BytesPerOop;
			break;
		default:
			byteSize = (err = PrimErrBadReceiver);
			goto l1;
		}
		if (numSlots >= ((((usqInt)1)) << ((BytesPerOop * 8) - 3 /* begin logBytesPerOop */))) {
			code1 = (nElements < 0
				? PrimErrBadArgument
				: PrimErrLimitExceeded);
			byteSize = (err = code1);
			goto l1;
		}
		byteSize = 
		/* begin objectBytesForSlots: */
(numSlots == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)));
	l1:	/* end byteSizeOfInstanceOf:withIndexableSlots:errInto: */;
		if (err >= 0) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = err;
			return;
		}
		oop = positive64BitIntegerFor(byteSize);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOfInstanceOf:errInto: */
	classFormat1 = ((longAt(((longAt(GIV(stackPointer) + (0 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec1 = (((usqInt)(classFormat1)) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (!(		/* begin isFixedSizePointerFormat: */
			(instSpec1 <= 1 /* begin nonIndexablePointerFormat */)
		 || (instSpec1 == 5 /* begin ephemeronFormat */))) {
		byteSize = (err = PrimErrBadReceiver);
		goto l2;
	}
	numSlots1 = classFormat1 & ((1U << (fixedFieldsFieldWidth())) - 1);
	byteSize = 
	/* begin objectBytesForSlots: */
(numSlots1 == 0
		? 8 /* begin allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(numSlots1) << (shiftForWord())))) + ((numSlots1 >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)));
	l2:	/* end byteSizeOfInstanceOf:errInto: */;
	if (err >= 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = err;
		return;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + ((0) * BytesPerWord)), ((byteSize << 3) | 1));
	GIV(stackPointer) = sp1;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatAdd */
static void
primitiveSmallFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatArctan */
static void
primitiveSmallFloatArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	aValue = floatObjectOf(atan(rcvr));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatCosine */
static void
primitiveSmallFloatCosine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	aValue = floatObjectOf(cos(rcvr));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatDivide */
static void
primitiveSmallFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (arg == 0.0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatEqual */
static void
primitiveSmallFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt intArg;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		if ((rcvr == arg)
		 && (((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			intArg = ((longAt(GIV(stackPointer))) >> 3);
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), ((((sqInt)rcvr)) == intArg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (rcvr == arg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Computes E raised to the receiver power.
	Since SmallFloats cannot represent NaNs there's no need to special case. */

	/* InterpreterPrimitives>>#primitiveSmallFloatExp */
static void
primitiveSmallFloatExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;

	aValue = floatObjectOf(exp(smallFloatValueOf(longAt(GIV(stackPointer)))));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Answer the exponent part of this float. */

	/* InterpreterPrimitives>>#primitiveSmallFloatExponent */
static void
primitiveSmallFloatExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqInt exp;

	aValue = (((((/* begin exponentOfSmallFloat: */
	assert(((longAt(GIV(stackPointer))) & (tagMask())) == (smallFloatTag())),
((((usqInt)(longAt(GIV(stackPointer))))) <= 15
		? 0
		: ((exp = ((((usqInt)(longAt(GIV(stackPointer)))))) >> (((numTagBits()) + (smallFloatMantissaBits())) + 1)),
			(exp + (smallFloatExponentOffset())) - 0x3FE)))) - 1) << 3) | 1);
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatFractionalPart */
static void
primitiveSmallFloatFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double frac;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double trunc;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	frac = modf(rcvr, (&trunc));
	aValue = floatObjectOf(frac);
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatGreaterOrEqual */
static void
primitiveSmallFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt intArg;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		if ((rcvr == arg)
		 && (((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			intArg = ((longAt(GIV(stackPointer))) >> 3);
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), ((((sqInt)rcvr)) >= intArg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (rcvr >= arg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatGreaterThan */
static void
primitiveSmallFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt intArg;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		if ((rcvr == arg)
		 && (((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			intArg = ((longAt(GIV(stackPointer))) >> 3);
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), ((((sqInt)rcvr)) > intArg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (rcvr > arg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatLessOrEqual */
static void
primitiveSmallFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt intArg;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		if ((rcvr == arg)
		 && (((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			intArg = ((longAt(GIV(stackPointer))) >> 3);
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), ((((sqInt)rcvr)) <= intArg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (rcvr <= arg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatLessThan */
static void
primitiveSmallFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt intArg;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		if ((rcvr == arg)
		 && (((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			intArg = ((longAt(GIV(stackPointer))) >> 3);
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), ((((sqInt)rcvr)) < intArg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (rcvr < arg
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Natural log. */

	/* InterpreterPrimitives>>#primitiveSmallFloatLogN */
static void
primitiveSmallFloatLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	aValue = floatObjectOf(log(rcvr));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatMultiply */
static void
primitiveSmallFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatNotEqual */
static void
primitiveSmallFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt intArg;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    char *sp1;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		if ((rcvr == arg)
		 && (((((longAt(GIV(stackPointer)))) & 7) == 1))) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			intArg = ((longAt(GIV(stackPointer))) >> 3);
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (!((((sqInt)rcvr)) == intArg)
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (!(rcvr == arg)
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSine */
static void
primitiveSmallFloatSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	aValue = floatObjectOf(sin(rcvr));
	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSquareRoot */
static void
primitiveSmallFloatSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	if (rcvr >= 0.0) {
		aValue = floatObjectOf(sqrt(rcvr));
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), aValue);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSmallFloatSubtract */
static void
primitiveSmallFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    sqInt floatOrIntOop;
    sqInt oop;
    double rcvr;
    double result;
    usqLong rot;
    usqLong rot1;
    char *sp;
    sqInt tagBits;
    double value;
    double value1;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	floatOrIntOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot1 = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			arg = ((double) ((floatOrIntOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			arg = result;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
}


/*	Multiply the receiver by the power of the argument. */

	/* InterpreterPrimitives>>#primitiveSmallFloatTimesTwoPower */
static void
primitiveSmallFloatTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt twiceMaxExponent;

	arg = longAt(GIV(stackPointer));
	if (!((((arg) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	/* N.B. SmallFloats are finite.  NaN and Infinity overflow into boxed floats.
	   This is doing range checking work that is done in ldexp, but we include
	   it explicitly to exemplify bit manipulation of SmallFloats. */
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((	/* begin isSmallFloatZero: */
		assert(isImmediateFloat(rcvr)),
	(((usqInt)rcvr)) <= ((1U << (numTagBits())) + (smallFloatTag())))) {
		result = rcvr;
	}
	else {
		arg = (arg >> 3);
		twiceMaxExponent = 0x1000;
		if (arg < (-twiceMaxExponent)) {
			/* begin mapSignedSmallFloatToSignedSmallFloatZero: */
			assert(isImmediateFloat(rcvr));
			result = rcvr & ((1U << (numTagBits())) + (tagMask()));
		}
		else {
			/* clip arg to at most int range; ldexp's last arg is of type int */
			if (arg > twiceMaxExponent) {
				arg = twiceMaxExponent;
			}
			result = floatObjectOf(ldexp(smallFloatValueOf(rcvr), ((int) arg)));
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSmallFloatTruncated */
static void
primitiveSmallFloatTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    sqInt oop;
    double rcvr;
    usqLong rot;
    double trunc;
    double value;

	/* begin smallFloatValueOf: */
	oop = longAt(GIV(stackPointer));
	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	rcvr = value;
	modf(rcvr, (&trunc));
	if ((((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) )))))
	 && ((((((usqInt)((((sqInt)trunc)))) >> 60) + 1) & 15) <= 1)) {
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), (((usqInt)(((sqInt)trunc)) << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}

	/* InterpreterPrimitives>>#primitiveSomeInstance */
static void
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt instance;
    char *sp;

	class = longAt(GIV(stackPointer));
	instance = initialInstanceOf(class);
	if (instance == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

	/* InterpreterPrimitives>>#primitiveSomeObject */
static void
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;


	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	object = firstAccessibleObject();
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

	/* InterpreterPrimitives>>#primitiveSpecialObjectsOop */
static void
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = specialObjectsOop();
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Computes square root of float receiver; receiver *must* be a float
	instance. 
 */

	/* InterpreterPrimitives>>#primitiveSquareRoot */
static void
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	if (doubleValue >= 0.0) {
		aValue = floatObjectOf(sqrt(doubleValue));
		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), aValue);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* InterpreterPrimitives>>#primitiveStoreImageSegment */
static void
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((		/* begin isArray: */
			((!(arrayOfRoots & (tagMask()))))
		 && (((((usqInt)((longAt(arrayOfRoots)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && ((		/* begin isArray: */
			((!(outPointerArray & (tagMask()))))
		 && (((((usqInt)((longAt(outPointerArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((!(segmentWordArray & (tagMask()))))
		 && (((((((usqInt)((longAt(segmentWordArray)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(segmentWordArray)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1)))))))) {
		/* Must be indexable words */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	if (ecode == PrimErrNeedCompaction) {
		fullGC();
		outPointerArray = longAt(GIV(stackPointer));
		segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	}
	if (ecode == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = ecode;
	}
}

	/* InterpreterPrimitives>>#primitiveStringAt */
static void
primitiveStringAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l6;
	}
	if (((!(index & (smallIntegerTag()))))
	 || ((GIV(argumentCount) > 1)
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l6;
	}
	index = (index >> 3);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l4;
	}
	totalLength = 0;
	l4:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l1;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l1;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l1:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = temporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l5;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, 
	/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			result = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l5;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l5;
		}
		if (fmt >= (firstShortFormat())) {
			result = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
			goto l5;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			result = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))));
			goto l5;
		}
		result = ((((((usqInt)(long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))))))) & 0xFFFFFFFFU) << 3) | 1);
		goto l5;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	result = 0;
	l5:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
				if (!(((result >= 0) && (result <= (0x3FFFFFFF))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			goto l6;
		}
		result = 
		/* begin characterForAscii: */
(((sqInt)((usqInt)(((result >> 3))) << (numTagBits())))) + (characterTag());
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	l6:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveStringAtPut */
static void
primitiveStringAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;
    usqLong unsigned64BitValueToStore;
    unsigned int unsignedValueToStore;
    sqInt value;
    sqInt value1;

	/* begin commonAtPut: */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l15;
	}
	if (((!(index & (smallIntegerTag()))))
	 || ((GIV(argumentCount) > 2)
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l15;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l15;
	}
	index = (index >> 3);
		value1 = asciiOfCharacter(value);
	/* begin stObject:at:put: */
	hdr = long64At(rcvr);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l2;
	}
	totalLength = 0;
	l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))))) {
			temporaryinput(index - 1, frameOfMarriedContext(rcvr), value1);
			goto l7;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, 
	/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(rcvr)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(value1 & (tagMask()))))
				 && (oopisLessThan(value1, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value1);
			goto l6;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((value1) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			signedValueToStore = (value1 >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l6;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((value1) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			signedValueToStore = (value1 >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))), signedValueToStore);
			goto l6;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			unsigned64BitValueToStore = positive64BitValueOf(value1);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l6;
		}
		unsignedValueToStore = positive32BitValueOf(value1);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l6:;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
	}
	l7:	/* end stObject:at:put: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
	l15:	/* end commonAtPut: */;
}


/*	<array> primReplaceFrom: start to: stop with: replacement startingAt:
	repStart 
	<primitive: 105> */

	/* InterpreterPrimitives>>#primitiveStringReplace */
static void
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    usqInt arrayLength;
    sqInt class;
    sqInt class1;
    sqInt i;
    sqInt mustRemember;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt oop;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    usqInt replLength;
    sqInt replStart;
    sqInt srcDelta;
    sqInt start;
    sqInt stop;


	/* begin primitiveSpurStringReplace */
	array = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	start = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	stop = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	repl = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	replStart = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((!(start & (smallIntegerTag()))))
	 || (((!(stop & (smallIntegerTag()))))
	 || (((!(replStart & (smallIntegerTag()))))
	 || (((repl & (tagMask())) != 0))))) {
		/* can happen in LgInt copy */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l10;
	}
	start = (start >> 3);
	stop = (stop >> 3);
	replStart = (replStart >> 3);
	if ((stop >= start)
	 && (
#  if IMMUTABILITY
		((((usqInt)((longAt(array)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l10;
	}
	arrayFmt = (((usqInt)((longAt(array)))) >> (formatShift())) & (formatMask());
	/* N.B. In the below start - 1 to: stop - 1 do:, Slang is intelligent enough to use < instead of <= so avoiding the stop - 1. */
	replFmt = (((usqInt)((longAt(repl)))) >> (formatShift())) & (formatMask());
	if (arrayFmt <= 5 /* begin lastPointerFormat */) {
		/* Array formats must be the same; but for copying, weak arrays are equivalent to arrays. */
		if (arrayFmt == (weakArrayFormat())) {
			arrayFmt = arrayFormat();
		}
		if (replFmt == (weakArrayFormat())) {
			replFmt = arrayFormat();
		}
		if (arrayFmt != replFmt) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			goto l10;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(array)) > (isForwardedObjectClassIndexPun()));
		arrayLength = (((numSlots = byteAt(array + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		/* begin fixedFieldsOf:format:length: */
		if ((arrayFmt >= (sixtyFourBitIndexableFormat()))
		 || (arrayFmt == (arrayFormat()))) {
			arrayInstSize = 0;
			goto l8;
		}
		if (arrayFmt < (arrayFormat())) {
			arrayInstSize = arrayLength;
			goto l8;
		}
		class = fetchClassOfNonImm(array);
		arrayInstSize = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l8:	/* end fixedFieldsOf:format:length: */;
		/* begin numSlotsOf: */
		assert((classIndexOf(repl)) > (isForwardedObjectClassIndexPun()));
		replLength = (((numSlots1 = byteAt(repl + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(repl - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		/* begin fixedFieldsOf:format:length: */
		if ((replFmt >= (sixtyFourBitIndexableFormat()))
		 || (replFmt == (arrayFormat()))) {
			replInstSize = 0;
			goto l9;
		}
		if (replFmt < (arrayFormat())) {
			replInstSize = replLength;
			goto l9;
		}
		class1 = fetchClassOfNonImm(repl);
		replInstSize = (((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l9:	/* end fixedFieldsOf:format:length: */;
		if (!((start >= 1)
			 && (((start - 1) <= stop)
			 && (((stop + arrayInstSize) <= arrayLength)
			 && ((replStart >= 1)
			 && ((((stop - start) + replStart) + replInstSize) <= replLength)))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			goto l10;
		}
		start += arrayInstSize;
		stop += arrayInstSize;
		srcDelta = (replStart + replInstSize) - start;
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(array)),
		oopisGreaterThanOrEqualTo(array, GIV(oldSpaceStart)))) {
			mustRemember = 0;
			for (i = (start - 1); i < stop; i += 1) {
				oop = longAt((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << (shiftForWord())))));
				if (				/* begin isYoung: */
					((!(oop & (tagMask()))))
				 && (oopisLessThan(oop, GIV(oldSpaceStart)))) {
					mustRemember = 1;
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(array)));
				longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), oop);
			}
			if (mustRemember) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(array)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(array);
				}
			}
		}
		else {
			for (i = (start - 1); i < stop; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(array)));
				longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << (shiftForWord()))))));
			}
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		goto l10;
	}
	/* begin lengthOf:format: */
	numSlots11 = byteAt(array + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (arrayFmt <= 5 /* begin ephemeronFormat */) {
		arrayLength = ((sqInt) numSlots2);
		goto l3;
	}
	if (arrayFmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		arrayLength = (numSlots2 << (shiftForWord())) - (arrayFmt & 7);
		goto l3;
	}
	if (arrayFmt >= (firstShortFormat())) {
		arrayLength = (numSlots2 << ((shiftForWord()) - 1)) - (arrayFmt & 3);
		goto l3;
	}
	if (arrayFmt >= (firstLongFormat())) {
		arrayLength = (numSlots2 << ((shiftForWord()) - 2)) - (arrayFmt & 1);
		goto l3;
	}
	if (arrayFmt == (sixtyFourBitIndexableFormat())) {
		arrayLength = ((sqInt) numSlots2);
		goto l3;
	}
	arrayLength = 0;
	l3:	/* end lengthOf:format: */;
	/* begin lengthOf:format: */
	numSlots12 = byteAt(repl + 7);
	numSlots3 = (numSlots12 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(repl - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots12);
	if (replFmt <= 5 /* begin ephemeronFormat */) {
		replLength = ((sqInt) numSlots3);
		goto l5;
	}
	if (replFmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		replLength = (numSlots3 << (shiftForWord())) - (replFmt & 7);
		goto l5;
	}
	if (replFmt >= (firstShortFormat())) {
		replLength = (numSlots3 << ((shiftForWord()) - 1)) - (replFmt & 3);
		goto l5;
	}
	if (replFmt >= (firstLongFormat())) {
		replLength = (numSlots3 << ((shiftForWord()) - 2)) - (replFmt & 1);
		goto l5;
	}
	if (replFmt == (sixtyFourBitIndexableFormat())) {
		replLength = ((sqInt) numSlots3);
		goto l5;
	}
	replLength = 0;
	l5:	/* end lengthOf:format: */;
	/* begin classFormatFromInstFormat: */
	if (arrayFmt >= (firstByteFormat())) {
		/* this is likely the common case */
		arrayFmt = arrayFmt & -8;
		goto l6;
	}
	if (arrayFmt <= (sixtyFourBitIndexableFormat())) {
		goto l6;
	}
	if (arrayFmt < (firstShortFormat())) {
		arrayFmt = arrayFmt & -2;
		goto l6;
	}
	arrayFmt = arrayFmt & -4;
	l6:	/* end classFormatFromInstFormat: */;
	/* begin classFormatFromInstFormat: */
	if (replFmt >= (firstByteFormat())) {
		/* this is likely the common case */
		replFmt = replFmt & -8;
		goto l7;
	}
	if (replFmt <= (sixtyFourBitIndexableFormat())) {
		goto l7;
	}
	if (replFmt < (firstShortFormat())) {
		replFmt = replFmt & -2;
		goto l7;
	}
	replFmt = replFmt & -4;
	l7:	/* end classFormatFromInstFormat: */;
	if (!((arrayFmt == replFmt)
		 && ((arrayFmt >= (sixtyFourBitIndexableFormat()))
		 && (arrayFmt < (firstCompiledMethodFormat()))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l10;
	}
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && ((stop <= arrayLength)
		 && ((replStart >= 1)
		 && (((stop - start) + replStart) <= replLength)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l10;
	}
	srcDelta = replStart - start;
	if (arrayFmt >= (firstShortFormat())) {
		/* 8 & 16-bit word type objects */
		if (arrayFmt >= (firstByteFormat())) {
			/* byte-type objects */
			for (i = (start - 1); i < stop; i += 1) {
				/* begin storeByte:ofObject:withValue: */
				byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + (srcDelta + i)));
			}
		}
		else {
			/* short type objects */
			for (i = (start - 1); i < stop; i += 1) {
				/* begin storeShort16:ofObject:withValue: */
				shortAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 1))), shortAt((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << 1)))));
			}
		}
	}
	else {
		/* 32 & 64-bit word type objects */
		if (arrayFmt >= (firstLongFormat())) {
			/* word-type objects */
			for (i = (start - 1); i < stop; i += 1) {
				/* begin storeLong32:ofObject:withValue: */
				long32Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 2))), long32At((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << 2)))));
			}
		}
		else {
			/* long type objects */
			for (i = (start - 1); i < stop; i += 1) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 3))), long64At((repl + BaseHeaderSize) + (((sqInt)((usqInt)((srcDelta + i)) << 3)))));
			}
		}
	}
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	l10:	/* end primitiveSpurStringReplace */;
}

	/* InterpreterPrimitives>>#primitiveSubtract */
static void
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((((usqInt)(integerResult)) >> 60) + 1) & 15) <= 1) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (((usqInt)integerResult << 3) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			};
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveSubtractLargeIntegers */
EXPORT(void)
primitiveSubtractLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative != bIsNegative) {
		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveTestAndSetOwnershipOfCriticalSection */
static void
primitiveTestAndSetOwnershipOfCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt objOop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
		if (		/* begin isOopForwarded: */
			((!(activeProc & (tagMask()))))
		 && ((!((longAt(activeProc)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
	}
	else {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));
		/* begin activeProcess */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}
	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(criticalSection)),
		oopisGreaterThanOrEqualTo(criticalSection, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(activeProc & (tagMask()))))
			 && (oopisLessThan(activeProc, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(criticalSection)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(criticalSection);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (((sqInt)((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
	GIV(stackPointer) = sp2;
}


/*	Return true if the host OS does support the given display depth. */

	/* InterpreterPrimitives>>#primitiveTestDisplayDepth */
static void
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	okay = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		bitsPerPixel = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
	}
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Given an object with indexable pointer fields, reduce the size of the
	indexable fields
	to the requested size. Answer the number of bytes freed, or zero if the
	object cannot
	be shortened.
 */

	/* InterpreterPrimitives>>#primitiveTestShortenIndexableSize */
#if TestingPrimitives
EXPORT(sqInt)
primitiveTestShortenIndexableSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt delta;
    sqInt indexableSize;
    sqInt integer;
    sqInt newSizeOop;
    usqInt numSlots;
    char *sp;

	newSizeOop = longAt(GIV(stackPointer));
	array = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((((newSizeOop) & 7) == 1))
		 && (((((newSizeOop >> 3)) >= 0) && (((newSizeOop >> 3)) <= ((stSizeOf(array)) - 1)))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	if (!(		/* begin canShorten: */
			((!(array & (tagMask()))))
		 && ((((		/* begin numSlotsOf: */
			assert((classIndexOf(array)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(array + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) > 0)
		 && ((((((usqInt)((longAt(array)))) >> (formatShift())) & (formatMask())) == (arrayFormat()))
		 || (((((((usqInt)((longAt(array)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(array)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1)))))))) {
		return (GIV(primFailCode) = PrimErrBadReceiver);
	}
	indexableSize = (newSizeOop >> 3);
	/* begin shorten:toIndexableSize: */
	assert((indexableSize >= 0)
	 && (indexableSize < (lengthOf(array))));
	delta = doShortentoIndexableSize(array, indexableSize);
	assert((lengthOf(followMaybeForwarded(array))) == indexableSize);
	runLeakCheckerFor(GCCheckShorten);
	integer = delta;
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}
#endif /* TestingPrimitives */


/*	Multiply the receiver by the power of the argument.
	Receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveTimesTwoPower */
static void
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aFloatOop;
    sqInt arg;
    usqLong bits;
    double rcvr;
    double result;
    double result1;
    usqLong rot;
    char *sp;
    sqInt twiceMaxExponent;
    double value;

	arg = longAt(GIV(stackPointer));
	if (!((((arg) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	arg = (arg >> 3);
	/* clip arg to at most int range; ldexp's last arg is of type int */
	twiceMaxExponent = 0x1000;
	if (arg < (-twiceMaxExponent)) {
		arg = -twiceMaxExponent;
	}
	else {
		if (arg > twiceMaxExponent) {
			arg = twiceMaxExponent;
		}
	}
	aFloatOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(aFloatOop));
	if ((aFloatOop & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(aFloatOop));
		rot = ((((usqInt)aFloatOop))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result1 = value;
	}
	else {
		fetchFloatAtinto(aFloatOop + BaseHeaderSize, result1);
	}
	rcvr = result1;
	result = ldexp(rcvr, ((int) arg));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), floatObjectOf(result));
	GIV(stackPointer) = sp;
}


/*	Integral part of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveTruncated */
static void
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    double doubleValue;
    sqInt rcvr;
    double result;
    usqLong rot;
    double trunc;
    double value;

	rcvr = longAt(GIV(stackPointer));
	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	if ((rcvr & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(rcvr));
		rot = ((((usqInt)rcvr))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(rcvr + BaseHeaderSize, result);
	}
	doubleValue = result;
	if (!GIV(primFailCode)) {
		modf(doubleValue, (&trunc));
		if (((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) ))))) {
			/* begin stackTopPut: */
			longAtPointerput(GIV(stackPointer), (((usqInt)(((sqInt)trunc)) << 3) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveUninitializedNewWithArg */
static void
primitiveUninitializedNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classFormat;
    sqInt classIndex;
    sqInt classObj;
    sqInt err;
    sqInt fmt;
    sqInt hash;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    int ok;
    sqInt oop;
    sqInt reasonCode;
    usqIntptr_t size;
    char *sp;
    sqInt value;

	oop = longAt(GIV(stackPointer));
	/* begin positiveMachineIntegerValueOf: */
	if ((((oop) & 7) == 1)) {
		value = (oop >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l4;
		}
		size = value;
		goto l4;
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l4;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l4;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l4;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
		goto l4;
	}
	size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	l4:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	classObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin instantiateUninitializedClass:indexableSize: */
	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec1 = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	assert(isPureBitsFormat(instSpec1));
	switch (instSpec1) {
	case sixtyFourBitIndexableFormat():
		numSlots1 = size;
		break;
	case firstLongFormat():
		if ((classIndex == ClassFloatCompactIndex)
		 && (size != 2)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			obj = null;
			goto l6;
		}
		numSlots1 = (size + 1) / 2;
		instSpec1 += size & 1;
		break;
	case firstShortFormat():
		numSlots1 = (size + 3) / 4;
		instSpec1 += (4 - size) & 3;
		break;
	case firstByteFormat():
		numSlots1 = (size + 7) / 8;
		instSpec1 += (8 - size) & 7;
		break;
	default:
		/* not bits indexable */
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		obj = null;
		goto l6;
	}
	if (classIndex == 0) {
		/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(classObj));
		flag("todo");
		classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
			? hash
			: (objCouldBeClassObj(classObj)
					? (((err = enterIntoClassTable(classObj))) != 0
							? -err
							: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
					: -PrimErrBadReceiver));
		if (classIndex < 0) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = -classIndex;
			obj = null;
			goto l6;
		}
	}
	if (numSlots1 > ((1U << (fixedFieldsFieldWidth())) - 1)) {
		if (numSlots1 > (0x10000000000LL)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			obj = null;
			goto l6;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots1, 
		/* begin objectBytesForSlots: */
(numSlots1 == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots1 << (shiftForWord())) + ((numSlots1 >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec1, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots1 >= (numSlotsMask())) {
			if (((numSlots1) >> 56) > 0) {
				newObj = null;
				goto l5;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots1 * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots1 < 1
	? 8 /* begin allocationUnit */
	: numSlots1 * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots1, numBytes, instSpec1, classIndex);
			goto l5;
		}
		if (numSlots1 >= (numSlotsMask())) {
			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots1);
			longAtput(newObj1, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec1) << (formatShift()))))) + classIndex);
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots1)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec1) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l5:	/* end allocateSlots:format:classIndex: */;
	}
	obj = newObj;
	l6:	/* end instantiateUninitializedClass:indexableSize: */;
	if (obj == null) {
		instSpec = (((usqInt)((((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
		reasonCode = ((		/* begin isIndexableFormat: */
			(instSpec >= (arrayFormat()))
		 && ((instSpec <= (weakArrayFormat()))
		 || (instSpec >= (sixtyFourBitIndexableFormat()))))
		 && (!(instSpec >= (firstCompiledMethodFormat())))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

	/* InterpreterPrimitives>>#primitiveUpdateTimezone */
static void
primitiveUpdateTimezone(void)
{
	ioUpdateVMTimezone();
}


/*	Return the value of the microsecond clock in UTC as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. This
	primitive accesses the time as answered by the OS. */

	/* InterpreterPrimitives>>#primitiveUTCMicrosecondClock */
static void
primitiveUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioUTCMicrosecondsNow());
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Smalltalk epoch and the
	current seconds offset from GMT in the local time zone. Any pointer object
	with two or more slots) may be supplied as a parameter. */

	/* InterpreterPrimitives>>#primitiveUtcAndTimezoneOffset */
static void
primitiveUtcAndTimezoneOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((			/* begin isPointers: */
				((!(resultArray & (tagMask()))))
			 && (((((usqInt)((longAt(resultArray)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
			 && ((lengthOf(resultArray)) >= 2))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	else {
		resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), 2);
	}
	valuePointer = (((usqInt)(ioLocalSecondsOffset()) << 3) | 1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(resultArray)));
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	valuePointer1 = positive64BitIntegerFor(ioUTCMicroseconds());
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(resultArray)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(resultArray)),
	oopisGreaterThanOrEqualTo(resultArray, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer1 & (tagMask()))))
		 && (oopisLessThan(valuePointer1, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(resultArray)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(resultArray);
			}
		}
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Posix epoch and the
	current seconds offset from GMT in the local time zone. An empty two
	element array (or any object with two or more slots) may be supplied
	as a parameter.
	This is a named (not numbered) primitive in the null module (ie the VM) */

	/* InterpreterPrimitives>>#primitiveUtcWithOffset */
EXPORT(sqInt)
primitiveUtcWithOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static usqLong epochDelta = 2177452800000000ULL;
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			return (GIV(primFailCode) = PrimErrBadNumArgs);
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((			/* begin isPointers: */
				((!(resultArray & (tagMask()))))
			 && (((((usqInt)((longAt(resultArray)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
			 && ((lengthOf(resultArray)) >= 2))) {
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
	}
	else {
		resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), 2);
	}
	valuePointer = (((usqInt)(ioLocalSecondsOffset()) << 3) | 1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(resultArray)));
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	valuePointer1 = positive64BitIntegerFor((ioUTCMicrosecondsNow()) - epochDelta);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(resultArray)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(resultArray)),
	oopisGreaterThanOrEqualTo(resultArray, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer1 & (tagMask()))))
		 && (oopisLessThan(valuePointer1, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(resultArray)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(resultArray);
			}
		}
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer1);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Return a string containing the path name of VM's directory. */

	/* InterpreterPrimitives>>#primitiveVMPath */
static void
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

	/* InterpreterPrimitives>>#primitiveVMProfileSamplesInto */
static void
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt numSamples;
    sqInt running;
    sqInt sampleBuffer;
    char *sp;
    char *sp1;

	bufferSize = 0;
	running = 0;
	ioNewProfileStatus((&running), (&bufferSize));
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (running
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	sampleBuffer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!(((!(sampleBuffer & (tagMask()))))
		 && ((isPureBitsNonImm(sampleBuffer))
		 && ((numBytesOf(sampleBuffer)) >= (bufferSize * BytesPerWord))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	numSamples = ioNewProfileSamplesInto(pointerForOop(sampleBuffer + BaseHeaderSize));
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)numSamples << 3) | 1));
	GIV(stackPointer) = sp1;
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

	/* InterpreterPrimitives>>#signalNoResume: */
int
signalNoResume(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int empty;


	/* begin isEmptyList: */
	assert(!(isForwarded(aSemaphore)));
	empty = (longAt((aSemaphore + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj);
	if (!empty) {
		putToSleepyieldingIf(removeFirstLinkOfList(aSemaphore), 1);
	}
	return empty;
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

	/* InterpreterPrimitives>>#signedMachineIntegerValueOf: */
sqIntptr_t
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    usqIntptr_t limit;
    usqIntptr_t magnitude;
    sqInt negative;
    usqInt numBytes;
    usqInt numSlots;
    int ok;
    sqInt value;

	if ((((oop) & 7) == 1)) {
		return (oop >> 3);
	}
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex1 = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	/* begin numBytesOf: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	numBytes = (((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {
		/* bytes (the common case), including CompiledMethod */
		bs = numBytes - (fmt & 7);
		goto l1;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		bs = numBytes;
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		bs = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
		goto l1;
	}
	bs = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l1:	/* end numBytesOf: */;
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(sqIntptr_t)) == 8)
	 && (bs > 4)) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((oop + BaseHeaderSize))));
	}
	else {
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	}
	limit = (((usqIntptr_t)1)) << (((sizeof(sqIntptr_t)) * 8) - 1);
	if ((negative
		? magnitude > limit
		: magnitude >= limit)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return SQABS((longAt(oop + BaseHeaderSize)));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

	/* InterpreterPrimitives>>#success: */
sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!successBoolean) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return 0;
}


/*	Answer the appropriate become effect flags for objOop, or 0 if none.
	The effect flags determine how much work is done after the become in
	following forwarding pointers,
	voiding method caches, etc. Flag jitted methods because these will have to
	be freed after divorcing
	frames and mapping native pcs to bytecode pcs in contexts using them.
	See the comment in InterpreterPrimitives>>#primitiveArrayBecome */

	/* Spur64BitCoMemoryManager>>#becomeEffectFlagsFor: */
static NoDbgRegParms int
becomeEffectFlagsFor(sqInt objOop)
{
    sqInt hash;
    sqInt methodHeader;

	if (((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */) {
		if ((((hash = (long32At(objOop + 4)) & (identityHashHalfWordMask()))) != 0)
		 && ((classAtIndex(hash)) == objOop)) {
			return BecamePointerObjectFlag + BecameActiveClassFlag;
		}
		return BecamePointerObjectFlag;
	}
	if (((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		methodHeader = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			flagCogMethodForBecome(((CogMethod *) methodHeader));
			return BecameCompiledMethodFlag + BecameJittedCompiledMethodFlag;
		}
		return BecameCompiledMethodFlag;
	}
	return 0;
}

	/* Spur64BitCoMemoryManager>>#ceScheduleScavenge */
void
ceScheduleScavenge(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(GIV(freeStart) >= GIV(scavengeThreshold));
	/* begin scheduleScavenge */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
}

	/* Spur64BitCoMemoryManager>>#classSmallFloat */
sqInt
classSmallFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)((smallFloatTag())) << (shiftForWord())))));
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */
/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header.
	Override to set a bit at each Cog method */

	/* Spur64BitCoMemoryManager>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt oop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	oop = 0;
	clearHeapMap();
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			heapMapAtWordPut(pointerForOop(obj), 1);
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	addCogMethodsToHeapMap();
}


/*	Ensure there are no forwarded literals in the argument. */

	/* Spur64BitCoMemoryManager>>#ensureNoForwardedLiteralsIn: */
void
ensureNoForwardedLiteralsIn(sqInt aMethodObj)
{
	followForwardedObjectFieldstoDepth(aMethodObj, 0);
}


/*	Follow pointers in the object to depth.
	Answer if any forwarders were found.
	How to avoid cyclic structures?? A temporary mark bit? eem 6/22/2020 no
	need since depth is always finite. */

	/* Spur64BitCoMemoryManager>>#followForwardedObjectFields:toDepth: */
static NoDbgRegParms sqInt
followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt found;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt referent;
    sqInt sp;

	found = 0;
	assert((isPointers(objOop))
	 || (isOopCompiledMethod(objOop)));
	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin numPointerSlotsOf:format: */
	if (fmt <= 5 /* begin lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l3;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
			numSlots = CtxtTempFrameStart + contextSize;
			goto l4;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
		if (((numSlots1 = byteAt(objOop + 7))) == (numSlotsMask())) {
			/* overflow slots; at least (2^32)-1 slots, which is plenty */
			numSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8;
		}
		else {
			numSlots = numSlots1;
		}
		goto l4;
	}
	if (fmt == 7 /* begin forwardedFormat */) {
		numSlots = 1;
		goto l4;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		numSlots = 0;
		goto l4;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header1 = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numSlots = numLiterals + LiteralStart;
	l4:	/* end numPointerSlotsOf:format: */;
	for (i = ((fmt >= (firstCompiledMethodFormat())
	? 1
	: 0)); i < numSlots; i += 1) {
		oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((!(oop & (tagMask())))) {
			if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				found = 1;
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent & (tagMask()))))
				 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				oop = referent;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(objOop)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(objOop)),
				oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(oop & (tagMask()))))
					 && (oopisLessThan(oop, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(objOop);
						}
					}
				}
				longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), oop);
			}
			if ((depth > 0)
			 && ((			/* begin hasPointerFields: */
				((!(oop & (tagMask()))))
			 && (hasPointerFieldsNonImm(oop)))
			 && (followForwardedObjectFieldstoDepth(oop, depth - 1)))) {
				found = 1;
			}
		}
	}
	return found;
}

	/* Spur64BitCoMemoryManager>>#freeStartAddress */
usqInt
freeStartAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(freeStart))));
}

	/* Spur64BitCoMemoryManager>>#getScavengeThreshold */
usqInt
getScavengeThreshold(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(scavengeThreshold);
}


/*	Answer the header of the argument even though
	it may have its header word in a forwarding block
	(which shouldn't happen with Spur). */

	/* Spur64BitCoMemoryManager>>#headerWhileForwardingOf: */
static NoDbgRegParms sqLong
headerWhileForwardingOf(sqInt aCompiledMethodObjOop)
{
	assert(!(isForwarded(aCompiledMethodObjOop)));
	return long64At(aCompiledMethodObjOop);
}


/*	A lenient tester of forwarded class indices for inline cache management in
	the Cogit.
 */

	/* Spur64BitCoMemoryManager>>#isForwardedClassIndex: */
sqInt
isForwardedClassIndex(sqInt maybeClassIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt entry;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	if ((((usqInt)maybeClassIndex)) >= (1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift())))) {
		return 0;
	}
	fieldIndex = ((usqInt)(maybeClassIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		return 0;
	}
	fieldIndex1 = maybeClassIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin fetchPointer:ofObject: */
	entry = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	return (!((longAt(entry)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))));
}

	/* Spur64BitCoMemoryManager>>#isImmediateClass: */
int
isImmediateClass(sqInt classObj)
{
	return ((((usqInt)((((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask())) == 7 /* begin forwardedFormat */;
}


/*	Answer if obj is young. Require that obj is non-immediate. Override to
	filter-out Cog methods
 */

	/* Spur64BitCoMemoryManager>>#isReallyYoungObject: */
sqInt
isReallyYoungObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return (oopisLessThan(objOop, GIV(oldSpaceStart)))
	 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart)));
}


/*	Answer the method header of a CompiledMethod object.
	If the method has been cogged then the header is a pointer to
	the CogMethod and the real header will be stored in the CogMethod. */

	/* Spur64BitCoMemoryManager>>#methodHeaderOf: */
sqInt
methodHeaderOf(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	assert(isCompiledMethod(methodObj));
	header = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	return ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
}

	/* Spur64BitCoMemoryManager>>#needGCFlagAddress */
usqInt
needGCFlagAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(needGCFlag))));
}

	/* Spur64BitCoMemoryManager>>#nullHeaderForMachineCodeMethod */
sqLong
nullHeaderForMachineCodeMethod(void)
{
	return ((((sqInt)((usqInt)((firstLongFormat())) << (formatShift())))) + (1ULL << (markedBitFullShift()))) + ClassBitmapCompactIndex;
}

	/* Spur64BitCoMemoryManager>>#scavengeThresholdAddress */
usqInt
scavengeThresholdAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(scavengeThreshold))));
}

	/* Spur64BitCoMemoryManager>>#specialObjectsOopAddress */
usqInt
specialObjectsOopAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((usqInt)((&GIV(specialObjectsOop))));
}


/*	For the purposes of become: send selector to the cogit with obj1, obj2
	and aBool and answer the result. Undo forwarding for the selector. */

	/* Spur64BitCoMemoryManager>>#withoutForwardingOn:and:with:sendToCogit: */
sqInt
withoutForwardingOnandwithsendToCogit(sqInt obj1, sqInt obj2, sqInt aBool, sqInt (*selector)(sqInt,sqInt,sqInt))
{
    sqInt referent;
    sqInt referent1;
    sqInt targetA;
    sqInt targetB;


	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(obj1));
	referent = longAt((obj1 + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent & (tagMask()))))
	 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	targetA = referent;
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(obj2));
	referent1 = longAt((obj2 + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent1 & (tagMask()))))
	 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	targetB = referent1;
	return selector(targetA, targetB, aBool);
}


/*	Answer the address immediately following an object. */

	/* Spur64BitMemoryManager>>#addressAfter: */
static NoDbgRegParms usqInt
addressAfter(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	if (numSlots == 0) {
		return (objOop + 8 /* begin allocationUnit */) + BaseHeaderSize;
	}
	if (numSlots == (numSlotsMask())) {
		numSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8;
	}
	return (objOop + BaseHeaderSize) + ((numSlots << (shiftForWord())));
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. Try
	and allocate in a segment that already includes pinned objects. The header
	of the
	result will have been filled-in but not the contents. */

	/* Spur64BitMemoryManager>>#allocateSlotsForPinningInOldSpace:bytes:format:classIndex: */
static NoDbgRegParms sqInt
allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt acceptedChunk;
    sqInt acceptedNode;
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    sqInt f;
    usqInt index;
    usqInt initialIndex;
    sqInt lilliputian;
    sqInt lilliputian1;
    sqInt next;
    sqInt next1;
    sqInt next2;
    sqInt next3;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    sqInt node;
    sqInt prev;

	f = 0;
	/* begin allocateOldSpaceChunkOfBytes:suchThat: */
	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= totalBytes;
	initialIndex = totalBytes / 8 /* begin allocationUnit */;
	if ((initialIndex < 64 /* begin numFreeLists */)
	 && ((1ULL << initialIndex) <= GIV(freeListsMask))) {
		if (((GIV(freeListsMask) & (1ULL << initialIndex)) != 0)) {
			if (((node = GIV(freeLists)[initialIndex])) == 0) {
				GIV(freeListsMask) -= 1ULL << initialIndex;
			}
			else {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node));
					next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
					if (((segmentContainingObj(node))->containsPinned)) {
						if (prev == 0) {
							/* begin unlinkFreeChunk:atIndex:chunkBytes: */
							/* begin isLilliputianSize: */
							assert(totalBytes >= (BaseHeaderSize + (allocationUnit())));
							lilliputian = totalBytes == (BaseHeaderSize + 8 /* begin allocationUnit */);
							/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
							assert(((bytesInBody(node)) == (initialIndex * (allocationUnit())))
							 && ((initialIndex > 1)
							 && ((startOfObject(node)) == node)));
							GIV(freeLists)[initialIndex] = ((next3 = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())))));
							if ((!lilliputian)
							 && (next3 != 0)) {
								/* begin storePointer:ofFreeChunk:withValue: */
								assert(isFreeObject(next3));
								assert(1);
								longAtput((next3 + BaseHeaderSize) + (1U << (shiftForWord())), 0);
							}
						}
						else {
							/* begin setNextFreeChunkOf:withValue:chunkBytes: */
							/* begin isLilliputianSize: */
							assert(totalBytes >= (BaseHeaderSize + (allocationUnit())));
							lilliputian1 = totalBytes == (BaseHeaderSize + 8 /* begin allocationUnit */);
							/* begin storePointer:ofFreeChunk:withValue: */
							assert(isFreeObject(prev));
							assert((next == 0)
							 || (isFreeObject(next)));
							longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord())), next);
							if ((next != 0)
							 && (!lilliputian1)) {
								/* begin storePointer:ofFreeChunk:withValue: */
								assert(isFreeObject(next));
								assert((prev == 0)
								 || (isFreeObject(prev)));
								longAtput((next + BaseHeaderSize) + (1U << (shiftForWord())), prev);
							}
						}
						chunk = node;
						goto l4;
					}
					prev = node;
					node = next;
				}
			}
		}
		index = initialIndex;
		while ((((index += initialIndex)) < 64 /* begin numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1ULL << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));
						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node));
						next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev == 0) {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInBody(node)) == (index * (allocationUnit())))
								 && ((index > 1)
								 && ((startOfObject(node)) == node)));
								GIV(freeLists)[index] = ((next1 = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())))));
								if (next1 != 0) {
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(next1));
									assert(1);
									longAtput((next1 + BaseHeaderSize) + (1U << (shiftForWord())), 0);
								}
							}
							else {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								assert(isFreeObject(prev));
								assert((next == 0)
								 || (isFreeObject(next)));
								longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord())), next);
								if ((next != 0)) {
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(next));
									assert((prev == 0)
									 || (isFreeObject(prev)));
									longAtput((next + BaseHeaderSize) + (1U << (shiftForWord())), prev);
								}
							}
							freeChunkWithBytesat((index * 8 /* begin allocationUnit */) - totalBytes, (/* begin startOfObject: */
	((byteAt(node + 7)) == (numSlotsMask())
	? node - BaseHeaderSize
	: node)) + totalBytes);
							chunk = node;
							goto l4;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 64 /* begin numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1ULL << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));
						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node));
						next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev == 0) {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInBody(node)) == (index * (allocationUnit())))
								 && ((index > 1)
								 && ((startOfObject(node)) == node)));
								GIV(freeLists)[index] = ((next2 = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())))));
								if (next2 != 0) {
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(next2));
									assert(1);
									longAtput((next2 + BaseHeaderSize) + (1U << (shiftForWord())), 0);
								}
							}
							else {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								assert(isFreeObject(prev));
								assert((next == 0)
								 || (isFreeObject(next)));
								longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord())), next);
								if ((next != 0)) {
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(next));
									assert((prev == 0)
									 || (isFreeObject(prev)));
									longAtput((next + BaseHeaderSize) + (1U << (shiftForWord())), prev);
								}
							}
							freeChunkWithBytesat((index * 8 /* begin allocationUnit */) - totalBytes, (/* begin startOfObject: */
	((byteAt(node + 7)) == (numSlotsMask())
	? node - BaseHeaderSize
	: node)) + totalBytes);
							chunk = node;
							goto l4;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
	}
	child = GIV(freeLists)[0];
	node = (acceptedChunk = (acceptedNode = 0));
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child));
		childBytes = bytesInBody(child);
		if (childBytes == totalBytes) {
			/* size match; try to remove from list at node. */
			node = child;
			while (1) {
				prev = node;
				node = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
				if (!(node != 0)) break;
				if (((segmentContainingObj(node))->containsPinned)) {
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node));
					nextFreeChunk = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(prev));
					assert((nextFreeChunk == 0)
					 || (isFreeObject(nextFreeChunk)));
					longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk);
					if ((nextFreeChunk != 0)) {
						/* begin storePointer:ofFreeChunk:withValue: */
						assert(isFreeObject(nextFreeChunk));
						assert((prev == 0)
						 || (isFreeObject(prev)));
						longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord())), prev);
					}
					chunk = 
					/* begin startOfObject: */
((byteAt(node + 7)) == (numSlotsMask())
						? node - BaseHeaderSize
						: node);
					goto l4;
				}
			}
			if (((segmentContainingObj(child))->containsPinned)) {
				next = longAt((child + BaseHeaderSize) + (0U << (shiftForWord())));
				if (next == 0) {
					/* no list; remove the interior node */
					unlinkSolitaryFreeTreeNode(child);
				}
				else {
					/* list; replace node with it */
					inFreeTreeReplacewith(child, next);
				}
				chunk = 
				/* begin startOfObject: */
((byteAt(child + 7)) == (numSlotsMask())
					? child - BaseHeaderSize
					: child);
				goto l4;
			}
		}
		if (child != 0) {
			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (totalBytes + 8 /* begin allocationUnit */)) {
				/* node too small; walk down the larger size of the tree */
				child = longAt((child + BaseHeaderSize) + (4U << (shiftForWord())));
			}
			else {
				flag("we can do better here; preferentially choosing the lowest node. That would be a form of best-fit since we are trying to compact down");
				node = child;
				child = longAt((node + BaseHeaderSize) + (3U << (shiftForWord())));
				if (acceptedNode == 0) {
					/* first search the list. */
					acceptedChunk = node;
					do {
						acceptedChunk = longAt((acceptedChunk + BaseHeaderSize) + (0U << (shiftForWord())));
						if ((acceptedChunk != 0)
						 && (((segmentContainingObj(acceptedChunk))->containsPinned))) {
							acceptedNode = node;
						}
					} while((acceptedChunk != 0)
						 && (acceptedNode == 0));
					if ((acceptedNode == 0)
					 && (((segmentContainingObj(node))->containsPinned))) {
						acceptedNode = node;
						/* break out of loop now we have an acceptedNode */
						child = 0;
					}
				}
			}
		}
	}
	if (acceptedNode != 0) {
		if (acceptedChunk != 0) {
			assert((bytesInBody(acceptedChunk)) >= (totalBytes + (allocationUnit())));
			while (1) {
				next = longAt((acceptedNode + BaseHeaderSize) + (0U << (shiftForWord())));
				if (!(next != acceptedChunk)) break;
				acceptedNode = next;
			}
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			nextFreeChunk1 = longAt((acceptedChunk + BaseHeaderSize) + (0U << (shiftForWord())));
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(acceptedNode));
			assert((nextFreeChunk1 == 0)
			 || (isFreeObject(nextFreeChunk1)));
			longAtput((acceptedNode + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk1);
			if ((nextFreeChunk1 != 0)) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(nextFreeChunk1));
				assert((acceptedNode == 0)
				 || (isFreeObject(acceptedNode)));
				longAtput((nextFreeChunk1 + BaseHeaderSize) + (1U << (shiftForWord())), acceptedNode);
			}
			freeChunkWithBytesat((bytesInBody(acceptedChunk)) - totalBytes, (/* begin startOfObject: */
	((byteAt(acceptedChunk + 7)) == (numSlotsMask())
	? acceptedChunk - BaseHeaderSize
	: acceptedChunk)) + totalBytes);
			chunk = 
			/* begin startOfObject: */
((byteAt(acceptedChunk + 7)) == (numSlotsMask())
				? acceptedChunk - BaseHeaderSize
				: acceptedChunk);
			goto l4;
		}
		next = longAt((acceptedNode + BaseHeaderSize) + (0U << (shiftForWord())));
		if (next == 0) {
			/* no list; remove the interior node */
			unlinkSolitaryFreeTreeNode(acceptedNode);
		}
		else {
			/* list; replace node with it */
			inFreeTreeReplacewith(acceptedNode, next);
		}
		assert((bytesInBody(acceptedNode)) >= (totalBytes + (allocationUnit())));
		freeChunkWithBytesat((bytesInBody(acceptedNode)) - totalBytes, (/* begin startOfObject: */
	((byteAt(acceptedNode + 7)) == (numSlotsMask())
	? acceptedNode - BaseHeaderSize
	: acceptedNode)) + totalBytes);
		chunk = 
		/* begin startOfObject: */
((byteAt(acceptedNode + 7)) == (numSlotsMask())
			? acceptedNode - BaseHeaderSize
			: acceptedNode);
		goto l4;
	}
	/* optimism was unfounded */
	GIV(totalFreeOldSpace) += totalBytes;
	chunk = null;
	l4:	/* end allocateOldSpaceChunkOfBytes:suchThat: */;
	if (!chunk) {
		chunk = allocateOldSpaceChunkOfBytes(totalBytes);
		if (!chunk) {
			return null;
		}
		((segmentContainingObj(chunk))->containsPinned = 1);
	}
	if (numSlots >= (numSlotsMask())) {
		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))));
		longAtput(chunk + BaseHeaderSize, ((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex) | (1U << (pinnedBitShift())));
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCModeNewSpace)) == (GCCheckFreeSpace | GCModeNewSpace))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
		}
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, ((((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex) | (1U << (pinnedBitShift())));
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeNewSpace)) == (GCCheckFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	return chunk;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. The
	header will have been filled-in but not the contents. If no memory is
	available answer nil. */

	/* Spur64BitMemoryManager>>#allocateSlotsInOldSpace:bytes:format:classIndex: */
static NoDbgRegParms sqInt
allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;

	chunk = allocateOldSpaceChunkOfBytes(totalBytes);
	if (!chunk) {
		return null;
	}
	if (numSlots >= (numSlotsMask())) {
		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))));
		longAtput(chunk + BaseHeaderSize, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
		/* begin checkFreeSpace:ignoring: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCModeNewSpace)) == (GCCheckFreeSpace | GCModeNewSpace))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, chunk + BaseHeaderSize);
		}
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	/* begin checkFreeSpace:ignoring: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeNewSpace)) == (GCCheckFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, chunk);
	}
	return chunk;
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* Spur64BitMemoryManager>>#byteSwapped: */
sqInt
byteSwapped(sqInt w)
{
	return SQ_SWAP_8_BYTES(w);
}


/*	Answer the total number of bytes in an object including header and
	possible overflow size header.
 */

	/* Spur64BitMemoryManager>>#bytesInBody: */
static NoDbgRegParms usqInt
bytesInBody(sqInt objOop)
{
    usqLong header;
    usqLong headerNumSlots;
    usqLong numSlots;

	flag("endianness");
	header = longAt(objOop);
	headerNumSlots = (header) >> (numSlotsFullShift());
	numSlots = (headerNumSlots == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: (headerNumSlots == 0
				? 1
				: headerNumSlots));
	return (numSlots << (shiftForWord())) + ((headerNumSlots == (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize));
}


/*	Answer the default amount of memory to allocate for the eden space.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file.
	The shootout tests seem to plateau at 5 or 6Mb.
	
	Originally, both the 32-bit and 64-bit versions used the same 4Mb default.
	Measuring the simulator on image start-up, the 64-bit system's eden at the
	same point in start-up
	(the first copyBits) is only 8% larger in bytes because it allocates 26%
	fewer objects.
	Some 21% of the objects in the 32-bit version's eden are large integers
	and floats that
	are representable as 64-bit immediates.
	
	But when running benchmarks such as the computer language shootout's
	binary trees,
	using the same amount of memory for the 64-bit system causes a significant
	slow-down and a lot of compactions. So we now use 4Mb for 32-bits and 7Mb
	for 64-bits. */

	/* Spur64BitMemoryManager>>#defaultEdenBytes */
static int
defaultEdenBytes(void)
{
	return 0x700000;
}


/*	Answer the tag used in lookup caches for a receiver. This is the
	receiver's classIndex. */

	/* Spur64BitMemoryManager>>#fetchClassTagOf: */
sqInt
fetchClassTagOf(sqInt oop)
{
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? tagBits
		: (longAt(oop)) & (classIndexMask()));
}

	/* Spur64BitMemoryManager>>#floatObjectOf: */
sqInt
floatObjectOf(double aFloat)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newFloatObj;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    usqLong rawFloat;
    usqLong rot;

	if (isSmallFloatValue(aFloat)) {
		/* begin smallFloatObjectOf: */
		rawFloat = 0;
		assert(isSmallFloatValue(aFloat));
		memcpy((&rawFloat), (&aFloat), sizeof(rawFloat));
		/* begin smallFloatObjectOfBits: */
		assert(isSmallFloatValueBits(rawFloat));
		rot = (((rawFloat) >> 0x3F) & 1) + (rawFloat << 1);
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot -= ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			assert(rot > 0);
		}
		return (rot << (numTagBits())) + (smallFloatTag());
	}
	objFormat = firstLongFormat();
	numSlots = (sizeof(double)) / BytesPerOop;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassFloatCompactIndex)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newFloatObj = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassFloatCompactIndex);
	GIV(freeStart) += numBytes;
	newFloatObj = newObj;
	l1:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the 64-bit value of the argument as raw bits. */

	/* Spur64BitMemoryManager>>#floatValueBitsOf: */
static NoDbgRegParms sqLong
floatValueBitsOf(sqInt floatOop)
{
    usqLong rot;

	assert(isFloatInstance(floatOop));
	if ((floatOop & (tagMask())) != 0) {
		/* begin smallFloatBitsOf: */
		assert(isImmediateFloat(floatOop));
		rot = ((((usqInt)floatOop))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		return rot;
	}
	return long64At((floatOop + BaseHeaderSize));
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* Spur64BitMemoryManager>>#floatValueOf: */
double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    double result;
    usqLong rot;
    sqInt tagBits;
    double value;

	if (((tagBits = oop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(oop));
			rot = ((((usqInt)oop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			return value;
		}
	}
	else {
		if (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
			return result;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	This is a horrible hack for getting to the first object in eden if
	pastSpace is almost full.
	If there is only one (64-bit) word at the end of pastSpace there is no
	room for a full
	bridge, but there is room for this hack. */

	/* Spur64BitMemoryManager>>#hackSlimBridgeTo:at: */
static NoDbgRegParms void
hackSlimBridgeToat(sqInt objOop, sqInt startAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(oopisLessThan(startAddress, objOop));
	assert(oopisLessThanOrEqualTo(objOop, GIV(oldSpaceStart)));
	assert(((startAddress + (allocationUnit())) == objOop)
	 || (((startAddress + (allocationUnit())) + (allocationUnit())) == objOop));
	longAtput(startAddress, ((startAddress + 8 /* begin allocationUnit */) == objOop
		? ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))
		: (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + 1));
}


/*	A negative header selects the alternate bytecode set. */

	/* Spur64BitMemoryManager>>#headerIndicatesAlternateBytecodeSet: */
int
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((sqLong) methodHeader)) < 0;
}


/*	must have room for a header (single or double) plus the next free pointer */

	/* Spur64BitMemoryManager>>#initFreeChunkWithBytes:at: */
static NoDbgRegParms sqInt
initFreeChunkWithBytesat(usqLong numBytes, sqInt address)
{
    sqLong numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BytesPerOop)));
	if (numBytes >= ((((sqInt)((usqInt)((numSlotsMask())) << (shiftForWord())))) + BaseHeaderSize)) {
		numSlots = ((usqLong)(((numBytes - BaseHeaderSize) - BaseHeaderSize))) >> (shiftForWord());
		longAtput(address, (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(address + 8, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift()))));
		return address + 8;
	}
	numSlots = ((usqLong)((numBytes - BaseHeaderSize))) >> (shiftForWord());
	assert(numSlots < (numSlotsMask()));
	longAtput(address, ((sqLong)((usqLong)(numSlots) << (numSlotsFullShift()))));
	return address;
}


/*	Must have room for a double header or a short object with the forwarding
	slot (16 bytes either way).
 */

	/* Spur64BitMemoryManager>>#initSegmentBridgeWithBytes:at: */
static NoDbgRegParms void
initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address)
{
    sqLong numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BaseHeaderSize)));
	numSlots = ((usqLong)(((numBytes - BaseHeaderSize) - BaseHeaderSize))) >> (shiftForWord());
	if (numSlots == 0) {
		/* short bridge for adjacent segments */
		longAtput(address, (((1U << (pinnedBitShift())) + (1ULL << (markedBitFullShift()))) + (((sqInt)((usqInt)((sixtyFourBitIndexableFormat())) << (formatShift()))))) + (segmentBridgePun()));
	}
	else {
		/* long bridge */
		longAtput(address, (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(address + BaseHeaderSize, ((((((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + (1U << (pinnedBitShift()))) + (1ULL << (markedBitFullShift()))) + (((sqInt)((usqInt)((sixtyFourBitIndexableFormat())) << (formatShift()))))) + (segmentBridgePun()));
	}
}


/*	Allocate an instance of a variable class, excepting CompiledMethod. */

	/* Spur64BitMemoryManager>>#instantiateClass:indexableSize: */
sqInt
instantiateClassindexableSize(sqInt classObj, usqInt nElements)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt fillValue;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt p;

	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	fillValue = 0;
	switch (instSpec) {
	case arrayFormat():
		numSlots = nElements;
		fillValue = GIV(nilObj);
		break;
	case indexablePointersFormat():
	case weakArrayFormat():
		numSlots = (classFormat & ((1U << (fixedFieldsFieldWidth())) - 1)) + nElements;
		fillValue = GIV(nilObj);
		break;
	case sixtyFourBitIndexableFormat():
		numSlots = nElements;
		break;
	case firstLongFormat():
		if ((classIndex == ClassFloatCompactIndex)
		 && (nElements != 2)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return null;
		}
		numSlots = (nElements + 1) / 2;
		instSpec += nElements & 1;
		break;
	case firstShortFormat():
		numSlots = (nElements + 3) / 4;
		instSpec += (4 - nElements) & 3;
		break;
	case firstByteFormat():
		numSlots = (nElements + 7) / 8;
		instSpec += (8 - nElements) & 7;
		break;
	default:
		/* non-indexable */
		/* Some Squeak images include funky fixed subclasses of abstract variable
		   superclasses. e.g. DirectoryEntry as a subclass of ArrayedCollection.
		   The (Threaded)FFIPlugin expects to be able to instantiate ExternalData via
		   this method.
		   Hence allow fixed classes to be instantiated here iff nElements = 0. */
		if ((nElements != 0)
		 || (instSpec > 5 /* begin lastPointerFormat */)) {
			return null;
		}
		numSlots = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
		fillValue = GIV(nilObj);
	}
	if (classIndex == 0) {
		/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(classObj));
		flag("todo");
		classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
			? hash
			: (objCouldBeClassObj(classObj)
					? (((err = enterIntoClassTable(classObj))) != 0
							? -err
							: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
					: -PrimErrBadReceiver));
		if (classIndex < 0) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = -classIndex;
			return null;
		}
	}
	if (numSlots > ((1U << (fixedFieldsFieldWidth())) - 1)) {
		if (numSlots > (0x10000000000LL)) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return null;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, 
		/* begin objectBytesForSlots: */
(numSlots == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), instSpec, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if (((numSlots) >> 56) > 0) {
				newObj = null;
				goto l1;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {
			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
			longAtput(newObj1, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec) << (formatShift()))))) + classIndex);
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, fillValue);
		}
	}
	return newObj;
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* Spur64BitMemoryManager>>#integerObjectOf: */
sqInt
integerObjectOf(sqInt value)
{
	return ((((usqInt)value)) << (numTagBits())) + 1;
}


/*	Translator produces 'oop >> 3' */

	/* Spur64BitMemoryManager>>#integerValueOf: */
sqInt
integerValueOf(sqInt oop)
{
	return (((((usqInt)(oop)) >> 0x3F)) == 1
		? ((((((-(numTagBits())) < 0) ? (((usqInt)(oop)) >> (-(-(numTagBits())))) : (((sqInt)((usqInt)(oop) << (-(numTagBits()))))))) & 0x1FFFFFFFFFFFFFFFLL) - 0x1FFFFFFFFFFFFFFFLL) - 1
		: (((-(numTagBits())) < 0) ? (((usqInt)(oop)) >> (-(-(numTagBits())))) : (((sqInt)((usqInt)(oop) << (-(numTagBits())))))));
}

	/* Spur64BitMemoryManager>>#isFloatInstance: */
static NoDbgRegParms int
isFloatInstance(sqInt oop)
{
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? tagBits == (smallFloatTag())
		: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
}

	/* Spur64BitMemoryManager>>#isImmediateFloat: */
static NoDbgRegParms int
isImmediateFloat(sqInt oop)
{
	return ((oop & (smallFloatTag())) != 0);
}

	/* Spur64BitMemoryManager>>#isIntegerObject: */
int
isIntegerObject(sqInt oop)
{
	return ((oop & (smallIntegerTag())) != 0);
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In 64-bits we use a 3 bit tag which leaves 61 bits for 2's complement
	signed integers. In C, use a shift add and mask to test if the top 4 bits
	are all the same.
	Since 16rFFFFFFFFFFFFFFFF >> 60 = 16rF the computation intValue >> 60 + 1
	bitAnd: 16rF
	maps in-range -ve values to 0 and in-range +ve values to 1. */

	/* Spur64BitMemoryManager>>#isIntegerValue: */
int
isIntegerValue(sqInt intValue)
{
	return (((((usqInt)(intValue)) >> 60) + 1) & 15) <= 1;
}


/*	To have a prev pointer, which follows the next pointer, we need at least
	two slots.
 */

	/* Spur64BitMemoryManager>>#isLilliputianSize: */
static NoDbgRegParms int
isLilliputianSize(sqInt chunkBytes)
{
	assert(chunkBytes >= (BaseHeaderSize + (allocationUnit())));
	return chunkBytes == (BaseHeaderSize + 8 /* begin allocationUnit */);
}

	/* Spur64BitMemoryManager>>#isMarked: */
int
isMarked(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0;
}

	/* Spur64BitMemoryManager>>#isSmallFloatValueBits: */
static NoDbgRegParms int
isSmallFloatValueBits(usqLong rawFloatBits)
{
    usqLong exponent;

	exponent = ((rawFloatBits) >> (smallFloatMantissaBits())) & 0x7FF;
	return (exponent > (smallFloatExponentOffset())
		? exponent <= (0xFF + (smallFloatExponentOffset()))
		: ((rawFloatBits & ((1ULL << (smallFloatMantissaBits())) - 1)) == 0
				? exponent == 0
				: exponent == (smallFloatExponentOffset())));
}

	/* Spur64BitMemoryManager>>#isSmallFloatValue: */
static NoDbgRegParms int
isSmallFloatValue(double aFloat)
{
    usqLong exponent;
    usqLong rawFloat;

	rawFloat = 0;
	memcpy((&rawFloat), (&aFloat), sizeof(rawFloat));
	exponent = ((rawFloat) >> (smallFloatMantissaBits())) & 0x7FF;
	return (exponent > (smallFloatExponentOffset())
		? exponent <= (0xFF + (smallFloatExponentOffset()))
		: ((rawFloat & ((1ULL << (smallFloatMantissaBits())) - 1)) == 0
				? exponent == 0
				: exponent == (smallFloatExponentOffset())));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* Spur64BitMemoryManager>>#isWordsNonImm: */
static NoDbgRegParms int
isWordsNonImm(sqInt objOop)
{
	return ((((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1)));
}


/*	If floatOrInt is an integer and we enable mixed arithmetic in primitives,
	then convert it to a C double float and return it.
	If it is a Float, then load its value and return it.
	Otherwise fail -- ie return with primErrorCode non-zero. */

	/* Spur64BitMemoryManager>>#loadFloatOrIntFrom: */
static NoDbgRegParms double
loadFloatOrIntFrom(sqInt floatOrIntOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    double result;
    usqLong rot;
    sqInt tagBits;
    double value;

	if (((tagBits = floatOrIntOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(floatOrIntOop));
			rot = ((((usqInt)floatOrIntOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			return value;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			return ((double) ((floatOrIntOop >> 3)) );
		}
	}
	else {
		if (((longAt(floatOrIntOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(floatOrIntOop + BaseHeaderSize, result);
			return result;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Answer the maximum number of slots we are willing to attempt to allocate
	in an object.
	Must fit in 56-bits; c.f. bytesInObject: */

	/* Spur64BitMemoryManager>>#maxSlotsForAlloc */
static sqInt
maxSlotsForAlloc(void)
{
	return 0x10000000000LL;
}


/*	Answer the C double precision floating point value of the argument,
	which *must* be something for which self isFloatInstance: answers true.
	Note: May be called by translated primitive code. */

	/* Spur64BitMemoryManager>>#noFailFloatValueOf: */
double
noFailFloatValueOf(sqInt aFloatOop)
{
    usqLong bits;
    double result;
    usqLong rot;
    double value;

	assert(isFloatInstance(aFloatOop));
	if ((aFloatOop & (tagMask())) != 0) {
		/* begin smallFloatValueOf: */
		assert(isImmediateFloat(aFloatOop));
		rot = ((((usqInt)aFloatOop))) >> (numTagBits());
		if (rot > 1) {
			/* a.k.a. ~= +/-0.0 */
			rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
		}
		rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
		bits = rot;
		memcpy((&value), (&bits), sizeof(value));
		result = value;
	}
	else {
		fetchFloatAtinto(aFloatOop + BaseHeaderSize, result);
	}
	return result;
}


/*	Answer the number of free lists. We use freeListsMask, a bitmap, to avoid
	reading empty list heads. This should fit in a machine word to end up in a
	register during free chunk allocation. */

	/* Spur64BitMemoryManager>>#numFreeLists */
static sqInt
numFreeLists(void)
{
	return 64;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceding word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word.
	
	This variation on objectAfter:limit: allows for a single (64-bit) word
	bridge which may be needed
	to bridge from an almost full pastSpace to eden. It is only used in the
	flat enumerators that use
	startAddressForBridgedHeapEnumeration and enumerate over pastSpace, eden
	and oldSpace
	in that order. Note that the order for allObjects, and allInstances
	enumerates over oldSpace first.
	
	This hack is cheap. It increases the size of the objectAfter code, but
	saves two extra copies of
	the inner loop, since the inner loop now enumerates over all of pastSpace,
	eden and oldSpace.
	The test for a slim bridge is only performed if applied to an overflow
	header, and typically only
	1 in 400 objects have overflow headers in 32-bits, 1 in 500 in 64-bits.
	The complication is that
	image segment loading evaporates the word array by setting the overflow
	slots to 1, and this
	is ambiguous with a slimbridge. The resolution is that if the segmentArray
	has an overflow header,
	and is in new space, then its slot size can be zeroed and its overflow
	header changed to a slimbridge.
	
	At some point we should allow slimbridges (slivers?) throughout object
	memory, and use them to
	provide object alignment by slimbridges (slivers?) padding up to the
	following (aligned) object.
 */

	/* Spur64BitMemoryManager>>#objectAfterMaybeSlimBridge:limit: */
static NoDbgRegParms sqInt
objectAfterMaybeSlimBridgelimit(sqInt objOop, sqInt limit)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
		? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
			 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
				? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
				: followingWordAddress + BaseHeaderSize)
		: followingWordAddress);
}


/*	Answer the C double precision floating point value of the argument, a
	SmallFloat. See section 61-bit Immediate Floats in the SpurMemoryManager
	class comment.
	msb lsb 
	Decode:				[8expsubset][52mantissa][1s][3tags] 
	shift away tags:		[ 000 ][8expsubset][52mantissa][1s] 
	add exponent offset:	[ 11 exponent ][52mantissa][1s] 
	rot sign:				[1s][ 11 exponent ][52mantissa] */

	/* Spur64BitMemoryManager>>#smallFloatValueOf: */
static NoDbgRegParms double
smallFloatValueOf(sqInt oop)
{
    usqLong bits;
    usqLong rot;
    double value;


	/* begin smallFloatBitsOf: */
	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {
		/* a.k.a. ~= +/-0.0 */
		rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
	bits = rot;
	memcpy((&value), (&bits), sizeof(value));
	return value;
}


/*	Answer the total number of bytes in an object without an overflow header,
	including header bytes.
 */

	/* Spur64BitMemoryManager>>#smallObjectBytesForSlots: */
usqInt
smallObjectBytesForSlots(sqInt numSlots)
{
	return BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
}

	/* Spur64BitMemoryManager>>#wordIndexableFormat */
static sqInt
wordIndexableFormat(void)
{
	return sixtyFourBitIndexableFormat();
}

	/* Spur64BitMemoryManager>>#wordSizeClassIndexPun */
static sqInt
wordSizeClassIndexPun(void)
{
	return sixtyFourBitLongsClassIndexPun();
}


/*	ephemeronCorpse is the corpse of an ephemeron that was copied and
	forwarded. Later on its surviving copy must be scanned to nil weak
	references. Thread the corpse onto the weakList. Later, the weakList can
	be followed, and
	the forwarding pointer followed to locate the survivor. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#addToEphemeronList: */
static NoDbgRegParms NeverInline void
addToEphemeronList(sqInt ephemeronCorpse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeronListOffset;

	assert(!(isScavengeSurvivor(keyOfEphemeron(followForwarded(ephemeronCorpse)))));
	ephemeronListOffset = (!(GIV(ephemeronList))
		? 0
		: GIV(ephemeronList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(ephemeronCorpse));
	assert(isForwarded(ephemeronCorpse));
	long64Atput(ephemeronCorpse, headerForSlotshashformatclassIndex(byteAt(ephemeronCorpse + 7), ((usqInt)(ephemeronListOffset)) >> (formatFieldWidthShift()), ephemeronListOffset & (formatMask()), isForwardedObjectClassIndexPun()));
	GIV(ephemeronList) = (((usqInt)((ephemeronCorpse - GIV(newSpaceStart)))) >> 3 /* begin shiftForAllocationUnit */) + 1;
	assert((firstCorpse(GIV(ephemeronList))) == ephemeronCorpse);
}


/*	weakCorpse is the corpse of a weak array that was copied and forwarded.
	Later on its surviving copy must be scanned to nil weak references.
	Thread the corpse onto the weakList. Later, the weakList can be followed,
	and the forwarding pointer followed to locate the survivor. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#addToWeakList: */
static NoDbgRegParms NeverInline void
addToWeakList(sqInt weakCorpse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt weakListOffset;

	weakListOffset = (!(GIV(weakList))
		? 0
		: GIV(weakList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(weakCorpse));
	assert(isForwarded(weakCorpse));
	long64Atput(weakCorpse, headerForSlotshashformatclassIndex(byteAt(weakCorpse + 7), ((usqInt)(weakListOffset)) >> (formatFieldWidthShift()), weakListOffset & (formatMask()), isForwardedObjectClassIndexPun()));
	GIV(weakList) = (((usqInt)((weakCorpse - GIV(newSpaceStart)))) >> 3 /* begin shiftForAllocationUnit */) + 1;
	assert((firstCorpse(GIV(weakList))) == weakCorpse);
}

	/* SpurGenerationScavenger>>#allNewSpaceObjectsHaveZeroRTRefCount */
static sqInt
allNewSpaceObjectsHaveZeroRTRefCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	obj = 0;
	/* begin allNewSpaceObjectsDo: */
	objOop = 0;
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isBridgeOrEnumerableObjectNoAssert(objOop1));
		if (((((usqInt)((longAt(objOop1)))) >> (rememberedBitShift())) & MaxRTRefCount) > 0) {
			return 0;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
	return 1;
}

	/* SpurGenerationScavenger>>#allWeakSurvivorsOnWeakList */
static sqInt
allWeakSurvivorsOnWeakList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt corpse;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt limit;
    sqInt listOffset;
    usqInt numSlots;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt survivor;

	survivor = 0;
	/* begin allFutureSpaceEntitiesDo: */
	prevPrevObj = (prevObj = null);
	address = (GIV(futureSpace).start);
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(futureSurvivorStart);
	while (oopisLessThan(objOop, limit)) {
		if (isWeakNonImm(objOop)) {
			/* begin is:onWeaklingList: */
			corpse = (((sqInt)((usqInt)((GIV(weakList) - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart);
			while (corpse) {
				if (objOop == (followForwarded(corpse))) {
					goto l4;
				}
				/* begin nextCorpseOrNil: */
				assert(isYoung(corpse));
				listOffset = (((sqInt)((usqInt)(((long32At(corpse + 4)) & (identityHashHalfWordMask()))) << (formatFieldWidthShift())))) + ((((usqInt)((longAt(corpse)))) >> (formatShift())) & (formatMask()));
				corpse = ((sqInt) ((listOffset != 0
	? (((sqInt)((usqInt)((listOffset - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart)
	: 0)));
			}
			return 0;
	l4:;
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
			objOop = limit;
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
	}
	return 1;
}


/*	Some time in every scavenger's life there may come a time when someone
	writes code that stresses
	the remembered table. One might conclude that if the remembered table is
	full, then the right thing
	to do is simply to tenure everything, emptying the remembered table. But
	in some circumstances this
	can be counter-productive, and result in the same situation arising soon
	after tenuring everything.
	Instead, we can try and selectively prune the remembered table, tenuring
	only those objects that
	are referenced by many objects in the remembered table. That's what this
	algorithm does. It
	reference counts young objects referenced from the remembered set, and
	then sets a threshold
	used to tenure objects oft referenced from the remembered set, thereby
	allowing the remembered
	set to shrink, while not tenuring everything.
	
	Once in a network monitoring application in a galaxy not dissimilar from
	the one this code inhabits,
	a tree of nodes referring to large integers was in precisely this
	situation. The nodes were old, and
	the integers were in new space. Some of the nodes referred to shared
	numbers, some their own
	unique numbers. The numbers were updated frequently. Were new space simply
	tenured when the
	remembered table was full, the remembered table would soon fill up as new
	numbers were computed.
	Only by selectively pruning the remembered table of nodes that shared
	data, was a balance achieved
	whereby the remembered table population was kept small, and tenuring rates
	were low. */

	/* SpurGenerationScavenger>>#computeRefCountToShrinkRT */
static NeverInline void
computeRefCountToShrinkRT(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt elephant;
    sqInt entirePopulation;
    sqInt header;
    int i;
    sqInt i1;
    sqInt j;
    sqInt j1;
    sqInt jLimiT;
    long population[MaxRTRefCount + 1];
    sqInt refCount;
    sqInt referent;
    sqInt referent1;

	memset(population, 0, (sizeof(long)) * (MaxRTRefCount + 1));
	assert(allNewSpaceObjectsHaveZeroRTRefCount());
	/* begin referenceCountRememberedReferents: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		elephant = GIV(rememberedSet)[i1];
		if ((!((longAt(elephant)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(elephant));
			referent1 = longAt((elephant + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent1 & (tagMask()))))
			 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			elephant = referent1;
			if (((elephant & (tagMask())) != 0)) {
				/* take care if elephant forwarded to an immediate */
				elephant = GIV(nilObj);
			}
		}
		for (j1 = 0, jLimiT = ((numPointerSlotsOf(elephant)) - 1); j1 <= jLimiT; j1 += 1) {
			referent = longAt((elephant + BaseHeaderSize) + (((sqInt)((usqInt)(j1) << (shiftForWord())))));
			if (			/* begin isReallyYoung: */
				((!(referent & (tagMask()))))
			 && ((assert(isNonImmediate(referent)),
			(oopisLessThan(referent, GIV(oldSpaceStart)))
				 && (oopisGreaterThanOrEqualTo(referent, GIV(newSpaceStart)))))) {
				refCount = (((usqInt)((longAt(referent)))) >> (rememberedBitShift())) & MaxRTRefCount;
				if (refCount < MaxRTRefCount) {
					if (refCount > 0) {
						population[refCount] = ((population[refCount]) - 1);
					}
					refCount += 1;
					/* begin rtRefCountOf:put: */
					assert(((refCount >= 0) && (refCount <= MaxRTRefCount)));
					header = longAt(referent);
					header = header & (~(usqIntptr_t)(7U << (rememberedBitShift())));
					header += ((sqInt)((usqInt)(refCount) << (rememberedBitShift())));
					longAtput(referent, header);
					population[refCount] = ((population[refCount]) + 1);
				}
			}
		}
	}
	/* begin setRefCountToShrinkRT: */
	assert((population[0]) == 0);
	entirePopulation = 0;
	for (j = 1; j <= MaxRTRefCount; j += 1) {
		entirePopulation += population[j];
	}
	count = 0;
	i = MaxRTRefCount + 1;
	while ((count < (entirePopulation / 2))
	 && (((i -= 1)) >= 0)) {
		count += population[i];
	}
	GIV(refCountToShrinkRT) = ((i < 0) ? 0 : i);
}


/*	A special version of copyAndForward: for objects in the mournQueue. If
	we're in the good times tenuring regime then copy to futureSpace,
	otherwise tenure.
	Also, don't repeat any of the ephemeron processing. */

	/* SpurGenerationScavenger>>#copyAndForwardMourner: */
static NoDbgRegParms sqInt
copyAndForwardMourner(sqInt mourner)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInObj;
    sqInt classIndex;
    sqInt format;
    sqInt header;
    sqInt newLocation;
    sqInt newStart;
    usqInt startOfSurvivor;
    int tenure;

	assert((isInEden(mourner))
	 || (isInPastSpace(mourner)));
	bytesInObj = bytesInBody(mourner);
	format = (((usqInt)((longAt(mourner)))) >> (formatShift())) & (formatMask());
	/* Allow Slang to inline. */
	tenure = !((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(tenureThreshold) == 0));
	if (tenure
	 || ((GIV(futureSurvivorStart) + bytesInObj) > ((GIV(futureSpace).limit)))) {
		newLocation = copyToOldSpacebytesformat(mourner, bytesInObj, format);
	}
	else {
		/* begin copyToFutureSpace:bytes: */
		/* we hope writes are cheap... */
		GIV(statSurvivorCount) += 1;
		assert((GIV(futureSurvivorStart) + bytesInObj) <= ((GIV(futureSpace).limit)));
		startOfSurvivor = 
		/* begin startOfObject: */
((byteAt(mourner + 7)) == (numSlotsMask())
			? mourner - BaseHeaderSize
			: mourner);
		newStart = GIV(futureSurvivorStart);
		GIV(futureSurvivorStart) += bytesInObj;
		memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObj);
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newStart + (mourner - startOfSurvivor));
			header = header & (~(usqIntptr_t)(7U << (rememberedBitShift())));
			header += 0U << (rememberedBitShift());
			longAtput(newStart + (mourner - startOfSurvivor), header);
		}
		newLocation = newStart + (mourner - startOfSurvivor);
	}
	/* begin forwardSurvivor:to: */
	assert(isInNewSpace(mourner));
	assert((isInFutureSpace(newLocation))
	 || (isInOldSpace(newLocation)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(mourner)));
	longAtput((mourner + BaseHeaderSize) + (0U << (shiftForWord())), newLocation);
	classIndex = isForwardedObjectClassIndexPun();
	/* begin set:classIndexTo:formatTo: */
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
	longAtput(mourner, ((longAt(mourner)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (7U << (formatShift()))));
	if (format == (weakArrayFormat())) {
		addToWeakList(mourner);
	}
	return newLocation;
}


/*	copyAndForward: survivor copies a survivor object either to
	futureSurvivorSpace or, if it is to be promoted, to oldSpace.
	It leaves a forwarding pointer behind. If the object is weak
	then corpse is threaded onto the weakList for later treatment. */

	/* SpurGenerationScavenger>>#copyAndForward: */
static NoDbgRegParms sqInt
copyAndForward(sqInt survivor)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInObj;
    sqInt classIndex;
    sqInt format;
    sqInt header;
    sqInt newLocation;
    sqInt newStart;
    usqInt startOfSurvivor;
    sqInt tenure;

	assert((isInEden(survivor))
	 || (isInPastSpace(survivor)));
	bytesInObj = bytesInBody(survivor);
	format = (((usqInt)((longAt(survivor)))) >> (formatShift())) & (formatMask());
	/* begin shouldBeTenured: */
	switch (GIV(tenureCriterion)) {
	case TenureByAge:
		tenure = oopisLessThan(survivor, GIV(tenureThreshold));
		break;
	case TenureByClass:
		tenure = ((longAt(survivor)) & (classIndexMask())) == GIV(tenuringClassIndex);
		break;
	case TenureToShrinkRT:
		tenure = ((((usqInt)((longAt(survivor)))) >> (rememberedBitShift())) & MaxRTRefCount) >= GIV(refCountToShrinkRT);
		break;
	default:
		tenure = 0;
	}
	if (tenure
	 || ((GIV(futureSurvivorStart) + bytesInObj) > ((GIV(futureSpace).limit)))) {
		newLocation = copyToOldSpacebytesformat(survivor, bytesInObj, format);
	}
	else {
		/* begin copyToFutureSpace:bytes: */
		/* we hope writes are cheap... */
		GIV(statSurvivorCount) += 1;
		assert((GIV(futureSurvivorStart) + bytesInObj) <= ((GIV(futureSpace).limit)));
		startOfSurvivor = 
		/* begin startOfObject: */
((byteAt(survivor + 7)) == (numSlotsMask())
			? survivor - BaseHeaderSize
			: survivor);
		newStart = GIV(futureSurvivorStart);
		GIV(futureSurvivorStart) += bytesInObj;
		memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObj);
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newStart + (survivor - startOfSurvivor));
			header = header & (~(usqIntptr_t)(7U << (rememberedBitShift())));
			header += 0U << (rememberedBitShift());
			longAtput(newStart + (survivor - startOfSurvivor), header);
		}
		newLocation = newStart + (survivor - startOfSurvivor);
	}
	/* begin forwardSurvivor:to: */
	assert(isInNewSpace(survivor));
	assert((isInFutureSpace(newLocation))
	 || (isInOldSpace(newLocation)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(survivor)));
	longAtput((survivor + BaseHeaderSize) + (0U << (shiftForWord())), newLocation);
	classIndex = isForwardedObjectClassIndexPun();
	/* begin set:classIndexTo:formatTo: */
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
	longAtput(survivor, ((longAt(survivor)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (7U << (formatShift()))));
	if (format == (weakArrayFormat())) {
		addToWeakList(survivor);
	}
	if ((format == 5 /* begin ephemeronFormat */)
	 && (!(isScavengeSurvivor(
		(		/* begin keyOfEphemeron: */
			assert((isNonImmediate(newLocation))
			 && (isObjEphemeron(newLocation))),
		/* begin fetchPointer:ofObject: */
longAt((newLocation + BaseHeaderSize) + (0U << (shiftForWord())))))))) {
		addToEphemeronList(survivor);
	}
	return newLocation;
}


/*	Copy survivor to oldSpace. Answer the new oop of the object. */
/*	Should be too infrequent to lower icache density of copyAndForward: */

	/* SpurGenerationScavenger>>#copyToOldSpace:bytes:format: */
static NoDbgRegParms NeverInline sqInt
copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt header;
    sqInt newOop;
    sqInt newStart;
    sqInt nTenures;
    sqInt p;
    usqInt startOfSurvivor;

	assert((formatOfSurvivor == (formatOf(survivor)))
	 && (((!(isMarked(survivor)))
	 || (GIV(tenureCriterion) == MarkOnTenure))
	 && ((GIV(tenureCriterion) == TenureToShrinkRT)
	 || ((!(isPinned(survivor)))
	 && (!(isRemembered(survivor)))))));
	nTenures = GIV(statTenures);
	startOfSurvivor = 
	/* begin startOfObject: */
((byteAt(survivor + 7)) == (numSlotsMask())
		? survivor - BaseHeaderSize
		: survivor);
	newStart = allocateOldSpaceChunkOfBytes(bytesInObject);
	if (!newStart) {
		growOldSpaceByAtLeast(0);
		newStart = allocateOldSpaceChunkOfBytes(bytesInObject);
		if (!newStart) {
			error("out of memory");
		}
	}
	memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObject);
	newOop = newStart + (survivor - startOfSurvivor);
	if (GIV(tenureCriterion) >= (((TenureToShrinkRT < MarkOnTenure) ? TenureToShrinkRT : MarkOnTenure))) {
		if (GIV(tenureCriterion) == TenureToShrinkRT) {
			/* begin rtRefCountOf:put: */
			assert(((0 >= 0) && (0 <= MaxRTRefCount)));
			header = longAt(newOop);
			header = header & (~(usqIntptr_t)(7U << (rememberedBitShift())));
			header += 0U << (rememberedBitShift());
			longAtput(newOop, header);
		}
		if (GIV(tenureCriterion) == MarkOnTenure) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(newOop)));
			longAtput(newOop, (longAt(newOop)) | (1ULL << (markedBitFullShift())));
		}
	}
	GIV(statTenures) = nTenures + 1;
	if (	/* begin isAnyPointerFormat: */
		(formatOfSurvivor <= 5 /* begin lastPointerFormat */)
	 || (formatOfSurvivor >= (firstCompiledMethodFormat()))) {
		/* A very quick and dirty scan to find young referents.  If we misidentify bytes
		   in a CompiledMethod as young we don't care; it's unlikely, and a subsequent
		   scan of the rt will filter the object out.  But it's good to filter here because
		   otherwise an attempt to shrink the RT may simply fill it up with new objects,
		   and here the data is likely in the cache. */
		for (p = BaseHeaderSize; p <= ((bytesInObject - (survivor - startOfSurvivor)) - BytesPerWord); p += BytesPerWord) {
			field = longAt(survivor + p);
			if (			/* begin isReallyYoung: */
				((!(field & (tagMask()))))
			 && ((assert(isNonImmediate(field)),
			(oopisLessThan(field, GIV(oldSpaceStart)))
				 && (oopisGreaterThanOrEqualTo(field, GIV(newSpaceStart)))))) {
				remember(newOop);
				return newOop;
			}
		}
	}
	return newOop;
}

	/* SpurGenerationScavenger>>#firstCorpse: */
static NoDbgRegParms usqInt
firstCorpse(sqInt headOfCorpseList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((sqInt)((usqInt)((headOfCorpseList - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart);
}

	/* SpurGenerationScavenger>>#growRememberedSet */
static void
growRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt *base;
    sqInt fudge;
    sqInt i;
    sqInt newObj;
    sqInt nSlots;
    sqInt nSlots1;
    sqInt nSlots2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt obj3;
    usqInt p;
    usqInt p1;
    usqInt p2;


	/* Don't ruin locality in remember: */
	obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
	/* begin numSlotsOf: */
	assert((classIndexOf(obj)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(obj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	assert(numSlots >= 0x400);
	nSlots = numSlots * 2;
	/* begin allocatePinnedSlots: */
	obj1 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, (nSlots == 0
		? 8 /* begin allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(nSlots) << (shiftForWord())))) + ((nSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
	if (!(obj1 == null)) {
		assert(isPinned(obj1));
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj1 + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj1)));
		for (p = (((usqInt)(obj1 + BaseHeaderSize))); p <= (((usqInt)(((obj1 + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, 0);
		}
	}
	newObj = obj1;
	if (!newObj) {
		nSlots1 = numSlots + 0x400;
		/* begin allocatePinnedSlots: */
		obj2 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots1, (nSlots1 == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (((sqInt)((usqInt)(nSlots1) << (shiftForWord())))) + ((nSlots1 >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
		if (!(obj2 == null)) {
			assert(isPinned(obj2));
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((obj2 + BaseHeaderSize) + (nSlots1 * BytesPerOop)) - 1, addressAfter(obj2)));
			for (p1 = (((usqInt)(obj2 + BaseHeaderSize))); p1 <= (((usqInt)(((obj2 + BaseHeaderSize) + (nSlots1 * BytesPerOop)) - 1))); p1 += 8 /* begin allocationUnit */) {
				longAtput(p1, 0);
			}
		}
		newObj = obj2;
		if (!newObj) {
			if (!(growOldSpaceByAtLeast((numSlots + 0x400) * BytesPerOop))) {
				error("could not grow remembered set");
			}
			nSlots2 = numSlots + 0x400;
			/* begin allocatePinnedSlots: */
			obj3 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots2, (nSlots2 == 0
				? 8 /* begin allocationUnit */ + BaseHeaderSize
				: (((sqInt)((usqInt)(nSlots2) << (shiftForWord())))) + ((nSlots2 >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
			if (!(obj3 == null)) {
				assert(isPinned(obj3));
				/* begin fillObj:numSlots:with: */
				assert(oopisLessThan(((obj3 + BaseHeaderSize) + (nSlots2 * BytesPerOop)) - 1, addressAfter(obj3)));
				for (p2 = (((usqInt)(obj3 + BaseHeaderSize))); p2 <= (((usqInt)(((obj3 + BaseHeaderSize) + (nSlots2 * BytesPerOop)) - 1))); p2 += 8 /* begin allocationUnit */) {
					longAtput(p2, 0);
				}
			}
			newObj = obj3;
		}
	}
	/* begin rememberedSetObj: */
	assert(isOldObject(newObj));
	assert(!(isOopForwarded(GIV(hiddenRootsObj))));
	longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))), newObj);
	base = firstIndexableField(newObj);
	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		base[i] = (GIV(rememberedSet)[i]);
	}
	if (((((usqInt)((longAt(obj)))) >> (markedBitFullShift())) & 1) != 0) {
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(newObj)));
		longAtput(newObj, (longAt(newObj)) | (1ULL << (markedBitFullShift())));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(obj)));
		longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
	}
	freeObject(obj);
	GIV(rememberedSet) = base;
	/* begin numSlotsOf: */
	assert((classIndexOf(newObj)) > (isForwardedObjectClassIndexPun()));
	GIV(rememberedSetLimit) = (((numSlots2 = byteAt(newObj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(newObj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 0x400;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#isInRememberedSet: */
static NoDbgRegParms sqInt
isInRememberedSet(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		if ((GIV(rememberedSet)[i]) == objOop) {
			return 1;
		}
	}
	return 0;
}


/*	Answer whether the oop has survived a scavenge. This version is
	for processing weak survivors and must cope with the scavenge in
	freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact. */

	/* SpurGenerationScavenger>>#isMaybeOldScavengeSurvivor: */
static NoDbgRegParms sqInt
isMaybeOldScavengeSurvivor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt target;

	if (((oop & (tagMask())) != 0)) {
		return 1;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop));
		referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		target = referent;
		if (((oop & (tagMask())) != 0)) {
			return 1;
		}
	}
	else {
		target = oop;
	}
	return ((	/* begin isOldObject: */
		assert(isNonImmediate(target)),
	oopisGreaterThanOrEqualTo(target, GIV(oldSpaceStart)))
		? (GIV(tenureCriterion) != MarkOnTenure)
			 || (((((usqInt)((longAt(target)))) >> (markedBitFullShift())) & 1) != 0)
		: oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace()).start), futureSurvivorStart()));
}


/*	Answer whether the oop has survived a scavenge. This is equivalent to
	| target |
	(manager isImmediate: oop) ifTrue:
	[^true].
	target := (manager isForwarded: oop)
	ifTrue: [manager followForwarded: oop]
	ifFalse: [oop].
	^((manager isInEden: target)
	or: [(manager isInPastSpace: target)]) not */

	/* SpurGenerationScavenger>>#isScavengeSurvivor: */
static NoDbgRegParms sqInt
isScavengeSurvivor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt target;

	if (((oop & (tagMask())) != 0)) {
		return 1;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop));
		referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		target = referent;
	}
	else {
		target = oop;
	}
	return (!(	/* begin isReallyYoung: */
		((!(target & (tagMask()))))
	 && ((assert(isNonImmediate(target)),
	(oopisLessThan(target, GIV(oldSpaceStart)))
		 && (oopisGreaterThanOrEqualTo(target, GIV(newSpaceStart)))))))
	 || (oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace()).start), futureSurvivorStart()));
}

	/* SpurGenerationScavenger>>#is:onWeaklingList: */
static NoDbgRegParms sqInt
isonWeaklingList(sqInt oop, sqInt listHead)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt corpse;
    sqInt listOffset;

	corpse = (((sqInt)((usqInt)((listHead - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart);
	while (corpse) {
		if (oop == (followForwarded(corpse))) {
			return 1;
		}
		/* begin nextCorpseOrNil: */
		assert(isYoung(corpse));
		listOffset = (((sqInt)((usqInt)(((long32At(corpse + 4)) & (identityHashHalfWordMask()))) << (formatFieldWidthShift())))) + ((((usqInt)((longAt(corpse)))) >> (formatShift())) & (formatMask()));
		corpse = ((sqInt) ((listOffset != 0
	? (((sqInt)((usqInt)((listOffset - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart)
	: 0)));
	}
	return 0;
}

	/* SpurGenerationScavenger>>#newSpaceCapacity */
static usqInt
newSpaceCapacity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(eden).limit)) - (((((GIV(futureSpace).start)) < ((GIV(pastSpace).start))) ? ((GIV(futureSpace).start)) : ((GIV(pastSpace).start))));
}


/*	For assert checking only. */

	/* SpurGenerationScavenger>>#noUnfiredEphemeronsAtEndOfRememberedSet */
static sqInt
noUnfiredEphemeronsAtEndOfRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt referrer;

	for (i = GIV(numRememberedEphemerons); i < GIV(rememberedSetSize); i += 1) {
		referrer = GIV(rememberedSet)[i];
		if (isEphemeron(referrer)) {
			if (!(isScavengeSurvivor(
					(					/* begin keyOfEphemeron: */
						assert((isNonImmediate(referrer))
						 && (isObjEphemeron(referrer))),
					/* begin fetchPointer:ofObject: */
longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord()))))))) {
				return 0;
			}
		}
	}
	return 1;
}

	/* SpurGenerationScavenger>>#openScavengeLog */
void
openScavengeLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(scavengeLog) = fopen("scavenge.log", "a+");
}


/*	Print the objects in the remembered set. */
/*	useful for debugging */

	/* SpurGenerationScavenger>>#printRememberedSet */
void
printRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)i));
		printChar(' ');
		shortPrintOop(GIV(rememberedSet)[i]);
	}
}


/*	There are ephemerons to be scavenged. Scavenge them and fire any whose
	keys are
	still in pastSpace and/or eden. The unscavenged ephemerons in this cycle
	can only be
	fired if all the unscavenged ephemerons in this cycle are firable, because
	references to ephemeron keys from unfired ephemerons should prevent the
	ephemerons with
	those keys from firing. So scavenge ephemerons with surviving keys, and
	only if none
	are found, fire ephemerons with unreferenced keys, and scavenge them. Read
	the class comment for a more in-depth description of the algorithm. */

	/* SpurGenerationScavenger>>#processEphemerons */
static void
processEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt ephemeron1;
    usqInt ephemeronCorpse;
    sqInt hasNewReferents;
    sqInt i;
    sqInt i1;
    sqInt key;
    sqInt key1;
    sqInt listOffset;
    usqInt oldCorpse;
    sqInt oldList;
    sqInt referent;
    sqInt referrer;
    sqInt unfiredEphemeronsScavenged;
    sqInt unfiredEphemeronsScavenged1;
    sqInt valuePointer;
    sqInt valuePointer1;


	/* begin scavengeUnfiredEphemeronsInRememberedSet */
	unfiredEphemeronsScavenged1 = 0;
	i = 0;
	while (i < GIV(numRememberedEphemerons)) {
		referrer = GIV(rememberedSet)[i];
		assert(isEphemeron(referrer));
		if (isScavengeSurvivor(
			(			/* begin keyOfEphemeron: */
				assert((isNonImmediate(referrer))
				 && (isObjEphemeron(referrer))),
			/* begin fetchPointer:ofObject: */
longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord())))))) {
			unfiredEphemeronsScavenged1 = 1;
			/* remove from unscanned ephemerons in set by swapping with last ephemeron */
			hasNewReferents = scavengeReferentsOf(referrer);
			GIV(numRememberedEphemerons) -= 1;
			GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			if (hasNewReferents) {
				/* keep in set */
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			}
			else {
				/* remove from set by overwriting with next-to-be scanned */
				GIV(previousRememberedSetSize) -= 1;
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
				/* begin setIsRememberedOf:to: */
				longAtput(referrer, (longAt(referrer)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
			}
		}
		else {
			i += 1;
		}
	}
	unfiredEphemeronsScavenged = unfiredEphemeronsScavenged1;
	if (scavengeUnfiredEphemeronsOnEphemeronList()) {
		unfiredEphemeronsScavenged = 1;
	}
	if (!unfiredEphemeronsScavenged) {
		/* begin fireEphemeronsInRememberedSet */
		assert(noUnfiredEphemeronsAtEndOfRememberedSet());
		i1 = 0;
		while (i1 < GIV(numRememberedEphemerons)) {
			ephemeron = GIV(rememberedSet)[i1];
			assert(isEphemeron(ephemeron));
			/* begin keyOfEphemeron: */
			assert((isNonImmediate(ephemeron))
			 && (isObjEphemeron(ephemeron)));
			key = longAt((ephemeron + BaseHeaderSize) + (0U << (shiftForWord())));
			if (!(isScavengeSurvivor(key))) {
				/* begin fireEphemeron: */
				queueMourner(ephemeron);
				assert(((1 /* begin nonIndexablePointerFormat */ >= 0) && (1 /* begin nonIndexablePointerFormat */ <= (formatMask()))));
				longAtput(ephemeron, ((longAt(ephemeron)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (1U << (formatShift())));
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
				valuePointer = copyAndForward(key);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(ephemeron)));
				longAtput((ephemeron + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
			}
			assert(!(((isScavengeSurvivor(key))
 && (isEphemeron(ephemeron)))));
			if (scavengeReferentsOf(ephemeron)) {
				/* keep in set */
				i1 += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(ephemeron, (longAt(ephemeron)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
				GIV(numRememberedEphemerons) -= 1;
				GIV(previousRememberedSetSize) -= 1;
				/* First overwrite with last firable ephemeron (could be a noop if this is the last one).
				   Then overwrite last firable entry with next unscanned rememberedSet entry (could also be a noop).
				   Then overwrite next unscanned entry with last unscanned rememberedSet entry (could also be a noop). */
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[i1] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
			}
		}
		GIV(numRememberedEphemerons) = 0;
		/* begin fireEphemeronsOnEphemeronList */
		if (!GIV(ephemeronList)) {
			goto l6;
		}
		oldCorpse = null;
		/* Reset the list head so that new ephemerons will get added
		   to a new list, not concatenated on the one we are scanning. */
		ephemeronCorpse = (((sqInt)((usqInt)((GIV(ephemeronList) - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart);
		oldList = GIV(ephemeronList);
		GIV(ephemeronList) = null;
		while (ephemeronCorpse) {
			assert((isYoung(ephemeronCorpse))
			 && (isForwarded(ephemeronCorpse)));
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(ephemeronCorpse));
			referent = longAt((ephemeronCorpse + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent & (tagMask()))))
			 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			ephemeron1 = referent;
			/* begin keyOfMaybeFiredEphemeron: */
			assert((isNonImmediate(ephemeron1))
			 && (isMaybeFiredEphemeron(ephemeron1)));
			key1 = longAt((ephemeron1 + BaseHeaderSize) + (0U << (shiftForWord())));
			if (!(isScavengeSurvivor(key1))) {
				/* begin fireEphemeron: */
				queueMourner(ephemeron1);
				assert(((1 /* begin nonIndexablePointerFormat */ >= 0) && (1 /* begin nonIndexablePointerFormat */ <= (formatMask()))));
				longAtput(ephemeron1, ((longAt(ephemeron1)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (1U << (formatShift())));
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
				valuePointer1 = copyAndForward(key1);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(ephemeron1)));
				longAtput((ephemeron1 + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer1);
			}
			assert(!(((isScavengeSurvivor(key1))
 && (isEphemeron(ephemeron1)))));
			((void) (scavengeReferentsOf(ephemeron1)));
			oldCorpse = ephemeronCorpse;
			/* begin nextCorpseOrNil: */
			assert(isYoung(ephemeronCorpse));
			listOffset = (((sqInt)((usqInt)(((long32At(ephemeronCorpse + 4)) & (identityHashHalfWordMask()))) << (formatFieldWidthShift())))) + ((((usqInt)((longAt(ephemeronCorpse)))) >> (formatShift())) & (formatMask()));
			ephemeronCorpse = ((sqInt) ((listOffset != 0
	? (((sqInt)((usqInt)((listOffset - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart)
	: 0)));
		}
	l6:	/* end fireEphemeronsOnEphemeronList */;
	}
}


/*	Go through the remembered set and the weak list, nilling references to
	any objects that didn't survive the scavenge. Read the class comment
	for a more in-depth description of the algorithm. */

	/* SpurGenerationScavenger>>#processWeaklings */
static void
processWeaklings(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt listOffset;
    sqInt referent;
    sqInt rootObj;
    usqInt weakCorpse;
    sqInt weakObj;

	assert(allWeakSurvivorsOnWeakList());
	i = 0;
	while (i < GIV(rememberedSetSize)) {
		rootObj = GIV(rememberedSet)[i];
		if (isWeakNonImm(rootObj)) {
			/* If no more referents, remove by overwriting with the last element in the set. */
			if (processWeakSurvivor(rootObj)) {
				i += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(rootObj, (longAt(rootObj)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
				if ((i + 1) < GIV(rememberedSetSize)) {
					GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
				}
				GIV(rememberedSetSize) -= 1;
			}
		}
		else {
			i += 1;
		}
	}
	if (!(GIV(weakList) == null)) {
		weakCorpse = (((sqInt)((usqInt)((GIV(weakList) - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart);
		while (weakCorpse) {
			assert(isForwarded(weakCorpse));
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(weakCorpse));
			referent = longAt((weakCorpse + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent & (tagMask()))))
			 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			weakObj = referent;
			if ((processWeakSurvivor(weakObj))
			 && (((			/* begin isOldObject: */
				assert(isNonImmediate(weakObj)),
			oopisGreaterThanOrEqualTo(weakObj, GIV(oldSpaceStart))))
			 && (!(((((usqInt)((longAt(weakObj)))) >> (rememberedBitShift())) & 1) != 0)))) {
				remember(weakObj);
			}
			/* begin nextCorpseOrNil: */
			assert(isYoung(weakCorpse));
			listOffset = (((sqInt)((usqInt)(((long32At(weakCorpse + 4)) & (identityHashHalfWordMask()))) << (formatFieldWidthShift())))) + ((((usqInt)((longAt(weakCorpse)))) >> (formatShift())) & (formatMask()));
			weakCorpse = ((sqInt) ((listOffset != 0
	? (((sqInt)((usqInt)((listOffset - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart)
	: 0)));
		}
		GIV(weakList) = null;
	}
}


/*	Process a weak survivor on the weakList. Those of its fields
	which have not survived the scavenge should be nilled, and if any
	are, the coInterpreter should be informed via fireFinalization:.
	Answer if the weakObj has any young referents. */

	/* SpurGenerationScavenger>>#processWeakSurvivor: */
static NoDbgRegParms sqInt
processWeakSurvivor(sqInt weakObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classPointer;
    sqInt hasYoungReferents;
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;
    sqInt numStrongSlots;
    sqInt referent;
    sqInt referent1;
    sqInt weakObjShouldMourn;


	/* N.B. generateToByDoLimitExpression:negative:on: guards against (unsigned)0 - 1 going +ve */
	weakObjShouldMourn = (hasYoungReferents = 0);
	/* begin numFixedSlotsOf: */
	classPointer = fetchClassOfNonImm(weakObj);
	classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	numStrongSlots = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
	for (i = 0; i < numStrongSlots; i += 1) {
		referent = longAt((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (((!(referent & (tagMask()))))
		 && ((		/* begin isYoungObject: */
			assert(isNonImmediate(referent)),
		oopisLessThan(referent, GIV(oldSpaceStart))))) {
			hasYoungReferents = 1;
		}
	}
	for (i = numStrongSlots, iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(weakObj)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(weakObj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(weakObj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i <= iLimiT; i += 1) {
		/* Referent could be forwarded due to scavenging or a become:, don't assume. */
		referent = longAt((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((!(referent & (tagMask())))) {
			if ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(referent));
				referent1 = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent1 & (tagMask()))))
				 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				referent = referent1;
				assert((isReallyYoungObject(weakObj))
				 || (isRemembered(weakObj)));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(weakObj)));
				longAtput((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), referent);
			}
			if (isMaybeOldScavengeSurvivor(referent)) {
				if ((				/* begin isYoungObject: */
					assert(isNonImmediate(referent)),
				oopisLessThan(referent, GIV(oldSpaceStart)))) {
					hasYoungReferents = 1;
				}
			}
			else {
				weakObjShouldMourn = 1;
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(weakObj)));
				longAtput((weakObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
			}
		}
	}
	if (weakObjShouldMourn) {
		/* begin fireFinalization: */
		if (GIV(newFinalization)) {
			queueMourner(weakObj);
		}
		/* begin signalFinalization: */
		forceInterruptCheck();
		GIV(pendingFinalizationSignals) += 1;
	}
	return hasYoungReferents;
}


/*	Add the argument to the remembered set and set its isRemembered bit to
	true. Answer the argument for the benefit of the Cogit. */

	/* SpurGenerationScavenger>>#remember: */
sqInt
remember(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	assert(!((isYoungObject(objOop))));
	assert(!((isRemembered(objOop))));
	assert(!((isInRememberedSet(objOop))));
	/* begin setIsRememberedOf:to: */
	longAtput(objOop, (longAt(objOop)) | (1U << (rememberedBitShift())));
	if (GIV(rememberedSetSize) >= GIV(rememberedSetLimit)) {
		growRememberedSet();
	}
	GIV(rememberedSet)[GIV(rememberedSetSize)] = objOop;
	if (((GIV(rememberedSetSize) += 1)) >= GIV(rememberedSetRedZone)) {
		/* begin scheduleScavenge */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	return objOop;
}


/*	scavengeFutureSurvivorSpaceStartingAt: does a depth-first traversal of the
	new objects starting at the one at initialAddress in futureSurvivorSpace. */

	/* SpurGenerationScavenger>>#scavengeFutureSurvivorSpaceStartingAt: */
static NoDbgRegParms void
scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    sqInt obj;
    usqInt ptr;

	ptr = initialAddress;
	while (ptr < GIV(futureSurvivorStart)) {
		/* begin objectStartingAt: */
		numSlots = byteAt(ptr + 7);
		obj = (numSlots == (numSlotsMask())
			? ptr + BaseHeaderSize
			: ptr);
		ptr = addressAfter(obj);
		((void) (scavengeReferentsOf(obj)));
	}
}


/*	This is the inner loop of the main routine, scavenge. It first scavenges
	the new objects immediately
	reachable from old ones. Then it scavenges those that are transitively
	reachable. If this results in a
	promotion, the promotee gets remembered, and it first scavenges objects
	adjacent to the promotee,
	then scavenges the ones reachable from the promoted. This loop continues
	until no more reachable
	objects are left. At that point, pastSurvivorSpace is exchanged with
	futureSurvivorSpace. 
	Notice that each pointer in a live object is inspected once and only once.
	The previousRememberedSetSize
	and previousFutureSurvivorSpaceLimit variables ensure that no object is
	scanned twice, as well as
	detecting closure. If this were not true, some pointers might get
	forwarded twice.
	
	An extension of the algorithm presented in David's original paper is to
	handle weak arrays and ephemerons.
	Weak arrays should not have their weak referents scavenged unless there
	are strong references to them.
	Ephemerons should fire if their key is not reachable other than from
	ephemerons and weak arrays.
	Handle this by maintaining a list for weak arrays and a list for
	ephemerons, which allow scavenging these
	objects once all other objects in new space have been scavenged, hence
	allowing the scavenger to
	detect which referents in new space of weak arrays are dead and of
	ephemeron keys are only live due to
	ephemerons. Read the class comment for a more in-depth description of the
	algorithm.  */

	/* SpurGenerationScavenger>>#scavengeLoop */
static void
scavengeLoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstTime;
    sqInt i;
    sqInt previousFutureSurvivorStart;
    StackPage *thePage;

	assert(GIV(futureSurvivorStart) == ((GIV(futureSpace).start)));
	GIV(weakList) = (GIV(ephemeronList) = null);
	GIV(numRememberedEphemerons) = 0;
	firstTime = 1;
	GIV(previousRememberedSetSize) = 0;
	previousFutureSurvivorStart = GIV(futureSurvivorStart);
	/* begin initStackPageGC */
	if (!(GIV(stackPage) == null)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		(thePage->trace = StackPageUnreached);
	}
	while (1) {
		scavengeRememberedSetStartingAt(GIV(previousRememberedSetSize));
		GIV(previousRememberedSetSize) = GIV(rememberedSetSize);
		if (firstTime) {
			mapInterpreterOops();
			mapMournQueue();
			mapExtraRoots();
			firstTime = 0;
		}
		if ((GIV(previousRememberedSetSize) == GIV(rememberedSetSize))
		 && ((previousFutureSurvivorStart == GIV(futureSurvivorStart))
		 && ((GIV(numRememberedEphemerons) == 0)
		 && (!GIV(ephemeronList))))) {
			return;
		}
		scavengeFutureSurvivorSpaceStartingAt(previousFutureSurvivorStart);
		/* no more roots created to scavenge... */
		previousFutureSurvivorStart = GIV(futureSurvivorStart);
		if (GIV(previousRememberedSetSize) == GIV(rememberedSetSize)) {
			if ((GIV(numRememberedEphemerons) == 0)
			 && (!GIV(ephemeronList))) {
				return;
			}
			processEphemerons();
		}
	}
}


/*	scavengeReferentsOf: referrer inspects all the pointers in referrer. If
	any are new objects, it has them moved to FutureSurvivorSpace, and
	answers truth. If there are no new referents, it answers falsity. To
	handle weak arrays, if the referrer is weak only scavenge strong slots and
	answer true so that it won't be removed from the remembered set until
	later.  */
/*	forwarding objects should be followed by callers,
	unless the forwarder is a root in the remembered table. */

	/* SpurGenerationScavenger>>#scavengeReferentsOf: */
static NoDbgRegParms sqInt
scavengeReferentsOf(sqInt referrer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt foundNewReferentOrIsWeakling;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt newLocation;
    sqInt numLiterals;
    sqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop1;
    sqInt referent;
    sqInt referent1;
    sqInt sp;

	assert((!(isForwarded(referrer)))
	 || (isRemembered(referrer)));
	assert((!(isEphemeron(referrer)))
	 || ((isScavengeSurvivor(keyOfEphemeron(referrer)))
	 || (isonWeaklingList(referrer, GIV(ephemeronList)))));
	fmt = (((usqInt)((longAt(referrer)))) >> (formatShift())) & (formatMask());
	foundNewReferentOrIsWeakling = fmt == (weakArrayFormat());
	/* begin numStrongSlotsOf:format:ephemeronInactiveIf: */
	if (fmt <= 5 /* begin lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(referrer)) > (isForwardedObjectClassIndexPun()));
		numSlots2 = (((numSlots1 = byteAt(referrer + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(referrer - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= (arrayFormat())) {
			numSlots = numSlots2;
			goto l4;
		}
		if (fmt == (indexablePointersFormat())) {
			if (((longAt(referrer)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(referrer);
				/* begin fetchStackPointerOf: */
				sp = longAt((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l3;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(referrer)));
				contextSize = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
				numSlots = CtxtTempFrameStart + contextSize;
				goto l4;
			}
			numSlots = numSlots2;
			goto l4;
		}
		if (fmt == (weakArrayFormat())) {
			objOop1 = fetchClassOfNonImm(referrer);
			numSlots = (((longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
			goto l4;
		}
		assert(fmt == (ephemeronFormat()));
		if (isScavengeSurvivor(
			(			/* begin keyOfEphemeron: */
				assert((isNonImmediate(referrer))
				 && (isObjEphemeron(referrer))),
			/* begin fetchPointer:ofObject: */
longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord())))))) {
			numSlots = numSlots2;
			goto l4;
		}
		else {
			numSlots = 0;
			goto l4;
		}
	}
	if (fmt == 7 /* begin forwardedFormat */) {
		numSlots = 1;
		goto l4;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		numSlots = 0;
		goto l4;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(referrer));
	header1 = longAt((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numSlots = numLiterals + LiteralStart;
	l4:	/* end numStrongSlotsOf:format:ephemeronInactiveIf: */;
	for (i = 0; i < numSlots; i += 1) {
		referent = longAt((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((!(referent & (tagMask())))) {
			/* a forwarding pointer could be because of become: or scavenging. */
			if ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(referent));
				referent1 = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent1 & (tagMask()))))
				 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				referent = referent1;
			}
			if ((			/* begin isReallyYoungObject: */
				assert(isNonImmediate(referent)),
			(oopisLessThan(referent, GIV(oldSpaceStart)))
				 && (oopisGreaterThanOrEqualTo(referent, GIV(newSpaceStart))))) {
				/* if target is already in future space forwarding pointer was due to a become:. */
				if (oopisGreaterThanOrEqualToandLessThan(referent, ((futureSpace()).start), futureSurvivorStart())) {
					newLocation = referent;
					foundNewReferentOrIsWeakling = 1;
				}
				else {
					newLocation = copyAndForward(referent);
					if (					/* begin isYoung: */
						((!(newLocation & (tagMask()))))
					 && (oopisLessThan(newLocation, GIV(oldSpaceStart)))) {
						foundNewReferentOrIsWeakling = 1;
					}
				}
				/* begin storePointerUnchecked:ofMaybeForwardedObject:withValue: */
				longAtput((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), newLocation);
			}
			else {
				/* begin storePointerUnchecked:ofMaybeForwardedObject:withValue: */
				longAtput((referrer + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), referent);
			}
		}
	}
	return foundNewReferentOrIsWeakling;
}


/*	scavengeRememberedSetStartingAt: n traverses objects in the remembered
	set starting at the nth one. If the object does not refer to any new
	objects, it
	is removed from the set. Otherwise, its new referents are scavenged. Defer
	scavenging ephemerons until after a complete scavenge has been performed,
	so that triggered ephemerons can be fired. Move them to the front of the
	set and count them in numRememberedEphemerons for later scanning. */

	/* SpurGenerationScavenger>>#scavengeRememberedSetStartingAt: */
static NoDbgRegParms void
scavengeRememberedSetStartingAt(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt destIndex;
    sqInt referrer;
    sqInt sourceIndex;

	sourceIndex = (destIndex = n);
	while (sourceIndex < GIV(rememberedSetSize)) {
		/* *Don't* follow forwarding pointers here. oldSpace objects may refer
		   to these roots, and so they can't be removed in the scavenge. */
		/* Any potential firing ephemerons should not be scanned yet.
		   Move any to the front of the set to save time in later scanning. */
		referrer = GIV(rememberedSet)[sourceIndex];
		if ((isEphemeron(referrer))
		 && (!(isScavengeSurvivor(
			(			/* begin keyOfEphemeron: */
				assert((isNonImmediate(referrer))
				 && (isObjEphemeron(referrer))),
			/* begin fetchPointer:ofObject: */
longAt((referrer + BaseHeaderSize) + (0U << (shiftForWord())))))))) {
			assert(destIndex >= GIV(numRememberedEphemerons));
			GIV(rememberedSet)[destIndex] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			GIV(numRememberedEphemerons) += 1;
			destIndex += 1;
		}
		else {
			if (scavengeReferentsOf(referrer)) {
				GIV(rememberedSet)[destIndex] = referrer;
				destIndex += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				longAtput(referrer, (longAt(referrer)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
			}
		}
		sourceIndex += 1;
	}
	GIV(rememberedSetSize) = destIndex;
	assert(noUnfiredEphemeronsAtEndOfRememberedSet());
}


/*	(Slang flattens so need unique selectors) */

	/* SpurGenerationScavenger>>#scavengerTenuringThreshold */
static float
scavengerTenuringThreshold(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(tenureThreshold) >= ((GIV(pastSpace).start))
		? (((double) (GIV(tenureThreshold) - ((GIV(pastSpace).start))) )) / (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))
		: 0);
}


/*	There may be ephemerons to be scavenged on the ephemeronList.
	Scavenge any with unfired (live) keys, removing them from the
	list, and answer if any with unfired keys were found. */

	/* SpurGenerationScavenger>>#scavengeUnfiredEphemeronsOnEphemeronList */
static sqInt
scavengeUnfiredEphemeronsOnEphemeronList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt corpseOffset;
    sqInt ephemeron;
    usqInt ephemeronCorpse;
    sqInt offsetToNextCorpse;
    usqInt previousCorpse;
    sqInt referent;
    sqInt unfiredEphemeronsScavenged;

	previousCorpse = 0;
	if (!GIV(ephemeronList)) {
		return 0;
	}
	unfiredEphemeronsScavenged = 0;
	corpseOffset = GIV(ephemeronList);
	while (corpseOffset != 0) {
		ephemeronCorpse = (((sqInt)((usqInt)((corpseOffset - 1)) << 3 /* begin shiftForAllocationUnit */))) + GIV(newSpaceStart);
		assert(isForwarded(ephemeronCorpse));
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(ephemeronCorpse));
		referent = longAt((ephemeronCorpse + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		ephemeron = referent;
		offsetToNextCorpse = (((sqInt)((usqInt)(((long32At(ephemeronCorpse + 4)) & (identityHashHalfWordMask()))) << (formatFieldWidthShift())))) + ((((usqInt)((longAt(ephemeronCorpse)))) >> (formatShift())) & (formatMask()));
		if (isScavengeSurvivor(
			(			/* begin keyOfEphemeron: */
				assert((isNonImmediate(ephemeron))
				 && (isObjEphemeron(ephemeron))),
			/* begin fetchPointer:ofObject: */
longAt((ephemeron + BaseHeaderSize) + (0U << (shiftForWord())))))) {
			if (corpseOffset == GIV(ephemeronList)) {
				GIV(ephemeronList) = (offsetToNextCorpse != 0
					? offsetToNextCorpse
					: 0);
			}
			else {
				/* begin setCorpseOffsetOf:to: */
				assert(isYoung(previousCorpse));
				assert(isForwarded(previousCorpse));
				long64Atput(previousCorpse, headerForSlotshashformatclassIndex(byteAt(previousCorpse + 7), ((usqInt)(offsetToNextCorpse)) >> (formatFieldWidthShift()), offsetToNextCorpse & (formatMask()), isForwardedObjectClassIndexPun()));
			}
			unfiredEphemeronsScavenged = 1;
			((void) (scavengeReferentsOf(ephemeron)));
		}
		else {
			previousCorpse = ephemeronCorpse;
		}
		corpseOffset = offsetToNextCorpse;
	}
	return unfiredEphemeronsScavenged;
}


/*	Output the entire record. */

	/* SpurGenerationScavenger>>#writeScavengeLog */
static NeverInline void
writeScavengeLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static char *policyNames[] = {"", "by age", "by class", "to shrink rt", "don't tenure", "mark on tenure"};

	fprintf(GIV(scavengeLog),
			"scavenge %" PRIdSQINT " eden bytes: 0x%" PRIxSQINT "/%" PRIdSQINT " past bytes: 0x%" PRIxSQINT "/%" PRIdSQINT "\n\trem set: %" PRIdSQINT " redzone: %" PRIdSQINT " size: %" PRIdSQINT "\n",
			GIV(statScavenges),
			(GIV(scavengeLogRecord).sEdenBytes),
			(GIV(scavengeLogRecord).sEdenBytes),
			(GIV(scavengeLogRecord).sPastBytes),
			(GIV(scavengeLogRecord).sPastBytes),
			(GIV(scavengeLogRecord).sRememberedSetSize),
			(GIV(scavengeLogRecord).sRememberedSetRedZone),
			(GIV(scavengeLogRecord).sRememberedSetLimit));
	fprintf(GIV(scavengeLog),
			(((GIV(scavengeLogRecord).tTenureCriterion)) == TenureToShrinkRT
		? "\ttenure below 0x%" PRIxSQINT "/%" PRIdSQINT " %s refct %" PRIdSQINT "\n"
		: "	tenure below 0x%lx/%ld %s\n"),
			(GIV(scavengeLogRecord).tTenureThreshold),
			(GIV(scavengeLogRecord).tTenureThreshold),
			policyNames[(GIV(scavengeLogRecord).tTenureCriterion)],
			(GIV(scavengeLogRecord).tRefCountToShrinkRT));
	fprintf(GIV(scavengeLog),
			"\tsurvivor bytes: 0x%" PRIxSQINT "/%" PRIdSQINT " rem set: %" PRIdSQINT " tenured: %" PRIdSQINT " usecs: %" PRIdSQINT "\n",
			(GIV(scavengeLogRecord).eSurvivorBytes),
			(GIV(scavengeLogRecord).eSurvivorBytes),
			(GIV(scavengeLogRecord).eRememberedSetSize),
			((GIV(scavengeLogRecord).eStatTenures)) - ((GIV(scavengeLogRecord).sStatTenures)),
			GIV(statSGCDeltaUsecs));
	fflush(GIV(scavengeLog));
}


/*	Answer the accessible object following the given object or 
	free chunk in the heap. Return nil when heap is exhausted.
	This is for primitiveNextObject subsequent to primitiveSomeObject.
	It also tries to handle more general use by ordering objects as
	eden
	past
	old
	but this is tricky becaus ethe order in memory is
	past
	eden
	old */

	/* SpurMemoryManager>>#accessibleObjectAfter: */
static NoDbgRegParms sqInt
accessibleObjectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt numSlots;
    sqInt objAfter;

	objAfter = objOop;
	if (oopisLessThan(objAfter, GIV(nilObj))) {
		/* object in new space */
		assert((isInEden(objOop))
		 || (isInPastSpace(objOop)));
		if (oopisGreaterThan(objAfter, GIV(pastSpaceStart))) {
			/* Obj is in eden.  Answer next normal object in eden, if there is one. */
			while (1) {
				/* begin objectAfter:limit: */
				followingWordAddress = addressAfter(objAfter);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
					objAfter = GIV(freeStart);
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				objAfter = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
				if (!(oopisLessThan(objAfter, GIV(freeStart)))) break;
				if (((longAt(objAfter)) & (classIndexMask())) > (lastClassIndexPun())) {
					return objAfter;
				}
			}
			if (GIV(pastSpaceStart) <= (((pastSpace()).start))) {
				return GIV(nilObj);
			}
			address = ((pastSpace()).start);
			/* begin objectStartingAt: */
			numSlots = byteAt(address + 7);
			objAfter = (numSlots == (numSlotsMask())
				? address + BaseHeaderSize
				: address);
			if (((longAt(objAfter)) & (classIndexMask())) > (lastClassIndexPun())) {
				return objAfter;
			}
		}
		while (1) {
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objAfter);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
				objAfter = GIV(pastSpaceStart);
				goto l3;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objAfter = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
			if (!(oopisLessThan(objAfter, GIV(pastSpaceStart)))) break;
			if (((longAt(objAfter)) & (classIndexMask())) > (lastClassIndexPun())) {
				return objAfter;
			}
		}
		return GIV(nilObj);
	}
	while (1) {
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objAfter);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objAfter = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objAfter = ((((usqInt)(followingWord2)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l4:	/* end objectAfter:limit: */;
		if (objAfter == GIV(endOfMemory)) {
			return null;
		}
		if (((longAt(objAfter)) & (classIndexMask())) > (lastClassIndexPun())) {
			return objAfter;
		}
	}
	return 0;
}


/*	Answer whether an ephemeron is active (has an unmarked
	key) and was pushed on the unscanned ephemerons stack. */

	/* SpurMemoryManager>>#activeAndDeferredScan: */
static NoDbgRegParms NeverInline sqInt
activeAndDeferredScan(sqInt anEphemeron)
{
    sqInt key;

	assert(isEphemeron(anEphemeron));
	if ((isImmediate((	/* begin keyOfEphemeron: */
		assert((isNonImmediate(anEphemeron))
		 && (isObjEphemeron(anEphemeron))),
	(key = longAt((anEphemeron + BaseHeaderSize) + (0U << (shiftForWord())))))))
	 || (((((usqInt)((longAt(key)))) >> (markedBitFullShift())) & 1) != 0)) {
		return 0;
	}
	return pushOnUnscannedEphemeronsStack(anEphemeron);
}


/*	Add a freeChunk sub tree back into the large free chunk tree.
	This is for allocateOldSpaceChunkOf[Exactly]Bytes:[suchThat:]. */
/*	N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */

	/* SpurMemoryManager>>#addFreeSubTree: */
static NoDbgRegParms void
addFreeSubTree(sqInt freeTree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInArg;
    usqInt bytesInNode;
    sqInt subNode;
    sqInt treeNode;

	assert(isFreeObject(freeTree));
	bytesInArg = bytesInBody(freeTree);
	assert(bytesInArg >= ((numFreeLists()) * (allocationUnit())));
	treeNode = GIV(freeLists)[0];
	assert(treeNode != 0);
	while (1) {
		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		bytesInNode = bytesInBody(treeNode);
		assert((oopisLessThanOrEqualTo((freeTree + bytesInArg) - BaseHeaderSize, treeNode))
		 || (oopisGreaterThanOrEqualTo(freeTree, (treeNode + bytesInNode) - BaseHeaderSize)));
		assert(bytesInNode >= ((numFreeLists()) * (allocationUnit())));
		assert(bytesInArg != bytesInNode);
		if (bytesInNode > bytesInArg) {
			subNode = longAt((treeNode + BaseHeaderSize) + (3U << (shiftForWord())));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree)));
				longAtput((treeNode + BaseHeaderSize) + (3U << (shiftForWord())), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode)));
				longAtput((freeTree + BaseHeaderSize) + (2U << (shiftForWord())), treeNode);
				return;
			}
		}
		else {
			subNode = longAt((treeNode + BaseHeaderSize) + (4U << (shiftForWord())));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree)));
				longAtput((treeNode + BaseHeaderSize) + (4U << (shiftForWord())), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode)));
				longAtput((freeTree + BaseHeaderSize) + (2U << (shiftForWord())), treeNode);
				return;
			}
		}
		treeNode = subNode;
	}
}


/*	Add the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#addGCRoot: */
sqInt
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootsSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}

	/* SpurMemoryManager>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & (BaseHeaderSize - 1)) == 0)
	 && ((oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory)))
	 || ((oopisGreaterThanOrEqualToandLessThan(address, ((eden()).start), GIV(freeStart)))
	 || ((oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart)))
	 || ((GIV(gcPhaseInProgress) == ScavengeInProgress)
	 && (oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart()))))));
}


/*	Answer if address appears to be that of either an immediate or an object.
	For code disassembly and assertions. */

	/* SpurMemoryManager>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address)
{
	return (((address & (tagMask())) != 0))
	 || (addressCouldBeObj(address));
}


/*	Add freeChunk to the relevant freeList.
	For the benefit of sortedFreeObject:, if freeChunk is large, answer the
	treeNode it
	is added to, if it is added to the next list of a freeTreeNode, otherwise
	answer 0. */
/*	coInterpreter transcript ensureCr. coInterpreter print: 'freeing '. self
	printFreeChunk: freeChunk.
 */

	/* SpurMemoryManager>>#addToFreeList:bytes: */
static NoDbgRegParms sqInt
addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt index;
    sqInt lilliputian;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    sqInt parent;

	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInBody(freeChunk)));
	index = chunkBytes / 8 /* begin allocationUnit */;
	if (index < 64 /* begin numFreeLists */) {
		/* begin setNextFreeChunkOf:withValue:chunkBytes: */
		nextFreeChunk = GIV(freeLists)[index];
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		/* begin isLilliputianSize: */
		assert(chunkBytes >= (BaseHeaderSize + (allocationUnit())));
		lilliputian = chunkBytes == (BaseHeaderSize + 8 /* begin allocationUnit */);
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(freeChunk));
		assert((nextFreeChunk == 0)
		 || (isFreeObject(nextFreeChunk)));
		longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk);
		if ((nextFreeChunk != 0)
		 && (!lilliputian)) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk)));
			longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord())), freeChunk);
		}
		if (!((			/* begin isLilliputianSize: */
				assert(chunkBytes >= (BaseHeaderSize + (allocationUnit()))),
			chunkBytes == (BaseHeaderSize + 8 /* begin allocationUnit */)))) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(freeChunk));
			assert(1);
			longAtput((freeChunk + BaseHeaderSize) + (1U << (shiftForWord())), 0);
		}
		GIV(freeLists)[index] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | (1ULL << index);
		return 0;
	}
	/* begin addToFreeTree:bytes: */
	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInBody(freeChunk)));
	assert(chunkBytes >= ((numFreeLists()) * (allocationUnit())));
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (1U << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (2U << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (3U << (shiftForWord())), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert(1);
	longAtput((freeChunk + BaseHeaderSize) + (4U << (shiftForWord())), 0);
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		childBytes = bytesInBody(child);
		assert((oopisLessThanOrEqualTo((freeChunk + chunkBytes) - BaseHeaderSize, child))
		 || (oopisGreaterThanOrEqualTo(freeChunk, (child + childBytes) - BaseHeaderSize)));
		if (childBytes == chunkBytes) {
			/* size match; add to list at node. */
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			nextFreeChunk1 = longAt((child + BaseHeaderSize) + (0U << (shiftForWord())));
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(freeChunk));
			assert((nextFreeChunk1 == 0)
			 || (isFreeObject(nextFreeChunk1)));
			longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk1);
			if ((nextFreeChunk1 != 0)) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(nextFreeChunk1));
				assert((freeChunk == 0)
				 || (isFreeObject(freeChunk)));
				longAtput((nextFreeChunk1 + BaseHeaderSize) + (1U << (shiftForWord())), freeChunk);
			}
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			assert(isFreeObject(child));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk)));
			longAtput((child + BaseHeaderSize) + (0U << (shiftForWord())), freeChunk);
			if ((freeChunk != 0)) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeChunk));
				assert((child == 0)
				 || (isFreeObject(child)));
				longAtput((freeChunk + BaseHeaderSize) + (1U << (shiftForWord())), child);
			}
			return child;
		}
		parent = child;
		child = longAt((child + BaseHeaderSize) + (((sqInt)((usqInt)(((childBytes > chunkBytes
	? 3 /* begin freeChunkSmallerIndex */
	: 4 /* begin freeChunkLargerIndex */))) << (shiftForWord())))));
	}
	if (parent == 0) {
		assert((GIV(freeLists)[0]) == 0);
		GIV(freeLists)[0] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | 1;
		return 0;
	}
	assert(((GIV(freeListsMask) & 1) != 0));
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((parent == 0)
	 || (isFreeObject(parent)));
	longAtput((freeChunk + BaseHeaderSize) + (2U << (shiftForWord())), parent);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(parent));
	assert((freeChunk == 0)
	 || (isFreeObject(freeChunk)));
	longAtput((parent + BaseHeaderSize) + (((sqInt)((usqInt)(((childBytes > chunkBytes
	? 3 /* begin freeChunkSmallerIndex */
	: 4 /* begin freeChunkLargerIndex */))) << (shiftForWord())))), freeChunk);
	return 0;
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of instances as a
	SmallInteger. Since objects are at least 16 bytes big, and the largest
	SmallInteger covers
	1/4 of the address space, the count can never overflow. */

	/* SpurMemoryManager>>#allInstancesOf: */
static NoDbgRegParms sqInt
allInstancesOf(sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualIndex;
    usqInt bytes;
    sqInt c;
    sqInt classIndex;
    sqInt classOrNil;
    sqInt count;
    sqInt count1;
    sqInt count2;
    sqInt entry;
    sqInt expectedIndex;
    sqInt expectedIndex1;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord11;
    sqInt followingWord2;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress11;
    usqInt followingWordAddress2;
    sqInt format;
    sqInt formatField;
    sqInt formatField1;
    sqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt index;
    sqInt index1;
    sqInt j;
    sqInt jLimiT;
    usqInt limit;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt p;
    sqInt page;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt ptr;
    sqInt ptr1;
    sqInt ptr2;
    sqInt smallObj;
    usqInt start;
    usqInt start1;
    usqInt start11;

	c = 0;
	p = 0;
	classIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask());
	if (classIndex == 0) {
		formatField = arrayFormat();
		/* begin allocateSlots:format:classIndex: */
				newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8 /* begin allocationUnit */);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			freeChunk = allocateSlotsInOldSpacebytesformatclassIndex(0, numBytes, formatField, ClassArrayCompactIndex);
			goto l1;
		}
		longAtput(newObj, (((((usqLong) 0)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + ClassArrayCompactIndex);
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		freeChunk = newObj;
	l1:	/* end allocateSlots:format:classIndex: */;
		return freeChunk;
	}
	/* N.B. Does /not/ update totalFreeOldSpace */
	freeChunk = allocateLargestFreeChunk();
	start = freeChunk + BaseHeaderSize;
	limit = addressAfter(freeChunk);
	if (isClassAtUniqueIndex(aClass)) {
		/* begin uniqueIndex:allInstancesInto:limit:resultsInto: */
		obj1 = 0;
		count2 = 0;
		ptr2 = start;
		/* begin allHeapEntitiesDo: */
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj2 = (prevObj2 = null);
		objOop2 = GIV(nilObj);
		while (1) {
			assert((objOop2 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop2, GIV(endOfMemory)))) break;
			assert((long64At(objOop2)) != 0);
			if (((longAt(objOop2)) & (classIndexMask())) > (lastClassIndexPun())) {
				if (((longAt(objOop2)) & (classIndexMask())) == classIndex) {
					count2 += 1;
					if (ptr2 < limit) {
						longAtput(ptr2, objOop2);
						ptr2 += BytesPerOop;
					}
				}
			}
			else {
			}
			prevPrevObj2 = prevObj2;
			prevObj2 = objOop2;
			/* begin objectAfter:limit: */
			followingWordAddress2 = addressAfter(objOop2);
			if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
				objOop2 = GIV(endOfMemory);
				goto l10;
			}
			flag("endianness");
			followingWord2 = longAt(followingWordAddress2);
			objOop2 = ((((usqInt)(followingWord2)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress2 + BaseHeaderSize
				: followingWordAddress2);
	l10:	/* end objectAfter:limit: */;
		}
		/* begin allNewSpaceEntitiesDo: */
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj11 = (prevObj11 = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		start11 = 
		/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		if (start11 > GIV(freeStart)) {
			goto l11;
		}
		/* begin bridgePastSpaceAndEden */
		if (GIV(pastSpaceStart) < (((eden()).start))) {
			/* past space can be entirely full (!!) */
			if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
				/* No room for a full bridge (!!); use the slim bridge hack */
				hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
				assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
			}
			else {
				/* Room for a regular bridge; this is straight-forward */
				initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
			}
		}
		/* begin objectStartingAt: */
		numSlots1 = byteAt(start11 + 7);
		objOop11 = (numSlots1 == (numSlotsMask())
			? start11 + BaseHeaderSize
			: start11);
		while (oopisLessThan(objOop11, GIV(freeStart))) {
			if (((longAt(objOop11)) & (classIndexMask())) > (lastClassIndexPun())) {
				if (((longAt(objOop11)) & (classIndexMask())) == classIndex) {
					count2 += 1;
					if (ptr2 < limit) {
						longAtput(ptr2, objOop11);
						ptr2 += BytesPerOop;
					}
				}
			}
			else {
			}
			prevPrevObj11 = prevObj11;
			prevObj11 = objOop11;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress11 = addressAfter(objOop11);
			if (oopisGreaterThanOrEqualTo(followingWordAddress11, GIV(freeStart))) {
				objOop11 = GIV(freeStart);
				goto l12;
			}
			flag("endianness");
			followingWord11 = longAt(followingWordAddress11);
			objOop11 = ((((usqInt)(followingWord11)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(objOop11, GIV(oldSpaceStart)))
					 && ((followingWord11 & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress11 + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress11 + BaseHeaderSize)
				: followingWordAddress11);
	l12:	/* end objectAfterMaybeSlimBridge:limit: */;
		}
	l11:	/* end allNewSpaceEntitiesDo: */;
		count = count2;
		ptr = ptr2;
	}
	else {
		/* begin ambiguousClass:allInstancesInto:limit:resultsInto: */
		obj = 0;
		count1 = 0;
		ptr1 = start;
		expectedIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask());
		/* begin allHeapEntitiesDo: */
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj = (prevObj = null);
		objOop = GIV(nilObj);
		while (1) {
			assert((objOop % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
			assert((long64At(objOop)) != 0);
			if (((longAt(objOop)) & (classIndexMask())) > (lastClassIndexPun())) {
				actualIndex = (longAt(objOop)) & (classIndexMask());
				if ((classOrNilAtIndex(actualIndex)) == aClass) {
					if (actualIndex != expectedIndex) {
						/* begin setClassIndexOf:to: */
						assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask()))));
						longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(classIndexMask()))) + expectedIndex);
					}
					count1 += 1;
					if (ptr1 < limit) {
						longAtput(ptr1, objOop);
						ptr1 += BytesPerOop;
					}
				}
			}
			else {
			}
			prevPrevObj = prevObj;
			prevObj = objOop;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				objOop = GIV(endOfMemory);
				goto l6;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
		}
		/* begin allNewSpaceEntitiesDo: */
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj1 = (prevObj1 = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		start1 = 
		/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		if (start1 > GIV(freeStart)) {
			goto l7;
		}
		/* begin bridgePastSpaceAndEden */
		if (GIV(pastSpaceStart) < (((eden()).start))) {
			/* past space can be entirely full (!!) */
			if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
				/* No room for a full bridge (!!); use the slim bridge hack */
				hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
				assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
			}
			else {
				/* Room for a regular bridge; this is straight-forward */
				initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
			}
		}
		/* begin objectStartingAt: */
		numSlots = byteAt(start1 + 7);
		objOop1 = (numSlots == (numSlotsMask())
			? start1 + BaseHeaderSize
			: start1);
		while (oopisLessThan(objOop1, GIV(freeStart))) {
			if (((longAt(objOop1)) & (classIndexMask())) > (lastClassIndexPun())) {
				actualIndex = (longAt(objOop1)) & (classIndexMask());
				if ((classOrNilAtIndex(actualIndex)) == aClass) {
					if (actualIndex != expectedIndex) {
						/* begin setClassIndexOf:to: */
						assert(((expectedIndex >= 0) && (expectedIndex <= (classIndexMask()))));
						longAtput(objOop1, ((longAt(objOop1)) & (~(usqIntptr_t)(classIndexMask()))) + expectedIndex);
					}
					count1 += 1;
					if (ptr1 < limit) {
						longAtput(ptr1, objOop1);
						ptr1 += BytesPerOop;
					}
				}
			}
			else {
			}
			prevPrevObj1 = prevObj1;
			prevObj1 = objOop1;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress1 = addressAfter(objOop1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
				objOop1 = GIV(freeStart);
				goto l8;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
					 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress1 + BaseHeaderSize)
				: followingWordAddress1);
	l8:	/* end objectAfterMaybeSlimBridge:limit: */;
		}
	l7:	/* end allNewSpaceEntitiesDo: */;
		/* begin purgeDuplicateClassTableEntriesFor: */
		entry = 0;
		index = 0;
		expectedIndex1 = (long32At(aClass + 4)) & (identityHashHalfWordMask());
		/* begin classTableEntriesDo: */
		for (i1 = 0; i1 < GIV(numClassTablePages); i1 += 1) {
			page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			for (j = 0, jLimiT = ((1U << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
				classOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))));
				if (classOrNil != GIV(nilObj)) {
					index1 = (((sqInt)((usqInt)(i1) << (classTableMajorIndexShift())))) + j;
					if ((classOrNil == aClass)
					 && ((index1 != expectedIndex1)
					 && (index1 > (lastClassIndexPun())))) {
						classAtIndexput(index1, GIV(nilObj));
						if (index1 < GIV(classTableIndex)) {
							GIV(classTableIndex) = index1;
						}
					}
				}
			}
		}
		assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
		count = count1;
		ptr = ptr1;
	}
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8 /* begin allocationUnit */))) {
		/* can't split a single word */
		freeChunkWithBytesat(bytesInBody(freeChunk), 
		/* begin startOfObject: */
((byteAt(freeChunk + 7)) == (numSlotsMask())
			? freeChunk - BaseHeaderSize
			: freeChunk));
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
		}
		return (((usqInt)count << 3) | 1);
	}
	if (count < (numSlotsMask())) {
		formatField1 = arrayFormat();
		/* begin allocateSlots:format:classIndex: */
		if (count >= (numSlotsMask())) {
			if ((((usqInt)(count)) >> 56) > 0) {
				smallObj = null;
				goto l2;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes1 = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes1 = BaseHeaderSize + ((count < 1
	? 8 /* begin allocationUnit */
	: count * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			smallObj = allocateSlotsInOldSpacebytesformatclassIndex(count, numBytes1, formatField1, ClassArrayCompactIndex);
			goto l2;
		}
		if (count >= (numSlotsMask())) {
			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + count);
			longAtput(newObj1, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField1) << (formatShift()))))) + ClassArrayCompactIndex);
		}
		else {
			longAtput(newObj1, (((((usqLong) count)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField1) << (formatShift()))))) + ClassArrayCompactIndex);
		}
		assert((numBytes1 % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes1;
		smallObj = newObj1;
	l2:	/* end allocateSlots:format:classIndex: */;
		for (i = 0; i < count; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(smallObj)));
			longAtput((smallObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((freeChunk + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
		}
		freeChunkWithBytesat(bytesInBody(freeChunk), 
		/* begin startOfObject: */
((byteAt(freeChunk + 7)) == (numSlotsMask())
			? freeChunk - BaseHeaderSize
			: freeChunk));
		beRootIfOld(smallObj);
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
		}
		return smallObj;
	}
	bytes = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
	start = 
	/* begin startOfObject: */
((byteAt(freeChunk + 7)) == (numSlotsMask())
		? freeChunk - BaseHeaderSize
		: freeChunk);
	freeChunkWithBytesat((limit - start) - bytes, start + bytes);
	GIV(totalFreeOldSpace) -= bytes;
	/* begin rawOverflowSlotsOf:put: */
	longAtput(freeChunk - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask())) << 56))) + count);
	format = arrayFormat();
	/* begin set:classIndexTo:formatTo: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask()))));
	assert(((format >= 0) && (format <= (formatMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (ClassArrayCompactIndex + (((sqInt)((usqInt)(format) << (formatShift()))))));
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt)((longAt(freeChunk)))) >> (rememberedBitShift())) & 1) != 0)) {
		remember(freeChunk);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	runLeakCheckerFor(GCModeFull);
	return freeChunk;
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of objects as a SmallInteger.
	Since objects are at least 16 bytes big, and the largest SmallInteger
	covers 1/4 of the address space, the count can never overflow. */

	/* SpurMemoryManager>>#allObjects */
static sqInt
allObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytes;
    sqInt count;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt format;
    sqInt freeChunk;
    usqInt limit;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ptr;
    usqInt start;
    usqInt start1;

	obj = 0;
	/* N.B. Does /not/ update totalFreeOldSpace */
	freeChunk = allocateLargestFreeChunk();
	ptr = (start = freeChunk + BaseHeaderSize);
	limit = addressAfter(freeChunk);
	count = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((longAt(objOop)) & (classIndexMask())) > (lastClassIndexPun())) {
			count += 1;
			if (ptr < limit) {
				longAtput(ptr, objOop);
				ptr += BytesPerOop;
			}
		}
		else {
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l5:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start1 = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start1 > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start1 + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start1 + BaseHeaderSize
		: start1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) > (lastClassIndexPun())) {
			count += 1;
			if (ptr < limit) {
				longAtput(ptr, objOop1);
				ptr += BytesPerOop;
			}
		}
		else {
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	assert(count >= (numSlotsMask()));
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8 /* begin allocationUnit */))) {
		/* can't split a single word */
		freeChunkWithBytesat(bytesInBody(freeChunk), 
		/* begin startOfObject: */
((byteAt(freeChunk + 7)) == (numSlotsMask())
			? freeChunk - BaseHeaderSize
			: freeChunk));
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
		}
		return (((usqInt)count << 3) | 1);
	}
	bytes = (BaseHeaderSize + BaseHeaderSize) + (count * BytesPerOop);
	start = 
	/* begin startOfObject: */
((byteAt(freeChunk + 7)) == (numSlotsMask())
		? freeChunk - BaseHeaderSize
		: freeChunk);
	freeChunkWithBytesat((limit - start) - bytes, start + bytes);
	GIV(totalFreeOldSpace) -= bytes;
	/* begin rawOverflowSlotsOf:put: */
	longAtput(freeChunk - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask())) << 56))) + count);
	format = arrayFormat();
	/* begin set:classIndexTo:formatTo: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask()))));
	assert(((format >= 0) && (format <= (formatMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (ClassArrayCompactIndex + (((sqInt)((usqInt)(format) << (formatShift()))))));
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt)((longAt(freeChunk)))) >> (rememberedBitShift())) & 1) != 0)) {
		remember(freeChunk);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	runLeakCheckerFor(GCModeFull);
	return freeChunk;
}

	/* SpurMemoryManager>>#allObjectsUnmarked */
static sqInt
allObjectsUnmarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt o;
    sqInt obj;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	o = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (((((usqInt)((longAt(obj)))) >> (markedBitFullShift())) & 1) != 0) {
				GIV(bogon) = obj;
				return 0;
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	return 1;
}

	/* SpurMemoryManager>>#allOldMarkedWeakObjectsOnWeaklingStack */
static sqInt
allOldMarkedWeakObjectsOnWeaklingStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	o = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((isWeakNonImm(objOop))
		 && (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0)) {
			if (!(isonObjStack(objOop, GIV(weaklingStack)))) {
				return 0;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return 1;
}


/*	Answer the largest free chunk in the free lists. */
/*	would like to use ifNotNil: but the ^next inside the ^blah ifNotNil:
	confused Slang
 */

	/* SpurMemoryManager>>#allocateLargestFreeChunk */
static sqInt
allocateLargestFreeChunk(void)
{
    sqInt freeChunk;
    sqInt next;
    sqInt nextFreeChunk;

	freeChunk = findLargestFreeChunk();
	if (!freeChunk) {
		return null;
	}
	next = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())));
	if (next != 0) {
		assert((bytesInBody(freeChunk)) >= (numFreeLists()));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		nextFreeChunk = longAt((next + BaseHeaderSize) + (0U << (shiftForWord())));
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(freeChunk));
		assert((nextFreeChunk == 0)
		 || (isFreeObject(nextFreeChunk)));
		longAtput((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk);
		if ((nextFreeChunk != 0)) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk)));
			longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord())), freeChunk);
		}
		return next;
	}
	unlinkSolitaryFreeTreeNode(freeChunk);
	return freeChunk;
}


/*	Allocate an object with numSlots in newSpace. This is for the `ee'
	execution engine allocations,
	and must be satisfied. If no memory is available, abort. If the allocation
	pushes freeStart past
	scavengeThreshold and a scavenge is not already scheduled, schedule a
	scavenge.  */
/*	Object headers are 8 bytes in length if the slot size fits in the num
	slots field (max implies overflow),
	16 bytes otherwise (num slots in preceding word).
	Objects always have at least one slot, for the forwarding pointer,
	and are multiples of 8 bytes in length. */

	/* SpurMemoryManager>>#allocateNewSpaceSlots:format:classIndex: */
static NoDbgRegParms usqInt
allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newObj;
    usqInt numBytes;

	if (numSlots >= (numSlotsMask())) {
		if (numSlots > 0xFFFFFFFFU) {
			return null;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateNewSpaceSlots:format:classIndex:");
			return 0;
		}
	}
	if (numSlots >= (numSlotsMask())) {
		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		long64Atput(newObj, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	}
	else {
		long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}


/*	Answer a chunk of oldSpace from the free lists, if available,
	otherwise answer nil. Break up a larger chunk if one of the
	exact size does not exist. N.B. the chunk is simply a pointer, it
	has no valid header. The caller *must* fill in the header correctly. */
/*	for debugging: */
/*	totalFreeOldSpace := self totalFreeListBytes */

	/* SpurMemoryManager>>#allocateOldSpaceChunkOfBytes: */
static NoDbgRegParms sqInt
allocateOldSpaceChunkOfBytes(usqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    usqInt index;
    usqInt initialIndex;
    sqInt lilliputian;
    sqInt next;
    sqInt next1;
    sqInt next2;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    usqInt nodeBytes;
    sqInt parent;

	nodeBytes = 0;
	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= chunkBytes;
	initialIndex = chunkBytes / 8 /* begin allocationUnit */;
	if ((initialIndex < 64 /* begin numFreeLists */)
	 && ((1ULL << initialIndex) <= GIV(freeListsMask))) {
		if (((GIV(freeListsMask) & (1ULL << initialIndex)) != 0)) {
			if (((chunk = GIV(freeLists)[initialIndex])) != 0) {
				assert(chunk == (startOfObject(chunk)));
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk));
				/* begin isLilliputianSize: */
				assert(chunkBytes >= (BaseHeaderSize + (allocationUnit())));
				lilliputian = chunkBytes == (BaseHeaderSize + 8 /* begin allocationUnit */);
				/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
				assert(((bytesInBody(chunk)) == (initialIndex * (allocationUnit())))
				 && ((initialIndex > 1)
				 && ((startOfObject(chunk)) == chunk)));
				GIV(freeLists)[initialIndex] = ((next2 = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord())))));
				if ((!lilliputian)
				 && (next2 != 0)) {
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(next2));
					assert(1);
					longAtput((next2 + BaseHeaderSize) + (1U << (shiftForWord())), 0);
				}
				return chunk;
			}
			GIV(freeListsMask) -= 1ULL << initialIndex;
		}
		index = initialIndex;
		while ((((index += index)) < 64 /* begin numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk));
					assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = ((next = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord())))));
					if (next != 0) {
						/* begin storePointer:ofFreeChunk:withValue: */
						assert(isFreeObject(next));
						assert(1);
						longAtput((next + BaseHeaderSize) + (1U << (shiftForWord())), 0);
					}
					assert((bytesInBody(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * 8 /* begin allocationUnit */) - chunkBytes, (/* begin startOfObject: */
	((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1ULL << index;
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 64 /* begin numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk));
					assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = ((next1 = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord())))));
					if (next1 != 0) {
						/* begin storePointer:ofFreeChunk:withValue: */
						assert(isFreeObject(next1));
						assert(1);
						longAtput((next1 + BaseHeaderSize) + (1U << (shiftForWord())), 0);
					}
					assert((bytesInBody(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * 8 /* begin allocationUnit */) - chunkBytes, (/* begin startOfObject: */
	((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1ULL << index;
			}
		}
	}
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child));
		childBytes = bytesInBody(child);
		if (childBytes == chunkBytes) {
			/* size match; try to remove from list at node. */
			chunk = longAt((child + BaseHeaderSize) + (0U << (shiftForWord())));
			if (chunk != 0) {
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk));
				nextFreeChunk = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord())));
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(child));
				assert((nextFreeChunk == 0)
				 || (isFreeObject(nextFreeChunk)));
				longAtput((child + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk);
				if ((nextFreeChunk != 0)) {
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(nextFreeChunk));
					assert((child == 0)
					 || (isFreeObject(child)));
					longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord())), child);
				}
				return 
				/* begin startOfObject: */
((byteAt(chunk + 7)) == (numSlotsMask())
					? chunk - BaseHeaderSize
					: chunk);
			}
			nodeBytes = childBytes;
			parent = child;
			/* break out of loop to remove interior node */
			child = 0;
		}
		else {
			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (chunkBytes + 8 /* begin allocationUnit */)) {
				/* node too small; walk down the larger size of the tree */
				child = longAt((child + BaseHeaderSize) + (4U << (shiftForWord())));
			}
			else {
				/* parent will be smallest node >= chunkBytes + allocationUnit */
				parent = child;
				nodeBytes = childBytes;
				child = longAt((child + BaseHeaderSize) + (3U << (shiftForWord())));
			}
		}
	}
	if (parent == 0) {
		/* optimism was unfounded */
		GIV(totalFreeOldSpace) += chunkBytes;
		return null;
	}
	assert((nodeBytes == chunkBytes)
	 || (nodeBytes >= (chunkBytes + (2 * (allocationUnit())))));
	assert((bytesInBody(parent)) == nodeBytes);
	chunk = longAt((parent + BaseHeaderSize) + (0U << (shiftForWord())));
	if (chunk != 0) {
		assert((chunkBytes == nodeBytes)
		 || ((chunkBytes + (allocationUnit())) < nodeBytes));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		nextFreeChunk1 = longAt((chunk + BaseHeaderSize) + (0U << (shiftForWord())));
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(parent));
		assert((nextFreeChunk1 == 0)
		 || (isFreeObject(nextFreeChunk1)));
		longAtput((parent + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk1);
		if ((nextFreeChunk1 != 0)) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk1));
			assert((parent == 0)
			 || (isFreeObject(parent)));
			longAtput((nextFreeChunk1 + BaseHeaderSize) + (1U << (shiftForWord())), parent);
		}
		if (chunkBytes != nodeBytes) {
			freeChunkWithBytesat(nodeBytes - chunkBytes, (/* begin startOfObject: */
	((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
		}
		return 
		/* begin startOfObject: */
((byteAt(chunk + 7)) == (numSlotsMask())
			? chunk - BaseHeaderSize
			: chunk);
	}
	chunk = parent;
	unlinkSolitaryFreeTreeNode(chunk);
	if (chunkBytes != nodeBytes) {
		freeChunkWithBytesat(nodeBytes - chunkBytes, (/* begin startOfObject: */
	((byteAt(chunk + 7)) == (numSlotsMask())
	? chunk - BaseHeaderSize
	: chunk)) + chunkBytes);
	}
	return 
	/* begin startOfObject: */
((byteAt(chunk + 7)) == (numSlotsMask())
		? chunk - BaseHeaderSize
		: chunk);
}

	/* SpurMemoryManager>>#allocatePinnedSlots: */
sqInt
allocatePinnedSlots(sqInt nSlots)
{
    sqInt obj;
    usqInt p;

	obj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, 
	/* begin objectBytesForSlots: */
(nSlots == 0
		? 8 /* begin allocationUnit */ + BaseHeaderSize
		: (((sqInt)((usqInt)(nSlots) << (shiftForWord())))) + ((nSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
	if (!(obj == null)) {
		assert(isPinned(obj));
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj)));
		for (p = (((usqInt)(obj + BaseHeaderSize))); p <= (((usqInt)(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, 0);
		}
	}
	return obj;
}


/*	All objects are a multiple of 8 bytes in length */

	/* SpurMemoryManager>>#allocationUnit */
static sqInt
allocationUnit(void)
{
	return 8;
}


/*	N.B. generateToByDoLimitExpression:negative:on: guards against (unsigned)0
	- 1 going +ve
 */

	/* SpurMemoryManager>>#allStrongSlotsOfWeaklingAreMarked: */
static NoDbgRegParms sqInt
allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling)
{
    sqInt i;
    sqInt iLimiT;
    sqInt referent;

	for (i = 0, iLimiT = ((numStrongSlotsOfWeakling(aWeakling)) - 1); i <= iLimiT; i += 1) {
		referent = longAt((aWeakling + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((!(referent & (tagMask())))) {
			if (!(((((usqInt)((longAt(referent)))) >> (markedBitFullShift())) & 1) != 0)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#allUnscannedEphemeronsAreActive */
static sqInt
allUnscannedEphemeronsAreActive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt key;
    sqInt p;

	for (p = ((GIV(unscannedEphemerons).start)); p <= (((GIV(unscannedEphemerons).top)) - BytesPerOop); p += BytesPerOop) {
		/* begin keyOfMaybeFiredEphemeron: */
		assert((isNonImmediate(longAt(p)))
		 && (isMaybeFiredEphemeron(longAt(p))));
		key = longAt(((longAt(p)) + BaseHeaderSize) + (0U << (shiftForWord())));
		if ((((key & (tagMask())) != 0))
		 || (((((usqInt)((longAt(key)))) >> (markedBitFullShift())) & 1) != 0)) {
			return 0;
		}
	}
	return 1;
}


/*	we don't want to inline so we can nest that in an assertion with the
	return true so the production VM does not generate any code here, while in
	simulation, the code breaks on the assertion we want to.
 */

	/* SpurMemoryManager>>#assertInnerValidFreeObject: */
static NoDbgRegParms NeverInline sqInt
assertInnerValidFreeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    sqInt chunk;
    sqInt freeNode;
    usqInt index;
    sqInt largeChild;
    sqInt smallChild;
    sqInt treeNode;

	freeNode = 0;
	assert(oopisLessThanOrEqualTo(addressAfter(objOop), GIV(endOfMemory)));
	chunk = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
	assert((chunk == 0)
	 || (isFreeOop(chunk)));
	if (!(isLilliputianSize(bytesInBody(objOop)))) {
		/* double linkedlist assertions */
		chunk = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
		if (!(chunk == 0)) {
			assert(isFreeOop(chunk));
			assert(objOop == (fetchPointerofFreeChunk(freeChunkPrevIndex(), chunk)));
		}
		chunk = longAt((objOop + BaseHeaderSize) + (1U << (shiftForWord())));
		index = (bytesInBody(objOop)) / 8 /* begin allocationUnit */;
		if ((index < 64 /* begin numFreeLists */)
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if ((GIV(freeLists)[index]) == objOop) {
				assert(chunk == 0);
			}
		}
		else {
			/* begin freeTreeNodesDo: */
			treeNode = GIV(freeLists)[0];
			if (treeNode == 0) {
				goto l1;
			}
			cameFrom = -1;
			do {
				assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
				smallChild = longAt((treeNode + BaseHeaderSize) + (3U << (shiftForWord())));
				largeChild = longAt((treeNode + BaseHeaderSize) + (4U << (shiftForWord())));
				assert((smallChild == 0)
				 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
				assert((largeChild == 0)
				 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
				if (((smallChild == 0)
				 && (largeChild == 0))
				 || ((largeChild == 0
					? cameFrom == smallChild
					: cameFrom == largeChild))) {
					if (treeNode == objOop) {
						assert(chunk == 0);
					}
					cameFrom = treeNode;
					treeNode = longAt((treeNode + BaseHeaderSize) + (2U << (shiftForWord())));
				}
				else {
					if ((smallChild != 0)
					 && (cameFrom != smallChild)) {
						treeNode = smallChild;
					}
					else {
						assert(largeChild != 0);
						treeNode = largeChild;
					}
					cameFrom = -1;
				}
			} while(treeNode != 0);
	l1:	/* end freeTreeNodesDo: */;
		}
		if (!(chunk == 0)) {
			assert(isFreeOop(chunk));
			assert(objOop == (fetchPointerofFreeChunk(freeChunkNextIndex(), chunk)));
		}
	}
	if ((bytesInBody(objOop)) >= (0x200)) {
		/* Tree assertions */
		chunk = longAt((objOop + BaseHeaderSize) + (2U << (shiftForWord())));
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
		chunk = longAt((objOop + BaseHeaderSize) + (3U << (shiftForWord())));
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
		chunk = longAt((objOop + BaseHeaderSize) + (4U << (shiftForWord())));
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
	}
	return 1;
}

	/* SpurMemoryManager>>#become:with: */
sqInt
becomewith(sqInt array1, sqInt array2)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced
	with with pointers to the other. The arguments must be arrays of the same
	length. 
	Answers PrimNoErr if the primitive succeeds, otherwise a relevant error
	code. 
 */
/*	Implementation: Uses lazy forwarding to defer updating references until
	message send.
 */

	/* SpurMemoryManager>>#become:with:twoWay:copyHash: */
static NoDbgRegParms sqInt
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt classIndex;
    sqInt contextSize;
    sqInt ec;
    sqInt errCode;
    sqInt fieldOffset;
    sqInt fmt;
    sqInt hash;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt newObj1;
    sqInt newObj2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots21;
    usqInt numSlots3;
    usqInt numSlots4;
    usqLong o1ClassIndex;
    sqLong o1Header;
    usqLong o2ClassIndex;
    sqLong o2Header;
    sqInt obj1;
    sqInt obj11;
    sqInt obj2;
    sqInt obj21;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop21;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt oop1;
    sqInt oop2;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt referent3;
    sqInt size;
    sqInt sp;
    sqInt theBecomeEffectsFlags;
    sqInt top;

	assert(GIV(becomeEffectsFlags) == 0);
	runLeakCheckerFor(GCModeBecome);
	if (!(		/* begin isArray: */
			((!(array1 & (tagMask()))))
		 && (((((usqInt)((longAt(array1)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))) {
		return PrimErrBadReceiver;
	}
	if (!((		/* begin isArray: */
			((!(array2 & (tagMask()))))
		 && (((((usqInt)((longAt(array2)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((assert((classIndexOf(array1)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(array1 + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(array1 - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) == ((		/* begin numSlotsOf: */
			assert((classIndexOf(array2)) > (isForwardedObjectClassIndexPun())),
		(((numSlots1 = byteAt(array2 + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(array2 - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1)))))) {
		return PrimErrBadArgument;
	}
	/* begin containsOnlyValidBecomeObjects:and:twoWay:copyHash: */
	errCode = 0;
	fmt = (((usqInt)((longAt(array1)))) >> (formatShift())) & (formatMask());
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5 /* begin lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(array1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l5;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array1)));
			contextSize = (sp >> 3);
	l5:	/* end fetchStackPointerOf: */;
			fieldOffset = (((CtxtTempFrameStart - 1) + contextSize) * BytesPerOop) + BaseHeaderSize;
			goto l7;
		}
		fieldOffset = ((((/* begin numSlotsOf: */
	assert((classIndexOf(array1)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(array1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(array1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) - 1) * BytesPerOop) + BaseHeaderSize;
		goto l7;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l7;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(array1));
	header1 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	fieldOffset = (((((/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
	l7:;
	/* array1 is known to be the same size as array2 */
	size = 0;
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(array1 + fieldOffset);
		if (		/* begin isOopForwarded: */
			((!(oop1 & (tagMask()))))
		 && ((!((longAt(oop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop1));
			referent2 = longAt((oop1 + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent2 & (tagMask()))))
			 && ((!((longAt(referent2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			oop1 = referent2;
			longAtput(array1 + fieldOffset, oop1);
		}
		/* begin ifOopInvalidForBecome:errorCodeInto: */
		if (((oop1 & (tagMask())) != 0)) {
			ec = PrimErrInappropriate;
			goto l9;
			goto l2;
		}
		if (((((usqInt)((longAt(oop1)))) >> (pinnedBitShift())) & 1) != 0) {
			ec = PrimErrObjectIsPinned;
			goto l9;
			goto l2;
		}
		if (
#    if IMMUTABILITY
			((((usqInt)((longAt(oop1)))) >> (immutableBitShift())) & 1) != 0
#    else
			0
#    endif
			) {
			ec = PrimErrNoModification;
			goto l9;
		}
	l2:	/* end ifOopInvalidForBecome:errorCodeInto: */;
		oop2 = longAt(array2 + fieldOffset);
		if (		/* begin isOopForwarded: */
			((!(oop2 & (tagMask()))))
		 && ((!((longAt(oop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop2));
			referent1 = longAt((oop2 + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent1 & (tagMask()))))
			 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			oop2 = referent1;
			longAtput(array2 + fieldOffset, oop2);
		}
		if (oop1 != oop2) {
			if (twoWayFlag) {
				/* begin ifOopInvalidForBecome:errorCodeInto: */
				if (((oop2 & (tagMask())) != 0)) {
					ec = PrimErrInappropriate;
					goto l9;
					goto l4;
				}
				if (((((usqInt)((longAt(oop2)))) >> (pinnedBitShift())) & 1) != 0) {
					ec = PrimErrObjectIsPinned;
					goto l9;
					goto l4;
				}
				if (
#        if IMMUTABILITY
					((((usqInt)((longAt(oop2)))) >> (immutableBitShift())) & 1) != 0
#        else
					0
#        endif
					) {
					ec = PrimErrNoModification;
					goto l9;
				}
	l4:	/* end ifOopInvalidForBecome:errorCodeInto: */;
				size = (size + (bytesInBody(oop1))) + (bytesInBody(oop2));
				GIV(becomeEffectsFlags) = (GIV(becomeEffectsFlags) | (becomeEffectFlagsFor(oop1))) | (becomeEffectFlagsFor(oop2));
			}
			else {
				if (copyHashFlag) {
					if (((oop2 & (tagMask())) != 0)) {
						ec = PrimErrInappropriate;
						goto l9;
					}
					if (
#          if IMMUTABILITY
						((((usqInt)((longAt(oop2)))) >> (immutableBitShift())) & 1) != 0
#          else
						0
#          endif
						) {
						ec = PrimErrNoModification;
						goto l9;
					}
				}
				GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | (becomeEffectFlagsFor(oop1));
			}
		}
		fieldOffset -= BytesPerOop;
	}
	if (size >= (GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart)))) {
		ec = PrimErrNoMemory;
		goto l9;
	}
	ec = 0;
	l9:	/* end containsOnlyValidBecomeObjects:and:twoWay:copyHash: */;
	if (ec != 0) {
		/* begin zeroBecomeEffectFlagsOnFailure */
		if (((GIV(becomeEffectsFlags) & BecameJittedCompiledMethodFlag) != 0)) {
			unflagBecomeFlaggedMethods();
		}
		GIV(becomeEffectsFlags) = 0;
		return ec;
	}
	theBecomeEffectsFlags = GIV(becomeEffectsFlags);
	/* begin preBecomeAction: */
	if (!(GIV(stackPage) == null)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	if (((theBecomeEffectsFlags & BecameJittedCompiledMethodFlag) != 0)) {
		/* begin insulateFramesAndContextsFromCogMethodsFlaggedForBecome */
		activeContext = divorceAllFramesSuchThat(isMachineCodeFrameForCogMethodFlaggedForBecome);
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		assert((GIV(framePointer) != 0) == (isStillMarriedContext(activeContext)));
		if (!(			/* begin isStillMarriedContext: */
				(((((longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (!(isWidowedContext(activeContext))))) {
			/* begin activeProcess */
			objOop12 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
			objOop5 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(objOop5)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(objOop5)),
			oopisGreaterThanOrEqualTo(objOop5, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(activeContext & (tagMask()))))
				 && (oopisLessThan(activeContext, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(objOop5)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(objOop5);
					}
				}
			}
			longAtput((objOop5 + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);
		}
	}
	GIV(gcMode) = GCModeBecome;
	if (twoWayFlag) {
		/* begin innerBecomeObjectsIn:and:copyHash: */
		for (i = 0, iLimiT = (((assert((classIndexOf(array1)) > (isForwardedObjectClassIndexPun())),
(((numSlots3 = byteAt(array1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(array1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3))) - 1); i <= iLimiT; i += 1) {
			/* At first blush it would appear unnecessary to use followField: here since
			   the validation in become:with:twoWay:copyHash: follows forwarders.  But
			   there's nothing to ensure all elements of each array are unique and don't
			   appear in the other array.  So the enumeration could encounter an object
			   already becommed earlier in the same enumeration. */
			/* begin followField:ofObject: */
			objOop = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop & (tagMask()))))
			 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(i, array1, objOop);
			}
			obj1 = objOop;
			/* begin followField:ofObject: */
			objOop1 = longAt((array2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop1 & (tagMask()))))
			 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(i, array2, objOop1);
			}
			obj2 = objOop1;
			if (obj1 != obj2) {
				/* begin doBecome:and:copyHash: */
				o1Header = long64At(obj1);
				o1ClassIndex = (((usqInt)(obj1)) >> (identityHashFullWordShift())) & (identityHashHalfWordMask());
				if ((o1ClassIndex != 0)
				 && ((classAtIndex(o1ClassIndex)) != obj1)) {
					o1ClassIndex = 0;
				}
				o2Header = long64At(obj2);
				o2ClassIndex = (((usqInt)(obj2)) >> (identityHashFullWordShift())) & (identityHashHalfWordMask());
				if ((o2ClassIndex != 0)
				 && ((classAtIndex(o2ClassIndex)) != obj2)) {
					o2ClassIndex = 0;
				}
				if ((((				/* begin numSlotsOf: */
					assert((classIndexOf(obj1)) > (isForwardedObjectClassIndexPun())),
				(((numSlots21 = byteAt(obj1 + 7))) == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(obj1 - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots21))) == ((				/* begin numSlotsOf: */
					assert((classIndexOf(obj2)) > (isForwardedObjectClassIndexPun())),
				(((numSlots11 = byteAt(obj2 + 7))) == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(obj2 - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots11))))
				 && (((o1ClassIndex + o2ClassIndex) == 0)
				 && ((!(isCompiledMethodFormat((((usqLong)(o1Header)) >> (formatShift())) & (formatMask()))))
				 && (!(isCompiledMethodFormat((((usqLong)(o2Header)) >> (formatShift())) & (formatMask()))))))) {
					inPlaceBecomeandcopyHashFlag(obj1, obj2, copyHashFlag);
					goto l10;
				}
				outOfPlaceBecomeandcopyHashFlag(obj1, obj2, copyHashFlag);
				if (copyHashFlag) {
					goto l10;
				}
				if (o1ClassIndex != 0) {
					if (o2ClassIndex != 0) {
						classAtIndexput(o1ClassIndex, obj2);
						classAtIndexput(o2ClassIndex, obj1);
					}
					else {
						/* o2 wasn't in the table; set its hash */
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(obj1));
						referent3 = longAt((obj1 + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent3 & (tagMask()))))
						 && ((!((longAt(referent3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						newObj2 = referent3;
						assert((rawHashBitsOf(newObj2)) == 0);
						/* begin setHashBitsOf:to: */
						assert(((o1ClassIndex >= 0) && (o1ClassIndex <= (identityHashHalfWordMask()))));
						long32Atput(newObj2 + 4, ((((long32At(newObj2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + o1ClassIndex);
					}
				}
				else {
					if (o2ClassIndex != 0) {
						/* o1 wasn't in the table; set its hash */
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(obj2));
						referent11 = longAt((obj2 + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent11 & (tagMask()))))
						 && ((!((longAt(referent11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent11 = longAt((referent11 + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						newObj1 = referent11;
						assert((rawHashBitsOf(newObj1)) == 0);
						/* begin setHashBitsOf:to: */
						assert(((o2ClassIndex >= 0) && (o2ClassIndex <= (identityHashHalfWordMask()))));
						long32Atput(newObj1 + 4, ((((long32At(newObj1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + o2ClassIndex);
					}
				}
	l10:	/* end doBecome:and:copyHash: */;
				/* begin followField:ofObject: */
				objOop2 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop2 & (tagMask()))))
				 && ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(i, array1, objOop2);
				}
				/* begin followField:ofObject: */
				objOop3 = longAt((array2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop3 & (tagMask()))))
				 && ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(i, array2, objOop3);
				}
			}
		}
	}
	else {
		/* begin innerBecomeObjectsIn:to:copyHash: */
		for (i1 = 0, iLimiT1 = (((assert((classIndexOf(array1)) > (isForwardedObjectClassIndexPun())),
(((numSlots4 = byteAt(array1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(array1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots4))) - 1); i1 <= iLimiT1; i1 += 1) {
			/* At first blush it would appear unnecessary to use followField: here since
			   the validation in become:with:twoWay:copyHash: follows forwarders.  But
			   there's nothing to ensure all elements of each array is unique and doesn't
			   appear in the other array.  So the enumeration could encounter an object
			   already becommed earlier in the same enumeration. */
			/* begin followField:ofObject: */
			objOop4 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop4 & (tagMask()))))
			 && ((!((longAt(objOop4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				objOop4 = fixFollowedFieldofObjectwithInitialValue(i1, array1, objOop4);
			}
			obj11 = objOop4;
			/* begin followField:ofObject: */
			objOop11 = longAt((array2 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop11 & (tagMask()))))
			 && ((!((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				objOop11 = fixFollowedFieldofObjectwithInitialValue(i1, array2, objOop11);
			}
			obj21 = objOop11;
			if (obj11 != obj21) {
				/* begin doBecome:to:copyHash: */
				classIndex = isForwardedObjectClassIndexPun();
				assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
				assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
				longAtput(obj11, ((longAt(obj11)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (7U << (formatShift()))));
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(obj11, (longAt(obj11)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#        endif // IMMUTABILITY

				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(obj11));
				assert(!(isOopForwarded(obj21)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(obj11)),
				oopisGreaterThanOrEqualTo(obj11, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(obj21 & (tagMask()))))
					 && (oopisLessThan(obj21, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(obj11)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(obj11);
						}
					}
				}
				longAtput((obj11 + BaseHeaderSize) + (0U << (shiftForWord())), obj21);
				if ((byteAt(obj11 + 7)) == 0) {
					/* begin rawNumSlotsOf:put: */
					byteAtput(obj11 + 7, 1);
				}
				if (copyHashFlag) {
					hash = (long32At(obj11 + 4)) & (identityHashHalfWordMask());
					/* begin setHashBitsOf:to: */
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
					long32Atput(obj21 + 4, ((((long32At(obj21 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
				}
				if (((				/* begin isOldObject: */
					assert(isNonImmediate(obj11)),
				oopisGreaterThanOrEqualTo(obj11, GIV(oldSpaceStart))))
				 && (				/* begin isYoung: */
					((!(obj21 & (tagMask()))))
				 && (oopisLessThan(obj21, GIV(oldSpaceStart))))) {
					GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | OldBecameNewFlag;
				}
				assert(!((isOopForwarded(obj21))));
				/* begin followField:ofObject: */
				objOop21 = longAt((array1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop21 & (tagMask()))))
				 && ((!((longAt(objOop21)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop21 = fixFollowedFieldofObjectwithInitialValue(i1, array1, objOop21);
				}
				assert(!(isOopForwarded(obj21)));
			}
		}
	}
	/* begin followSpecialObjectsOop */
	if ((!((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		GIV(validatedIntegerClassFlags) = 0;
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(specialObjectsOop)));
		referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		GIV(specialObjectsOop) = referent;
	}
	followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
	/* begin postBecomeAction: */
	spurPostBecomeAction(GIV(becomeEffectsFlags));
	if (((GIV(becomeEffectsFlags) & BecameJittedCompiledMethodFlag) != 0)) {
		freeBecomeFlaggedMethods();
	}
	followMovableLiteralsAndUpdateYoungReferrers();
	/* begin nilUncoggableMethods */
	GIV(lastCoggableInterpretedBlockMethod) = (GIV(lastUncoggableInterpretedBlockMethod) = null);
	assert(kosherYoungReferrers());
	GIV(gcMode) = 0;
	postBecomeScanClassTable(GIV(becomeEffectsFlags));
	if (twoWayFlag) {
		assert(validPostBecomeArrayContents(array1));
		assert(validPostBecomeArrayContents(array2));
	}
	else {
		assert(validPostBecomeArrayContents(array2));
	}
	assert(validClassTableHashes());
	runLeakCheckerFor(GCModeBecome);
	/* begin zeroBecomeEffectFlagsOnSuccess */
	GIV(becomeEffectsFlags) = 0;
	return PrimNoErr;
}


/*	If this object is old, mark it as a root (because a new object
	may be stored into it). */

	/* SpurMemoryManager>>#beRootIfOld: */
void
beRootIfOld(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(oop)),
	oopisGreaterThanOrEqualTo(oop, GIV(oldSpaceStart)))) {
		/* No, oop is an old object */
		/* begin possibleRootStoreInto: */
		if (!(((((usqInt)((longAt(oop)))) >> (rememberedBitShift())) & 1) != 0)) {
			remember(oop);
		}
	}
}

	/* SpurMemoryManager>>#bitsSetInFreeSpaceMaskForAllFreeLists */
static sqInt
bitsSetInFreeSpaceMaskForAllFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	for (i = 0, iLimiT = (0x3F); i <= iLimiT; i += 1) {
		if (((GIV(freeLists)[i]) != 0)
		 && ((!((1ULL << i) & GIV(freeListsMask))))) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#bridgeSize */
static sqInt
bridgeSize(void)
{
	return 2 * BaseHeaderSize;
}

	/* SpurMemoryManager>>#byteFormatForNumBytes: */
static NoDbgRegParms sqInt
byteFormatForNumBytes(sqInt numBytes)
{
	return (firstByteFormat()) + ((8 - numBytes) & (BytesPerWord - 1));
}

	/* SpurMemoryManager>>#byteFormatMask */
static sqInt
byteFormatMask(void)
{
	return 24;
}

	/* SpurMemoryManager>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;

	if (((oop & (tagMask())) != 0)) {
		return 0;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	numBytes = (((numSlots = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {
		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
	}
	return numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
}


/*	Answer the basic element size for the receiver. Answer 0 for immediates
	and CompiledCode
	(element size could be wordSize for literals or 1 for bytes, so its
	indeterminable). Answer
	wordSize for pointer objects. Otherwise answer the actual element size of
	a bits container. */

	/* SpurMemoryManager>>#bytesPerElement: */
unsigned char
bytesPerElement(sqInt oop)
{
    unsigned char byteSizes[16] =
								   {	wordSize(),  wordSize(),  wordSize(),  wordSize(),
									wordSize(),  wordSize(),  wordSize(),  0, /* forwarder */ wordSize(),
									8,
									4, 4,
									2, 2, 2, 2 };
    sqInt fmt;

	if (((oop & (tagMask())) != 0)) {
		return 0;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			return 0;
		}
		return 1;
	}
	return byteSizes[fmt];
}


/*	Attempt to change the class of the receiver to the argument given that the
	format of the receiver matches the format of the argument. If successful,
	answer 0, otherwise answer an error code indicating the reason for
	failure. 
	Fail if the format of the receiver is incompatible with the format of the
	argument, or if the argument is a fixed class and the receiver's size
	differs from the size
	that an instance of the argument should have. */

	/* SpurMemoryManager>>#changeClassOf:to: */
static NoDbgRegParms sqInt
changeClassOfto(sqInt rcvr, sqInt argClass)
{
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hash;
    sqInt instBytes;
    sqInt instFormat;
    usqInt instSlots;
    sqInt newFormat;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;

	instBytes = 0;
	instSlots = 0;
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		return PrimErrNoModification;
	}
	classFormat = ((longAt((argClass + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	fixedFields = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
	classFormat = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	/* Fail for inability to access classIndex before making contexts snapshot-safe. */
	instFormat = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	if (((	/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(argClass)),
	flag("todo"),
	(((hash = (long32At(argClass + 4)) & (identityHashHalfWordMask()))) != 0
			? (classIndex = hash)
			: (objCouldBeClassObj(argClass)
					? (((err = enterIntoClassTable(argClass))) != 0
							? (classIndex = -err)
							: (classIndex = (long32At(argClass + 4)) & (identityHashHalfWordMask())))
					: (classIndex = -PrimErrBadReceiver))))) < 0) {
		return -classIndex;
	}
	if (classFormat <= 5 /* begin lastPointerFormat */) {
		if (instFormat > 5 /* begin lastPointerFormat */) {
			return PrimErrInappropriate;
		}
		if ((((		/* begin numSlotsOf: */
			assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(rcvr + 7))) == (numSlotsMask())
				? (instSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8)
				: (instSlots = numSlots)))) < fixedFields)
		 || ((instSlots > fixedFields)
		 && (		/* begin isFixedSizePointerFormat: */
			(classFormat <= 1 /* begin nonIndexablePointerFormat */)
		 || (classFormat == 5 /* begin ephemeronFormat */)))) {
			return PrimErrBadReceiver;
		}
		if ((instFormat == (indexablePointersFormat()))
		 && (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			makeContextSnapshotSafe(rcvr);
		}
		newFormat = classFormat;
	}
	else {
		/* Fail if the class's format is somehow invalid. */
		if (classFormat != (classFormatFromInstFormat(classFormat))) {
			return PrimErrBadArgument;
		}
		/* begin numBytesOf: */
		fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numBytes = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		numBytes = numBytes << (shiftForWord());
		if (fmt >= (firstByteFormat())) {
			/* bytes (the common case), including CompiledMethod */
			instBytes = numBytes - (fmt & 7);
			goto l1;
		}
		if (fmt <= (sixtyFourBitIndexableFormat())) {
			instBytes = numBytes;
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			instBytes = numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
			goto l1;
		}
		instBytes = numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
	l1:	/* end numBytesOf: */;
		switch (classFormat) {
		case sixtyFourBitIndexableFormat():
			if (((instBytes & 7) != 0)) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat;
			break;
		case firstLongFormat():
			if (((instBytes & 3) != 0)) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat + ((2 - (((usqInt)(instBytes)) >> 2)) & 1);
			break;
		case firstShortFormat():
			if (((instBytes & 1) != 0)) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat + ((4 - (((usqInt)(instBytes)) >> 1)) & 3);
			break;
		case firstByteFormat():
			newFormat = classFormat + ((8 - instBytes) & 7);
			break;
		case firstCompiledMethodFormat():
			if (classFormat != (firstCompiledMethodFormat())) {
				return PrimErrInappropriate;
			}
			newFormat = instFormat;
			break;
		default:
			/* bits instances cannot be adopted by pointer-like classes... */
			return PrimErrInappropriate;
		}
	}
	/* begin set:classIndexTo:formatTo: */
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((newFormat >= 0) && (newFormat <= (formatMask()))));
	longAtput(rcvr, ((longAt(rcvr)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (((sqInt)((usqInt)(newFormat) << (formatShift()))))));
	assert((numBytesOf(rcvr)) == ((classFormat <= (lastPointerFormat())
		? instSlots * BytesPerOop
		: instBytes)));
	return 0;
}

	/* SpurMemoryManager>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode)
{
	return (((sqInt)((usqInt)(characterCode) << (numTagBits())))) + (characterTag());
}


/*	Immediate characters are unsigned */

	/* SpurMemoryManager>>#characterValueOf: */
usqInt
characterValueOf(sqInt oop)
{
	return ((((usqInt)oop))) >> (numTagBits());
}

	/* SpurMemoryManager>>#cheapAddressCouldBeInHeap: */
static NoDbgRegParms sqInt
cheapAddressCouldBeInHeap(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & (BytesPerWord - 1)) == 0)
	 && ((oopisGreaterThanOrEqualTo(address, GIV(newSpaceStart)))
	 && (oopisLessThan(address, GIV(endOfMemory))));
}


/*	Assumes zero-based array indexing. */

	/* SpurMemoryManager>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isInMemory(byteAddress))) {
		warning("checkedLongAt bad address");
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return longAt(byteAddress);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleFreeSpace has set a bit at each free chunk's
	header. Scan all objects in the heap checking that no pointer points
	to a free chunk and that all free chunks that refer to others refer to
	marked chunks. Answer if all checks pass. */

	/* SpurMemoryManager>>#checkHeapFreeSpaceIntegrity */
static sqInt
checkHeapFreeSpaceIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fi;
    sqInt fieldOop;
    sqInt fiLimiT;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;
    usqInt total;

	obj = 0;
	ok = 1;
	total = 0;
	for (i = 0, iLimiT = (0x3F); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			if ((heapMapAtWord(pointerForOop(GIV(freeLists)[i]))) == 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"leak in free list ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)i));
				fprintf(GIV(transcript),
						"%s",
						" to non-free ");
				printHex(GIV(freeLists)[i]);
				eekcr();
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (((longAt(objOop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"young object ");
			printHex(objOop);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" is free");
			eekcr();
			ok = 0;
		}
		else {
			if (objOop != GIV(freeSpaceCheckOopToIgnore)) {
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					if ((!(fieldOop & (tagMask())))) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) != 0) {
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									"object leak in ");
							printHex(objOop);
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" @ ");
							fprintf(GIV(transcript),
									"%" PRIdSQINT "",
									((sqInt)fi));
							fprintf(GIV(transcript),
									"%s",
									" = ");
							printHex(fieldOop);
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" is free");
							eekcr();
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			if ((heapMapAtWord(pointerForOop(objOop1))) == 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"leak in free chunk ");
				printHex(objOop1);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" is unmapped?! ");
				eekcr();
				ok = 0;
			}
			fieldOop = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"leak in free chunk ");
				printHex(objOop1);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" @ 0 = ");
				printHex(fieldOop);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" is unmapped");
				eekcr();
				ok = 0;
			}
			if (!(isLilliputianSize(bytesInBody(objOop1)))) {
				fieldOop = longAt((objOop1 + BaseHeaderSize) + (1U << (shiftForWord())));
				if ((fieldOop != 0)
				 && ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"leak in free chunk ");
					printHex(objOop1);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" @ 0 = ");
					printHex(fieldOop);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" is unmapped");
					eekcr();
					ok = 0;
				}
			}
			if ((bytesInBody(objOop1)) >= (0x200)) {
				for (fi = 2 /* begin freeChunkParentIndex */, fiLimiT = 4 /* begin freeChunkLargerIndex */; fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"leak in free chunk ");
						printHex(objOop1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" @ ");
						fprintf(GIV(transcript),
								"%" PRIdSQINT "",
								((sqInt)fi));
						fprintf(GIV(transcript),
								"%s",
								" = ");
						printHex(fieldOop);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" is unmapped");
						eekcr();
						ok = 0;
					}
				}
			}
			total += bytesInBody(objOop1);
		}
		else {
			if (objOop1 != GIV(freeSpaceCheckOopToIgnore)) {
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop1)) - 1); fi <= fiLimiT; fi += 1) {
					if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						assert(fi == 0);
						fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					}
					else {
						/* We keep #fetchPointer:ofObject: API here for assertions */
						fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					}
					if ((!(fieldOop & (tagMask())))) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) != 0) {
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									"object leak in ");
							printHex(objOop1);
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" @ ");
							fprintf(GIV(transcript),
									"%" PRIdSQINT "",
									((sqInt)fi));
							fprintf(GIV(transcript),
									"%s",
									" = ");
							printHex(fieldOop);
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" is free");
							eekcr();
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
	}
	if (total != GIV(totalFreeOldSpace)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"incorrect totalFreeOldSpace; expected ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)GIV(totalFreeOldSpace)));
		fprintf(GIV(transcript),
				"%s",
				" found ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)total));
		eekcr();
		ok = 0;
	}
	return ok;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each (non-free)
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rememberedSet, remapBuffer and
	extraRootTable checking
	that every entry is a pointer to a header. Check that the number of roots
	is correct and that all
	rememberedSet entries have their isRemembered: flag set. Answer if all
	checks pass. */

	/* SpurMemoryManager>>#checkHeapIntegrity:classIndicesShouldBeValid: */
static NoDbgRegParms sqInt
checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt classOop;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt containsYoung;
    sqInt fi;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex11;
    sqInt fieldIndex2;
    sqInt fieldOop;
    sqInt fiLimiT;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt freeListOop;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    sqInt n;
    sqInt numOnThisPage;
    sqInt numRememberedObjectsInHeap;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objStackPage;
    sqInt ok;
    sqInt page;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ri;
    char *s;
    char *s1;
    usqInt start;

	obj = 0;
	page = 0;
	ok = 1;
	numRememberedObjectsInHeap = 0;
	for (i = 0, iLimiT = (0x3F); i <= iLimiT; i += 1) {
		if (((freeListOop = GIV(freeLists)[i])) != 0) {
			if (oopisGreaterThanOrEqualToandLessThan(freeListOop, GIV(oldSpaceStart), GIV(endOfMemory))) {
				if ((heapMapAtWord(pointerForOop(freeListOop))) != 0) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"leak in free list ");
					fprintf(GIV(transcript),
							"%" PRIdSQINT "",
							((sqInt)i));
					fprintf(GIV(transcript),
							"%s",
							" to non-free ");
					printHex(freeListOop);
					eekcr();
					ok = 0;
				}
			}
			else {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"leak in free list ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)i));
				fprintf(GIV(transcript),
						"%s",
						" to out-of-bounds ");
				printHex(freeListOop);
				eekcr();
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l5;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (((longAt(objOop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"young object ");
			printHex(objOop);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" is free");
			eekcr();
			ok = 0;
		}
		else {
			if (!((!(((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0))
				 && (excludeUnmarkedObjs))) {
				if (((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"young object ");
					printHex(objOop);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" is remembered");
					eekcr();
					ok = 0;
				}
			}
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				fieldOop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
				if (				/* begin isInHeapBounds: */
					(oopisGreaterThanOrEqualTo(fieldOop, minCogMethodAddress()))
				 && (oopisLessThan(fieldOop, GIV(endOfMemory)))) {
					if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"object leak in forwarder ");
						printHex(objOop);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" to unmapped ");
						printHex(fieldOop);
						eekcr();
						ok = 0;
					}
				}
				else {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"object leak in forwarder ");
					printHex(objOop);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" to out-of-bounds ");
					printHex(fieldOop);
					eekcr();
					ok = 0;
				}
			}
			else {
				classIndex1 = (classIndex = (longAt(objOop)) & (classIndexMask()));
				/* begin classOrNilAtIndex: */
				assert((classIndex1 <= (tagMask()))
				 || (classIndex1 >= (arrayClassIndexPun())));
				fieldIndex = ((usqInt)(classIndex1)) >> (classTableMajorIndexShift());
				/* begin fetchPointer:ofObject: */
				classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
				if (classTablePage == GIV(nilObj)) {
					classOop = GIV(nilObj);
					goto l2;
				}
				fieldIndex1 = classIndex1 & ((1U << (classTableMajorIndexShift())) - 1);
				classOop = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l2:	/* end classOrNilAtIndex: */;
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(((longAt(objOop)) & (classIndexMask())) <= (lastClassIndexPun()))))) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"object leak in ");
					printHex(objOop);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" invalid class index ");
					printHex(classIndex);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" -> ");
					s = (classOop == null
						? "nil"
						: "nilObj");
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							s);
					eekcr();
					ok = 0;
				}
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					if ((!(fieldOop & (tagMask())))) {
						if (						/* begin isInHeapBounds: */
							(oopisGreaterThanOrEqualTo(fieldOop, minCogMethodAddress()))
						 && (oopisLessThan(fieldOop, GIV(endOfMemory)))) {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								/* begin print: */
								fprintf(GIV(transcript),
										"%s",
										"object leak in ");
								printHex(objOop);
								/* begin print: */
								fprintf(GIV(transcript),
										"%s",
										" @ ");
								fprintf(GIV(transcript),
										"%" PRIdSQINT "",
										((sqInt)fi));
								fprintf(GIV(transcript),
										"%s",
										" = ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
						}
						else {
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									"object leak in ");
							printHex(objOop);
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" to out-of-bounds ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l4;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l4:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l5:	/* end allNewSpaceEntitiesDo: */;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			if ((heapMapAtWord(pointerForOop(objOop1))) != 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"leak in free chunk ");
				printHex(objOop1);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" is mapped?! ");
				eekcr();
				ok = 0;
			}
			fieldOop = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"leak in free chunk ");
				printHex(objOop1);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" @ 0 = ");
				printHex(fieldOop);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" is mapped");
				eekcr();
				ok = 0;
			}
			if (!(isLilliputianSize(bytesInBody(objOop1)))) {
				fieldOop = longAt((objOop1 + BaseHeaderSize) + (1U << (shiftForWord())));
				if ((fieldOop != 0)
				 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"leak in free chunk ");
					printHex(objOop1);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" @ 1 = ");
					printHex(fieldOop);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" is mapped");
					eekcr();
					ok = 0;
				}
			}
			if ((bytesInBody(objOop1)) >= (0x200)) {
				for (fi = 2 /* begin freeChunkParentIndex */, fiLimiT = 4 /* begin freeChunkLargerIndex */; fi <= fiLimiT; fi += 1) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"leak in free chunk ");
						printHex(objOop1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" @ ");
						fprintf(GIV(transcript),
								"%" PRIdSQINT "",
								((sqInt)fi));
						fprintf(GIV(transcript),
								"%s",
								" = ");
						printHex(fieldOop);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" is mapped");
						eekcr();
						ok = 0;
					}
				}
			}
		}
		else {
			if (!(excludeUnmarkedObjs
				 && (!(((((usqInt)((longAt(objOop1)))) >> (markedBitFullShift())) & 1) != 0)))) {
				containsYoung = 0;
				if (((((usqInt)((longAt(objOop1)))) >> (rememberedBitShift())) & 1) != 0) {
					numRememberedObjectsInHeap += 1;
					if (!(isInRememberedSet(objOop1))) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"remembered object ");
						printHex(objOop1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" is not in remembered table");
						eekcr();
						ok = 0;
					}
				}
				if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					fieldOop = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
					if (					/* begin isInHeapBounds: */
						(oopisGreaterThanOrEqualTo(fieldOop, minCogMethodAddress()))
					 && (oopisLessThan(fieldOop, GIV(endOfMemory)))) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									"object leak in forwarder ");
							printHex(objOop1);
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" to unmapped ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
					}
					else {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"object leak in forwarder ");
						printHex(objOop1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" to out-of-bounds ");
						printHex(fieldOop);
						eekcr();
						ok = 0;
					}
					if (					/* begin isReallyYoung: */
						((!(fieldOop & (tagMask()))))
					 && ((assert(isNonImmediate(fieldOop)),
					(oopisLessThan(fieldOop, GIV(oldSpaceStart)))
						 && (oopisGreaterThanOrEqualTo(fieldOop, GIV(newSpaceStart)))))) {
						containsYoung = 1;
					}
				}
				else {
					classIndex2 = (classIndex = (longAt(objOop1)) & (classIndexMask()));
					/* begin classOrNilAtIndex: */
					assert((classIndex2 <= (tagMask()))
					 || (classIndex2 >= (arrayClassIndexPun())));
					fieldIndex2 = ((usqInt)(classIndex2)) >> (classTableMajorIndexShift());
					/* begin fetchPointer:ofObject: */
					classTablePage1 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex2) << (shiftForWord())))));
					if (classTablePage1 == GIV(nilObj)) {
						classOop = GIV(nilObj);
						goto l7;
					}
					fieldIndex11 = classIndex2 & ((1U << (classTableMajorIndexShift())) - 1);
					classOop = longAt((classTablePage1 + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex11) << (shiftForWord())))));
	l7:	/* end classOrNilAtIndex: */;
					if (classIndicesShouldBeValid
					 && ((classOop == GIV(nilObj))
					 && (classIndex > (lastClassIndexPun())))) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"object leak in ");
						printHex(objOop1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" invalid class index ");
						printHex(classIndex);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" -> ");
						s1 = (classOop == null
							? "nil"
							: "nilObj");
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								s1);
						eekcr();
						ok = 0;
					}
					for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop1)) - 1); fi <= fiLimiT; fi += 1) {
						fieldOop = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(fi) << (shiftForWord())))));
						if ((!(fieldOop & (tagMask())))) {
							if (							/* begin isInHeapBounds: */
								(oopisGreaterThanOrEqualTo(fieldOop, minCogMethodAddress()))
							 && (oopisLessThan(fieldOop, GIV(endOfMemory)))) {
								if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
									/* begin print: */
									fprintf(GIV(transcript),
											"%s",
											"object leak in ");
									printHex(objOop1);
									/* begin print: */
									fprintf(GIV(transcript),
											"%s",
											" @ ");
									fprintf(GIV(transcript),
											"%" PRIdSQINT "",
											((sqInt)fi));
									fprintf(GIV(transcript),
											"%s",
											" = ");
									printHex(fieldOop);
									eekcr();
									ok = 0;
								}
							}
							else {
								/* begin print: */
								fprintf(GIV(transcript),
										"%s",
										"object leak in ");
								printHex(objOop1);
								/* begin print: */
								fprintf(GIV(transcript),
										"%s",
										" to out-of-bounds ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
							if (							/* begin isReallyYoung: */
								((!(fieldOop & (tagMask()))))
							 && ((assert(isNonImmediate(fieldOop)),
							(oopisLessThan(fieldOop, GIV(oldSpaceStart)))
								 && (oopisGreaterThanOrEqualTo(fieldOop, GIV(newSpaceStart)))))) {
								containsYoung = 1;
							}
						}
					}
				}
				if (containsYoung) {
					if (!(((((usqInt)((longAt(objOop1)))) >> (rememberedBitShift())) & 1) != 0)) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"unremembered object ");
						printHex(objOop1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" contains young oop(s)");
						eekcr();
						ok = 0;
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l9;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l9:	/* end objectAfter:limit: */;
	}
	if (numRememberedObjectsInHeap != (rememberedSetSize())) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"root count mismatch. #heap roots ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)numRememberedObjectsInHeap));
		fprintf(GIV(transcript),
				"%s",
				"; #roots ");
		n = rememberedSetSize();
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
		eekcr();
		flag("no support for remembered set overflow yet");
	}
	/* begin rememberedSetWithIndexDo: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		obj1 = GIV(rememberedSet)[i1];
		if ((obj1 & (BytesPerWord - 1)) != 0) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"misaligned oop in remembered set @ ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)i1));
			fprintf(GIV(transcript),
					"%s",
					" = ");
			printHex(obj1);
			eekcr();
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj1))) == 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"object leak in remembered set @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)i1));
				fprintf(GIV(transcript),
						"%s",
						" = ");
				printHex(obj1);
				eekcr();
				ok = 0;
			}
			else {
				if (				/* begin isYoung: */
					((!(obj1 & (tagMask()))))
				 && (oopisLessThan(obj1, GIV(oldSpaceStart)))) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"non-root in remembered set @ ");
					fprintf(GIV(transcript),
							"%" PRIdSQINT "",
							((sqInt)i1));
					fprintf(GIV(transcript),
							"%s",
							" = ");
					printHex(obj1);
					eekcr();
					ok = 0;
				}
			}
		}
	}
	/* begin objStack:do: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l8;
	}
	eassert(isValidObjStack(GIV(mournQueue)));
	objStackPage = GIV(mournQueue);
	while (objStackPage != 0) {
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
		for (i2 = ((numOnThisPage + ObjStackFixedSlots) - 1); i2 >= ObjStackFixedSlots; i2 += -1) {
			obj = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord())))));
			if ((obj & (BytesPerWord - 1)) != 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"misaligned oop in mournQueue @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)i2));
				fprintf(GIV(transcript),
						"%s",
						" in ");
				printHex(objStackPage);
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
			else {
				if (!(excludeUnmarkedObjs
					 && (!(((((usqInt)((longAt(obj)))) >> (markedBitFullShift())) & 1) != 0)))) {
					if ((heapMapAtWord(pointerForOop(obj))) == 0) {
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								"object leak in mournQueue @ ");
						fprintf(GIV(transcript),
								"%" PRIdSQINT "",
								((sqInt)i2));
						fprintf(GIV(transcript),
								"%s",
								" in ");
						printHex(objStackPage);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" = ");
						printHex(obj);
						eekcr();
						ok = 0;
					}
				}
			}
		}
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	}
	l8:	/* end objStack:do: */;
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"misaligned remapRoot @ ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)ri));
			fprintf(GIV(transcript),
					"%s",
					" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"object leak in remapRoots @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)ri));
				fprintf(GIV(transcript),
						"%s",
						" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"misaligned extraRoot @ ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)ri));
			fprintf(GIV(transcript),
					"%s",
					" => ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"object leak in extraRoots @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)ri));
				fprintf(GIV(transcript),
						"%s",
						" => ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */
/*	useful for debugging */

	/* SpurMemoryManager>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	if (((oop & (tagMask())) != 0)) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & (classIndexMask()))) >= (firstClassIndexPun()))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if ((fmt == 6) || (fmt == 8)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has an unknown format type");
		return 0;
	}
	if ((fmt == 7 /* begin forwardedFormat */) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (0x400000) | (0x40000000000000LL);
	if (((long64At(oop)) & unusedBits) != 0) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has some unused header bits set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = (1U << (greyBitShift())) | ((1U << (pinnedBitShift())) | (1U << (rememberedBitShift())));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has some header bits unused in young objects set; should be zero");
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */
/*	useful for debugging */

	/* SpurMemoryManager>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt objClass;
    sqInt objFormat;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) (fetchClassOfNonImm(obj)));
	if (((objClass & (tagMask())) != 0)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" an immediate is not a valid class or behavior");
		cr();
		return 0;
	}
	if (!(okayOop(objClass))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" class obj is not ok");
		cr();
		return 0;
	}
	if (!((((((usqInt)((longAt(objClass)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
		 && (((		/* begin numSlotsOf: */
			assert((classIndexOf(objClass)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(objClass + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(objClass - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) >= 3))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" a class (behavior) must be a pointers object of size >= 3");
		cr();
		return 0;
	}
	objFormat = (	/* begin isBytes: */
		((!(obj & (tagMask()))))
	 && (((((usqInt)((longAt(obj)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))
		? ((((((usqInt)((longAt(obj)))) >> (formatShift())) & (formatMask())) | 7) - 7)
		: (((usqInt)((longAt(obj)))) >> (formatShift())) & (formatMask()));
	if (((((usqInt)((((longAt((objClass + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask())) != objFormat) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" and its class (behavior) formats differ");
		cr();
		return 0;
	}
	return 1;
}

	/* SpurMemoryManager>>#checkOopIntegrity:named: */
static NoDbgRegParms sqInt
checkOopIntegritynamed(sqInt obj, char *name)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((oopisLessThan(obj, GIV(endOfMemory)))
	 && ((heapMapAtWord(pointerForOop(obj))) != 0)) {
		return 1;
	}
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			name);
	fprintf(GIV(transcript),
			"%s",
			" leak ");
	printHex(obj);
	eekcr();
	return 0;
}

	/* SpurMemoryManager>>#checkOopIntegrity:named:index: */
static NoDbgRegParms sqInt
checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((oopisLessThan(obj, GIV(endOfMemory)))
	 && ((heapMapAtWord(pointerForOop(obj))) != 0)) {
		return 1;
	}
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			name);
	fprintf(GIV(transcript),
			"%s",
			" leak @ ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)i));
	fprintf(GIV(transcript),
			"%s",
			" = ");
	printHex(obj);
	eekcr();
	return 0;
}

	/* SpurMemoryManager>>#classAlien */
sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classArray */
sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classAtIndex: */
sqInt
classAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask()))
	 || ((classIndex >= (arrayClassIndexPun()))
	 && (classIndex <= (classIndexMask())))));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin fetchPointer:ofObject: */
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
}


/*	for become & GC of classes */

	/* SpurMemoryManager>>#classAtIndex:put: */
static NoDbgRegParms sqInt
classAtIndexput(sqInt classIndex, sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	assert((objOop == GIV(nilObj))
	 || ((((rawHashBitsOf(objOop)) == classIndex)
	 || ((classAtIndex(rawHashBitsOf(objOop))) == objOop))
	 && (objCouldBeClassObj(objOop))));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		error("attempt to add class to empty page");
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(classTablePage)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(classTablePage)),
	oopisGreaterThanOrEqualTo(classTablePage, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(objOop & (tagMask()))))
		 && (oopisLessThan(objOop, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(classTablePage)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(classTablePage);
			}
		}
	}
	return longAtput((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))), objOop);
}

	/* SpurMemoryManager>>#classBitmap */
sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassBitmap) << (shiftForWord())))));
}


/*	a.k.a. self fetchPointer: ClassByteArrayCompactIndex ofObject:
	classTableFirstPage 
 */

	/* SpurMemoryManager>>#classByteArray */
sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteArray) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classCharacter */
sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassCharacter) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classDoubleByteArray */
sqInt
classDoubleByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;


	/* begin accessIntegerClass:withValidationFlag: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassDoubleByteArray) << (shiftForWord())))));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassDoubleByteArrayFlag) != 0)) {
		return classOop;
	}
	if ((((classOop & (tagMask())) != 0))
	 || ((((hash = (long32At(classOop + 4)) & (identityHashHalfWordMask()))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassDoubleByteArrayFlag;
	return classOop;
}

	/* SpurMemoryManager>>#classDoubleWordArray */
sqInt
classDoubleWordArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;


	/* begin accessIntegerClass:withValidationFlag: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassDoubleWordArray) << (shiftForWord())))));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassDoubleWordArrayFlag) != 0)) {
		return classOop;
	}
	if ((((classOop & (tagMask())) != 0))
	 || ((((hash = (long32At(classOop + 4)) & (identityHashHalfWordMask()))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassDoubleWordArrayFlag;
	return classOop;
}

	/* SpurMemoryManager>>#classExternalAddress */
sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalAddress) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classExternalData */
sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalData) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classExternalFunction */
sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalFunction) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classExternalLibrary */
sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalLibrary) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classExternalStructure */
sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassExternalStructure) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classFloat */
sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassFloat) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classFloat32Array */
sqInt
classFloat32Array(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}

	/* SpurMemoryManager>>#classFloat64Array */
sqInt
classFloat64Array(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	No need to check this; classAtIndex: has a stricter assert:
	self assert: classIndex ~= self isForwardedObjectClassIndexPun. */

	/* SpurMemoryManager>>#classForClassTag: */
static NoDbgRegParms sqInt
classForClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;


	/* begin classAtIndex: */
	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask()))
	 || ((classIndex >= (arrayClassIndexPun()))
	 && (classIndex <= (classIndexMask())))));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin fetchPointer:ofObject: */
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable
	12 - 15 16-bit indexable
	16 - 23 byte indexable
	24 - 31 compiled method */

	/* SpurMemoryManager>>#classFormatFromInstFormat: */
static NoDbgRegParms sqInt
classFormatFromInstFormat(sqInt instFormat)
{
	if (instFormat >= (firstByteFormat())) {
		/* this is likely the common case */
		return instFormat & -8;
	}
	if (instFormat <= (sixtyFourBitIndexableFormat())) {
		return instFormat;
	}
	if (instFormat < (firstShortFormat())) {
		return instFormat & -2;
	}
	return instFormat & -4;
}


/*	22-bit class mask => ~ 4M classes */

	/* SpurMemoryManager>>#classIndexFieldWidth */
static sqInt
classIndexFieldWidth(void)
{
	return 22;
}


/*	Answer objOop's classIndex from the object header.
	A note on performance:
	This routine uses longAt:, which does a 32-bit load on the 32-bit system,
	and a 64-bit load
	on the 64-bit system. Since the only 64-bit implementation(s) is/are
	little-endian, and
	since all of isGrey,isPinned,isRemembered,format,isUmmutable and
	classIndex fit within
	the least significant 32-bits we could use long32At: to access these, in
	the hope that the
	32-bit access will be quicker on 64-bits by virtue of fetching half the
	bits. But experiments
	show that doing this does not produce any increase; at least any signal is
	lost in the noise. */

	/* SpurMemoryManager>>#classIndexOf: */
sqInt
classIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & (classIndexMask());
}

	/* SpurMemoryManager>>#classLargeNegativeInteger */
sqInt
classLargeNegativeInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (		/* begin knownClassAtIndex: */
			assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize())))),
		longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargeNegativeIntegerCompactIndex) << (shiftForWord()))))));
}

	/* SpurMemoryManager>>#classLargePositiveInteger */
sqInt
classLargePositiveInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (		/* begin knownClassAtIndex: */
			assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize())))),
		longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassLargePositiveIntegerCompactIndex) << (shiftForWord()))))));
}

	/* SpurMemoryManager>>#classOrNilAtIndex: */
sqInt
classOrNilAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin fetchPointer:ofObject: */
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classPoint */
sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classSemaphore */
sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classSmallInteger */
sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSmallInteger) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classString */
sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord())))));
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTableMinorIndexMask */

	/* SpurMemoryManager>>#classTableMinorIndexMask */
sqInt
classTableMinorIndexMask(void)
{
	return (1U << (classTableMajorIndexShift())) - 1;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTablePageSize */

	/* SpurMemoryManager>>#classTablePageSize */
sqInt
classTablePageSize(void)
{
	return 1U << (classTableMajorIndexShift());
}


/*	For Cogit & bootstrap */

	/* SpurMemoryManager>>#classTableRootObj */
sqInt
classTableRootObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	Answer the number of slots for class table pages in the hidden root
	object. 
 */

	/* SpurMemoryManager>>#classTableRootSlots */
static sqInt
classTableRootSlots(void)
{
	return 1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift()));
}


/*	Answer the classObj's identityHash to use as a tag in the first-level
	method lookup cache.
 */

	/* SpurMemoryManager>>#classTagForClass: */
sqInt
classTagForClass(sqInt classObj)
{
    sqInt err;
    sqInt hash;

	return (		/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(classObj)),
		flag("todo"),
		(((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
				? hash
				: (objCouldBeClassObj(classObj)
						? (((err = enterIntoClassTable(classObj))) != 0
								? -err
								: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
						: -PrimErrBadReceiver)));
}

	/* SpurMemoryManager>>#classUnsafeAlien */
sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassUnsafeAlien) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#classWordArray */
sqInt
classWordArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;


	/* begin accessIntegerClass:withValidationFlag: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassWordArray) << (shiftForWord())))));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassWordArrayFlag) != 0)) {
		return classOop;
	}
	if ((((classOop & (tagMask())) != 0))
	 || ((((hash = (long32At(classOop + 4)) & (identityHashHalfWordMask()))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassWordArrayFlag;
	return classOop;
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each free
	chunk's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleFreeSpace */
static void
clearLeakMapAndMapAccessibleFreeSpace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;

	objOop = 0;
	clearHeapMap();
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			heapMapAtWordPut(pointerForOop(objOop1), 1);
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
}

	/* SpurMemoryManager>>#cloneInOldSpace:forPinning: */
static NoDbgRegParms sqInt
cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cogMethodOrMethodHeader;
    sqInt fmt;
    sqInt hash;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt rawHeader;
    sqInt referent;


	/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	if (forPinning) {
		newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, 
		/* begin objectBytesForSlots: */
(numSlots == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), fmt, (longAt(objOop)) & (classIndexMask()));
	}
	else {
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, 
		/* begin objectBytesForSlots: */
(numSlots == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), fmt, (longAt(objOop)) & (classIndexMask()));
	}
	if (!newObj) {
		return 0;
	}
	if (fmt <= 5 /* begin lastPointerFormat */) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (((!(oop & (tagMask()))))
			 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(oop));
				referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent & (tagMask()))))
				 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				oop = referent;
			}
			if (((!(oop & (tagMask()))))
			 && ((			/* begin isYoungObject: */
				assert(isNonImmediate(oop)),
			oopisLessThan(oop, GIV(oldSpaceStart))))) {
				hasYoung = 1;
			}
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(newObj)));
			longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), oop);
		}
		if (hasYoung) {
			remember(newObj);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(newObj)));
			longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
		}
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin maybeFixClonedCompiledMethod: */
			assert(isOopCompiledMethod(newObj));
			rawHeader = longAt((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			if ((			/* begin isCogMethodReference: */
				assert(((((rawHeader) & 7) == 1))
				 || (((((usqInt)rawHeader)) < (startOfMemory()))
				 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
			/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))) {
				cogMethodOrMethodHeader = ((((CogMethod *) rawHeader))->methodHeader);
				/* begin rawHeaderOf:put: */
				assert(isCompiledMethodHeader(headerWhileForwardingOf(newObj)));
				assert(!(isOopForwarded(newObj)));
				longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))), cogMethodOrMethodHeader);
			}
			if (((			/* begin isYoungObject: */
				assert(isNonImmediate(objOop)),
			oopisLessThan(objOop, GIV(oldSpaceStart))))
			 || (((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(newObj);
			}
		}
	}
	if (((hash = (long32At(objOop + 4)) & (identityHashHalfWordMask()))) != 0) {
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(newObj + 4, ((((long32At(newObj + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(objOop)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin setIsImmutableOf:to: */
		longAtput(newObj, (longAt(newObj)) | (1U << (immutableBitShift())));
	}
	return newObj;
}

	/* SpurMemoryManager>>#cloneObject: */
sqInt
cloneObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt cogMethodOrMethodHeader;
    sqInt fmt;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt rawHeader;
    sqInt referent;


	/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	if (numSlots > ((1U << (fixedFieldsFieldWidth())) - 1)) {
		classIndex = (longAt(objOop)) & (classIndexMask());
		/* begin allocateSlotsInOldSpace:format:classIndex: */
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
			? 8 /* begin allocationUnit */ + BaseHeaderSize
			: (numSlots << (shiftForWord())) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), fmt, classIndex);
	}
	else {
		classIndex1 = (longAt(objOop)) & (classIndexMask());
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if (((numSlots) >> 56) > 0) {
				newObj = null;
				goto l2;
			}
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, fmt, classIndex1);
			goto l2;
		}
		if (numSlots >= (numSlotsMask())) {
			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
			longAtput(newObj1, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(fmt) << (formatShift()))))) + classIndex1);
		}
		else {
			longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(fmt) << (formatShift()))))) + classIndex1);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l2:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		if (fmt <= 5 /* begin lastPointerFormat */) {
			hasYoung = 0;
			for (i = 0; i < numSlots; i += 1) {
				oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
				if ((!(oop & (tagMask())))) {
					if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(oop));
						referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent & (tagMask()))))
						 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						oop = referent;
					}
					if (((!(oop & (tagMask()))))
					 && ((					/* begin isYoungObject: */
						assert(isNonImmediate(oop)),
					oopisLessThan(oop, GIV(oldSpaceStart))))) {
						hasYoung = 1;
					}
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newObj)));
				longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), oop);
			}
			if (hasYoung
			 && (!((			/* begin isYoungObject: */
				assert(isNonImmediate(newObj)),
			oopisLessThan(newObj, GIV(oldSpaceStart)))))) {
				remember(newObj);
			}
		}
		else {
			for (i = 0; i < numSlots; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(newObj)));
				longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
			}
			if (fmt >= (firstCompiledMethodFormat())) {
				/* begin maybeFixClonedCompiledMethod: */
				assert(isOopCompiledMethod(newObj));
				rawHeader = longAt((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
				if ((				/* begin isCogMethodReference: */
					assert(((((rawHeader) & 7) == 1))
					 || (((((usqInt)rawHeader)) < (startOfMemory()))
					 && ((((usqInt)rawHeader)) >= (minCogMethodAddress())))),
				/* begin isNonIntegerObject: */
(!(rawHeader & (smallIntegerTag()))))) {
					cogMethodOrMethodHeader = ((((CogMethod *) rawHeader))->methodHeader);
					/* begin rawHeaderOf:put: */
					assert(isCompiledMethodHeader(headerWhileForwardingOf(newObj)));
					assert(!(isOopForwarded(newObj)));
					longAtput((newObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))), cogMethodOrMethodHeader);
				}
				if (((				/* begin isOldObject: */
					assert(isNonImmediate(newObj)),
				oopisGreaterThanOrEqualTo(newObj, GIV(oldSpaceStart))))
				 && (((				/* begin isYoungObject: */
					assert(isNonImmediate(objOop)),
				oopisLessThan(objOop, GIV(oldSpaceStart))))
				 || (((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0))) {
					remember(newObj);
				}
			}
		}
	}
	return newObj;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Copy objOop into the segment beginning at segAddr, and forward it to the
	copy, saving its first field in savedFirstField, and setting its marked
	bit to indicate it has
	been copied. If it is a class in the class table, set the copy's hash to 0
	for reassignment
	on load, and mark it as a class by setting its isRemembered bit.
	Answer the next segmentAddr if successful. Answer an appropriate error
	code if not */
/*	Copy the object... */

	/* SpurMemoryManager>>#copyObj:toAddr:stopAt:savedFirstFields:index: */
static NoDbgRegParms usqInt
copyObjtoAddrstopAtsavedFirstFieldsindex(sqInt objOop, sqInt segAddr, sqInt endSeg, sqInt savedFirstFields, sqInt i)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bodySize;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt copy;
    sqInt fmt;
    sqInt hash;
    sqInt header;
    sqInt header1;
    sqInt i1;
    sqInt iLimiT;
    sqInt methodHeader;
    sqInt numLiterals;
    usqInt numMediatedSlots;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt oop;
    sqInt sp;

	assert(!((isCopiedIntoSegment(objOop))));
	bodySize = bytesInBody(objOop);
	if (oopisGreaterThanOrEqualTo(segAddr + bodySize, endSeg)) {
		return PrimErrWritePastObject;
	}
	memcpy(((void *)segAddr), ((void *)(/* begin startOfObject: */
	((byteAt(objOop + 7)) == (numSlotsMask())
	? objOop - BaseHeaderSize
	: objOop))), bodySize);
	numSlots = byteAt(segAddr + 7);
	copy = (numSlots == (numSlotsMask())
		? segAddr + BaseHeaderSize
		: segAddr);
	/* begin setIsRememberedOf:to: */
	longAtput(copy, (longAt(copy)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(copy)));
	longAtput(copy, (longAt(copy)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
	/* begin ifAProxy:updateCopy: */
	if (	/* begin isContext: */
		((!(objOop & (tagMask()))))
	 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		if (((((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
			/* Since the context is here via objectsReachableFromRoots: we know it cannot be divorced.
			   I'd like to assert coInterpreter checkIsStillMarriedContext: objOop currentFP: framePointer,
			   here but that requires access to framePointer. */
			/* begin numSlotsOfMarriedContext: */
			contextSize = stackPointerIndexForFrame(frameOfMarriedContext(objOop));
			numMediatedSlots = CtxtTempFrameStart + contextSize;
			for (i1 = 0; i1 < numMediatedSlots; i1 += 1) {
				oop = fetchPointerofMarriedContext(i1, objOop);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(copy)));
				longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), oop);
			}
		}
		else {
			/* begin numPointerSlotsOf: */
			fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
			if (fmt <= 5 /* begin lastPointerFormat */) {
				if ((fmt == (indexablePointersFormat()))
				 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((((sp) & 7) == 1))) {
						contextSize1 = 0;
						goto l3;
					}
					assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
					contextSize1 = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
					numMediatedSlots = CtxtTempFrameStart + contextSize1;
					goto l4;
				}
				/* begin numSlotsOf: */
				assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
				if (((numSlots1 = byteAt(objOop + 7))) == (numSlotsMask())) {
					/* overflow slots; at least (2^32)-1 slots, which is plenty */
					numMediatedSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8;
				}
				else {
					numMediatedSlots = numSlots1;
				}
				goto l4;
			}
			if (fmt == 7 /* begin forwardedFormat */) {
				numMediatedSlots = 1;
				goto l4;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				numMediatedSlots = 0;
				goto l4;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objOop));
			header1 = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			header = ((((header1) & 7) == 1)
				? header1
				: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
					assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
					((((CogMethod *) header1))->methodHeader)));
			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			numMediatedSlots = numLiterals + LiteralStart;
	l4:	/* end numPointerSlotsOf: */;
		}
		for (i1 = numMediatedSlots, iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) - 1); i1 <= iLimiT; i1 += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(copy)));
			longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), GIV(nilObj));
		}
	}
	if (((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		methodHeader = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(copy)));
			longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))), ((((CogMethod *) methodHeader))->methodHeader));
		}
	}
	hash = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	if ((hash > (lastClassIndexPun()))
	 && ((classOrNilAtIndex(hash)) == objOop)) {
		/* begin setHashBitsOf:to: */
		assert(((0 >= 0) && (0 <= (identityHashHalfWordMask()))));
		long32Atput(copy + 4, ((((long32At(copy + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))));
		/* begin setIsRememberedOf:to: */
		longAtput(copy, (longAt(copy)) | (1U << (rememberedBitShift())));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(savedFirstFields)));
	longAtput((savedFirstFields + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord()))));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(objOop)));
	longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord())), copy);
	/* begin markAsCopiedIntoSegment: */
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift())));
	return segAddr + bodySize;
}


/*	print the count of marked and unmarked objects.
	In addition if 1 is set in printFlags, short-print marked objects,
	and/or if 2 is set, short-print unmarked obejcts. */
/*	useful for debugging */

	/* SpurMemoryManager>>#countMarkedAndUnmarkdObjects: */
void
countMarkedAndUnmarkdObjects(sqInt printFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt nm;
    sqInt nu;
    usqInt numSlots;
    sqInt o;
    sqInt obj;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	o = 0;
	nm = (nu = 0);
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (((((usqInt)((longAt(obj)))) >> (markedBitFullShift())) & 1) != 0) {
				nm += 1;
				if (((printFlags & 1) != 0)) {
					shortPrintOop(obj);
				}
			}
			else {
				nu += 1;
				if (((printFlags & 2) != 0)) {
					shortPrintOop(obj);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"n marked: ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)nm));
	cr();
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"n unmarked: ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)nu));
	cr();
}


/*	Compute the current allocated bytes since last set.
	This is the cumulative total in statAllocatedBytes plus the allocation
	since the last scavenge. */
/*	Slang infers the type of the difference between two unsigned variables as
	signed. In this case we want it to be unsigned. */

	/* SpurMemoryManager>>#currentAllocatedBytes */
static usqLong
currentAllocatedBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt use;

	use = ((/* begin totalOldSpaceCapacity */
	assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	return (GIV(statAllocatedBytes) + (GIV(freeStart) - (((eden()).start)))) + (use - GIV(oldSpaceUsePriorToScavenge));
}

	/* SpurMemoryManager>>#displayObject */
sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord())))));
}


/*	The inner shell for scavenge, abstrascted out so globalGarbageCollect can
	use it.
 */

	/* SpurMemoryManager>>#doScavenge: */
static NoDbgRegParms void
doScavenge(sqInt tenuringCriterion)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    float fractionSurvived;
    sqInt oldStart;
    SpurNewSpaceSpace temp;
    usqInt use;

	/* begin doAllocationAccountingForScavenge */
	use = ((assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	GIV(statAllocatedBytes) = (GIV(statAllocatedBytes) + (GIV(freeStart) - (((eden()).start)))) + (use - GIV(oldSpaceUsePriorToScavenge));
	GIV(gcPhaseInProgress) = ScavengeInProgress;
	/* begin scavenge: */
	GIV(statSurvivorCount) = 0;
	GIV(tenureCriterion) = tenuringCriterion;
	/* begin logStartScavenge */
	(GIV(scavengeLogRecord).sEdenBytes = (freeStart()) - ((GIV(eden).start)));
	(GIV(scavengeLogRecord).sPastBytes = (pastSpaceStart()) - ((GIV(pastSpace).start)));
	(GIV(scavengeLogRecord).sRememberedSetSize = GIV(rememberedSetSize));
	(GIV(scavengeLogRecord).sRememberedSetRedZone = GIV(rememberedSetRedZone));
	(GIV(scavengeLogRecord).sRememberedSetLimit = GIV(rememberedSetLimit));
	(GIV(scavengeLogRecord).sStatTenures = GIV(statTenures));
	/* begin strategizeToLimitRememberedTable */
	if ((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(rememberedSetSize) >= GIV(rememberedSetRedZone))) {
		GIV(tenureCriterion) = TenureToShrinkRT;
		computeRefCountToShrinkRT();
	}
	/* begin logTenuringPolicy */
	(GIV(scavengeLogRecord).tTenureCriterion = GIV(tenureCriterion));
	(GIV(scavengeLogRecord).tTenureThreshold = ((GIV(tenureCriterion) == TenureByAge)
	 && (GIV(tenureThreshold) > ((GIV(pastSpace).start)))
		? GIV(tenureThreshold) - ((GIV(pastSpace).start))
		: 0));
	(GIV(scavengeLogRecord).tRefCountToShrinkRT = GIV(refCountToShrinkRT));
	scavengeLoop();
	processWeaklings();
	/* begin computeTenuringThreshold */
	fractionSurvived = (((GIV(futureSpace).limit)) == ((GIV(futureSpace).start))
		? 0.0
		: (((double) (GIV(futureSurvivorStart) - ((GIV(futureSpace).start))) )) / (((GIV(futureSpace).limit)) - ((GIV(futureSpace).start))));
	GIV(tenureThreshold) = (fractionSurvived > 0.9
		? (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - GIV(tenuringProportion))))) + ((GIV(pastSpace).start))
		: 0);
	/* begin exchangeSurvivorSpaces */
	temp = GIV(pastSpace);
	GIV(pastSpace) = GIV(futureSpace);
	GIV(futureSpace) = temp;
	/* begin logEndScavenge */
	(GIV(scavengeLogRecord).eSurvivorBytes = GIV(futureSurvivorStart) - ((GIV(pastSpace).start)));
	(GIV(scavengeLogRecord).eRememberedSetSize = GIV(rememberedSetSize));
	(GIV(scavengeLogRecord).eStatTenures = GIV(statTenures));
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	GIV(pastSpaceStart) = oldStart;
	assert(oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(pastSpaceStart), ((pastSpace()).start), ((pastSpace()).limit)));
	GIV(freeStart) = ((eden()).start);
	GIV(gcPhaseInProgress) = 0;
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = ((assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
}


/*	Reduce the number of indexable fields in objOop, a pointer object, to
	nSlots. Convert the
	unused residual to a free chunk. Without changes to
	numSlotsForShortening:toIndexableSize: this only works for arrayFormat and
	longFormat objects.
	Answer the number of bytes returned to free memory, which may be zero if
	no change
	was possible. */

	/* SpurMemoryManager>>#doShorten:toIndexableSize: */
static NoDbgRegParms sqInt
doShortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesBefore;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt copy;
    sqInt delta;
    usqInt followingAddress;
    sqInt format;
    sqInt format1;
    sqInt format2;
    sqInt format3;
    sqInt format4;
    sqInt format5;
    sqInt freeChunk;
    sqInt i;
    sqInt instFormat;
    sqInt instFormat1;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;


	/* for assert checking */
	followingAddress = addressAfter(objOop);
	assert(oopisLessThanOrEqualTo(followingAddress, GIV(endOfMemory)));
	/* begin numSlotsForShortening:toIndexableSize: */
	switch ((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) {
	case arrayFormat():
		numSlots = indexableSize;
		break;
	case firstLongFormat():
	case (firstLongFormat()) + 1:
		numSlots = ((indexableSize * 4) + (BytesPerWord - 1)) / BytesPerWord;
		break;
	default:
		assertf("invalid format for shortening");
		numSlots = 0;
	}
	bytesBefore = bytesInBody(objOop);
	/* Since the system rounds objects up to 64-bits, losing a 32-bit
	   slot may not actually change the bytes occupied by the object. */
	delta = bytesBefore - (/* begin objectBytesForSlots: */
	(numSlots == 0
	? 8 /* begin allocationUnit */ + BaseHeaderSize
	: (((sqInt)((usqInt)(numSlots) << (shiftForWord())))) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))));
	if (delta == 0) {
		if ((byteAt(objOop + 7)) == (numSlotsMask())) {
			/* begin rawOverflowSlotsOf:put: */
			longAtput(objOop - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask())) << 56))) + numSlots);
		}
		else {
			/* begin rawNumSlotsOf:put: */
			byteAtput(objOop + 7, numSlots);
		}
		if (((((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) <= ((firstLongFormat()) + 1)))) {
			format3 = (firstLongFormat()) + (indexableSize & 1);
			/* begin setFormatOf:to: */
			assert(((format3 >= 0) && (format3 <= (formatMask()))));
			longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (((sqInt)((usqInt)(format3) << (formatShift())))));
		}
		return 0;
	}
	if ((delta <= 8 /* begin allocationUnit */)
	 && ((	/* begin isOldObject: */
		assert(isNonImmediate(objOop)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart))))) {
		/* begin normalisedFormatFor:indexableSize: */
		instFormat = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
		if (instFormat >= (firstByteFormat())) {
			/* this is likely the common case */
			format4 = instFormat & -8;
			goto l5;
		}
		if (instFormat <= (sixtyFourBitIndexableFormat())) {
			format4 = instFormat;
			goto l5;
		}
		if (instFormat < (firstShortFormat())) {
			format4 = instFormat & -2;
			goto l5;
		}
		format4 = instFormat & -4;
	l5:	/* end classFormatFromInstFormat: */;
		format = ((format4 == (firstLongFormat()))
		 && (((indexableSize & 1) != 0))
			? format4 + 1
			: format4);
		classIndex = (longAt(objOop)) & (classIndexMask());
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if ((((usqInt)(numSlots)) >> 56) > 0) {
				copy = null;
				goto l2;
			}
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
		}
		else {
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			copy = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, format, classIndex);
			goto l2;
		}
		if (numSlots >= (numSlotsMask())) {
			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
			longAtput(newObj, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(format) << (formatShift()))))) + classIndex);
		}
		else {
			longAtput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(format) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		copy = newObj;
	l2:	/* end allocateSlots:format:classIndex: */;
		if (!copy) {
			error("shorten:toIndexableSize: attempted to shorten by allocationUnit and failed to allocate space for copy!");
		}
		if (		/* begin isPureBitsFormat: */
			(format >= (sixtyFourBitIndexableFormat()))
		 && (format < (firstCompiledMethodFormat()))) {
			memcpy(firstIndexableField(copy), firstIndexableField(objOop), numBytesOfBitsformat(copy, format));
		}
		else {
			for (i = 0; i < numSlots; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(copy)));
				longAtput((copy + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
			}
		}
		if (((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0) {
			remember(copy);
		}
		/* begin forward:to: */
		classIndex2 = isForwardedObjectClassIndexPun();
		assert(((classIndex2 >= 0) && (classIndex2 <= (classIndexMask()))));
		assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex2 + (7U << (formatShift()))));
#    if IMMUTABILITY
		/* begin setIsImmutableOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#    endif // IMMUTABILITY

		/* begin storePointer:ofForwarder:withValue: */
		assert(isForwarded(objOop));
		assert(!(isOopForwarded(copy)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(objOop)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(copy & (tagMask()))))
			 && (oopisLessThan(copy, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord())), copy);
		if ((byteAt(objOop + 7)) == 0) {
			/* begin rawNumSlotsOf:put: */
			byteAtput(objOop + 7, 1);
		}
		return 0;
	}
	if ((byteAt(objOop + 7)) == (numSlotsMask())) {
		/* begin rawOverflowSlotsOf:put: */
		longAtput(objOop - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask())) << 56))) + numSlots);
		if (numSlots <= 1) {
			if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
				/* begin rawNumSlotsOf:put: */
				byteAtput(objOop + 7, numSlots);
				hackSlimBridgeToat(objOop, objOop - 8 /* begin allocationUnit */);
			}
		}
	}
	else {
		assert(numSlots < (numSlotsMask()));
		/* begin rawNumSlotsOf:put: */
		byteAtput(objOop + 7, numSlots);
	}
	delta = followingAddress - (addressAfter(objOop));
	assert((delta >= (allocationUnit()))
	 && ((delta % (allocationUnit())) == 0));
	if (delta == 8 /* begin allocationUnit */) {
		assert(!((isOldObject(objOop))));
		delta = 0;
		if (followingAddress == GIV(freeStart)) {
			GIV(freeStart) = addressAfter(objOop);
		}
		else {
			hackSlimBridgeToat(followingAddress, addressAfter(objOop));
		}
	}
	else {
		freeChunk = initFreeChunkWithBytesat(delta, addressAfter(objOop));
		assert((objectAfter(objOop)) == freeChunk);
		assert((addressAfter(freeChunk)) == followingAddress);
		if (oopisGreaterThanOrEqualToandLessThan(objOop, GIV(oldSpaceStart), GIV(endOfMemory))) {
			GIV(totalFreeOldSpace) += delta;
			addToFreeListbytes(freeChunk, delta);
		}
		else {
			delta = 0;
			classIndex1 = sixtyFourBitLongsClassIndexPun();
			/* begin setClassIndexOf:to: */
			assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask()))));
			longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(classIndexMask()))) + classIndex1);
			format1 = firstLongFormat();
			/* begin setFormatOf:to: */
			assert(((format1 >= 0) && (format1 <= (formatMask()))));
			longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (((sqInt)((usqInt)(format1) << (formatShift())))));
		}
	}
	/* begin normalisedFormatFor:indexableSize: */
	instFormat1 = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	if (instFormat1 >= (firstByteFormat())) {
		/* this is likely the common case */
		format5 = instFormat1 & -8;
		goto l8;
	}
	if (instFormat1 <= (sixtyFourBitIndexableFormat())) {
		format5 = instFormat1;
		goto l8;
	}
	if (instFormat1 < (firstShortFormat())) {
		format5 = instFormat1 & -2;
		goto l8;
	}
	format5 = instFormat1 & -4;
	l8:	/* end classFormatFromInstFormat: */;
	format2 = ((format5 == (firstLongFormat()))
	 && (((indexableSize & 1) != 0))
		? format5 + 1
		: format5);
	/* begin setFormatOf:to: */
	assert(((format2 >= 0) && (format2 <= (formatMask()))));
	longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (((sqInt)((usqInt)(format2) << (formatShift())))));
	return delta;
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* SpurMemoryManager>>#eeInstantiateClassIndex:format:numSlots: */
usqInt
eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	return allocateNewSpaceSlotsformatclassIndex(numSlots, objFormat, knownClassIndex);
}


/*	We use bridges to stitch segments together to make it appear that the heap
	is one contiguous space.
	Bridges at the end of oldSpace segments are maintained. Bridges at the end
	of pastSpace and eden
	are temporary, and are established here, depending on the current sizes of
	pastSpace end eden.
	
	N.B. this introduces complications. Either or both pastSpace and eden may
	be empty, so the 
	bridge from pastSpace may skip eden. pastSpace may be full, so there may
	be no bridge at
	the end of pastSpace. Most difficult, pastSpace could be one 64-bit word
	short of full, but normal
	bridges are two word objects. To make this work we introduce a hack,
	objectAfterMaybeSlimBridge:limit:, which uses a fake overflow slot count
	to get to the start of the next object, which is either one or two
	words away, depending on whether the first object in eden has a normal or
	an overflow header. */

	/* SpurMemoryManager>>#enableObjectEnumerationFrom: */
static NoDbgRegParms void
enableObjectEnumerationFrom(sqInt initialObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (oopisLessThan(initialObject, GIV(oldSpaceStart))) {
		if (GIV(freeStart) > (((eden()).start))) {
			/* begin bridgeEdenAndOldSpace */
			initSegmentBridgeWithBytesat(GIV(oldSpaceStart) - GIV(freeStart), GIV(freeStart));
			if (GIV(pastSpaceStart) < (((eden()).start))) {
				/* past space can be entirely full (!!) */
				if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
					/* No room for a full bridge (!!); use the slim bridge hack */
					hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
					assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
				}
				else {
					/* Room for a regular bridge; this is straight-forward */
					initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
				}
			}
		}
		else {
			/* If eden is empty (e.g. at snapshot time), skip it entirely */
			/* begin bridgePastSpaceAndOldSpace */
			initSegmentBridgeWithBytesat(GIV(oldSpaceStart) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such as
	the markStack or the ephemeronQueue. It is a linked list of segments,
	with the hot end at the head of the list. It is a word object. The stack
	pointer is in ObjStackTopx and 0 means empty. The list goes through
	ObjStackNextx. We don't want to shrink objStacks, since they're used
	in GC and its good to keep their memory around. So unused pages
	created by popping emptying pages are kept on the ObjStackFreex list. */

	/* SpurMemoryManager>>#ensureRoomOnObjStackAt: */
static NoDbgRegParms sqInt
ensureRoomOnObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNewPage;
    sqInt stackOrNil;

	stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord())))));
	if ((stackOrNil == GIV(nilObj))
	 || ((longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))) >= ObjStackLimit)) {
		freeOrNewPage = (stackOrNil == GIV(nilObj)
			? 0
			: longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord()))))));
		if (freeOrNewPage != 0) {
			/* the free page list is always on the new page. */
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
			longAtput((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))), 0);
			assert((!GIV(marking))
			 || (isMarked(freeOrNewPage)));
		}
		else {
			freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, 
			/* begin objectBytesForSlots: */
(((sqInt)((usqInt)(ObjStackPageSlots) << (shiftForWord())))) + (BaseHeaderSize + BaseHeaderSize), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
			if (!freeOrNewPage) {
				/* Allocate a new segment an retry. This is very uncommon. But it happened to me (Clement). */
				growOldSpaceByAtLeast(ObjStackPageSlots * BytesPerOop);
				freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, 
				/* begin objectBytesForSlots: */
(((sqInt)((usqInt)(ObjStackPageSlots) << (shiftForWord())))) + (BaseHeaderSize + BaseHeaderSize), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
				if (!freeOrNewPage) {
					error("no memory to allocate or extend obj stack");
				}
			}
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
			longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))), 0);
			if (GIV(marking)) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(freeOrNewPage)));
				longAtput(freeOrNewPage, (longAt(freeOrNewPage)) | (1ULL << (markedBitFullShift())));
			}
		}
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord())))), objStackRootIndex);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))), (stackOrNil == GIV(nilObj)
			? 0
			: stackOrNil));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))), 0);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(GIV(hiddenRootsObj))),
		oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(freeOrNewPage & (tagMask()))))
			 && (oopisLessThan(freeOrNewPage, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(GIV(hiddenRootsObj))))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord())))), freeOrNewPage);
		assert(isValidObjStackAt(objStackRootIndex));
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(GIV(hiddenRootsObj))),
		oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(freeOrNewPage & (tagMask()))))
			 && (oopisLessThan(freeOrNewPage, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(GIV(hiddenRootsObj))))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord())))), freeOrNewPage);
		switch (objStackRootIndex) {
		case MarkStackRootIndex:
			GIV(markStack) = freeOrNewPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = freeOrNewPage;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = freeOrNewPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		stackOrNil = freeOrNewPage;
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return stackOrNil;
}


/*	Enter aBehavior into the class table and answer 0. Otherwise answer a
	primitive failure code. */

	/* SpurMemoryManager>>#enterIntoClassTable: */
static NoDbgRegParms sqInt
enterIntoClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt formatField;
    sqInt i;
    sqInt iLimiT;
    sqInt initialMajorIndex;
    sqInt majorIndex;
    sqInt minorIndex;
    sqInt numSlots;
    sqInt numSlots1;
    usqInt p;
    sqInt page;

	majorIndex = ((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift());
	/* classTableIndex should never index the first page; it's reserved for known classes */
	initialMajorIndex = majorIndex;
	assert(initialMajorIndex > 0);
	minorIndex = GIV(classTableIndex) & ((1U << (classTableMajorIndexShift())) - 1);
	while (1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(majorIndex) << (shiftForWord())))));
		if (page == GIV(nilObj)) {
			numSlots = 1U << (classTableMajorIndexShift());
			formatField = arrayFormat();
			classIndex = arrayClassIndexPun();
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			page = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, (numSlots == 0
				? 8 /* begin allocationUnit */ + BaseHeaderSize
				: (((sqInt)((usqInt)(numSlots) << (shiftForWord())))) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize))), formatField, classIndex);
			if (!page) {
				return PrimErrNoMemory;
			}
			numSlots1 = 1U << (classTableMajorIndexShift());
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(page)));
			for (p = (((usqInt)(page + BaseHeaderSize))); p <= (((usqInt)(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
				longAtput(p, GIV(nilObj));
			}
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(hiddenRootsObj))));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(GIV(hiddenRootsObj))),
			oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(page & (tagMask()))))
				 && (oopisLessThan(page, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(GIV(hiddenRootsObj))))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(GIV(hiddenRootsObj));
					}
				}
			}
			longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(majorIndex) << (shiftForWord())))), page);
			GIV(numClassTablePages) += 1;
			minorIndex = 0;
		}
		for (i = minorIndex, iLimiT = ((1U << (classTableMajorIndexShift())) - 1); i <= iLimiT; i += 1) {
			if ((longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))))) == GIV(nilObj)) {
				/* classTableIndex must never index the first page, which is reserved for classes known to the VM. */
				GIV(classTableIndex) = (((sqInt)((usqInt)(majorIndex) << (classTableMajorIndexShift())))) + i;
				assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(page)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(page)),
				oopisGreaterThanOrEqualTo(page, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(aBehavior & (tagMask()))))
					 && (oopisLessThan(aBehavior, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(page)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(page);
						}
					}
				}
				longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), aBehavior);
				/* begin setHashBitsOf:to: */
				assert(((GIV(classTableIndex) >= 0) && (GIV(classTableIndex) <= (identityHashHalfWordMask()))));
				long32Atput(aBehavior + 4, ((((long32At(aBehavior + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + GIV(classTableIndex));
				assert((classAtIndex(rawHashBitsOf(aBehavior))) == aBehavior);
				return 0;
			}
		}
		majorIndex = ((((majorIndex + 1) & (classIndexMask())) < 1) ? 1 : ((majorIndex + 1) & (classIndexMask())));
		if (majorIndex == initialMajorIndex) {
			/* wrapped; table full */
			return PrimErrLimitExceeded;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#ephemeronFormat */
static sqInt
ephemeronFormat(void)
{
	return 5;
}

	/* SpurMemoryManager>>#existInstancesInNewSpaceOf: */
static NoDbgRegParms sqInt
existInstancesInNewSpaceOf(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	obj = 0;
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin allNewSpaceObjectsDo: */
	objOop = 0;
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isBridgeOrEnumerableObjectNoAssert(objOop1));
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			return 1;
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
	return 0;
}


/*	Remove aBehavior from the class table. */

	/* SpurMemoryManager>>#expungeFromClassTable: */
static NoDbgRegParms void
expungeFromClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt majorIndex;
    sqInt minorIndex;

	assert(isInClassTable(aBehavior));
	classIndex = (long32At(aBehavior + 4)) & (identityHashHalfWordMask());
	majorIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	minorIndex = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(majorIndex) << (shiftForWord())))));
	assert(classTablePage != GIV(classTableFirstPage));
	assert((numSlotsOf(classTablePage)) == (classTablePageSize()));
	assert((fetchPointerofObject(minorIndex, classTablePage)) == aBehavior);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(classTablePage)));
	longAtput((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(minorIndex) << (shiftForWord())))), GIV(nilObj));
	if (classIndex < GIV(classTableIndex)) {
		GIV(classTableIndex) = classIndex;
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
}

	/* SpurMemoryManager>>#falseObject */
sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* SpurMemoryManager>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt objOop)
{
	return byteAt((objOop + BaseHeaderSize) + byteIndex);
}

	/* SpurMemoryManager>>#fetchClassOfNonImm: */
static NoDbgRegParms NeverInline sqInt
fetchClassOfNonImm(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	classIndex = (longAt(objOop)) & (classIndexMask());
	if (classIndex <= (classIsItselfClassIndexPun())) {
		if (classIndex == (classIsItselfClassIndexPun())) {
			return objOop;
		}
		if (classIndex == (isForwardedObjectClassIndexPun())) {
			return GIV(nilObj);
		}
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin fetchPointer:ofObject: */
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchClassOf: */
sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
		: fetchClassOfNonImm(oop));
}


/*	In Spur an object's classIndex is the tag in all method caches. */

	/* SpurMemoryManager>>#fetchClassTagOfNonImm: */
static NoDbgRegParms sqInt
fetchClassTagOfNonImm(sqInt obj)
{
	return (longAt(obj)) & (classIndexMask());
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* SpurMemoryManager>>#fetchLong32:ofObject: */
int
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
}

	/* SpurMemoryManager>>#fetchPointer:ofFreeChunk: */
static NoDbgRegParms sqInt
fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
}


/*	Answer, but do not remove, the largest free chunk in the free lists. */

	/* SpurMemoryManager>>#findLargestFreeChunk */
static sqInt
findLargestFreeChunk(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt childNode;
    sqInt treeNode;

	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		return null;
	}
	while (1) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(treeNode));
		assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		childNode = longAt((treeNode + BaseHeaderSize) + (4U << (shiftForWord())));
		if (!(childNode != 0)) break;
		treeNode = childNode;
	}
	return treeNode;
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */
/*	useful for debugging */

	/* SpurMemoryManager>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    sqInt address;
    sqInt classIndex;
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt n;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	aCStringStrlen = strlen(aCString);
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots2 = byteAt(address + 7);
	startObject = (numSlots2 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (			/* begin object:beginsWithString:ofSize: */
				(((!(obj1 & (tagMask()))))
			 && (((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
			 && ((!(((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
			 && (((numBytesOfBytes(obj1)) >= aCStringStrlen)
			 && ((strncmp(aCString, firstIndexableField(obj1), aCStringStrlen)) == 0)))) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				fmt = (((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask());
				/* begin numSlotsOfAny: */
				numSlots1 = byteAt(obj1 + 7);
				numSlots = (numSlots1 == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(obj1 - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1);
				if (fmt <= 5 /* begin ephemeronFormat */) {
					n = numSlots;
					goto l2;
				}
				if (fmt >= (firstByteFormat())) {
					/* bytes, including CompiledMethod */
					n = (numSlots << (shiftForWord())) - (fmt & 7);
					goto l2;
				}
				if (fmt >= (firstShortFormat())) {
					n = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
					goto l2;
				}
				if (fmt >= (firstLongFormat())) {
					n = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
					goto l2;
				}
				if (fmt == (sixtyFourBitIndexableFormat())) {
					n = numSlots;
					goto l2;
				}
				n = 0;
	l2:	/* end lengthOf: */;
				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)n));
				printChar(' ');
				printOopShortInner(obj1);
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l4:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* SpurMemoryManager>>#findString: */
void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	aCStringStrlen = strlen(aCString);
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (			/* begin object:equalsString:ofSize: */
				(((!(obj1 & (tagMask()))))
			 && (((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
			 && ((!(((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
			 && (((numBytesOfBytes(obj1)) == aCStringStrlen)
			 && ((strncmp(aCString, firstIndexableField(obj1), aCStringStrlen)) == 0)))) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				printOopShortInner(obj1);
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}

	/* SpurMemoryManager>>#firstAccessibleObject */
static sqInt
firstAccessibleObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	assert(GIV(nilObj) == GIV(oldSpaceStart));
	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	GIV(tenureThreshold) = GIV(oldSpaceStart);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
	return GIV(nilObj);
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* SpurMemoryManager>>#firstFixedFieldOfMaybeImmediate: */
static NoDbgRegParms void *
firstFixedFieldOfMaybeImmediate(sqInt oop)
{
	return (((oop & (tagMask())) != 0)
		? ((void *)oop)
		: pointerForOop(oop + BaseHeaderSize));
}

	/* SpurMemoryManager>>#firstFixedField: */
void *
firstFixedField(sqInt objOop)
{
	return pointerForOop(objOop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes.
	There are only two important cases, both for objects with named inst vars,
	i.e. formats 2,3 & 5.
	The first indexable field for formats 2 & 5 is the slot count (by
	convention, even though that's off the end
	of the object). For 3 we must go to the class. */

	/* SpurMemoryManager>>#firstIndexableField: */
void *
firstIndexableField(sqInt objOop)
{
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	if (fmt <= (weakArrayFormat())) {
		if (fmt == (arrayFormat())) {
			/* array starts at 0. */
			return pointerForOop(objOop + BaseHeaderSize);
		}
		if (fmt >= (indexablePointersFormat())) {
			/* indexable with inst vars; need to delve into the class format word */
			classPointer = fetchClassOfNonImm(objOop);
			/* begin formatOfClass: */
			classFormat = ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
			return pointerForOop((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((classFormat & ((1U << (fixedFieldsFieldWidth())) - 1))) << (shiftForWord())))));
		}
		return 0;
	}
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 && (fmt < (firstCompiledMethodFormat()))) {
		return pointerForOop(objOop + BaseHeaderSize);
	}
	return 0;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormatMask */
sqInt
fixedFieldsOfClassFormatMask(void)
{
	return (1U << (fixedFieldsFieldWidth())) - 1;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormat: */
sqInt
fixedFieldsOfClassFormat(sqInt classFormat)
{
	return classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
}

	/* SpurMemoryManager>>#fixedFieldsOf:format:length: */
static NoDbgRegParms sqInt
fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength)
{
    sqInt class;


	/* N.B. written to fall through to fetchClassOfNonImm: et al for forwarders
	   so as to trigger an assert fail. */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		return 0;
	}
	if (fmt < (arrayFormat())) {
		return wordLength;
	}
	class = fetchClassOfNonImm(objOop);
	return (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
}


/*	Private helper for followField:ofObject: to avoid code duplication for
	rare case.
 */

	/* SpurMemoryManager>>#fixFollowedField:ofObject:withInitialValue: */
static NoDbgRegParms NeverInline sqInt
fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	assert(isOopForwarded(initialValue));
	objOop = initialValue;
	do {
		objOop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
	} while(		/* begin isOopForwarded: */
			((!(objOop & (tagMask()))))
		 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))));
	assert(!(isForwarded(anObject)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(anObject)),
	oopisGreaterThanOrEqualTo(anObject, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(objOop & (tagMask()))))
		 && (oopisLessThan(objOop, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(anObject)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(anObject);
			}
		}
	}
	longAtput((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), objOop);
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#followField:ofObject: */
static NoDbgRegParms sqInt
followFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}


/*	Follow a forwarding pointer. This must be a loop because we cannot prevent
	forwarders to
	forwarders being created by lazy become. Consider the following example by
	Igor Stasenko:
	array := { a. b. c }.
	- array at: 1 points to &a. array at: 2 points to &b. array at: 3 points
	to &c
	a becomeForward: b
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	b becomeForward: c.
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	- when accessing array first one has to follow a forwarding chain:
	&a -> &b -> c */

	/* SpurMemoryManager>>#followForwarded: */
sqInt
followForwarded(sqInt objOop)
{
    sqInt referent;

	assert(isUnambiguouslyForwarder(objOop));
	referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent & (tagMask()))))
	 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	return referent;
}

	/* SpurMemoryManager>>#followMaybeForwarded: */
static NoDbgRegParms sqInt
followMaybeForwarded(sqInt objOop)
{
	return (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
		? followForwarded(objOop)
		: objOop);
}


/*	Make sure the obj at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) obj at
	fieldIndex.  */

	/* SpurMemoryManager>>#followObjField:ofObject: */
static NoDbgRegParms sqInt
followObjFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}

	/* SpurMemoryManager>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer)
{
	return ((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable	(11 unused in 32 bits)
	12 - 15 16-bit indexable	(14 & 15 unused in 32-bits)
	16 - 23 byte indexable		(20-23 unused in 32-bits)
	24 - 31 compiled method	(28-31 unused in 32-bits) */
/*	A note on performance. Since the format field is, by design, aligned on a
	byte boundary
	in the fourth byte of the header we could access it via
	^(self byteAt: objOop + 3) bitAnd: self formatMask
	but al least on e.g. Core i7 x86-64 using the clang 6 compiler, this makes
	no difference,
	or at least any change is in the noise. */

	/* SpurMemoryManager>>#formatOf: */
static NoDbgRegParms sqInt
formatOf(sqInt objOop)
{
	return (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
}


/*	A special format used by the GC to follow only the first pointer. */

	/* SpurMemoryManager>>#forwardedFormat */
static sqInt
forwardedFormat(void)
{
	return 7;
}


/*	Answer if anObject is itself forwarded, or is a pointer object containing
	any references to forwarded objects.
 */

	/* SpurMemoryManager>>#forwardersIn: */
static NoDbgRegParms sqInt
forwardersIn(sqInt anObject)
{
    sqInt i;
    sqInt iLimiT;
    sqInt oop;

	if ((!((longAt(anObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		return 1;
	}
	for (i = 0, iLimiT = ((numPointerSlotsOf(anObject)) - 1); i <= iLimiT; i += 1) {
		oop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (((!(oop & (tagMask()))))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			return 1;
		}
	}
	return 0;
}


/*	for linking objecs on each free list, or, during pigCompact, doubly-
	linking the free objects in address order using the xor link hack. */

	/* SpurMemoryManager>>#freeChunkNextIndex */
static sqInt
freeChunkNextIndex(void)
{
	return 0;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkParentIndex */
static sqInt
freeChunkParentIndex(void)
{
	return 2;
}


/*	For linking objecs on each free list, doubly-linking the free objects.
	Free chunks of size 1 do not have a prev index. */

	/* SpurMemoryManager>>#freeChunkPrevIndex */
static sqInt
freeChunkPrevIndex(void)
{
	return 1;
}

	/* SpurMemoryManager>>#freeChunkWithBytes:at: */
static NoDbgRegParms sqInt
freeChunkWithBytesat(sqInt bytes, sqInt address)
{
    sqInt freeChunk;

	assert(isInOldSpace(address));
	assert((segmentContainingObj(address)) == (segmentContainingObj(address + bytes)));
	freeChunk = initFreeChunkWithBytesat(bytes, address);
	addToFreeListbytes(freeChunk, bytes);
	assert(freeChunk == (objectStartingAt(address)));
	return freeChunk;
}


/*	Free an object in oldSpace. Coalesce if possible to reduce fragmentation. */

	/* SpurMemoryManager>>#freeObject: */
sqInt
freeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytes;
    usqInt chunkBytes;
    sqInt index;
    sqInt next;
    usqInt numSlots;
    usqInt start;

	assert(isInOldSpace(objOop));
	if (((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0) {
		/* begin forgetObject: */
		assert(GIV(rememberedSetSize) > 0);
		assert(isRemembered(objOop));
		/* begin setIsRememberedOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
		if (!(objOop == (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]))) {
			index = 0;
			while (index < GIV(rememberedSetSize)) {
				if (objOop == (GIV(rememberedSet)[index])) {
					GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
					index = GIV(rememberedSetSize);
				}
				else {
					index += 1;
				}
			}
		}
		GIV(rememberedSetSize) -= 1;
		assert(GIV(rememberedSetSize) >= 0);
	}
	bytes = bytesInBody(objOop);
	start = 
	/* begin startOfObject: */
((byteAt(objOop + 7)) == (numSlotsMask())
		? objOop - BaseHeaderSize
		: objOop);
	numSlots = byteAt((start + bytes) + 7);
	next = (numSlots == (numSlotsMask())
		? (start + bytes) + BaseHeaderSize
		: start + bytes);
	if (((longAt(next)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
		/* begin detachFreeObject: */
		chunkBytes = bytesInBody(next);
		GIV(totalFreeOldSpace) -= chunkBytes;
		unlinkFreeChunkchunkBytes(next, chunkBytes);
		bytes += bytesInBody(next);
	}
	GIV(totalFreeOldSpace) += bytes;
	return freeChunkWithBytesat(bytes, start);
}


/*	Perform a full eager compacting GC. Answer the size of the largest free
	chunk. 
 */
/*	for profiling */

	/* SpurMemoryManager>>#fullGC */
NeverInline usqLong
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqLong compactionStartUsecs;
    usqLong gcMarkEndUsecs;
    sqInt i;
    sqInt index;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;

	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statMarkCount) = 0;
	preGCAction(GCModeFull);
	/* begin globalGarbageCollect */
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	markObjects(1);
	gcMarkEndUsecs = ioUTCMicrosecondsNow();
	/* begin forgetUnmarkedRememberedObjects */
	index = 0;
	while (index < GIV(rememberedSetSize)) {
		obj = GIV(rememberedSet)[index];
		if (((((usqInt)((longAt(obj)))) >> (markedBitFullShift())) & 1) != 0) {
			index += 1;
		}
		else {
			/* unmarked; remove by overwriting with last element. */
			/* begin setIsRememberedOf:to: */
			longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
			GIV(rememberedSetSize) -= 1;
			GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
		}
	}
	assert(GIV(rememberedSetSize) >= 0);
	/* begin setGCMode: */
	GIV(gcMode) = GCModeNewSpace;
	doScavenge(MarkOnTenure);
	/* begin setGCMode: */
	GIV(gcMode) = GCModeFull;
	runLeakCheckerForexcludeUnmarkedObjsclassIndicesShouldBeValid(GCModeFull, 1, 1);
	compactionStartUsecs = ioUTCMicrosecondsNow();
	/* begin prepareForGlobalSweep */
	for (i = 0; i < GIV(numSegments); i += 1) {
		((GIV(segments)[i]).containsPinned = 0);
	}
	/* begin bridgeAt: */
	address = (((((&(GIV(segments)[GIV(numSegments) - 1])))->segSize)) + ((((&(GIV(segments)[GIV(numSegments) - 1])))->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	objOop = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift())));
	compact();
	/* begin attemptToShrink */
	if ((GIV(totalFreeOldSpace) > GIV(shrinkThreshold))
	 && ((GIV(totalFreeOldSpace) > GIV(growHeadroom))
	 && (shrinkObjectMemory((((GIV(totalFreeOldSpace) - GIV(growHeadroom)) < GIV(growHeadroom)) ? GIV(growHeadroom) : (GIV(totalFreeOldSpace) - GIV(growHeadroom))))))) {
		GIV(statShrinkMemory) += 1;
	}
	/* begin setHeapSizeAtPreviousGC */
	GIV(heapSizeAtPreviousGC) = ((assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = ((assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	assert(allObjectsUnmarked());
	runLeakCheckerFor(GCModeFull);
	postGCAction(GCModeFull);
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	/* begin updateFullGCStats */
	GIV(statFullGCs) += 1;
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statCompactionUsecs) += GIV(statGCEndUsecs) - compactionStartUsecs;
	if (!(GIV(gcSweepEndUsecs) == 0)) {
		GIV(statSweepUsecs) += GIV(gcSweepEndUsecs) - compactionStartUsecs;
	}
	GIV(statMarkUsecs) += gcMarkEndUsecs - GIV(gcStartUsecs);
	if ((GIV(freeLists)[0]) != 0) {
		return bytesInBody(findLargestFreeChunk());
	}
	else {
		return 0;
	}
}

	/* SpurMemoryManager>>#getHeapGrowthToSizeGCRatio */
static float
getHeapGrowthToSizeGCRatio(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(heapGrowthToSizeGCRatio);
}

	/* SpurMemoryManager>>#goodContextSize: */
static NoDbgRegParms sqInt
goodContextSize(sqInt oop)
{
    usqInt numSlots;
    usqInt numSlots1;


	/* begin numSlotsOf: */
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(oop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	return (numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots);
}


/*	Attempt to grow memory by at least minAmmount.
	Answer the size of the new segment, or nil if the attempt failed. */

	/* SpurMemoryManager>>#growOldSpaceByAtLeast: */
static NoDbgRegParms usqInt
growOldSpaceByAtLeast(sqInt minAmmount)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt ammount;
    sqInt bytes;
    sqInt headroom;
    sqInt interval;
    SpurSegmentInfo *segInfo;
    sqInt start;
    usqInt total;


	/* statGrowMemory counts attempts, not successes. */
	/* we need to include overhead for a new object header plus the segment bridge. */
	GIV(statGrowMemory) += 1;
	/* round up to the nearest power of two. */
	ammount = minAmmount + ((BaseHeaderSize * 2) + (2 * BaseHeaderSize));
	/* and grow by at least growHeadroom. */
	ammount = 1ULL << (highBit(ammount - 1));
	/* Now apply the maxOldSpaceSize limit, if one is in effect. */
	ammount = ((ammount < GIV(growHeadroom)) ? GIV(growHeadroom) : ammount);
	if (maxOldSpaceSize > 0) {
		/* begin totalOldSpaceSize */
		assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges));
		total = GIV(totalHeapSizeIncludingBridges);
		if (total >= maxOldSpaceSize) {
			GIV(needGCFlag) = 1;
			return null;
		}
		headroom = maxOldSpaceSize - total;
		if (headroom < ammount) {
			if (headroom < (minAmmount + ((BaseHeaderSize * 2) + (2 * BaseHeaderSize)))) {
				GIV(needGCFlag) = 1;
				return null;
			}
			ammount = headroom;
		}
	}
	start = ioUTCMicrosecondsNow();
	segInfo = addSegmentOfSize(ammount);
	if (segInfo == null) {
		GIV(needGCFlag) = 1;
		return null;
	}
	else {
		/* begin assimilateNewSegment: */
		if ((((segInfo->segSize)) + ((segInfo->segStart))) >= GIV(endOfMemory)) {
			GIV(freeOldSpaceStart) = (GIV(endOfMemory) = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * BaseHeaderSize));
		}
		bytes = ((segInfo->segSize)) - (2 * BaseHeaderSize);
		address = (segInfo->segStart);
		/* begin addFreeChunkWithBytes:at: */
		GIV(totalFreeOldSpace) += bytes;
		freeChunkWithBytesat(bytes, address);
		assert((addressAfter(objectStartingAt((segInfo->segStart)))) == ((segLimit(segInfo)) - (bridgeSize())));
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCCheckFreeSpace)) == (GCCheckFreeSpace | GCCheckFreeSpace))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
		}
		checkSegments();
		interval = (ioUTCMicrosecondsNow()) - start;
		if (interval > GIV(statMaxAllocSegmentTime)) {
			GIV(statMaxAllocSegmentTime) = interval;
		}
		return (segInfo->segSize);
	}
}

	/* SpurMemoryManager>>#hasPointerFieldsNonImm: */
static NoDbgRegParms sqInt
hasPointerFieldsNonImm(sqInt oop)
{
    sqInt format;

	format = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	/* begin isAnyPointerFormat: */
	return (format <= 5 /* begin lastPointerFormat */)
	 || (format >= (firstCompiledMethodFormat()));
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,isExtraAligned})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:format:classIndex: */
usqLong
headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{
	return (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex;
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,?})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:hash:format:classIndex: */
static NoDbgRegParms usqLong
headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex)
{
	return ((((((usqLong) numSlots)) << (numSlotsFullShift())) + ((((usqLong) hash)) << (identityHashFullWordShift()))) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex;
}


/*	Answer the number of extra root slots in the root of the hidden root
	object. 
 */

	/* SpurMemoryManager>>#hiddenRootSlots */
static sqInt
hiddenRootSlots(void)
{
	return 8;
}

	/* SpurMemoryManager>>#hiddenRootsObject */
static sqInt
hiddenRootsObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine
	it came from. Low half of word is e.g. 6521. Top byte is top byte of
	#doesNotUnderstand: on
	this machine. ($d on the Mac or $s on the PC) */

	/* SpurMemoryManager>>#imageSegmentVersion */
static sqInt
imageSegmentVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int wholeWord;


	/* first data word, 'does' */
	wholeWord = long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))) + BaseHeaderSize);
	return 68021 /* begin imageFormatVersion */ | (wholeWord & 0xFF000000U);
}


/*	mask the immutable bit in the base header word */

	/* SpurMemoryManager>>#immutableBitMask */
#if IMMUTABILITY
sqInt
immutableBitMask(void)
{
	return 1U << (immutableBitShift());
}
#endif /* IMMUTABILITY */


/*	Part of reorderReversedTreeList:. Switch treeNode with newNode in
	the tree, but do nothing to the list linked through freeChunkNextIndex. */

	/* SpurMemoryManager>>#inFreeTreeReplace:with: */
static NoDbgRegParms void
inFreeTreeReplacewith(sqInt treeNode, sqInt newNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt i;
    sqInt iLimiT;
    sqInt relative;


	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(newNode));
	assert(1);
	longAtput((newNode + BaseHeaderSize) + (1U << (shiftForWord())), 0);
	for (i = 2 /* begin freeChunkParentIndex */, iLimiT = 4 /* begin freeChunkLargerIndex */; i <= iLimiT; i += 1) {
		relative = longAt((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (i == 2 /* begin freeChunkParentIndex */) {
			if (relative == 0) {
				/* update root to point to newNode */
				assert((GIV(freeLists)[0]) == treeNode);
				GIV(freeLists)[0] = newNode;
			}
			else {
				/* replace link from parent to treeNode with link to newNode. */
				fieldIndex = (treeNode == (longAt((relative + BaseHeaderSize) + (3U << (shiftForWord()))))
					? 3 /* begin freeChunkSmallerIndex */
					: 4 /* begin freeChunkLargerIndex */);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(relative));
				assert((newNode == 0)
				 || (isFreeObject(newNode)));
				longAtput((relative + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), newNode);
			}
		}
		else {
			if (relative != 0) {
				assert((fetchPointerofFreeChunk(freeChunkParentIndex(), relative)) == treeNode);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(relative));
				assert((newNode == 0)
				 || (isFreeObject(newNode)));
				longAtput((relative + BaseHeaderSize) + (2U << (shiftForWord())), newNode);
			}
		}
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(newNode));
		assert((relative == 0)
		 || (isFreeObject(relative)));
		longAtput((newNode + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), relative);
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(treeNode));
		assert(1);
		longAtput((treeNode + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), 0);
	}
}

	/* SpurMemoryManager>>#initialInstanceOf: */
static NoDbgRegParms sqInt
initialInstanceOf(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevPrevObj;

	objOop = 0;
	classIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	if (classIndex != 0) {
		/* flush instances in newSpace to settle the enumeration. */
		/* begin flushNewSpaceInstancesOf: */
		classIndex1 = (long32At(classObj + 4)) & (identityHashHalfWordMask());
		if (classIndex1 == 0) {
			/* no instances; nothing to do */
			goto l1;
		}
		/* begin tenuringClassIndex: */
		GIV(tenuringClassIndex) = classIndex1;
		scavengingGCTenuringIf(TenureByClass);
		assert(!(existInstancesInNewSpaceOf(classObj)));
	l1:	/* end flushNewSpaceInstancesOf: */;
		/* begin allOldSpaceObjectsDo: */
		objOop2 = 0;
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj = (prevObj = null);
		objOop1 = GIV(nilObj);
		while (1) {
			assert((objOop1 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
			assert((long64At(objOop1)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex2 = (longAt(objOop1)) & (classIndexMask())),
			assert((classIndex2 == (segmentBridgePun()))
				 || ((classIndex2 == (isForwardedObjectClassIndexPun()))
				 || (((long64At(objOop1)) != 0)
				 && (classIndex2 < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex2 >= (isForwardedObjectClassIndexPun()))) {
				if (classIndex == ((longAt(objOop1)) & (classIndexMask()))) {
					return objOop1;
				}
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				objOop1 = GIV(endOfMemory);
				goto l2;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
		}
	}
	return null;
}

	/* SpurMemoryManager>>#initializeNewSpaceVariables */
static NeverInline void
initializeNewSpaceVariables(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(scavengeThreshold) = ((((eden()).limit)) - ((((GIV(eden).limit)) - ((GIV(eden).start))) / 64)) - (interpreterAllocationReserveBytes());
	GIV(newSpaceStart) = (((((pastSpace()).start)) < (((futureSpace()).start))) ? (((pastSpace()).start)) : (((futureSpace()).start)));
	assert(GIV(newSpaceStart) < (((eden()).start)));
}


/*	Initialize object memory variables at startup time. Assume endOfMemory at
	al are
	initialised by the image-reading code via
	setHeapBase:memoryLimit:endOfMemory:. endOfMemory is assumed to point to
	the end of the last object in the image.
	Assume: image reader also initializes the following variables:
	specialObjectsOop
	lastHash */
/*	Catch mis-initializations leading to bad translations to C */

	/* SpurMemoryManager>>#initializeObjectMemory: */
static NoDbgRegParms void
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anOop;
    sqInt cameFrom;
    usqInt chunkBytes;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTableRoot;
    sqInt field;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt firstObj;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt format;
    sqInt freeChunk;
    sqInt freeListObj;
    sqInt freeNode;
    usqInt freeOldStart;
    sqInt fudge;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt index;
    sqInt indexLimiT;
    sqInt j;
    sqInt largeChild;
    usqInt limit;
    sqInt min;
    sqInt nilObjPreSwizzle;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    usqInt p;
    sqInt page;
    sqInt smallChild;
    sqInt treeNode;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(BaseHeaderSize == BaseHeaderSize);
	assert((((sqInt)((maxSlotsForAlloc()) * BytesPerWord))) > 0);
	initSegmentBridgeWithBytesat(2 * BaseHeaderSize, GIV(endOfMemory) - (2 * BaseHeaderSize));
	adjustSegmentSwizzlesBy(bytesToShift);
	/* begin adjustAllOopsBy: */
	assert(newSpaceIsEmpty());
	numSlots1 = byteAt(GIV(oldSpaceStart) + 7);
	firstObj = (numSlots1 == (numSlotsMask())
		? GIV(oldSpaceStart) + BaseHeaderSize
		: GIV(oldSpaceStart));
	classTableRoot = oldSpaceObjectAfter(oldSpaceObjectAfter(oldSpaceObjectAfter(oldSpaceObjectAfter(firstObj))));
	nilObjPreSwizzle = GIV(oldSpaceStart) - bytesToShift;
	/* begin numSlotsOf: */
	assert((classIndexOf(classTableRoot)) > (isForwardedObjectClassIndexPun()));
	GIV(numClassTablePages) = (((numSlots2 = byteAt(classTableRoot + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classTableRoot - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2);
	assert(GIV(numClassTablePages) == ((classTableRootSlots()) + (hiddenRootSlots())));
	for (i3 = 2; i3 < GIV(numClassTablePages); i3 += 1) {
		if ((longAt((classTableRoot + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord())))))) == nilObjPreSwizzle) {
			GIV(numClassTablePages) = i3;
			goto l4;
		}
	}
	l4:	/* end countNumClassPagesPreSwizzle: */;
	if ((bytesToShift != 0)
	 || ((numSegments()) > 1)) {
		/* begin objectStartingAt: */
		numSlots3 = byteAt(GIV(oldSpaceStart) + 7);
		obj2 = (numSlots3 == (numSlotsMask())
			? GIV(oldSpaceStart) + BaseHeaderSize
			: GIV(oldSpaceStart));
		while (oopisLessThan(obj2, GIV(freeOldSpaceStart))) {
			classIndex1 = (longAt(obj2)) & (classIndexMask());
			if (classIndex1 >= (isForwardedObjectClassIndexPun())) {
				/* begin swizzleFieldsOfObject: */
				fieldAddr = obj2 + (lastPointerOfWhileSwizzling(obj2));
				while (oopisGreaterThanOrEqualTo(fieldAddr, obj2 + BaseHeaderSize)) {
					fieldOop = longAt(fieldAddr);
					if ((!(fieldOop & (tagMask())))) {
						longAtput(fieldAddr, swizzleObj(fieldOop));
					}
					fieldAddr -= BytesPerOop;
				}
			}
			else {
				if (classIndex1 == (isFreeObjectClassIndexPun())) {
					/* begin swizzleFieldsOfFreeChunk: */
					field = longAt((obj2 + BaseHeaderSize) + (0U << (shiftForWord())));
					if (field != 0) {
						valuePointer = swizzleObj(field);
						/* begin storePointerNoAssert:ofFreeChunk:withValue: */
						longAtput((obj2 + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
					}
					chunkBytes = bytesInBody(obj2);
					if (chunkBytes >= (0x200)) {
						for (index = 2 /* begin freeChunkParentIndex */, indexLimiT = 4 /* begin freeChunkLargerIndex */; index <= indexLimiT; index += 1) {
							field = longAt((obj2 + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
							if (field != 0) {
								valuePointer1 = swizzleObj(field);
								/* begin storePointerNoAssert:ofFreeChunk:withValue: */
								longAtput((obj2 + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), valuePointer1);
							}
						}
					}
				}
			}
			followingWordAddress = addressAfter(obj2);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				obj2 = GIV(endOfMemory);
				goto l9;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			obj2 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l9:	/* end objectAfter:limit: */;
		}
	}
	/* heavily used special objects */
	GIV(specialObjectsOop) = swizzleObj(GIV(specialObjectsOop));
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(NilObject) << (shiftForWord())))));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(FalseObject) << (shiftForWord())))));
	/* In Cog we insist that nil, true & false are next to each other (Cogit generates tighter
	   conditional branch code as a result).  In addition, Spur places the free lists and
	   class table root page immediately following them. */
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TrueObject) << (shiftForWord())))));
	assert(GIV(nilObj) == GIV(oldSpaceStart));
	assert(GIV(falseObj) == (oldSpaceObjectAfter(GIV(nilObj))));
	assert(GIV(trueObj) == (oldSpaceObjectAfter(GIV(falseObj))));
	freeListObj = oldSpaceObjectAfter(GIV(trueObj));
	anOop = oldSpaceObjectAfter(freeListObj);
	/* begin setHiddenRootsObj: */
	GIV(hiddenRootsObj) = anOop;
	assert(validClassTableRootPages());
	GIV(classTableFirstPage) = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (0U << (shiftForWord())));
	assert(((numSlotsOf(GIV(classTableFirstPage))) - 1) == (classTableMinorIndexMask()));
	flag("remove at some stage");
	if (((longAt(GIV(classTableFirstPage))) & (classIndexMask())) != (arrayClassIndexPun())) {
		classIndex = arrayClassIndexPun();
		/* begin setClassIndexOf:to: */
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
		longAtput(GIV(classTableFirstPage), ((longAt(GIV(classTableFirstPage))) & (~(usqIntptr_t)(classIndexMask()))) + classIndex);
	}
	GIV(numClassTablePages) = 1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift()));
	GIV(classTableIndex) = ((sqInt)((usqInt)(GIV(numClassTablePages)) << (classTableMajorIndexShift())));
	for (i = 1; i < GIV(numClassTablePages); i += 1) {
		if (((page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) == GIV(nilObj)) {
			if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) > i) {
				GIV(classTableIndex) = ((sqInt)((usqInt)(((((i - 1) < 1) ? 1 : (i - 1)))) << (classTableMajorIndexShift())));
			}
			GIV(numClassTablePages) = i;
			assert((classOrNilAtIndex(GIV(classTableIndex))) == GIV(nilObj));
			goto l1;
		}
		else {
			if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) > i) {
				j = 0;
				while (j < (1U << (classTableMajorIndexShift()))) {
					if ((longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))))) == GIV(nilObj)) {
						GIV(classTableIndex) = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
						j = 1U << (classTableMajorIndexShift());
					}
					j += 1;
				}
			}
		}
	}
	if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) >= GIV(numClassTablePages)) {
		GIV(classTableIndex) = 1U << (classTableMajorIndexShift());
	}
	assert((classOrNilAtIndex(GIV(classTableIndex))) == GIV(nilObj));
	l1:	/* end setHiddenRootsObj: */;
	GIV(markStack) = swizzleObjStackAt(MarkStackRootIndex);
	GIV(weaklingStack) = swizzleObjStackAt(WeaklingStackRootIndex);
	GIV(mournQueue) = swizzleObjStackAt(MournQueueRootIndex);
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	/* begin initializeFreeSpacePostLoad: */
	assert((numSlotsOf(freeListObj)) == (numFreeLists()));
	assert((formatOf(freeListObj)) == (wordIndexableFormat()));
	GIV(freeLists) = firstIndexableField(freeListObj);
	GIV(freeListsMask) = 0;
	for (i1 = 0, iLimiT = (0x3F); i1 <= iLimiT; i1 += 1) {
		if ((GIV(freeLists)[i1]) != 0) {
			GIV(freeListsMask) = GIV(freeListsMask) | (1ULL << i1);
			GIV(freeLists)[i1] = (swizzleObj(GIV(freeLists)[i1]));
		}
	}
	collapseSegmentsPostSwizzle();
	/* begin updateFreeLists */
	freeNode = 0;
	min = 3;
	for (i2 = min, iLimiT1 = (0x3F); i2 <= iLimiT1; i2 += 1) {
		updateListStartingAt(GIV(freeLists)[i2]);
	}
	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		goto l2;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = longAt((treeNode + BaseHeaderSize) + (3U << (shiftForWord())));
		largeChild = longAt((treeNode + BaseHeaderSize) + (4U << (shiftForWord())));
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {
			updateListStartingAt(treeNode);
			cameFrom = treeNode;
			treeNode = longAt((treeNode + BaseHeaderSize) + (2U << (shiftForWord())));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
	l2:	/* end freeTreeNodesDo: */;
	/* begin computeFreeSpacePostSwizzle */
	GIV(totalFreeOldSpace) = totalFreeListBytes();
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	/* begin initializeOldSpaceFirstFree: */
	limit = GIV(endOfMemory) - (2 * BaseHeaderSize);
	if (limit > GIV(freeOldSpaceStart)) {
		GIV(totalFreeOldSpace) += limit - GIV(freeOldSpaceStart);
		freeOldStart = GIV(freeOldSpaceStart);
		while ((limit - freeOldStart) >= (0x100000000LL)) {
			freeChunk = freeChunkWithBytesat(0x100000000LL, freeOldStart);
			freeOldStart += 0x100000000LL;
			assert(freeOldStart == (addressAfter(freeChunk)));
		};
		if (freeOldStart < limit) {
			freeChunk = freeChunkWithBytesat(limit - freeOldStart, freeOldStart);
			assert((addressAfter(freeChunk)) == limit);
		}
	}
	GIV(endOfMemory) -= 2 * BaseHeaderSize;
	GIV(freeOldSpaceStart) = GIV(endOfMemory);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCCheckFreeSpace)) == (GCCheckFreeSpace | GCCheckFreeSpace))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	initializeNewSpaceVariables();
	/* begin initializeRememberedSet */
	obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
	if (obj == GIV(nilObj)) {
		/* begin allocatePinnedSlots: */
		obj1 = allocateSlotsForPinningInOldSpacebytesformatclassIndex(0x400, (1024U << (shiftForWord())) + (BaseHeaderSize + BaseHeaderSize), sixtyFourBitIndexableFormat(), sixtyFourBitLongsClassIndexPun());
		if (!(obj1 == null)) {
			assert(isPinned(obj1));
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((obj1 + BaseHeaderSize) + (0x400 * BytesPerOop)) - 1, addressAfter(obj1)));
			for (p = (((usqInt)(obj1 + BaseHeaderSize))); p <= (((usqInt)(((obj1 + BaseHeaderSize) + (0x400 * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
				longAtput(p, 0);
			}
		}
		obj = obj1;
		/* begin rememberedSetObj: */
		assert(isOldObject(obj));
		assert(!(isOopForwarded(GIV(hiddenRootsObj))));
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))), obj);
	}
	else {
		/* The Spur32to64BitBootstrap failed to set the type of rememberedSetObj to 64-bit indexability.
		   This is unimportant except for simulation; rememberedSet is declared as sqInt *, but to have
		   firstIndexableField: below answer a suitable type the format must be wordIndexableFormat. */
		format = sixtyFourBitIndexableFormat();
		/* begin setFormatOf:to: */
		assert(((format >= 0) && (format <= (formatMask()))));
		longAtput(obj, ((longAt(obj)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (((sqInt)((usqInt)(format) << (formatShift())))));
	}
	assert((formatOf(obj)) == (wordIndexableFormat()));
	assert(isPinned(obj));
	GIV(rememberedSet) = firstIndexableField(obj);
	GIV(rememberedSetSize) = 0;
	/* begin numSlotsOf: */
	assert((classIndexOf(obj)) > (isForwardedObjectClassIndexPun()));
	GIV(rememberedSetLimit) = (((numSlots = byteAt(obj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 0x400;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
	checkSegments();
	/* begin biasForGC */
	GIV(biasForGC) = 1;
	/* headroom when growing */
	GIV(growHeadroom) = 0x1000000;
	/* free space before shrinking */
	GIV(shrinkThreshold) = 0x2000000;
	GIV(heapSizeAtPreviousGC) = ((assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = ((assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	/* By default GC after scavenge if heap has grown by a third since the last GC */
	GIV(heapGrowthToSizeGCRatio) = 0.333333;
}


/*	print free chunks in freeTree in order. */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#inOrderPrintFreeTree:printList: */
void
inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList)
{
    sqInt next;

	if (((next = longAt((freeChunk + BaseHeaderSize) + (3U << (shiftForWord()))))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
	printFreeChunkprintAsTreeNode(freeChunk, 1);
	if (printNextList) {
		next = freeChunk;
		while (((next = longAt((next + BaseHeaderSize) + (0U << (shiftForWord()))))) != 0) {
			/* begin tab */
			printChar('\t');
			printFreeChunkprintAsTreeNode(next, 0);
		}
	}
	if (((next = longAt((freeChunk + BaseHeaderSize) + (4U << (shiftForWord()))))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
}


/*	in an effort to fix a compiler bug with two-way become post r3427 */
/*	Do become in place by swapping object contents. */

	/* SpurMemoryManager>>#inPlaceBecome:and:copyHashFlag: */
static NoDbgRegParms NeverInline void
inPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqLong hashBits;
    sqLong header1;
    sqLong header2;
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;
    sqInt o1HasYoung;
    sqInt o2HasYoung;
    sqLong remembered;
    sqInt temp1;
    sqInt temp2;

	assert((numSlotsOf(obj1)) == (numSlotsOf(obj2)));
	assert(((rawHashBitsOf(obj1)) == 0)
	 || ((classOrNilAtIndex(rawHashBitsOf(obj1))) != obj1));
	assert(((rawHashBitsOf(obj2)) == 0)
	 || ((classOrNilAtIndex(rawHashBitsOf(obj2))) != obj2));
	/* begin cleverSwapHeaders:and:copyHashFlag: */
	header1 = long64At(obj1);
	header2 = long64At(obj2);
	remembered = (header1 ^ header2) & (1U << (rememberedBitShift()));
	if (remembered != 0) {
		header1 = header1 ^ remembered;
		header2 = header2 ^ remembered;
	}
	if (!copyHashFlag) {
		hashBits = (header1 ^ header2) & 0x3FFFFF00000000LL /* begin identityHashFullWordMask */;
		if (hashBits != 0) {
			header1 = header1 ^ hashBits;
			header2 = header2 ^ hashBits;
		}
	}
	long64Atput(obj1, header2);
	long64Atput(obj2, header1);
	o1HasYoung = (o2HasYoung = 0);
	for (i = 0, iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(obj1)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(obj1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(obj1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i <= iLimiT; i += 1) {
		temp1 = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		temp2 = longAt((obj2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(obj1)));
		longAtput((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), temp2);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(obj2)));
		longAtput((obj2 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), temp1);
		if (		/* begin isYoung: */
			((!(temp2 & (tagMask()))))
		 && (oopisLessThan(temp2, GIV(oldSpaceStart)))) {
			o1HasYoung = 1;
		}
		if (		/* begin isYoung: */
			((!(temp1 & (tagMask()))))
		 && (oopisLessThan(temp1, GIV(oldSpaceStart)))) {
			o2HasYoung = 1;
		}
	}
	if (o1HasYoung
	 && ((	/* begin isOldObject: */
		assert(isNonImmediate(obj1)),
	oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart))))) {
		fmt = (((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask());
		if (!(			/* begin isPureBitsFormat: */
				(fmt >= (sixtyFourBitIndexableFormat()))
			 && (fmt < (firstCompiledMethodFormat())))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(obj1)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj1);
			}
		}
	}
	if (o2HasYoung
	 && ((	/* begin isOldObject: */
		assert(isNonImmediate(obj2)),
	oopisGreaterThanOrEqualTo(obj2, GIV(oldSpaceStart))))) {
		fmt = (((usqInt)((longAt(obj2)))) >> (formatShift())) & (formatMask());
		if (!(			/* begin isPureBitsFormat: */
				(fmt >= (sixtyFourBitIndexableFormat()))
			 && (fmt < (firstCompiledMethodFormat())))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(obj2)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj2);
			}
		}
	}
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* SpurMemoryManager>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj)
{
	assert(addressCouldBeClassObj(classObj));
	return (((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
}

	/* SpurMemoryManager>>#instantiateClass: */
static NoDbgRegParms sqInt
instantiateClass(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    sqInt numSlots;
    usqInt p;

	classFormat = ((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3);
	instSpec = (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (!(		/* begin isFixedSizePointerFormat: */
			(instSpec <= 1 /* begin nonIndexablePointerFormat */)
		 || (instSpec == 5 /* begin ephemeronFormat */))) {
		return null;
	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	flag("todo");
	classIndex = (((hash = (long32At(classObj + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(classObj)
				? (((err = enterIntoClassTable(classObj))) != 0
						? -err
						: (long32At(classObj + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -classIndex;
		return null;
	}
	numSlots = classFormat & ((1U << (fixedFieldsFieldWidth())) - 1);
	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		if ((((usqInt)(numSlots)) >> 56) > 0) {
			newObj = null;
			goto l1;
		}
		newObj1 = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {
		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(newObj1, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec) << (formatShift()))))) + classIndex);
	}
	else {
		longAtput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(instSpec) << (formatShift()))))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
			longAtput(p, GIV(nilObj));
		}
	}
	return newObj;
}

	/* SpurMemoryManager>>#instSpecOfClassFormat: */
sqInt
instSpecOfClassFormat(sqInt classFormat)
{
	return (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
}


/*	This field in a class's format inst var corresponds to the 5-bit format
	field stored in every object header
 */

	/* SpurMemoryManager>>#instSpecOfClass: */
static NoDbgRegParms sqInt
instSpecOfClass(sqInt classPointer)
{
	return (((usqInt)((((longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
}

	/* SpurMemoryManager>>#invalidCompactClassError: */
static NoDbgRegParms void
invalidCompactClassError(const char *className)
{
	printf("\nClass %s does not have the required class index\n", className);
	exit(-1);
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArray: */
sqInt
isArray(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) == (arrayFormat()));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	This is for assert-checking only. */

	/* SpurMemoryManager>>#isBridgeOrEnumerableObjectNoAssert: */
static NoDbgRegParms int
isBridgeOrEnumerableObjectNoAssert(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = (longAt(objOop)) & (classIndexMask());
	return (classIndex >= (isForwardedObjectClassIndexPun())
		? classIndex < (GIV(numClassTablePages) * (1U << (classTableMajorIndexShift())))
		: classIndex == (segmentBridgePun()));
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* SpurMemoryManager>>#isBytes: */
sqInt
isBytes(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
}

	/* SpurMemoryManager>>#isCharacterObject: */
int
isCharacterObject(sqInt oop)
{
	return ((oop & (characterTag())) != 0);
}

	/* SpurMemoryManager>>#isCharacterValue: */
int
isCharacterValue(sqInt anInteger)
{
	return ((anInteger >= 0) && (anInteger <= (0x3FFFFFFF)));
}


/*	Answer if aClass exists at only one index in the class table. Be careful
	not to
	be misled by classes that have puns, such as Array. */

	/* SpurMemoryManager>>#isClassAtUniqueIndex: */
static NoDbgRegParms sqInt
isClassAtUniqueIndex(sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt entry;
    sqInt expectedIndex;
    sqInt i;
    sqInt index;
    sqInt index1;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	entry = 0;
	index = 0;
	expectedIndex = (long32At(aClass + 4)) & (identityHashHalfWordMask());
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		for (j = 0, jLimiT = ((1U << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))));
			if (classOrNil != GIV(nilObj)) {
				index1 = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
				if ((classOrNil == aClass)
				 && ((index1 != expectedIndex)
				 && (index1 > (lastClassIndexPun())))) {
					return 0;
				}
			}
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#isCompiledMethodFormat: */
static NoDbgRegParms int
isCompiledMethodFormat(sqInt format)
{
	return format >= (firstCompiledMethodFormat());
}


/*	Answer whether the argument header has compiled method format */

	/* SpurMemoryManager>>#isCompiledMethodHeader: */
static NoDbgRegParms int
isCompiledMethodHeader(sqInt objHeader)
{
	return ((((usqInt)(objHeader)) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat());
}


/*	Answer whether the argument object is of compiled method format */

	/* SpurMemoryManager>>#isCompiledMethod: */
int
isCompiledMethod(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat());
}

	/* SpurMemoryManager>>#isContextHeader: */
static NoDbgRegParms int
isContextHeader(sqInt aHeader)
{
	return (aHeader & (classIndexMask())) == ClassMethodContextCompactIndex;
}

	/* SpurMemoryManager>>#isContext: */
static NoDbgRegParms sqInt
isContext(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex);
}


/*	This is part of storeImageSegmentInto:outPointers:roots:. */

	/* SpurMemoryManager>>#isCopiedIntoSegment: */
static NoDbgRegParms int
isCopiedIntoSegment(sqInt anObjectInTheHeap)
{
	return ((((usqInt)((longAt(anObjectInTheHeap)))) >> (markedBitFullShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isEmptyObjStack: */
static NoDbgRegParms sqInt
isEmptyObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		return 1;
	}
	eassert(isValidObjStack(objStack));
	return (0 == (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))))
	 && (0 == (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))))));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	This is for assert-checking only. */

	/* SpurMemoryManager>>#isEnumerableObjectNoAssert: */
static NoDbgRegParms sqInt
isEnumerableObjectNoAssert(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = (longAt(objOop)) & (classIndexMask());
	return (classIndex >= (isForwardedObjectClassIndexPun()))
	 && (classIndex < (GIV(numClassTablePages) * (1U << (classTableMajorIndexShift()))));
}

	/* SpurMemoryManager>>#isEphemeron: */
static NoDbgRegParms int
isEphemeron(sqInt objOop)
{
    sqInt format;

	assert(isNonImmediate(objOop));
	format = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin isEphemeronFormat: */
	return format == 5 /* begin ephemeronFormat */;
}

	/* SpurMemoryManager>>#isFixedSizePointerFormat: */
sqInt
isFixedSizePointerFormat(sqInt format)
{
	return (format <= 1 /* begin nonIndexablePointerFormat */)
	 || (format == 5 /* begin ephemeronFormat */);
}

	/* SpurMemoryManager>>#isForwardedClassTag: */
static NoDbgRegParms int
isForwardedClassTag(sqInt classIndex)
{
	return classIndex == (isForwardedObjectClassIndexPun());
}


/*	Answer if objOop is that if a forwarder. Take advantage of
	isForwardedObjectClassIndexPun being a power of two to generate a more
	efficient test than the straight-forward
	(self classIndexOf: objOop) = self isForwardedObjectClassIndexPun
	at the cost of this being ambiguous with free chunks. So either never
	apply this to free chunks
	or guard with (self isFreeObject: foo) not. So far the idiom has been to
	guard with isFreeObject: */
/*	self assert: (self isFreeObject: objOop) not. */

	/* SpurMemoryManager>>#isForwarded: */
int
isForwarded(sqInt objOop)
{
	return (!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))));
}

	/* SpurMemoryManager>>#isFreeObject: */
static NoDbgRegParms int
isFreeObject(sqInt objOop)
{
	return ((longAt(objOop)) & (classIndexMask())) == (isFreeObjectClassIndexPun());
}

	/* SpurMemoryManager>>#isFreeOop: */
static NoDbgRegParms sqInt
isFreeOop(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun()));
}

	/* SpurMemoryManager>>#isImmediate: */
int
isImmediate(sqInt oop)
{
	return ((oop & (tagMask())) != 0);
}

	/* SpurMemoryManager>>#isInClassTable: */
static NoDbgRegParms sqInt
isInClassTable(sqInt objOop)
{
    sqInt hash;

	hash = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	return (hash != 0)
	 && ((classAtIndex(hash)) == objOop);
}

	/* SpurMemoryManager>>#isIndexable: */
sqInt
isIndexable(sqInt objOop)
{
    sqInt fmt;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	return 
	/* begin isIndexableFormat: */
(fmt >= (arrayFormat()))
	 && ((fmt <= (weakArrayFormat()))
	 || (fmt >= (sixtyFourBitIndexableFormat())));
}

	/* SpurMemoryManager>>#isInEden: */
static NoDbgRegParms sqInt
isInEden(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(objOop, ((eden()).start), GIV(freeStart));
}

	/* SpurMemoryManager>>#isInFutureSpace: */
static NoDbgRegParms sqInt
isInFutureSpace(sqInt address)
{
	return oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart());
}


/*	Answer if the given address is in ST object memory. */

	/* SpurMemoryManager>>#isInMemory: */
sqInt
isInMemory(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	if (	/* begin isInNewSpace: */
		(oopisLessThan(address, GIV(oldSpaceStart)))
	 && (oopisGreaterThanOrEqualTo(address, GIV(newSpaceStart)))) {
		return (oopisGreaterThanOrEqualToandLessThan(address, ((eden()).start), GIV(freeStart)))
		 || ((oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart)))
		 || ((GIV(gcPhaseInProgress) == ScavengeInProgress)
		 && (oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart()))));
	}
	/* begin isInSegments: */
	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#isInNewSpace: */
static NoDbgRegParms sqInt
isInNewSpace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisLessThan(objOop, GIV(oldSpaceStart)))
	 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart)));
}

	/* SpurMemoryManager>>#isInOldSpace: */
sqInt
isInOldSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory));
}

	/* SpurMemoryManager>>#isInPastSpace: */
static NoDbgRegParms sqInt
isInPastSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart));
}

	/* SpurMemoryManager>>#isLargeFreeObject: */
static NoDbgRegParms int
isLargeFreeObject(sqInt objOop)
{
	return (bytesInBody(objOop)) >= (0x200);
}


/*	Answer if the argument contains only indexable 64-bit double words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isLong64s: */
sqInt
isLong64s(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) == (sixtyFourBitIndexableFormat()));
}

	/* SpurMemoryManager>>#isMaybeFiredEphemeron: */
static NoDbgRegParms sqInt
isMaybeFiredEphemeron(sqInt objOop)
{
    sqInt format;

	format = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin isMaybeFiredEphemeronFormat: */
	return (format <= 5 /* begin lastPointerFormat */)
	 && ((format & 1));
}

	/* SpurMemoryManager>>#isNonImmediate: */
int
isNonImmediate(sqInt oop)
{
	return (!(oop & (tagMask())));
}

	/* SpurMemoryManager>>#isObjEphemeron: */
static NoDbgRegParms int
isObjEphemeron(sqInt objOop)
{
    sqInt format;

	format = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin isEphemeronFormat: */
	return format == 5 /* begin ephemeronFormat */;
}

	/* SpurMemoryManager>>#isObjImmutable: */
static NoDbgRegParms sqInt
isObjImmutable(sqInt anOop)
{
	return 
#  if IMMUTABILITY
		((((usqInt)((longAt(anOop)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		;
}


/*	Answer if obj is old. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isOldObject: */
static NoDbgRegParms int
isOldObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart));
}


/*	Answer whether the oop is an object of compiled method format */

	/* SpurMemoryManager>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()));
}

	/* SpurMemoryManager>>#isOopForwarded: */
sqInt
isOopForwarded(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))));
}

	/* SpurMemoryManager>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt oop)
{
	return (((oop & (tagMask())) != 0))
	 || (((((usqInt)((longAt(oop)))) >> (immutableBitShift())) & 1) != 0);
}

	/* SpurMemoryManager>>#isOopMutable: */
sqInt
isOopMutable(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (!(((((usqInt)((longAt(oop)))) >> (immutableBitShift())) & 1) != 0));
}

	/* SpurMemoryManager>>#isPinned: */
int
isPinned(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0;
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointers: */
sqInt
isPointers(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */);
}


/*	the inverse of isAnyPointerFormat: */

	/* SpurMemoryManager>>#isPureBitsFormat: */
static NoDbgRegParms sqInt
isPureBitsFormat(sqInt format)
{
	return (format >= (sixtyFourBitIndexableFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isPureBitsNonImm: */
static NoDbgRegParms sqInt
isPureBitsNonImm(sqInt objOop)
{
    sqInt format;

	format = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin isPureBitsFormat: */
	return (format >= (sixtyFourBitIndexableFormat()))
	 && (format < (firstCompiledMethodFormat()));
}

	/* SpurMemoryManager>>#isRemembered: */
static NoDbgRegParms int
isRemembered(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0;
}


/*	Maybe this should be in SpurSegmentManager only */

	/* SpurMemoryManager>>#isSegmentBridge: */
static NoDbgRegParms int
isSegmentBridge(sqInt objOop)
{
	return ((longAt(objOop)) & (classIndexMask())) == (segmentBridgePun());
}

	/* SpurMemoryManager>>#isSemaphoreOop: */
static NoDbgRegParms sqInt
isSemaphoreOop(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((!(anOop & (tagMask()))))
	 && (((longAt(anOop)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord()))))))));
}


/*	Answer if the argument contains only indexable 16-bit half words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isShorts: */
sqInt
isShorts(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstShortFormat())) && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= ((firstByteFormat()) - 1))));
}


/*	This version is private to SpurMemoryManager (for asserts, etc). It does
	not take advantage of the power-of-two optimization in isForwarded:. */

	/* SpurMemoryManager>>#isUnambiguouslyForwarder: */
static NoDbgRegParms int
isUnambiguouslyForwarder(sqInt objOop)
{
	return ((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun());
}


/*	For debugging using printOopsSuchThat: */

	/* SpurMemoryManager>>#isUnmarked: */
int
isUnmarked(sqInt objOop)
{
	return !(((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0);
}

	/* SpurMemoryManager>>#isValidClassTag: */
sqInt
isValidClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	assert(((classIndex >= 0) && (classIndex <= ((1U << (classIndexFieldWidth())) - 1))));
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		classOrNil = GIV(nilObj);
		goto l2;
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	classOrNil = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l2:	/* end classOrNilAtIndex: */;
	return (classOrNil != GIV(nilObj))
	 && (((long32At(classOrNil + 4)) & (identityHashHalfWordMask())) == classIndex);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackAt: */
static NoDbgRegParms sqInt
isValidObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackOrNil;

	stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord())))));
	return (stackOrNil == GIV(nilObj))
	 || (isValidObjStackPagemyIndexfirstPage(stackOrNil, objStackRootIndex, 1));
}


/*	Just check the page itself. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex: */
static NoDbgRegParms sqInt
isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(((longAt(objStackPage)) & (classIndexMask())) == (sixtyFourBitLongsClassIndexPun()))) {
		GIV(objStackInvalidBecause) = "wrong class index";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(((((usqInt)((longAt(objStackPage)))) >> (formatShift())) & (formatMask())) == (sixtyFourBitIndexableFormat()))) {
		GIV(objStackInvalidBecause) = "wrong format";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((numSlotsOfAny(objStackPage)) == ObjStackPageSlots)) {
		GIV(objStackInvalidBecause) = "wrong num slots";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(myx == (longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord())))))))) {
		GIV(objStackInvalidBecause) = "wrong myx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (GIV(marking)
	 && (!(((((usqInt)((longAt(objStackPage)))) >> (markedBitFullShift())) & 1) != 0))) {
		GIV(objStackInvalidBecause) = "marking but page is unmarked";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return 1;
}


/*	Answer if the obj stack at stackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex:firstPage: */
static NoDbgRegParms sqInt
isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    char *ns;
    sqInt page;
    char *s1;

	if (!(isValidObjStackPagemyIndex(objStackPage, myx))) {
		return 0;
	}
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
	while (freeOrNextPage != 0) {
		if (!isFirstPage) {
			GIV(objStackInvalidBecause) = "free page on other than first page";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (freeOrNextPage == (longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord()))))))) {
			GIV(objStackInvalidBecause) = "free page = next page";
			GIV(invalidObjStackPage) = freeOrNextPage;
			return 0;
		}
		if (!(isValidObjStackPagemyIndex(freeOrNextPage, myx))) {
			s1 = GIV(objStackInvalidBecause);
			/* begin stretch:cat: */
			ns = malloc(((strlen(s1)) + (14)) + 2);
			strcpy(ns, s1);
			GIV(objStackInvalidBecause) = ((char *) (strcat(ns, ", on next page")));
			return 0;
		}
		page = longAt((freeOrNextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
		if ((page == freeOrNextPage)
		 || (page == objStackPage)) {
			GIV(objStackInvalidBecause) = "circularity in free page list";
			GIV(invalidObjStackPage) = page;
			return 0;
		}
		freeOrNextPage = page;
	}
	if (isFirstPage) {
		if (!(((myx >= (1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift())))) && (myx <= (((1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift()))) + 8 /* begin hiddenRootSlots */) - 1))))) {
			GIV(objStackInvalidBecause) = "myx out of range";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (!((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(myx) << (shiftForWord())))))) == objStackPage)) {
			GIV(objStackInvalidBecause) = "firstPage is not root";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
	}
	index = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
	if (!(((index >= 0) && (index <= ObjStackLimit)))) {
		GIV(objStackInvalidBecause) = "bad topx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	if (freeOrNextPage == 0) {
		return 1;
	}
	if (freeOrNextPage == objStackPage) {
		GIV(objStackInvalidBecause) = "circularity in objStack page list";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(freeOrNextPage, myx, 0);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStack: */
static NoDbgRegParms sqInt
isValidObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((addressCouldBeObj(objStack))
		 && ((numSlotsOfAny(objStack)) == ObjStackPageSlots))) {
		GIV(objStackInvalidBecause) = "first page not obj or wrong size";
		GIV(invalidObjStackPage) = objStack;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(objStack, longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord()))))), 1);
}

	/* SpurMemoryManager>>#isWeakNonImm: */
static NoDbgRegParms int
isWeakNonImm(sqInt objOop)
{
    sqInt format;

	format = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin isWeakFormat: */
	return format == (weakArrayFormat());
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWeak: */
sqInt
isWeak(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (isWeakNonImm(oop));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytesNonImm: */
static NoDbgRegParms sqInt
isWordsOrBytesNonImm(sqInt objOop)
{
    sqInt format;

	format = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin isPureBitsFormat: */
	return (format >= (sixtyFourBitIndexableFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytes: */
sqInt
isWordsOrBytes(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (isWordsOrBytesNonImm(oop));
}


/*	Answer if the argument contains only indexable 16-bit half words or 32-bit
	indexable words (no oops).
	See comment in formatOf: */

	/* SpurMemoryManager>>#isWordsOrShorts: */
sqInt
isWordsOrShorts(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= ((firstByteFormat()) - 1))));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWords: */
sqInt
isWords(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (((((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstLongFormat())) && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= ((firstShortFormat()) - 1))));
}


/*	Answer if obj is young. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isYoungObject: */
int
isYoungObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisLessThan(objOop, GIV(oldSpaceStart));
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isYoung: */
sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((!(oop & (tagMask()))))
	 && (oopisLessThan(oop, GIV(oldSpaceStart)));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* SpurMemoryManager>>#is:instanceOf:compactClassIndex: */
static NoDbgRegParms sqInt
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if (((oop & (tagMask())) != 0)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	else {
		return classOop == (classAtIndex(ccIndex));
	}
}

	/* SpurMemoryManager>>#is:onObjStack: */
static NoDbgRegParms sqInt
isonObjStack(sqInt oop, sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt nextPage;

	if (objStack == GIV(nilObj)) {
		return 0;
	}
	assert((numSlotsOfAny(objStack)) == ObjStackPageSlots);
	index = (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		if (oop == (longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord()))))))) {
			return 1;
		}
		index -= 1;
	}
	nextPage = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	if (nextPage != 0) {
		if (isonObjStack(oop, nextPage)) {
			return 1;
		}
	}
	return 0;
}


/*	Answer the object the ephemeron guards. This is its first element. */

	/* SpurMemoryManager>>#keyOfEphemeron: */
static NoDbgRegParms sqInt
keyOfEphemeron(sqInt objOop)
{
	assert((isNonImmediate(objOop))
	 && (isObjEphemeron(objOop)));
	return longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
}

	/* SpurMemoryManager>>#knownClassAtIndex: */
static NoDbgRegParms sqInt
knownClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(((classIndex >= 1) && (classIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(classIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#lastPointerFormat */
static sqInt
lastPointerFormat(void)
{
	return 5;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects.
	Does not examine the stack pointer of contexts to be sure to swizzle
	the nils that fill contexts on snapshot.
	It is invariant that on image load no object contains a forwarding
	pointer, and the image contains no forwarders (see class comment). */

	/* SpurMemoryManager>>#lastPointerOfWhileSwizzling: */
static NoDbgRegParms sqInt
lastPointerOfWhileSwizzling(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt header1;
    usqInt numSlots;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5 /* begin lastPointerFormat */) {
		return ((((/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header1 = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	return (((((/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#lastPointerOf: */
static NoDbgRegParms sqInt
lastPointerOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    usqInt numSlots;
    sqInt sp;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5 /* begin lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
	l1:	/* end fetchStackPointerOf: */;
			return (((CtxtTempFrameStart - 1) + contextSize) * BytesPerOop) + BaseHeaderSize;
		}
		return ((((/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header1 = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	return (((((/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1)),
((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* SpurMemoryManager>>#leakCheckFullGC */
int
leakCheckFullGC(void)
{
	return ((checkForLeaks & GCModeFull) != 0);
}

	/* SpurMemoryManager>>#leakCheckNewSpaceGC */
int
leakCheckNewSpaceGC(void)
{
	return ((checkForLeaks & GCModeNewSpace) != 0);
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* SpurMemoryManager>>#lengthOfMaybeImmediate: */
static NoDbgRegParms sqInt
lengthOfMaybeImmediate(sqInt oop)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	if (((oop & (tagMask())) != 0)) {
		return 0;
	}
	/* begin lengthOf: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes) should
	be subtracted from the result. */

	/* SpurMemoryManager>>#lengthOf: */
static NoDbgRegParms sqInt
lengthOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin lengthOf:format: */
	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(objOop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}

	/* SpurMemoryManager>>#literalCountOfMethodHeader: */
sqInt
literalCountOfMethodHeader(sqInt header)
{
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}

	/* SpurMemoryManager>>#literalCountOf: */
sqInt
literalCountOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	header1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}


/*	This primitive is called from Smalltalk as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed.
	It will return as its value the original array of roots, and the
	segmentWordArray will become an
	array of the loaded objects. If this primitive should fail, the
	segmentWordArray will, sadly, have
	been reduced to an unrecognizable and unusable jumble. But what more could
	you have done
	with it anyway?
	
	The primitive, if it succeeds, also becomes the segmentWordArray into the
	array of loaded objects.
	This allows fixing up of loaded objects directly, without nextObject,
	which Spur doesn't support. */

	/* SpurMemoryManager>>#loadImageSegmentFrom:outPointers: */
static NoDbgRegParms NeverInline sqInt
loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt classIndex3;
    sqInt classIndex4;
    sqInt classOop;
    sqInt classRef;
    sqInt clone;
    sqInt err;
    sqInt errorCode;
    sqInt errorCode1;
    sqInt fillIdx;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt loadedObjectsArray;
    usqInt mappedOop;
    sqInt numLoadedObjects;
    usqInt numOutPointers;
    sqInt numSegObjs;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oldClone;
    sqInt oop;
    sqInt oop1;
    usqInt oop2;
    sqInt scanClassTable;
    usqInt segmentLimit;
    sqInt segmentStart;
    sqInt segVersion;


	/* begin numSlotsOf: */
	assert((classIndexOf(segmentWordArray)) > (isForwardedObjectClassIndexPun()));
	segmentLimit = (((numSlots = byteAt(segmentWordArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(segmentWordArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if ((	/* begin objectBytesForSlots: */
		(segmentLimit == 0
		? 8 /* begin allocationUnit */ + BaseHeaderSize
		: (segmentLimit << (shiftForWord())) + ((segmentLimit >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)))) < (8 /* begin allocationUnit */ + BaseHeaderSize)) {
		/* version info */
		/* one object header */
		return PrimErrBadArgument;
	}
	segVersion = longAt(segmentWordArray + BaseHeaderSize);
	if (!(((((segVersion & 0xFFFFFF) | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */)) {
		/* low 3 bytes */
		reverseBytesIn32BitWordsIn(segmentWordArray);
		segVersion = longAt(segmentWordArray + BaseHeaderSize);
		if (!(((((segVersion & 0xFFFFFF) | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */)) {
			/* low 3 bytes */
			reverseBytesIn32BitWordsIn(segmentWordArray);
			return PrimErrBadArgument;
		}
	}
	segmentStart = (segmentWordArray + BaseHeaderSize) + 8 /* begin allocationUnit */;
	/* Notionally reverse the Byte type objects if the data is from opposite endian machine.
	   Test top byte.  $d on the Mac or $s on the PC.  Rest of word is equal.  If Spur is ever
	   ported to big-endian machines then the segment may have to be byte/word swapped,
	   but so far it only runs on little-endian machines, so for now just fail if endianness is wrong. */
	segmentLimit = ((segmentLimit * BytesPerOop) + segmentWordArray) + BaseHeaderSize;
	flag("endianness");
	if (((((usqInt)(segVersion)) >> 24) & 0xFF) != ((((usqInt)((imageSegmentVersion()))) >> 24) & 0xFF)) {
		/* Reverse the byte-type objects once */
		return PrimErrBadArgument;
	}
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(segmentWordArray)),
	oopisGreaterThanOrEqualTo(segmentWordArray, GIV(oldSpaceStart)))) {
		/* begin ensureNoNewObjectsIn: */
		scanClassTable = 0;
		for (i = 0, iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun())),
(((numSlots3 = byteAt(outPointerArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3))) - 1); i <= iLimiT; i += 1) {
			oop1 = longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (			/* begin isYoung: */
				((!(oop1 & (tagMask()))))
			 && (oopisLessThan(oop1, GIV(oldSpaceStart)))) {
				clone = cloneInOldSpaceforPinning(oop1, 0);
				if (clone == 0) {
					errorCode = PrimErrNoMemory;
					goto l12;
				}
				if ((((hash1 = (long32At(oop1 + 4)) & (identityHashHalfWordMask()))) != 0)
				 && ((classOrNilAtIndex(hash1)) == oop1)) {
					scanClassTable = 1;
				}
				/* begin forward:to: */
				classIndex3 = isForwardedObjectClassIndexPun();
				assert(((classIndex3 >= 0) && (classIndex3 <= (classIndexMask()))));
				assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
				longAtput(oop1, ((longAt(oop1)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex3 + (7U << (formatShift()))));
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(oop1, (longAt(oop1)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#        endif // IMMUTABILITY

				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(oop1));
				assert(!(isOopForwarded(clone)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(oop1)),
				oopisGreaterThanOrEqualTo(oop1, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(clone & (tagMask()))))
					 && (oopisLessThan(clone, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(oop1)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(oop1);
						}
					}
				}
				longAtput((oop1 + BaseHeaderSize) + (0U << (shiftForWord())), clone);
				if ((byteAt(oop1 + 7)) == 0) {
					/* begin rawNumSlotsOf:put: */
					byteAtput(oop1 + 7, 1);
				}
				assert(!(isOopForwarded(outPointerArray)));
				longAtput((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), clone);
			}
		}
		if (scanClassTable) {
			postBecomeScanClassTable(BecamePointerObjectFlag);
		}
		errorCode = 0;
	l12:	/* end ensureNoNewObjectsIn: */;
		if (errorCode != 0) {
			return errorCode;
		}
	}
	/* begin mapOopsAndValidateClassRefsFrom:to:outPointers: */
	assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun()));
	numOutPointers = (((numSlots4 = byteAt(outPointerArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots4);
	numSegObjs = 0;
	/* begin objectStartingAt: */
	numSlots11 = byteAt(segmentStart + 7);
	objOop2 = (numSlots11 == (numSlotsMask())
		? segmentStart + BaseHeaderSize
		: segmentStart);
	while (oopisLessThan(objOop2, segmentLimit)) {
		/* No object in the segment should be marked.  If is is something is wrong. */
		numSegObjs += 1;
		if (((((usqInt)((longAt(objOop2)))) >> (markedBitFullShift())) & 1) != 0) {
			errorCode = PrimErrInappropriate;
			goto l15;
		}
		/* validate the class ref, but don't update it until any internal classes have been added to the class table. */
		classIndex4 = (longAt(objOop2)) & (classIndexMask());
		if (((classIndex4 & TopHashBit) != 0)) {
			classIndex4 -= TopHashBit;
			if (classIndex4 >= numOutPointers) {
				errorCode = PrimErrBadIndex;
				goto l15;
			}
			mappedOop = longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(classIndex4) << (shiftForWord())))));
			hash2 = (long32At(mappedOop + 4)) & (identityHashHalfWordMask());
			if (!((hash2 == 0)
				 || ((hash2 > (lastClassIndexPun()))
				 && ((classOrNilAtIndex(hash2)) == mappedOop)))) {
				errorCode = PrimErrInappropriate;
				goto l15;
			}
		}
		else {
			/* The class is contained within the segment. */
			if (((oop2 = ((classIndex4 - (firstClassIndexPun())) * 8 /* begin allocationUnit */) + segmentStart)) >= segmentLimit) {
				errorCode = PrimErrBadIndex;
				goto l15;
			}
			if (((long32At(oop2 + 4)) & (identityHashHalfWordMask())) != 0) {
				errorCode = PrimErrInappropriate;
				goto l15;
			}
		}
		for (i1 = 0, iLimiT1 = ((numPointerSlotsOf(objOop2)) - 1); i1 <= iLimiT1; i1 += 1) {
			oop2 = longAt((objOop2 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			if ((!(oop2 & (tagMask())))) {
				if (((oop2 & TopOopBit) != 0)) {
					if (((oop2 = (oop2 - TopOopBit) / BytesPerOop)) >= numOutPointers) {
						errorCode = PrimErrBadIndex;
						goto l15;
					}
					mappedOop = longAt((outPointerArray + BaseHeaderSize) + (oop2 << (shiftForWord())));
				}
				else {
					if ((oop2 & (7)) != 0) {
						errorCode = PrimErrInappropriate;
						goto l15;
					}
					if (((mappedOop = oop2 + segmentStart)) >= segmentLimit) {
						errorCode = PrimErrBadIndex;
						goto l15;
					}
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(objOop2)));
				longAtput((objOop2 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), mappedOop);
			}
		}
		/* begin objectAfter:limit: */
		followingWordAddress3 = addressAfter(objOop2);
		if (oopisGreaterThanOrEqualTo(followingWordAddress3, segmentLimit)) {
			objOop2 = segmentLimit;
			goto l14;
		}
		flag("endianness");
		followingWord3 = longAt(followingWordAddress3);
		objOop2 = ((((usqInt)(followingWord3)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress3 + BaseHeaderSize
			: followingWordAddress3);
	l14:	/* end objectAfter:limit: */;
	}
	errorCode = -numSegObjs;
	l15:	/* end mapOopsAndValidateClassRefsFrom:to:outPointers: */;
	if (errorCode > 0) {
		return errorCode;
	}
	numLoadedObjects = -errorCode;
	loadedObjectsArray = noInlineAllocateSlotsformatclassIndex(numLoadedObjects, arrayFormat(), ClassArrayCompactIndex);
	if (!loadedObjectsArray) {
		growOldSpaceByAtLeast((BaseHeaderSize + BaseHeaderSize) + (numLoadedObjects * BytesPerOop));
		loadedObjectsArray = noInlineAllocateSlotsformatclassIndex(numLoadedObjects, arrayFormat(), ClassArrayCompactIndex);
		if (!loadedObjectsArray) {
			return PrimErrNoMemory;
		}
	}
	/* begin enterClassesIntoClassTableFrom:to: */
	objOop = objectAfter(objectStartingAt(segmentStart));
	while ((oopisLessThan(objOop, segmentLimit))
	 && (((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
		/* begin setIsRememberedOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (rememberedBitShift()))));
		if (((errorCode1 = enterIntoClassTable(objOop))) != 0) {
			oop = objOop;
			objOop = objectAfter(objectStartingAt(segmentStart));
			while (oopisLessThan(objOop, oop)) {
				expungeFromClassTable(objOop);
				/* begin objectAfter:limit: */
				followingWordAddress = addressAfter(objOop);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, segmentLimit)) {
					objOop = segmentLimit;
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
			}
			errorCode = errorCode1;
			goto l3;
		}
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, segmentLimit)) {
			objOop = segmentLimit;
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l2:	/* end objectAfter:limit: */;
	}
	errorCode = 0;
	l3:	/* end enterClassesIntoClassTableFrom:to: */;
	if (errorCode != 0) {
		return errorCode;
	}
	/* begin assignClassIndicesAndPinFrom:to:outPointers:filling: */
	numSlots2 = byteAt(segmentStart + 7);
	objOop1 = (numSlots2 == (numSlotsMask())
		? segmentStart + BaseHeaderSize
		: segmentStart);
	fillIdx = 0;
	while (oopisLessThan(objOop1, segmentLimit)) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(loadedObjectsArray)));
		longAtput((loadedObjectsArray + BaseHeaderSize) + (((sqInt)((usqInt)(fillIdx) << (shiftForWord())))), objOop1);
		/* In the segment, class indices are offset indexes into the segment data,
		   or into outPointers.  See mapOopsFrom:to:outPointers:outHashes: and
		   newOutPointer:at:in:hashes:. */
		fillIdx += 1;
		classRef = (longAt(objOop1)) & (classIndexMask());
		classOop = (((classRef & TopHashBit) != 0)
			? longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)((classRef - TopHashBit)) << (shiftForWord())))))
			: ((classRef - (firstClassIndexPun())) * 8 /* begin allocationUnit */) + segmentStart);
		classIndex = (long32At(classOop + 4)) & (identityHashHalfWordMask());
		if (classIndex == 0) {
			/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(classOop));
			flag("todo");
			if (((hash = (long32At(classOop + 4)) & (identityHashHalfWordMask()))) != 0) {
				classIndex = hash;
			}
			else {
				if (objCouldBeClassObj(classOop)) {
					if (((err = enterIntoClassTable(classOop))) != 0) {
						classIndex = -err;
					}
					else {
						classIndex = (long32At(classOop + 4)) & (identityHashHalfWordMask());
					}
				}
				else {
					classIndex = -PrimErrBadReceiver;
				}
			}
			if (classIndex < 0) {
				/* Error code e.g. - PrimErrNoMemory */
				errorCode = -classIndex;
				goto l9;
			}
		}
		assert((classIndex > (lastClassIndexPun()))
		 && ((classOrNilAtIndex(classIndex)) == classOop));
		/* begin setClassIndexOf:to: */
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
		longAtput(objOop1, ((longAt(objOop1)) & (~(usqIntptr_t)(classIndexMask()))) + classIndex);
		if ((		/* begin isInNewSpace: */
			(oopisLessThan(objOop1, GIV(oldSpaceStart)))
		 && (oopisGreaterThanOrEqualTo(objOop1, GIV(newSpaceStart))))
		 && (((((usqInt)((longAt(objOop1)))) >> (pinnedBitShift())) & 1) != 0)) {
			oldClone = cloneInOldSpaceforPinning(objOop1, 1);
			if (oldClone != 0) {
				/* begin setIsPinnedOf:to: */
				longAtput(oldClone, (longAt(oldClone)) | (1U << (pinnedBitShift())));
				/* begin forward:to: */
				classIndex1 = isForwardedObjectClassIndexPun();
				assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask()))));
				assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
				longAtput(objOop1, ((longAt(objOop1)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex1 + (7U << (formatShift()))));
#        if IMMUTABILITY
				/* begin setIsImmutableOf:to: */
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#        endif // IMMUTABILITY

				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(objOop1));
				assert(!(isOopForwarded(oldClone)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(objOop1)),
				oopisGreaterThanOrEqualTo(objOop1, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(oldClone & (tagMask()))))
					 && (oopisLessThan(oldClone, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(objOop1)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(objOop1);
						}
					}
				}
				longAtput((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())), oldClone);
				if ((byteAt(objOop1 + 7)) == 0) {
					/* begin rawNumSlotsOf:put: */
					byteAtput(objOop1 + 7, 1);
				}
			}
		}
		followingWordAddress2 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, segmentLimit)) {
			objOop1 = segmentLimit;
			goto l8;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop1 = ((((usqInt)(followingWord2)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l8:	/* end objectAfter:limit: */;
	}
	errorCode = 0;
	l9:	/* end assignClassIndicesAndPinFrom:to:outPointers:filling: */;
	if (errorCode != 0) {
		return errorCode;
	}
	if ((byteAt(segmentWordArray + 7)) == (numSlotsMask())) {
		/* N.B. setting the overflow slots to 1 creates a slimbridge in eden, so we also need to delete the overflow slot count in the segment itself */
		if (oopisLessThan(segmentWordArray, GIV(oldSpaceStart))) {
			/* begin rawOverflowSlotsOf:put: */
			longAtput(segmentWordArray - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask())) << 56))));
			/* begin rawNumSlotsOf:put: */
			byteAtput(segmentWordArray + 7, 0);
		}
		else {
			/* begin rawOverflowSlotsOf:put: */
			longAtput(segmentWordArray - BaseHeaderSize, (((sqInt)((usqInt)((numSlotsMask())) << 56))) + (8 /* begin allocationUnit */ / BytesPerOop));
			8 /* begin allocationUnit */ / BytesPerOop;
		}
	}
	else {
		/* begin rawNumSlotsOf:put: */
		byteAtput(segmentWordArray + 7, 8 /* begin allocationUnit */ / BytesPerOop);
	}
	classIndex2 = isForwardedObjectClassIndexPun();
	assert(((classIndex2 >= 0) && (classIndex2 <= (classIndexMask()))));
	assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
	longAtput(segmentWordArray, ((longAt(segmentWordArray)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex2 + (7U << (formatShift()))));
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(segmentWordArray, (longAt(segmentWordArray)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#  endif // IMMUTABILITY

	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(segmentWordArray));
	assert(!(isOopForwarded(loadedObjectsArray)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(segmentWordArray)),
	oopisGreaterThanOrEqualTo(segmentWordArray, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(loadedObjectsArray & (tagMask()))))
		 && (oopisLessThan(loadedObjectsArray, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(segmentWordArray)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(segmentWordArray);
			}
		}
	}
	longAtput((segmentWordArray + BaseHeaderSize) + (0U << (shiftForWord())), loadedObjectsArray);
	if ((byteAt(segmentWordArray + 7)) == 0) {
		/* begin rawNumSlotsOf:put: */
		byteAtput(segmentWordArray + 7, 1);
	}
	runLeakCheckerFor(GCCheckImageSegment);
	/* begin objectStartingAt: */
	numSlots1 = byteAt(segmentStart + 7);
	return (numSlots1 == (numSlotsMask())
		? segmentStart + BaseHeaderSize
		: segmentStart);
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = (long32At(aClassOop + 4)) & (identityHashHalfWordMask());
	if (classIndex != (isFreeObjectClassIndexPun())) {
		longPrintInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing any and all objects whose classIndex equals the
	argument. 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintInstancesWithClassIndex: */
void
longPrintInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	obj = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((longAt(objOop)) & (classIndexMask())) == classIndex) {
			longPrintOop(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			longPrintOop(objOop1);
			cr();
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt prntObj;
    sqInt startObject;

	obj = 0;
	prntObj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots1 = byteAt(address + 7);
	startObject = (numSlots1 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if ((((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
			 || (((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
				if (((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
					i = (literalCountOf(obj1)) + LiteralStart;
				}
				else {
					if (((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						i = CtxtTempFrameStart + (fetchStackPointerOf(obj1));
					}
					else {
						/* begin numSlotsOf: */
						assert((classIndexOf(obj1)) > (isForwardedObjectClassIndexPun()));
						i = (((numSlots = byteAt(obj1 + 7))) == (numSlotsMask())
							? ((((usqInt)(((sqInt)((usqInt)((longAt(obj1 - BaseHeaderSize))) << 8)))))) >> 8
							: numSlots);
					}
				}
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
						printHex(obj1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" @ ");
						fprintf(GIV(transcript),
								"%" PRIdSQINT "",
								((sqInt)i));
						cr();
						prntObj = 1;
						i = 0;
					}
				}
				if (prntObj) {
					prntObj = 0;
					longPrintOop(obj1);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}

	/* SpurMemoryManager>>#mapExtraRoots */
static void
mapExtraRoots(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	if (shouldRemapObj(GIV(specialObjectsOop))) {
		GIV(validatedIntegerClassFlags) = 0;
		GIV(specialObjectsOop) = remapObj(GIV(specialObjectsOop));
	}
	assert(GIV(remapBufferCount) == 0);
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!((((oop & (tagMask())) != 0))
			 || (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())))) {
			if (shouldRemapObj(oop)) {
				(GIV(extraRoots)[i])[0] = (remapObj(oop));
			}
		}
	}
}

	/* SpurMemoryManager>>#mapMournQueue */
static NeverInline void
mapMournQueue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt mourner;
    sqInt numOnThisPage;
    sqInt objStackPage;
    sqInt page;
    sqInt referent;

	i = 0;
	page = 0;
	/* begin objStack:do: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l2;
	}
	eassert(isValidObjStack(GIV(mournQueue)));
	objStackPage = GIV(mournQueue);
	while (objStackPage != 0) {
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
		for (i1 = ((numOnThisPage + ObjStackFixedSlots) - 1); i1 >= ObjStackFixedSlots; i1 += -1) {
			mourner = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			if ((!(mourner & (tagMask())))) {
				/* someone could try and become weaklings into immediates... */
				if ((!((longAt(mourner)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(mourner));
					referent = longAt((mourner + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					mourner = referent;
				}
				if (!(isScavengeSurvivor(mourner))) {
					mourner = copyAndForwardMourner(mourner);
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(objStackPage)));
				longAtput((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), mourner);
			}
		}
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	}
	l2:	/* end objStack:do: */;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Now scan, adding out pointers to the outPointersArray; all objects in
	arrayOfObjects have had their first fields set to point to their copies in
	segmentWordArray. Answer
	the outIndex if the scan succeded. Fail if outPointers is too small and
	answer -1.
	
	As established by copyObj:toAddr:startAt:stopAt:savedFirstFields:index:,
	the marked bit is set for all objects in the segment
	the remembered bit is set for all classes in the segment.
	
	Class indices should be set as follows (see
	assignClassIndicesAndPinFrom:to:outPointers:filling:) - class indices for
	classes in the segment */

	/* SpurMemoryManager>>#mapOopsFrom:to:outPointers:outHashes: */
static NoDbgRegParms sqInt
mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt heapOop;
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;
    sqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt objIndex;
    sqInt objOop;
    sqInt oop;
    sqInt outIndex;
    usqInt p;
    sqInt segIndex;
    sqInt valueWord;
    sqInt valueWord1;


	/* objIndex is for debugging; it mirrors indices in the sender's arrayOfObjects. */
	outIndex = (objIndex = 0);
	/* begin numSlotsOf: */
	assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun()));
	if (((numSlots = byteAt(outPointerArray + 7))) == (numSlotsMask())) {
		/* overflow slots; at least (2^32)-1 slots, which is plenty */
		numSlots1 = ((((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8;
	}
	else {
		numSlots1 = numSlots;
	}
	/* begin fillObj:numSlots:with: */
	assert(oopisLessThan(((outPointerArray + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(outPointerArray)));
	for (p = (((usqInt)(outPointerArray + BaseHeaderSize))); p <= (((usqInt)(((outPointerArray + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
		longAtput(p, GIV(nilObj));
	}
	/* begin objectStartingAt: */
	numSlots2 = byteAt(segStart + 7);
	objOop = (numSlots2 == (numSlotsMask())
		? segStart + BaseHeaderSize
		: segStart);
	while (oopisLessThan(objOop, segAddr)) {
		/* Set the classIndex of the instance.  This is a segment offset (segAddr - segStart / allocationUnit) for instances of
		   classes within the segment, and an outPointer index (index in outPointers + TopHashBit) for classes outside the segment. */
		heapOop = fetchClassOfNonImm(objOop);
		if (((((usqInt)((longAt(heapOop)))) >> (markedBitFullShift())) & 1) != 0) {
			/* oop is a class in the segment; storeImageSegmentInto:outPointers:roots: established offset is within range. */
			oop = longAt((heapOop + BaseHeaderSize) + (0U << (shiftForWord())));
			assert(oopisGreaterThanOrEqualToandLessThan(oop, segStart, segAddr));
			segIndex = ((oop - segStart) / 8 /* begin allocationUnit */) + (firstClassIndexPun());
			if (((segIndex & TopHashBit) != 0)) {
				/* Too many classes in the segment */
				return -1;
			}
		}
		else {
			/* oop is an outPointer; locate or allocate its oop */
			hash = (long32At(heapOop + 4)) & (identityHashHalfWordMask());
			if (			/* begin is:outPointerClassHashFor:in:limit: */
				(((hash & TopHashBit) != 0))
			 && (((hash - TopHashBit) <= outIndex)
			 && (heapOop == (longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)((hash - TopHashBit)) << (shiftForWord()))))))))) {
				segIndex = hash;
			}
			else {
				/* oop is a new outPointer; allocate its oop */
				/* begin newOutPointer:at:in:hashes: */
				if (outIndex >= ((				/* begin numSlotsOf: */
					assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun())),
				(((numSlots3 = byteAt(outPointerArray + 7))) == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots3)))) {
					/* no room in outPointers; fail */
					outIndex = 0;
					goto l5;
				}
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(outPointerArray)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(outPointerArray)),
				oopisGreaterThanOrEqualTo(outPointerArray, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(heapOop & (tagMask()))))
					 && (oopisLessThan(heapOop, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(outPointerArray)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(outPointerArray);
						}
					}
				}
				longAtput((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << (shiftForWord())))), heapOop);
				valueWord = (long32At(heapOop + 4)) & (identityHashHalfWordMask());
				/* begin storeLong32:ofObject:withValue: */
				long32Atput((savedOutHashes + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << 2))), valueWord);
				hash1 = outIndex + TopHashBit;
				/* begin setHashBitsOf:to: */
				assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
				long32Atput(heapOop + 4, ((((long32At(heapOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
				outIndex += 1;
	l5:	/* end newOutPointer:at:in:hashes: */;
				if (outIndex == 0) {
					/* no room in outPointers; fail */
					return -1;
				}
				segIndex = (long32At(heapOop + 4)) & (identityHashHalfWordMask());
			}
			assert(((segIndex & TopHashBit) != 0));
		}
		/* begin setClassIndexOf:to: */
		assert(((segIndex >= 0) && (segIndex <= (classIndexMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(classIndexMask()))) + segIndex);
		for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
			heapOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if ((!(heapOop & (tagMask())))) {
				if (((((usqInt)((longAt(heapOop)))) >> (markedBitFullShift())) & 1) != 0) {
					/* oop is an object in the segment. */
					oop = longAt((heapOop + BaseHeaderSize) + (0U << (shiftForWord())));
					assert(oopisGreaterThanOrEqualToandLessThan(oop, segStart, segAddr));
					oop -= segStart;
				}
				else {
					/* oop is an outPointer; locate or allocate its oop */
					hash = (long32At(heapOop + 4)) & (identityHashHalfWordMask());
					if (					/* begin is:outPointerClassHashFor:in:limit: */
						(((hash & TopHashBit) != 0))
					 && (((hash - TopHashBit) <= outIndex)
					 && (heapOop == (longAt((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)((hash - TopHashBit)) << (shiftForWord()))))))))) {
						oop = ((hash - TopHashBit) * BytesPerOop) + TopOopBit;
					}
					else {
						/* oop is a new outPointer; allocate its oop */
						/* begin newOutPointer:at:in:hashes: */
						if (outIndex >= ((						/* begin numSlotsOf: */
							assert((classIndexOf(outPointerArray)) > (isForwardedObjectClassIndexPun())),
						(((numSlots4 = byteAt(outPointerArray + 7))) == (numSlotsMask())
								? ((((usqInt)(((sqInt)((usqInt)((longAt(outPointerArray - BaseHeaderSize))) << 8)))))) >> 8
								: numSlots4)))) {
							/* no room in outPointers; fail */
							outIndex = 0;
							goto l8;
						}
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(outPointerArray)));
						if ((						/* begin isOldObject: */
							assert(isNonImmediate(outPointerArray)),
						oopisGreaterThanOrEqualTo(outPointerArray, GIV(oldSpaceStart)))) {
							/* most stores into young objects */
							if (							/* begin isYoung: */
								((!(heapOop & (tagMask()))))
							 && (oopisLessThan(heapOop, GIV(oldSpaceStart)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt)((longAt(outPointerArray)))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(outPointerArray);
								}
							}
						}
						longAtput((outPointerArray + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << (shiftForWord())))), heapOop);
						valueWord1 = (long32At(heapOop + 4)) & (identityHashHalfWordMask());
						/* begin storeLong32:ofObject:withValue: */
						long32Atput((savedOutHashes + BaseHeaderSize) + (((sqInt)((usqInt)(outIndex) << 2))), valueWord1);
						hash2 = outIndex + TopHashBit;
						/* begin setHashBitsOf:to: */
						assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask()))));
						long32Atput(heapOop + 4, ((((long32At(heapOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash2);
						outIndex += 1;
	l8:	/* end newOutPointer:at:in:hashes: */;
						if (outIndex == 0) {
							/* no room in outPointers; fail */
							return -1;
						}
						assert((((rawHashBitsOf(heapOop)) & TopHashBit) != 0));
						oop = ((((long32At(heapOop + 4)) & (identityHashHalfWordMask())) - TopHashBit) * BytesPerOop) + TopOopBit;
					}
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(objOop)));
				longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), oop);
			}
		}
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, segAddr)) {
			objOop = segAddr;
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
		objIndex += 1;
	}
	return outIndex;
}


/*	Ensure the class of the argument is marked, pushing it on the markStack if
	not already marked.
	And for one-way become, which can create duplicate entries in the class
	table, make sure
	objOop's classIndex refers to the classObj's actual classIndex.
	Note that this is recursive, but the metaclass chain should terminate
	quickly. 
 */

	/* SpurMemoryManager>>#markAndTraceClassOf: */
static NoDbgRegParms void
markAndTraceClassOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classObj;
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt objStack;
    sqInt realClassIndex;

	classIndex = (longAt(objOop)) & (classIndexMask());
	/* begin classOrNilAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		classObj = GIV(nilObj);
		goto l2;
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	classObj = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
	l2:	/* end classOrNilAtIndex: */;
	assert(objCouldBeClassObj(classObj));
	realClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	if ((classIndex != realClassIndex)
	 && (classIndex > (lastClassIndexPun()))) {
		/* begin setClassIndexOf:to: */
		assert(((realClassIndex >= 0) && (realClassIndex <= (classIndexMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(classIndexMask()))) + realClassIndex);
	}
	if (!(((((usqInt)((longAt(classObj)))) >> (markedBitFullShift())) & 1) != 0)) {
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(classObj)));
		longAtput(classObj, (longAt(classObj)) | (1ULL << (markedBitFullShift())));
		markAndTraceClassOf(classObj);
		objStack = GIV(markStack);
		/* begin push:onObjStack: */
		assert(addressCouldBeOop(classObj));
		if (((classObj & (tagMask())) != 0)) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
				? fetchPointerofObject(ObjStackNextx, objStack)
				: objStack))));
		}
		else {
			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(classObj))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(classObj)));
		}
		noCheckPushonObjStack(classObj, objStack);
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such
	as the markStack or the ephemeronQueue. It is a linked list of
	segments, with the hot end at the head of the list. It is a word object.
	The stack pointer is in ObjStackTopx and 0 means empty. */

	/* SpurMemoryManager>>#markAndTraceObjStack:andContents: */
static NoDbgRegParms void
markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt index;
    sqInt objOop;

	if (stackOrNil == GIV(nilObj)) {
		return;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(stackOrNil)));
	longAtput(stackOrNil, (longAt(stackOrNil)) | (1ULL << (markedBitFullShift())));
	assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
	field = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	if (field != 0) {
		markAndTraceObjStackandContents(field, markAndTraceContents);
	}
	field = stackOrNil;
	while (1) {
		field = longAt((field + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
		if (!(field != 0)) break;
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(field)));
		longAtput(field, (longAt(field)) | (1ULL << (markedBitFullShift())));
	}
	if (!markAndTraceContents) {
		return;
	}
	index = (longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		/* begin followObjField:ofObject: */
		objOop = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(index, stackOrNil, objOop);
		}
		field = objOop;
		if (!(((field & (tagMask())) != 0))) {
			markAndTrace(field);
		}
		index -= 1;
	}
}


/*	Mark the argument, and all objects reachable from it, and any remaining
	objects on the mark stack. Follow forwarding pointers in the scan. */
/*	if markAndTrace: is to follow and eliminate forwarding pointers
	in its scan it cannot be handed an r-value which is forwarded.
	The assert for this is in markAndShouldScan: */

	/* SpurMemoryManager>>#markAndTrace: */
NeverInline void
markAndTrace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt format1;
    sqInt format11;
    sqInt header;
    sqInt header1;
    sqInt index;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objStack;
    sqInt objStack1;
    sqInt objStack2;
    sqInt objStack3;
    sqInt objStack4;
    sqInt objStack5;
    sqInt objToScan;
    sqInt scanLargeObject;
    sqInt sp;


	/* begin markAndShouldScan: */
	if (((objOop & (tagMask())) != 0)) {
		return;
	}
	assert(!(isForwarded(objOop)));
	if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
		return;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift())));
	format1 = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	if (	/* begin isPureBitsFormat: */
		(format1 >= (sixtyFourBitIndexableFormat()))
	 && (format1 < (firstCompiledMethodFormat()))) {
		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if (((longAt(objOop)) & (classIndexMask())) > (lastClassIndexPun())) {
			markAndTraceClassOf(objOop);
		}
		return;
	}
	if (format1 == (weakArrayFormat())) {
		/* push weaklings on the weakling stack to scan later */
		objStack = GIV(weaklingStack);
		/* begin push:onObjStack: */
		assert(addressCouldBeOop(objOop));
		if (((objOop & (tagMask())) != 0)) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
				? fetchPointerofObject(ObjStackNextx, objStack)
				: objStack))));
		}
		else {
			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(objOop))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(objOop)));
		}
		noCheckPushonObjStack(objOop, objStack);
		return;
	}
	if ((format1 == 5 /* begin ephemeronFormat */)
	 && (activeAndDeferredScan(objOop))) {
		return;
	}
	/* begin markLoopFrom: */
	numStrongSlots = 0;
	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan = objOop;
	do {
		if (((objToScan & (tagMask())) != 0)) {
			scanLargeObject = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt = (((usqInt)((longAt(objToScan)))) >> (formatShift())) & (formatMask());
			assert((fmt != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan))));
			if (fmt <= 5 /* begin lastPointerFormat */) {
				/* begin numSlotsOf: */
				assert((classIndexOf(objToScan)) > (isForwardedObjectClassIndexPun()));
				numSlots = (((numSlots1 = byteAt(objToScan + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(objToScan - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1);
				if (fmt <= (arrayFormat())) {
					numStrongSlots = numSlots;
					goto l11;
				}
				if (fmt == (indexablePointersFormat())) {
					if (((longAt(objToScan)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(objToScan);
						/* begin fetchStackPointerOf: */
						sp = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
						if (!((((sp) & 7) == 1))) {
							contextSize = 0;
							goto l9;
						}
						assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
						contextSize = (sp >> 3);
	l9:	/* end fetchStackPointerOf: */;
						numStrongSlots = CtxtTempFrameStart + contextSize;
						goto l11;
					}
					numStrongSlots = numSlots;
					goto l11;
				}
				if (fmt == (weakArrayFormat())) {
					objOop11 = fetchClassOfNonImm(objToScan);
					numStrongSlots = (((longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
					goto l11;
				}
			}
			if (fmt == 7 /* begin forwardedFormat */) {
				numStrongSlots = 1;
				goto l11;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				numStrongSlots = 0;
				goto l11;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objToScan));
			header1 = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			header = ((((header1) & 7) == 1)
				? header1
				: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
					assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
					((((CogMethod *) header1))->methodHeader)));
			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots = numLiterals + LiteralStart;
	l11:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject = numStrongSlots > 64 /* begin traceImmediatelySlotLimit */;
		}
		if (scanLargeObject) {
			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if (((objToScan & (tagMask())) != 0)) {
				index = (objToScan >> 3);
				objToScan = topOfObjStack(GIV(markStack));
			}
			else {
				index = numStrongSlots;
				markAndTraceClassOf(objToScan);
			}
			while (index > 0) {
				index -= 1;
				field = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
				if ((!(field & (tagMask())))) {
					if ((!((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}
					/* begin markAndShouldScan: */
					if (((field & (tagMask())) != 0)) {
						goto l3;
					}
					assert(!(isForwarded(field)));
					if (((((usqInt)((longAt(field)))) >> (markedBitFullShift())) & 1) != 0) {
						goto l3;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field)));
					longAtput(field, (longAt(field)) | (1ULL << (markedBitFullShift())));
					format11 = (((usqInt)((longAt(field)))) >> (formatShift())) & (formatMask());
					if (					/* begin isPureBitsFormat: */
						(format11 >= (sixtyFourBitIndexableFormat()))
					 && (format11 < (firstCompiledMethodFormat()))) {
						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field)) & (classIndexMask())) > (lastClassIndexPun())) {
							markAndTraceClassOf(field);
						}
						goto l3;
					}
					if (format11 == (weakArrayFormat())) {
						/* push weaklings on the weakling stack to scan later */
						objStack1 = GIV(weaklingStack);
						/* begin push:onObjStack: */
						assert(addressCouldBeOop(field));
						if (((field & (tagMask())) != 0)) {
							assert(objStack1 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
								? fetchPointerofObject(ObjStackNextx, objStack1)
								: objStack1))));
						}
						else {
							/* There should be no weaklings on the mark stack. */
							assert(!((objStack1 == GIV(markStack))
							 && (isWeakNonImm(field))));
							assert((objStack1 != GIV(weaklingStack))
							 || (isWeakNonImm(field)));
						}
						noCheckPushonObjStack(field, objStack1);
						goto l3;
					}
					if ((format11 == 5 /* begin ephemeronFormat */)
					 && (activeAndDeferredScan(field))) {
						goto l3;
					}
					if (index > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan) {
							objStack2 = GIV(markStack);
							/* begin push:onObjStack: */
							assert(addressCouldBeOop(objToScan));
							if (((objToScan & (tagMask())) != 0)) {
								assert(objStack2 == GIV(markStack));
								assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack2))
									? fetchPointerofObject(ObjStackNextx, objStack2)
									: objStack2))));
							}
							else {
								/* There should be no weaklings on the mark stack. */
								assert(!((objStack2 == GIV(markStack))
								 && (isWeakNonImm(objToScan))));
								assert((objStack2 != GIV(weaklingStack))
								 || (isWeakNonImm(objToScan)));
							}
							noCheckPushonObjStack(objToScan, objStack2);
						}
						objOop1 = (((usqInt)index << 3) | 1);
						objStack3 = GIV(markStack);
						/* begin push:onObjStack: */
						assert(addressCouldBeOop(objOop1));
						if (((objOop1 & (tagMask())) != 0)) {
							assert(objStack3 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack3))
								? fetchPointerofObject(ObjStackNextx, objStack3)
								: objStack3))));
						}
						else {
							/* There should be no weaklings on the mark stack. */
							assert(!((objStack3 == GIV(markStack))
							 && (isWeakNonImm(objOop1))));
							assert((objStack3 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop1)));
						}
						noCheckPushonObjStack(objOop1, objStack3);
					}
					objToScan = field;
					index = -1;
	l3:;
				}
			}
			if (index >= 0) {
				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan = popObjStack(GIV(markStack));
				if (objToScan == objOop) {
					objToScan = popObjStack(GIV(markStack));
				}
			}
		}
		else {
			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index = numStrongSlots;
			markAndTraceClassOf(objToScan);
			while (index > 0) {
				index -= 1;
				field = longAt((objToScan + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
				if ((!(field & (tagMask())))) {
					if ((!((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}
					/* begin markAndShouldScan: */
					if (((field & (tagMask())) != 0)) {
						goto l4;
					}
					assert(!(isForwarded(field)));
					if (((((usqInt)((longAt(field)))) >> (markedBitFullShift())) & 1) != 0) {
						goto l4;
					}
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(field)));
					longAtput(field, (longAt(field)) | (1ULL << (markedBitFullShift())));
					format11 = (((usqInt)((longAt(field)))) >> (formatShift())) & (formatMask());
					if (					/* begin isPureBitsFormat: */
						(format11 >= (sixtyFourBitIndexableFormat()))
					 && (format11 < (firstCompiledMethodFormat()))) {
						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if (((longAt(field)) & (classIndexMask())) > (lastClassIndexPun())) {
							markAndTraceClassOf(field);
						}
						goto l4;
					}
					if (format11 == (weakArrayFormat())) {
						/* push weaklings on the weakling stack to scan later */
						objStack1 = GIV(weaklingStack);
						/* begin push:onObjStack: */
						assert(addressCouldBeOop(field));
						if (((field & (tagMask())) != 0)) {
							assert(objStack1 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
								? fetchPointerofObject(ObjStackNextx, objStack1)
								: objStack1))));
						}
						else {
							/* There should be no weaklings on the mark stack. */
							assert(!((objStack1 == GIV(markStack))
							 && (isWeakNonImm(field))));
							assert((objStack1 != GIV(weaklingStack))
							 || (isWeakNonImm(field)));
						}
						noCheckPushonObjStack(field, objStack1);
						goto l4;
					}
					if ((format11 == 5 /* begin ephemeronFormat */)
					 && (activeAndDeferredScan(field))) {
						goto l4;
					}
					objStack4 = GIV(markStack);
					/* begin push:onObjStack: */
					assert(addressCouldBeOop(field));
					if (((field & (tagMask())) != 0)) {
						assert(objStack4 == GIV(markStack));
						assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack4))
							? fetchPointerofObject(ObjStackNextx, objStack4)
							: objStack4))));
					}
					else {
						/* There should be no weaklings on the mark stack. */
						assert(!((objStack4 == GIV(markStack))
						 && (isWeakNonImm(field))));
						assert((objStack4 != GIV(weaklingStack))
						 || (isWeakNonImm(field)));
					}
					noCheckPushonObjStack(field, objStack4);
					if (((byteAt(field + 7)) > 64 /* begin traceImmediatelySlotLimit */)
					 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > 64 /* begin traceImmediatelySlotLimit */)) {
						objOop2 = (((usqInt)numStrongSlots << 3) | 1);
						objStack5 = GIV(markStack);
						/* begin push:onObjStack: */
						assert(addressCouldBeOop(objOop2));
						if (((objOop2 & (tagMask())) != 0)) {
							assert(objStack5 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack5))
								? fetchPointerofObject(ObjStackNextx, objStack5)
								: objStack5))));
						}
						else {
							/* There should be no weaklings on the mark stack. */
							assert(!((objStack5 == GIV(markStack))
							 && (isWeakNonImm(objOop2))));
							assert((objStack5 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop2)));
						}
						noCheckPushonObjStack(objOop2, objStack5);
					}
	l4:;
				}
			}
			objToScan = popObjStack(GIV(markStack));
		}
	} while(objToScan);
}


/*	Go through the unscanned ephemerons, marking the inactive ones, and
	removing them from the unscanned ephemerons. Answer if any inactive
	ones were found. We cannot fire the ephemerons until all are found to
	be active since scan-marking an inactive ephemeron later in the set may
	render a previously-observed active ephemeron as inactive. */

	/* SpurMemoryManager>>#markInactiveEphemerons */
static sqInt
markInactiveEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt foundInactive;
    sqInt key;
    sqInt objOop;
    sqInt oop;
    usqInt ptr;

	foundInactive = 0;
	ptr = (GIV(unscannedEphemerons).start);
	while (ptr < ((GIV(unscannedEphemerons).top))) {
		objOop = (ephemeron = longAt(ptr));
		/* begin followedKeyOfEphemeron: */
		assert((isNonImmediate(objOop))
		 && (isEphemeron(objOop)));
		/* begin followOopField:ofObject: */
		oop = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
		if (		/* begin isOopForwarded: */
			((!(oop & (tagMask()))))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			oop = fixFollowedFieldofObjectwithInitialValue(0, objOop, oop);
		}
		key = oop;
		if ((((key & (tagMask())) != 0))
		 || (((((usqInt)((longAt(key)))) >> (markedBitFullShift())) & 1) != 0)) {
			/* Now remove the inactive ephemeron from the set, and scan-mark it.
			   Scan-marking it may add more ephemerons to the set. */
			foundInactive = 1;
			(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) - BytesPerOop);
			if (((GIV(unscannedEphemerons).top)) > ptr) {
				longAtput(ptr, longAt((GIV(unscannedEphemerons).top)));
			}
			markAndTrace(ephemeron);
		}
		else {
			ptr += BytesPerOop;
		}
	}
	return foundInactive;
}


/*	for profiling */
/*	Mark all accessible objects.
	objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged is true if all
	objects are unmarked and/or if unmarked classes shoud be removed from the
	class table. */
/*	If the incremental collector is running mark bits may be set; stop it and
	clear them if necessary.
 */

	/* SpurMemoryManager>>#markObjects: */
static NoDbgRegParms NeverInline void
markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt iLimiT;
    sqInt j;
    sqInt jLimiT;
    sqInt largestFree;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;
    sqInt referent4;
    sqInt sizeOfUnusedEden;
    StackPage *thePage;

	runLeakCheckerFor(GCModeFull);
	/* begin shutDownGlobalIncrementalGC: */
	if (objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged) {
		assert(allObjectsUnmarked());
	}
	/* begin initializeUnscannedEphemerons */
	largestFree = findLargestFreeChunk();
	sizeOfUnusedEden = (((eden()).limit)) - GIV(freeStart);
	if ((largestFree)
	 && ((numSlotsOfAny(largestFree)) > (sizeOfUnusedEden / BytesPerWord))) {
		(GIV(unscannedEphemerons).start = (largestFree + BaseHeaderSize) + ((5) * BytesPerWord));
		(GIV(unscannedEphemerons).limit = addressAfter(largestFree));
	}
	else {
		(GIV(unscannedEphemerons).start = GIV(freeStart));
		(GIV(unscannedEphemerons).limit = ((eden()).limit));
	}
	(GIV(unscannedEphemerons).top = (GIV(unscannedEphemerons).start));
	/* begin initializeMarkStack */
	ensureRoomOnObjStackAt(MarkStackRootIndex);
	ensureRoomOnObjStackAt(WeaklingStackRootIndex);
	GIV(marking) = 1;
	/* begin markAccessibleObjectsAndFireEphemerons */
	assert(GIV(marking));
	assert(validClassTableRootPages());
	assert(allBridgesMarked());
	/* begin initStackPageGC */
	if (!(GIV(stackPage) == null)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i2 = 0; i2 < GIV(numStackPages); i2 += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i2, GIV(pages));
		(thePage->trace = StackPageUnreached);
	}
	/* begin markAndTraceHiddenRoots */
	markAndTraceObjStackandContents(GIV(markStack), 0);
	markAndTraceObjStackandContents(GIV(weaklingStack), 0);
	markAndTraceObjStackandContents(GIV(mournQueue), 1);
	objOop = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (longAt(objOop)) | (1ULL << (markedBitFullShift())));
	/* begin freeListsObj */
	assert((firstIndexableField(oldSpaceObjectAfter(GIV(trueObj)))) == GIV(freeLists));
	objOop1 = oldSpaceObjectAfter(GIV(trueObj));
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(objOop1)));
	longAtput(objOop1, (longAt(objOop1)) | (1ULL << (markedBitFullShift())));
	if (isWeakNonImm(GIV(classTableFirstPage))) {
		markAndTrace(GIV(hiddenRootsObj));
		goto l1;
	}
	/* begin setIsMarkedOf:to: */
	assert(!(isFreeObject(GIV(hiddenRootsObj))));
	longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1ULL << (markedBitFullShift())));
	markAndTrace(GIV(classTableFirstPage));
	for (i4 = 1; i4 < GIV(numClassTablePages); i4 += 1) {
		objOop2 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord())))));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(objOop2)));
		longAtput(objOop2, (longAt(objOop2)) | (1ULL << (markedBitFullShift())));
	}
	l1:	/* end markAndTraceHiddenRoots */;
	/* begin markAndTraceExtraRoots */
	assert(GIV(remapBufferCount) == 0);
	for (i1 = 1; i1 <= GIV(extraRootCount); i1 += 1) {
		oop = (GIV(extraRoots)[i1])[0];
		if (!((((oop & (tagMask())) != 0))
			 || (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())))) {
			markAndTrace(oop);
		}
	}
	assert(validClassTableRootPages());
	/* begin markAndTraceInterpreterOops: */
	markAndTraceStackPages(1);
	markAndTraceTraceLog();
	markAndTracePrimTraceLog();
	markAndTrace(specialObjectsOop());
	if (!(((GIV(newMethod) & (tagMask())) != 0))) {
		markAndTrace(GIV(newMethod));
	}
	/* begin traceProfileState */
	if ((!((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileProcess)));
		referent = longAt((GIV(profileProcess) + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		GIV(profileProcess) = referent;
	}
	if ((!((longAt(GIV(profileMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileMethod)));
		referent1 = longAt((GIV(profileMethod) + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent1 & (tagMask()))))
		 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		GIV(profileMethod) = referent1;
	}
	if ((!((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(GIV(profileSemaphore)));
		referent2 = longAt((GIV(profileSemaphore) + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent2 & (tagMask()))))
		 && ((!((longAt(referent2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		GIV(profileSemaphore) = referent2;
	}
	markAndTrace(GIV(profileProcess));
	markAndTrace(GIV(profileMethod));
	markAndTrace(GIV(profileSemaphore));
#  if LRPCheck
	/* The longRunningPrimitiveCheckMethod (LRPCM) is sampled in an interrupt.  Be very careful with it.
	   If longRunningPrimitiveCheckSequenceNumber (LRPCSN) = statCheckForEvents then LRPCM has
	   been recenty sampled, but it must be newMethod and we don't need to trace it twice.  If LRPCSN
	   ~= statCheckForEvents then LRPCM must be some extant object and needs to be traced. */
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		if ((!((longAt(GIV(longRunningPrimitiveCheckMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(longRunningPrimitiveCheckMethod)));
			referent3 = longAt((GIV(longRunningPrimitiveCheckMethod) + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent3 & (tagMask()))))
			 && ((!((longAt(referent3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			GIV(longRunningPrimitiveCheckMethod) = referent3;
		}
		markAndTrace(GIV(longRunningPrimitiveCheckMethod));
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		if ((!((longAt(GIV(longRunningPrimitiveCheckSemaphore))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(longRunningPrimitiveCheckSemaphore)));
			referent4 = longAt((GIV(longRunningPrimitiveCheckSemaphore) + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent4 & (tagMask()))))
			 && ((!((longAt(referent4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent4 = longAt((referent4 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			GIV(longRunningPrimitiveCheckSemaphore) = referent4;
		}
		markAndTrace(GIV(longRunningPrimitiveCheckSemaphore));
	}
#  endif // LRPCheck

	if (!(GIV(tempOop) == 0)) {
		markAndTrace(GIV(tempOop));
	}
	if (!(GIV(tempOop2) == 0)) {
		markAndTrace(GIV(tempOop2));
	}
	for (i3 = 1, iLimiT = (remapBufferCount()); i3 <= iLimiT; i3 += 1) {
		oop1 = GIV(remapBuffer)[i3];
		if (!(((oop1 & (tagMask())) != 0))) {
			markAndTrace(oop1);
		}
	}
	assert(validObjStacks());
	markWeaklingsAndMarkAndFireEphemerons();
	assert(validObjStacks());
	/* begin expungeDuplicateAndUnmarkedClasses: */
	for (i = 1; i < GIV(numClassTablePages); i += 1) {
		/* Avoid expunging the puns by not scanning the 0th page. */
		classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		for (j = 0, jLimiT = ((1U << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))));
			classIndex = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
			assert((classOrNil == GIV(nilObj))
			 || (addressCouldBeClassObj(classOrNil)));
			if (classOrNil == GIV(nilObj)) {
				if (classIndex < GIV(classTableIndex)) {
					GIV(classTableIndex) = classIndex;
				}
			}
			else {
				if ((objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged
				 && (!(((((usqInt)((longAt(classOrNil)))) >> (markedBitFullShift())) & 1) != 0)))
				 || (((long32At(classOrNil + 4)) & (identityHashHalfWordMask())) != classIndex)) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(classTablePage)));
					longAtput((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))), GIV(nilObj));
					assert((objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged
					 && (!(isMarked(classOrNil))))
					 || ((classAtIndex(rawHashBitsOf(classOrNil))) == classOrNil));
					if (classIndex < GIV(classTableIndex)) {
						GIV(classTableIndex) = classIndex;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
	nilUnmarkedWeaklingSlots();
	GIV(marking) = 0;
}


/*	After the initial scan-mark is complete ephemerons can be processed.
	Weaklings have accumulated on the weaklingStack, but more may be
	uncovered during ephemeron processing. So trace the strong slots
	of the weaklings, and as ephemerons are processed ensure any newly
	reached weaklings are also traced. */

	/* SpurMemoryManager>>#markWeaklingsAndMarkAndFireEphemerons */
static void
markWeaklingsAndMarkAndFireEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt field;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt key;
    sqInt lastptr;
    sqInt numOnThisPage;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt numTracedWeaklings;
    sqInt objStackPage;
    sqInt oop;
    sqInt oop1;
    sqInt p;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;
    sqInt weakling1;

	numTracedWeaklings = 0;
	while (1) {
		markAndTraceUntracedReachableStackPages();
		markAndTraceMachineCodeOfMarkedMethods();
		do {
			/* begin markAndTraceWeaklingsFrom: */
			weakling = 0;
			eassert(isValidObjStack(GIV(weaklingStack)));
			size = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
			objStackPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
			while (objStackPage != 0) {
				size += ObjStackLimit;
				assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
				objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
			}
			numToEnumerate = size - numTracedWeaklings;
			objStackPage = GIV(weaklingStack);
			while (numToEnumerate > 0) {
				numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
				numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
				topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
				for (i1 = topIndex; i1 >= ((topIndex - numToEnumerateOnThisPage) + 1); i1 += -1) {
					assert(isWeak(fetchPointerofObject(i1, objStackPage)));
					weakling1 = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
					assert(!((isForwarded(weakling1))));
					markAndTraceClassOf(weakling1);
					for (i = 0, iLimiT = ((numStrongSlotsOfWeakling(weakling1)) - 1); i <= iLimiT; i += 1) {
						/* begin followOopField:ofObject: */
						oop1 = longAt((weakling1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
						if (						/* begin isOopForwarded: */
							((!(oop1 & (tagMask()))))
						 && ((!((longAt(oop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							oop1 = fixFollowedFieldofObjectwithInitialValue(i, weakling1, oop1);
						}
						field = oop1;
						if (!((((field & (tagMask())) != 0))
							 || (((((usqInt)((longAt(field)))) >> (markedBitFullShift())) & 1) != 0))) {
							markAndTrace(field);
						}
					}
				}
				numToEnumerate -= numToEnumerateOnThisPage;
				objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
			}
			numTracedWeaklings = size;
		} while((sizeOfObjStack(GIV(weaklingStack))) > numTracedWeaklings);
		if (((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start))) {
			markAndTraceUntracedReachableStackPages();
			markAndTraceMachineCodeOfMarkedMethods();
			freeUntracedStackPages();
			freeUnmarkedMachineCode();
			return;
		}
		if (!(markInactiveEphemerons())) {
			/* begin fireAllUnscannedEphemerons */
			assert(!(noUnscannedEphemerons()));
			assert(allUnscannedEphemeronsAreActive());
			for (p = ((GIV(unscannedEphemerons).start)); p <= (((GIV(unscannedEphemerons).top)) - BytesPerOop); p += BytesPerOop) {
				/* begin fireEphemeron: */
				queueMourner(longAt(p));
				assert(((1 /* begin nonIndexablePointerFormat */ >= 0) && (1 /* begin nonIndexablePointerFormat */ <= (formatMask()))));
				longAtput(longAt(p), ((longAt(longAt(p))) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (1U << (formatShift())));
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}
		}
		/* begin markAllUnscannedEphemerons */
		assert(!(noUnscannedEphemerons()));
		assert(allUnscannedEphemeronsAreActive());
		while (((GIV(unscannedEphemerons).top)) > ((GIV(unscannedEphemerons).start))) {
			ephemeron = longAt((GIV(unscannedEphemerons).start));
			lastptr = ((GIV(unscannedEphemerons).top)) - BytesPerOop;
			if (lastptr > ((GIV(unscannedEphemerons).start))) {
				longAtput((GIV(unscannedEphemerons).start), longAt(lastptr));
			}
			(GIV(unscannedEphemerons).top = lastptr);
			/* begin followedKeyOfMaybeFiredEphemeron: */
			assert((isNonImmediate(ephemeron))
			 && (isMaybeFiredEphemeron(ephemeron)));
			/* begin followOopField:ofObject: */
			oop = longAt((ephemeron + BaseHeaderSize) + (0U << (shiftForWord())));
			if (			/* begin isOopForwarded: */
				((!(oop & (tagMask()))))
			 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				oop = fixFollowedFieldofObjectwithInitialValue(0, ephemeron, oop);
			}
			key = oop;
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(ephemeron)));
			longAtput(ephemeron, (longAt(ephemeron)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			markAndTrace(key);
			markAndTrace(ephemeron);
		}
	}
}


/*	Almost entirely arbitrary, but we dont want 1Mb bitmaps allocated in eden.
	But this choice means no check for numSlots > maxSlotsForNewSpaceAlloc
	for non-variable allocations. */

	/* SpurMemoryManager>>#maxSlotsForNewSpaceAlloc */
sqInt
maxSlotsForNewSpaceAlloc(void)
{
	return (1U << (fixedFieldsFieldWidth())) - 1;
}


/*	Answers if the code is installed in a class instantiating objects with the
	format. Used in primitive 
	generation to make a quick path based on where the method is installed.
	This method cannot
	be used as a guarantee as there can be false positive, it's just a
	heuristic. Tries to interpret the last literal of the method as a behavior
	(more than 3 fields, 3rd field a Smi).
	If it can be interpreted as a behavior, answers if instSpec matches the
	format, else answers false. */

	/* SpurMemoryManager>>#maybeMethodClassOf:seemsToBeInstantiating: */
sqInt
maybeMethodClassOfseemsToBeInstantiating(sqInt methodObj, sqInt format)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instSpec;
    sqInt literal;
    sqInt maybeClassObj;
    sqInt maybeFormat;
    sqInt objOop;
    sqInt objOop1;
    sqInt offset;

	/* begin methodClassOf: */
	offset = (literalCountOf(methodObj)) - 1;
	/* begin followField:ofObject: */
	objOop = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodObj, objOop);
	}
	literal = objOop;
	if ((literal != GIV(nilObj))
	 && (	/* begin isPointers: */
		((!(literal & (tagMask()))))
	 && (((((usqInt)((longAt(literal)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))) {
		/* filters out fullBlock last literal */
		assert((numSlotsOf(literal)) > ValueIndex);
		/* begin followField:ofObject: */
		objOop1 = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop1 & (tagMask()))))
		 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop1);
		}
		maybeClassObj = objOop1;
	}
	else {
		maybeClassObj = GIV(nilObj);
	}
	if (!(((((usqInt)((longAt(maybeClassObj)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)) {
		return 0;
	}
	if (!((numSlotsOfAny(maybeClassObj)) > InstanceSpecificationIndex)) {
		return 0;
	}
	maybeFormat = longAt((maybeClassObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))));
	if (!((((maybeFormat) & 7) == 1))) {
		return 0;
	}
	instSpec = (((usqInt)(((maybeFormat >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
	return instSpec == format;
}


/*	Answer the minimum number of additional slots to allocate in an object to
	always be able to shorten it.
	This is enough slots to allocate a minimum-sized object. */

	/* SpurMemoryManager>>#minSlotsForShortening */
sqInt
minSlotsForShortening(void)
{
	return (16) / BytesPerOop;
}

	/* SpurMemoryManager>>#newHashBitsOf: */
static NoDbgRegParms usqInt
newHashBitsOf(sqInt objOop)
{
    usqInt hash;

	hash = (newObjectHash()) & (identityHashHalfWordMask());
	/* begin setHashBitsOf:to: */
	assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
	long32Atput(objOop + 4, ((((long32At(objOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
	return hash;
}


/*	Use a slight variation on D.H. Lehmer's linear congruential generator from
	1951. See e.g. http://en.wikipedia.org/wiki/Linear_congruential_generator. */

	/* SpurMemoryManager>>#newObjectHash */
static usqInt
newObjectHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;

	do {
		GIV(lastHash) = GIV(lastHash) * 16807;
		/* adding the top bits gives much better spread.  See below: */
		hash = GIV(lastHash) + ((GIV(lastHash)) >> 4);
	} while((hash & (identityHashHalfWordMask())) == 0);
	return hash;
}

	/* SpurMemoryManager>>#newSpaceIsEmpty */
static sqInt
newSpaceIsEmpty(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(freeStart) == (((eden()).start)))
	 && (GIV(pastSpaceStart) == (((pastSpace()).start)));
}

	/* SpurMemoryManager>>#nilObject */
sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	Nil the unmarked slots in the weaklings on the
	weakling stack, finalizing those that lost references.
	Finally, empty the weaklingStack. */
/*	for profiling */

	/* SpurMemoryManager>>#nilUnmarkedWeaklingSlots */
static NeverInline void
nilUnmarkedWeaklingSlots(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anyUnmarked;
    sqInt anyUnmarked1;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt nextNextPage;
    sqInt nextPage;
    sqInt numOnThisPage;
    usqInt numSlots;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt objStackPage;
    sqInt referent;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;
    sqInt weakling1;

	weakling = 0;
	eassert(allOldMarkedWeakObjectsOnWeaklingStack());
	if (GIV(weaklingStack) == GIV(nilObj)) {
		return;
	}
	/* begin objStack:from:do: */
	eassert(isValidObjStack(GIV(weaklingStack)));
	size = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
	objStackPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	while (objStackPage != 0) {
		size += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	}
	numToEnumerate = size;
	objStackPage = GIV(weaklingStack);
	while (numToEnumerate > 0) {
		numOnThisPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
		numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
		topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
		for (i = topIndex; i >= ((topIndex - numToEnumerateOnThisPage) + 1); i += -1) {
			assert(isWeak(fetchPointerofObject(i, objStackPage)));
			weakling1 = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			/* begin nilUnmarkedWeaklingSlotsIn: */
			anyUnmarked1 = 0;
			assert(allStrongSlotsOfWeaklingAreMarked(weakling1));
			for (i1 = (numStrongSlotsOfWeakling(weakling1)), iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(weakling1)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(weakling1 + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(weakling1 - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i1 <= iLimiT; i1 += 1) {
				referent = longAt((weakling1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
				if ((!(referent & (tagMask())))) {
					if (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
						referent = fixFollowedFieldofObjectwithInitialValue(i1, weakling1, referent);
					}
					if (!((((referent & (tagMask())) != 0))
						 || (((((usqInt)((longAt(referent)))) >> (markedBitFullShift())) & 1) != 0))) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(weakling1)));
						longAtput((weakling1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), GIV(nilObj));
						anyUnmarked1 = 1;
					}
				}
			}
			anyUnmarked = anyUnmarked1;
			if (anyUnmarked) {
				/* fireFinalization: could grow the mournQueue and if so,
				   additional pages must be marked to avoid being GC'ed. */
				assert(GIV(marking));
				/* begin fireFinalization: */
				if (GIV(newFinalization)) {
					queueMourner(weakling1);
				}
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}
		}
		numToEnumerate -= numToEnumerateOnThisPage;
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	}
	/* begin emptyObjStack: */
	if (GIV(weaklingStack) == GIV(nilObj)) {
		goto l3;
	}
	eassert(isValidObjStack(GIV(weaklingStack)));
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(GIV(weaklingStack))) == (wordIndexableFormat()));
	longAtput((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))), 0);
	nextPage = longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	while (nextPage != 0) {
		nextNextPage = longAt((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))), longAt((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord()))))));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))), 0);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(GIV(weaklingStack))) == (wordIndexableFormat()));
		longAtput((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))), nextPage);
		nextPage = nextNextPage;
	}
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(GIV(weaklingStack))) == (wordIndexableFormat()));
	longAtput((GIV(weaklingStack) + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))), 0);
	eassert(isValidObjStack(GIV(weaklingStack)));
	l3:	/* end emptyObjStack: */;
}

	/* SpurMemoryManager>>#noCheckClassAtIndex: */
static NoDbgRegParms sqInt
noCheckClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;
    sqInt fieldIndex;
    sqInt fieldIndex1;

	fieldIndex = ((usqInt)(classIndex)) >> (classTableMajorIndexShift());
	/* begin fetchPointer:ofObject: */
	classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	fieldIndex1 = classIndex & ((1U << (classTableMajorIndexShift())) - 1);
	/* begin fetchPointer:ofObject: */
	return longAt((classTablePage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))));
}


/*	Push an element on an objStack. Split from push:onObjStack: for testing. */

	/* SpurMemoryManager>>#noCheckPush:onObjStack: */
static NoDbgRegParms sqInt
noCheckPushonObjStack(sqInt objOop, sqInt objStack)
{
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
	if (topx >= ObjStackLimit) {
		noCheckPushonObjStack(objOop, ensureRoomOnObjStackAt(longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord())))))));
	}
	else {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)((ObjStackFixedSlots + topx)) << (shiftForWord())))), objOop);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))), topx + 1);
	}
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#noFixupFollowField:ofObject: */
static NoDbgRegParms sqInt
noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;
    sqInt referent;

	objOop = longAt((anObject + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(objOop));
		referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		objOop = referent;
	}
	return objOop;
}


/*	Allocate an object with numSlots space. If there is room beneath
	scavengeThreshold allocate in newSpace, otherwise alocate in oldSpace. If
	there is not room in newSpace
	and a scavenge is not already scheduled, schedule a scavenge. */

	/* SpurMemoryManager>>#noInlineAllocateSlots:format:classIndex: */
static NoDbgRegParms NeverInline sqInt
noInlineAllocateSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newObj;
    usqInt numBytes;


	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		if ((((usqInt)(numSlots)) >> 56) > 0) {
			return null;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		return allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, classIndex);
	}
	if (numSlots >= (numSlotsMask())) {
		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(newObj, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	}
	else {
		longAtput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}

	/* SpurMemoryManager>>#nonIndexablePointerFormat */
sqInt
nonIndexablePointerFormat(void)
{
	return 1;
}

	/* SpurMemoryManager>>#noUnscannedEphemerons */
static int
noUnscannedEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start));
}


/*	Answer the number of indexable bytes in the given non-immediate pure bits
	object with format.
 */

	/* SpurMemoryManager>>#numBytesOfBits:format: */
static NoDbgRegParms sqInt
numBytesOfBitsformat(sqInt objOop, sqInt format)
{
    usqInt numBytes;
    usqInt numSlots;

	assert((isPureBitsFormat(format))
	 && ((formatOf(objOop)) == format));
	/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numBytes = (((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (format < (firstShortFormat())) {
		return (format <= (sixtyFourBitIndexableFormat())
			? numBytes
			: numBytes - (((sqInt)((usqInt)((format & 1)) << 2))));
	}
	return (format < (firstByteFormat())
		? numBytes - (((sqInt)((usqInt)((format & 3)) << 1)))
		: numBytes - (format & 7));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* SpurMemoryManager>>#numBytesOfBytes: */
static NoDbgRegParms sqInt
numBytesOfBytes(sqInt objOop)
{
    sqInt fmt;
    usqInt numSlots;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	return (((/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* SpurMemoryManager>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numBytes = (((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {
		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
	}
	return numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
}


/*	Answer the number of pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numPointerSlotsOf: */
static NoDbgRegParms usqInt
numPointerSlotsOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt sp;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin numPointerSlotsOf:format: */
	if (fmt <= 5 /* begin lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
	l1:	/* end fetchStackPointerOf: */;
			return CtxtTempFrameStart + contextSize;
		}
		return (			/* begin numSlotsOf: */
				assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun())),
			(((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots));
	}
	if (fmt == 7 /* begin forwardedFormat */) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header1 = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}

	/* SpurMemoryManager>>#numSlotsForBytes: */
static NoDbgRegParms sqInt
numSlotsForBytes(sqInt numBytes)
{
	return (numBytes + (BytesPerWord - 1)) / BytesPerWord;
}


/*	A private internal version of numSlotsOf: that is happy to be applied to
	free or forwarded objects.
 */

	/* SpurMemoryManager>>#numSlotsOfAny: */
static NoDbgRegParms usqInt
numSlotsOfAny(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
}

	/* SpurMemoryManager>>#numSlotsOf: */
usqInt
numSlotsOf(sqInt objOop)
{
    usqInt numSlots;

	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	return (((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
}


/*	Answer the number of strong pointer fields in the given object,
	which is .expected not to be an active ephemeron.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numStrongSlotsOfInephemeral: */
static NoDbgRegParms sqInt
numStrongSlotsOfInephemeral(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt header1;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt sp;

	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	assert((fmt != (ephemeronFormat()))
	 || (isMarked(keyOfEphemeron(objOop))));
	if (fmt <= 5 /* begin lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
		numSlots = (((numSlots1 = byteAt(objOop + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= (arrayFormat())) {
			return numSlots;
		}
		if (fmt == (indexablePointersFormat())) {
			if (((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(objOop);
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
				contextSize = (sp >> 3);
	l1:	/* end fetchStackPointerOf: */;
				return CtxtTempFrameStart + contextSize;
			}
			return numSlots;
		}
		if (fmt == (weakArrayFormat())) {
			objOop1 = fetchClassOfNonImm(objOop);
			/* begin fixedFieldsOfClass: */
			return (((longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
		}
	}
	if (fmt == 7 /* begin forwardedFormat */) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header1 = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	Answer the number of strong pointer fields in the given weakling. */

	/* SpurMemoryManager>>#numStrongSlotsOfWeakling: */
static NoDbgRegParms sqInt
numStrongSlotsOfWeakling(sqInt objOop)
{
    sqInt objOop1;

	assert((formatOf(objOop)) == (weakArrayFormat()));
	objOop1 = fetchClassOfNonImm(objOop);
	/* begin fixedFieldsOfClass: */
	return (((longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#objectAfter: */
sqInt
objectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt limit;

	if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((eden()).start), GIV(freeStart))) {
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				return GIV(freeStart);
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		}
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((pastSpace()).start), GIV(pastSpaceStart))) {
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
				return GIV(pastSpaceStart);
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			return ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		}
		limit = futureSurvivorStart();
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			return limit;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		return ((((usqInt)(followingWord2)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	}
	/* begin objectAfter:limit: */
	followingWordAddress3 = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord3 = longAt(followingWordAddress3);
	return ((((usqInt)(followingWord3)) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress3 + BaseHeaderSize
		: followingWordAddress3);
}


/*	useful for debugging */

	/* SpurMemoryManager>>#objectBefore: */
sqInt
objectBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt o;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prev;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	o = 0;
	prev = null;
	if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
		/* begin allNewSpaceEntitiesDo: */
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		start = 
		/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		if (start > GIV(freeStart)) {
			goto l3;
		}
		/* begin bridgePastSpaceAndEden */
		if (GIV(pastSpaceStart) < (((eden()).start))) {
			/* past space can be entirely full (!!) */
			if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
				/* No room for a full bridge (!!); use the slim bridge hack */
				hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
				assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
			}
			else {
				/* Room for a regular bridge; this is straight-forward */
				initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
			}
		}
		/* begin objectStartingAt: */
		numSlots = byteAt(start + 7);
		objOop1 = (numSlots == (numSlotsMask())
			? start + BaseHeaderSize
			: start);
		while (oopisLessThan(objOop1, GIV(freeStart))) {
			if (oopisGreaterThanOrEqualTo(objOop1, objOop)) {
				return prev;
			}
			prev = objOop1;
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress = addressAfter(objOop1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				objOop1 = GIV(freeStart);
				goto l2;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress + BaseHeaderSize)
				: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		}
	l3:	/* end allNewSpaceEntitiesDo: */;
		return prev;
	}
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop2 = GIV(nilObj);
	while (1) {
		assert((objOop2 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop2, GIV(endOfMemory)))) break;
		assert((long64At(objOop2)) != 0);
		if (oopisGreaterThanOrEqualTo(objOop2, objOop)) {
			return prev;
		}
		prev = objOop2;
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop2);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop2 = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop2 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For assertions only... This ends the recursion in setting up the bridged
	enumerations of new space that need objectBefore: for assertion checking. */

	/* SpurMemoryManager>>#objectInPastSpaceBefore: */
static NoDbgRegParms sqInt
objectInPastSpaceBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt prev;

	if (GIV(pastSpaceStart) <= (((pastSpace()).start))) {
		return null;
	}
	prev = null;
	address = ((pastSpace()).start);
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	obj = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	while (oopisLessThan(obj, GIV(pastSpaceStart))) {
		if (oopisGreaterThanOrEqualTo(obj, objOop)) {
			return prev;
		}
		prev = obj;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
			obj = GIV(pastSpaceStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For enumerating objects find the header of the first object in a space.
	If the object starts with an overflow size field it will start at the next
	allocationUnit. c.f. numSlotsOf: */

	/* SpurMemoryManager>>#objectStartingAt: */
static NoDbgRegParms sqInt
objectStartingAt(sqInt address)
{
    usqInt numSlots;

	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}


/*	This primitive is called from Squeak as...
	arrayOfRoots uniquelyAccessibleObjects
	
	This primitive answers an array of the receiver and every object in its
	proper tree of subParts (ie, that is not refered to from anywhere else
	outside the tree).
	
	The primitive can fail for the following reasons with the specified
	failure codes:
	PrimErrNoMemory:			additional allocations failed
 */

	/* SpurMemoryManager>>#objectsAccessibleFromRoots: */
static NoDbgRegParms sqInt
objectsAccessibleFromRoots(sqInt arrayOfRootsArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfObjects;
    sqInt arrayOfRoots;
    sqInt referent;

	runLeakCheckerFor(GCCheckImageSegment);
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge);
	if ((!((longAt(arrayOfRootsArg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(arrayOfRootsArg));
		referent = longAt((arrayOfRootsArg + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		arrayOfRoots = referent;
	}
	else {
		arrayOfRoots = arrayOfRootsArg;
	}
	arrayOfObjects = objectsReachableFromRoots(arrayOfRoots);
	if (!arrayOfObjects) {
		return (((usqInt)PrimErrNoMemory << 3) | 1);
	}
	if ((((arrayOfObjects) & 7) == 1)) {
		if ((GIV(totalFreeOldSpace) - 8 /* begin allocationUnit */) >= ((arrayOfObjects >> 3))) {
			return (((usqInt)PrimErrNeedCompaction << 3) | 1);
		}
		return (((usqInt)PrimErrNoMemory << 3) | 1);
	}
	assert(allObjectsUnmarked());
	assert(!((forwardersIn(arrayOfObjects))));
	return arrayOfObjects;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:.
	Answer an Array of all the objects only reachable from the argument, an
	Array of root objects,
	starting with arrayOfRoots. If there is no space, answer a SmallInteger
	whose value is the
	number of slots required. This is used to collect the objects to include
	in an image segment
	on Spur, separate from creating the segment, hence simplifying the
	implementation. Thanks to Igor Stasenko for this idea. */

	/* SpurMemoryManager>>#objectsReachableFromRoots: */
static NoDbgRegParms NeverInline sqInt
objectsReachableFromRoots(sqInt arrayOfRoots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt delta;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt format;
    usqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt iLimiT2;
    usqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt ptr;
    sqInt referent;
    usqInt start;
    usqInt start1;


	/* & hence start & ptr are too; limit is also because of addressAfter: */
	assert(isArray(arrayOfRoots));
	assert(allObjectsUnmarked());
	/* begin markObjectsIn: */
	assert(!(isFreeObject(arrayOfRoots)));
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | (1ULL << (markedBitFullShift())));
	for (i1 = 0, iLimiT1 = (((/* begin numSlotsOf: */
	assert((classIndexOf(arrayOfRoots)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(arrayOfRoots + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(arrayOfRoots - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i1 <= iLimiT1; i1 += 1) {
		/* begin followField:ofObject: */
		objOop1 = longAt((arrayOfRoots + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop1 & (tagMask()))))
		 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(i1, arrayOfRoots, objOop1);
		}
		oop1 = objOop1;
		if ((!(oop1 & (tagMask())))) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop1)));
			longAtput(oop1, (longAt(oop1)) | (1ULL << (markedBitFullShift())));
		}
	}
	markObjects(0);
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	assert(noUnscannedEphemerons());
	/* begin unmarkObjectsIn: */
	for (i2 = 0, iLimiT2 = (((assert((classIndexOf(arrayOfRoots)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(arrayOfRoots + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(arrayOfRoots - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) - 1); i2 <= iLimiT2; i2 += 1) {
		/* begin followField:ofObject: */
		objOop2 = longAt((arrayOfRoots + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop2 & (tagMask()))))
		 && ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(i2, arrayOfRoots, objOop2);
		}
		oop2 = objOop2;
		if ((!(oop2 & (tagMask())))) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop2)));
			longAtput(oop2, (longAt(oop2)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
		}
	}
	/* N.B. Does /not/ update totalFreeOldSpace */
	freeChunk = allocateLargestFreeChunk();
	/* but must update so that growth in the markStack does not cause assert fails. */
	GIV(totalFreeOldSpace) -= bytesInBody(freeChunk);
	ptr = (start = freeChunk + BaseHeaderSize);
	limit = addressAfter(freeChunk);
	/* First put the arrayOfRoots; order is important. */
	count = 0;
	noCheckPushonObjStack(arrayOfRoots, GIV(markStack));
	while (!(isEmptyObjStack(GIV(markStack)))) {
		objOop = popObjStack(GIV(markStack));
		assert(isMarked(objOop));
		count += 1;
		if (ptr < limit) {
			longAtput(ptr, objOop);
			ptr += BytesPerOop;
		}
		oop = fetchClassOfNonImm(objOop);
		if (!(((((usqInt)((longAt(oop)))) >> (markedBitFullShift())) & 1) != 0)) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(oop)));
			longAtput(oop, (longAt(oop)) | (1ULL << (markedBitFullShift())));
			noCheckPushonObjStack(oop, GIV(markStack));
		}
		if ((((longAt(objOop)) & (classIndexMask())) == ClassMethodContextCompactIndex)
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(objOop))))) {
			/* widow now, before the copy loop */
			for (i = 0, iLimiT = ((numSlotsOfMarriedContext(objOop)) - 1); i <= iLimiT; i += 1) {
				oop = fetchPointerofMarriedContext(i, objOop);
				if (!((((oop & (tagMask())) != 0))
					 || (((((usqInt)((longAt(oop)))) >> (markedBitFullShift())) & 1) != 0))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(oop)));
					longAtput(oop, (longAt(oop)) | (1ULL << (markedBitFullShift())));
					noCheckPushonObjStack(oop, GIV(markStack));
				}
			}
		}
		else {
			for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
				oop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
				if (!((((oop & (tagMask())) != 0))
					 || (((((usqInt)((longAt(oop)))) >> (markedBitFullShift())) & 1) != 0))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(oop)));
					longAtput(oop, (longAt(oop)) | (1ULL << (markedBitFullShift())));
					noCheckPushonObjStack(oop, GIV(markStack));
				}
			}
		}
	}
	/* begin unmarkAllObjects */
	obj = 0;
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop3 = GIV(nilObj);
	while (1) {
		assert((objOop3 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop3, GIV(endOfMemory)))) break;
		assert((long64At(objOop3)) != 0);
		if (((((usqInt)((longAt(objOop3)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((longAt(objOop3)) & (classIndexMask())) > (lastClassIndexPun())) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop3)));
				longAtput(objOop3, (longAt(objOop3)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			else {
				if (!(((longAt(objOop3)) & (classIndexMask())) == (segmentBridgePun()))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop3)));
					longAtput(objOop3, (longAt(objOop3)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop3;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop3);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop3 = GIV(endOfMemory);
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop3 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l6:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start1 = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start1 > GIV(freeStart)) {
		goto l7;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots2 = byteAt(start1 + 7);
	objOop11 = (numSlots2 == (numSlotsMask())
		? start1 + BaseHeaderSize
		: start1);
	while (oopisLessThan(objOop11, GIV(freeStart))) {
		if (((((usqInt)((longAt(objOop11)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((longAt(objOop11)) & (classIndexMask())) > (lastClassIndexPun())) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop11)));
				longAtput(objOop11, (longAt(objOop11)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			else {
				if (!(((longAt(objOop11)) & (classIndexMask())) == (segmentBridgePun()))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop11)));
					longAtput(objOop11, (longAt(objOop11)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop11);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop11 = GIV(freeStart);
			goto l8;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop11 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop11, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l8:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l7:	/* end allNewSpaceEntitiesDo: */;
	if ((count > ((ptr - start) / BytesPerOop))
	 || ((limit != ptr)
	 && ((limit - ptr) <= 8 /* begin allocationUnit */))) {
		/* can't split a single word */
		freeObject(freeChunk);
		/* begin checkFreeSpace: */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		if (((checkForLeaks & (GCCheckFreeSpace | GCCheckImageSegment)) == (GCCheckFreeSpace | GCCheckImageSegment))) {
			runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
		}
		return (((usqInt)count << 3) | 1);
	}
	format = arrayFormat();
	/* begin setFormatOf:to: */
	assert(((format >= 0) && (format <= (formatMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (((sqInt)((usqInt)(format) << (formatShift())))));
	/* begin setClassIndexOf:to: */
	assert(((ClassArrayCompactIndex >= 0) && (ClassArrayCompactIndex <= (classIndexMask()))));
	longAtput(freeChunk, ((longAt(freeChunk)) & (~(usqIntptr_t)(classIndexMask()))) + ClassArrayCompactIndex);
	/* begin shorten:toIndexableSize: */
	assert((count >= 0)
	 && (count < (lengthOf(freeChunk))));
	delta = doShortentoIndexableSize(freeChunk, count);
	assert((lengthOf(followMaybeForwarded(freeChunk))) == count);
	runLeakCheckerFor(GCCheckShorten);
	if ((!((longAt(freeChunk)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(freeChunk));
		referent = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		freeChunk = referent;
	}
	/* begin possibleRootStoreInto: */
	if (!(((((usqInt)((longAt(freeChunk)))) >> (rememberedBitShift())) & 1) != 0)) {
		remember(freeChunk);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCCheckImageSegment)) == (GCCheckFreeSpace | GCCheckImageSegment))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	runLeakCheckerFor(GCCheckImageSegment);
	return freeChunk;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* SpurMemoryManager>>#okayOop: */
static NoDbgRegParms sqInt
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqInt oop;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	oop = ((usqInt) signedOop);
	if (((oop & (tagMask())) != 0)) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & (classIndexMask()))) >= (firstClassIndexPun()))) {
		error("oop is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		error("oop header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if ((fmt == 6) || (fmt == 8)) {
		error("oop has an unknown format type");
		return 0;
	}
	if ((fmt == 7 /* begin forwardedFormat */) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		error("oop has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (0x400000) | (0x40000000000000LL);
	if (((long64At(oop)) & unusedBits) != 0) {
		error("some unused header bits are set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1U << (greyBitShift())) | (1U << (pinnedBitShift()))) | (1U << (rememberedBitShift()));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		error("some header bits unused in young objects are set; should be zero");
		return 0;
	}
	return 1;
}


/*	useful for debugging */
/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#oldSpaceObjectAfter: */
sqInt
oldSpaceObjectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;


	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
}


/*	in an effort to fix a compiler bug with two-way become post r3427 */
/*	Allocate two new objects, n1 & n2. Copy the contents appropriately.
	Convert obj1 and obj2
	into forwarding objects pointing to n2 and n1 respectively. No need to
	check if cloneObject:
	succeeds because an earlier pass over objects ensured that there is enough
	memory. 
 */

	/* SpurMemoryManager>>#outOfPlaceBecome:and:copyHashFlag: */
static NoDbgRegParms NeverInline void
outOfPlaceBecomeandcopyHashFlag(sqInt obj1, sqInt obj2, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt clone1;
    sqInt clone2;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt hash3;

	if (((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
		clone1 = cloneContext(obj1);
	}
	else {
		clone1 = cloneObject(obj1);
	}
	if (((longAt(obj2)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
		clone2 = cloneContext(obj2);
	}
	else {
		clone2 = cloneObject(obj2);
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(obj1)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin setIsImmutableOf:to: */
		longAtput(clone1, (longAt(clone1)) | (1U << (immutableBitShift())));
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(obj2)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin setIsImmutableOf:to: */
		longAtput(clone2, (longAt(clone2)) | (1U << (immutableBitShift())));
	}
	if (copyHashFlag) {
		hash = (long32At(obj1 + 4)) & (identityHashHalfWordMask());
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(clone1 + 4, ((((long32At(clone1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		hash1 = (long32At(obj2 + 4)) & (identityHashHalfWordMask());
		/* begin setHashBitsOf:to: */
		assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
		long32Atput(clone2 + 4, ((((long32At(clone2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
	}
	else {
		hash2 = (long32At(obj2 + 4)) & (identityHashHalfWordMask());
		/* begin setHashBitsOf:to: */
		assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask()))));
		long32Atput(clone1 + 4, ((((long32At(clone1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash2);
		hash3 = (long32At(obj1 + 4)) & (identityHashHalfWordMask());
		/* begin setHashBitsOf:to: */
		assert(((hash3 >= 0) && (hash3 <= (identityHashHalfWordMask()))));
		long32Atput(clone2 + 4, ((((long32At(clone2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash3);
	}
	/* begin forward:to: */
	classIndex = isForwardedObjectClassIndexPun();
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
	longAtput(obj1, ((longAt(obj1)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (7U << (formatShift()))));
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(obj1, (longAt(obj1)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#  endif

	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(obj1));
	assert(!(isOopForwarded(clone2)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(obj1)),
	oopisGreaterThanOrEqualTo(obj1, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(clone2 & (tagMask()))))
		 && (oopisLessThan(clone2, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(obj1)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj1);
			}
		}
	}
	longAtput((obj1 + BaseHeaderSize) + (0U << (shiftForWord())), clone2);
	if ((byteAt(obj1 + 7)) == 0) {
		/* begin rawNumSlotsOf:put: */
		byteAtput(obj1 + 7, 1);
	}
	classIndex1 = isForwardedObjectClassIndexPun();
	assert(((classIndex1 >= 0) && (classIndex1 <= (classIndexMask()))));
	assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
	longAtput(obj2, ((longAt(obj2)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex1 + (7U << (formatShift()))));
#  if IMMUTABILITY
	/* begin setIsImmutableOf:to: */
	longAtput(obj2, (longAt(obj2)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#  endif

	/* begin storePointer:ofForwarder:withValue: */
	assert(isForwarded(obj2));
	assert(!(isOopForwarded(clone1)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(obj2)),
	oopisGreaterThanOrEqualTo(obj2, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(clone1 & (tagMask()))))
		 && (oopisLessThan(clone1, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(obj2)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(obj2);
			}
		}
	}
	longAtput((obj2 + BaseHeaderSize) + (0U << (shiftForWord())), clone1);
	if ((byteAt(obj2 + 7)) == 0) {
		/* begin rawNumSlotsOf:put: */
		byteAtput(obj2 + 7, 1);
	}
	if ((((	/* begin isYoungObject: */
		assert(isNonImmediate(obj1)),
	oopisLessThan(obj1, GIV(oldSpaceStart)))) != ((	/* begin isYoungObject: */
		assert(isNonImmediate(clone2)),
	oopisLessThan(clone2, GIV(oldSpaceStart)))))
	 || (((	/* begin isYoungObject: */
		assert(isNonImmediate(obj2)),
	oopisLessThan(obj2, GIV(oldSpaceStart)))) != ((	/* begin isYoungObject: */
		assert(isNonImmediate(clone1)),
	oopisLessThan(clone1, GIV(oldSpaceStart)))))) {
		GIV(becomeEffectsFlags) = GIV(becomeEffectsFlags) | OldBecameNewFlag;
	}
}


/*	Attempt to pin objOop, which must not be immediate.
	If the attempt succeeds answer objOop's (possibly moved) oop.
	If the attempt fails, which can only occur if there is no memory, answer
	0.  */

	/* SpurMemoryManager>>#pinObject: */
sqInt
pinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt oldClone;
    sqInt referent;
    SpurSegmentInfo *seg;

	assert(isNonImmediate(objOop));
	assert(!((isForwarded(objOop))));
	flag("policy decision here. if already old, do we clone in a segment containing pinned objects or merely pin?");
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(objOop)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
		if ((numBytesOf(objOop)) > (0x100000)) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1U << (pinnedBitShift())));
			return objOop;
		}
		seg = segmentContainingObj(objOop);
		if ((seg->containsPinned)) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1U << (pinnedBitShift())));
			return objOop;
		}
		if (!(someSegmentContainsPinned())) {
			/* begin setIsPinnedOf:to: */
			longAtput(objOop, (longAt(objOop)) | (1U << (pinnedBitShift())));
			(seg->containsPinned = 1);
			return objOop;
		}
	}
	oldClone = cloneInOldSpaceforPinning(objOop, 1);
	if (oldClone != 0) {
		GIV(becomeEffectsFlags) = becomeEffectFlagsFor(objOop);
		/* begin setIsPinnedOf:to: */
		longAtput(oldClone, (longAt(oldClone)) | (1U << (pinnedBitShift())));
		/* begin forward:to: */
		classIndex = isForwardedObjectClassIndexPun();
		assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
		assert(((7 /* begin forwardedFormat */ >= 0) && (7 /* begin forwardedFormat */ <= (formatMask()))));
		longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (7U << (formatShift()))));
#    if IMMUTABILITY
		/* begin setIsImmutableOf:to: */
		longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (immutableBitShift()))));
#    endif // IMMUTABILITY

		/* begin storePointer:ofForwarder:withValue: */
		assert(isForwarded(objOop));
		assert(!(isOopForwarded(oldClone)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(objOop)),
		oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(oldClone & (tagMask()))))
			 && (oopisLessThan(oldClone, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop);
				}
			}
		}
		longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord())), oldClone);
		if ((byteAt(objOop + 7)) == 0) {
			/* begin rawNumSlotsOf:put: */
			byteAtput(objOop + 7, 1);
		}
		if ((!((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			GIV(validatedIntegerClassFlags) = 0;
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(GIV(specialObjectsOop)));
			referent = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent & (tagMask()))))
			 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			GIV(specialObjectsOop) = referent;
		}
		followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
		/* begin postBecomeAction: */
		spurPostBecomeAction(GIV(becomeEffectsFlags));
		if (((GIV(becomeEffectsFlags) & BecameJittedCompiledMethodFlag) != 0)) {
			freeBecomeFlaggedMethods();
		}
		followMovableLiteralsAndUpdateYoungReferrers();
		/* begin nilUncoggableMethods */
		GIV(lastCoggableInterpretedBlockMethod) = (GIV(lastUncoggableInterpretedBlockMethod) = null);
		assert(kosherYoungReferrers());
		GIV(gcMode) = 0;
		postBecomeScanClassTable(GIV(becomeEffectsFlags));
		GIV(becomeEffectsFlags) = 0;
	}
	return oldClone;
}

	/* SpurMemoryManager>>#popObjStack: */
static NoDbgRegParms sqInt
popObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt myx;
    sqInt nextPage;
    sqInt top;
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	topx -= 1;
	top = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)((topx + ObjStackFixedSlots)) << (shiftForWord())))));
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack)) == (wordIndexableFormat()));
	longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))), topx);
	if ((topx == 0)
	 && (((nextPage = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord()))))))) != 0)) {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))), objStack);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))), 0);
		myx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord())))));
		/* begin updateRootOfObjStackAt:with: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(GIV(hiddenRootsObj))),
		oopisGreaterThanOrEqualTo(GIV(hiddenRootsObj), GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(nextPage & (tagMask()))))
			 && (oopisLessThan(nextPage, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(GIV(hiddenRootsObj))))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(myx) << (shiftForWord())))), nextPage);
		switch (myx) {
		case MarkStackRootIndex:
			GIV(markStack) = nextPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = nextPage;
			break;
		case MournQueueRootIndex:
			GIV(mournQueue) = nextPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		eassert(isValidObjStack(nextPage));
	}
	else {
		eassert(isValidObjStack(objStack));
	}
	return top;
}


/*	Pop and return the possibly remapped object from the remap buffer.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#popRemappableOop */
sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	Scan the class table post-become (iff an active class object was becommed)
	to ensure no
	forwarding pointers, and no unhashed classes exist in the class table.
	
	Note that one-way become can cause duplications in the class table.
	So if pointer objects have been becommed, scan all pages in the class
	table and eliminate ay entries that have a zero hash.
	doBecome:and:copyHash: has
	already ensured that any becomed class has been stored at the right index. */

	/* SpurMemoryManager>>#postBecomeScanClassTable: */
static NoDbgRegParms void
postBecomeScanClassTable(sqInt effectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt i;
    sqInt j;
    sqInt jLimiT;
    usqInt numSlots;
    sqInt page;
    sqInt referent;

	assert(validClassTableRootPages());
	if (!(((effectsFlags & BecamePointerObjectFlag) != 0))) {
		return;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		assert(!(isForwarded(page)));
		for (j = 0, jLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(page)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(page + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(page - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))));
			if (classOrNil != GIV(nilObj)) {
				if ((!((longAt(classOrNil)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(classOrNil));
					referent = longAt((classOrNil + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					classOrNil = referent;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(page)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(page)),
					oopisGreaterThanOrEqualTo(page, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(classOrNil & (tagMask()))))
						 && (oopisLessThan(classOrNil, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(page)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(page);
							}
						}
					}
					longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))), classOrNil);
				}
				if (((long32At(classOrNil + 4)) & (identityHashHalfWordMask())) == 0) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(page)));
					longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))), GIV(nilObj));
					if (((((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j) < GIV(classTableIndex)) {
						GIV(classTableIndex) = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
}

	/* SpurMemoryManager>>#primitiveErrorTable */
sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(PrimitiveErrorTableIndex) << (shiftForWord())))));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printActivationsOf: */
void
printActivationsOf(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if ((((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex)
			 && (aMethodObj == (longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))))))) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				printOopShortInner(obj1);
				fflush(GIV(transcript));
				fprintf(GIV(transcript),
						"%s",
						" pc ");
				printHex(longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printBogons */
void
printBogons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printTheBogons: */
	fprintf(GIV(transcript),
			"%s",
			"bogon ");
	fprintf(GIV(transcript),
			"%p",
			((void *)GIV(bogon)));
	cr();
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"anomaly ");
	fprintf(GIV(transcript),
			"%p",
			((void *)GIV(anomaly)));
	cr();
}

	/* SpurMemoryManager>>#printBridge:on: */
static NoDbgRegParms void
printBridgeon(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a bridge hdr%d slot size %" PRIuSQINT "\n",
			((void *)oop),
			((byteAt(oop + 7)) == (numSlotsMask())
		? 16
		: 8),
			numSlotsOfAny(oop));
}

	/* SpurMemoryManager>>#printCantBeObject:on: */
static NoDbgRegParms void
printCantBeObjecton(sqInt oop, FILE *aStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((oop & (7)) == 0) {
		if ((		/* begin isInNewSpace: */
			(oopisLessThan(oop, GIV(oldSpaceStart)))
		 && (oopisGreaterThanOrEqualTo(oop, GIV(newSpaceStart))))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			printForwarderon(oop, aStream);
			return;
		}
		if (oop == (bridgeAt((numSegments()) - 1))) {
			printBridgeon(oop, aStream);
			return;
		}
	}
	fprintf(aStream,
			"%p%s\n",
			((void *)oop),
			((oop & (7)) != 0
		? " is misaligned"
		: whereIs(oop)));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printContextReferencesTo: */
void
printContextReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				i = CtxtTempFrameStart + (fetchStackPointerOf(obj1));
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
						printHex(obj1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" @ ");
						fprintf(GIV(transcript),
								"%" PRIdSQINT "",
								((sqInt)i));
						printChar(' ');
						printOopShortInner(obj1);
						fflush(GIV(transcript));
						fprintf(GIV(transcript),
								"%s",
								" pc ");
						printHex(longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))));
						cr();
						i = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printEntity: */
void
printEntity(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt n;
    sqInt n1;
    usqInt n2;
    sqInt printFlags;
    char *s;
    char *s1;
    char *s2;
    char *s3;
    char *s4;
    char *s5;
    char *s6;
    char *s7;

	printFlags = 0;
	printHex(oop);
	/* begin space */
	printChar(' ');
	if (!(addressCouldBeObj(oop))) {
		s = (((oop & (tagMask())) != 0)
			? "immediate"
			: "unknown");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s);
		return;
	}
	s1 = (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())
		? "free"
		: (((longAt(oop)) & (classIndexMask())) == (segmentBridgePun())
				? "bridge"
				: ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))
						? "forwarder"
						: (((longAt(oop)) & (classIndexMask())) <= (lastClassIndexPun())
								? ((printFlags = 1),
									"pun/obj stack")
								: ((printFlags = 1),
									"object")))));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			s1);
	printChar(' ');
	fprintf(GIV(transcript),
			"%" PRIxSQINT "",
			byteAt(oop + 7));
	fprintf(GIV(transcript),
			"%s",
			"/");
	n = bytesInBody(oop);
	/* begin printHexnpnp: */
	fprintf(GIV(transcript),
			"%" PRIxSQINT "",
			n);
	fprintf(GIV(transcript),
			"%s",
			"/");
	n1 = bytesInBody(oop);
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n1));
	if (printFlags) {
		/* begin space */
		printChar(' ');
		s2 = (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= 15
			? "f:0"
			: "f:");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s2);
		n2 = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
		/* begin printHexnpnp: */
		fprintf(GIV(transcript),
				"%" PRIxSQINT "",
				n2);
		s3 = (((((usqInt)((longAt(oop)))) >> (greyBitShift())) & 1) != 0
			? " g"
			: " .");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s3);
		s4 = (((((usqInt)((longAt(oop)))) >> (immutableBitShift())) & 1) != 0
			? "i"
			: ".");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s4);
		s5 = (((((usqInt)((longAt(oop)))) >> (markedBitFullShift())) & 1) != 0
			? "m"
			: ".");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s5);
		s6 = (((((usqInt)((longAt(oop)))) >> (pinnedBitShift())) & 1) != 0
			? "p"
			: ".");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s6);
		s7 = (((((usqInt)((longAt(oop)))) >> (rememberedBitShift())) & 1) != 0
			? "r"
			: ".");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s7);
	}
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printForwarders */
void
printForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	objOop = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop2 = GIV(nilObj);
	while (1) {
		assert((objOop2 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop2, GIV(endOfMemory)))) break;
		assert((long64At(objOop2)) != 0);
		if (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			printHex(objOop2);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop2);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop2 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop2 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())) {
			printHex(objOop1);
			cr();
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
}

	/* SpurMemoryManager>>#printForwarder:on: */
static NoDbgRegParms void
printForwarderon(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a forwarded hdr%d slot size %" PRIuSQINT " object to %p\n",
			((void *)oop),
			((byteAt(oop + 7)) == (numSlotsMask())
		? 16
		: 8),
			numSlotsOfAny(oop),
			((void *)(followForwarded(oop))));
}


/*	This version goes through memory, printing all free chunks.
	Other versions go through the free lists. This one will show
	all free chunks even if the free lists are corrupt. */
/*	useful for debugging */

	/* SpurMemoryManager>>#printFreeChunks */
void
printFreeChunks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt seenNewFreeChunk;
    usqInt start;

	o = 0;
	seenNewFreeChunk = 0;
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (((longAt(objOop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			if (!seenNewFreeChunk) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"NewSpace CONTAINS FREE OBJECT(S)!!");
				cr();
				seenNewFreeChunk = 1;
			}
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop, 1);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (((longAt(objOop1)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
			/* begin printFreeChunk: */
			printFreeChunkprintAsTreeNode(objOop1, 1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l4:	/* end objectAfter:limit: */;
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeChunk: */
void
printFreeChunk(sqInt freeChunk)
{
	printFreeChunkprintAsTreeNode(freeChunk, 1);
}

	/* SpurMemoryManager>>#printFreeChunk:printAsTreeNode: */
static NoDbgRegParms void
printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt n;
    usqInt n1;
    usqInt n2;
    usqInt n3;
    usqInt n4;
    usqInt n5;
    usqInt numBytes;
    char *s;

	numBytes = bytesInBody(freeChunk);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"freeChunk ");
	fprintf(GIV(transcript),
			"%p",
			((void *)freeChunk));
	if (printAsTreeNode) {
		s = (freeChunk == (GIV(freeLists)[0])
			? " + "
			: " - ");
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s);
		n = addressAfter(freeChunk);
		/* begin printHexnp: */
		fprintf(GIV(transcript),
				"%p",
				((void *)n));
	}
	fprintf(GIV(transcript),
			"%s",
			" bytes ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)numBytes));
	fprintf(GIV(transcript),
			"%s",
			" next ");
	n1 = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())));
	/* begin printHexnp: */
	fprintf(GIV(transcript),
			"%p",
			((void *)n1));
	if (!((		/* begin isLilliputianSize: */
			assert(numBytes >= (BaseHeaderSize + (allocationUnit()))),
		numBytes == (BaseHeaderSize + 8 /* begin allocationUnit */)))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" prev ");
		n2 = longAt((freeChunk + BaseHeaderSize) + (1U << (shiftForWord())));
		/* begin printHexnp: */
		fprintf(GIV(transcript),
				"%p",
				((void *)n2));
	}
	if ((numBytes >= (0x200))
	 && (printAsTreeNode)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" ^ ");
		n3 = longAt((freeChunk + BaseHeaderSize) + (2U << (shiftForWord())));
		/* begin printHexnp: */
		fprintf(GIV(transcript),
				"%p",
				((void *)n3));
		fprintf(GIV(transcript),
				"%s",
				" < ");
		n4 = longAt((freeChunk + BaseHeaderSize) + (3U << (shiftForWord())));
		/* begin printHexnp: */
		fprintf(GIV(transcript),
				"%p",
				((void *)n4));
		fprintf(GIV(transcript),
				"%s",
				" > ");
		n5 = longAt((freeChunk + BaseHeaderSize) + (4U << (shiftForWord())));
		/* begin printHexnp: */
		fprintf(GIV(transcript),
				"%p",
				((void *)n5));
	}
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeListHeads */
void
printFreeListHeads(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt expectedMask;
    sqInt i;
    sqInt iLimiT;

	expectedMask = 0;
	for (i = 0, iLimiT = (0x3F); i <= iLimiT; i += 1) {
		printHex(GIV(freeLists)[i]);
		if ((GIV(freeLists)[i]) != 0) {
			expectedMask += 1ULL << i;
		}
		if (((i + 1) % (4)) == 0) {
			cr();
		}
		else {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"  ");
		}
	}
	cr();
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"mask: ");
	fprintf(GIV(transcript),
			"%p",
			((void *)GIV(freeListsMask)));
	fprintf(GIV(transcript),
			"%s",
			" expected: ");
	fprintf(GIV(transcript),
			"%p",
			((void *)expectedMask));
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeList: */
sqInt
printFreeList(sqInt chunkOrIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;

	if ((chunkOrIndex >= 0)
	 && (chunkOrIndex < 64 /* begin numFreeLists */)) {
		return printFreeList(GIV(freeLists)[chunkOrIndex]);
	}
	freeChunk = chunkOrIndex;
	while (freeChunk != 0) {
		/* begin printFreeChunk: */
		printFreeChunkprintAsTreeNode(freeChunk, 1);
		freeChunk = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	return 0;
}

	/* SpurMemoryManager>>#printFreeObject:on: */
static NoDbgRegParms void
printFreeObjecton(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a free chunk of size %" PRIdSQINT " 0th field:%p\n",
			((void *)oop),
			bytesInBody(oop),
			((void *)(longAt((oop + BaseHeaderSize) + (0U << (shiftForWord()))))));
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeTree */
void
printFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFreeTreeChunk(GIV(freeLists)[0]);
}


/*	Slang is blind-sided by the inlining of printFreeTreeChunk: into
	printFreeTree. 
 */

	/* SpurMemoryManager>>#printFreeTreeChunk: */
static NoDbgRegParms void
printFreeTreeChunk(sqInt chunkOrZero)
{
	if (chunkOrZero > 0) {
		printFreeTreeChunk(longAt((chunkOrZero + BaseHeaderSize) + (3U << (shiftForWord()))));
		/* begin printFreeChunk: */
		printFreeChunkprintAsTreeNode(chunkOrZero, 1);
		printFreeTreeChunk(longAt((chunkOrZero + BaseHeaderSize) + (4U << (shiftForWord()))));
	}
}


/*	useful for VM debugging */
/*	N.B. No safety bounds checks!! We need to look e.g. at corpses. */

	/* SpurMemoryManager>>#printHeaderOf: */
void
printHeaderOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt n;
    usqInt n1;
    usqInt n2;
    usqInt n3;
    usqInt numSlots;


	/* begin printHexnp: */
	fprintf(GIV(transcript),
			"%p",
			((void *)objOop));
	if ((byteAt(objOop + 7)) == (numSlotsMask())) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" hdr16 slotf ");
		fprintf(GIV(transcript),
				"%p",
				((void *)(byteAt(objOop + 7))));
		fprintf(GIV(transcript),
				"%s",
				" slotc ");
		fprintf(GIV(transcript),
				"%p",
				((void *)(((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8)));
		printChar(' ');
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" hdr8 slots ");
		numSlots = byteAt(objOop + 7);
		n = (numSlots == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		/* begin printHexnp: */
		fprintf(GIV(transcript),
				"%p",
				((void *)n));
	}
	printChar(' ');
	printChar((((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0
		? 'M'
		: 'm'));
	printChar((((((usqInt)((longAt(objOop)))) >> (greyBitShift())) & 1) != 0
		? 'G'
		: 'g'));
	printChar((((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0
		? 'P'
		: 'p'));
	printChar((((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0
		? 'R'
		: 'r'));
	printChar((((((usqInt)((longAt(objOop)))) >> (immutableBitShift())) & 1) != 0
		? 'I'
		: 'i'));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" hash ");
	n1 = (long32At(objOop + 4)) & (identityHashHalfWordMask());
	/* begin printHexnp: */
	fprintf(GIV(transcript),
			"%p",
			((void *)n1));
	fprintf(GIV(transcript),
			"%s",
			" fmt ");
	n2 = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin printHexnp: */
	fprintf(GIV(transcript),
			"%p",
			((void *)n2));
	fprintf(GIV(transcript),
			"%s",
			" cidx ");
	n3 = (longAt(objOop)) & (classIndexMask());
	/* begin printHexnp: */
	fprintf(GIV(transcript),
			"%p",
			((void *)n3));
	cr();
}

	/* SpurMemoryManager>>#printImmediateObject:on: */
static NoDbgRegParms void
printImmediateObjecton(sqInt oop, FILE *aStream)
{
	assert(isImmediate(oop));
	if ((((oop) & 7) == 1)) {
		fprintf(aStream,
				"%p=%" PRIdSQINT "\n",
				((void *)oop),
				((sqInt)((oop >> 3))));
	}
	if (((oop & (characterTag())) != 0)) {
		fprintf(aStream,
				"%p=$%" PRIdSQINT " ($%lc)\n",
				((void *)oop),
				((long)(((((usqInt)oop))) >> (numTagBits()))),
				((wint_t) (((((usqInt)oop))) >> (numTagBits()))));
	}
	if (((oop & (smallFloatTag())) != 0)) {
		fprintf(aStream,
				"%p=%g\n",
				((void *)oop),
				floatValueOf(oop));
	}
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = (long32At(aClassOop + 4)) & (identityHashHalfWordMask());
	if (classIndex != (isFreeObjectClassIndexPun())) {
		printInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing the oops of any and all objects whose classIndex
	equals the argument.
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printInstancesWithClassIndex: */
void
printInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	obj = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((longAt(objOop)) & (classIndexMask())) == classIndex) {
			printHex(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((longAt(objOop1)) & (classIndexMask())) == classIndex) {
			printHex(objOop1);
			cr();
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
}


/*	Print the objects in the classTable that have bad hashes. */
/*	useful for debugging */

	/* SpurMemoryManager>>#printInvalidClassTableEntries */
void
printInvalidClassTableEntries(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt index1;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	classOrNil = 0;
	index = 0;
	if (!(validClassTableRootPages())) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"class table invalid; cannot print");
		cr();
		return;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		for (j = 0, jLimiT = ((1U << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil1 = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))));
			if (classOrNil1 != GIV(nilObj)) {
				index1 = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
				if (((!((longAt(classOrNil1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
				 || ((((hash = (long32At(classOrNil1 + 4)) & (identityHashHalfWordMask()))) == 0)
				 || ((noCheckClassAtIndex(hash)) != classOrNil1))) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"entry ");
					printHex(index1);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" oop ");
					printHex(classOrNil1);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" hash ");
					printHex(hash);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" => ");
					printHex(classAtIndex(hash));
					cr();
				}
			}
		}
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMarkedOops */
#if LLDB
void
printMarkedOops(void)
{
	printOopsSuchThat(isMarked);
}
#endif /* LLDB */


/*	Scan the heap printing the oops of any and all methods that implement
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMethodImplementorsOf: */
void
printMethodImplementorsOf(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if ((((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
			 && ((maybeSelectorOfMethod(obj1)) == anOop)) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				printOopShortInner(obj1);
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}


/*	Scan the heap printing the oops of any and all methods that refer to anOop */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    usqInt numSlots;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
				i = ((literalCountOf(obj1)) + LiteralStart) - 1;
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
						printHex(obj1);
						/* begin print: */
						fprintf(GIV(transcript),
								"%s",
								" @ ");
						fprintf(GIV(transcript),
								"%" PRIdSQINT "",
								((sqInt)i));
						printChar(' ');
						printOopShortInner(obj1);
						fflush(GIV(transcript));
						cr();
						i = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}

	/* SpurMemoryManager>>#printNonPointerDataOf:on: */
static NoDbgRegParms void
printNonPointerDataOfon(sqInt oop, FILE *aStream)
{
    sqInt elementsPerLine;
    sqInt format;
    sqInt index;
    sqInt lastIndex;
    usqInt numSlots;
    usqInt numSlots1;

	format = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	assert(((format >= (sixtyFourBitIndexableFormat())) && (format <= ((firstCompiledMethodFormat()) - 1))));
	/* begin lengthOf:format: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (format <= 5 /* begin ephemeronFormat */) {
		lastIndex = numSlots;
		goto l2;
	}
	if (format >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		lastIndex = (numSlots << (shiftForWord())) - (format & 7);
		goto l2;
	}
	if (format >= (firstShortFormat())) {
		lastIndex = (numSlots << ((shiftForWord()) - 1)) - (format & 3);
		goto l2;
	}
	if (format >= (firstLongFormat())) {
		lastIndex = (numSlots << ((shiftForWord()) - 2)) - (format & 1);
		goto l2;
	}
	if (format == (sixtyFourBitIndexableFormat())) {
		lastIndex = numSlots;
		goto l2;
	}
	lastIndex = 0;
	l2:	/* end lengthOf:format: */;
	if (lastIndex == 0) {
		return;
	}
	if (format == (sixtyFourBitIndexableFormat())) {
		lastIndex = ((32 < lastIndex) ? 32 : lastIndex);
		/* 0x/16r0123456789ABCDEF<space|cr> x 4 = 76/80 */
		elementsPerLine = 4;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%18" PRIXSQINT "%c",
					((usqLong) (long64At((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 3)))))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
				? '\n'
				: ' '));
		}
		return;
	}
	if (format < (firstShortFormat())) {
		lastIndex = ((64 < lastIndex) ? 64 : lastIndex);
		/* 0x/16r12345678<space|cr> x 8 = 80/88 */
		elementsPerLine = 8;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%10p%c",
					((void *)(long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2)))))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
				? '\n'
				: ' '));
		}
		return;
	}
	if (format < (firstByteFormat())) {
		lastIndex = ((128 < lastIndex) ? 128 : lastIndex);
		/* 0x/16r1234<space|cr> x 10 = 70/80 */
		elementsPerLine = 10;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%6p%c",
					((void *)(shortAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1)))))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
				? '\n'
				: ' '));
		}
		return;
	}
	lastIndex = ((0x100 < lastIndex) ? 0x100 : lastIndex);
	/* 0x/16r12<space|cr> x 16 = 80/96 */
	elementsPerLine = 16;
	for (index = 1; index <= lastIndex; index += 1) {
		fprintf(aStream,
				"%4p%c",
				((void *)(byteAt((oop + BaseHeaderSize) + (index - 1)))),
				(((index % elementsPerLine) == 0)
		 || (index == lastIndex)
			? '\n'
			: ' '));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress)) {
		if (!((((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun()))
			 || (((longAt(oop)) & (classIndexMask())) == (segmentBridgePun())))) {
			printOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all objects whose hash equals
	the argument.
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printObjectsWithHash: */
void
printObjectsWithHash(sqInt hash)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	obj = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((long32At(objOop + 4)) & (identityHashHalfWordMask())) == hash) {
			shortPrintOop(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((long32At(objOop1 + 4)) & (identityHashHalfWordMask())) == hash) {
			shortPrintOop(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
}

	/* SpurMemoryManager>>#printObjStackAndContents: */
void
printObjStackAndContents(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin printObjStack:printContents: */
	if (objStack == GIV(nilObj)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"nil");
		cr();
	}
	else {
		printObjStackPagemyIndexpageTypeprintContents(objStack, longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord()))))), ObjStackMyx, 1);
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:pageType:printContents: */
static NoDbgRegParms void
printObjStackPagemyIndexpageTypeprintContents(sqInt objStackPage, sqInt myx, sqInt pageType, sqInt printContents)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    int isFirstPage;
    int isFreePage;
    int isNextPage;
    sqInt page;

	isFirstPage = pageType == ObjStackMyx;
	isNextPage = pageType == ObjStackNextx;
	isFreePage = pageType == ObjStackFreex;
	printObjStackPagemyIndextag(objStackPage, myx, (isFirstPage
		? "head"
		: (isFreePage
				? "free"
				: "next")));
	if (isFirstPage
	 || (isNextPage)) {
		/* begin tab */
		printChar('\t');
		fprintf(GIV(transcript),
				"%s",
				"topx: ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord()))))))));
		fprintf(GIV(transcript),
				"%s",
				" next: ");
		printHex(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord()))))));
		if (isFirstPage) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" free: ");
			printHex(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord()))))));
		}
		cr();
	}
	if (isFirstPage) {
		freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
		while (freeOrNextPage != 0) {
			printObjStackPagemyIndexpageTypeprintContents(freeOrNextPage, myx, ObjStackFreex, 0);
			page = longAt((freeOrNextPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
			if ((page == freeOrNextPage)
			 || (page == objStackPage)) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"circularity in free page list!!");
				cr();
				page = 0;
			}
			freeOrNextPage = page;
		}
	}
	freeOrNextPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
	if (freeOrNextPage != 0) {
		printObjStackPagemyIndexpageTypeprintContents(freeOrNextPage, myx, ObjStackNextx, printContents);
	}
	if (printContents) {
		index = (longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))) + ObjStackNextx;
		while (index >= ObjStackFixedSlots) {
			/* begin space */
			printChar(' ');
			printHex(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord()))))));
			index -= 1;
		}
		if (((longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))) + ObjStackNextx) >= ObjStackFixedSlots) {
			cr();
		}
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:tag: */
static NoDbgRegParms void
printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt n;
    sqInt n1;
    sqInt n2;
    sqInt n3;
    sqInt n4;
    usqInt numSlots;
    char *s;


	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			pageType);
	printChar(' ');
	printHex(objStackPage);
	/* begin space */
	printChar(' ');
	fprintf(GIV(transcript),
			"%s",
			"cx ");
	n = (longAt(objStackPage)) & (classIndexMask());
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n));
	fprintf(GIV(transcript),
			"%s",
			" (");
	n1 = sixtyFourBitLongsClassIndexPun();
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n1));
	fprintf(GIV(transcript),
			"%s",
			") fmt ");
	n2 = (((usqInt)((longAt(objStackPage)))) >> (formatShift())) & (formatMask());
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n2));
	fprintf(GIV(transcript),
			"%s",
			" (");
	n3 = sixtyFourBitIndexableFormat();
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n3));
	fprintf(GIV(transcript),
			"%s",
			") sz ");
	numSlots = byteAt(objStackPage + 7);
	n4 = (numSlots == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objStackPage - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n4));
	fprintf(GIV(transcript),
			"%s",
			" (");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)ObjStackPageSlots));
	fprintf(GIV(transcript),
			"%s",
			") myx: ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)(longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord()))))))));
	fprintf(GIV(transcript),
			"%s",
			" (");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)myx));
	s = (((((usqInt)((longAt(objStackPage)))) >> (markedBitFullShift())) & 1) != 0
		? ") mkd"
		: ") unmkd");
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			s);
	cr();
}


/*	useful for debugging */

	/* SpurMemoryManager>>#printObjStack: */
void
printObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin printObjStack:printContents: */
	if (objStack == GIV(nilObj)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"nil");
		cr();
	}
	else {
		printObjStackPagemyIndexpageTypeprintContents(objStack, longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackMyx) << (shiftForWord()))))), ObjStackMyx, 0);
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsExcept: */
NeverInline void
printOopsExcept(sqInt (*function)(sqInt))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt n;
    usqInt numSlots;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	o = 0;
	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (!(function(objOop))) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (!(function(objOop1))) {
			n += 1;
			printEntity(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
	if (n > 4) {
		/* rabbits */
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
		fprintf(GIV(transcript),
				"%s",
				" objects");
		cr();
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsFrom:to: */
void
printOopsFromto(sqInt startAddress, sqInt endAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstNonEntity;
    sqInt inEmptySpace;
    sqInt lastNonEntity;
    sqInt limit;
    usqInt numSlots;
    sqInt oop;

	firstNonEntity = 0;
	oop = objectBefore(startAddress);
	limit = (((((usqIntptr_t)endAddress)) < GIV(endOfMemory)) ? (((usqIntptr_t)endAddress)) : GIV(endOfMemory));
	if (oop == null) {
		oop = startAddress;
	}
	else {
		if ((objectAfter(oop)) == startAddress) {
			oop = startAddress;
		}
		else {
		}
	}
	inEmptySpace = 0;
	while (oopisLessThan(oop, limit)) {
		printEntity(oop);
		while (1) {
			oop = objectAfter(oop);
			if (!((long64At(oop)) == 0)) break;
			if (!inEmptySpace) {
				inEmptySpace = 1;
				firstNonEntity = oop;
			}
			lastNonEntity = oop;
		}
		if (inEmptySpace) {
			inEmptySpace = 0;
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"skipped empty space from ");
			fprintf(GIV(transcript),
					"%p",
					((void *)firstNonEntity));
			fprintf(GIV(transcript),
					"%s",
					" to ");
			fprintf(GIV(transcript),
					"%p",
					((void *)lastNonEntity));
			cr();
			/* begin objectStartingAt: */
			numSlots = byteAt(oop + 7);
			oop = (numSlots == (numSlotsMask())
				? oop + BaseHeaderSize
				: oop);
		}
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsSuchThat: */
NeverInline void
printOopsSuchThat(sqInt (*function)(sqInt))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt n;
    usqInt numSlots;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	o = 0;
	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (function(objOop)) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (function(objOop1)) {
			n += 1;
			printEntity(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
	if (n > 4) {
		/* rabbits */
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
		fprintf(GIV(transcript),
				"%s",
				" objects");
		cr();
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt contextSize;
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt header;
    sqInt header1;
    sqInt i;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt sp;
    sqInt startObject;

	obj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots1 = byteAt(address + 7);
	startObject = (numSlots1 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			/* begin numPointerSlotsOf: */
			fmt = (((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask());
			if (fmt <= 5 /* begin lastPointerFormat */) {
				if ((fmt == (indexablePointersFormat()))
				 && (((longAt(obj1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((((sp) & 7) == 1))) {
						contextSize = 0;
						goto l1;
					}
					assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(obj1)));
					contextSize = (sp >> 3);
	l1:	/* end fetchStackPointerOf: */;
					i = ((usqInt) (CtxtTempFrameStart + contextSize));
					goto l3;
				}
				/* begin numSlotsOf: */
				assert((classIndexOf(obj1)) > (isForwardedObjectClassIndexPun()));
				if (((numSlots = byteAt(obj1 + 7))) == (numSlotsMask())) {
					/* overflow slots; at least (2^32)-1 slots, which is plenty */
					i = ((((usqInt)(((sqInt)((usqInt)((longAt(obj1 - BaseHeaderSize))) << 8)))))) >> 8;
				}
				else {
					i = numSlots;
				}
				goto l3;
			}
			if (fmt == 7 /* begin forwardedFormat */) {
				i = 1;
				goto l3;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				i = 0;
				goto l3;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(obj1));
			header1 = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			header = ((((header1) & 7) == 1)
				? header1
				: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
					assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
					((((CogMethod *) header1))->methodHeader)));
			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			i = ((usqInt) (numLiterals + LiteralStart));
	l3:	/* end numPointerSlotsOf: */;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					printHex(obj1);
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" @ ");
					fprintf(GIV(transcript),
							"%" PRIdSQINT "",
							((sqInt)i));
					printChar(' ');
					printOopShortInner(obj1);
					fflush(GIV(transcript));
					cr();
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l5;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l5:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}

	/* SpurMemoryManager>>#printStringDataOf:on: */
static NoDbgRegParms void
printStringDataOfon(sqInt oop, FILE *aStream)
{
    char *buffer;
    sqInt byte;
    sqInt i;
    sqInt limit;
    sqInt n;
    unsigned int *wideBuffer;
    int word;

	if (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())) {
		buffer = ((char *) (alloca(0x400)));
		n = (i = 0);
		limit = (((numBytesOfBytes(oop)) < 0x100) ? (numBytesOfBytes(oop)) : 0x100);
		while (n < limit) {
			byte = byteAt((oop + BaseHeaderSize) + i);
			i += 1;
			if ((byte < 32)
			 && (byte != 9)) {
				buffer[n] = '<';
				n += 1;
				if ((byte == 10)
				 || (byte == 13)) {
					if (byte == 10) {
						buffer[n] = 'L';
						buffer[n + 1] = 'F';
					}
					else {
						buffer[n] = 'C';
						buffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (byte >= 10) {
						buffer[n] = ((byte / 10) + (((sqInt)'0')));
						n += 1;
					}
					buffer[n] = ((byte % 10) + (((sqInt)'0')));
					n += 1;
				}
				buffer[n] = '>';
				n += 1;
			}
			else {
				buffer[n] = byte;
				n += 1;
			}
		}
		fprintf(aStream,
				"%.*s%s\n",
				((int) n),
				buffer,
				((numBytesOfBytes(oop)) > limit
			? "..."
			: ""));
	}
	else {
		assert(isWordsNonImm(oop));
		wideBuffer = ((unsigned int *) (alloca(0x1000)));
		n = (i = 0);
		limit = (((lengthOf(oop)) < 0x100) ? (lengthOf(oop)) : 0x100);
		while (i < limit) {
			word = long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(i) << 2))));
			i += 1;
			if ((word < 32)
			 && (word != 9)) {
				wideBuffer[n] = '<';
				n += 1;
				if ((word == 10)
				 || (word == 13)) {
					if (word == 10) {
						wideBuffer[n] = 'L';
						wideBuffer[n + 1] = 'F';
					}
					else {
						wideBuffer[n] = 'C';
						wideBuffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (word >= 10) {
						wideBuffer[n] = ((word / 10) + (((sqInt)'0')));
						n += 1;
					}
					wideBuffer[n] = ((word % 10) + (((sqInt)'0')));
					n += 1;
				}
				wideBuffer[n] = '>';
				n += 1;
			}
			else {
				wideBuffer[n] = word;
				n += 1;
			}
		}
		fwprintf(aStream,
				L"%.*ls%s\n",
				((int) n),
				wideBuffer,
				((lengthOf(oop)) > limit
			? "..."
			: ""));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printUnmarkedOops */
#if LLDB
void
printUnmarkedOops(void)
{
	printOopsExcept(isMarked);
}
#endif /* LLDB */


/*	Attempt to push anEphemeron on the unscanned ephemerons stack
	and answer if the attempt succeeded. Note that the ephemeron
	stack overflowing isn't a disaster; it simply means treating the
	ephemeron as strong in this GC cycle. */

	/* SpurMemoryManager>>#pushOnUnscannedEphemeronsStack: */
static NoDbgRegParms sqInt
pushOnUnscannedEphemeronsStack(sqInt anEphemeron)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isEphemeron(anEphemeron));
	if (((GIV(unscannedEphemerons).top)) >= ((GIV(unscannedEphemerons).limit))) {
		return 0;
	}
	longAtput((GIV(unscannedEphemerons).top), anEphemeron);
	(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) + BytesPerOop);
	return 1;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that
	objects in temporary variables are properly remapped.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}


/*	Add the ephemeron or weak array to the queue. */

	/* SpurMemoryManager>>#queueMourner: */
static NoDbgRegParms void
queueMourner(sqInt anEphemeronOrWeakArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objStack;

	assert((isNonImmediate(anEphemeronOrWeakArray))
	 && (((formatOf(anEphemeronOrWeakArray)) == (ephemeronFormat()))
	 || ((formatOf(anEphemeronOrWeakArray)) == (weakArrayFormat()))));
	assert(!((((formatOf(anEphemeronOrWeakArray)) == (ephemeronFormat()))
 && (isonObjStack(anEphemeronOrWeakArray, GIV(mournQueue))))));
	ensureRoomOnObjStackAt(MournQueueRootIndex);
	if (!(isEphemeron(anEphemeronOrWeakArray))) {
		if (isonObjStack(anEphemeronOrWeakArray, GIV(mournQueue))) {
			return;
		}
	}
	objStack = GIV(mournQueue);
	/* begin push:onObjStack: */
	assert(addressCouldBeOop(anEphemeronOrWeakArray));
	if (((anEphemeronOrWeakArray & (tagMask())) != 0)) {
		assert(objStack == GIV(markStack));
		assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
			? fetchPointerofObject(ObjStackNextx, objStack)
			: objStack))));
	}
	else {
		/* There should be no weaklings on the mark stack. */
		assert(!((objStack == GIV(markStack))
		 && (isWeakNonImm(anEphemeronOrWeakArray))));
		assert((objStack != GIV(weaklingStack))
		 || (isWeakNonImm(anEphemeronOrWeakArray)));
	}
	noCheckPushonObjStack(anEphemeronOrWeakArray, objStack);
}

	/* SpurMemoryManager>>#rawHashBitsOf: */
sqInt
rawHashBitsOf(sqInt objOop)
{
	flag("endianness");
	return (long32At(objOop + 4)) & (identityHashHalfWordMask());
}


/*	Answer the tag bits for the receiver based on the method's methodClass, if
	any. These bits are extended with a bit that says that the method may have
	a Context receiver, i.e.
	mclass is Context or its superclasses. The absence of this bit is used to
	avoid expensive store checks, etc. */

	/* SpurMemoryManager>>#receiverTagBitsForMethod: */
sqInt
receiverTagBitsForMethod(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classContextOrSuperclass;
    sqInt literal;
    sqInt methodClassOrNil;
    sqInt objOop;
    sqInt objOop1;
    sqInt offset;

	/* begin methodClassOf: */
	offset = (literalCountOf(aMethodObj)) - 1;
	/* begin followField:ofObject: */
	objOop = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, aMethodObj, objOop);
	}
	literal = objOop;
	if ((literal != GIV(nilObj))
	 && (	/* begin isPointers: */
		((!(literal & (tagMask()))))
	 && (((((usqInt)((longAt(literal)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))) {
		/* filters out fullBlock last literal */
		assert((numSlotsOf(literal)) > ValueIndex);
		/* begin followField:ofObject: */
		objOop1 = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop1 & (tagMask()))))
		 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop1);
		}
		methodClassOrNil = objOop1;
	}
	else {
		methodClassOrNil = GIV(nilObj);
	}
	if (methodClassOrNil == GIV(nilObj)) {
		/* If we don't know the methodClass be pessimal */
		return (1U << (numTagBits()));
	}
	if (((((usqInt)((((longAt((methodClassOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask())) == 7 /* begin forwardedFormat */) {
		/* begin receiverTagBitsForImmediateMethodClass: */
		if (methodClassOrNil == (longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)((smallIntegerTag())) << (shiftForWord()))))))) {
			return smallIntegerTag();
		}
		if (methodClassOrNil == (longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)((characterTag())) << (shiftForWord()))))))) {
			return characterTag();
		}
		assert(methodClassOrNil == (fetchPointerofObject(smallFloatTag(), GIV(classTableFirstPage))));
		return smallFloatTag();
	}
	/* begin knownClassAtIndex: */
	assert(((ClassMethodContextCompactIndex >= 1) && (ClassMethodContextCompactIndex <= (classTablePageSize()))));
	classContextOrSuperclass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMethodContextCompactIndex) << (shiftForWord())))));
	do {
		if (classContextOrSuperclass == methodClassOrNil) {
			return (1U << (numTagBits()));
		}
		classContextOrSuperclass = longAt((classContextOrSuperclass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	} while(classContextOrSuperclass != GIV(nilObj));
	return 0;
}


/*	Relocate all objStack pages that comprise objStack, including contents if
	requested. 
 */

	/* SpurMemoryManager>>#relocateObjStackForPlanningCompactor:andContents: */
static NoDbgRegParms sqInt
relocateObjStackForPlanningCompactorandContents(sqInt objStack, sqInt relocateContents)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt finishIndex;
    sqInt freeList;
    sqInt fwd;
    sqInt fwd1;
    sqInt i;
    sqInt i1;
    sqInt next;
    sqInt oop;
    sqInt oop1;
    sqInt relocated;
    sqInt result;
    sqInt stackOrNil;

	if (objStack == GIV(nilObj)) {
		return objStack;
	}
	assert((relocateContents
		? (rawHashBitsOf(objStack)) < ObjStackLimit
		: (rawHashBitsOf(objStack)) == 0));
	stackOrNil = objStack;
	freeList = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
	while (1) {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		next = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
		finishIndex = ObjStackNextx + ((relocateContents
	? (long32At(stackOrNil + 4)) & (identityHashHalfWordMask())
	: 0));
		/* begin relocateObjectsInHeapEntity:from:to: */
		for (i = ObjStackFreex; i <= finishIndex; i += 1) {
			oop = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
			if (((!(oop & (tagMask()))))
			 && (			/* begin isMobile: */
				(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject)))
			 && (!(((((usqInt)((longAt(oop)))) >> (pinnedBitShift())) & 1) != 0)))) {
				assert(isMarked(oop));
				fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
				assert(isPostMobile(fwd));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(stackOrNil)));
				longAtput((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), fwd);
			}
		}
		relocated = (		/* begin isMobile: */
			(oopisGreaterThanOrEqualToandLessThanOrEqualTo(stackOrNil, GIV(mobileStart), GIV(lastMobileObject)))
		 && (!(((((usqInt)((longAt(stackOrNil)))) >> (pinnedBitShift())) & 1) != 0))
			? longAt((stackOrNil + BaseHeaderSize) + (0U << (shiftForWord())))
			: stackOrNil);
		if (stackOrNil == objStack) {
			result = relocated;
		}
		if (!(next != 0)) break;
		stackOrNil = next;
	}
	while (freeList != 0) {
		assert((numSlotsOfAny(freeList)) == ObjStackPageSlots);
		next = longAt((freeList + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))));
		/* begin relocateObjectsInHeapEntity:from:to: */
		for (i1 = ObjStackFreex; i1 <= ObjStackFreex; i1 += 1) {
			oop1 = longAt((freeList + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			if (((!(oop1 & (tagMask()))))
			 && (			/* begin isMobile: */
				(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop1, GIV(mobileStart), GIV(lastMobileObject)))
			 && (!(((((usqInt)((longAt(oop1)))) >> (pinnedBitShift())) & 1) != 0)))) {
				assert(isMarked(oop1));
				fwd1 = longAt((oop1 + BaseHeaderSize) + (0U << (shiftForWord())));
				assert(isPostMobile(fwd1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(freeList)));
				longAtput((freeList + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), fwd1);
			}
		}
		if (		/* begin isMobile: */
			(oopisGreaterThanOrEqualToandLessThanOrEqualTo(freeList, GIV(mobileStart), GIV(lastMobileObject)))
		 && (!(((((usqInt)((longAt(freeList)))) >> (pinnedBitShift())) & 1) != 0))) {
			/* begin fetchPointer:ofObject: */
			longAt((freeList + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		else {
		}
		freeList = next;
	}
	return relocated;
}


/*	Remove the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#removeGCRoot: */
sqInt
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {
			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:. */

	/* SpurMemoryManager>>#return:restoringObjectsIn:savedFirstFields:and:savedHashes: */
static NoDbgRegParms sqInt
returnrestoringObjectsInsavedFirstFieldsandsavedHashes(sqInt errCode, sqInt firstArray, sqInt savedFirstFields, sqInt secondArray, sqInt savedHashes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int hash;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt oop;
    sqInt oop1;


	/* begin restoreObjectsIn:upTo:savedFirstFields: */
	numSlots = (	/* begin numSlotsOf: */
		assert((classIndexOf(firstArray)) > (isForwardedObjectClassIndexPun())),
	(((numSlots1 = byteAt(firstArray + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(firstArray - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1));
	for (i = 0; i < numSlots; i += 1) {
		oop = longAt((firstArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(oop)));
		longAtput((oop + BaseHeaderSize) + (0U << (shiftForWord())), longAt((savedFirstFields + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop)));
		longAtput(oop, (longAt(oop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedFirstFields, GIV(oldSpaceStart), GIV(endOfMemory))) {
		freeObject(savedFirstFields);
	}
	/* begin restoreObjectsIn:savedHashes: */
	for (i1 = 0, iLimiT = (((assert((classIndexOf(secondArray)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(secondArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(secondArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) - 1); i1 <= iLimiT; i1 += 1) {
		if (((hash = long32At((savedHashes + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << 2)))))) > (identityHashHalfWordMask())) {
			if (oopisGreaterThanOrEqualToandLessThan(savedHashes, GIV(oldSpaceStart), GIV(endOfMemory))) {
				freeObject(savedHashes);
			}
			goto l2;
		}
		oop1 = longAt((secondArray + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(oop1 + 4, ((((long32At(oop1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop1)));
		longAtput(oop1, (longAt(oop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedHashes, GIV(oldSpaceStart), GIV(endOfMemory))) {
		freeObject(savedHashes);
	}
	l2:	/* end restoreObjectsIn:savedHashes: */;
	runLeakCheckerFor(GCCheckImageSegment);
	assert(allObjectsUnmarked());
	return errCode;
}


/*	This is part of storeImageSegmentInto:outPointers:roots:. */

	/* SpurMemoryManager>>#return:restoringObjectsIn:upTo:savedFirstFields: */
static NoDbgRegParms sqInt
returnrestoringObjectsInupTosavedFirstFields(sqInt errCode, sqInt firstArray, sqInt limitOrTag, sqInt savedFirstFields)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;


	/* begin restoreObjectsIn:upTo:savedFirstFields: */
	numSlots = (limitOrTag == -1
		? (			/* begin numSlotsOf: */
				assert((classIndexOf(firstArray)) > (isForwardedObjectClassIndexPun())),
			(((numSlots1 = byteAt(firstArray + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(firstArray - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1))
		: limitOrTag);
	for (i = 0; i < numSlots; i += 1) {
		oop = longAt((firstArray + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(oop)));
		longAtput((oop + BaseHeaderSize) + (0U << (shiftForWord())), longAt((savedFirstFields + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
		/* begin setIsMarkedOf:to: */
		assert(!(isFreeObject(oop)));
		longAtput(oop, (longAt(oop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
	}
	if (oopisGreaterThanOrEqualToandLessThan(savedFirstFields, GIV(oldSpaceStart), GIV(endOfMemory))) {
		freeObject(savedFirstFields);
	}
	runLeakCheckerFor(GCCheckImageSegment);
	assert(allObjectsUnmarked());
	return errCode;
}


/*	This exists to get around a compiler bug in Apple LLVM version 7.0.0
	(clang-700.1.76) that was avoiding the second comparison of segVersion
	after the first byte swap. */

	/* SpurMemoryManager>>#reverseBytesIn32BitWordsIn: */
static NoDbgRegParms NeverInline void
reverseBytesIn32BitWordsIn(sqInt segmentWordArray)
{
    sqInt addr;
    sqInt stopAddr;

	stopAddr = addressAfter(segmentWordArray);
	/* begin reverseBytesIn32BitWordsFrom:to: */
	addr = segmentWordArray + BaseHeaderSize;
	while (oopisLessThan(addr, stopAddr)) {
		long32Atput(addr, SQ_SWAP_4_BYTES((long32At(addr))));
		addr += 4;
	}
}


/*	Check free space integrity by setting bits in the map corresponding to all
	free space objects
	and checking tat no pointer field refers to a free object. anOopOrNil is
	provided to filter-out
	the as-yet-to-be initialized object in
	primitiveShallowCopy/primitiveClone. 
 */

	/* SpurMemoryManager>>#runLeakCheckerForFreeSpace:ignoring: */
static NoDbgRegParms void
runLeakCheckerForFreeSpaceignoring(sqInt gcModes, sqInt anOopOrNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (((gcModes & GCCheckFreeSpace) != 0)) {
		reverseDisplayFromto(16, 19);
		clearLeakMapAndMapAccessibleFreeSpace();
		GIV(freeSpaceCheckOopToIgnore) = anOopOrNil;
		asserta(checkHeapFreeSpaceIntegrity());
		GIV(freeSpaceCheckOopToIgnore) = null;
	}
}

	/* SpurMemoryManager>>#runLeakCheckerFor: */
static NoDbgRegParms void
runLeakCheckerFor(sqInt gcModes)
{

	/* begin inLineRunLeakCheckerFor:excludeUnmarkedObjs:classIndicesShouldBeValid: */
	if (((gcModes & checkForLeaks) != 0)) {
		if (((gcModes & GCModeFull) != 0)) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		asserta(checkHeapIntegrityclassIndicesShouldBeValid(0, 1));
		asserta((checkInterpreterIntegrity()) == 0);
		asserta(checkStackIntegrity());
		asserta(checkCodeIntegrity(gcModes));
		if (((gcModes & GCCheckFreeSpace) != 0)) {
			clearLeakMapAndMapAccessibleFreeSpace();
			asserta(checkHeapFreeSpaceIntegrity());
		}
	}
	return;
}

	/* SpurMemoryManager>>#runLeakCheckerFor:excludeUnmarkedObjs:classIndicesShouldBeValid: */
static NoDbgRegParms void
runLeakCheckerForexcludeUnmarkedObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid)
{

	/* begin inLineRunLeakCheckerFor:excludeUnmarkedObjs:classIndicesShouldBeValid: */
	if (((gcModes & checkForLeaks) != 0)) {
		if (((gcModes & GCModeFull) != 0)) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		asserta(checkHeapIntegrityclassIndicesShouldBeValid(excludeUnmarkedObjs, classIndicesShouldBeValid));
		asserta((checkInterpreterIntegrity()) == 0);
		asserta(checkStackIntegrity());
		asserta(checkCodeIntegrity(gcModes));
		if (((gcModes & GCCheckFreeSpace) != 0)) {
			clearLeakMapAndMapAccessibleFreeSpace();
			asserta(checkHeapFreeSpaceIntegrity());
		}
	}
}


/*	Run the scavenger. */

	/* SpurMemoryManager>>#scavengingGCTenuringIf: */
static NoDbgRegParms void
scavengingGCTenuringIf(sqInt tenuringCriterion)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt n;
    sqInt n1;
    sqInt n2;
    sqInt probe;

	assert(GIV(remapBufferCount) == 0);
	if (!(asserta(((((eden()).limit)) - GIV(freeStart)) > (interpreterAllocationReserveBytes())))) {
		/* begin tab */
		printChar('\t');
		n = (((eden()).limit)) - GIV(freeStart);
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
		printChar(' ');
		n1 = interpreterAllocationReserveBytes();
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n1));
		printChar(' ');
		n2 = (interpreterAllocationReserveBytes()) - ((((eden()).limit)) - GIV(freeStart));
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n2));
		cr();
	}
	/* begin checkMemoryMap */
	assert(isYoungObject(GIV(newSpaceStart)));
	assert(!(isOldObject(GIV(newSpaceStart))));
	assert(isYoungObject(GIV(oldSpaceStart) - BytesPerWord));
	assert(!(isOldObject(GIV(oldSpaceStart) - BytesPerWord)));
	assert(!(isYoungObject(GIV(oldSpaceStart))));
	assert(isOldObject(GIV(oldSpaceStart)));
	assert(!(isYoungObject(GIV(endOfMemory))));
	assert(isOldObject(GIV(endOfMemory)));
	assert(!(isOldObject(minCogMethodAddress())));
	assert(!(isOldObject(maxCogMethodAddress())));
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeNewSpace)) == (GCCheckFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	runLeakCheckerFor(GCModeNewSpace);
	preGCAction(GCModeNewSpace);
	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if ((((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheSelector], GIV(newSpaceStart)))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheSelector], GIV(oldSpaceStart))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheClass], GIV(newSpaceStart)))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheClass], GIV(oldSpaceStart)))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheMethod], GIV(newSpaceStart)))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheMethod], GIV(oldSpaceStart))))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	doScavenge(tenuringCriterion);
	GIV(statScavenges) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statSGCDeltaUsecs) = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statScavengeGCUsecs) += GIV(statSGCDeltaUsecs);
	GIV(statRootTableCount) = rememberedSetSize();
	/* begin logScavenge */
	if (!(GIV(scavengeLog) == null)) {
		writeScavengeLog();
	}
	postGCAction(GCModeNewSpace);
	runLeakCheckerFor(GCModeNewSpace);
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeNewSpace)) == (GCCheckFreeSpace | GCModeNewSpace))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
}


/*	Set the dimensions of the heap, answering the start of oldSpace. edenBytes
	holds the desired ``size of eden''
	which is actually the total size of new space minus the reserve. edenBytes
	is then divided up between eden
	and the two survivor spaces, where each survivor space is a
	scavengerDenominator (one seventh) of the total. */
/*	Transcript
	cr; nextPutAll: 'heapBase: '; print: baseOfHeap; nextPut: $/; nextPutAll:
	baseOfHeap hex;
	nextPutAll: ' memLimit '; print: memLimit; nextPut: $/; nextPutAll:
	memLimit hex;
	nextPutAll: ' memEnd '; print: memEnd; nextPut: $/; nextPutAll: memEnd
	hex; cr; flush. */
/*	This is more than a little counter-intuitive. Eden must include
	interpreterAllocationReserveBytes. 
 */

	/* SpurMemoryManager>>#setHeapBase:memoryLimit:endOfMemory: */
static NoDbgRegParms NeverInline sqInt
setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualEdenBytes;
    sqInt oldStart;
    sqInt reserve;
    sqInt survivorBytes;
    sqInt totalBytes;

	reserve = interpreterAllocationReserveBytes();
	GIV(newSpaceStart) = baseOfHeap;
	GIV(oldSpaceStart) = (baseOfHeap + GIV(edenBytes)) + reserve;
	totalBytes = GIV(oldSpaceStart) - GIV(newSpaceStart);
	/* begin newSpaceStart:newSpaceBytes:survivorBytes: */
	survivorBytes = ((((GIV(oldSpaceStart) - GIV(newSpaceStart)) - reserve) / 7 /* begin scavengerDenominator */) & ~7);
	actualEdenBytes = (((totalBytes - survivorBytes) - survivorBytes) & ~7);
	assert((((totalBytes - actualEdenBytes) - survivorBytes) - survivorBytes) < (allocationUnit()));
	(GIV(pastSpace).start = GIV(newSpaceStart));
	(GIV(pastSpace).limit = GIV(newSpaceStart) + survivorBytes);
	(GIV(futureSpace).start = (GIV(pastSpace).limit));
	(GIV(futureSpace).limit = ((GIV(pastSpace).limit)) + survivorBytes);
	(GIV(eden).start = (GIV(futureSpace).limit));
	(GIV(eden).limit = GIV(newSpaceStart) + totalBytes);
	assert((((futureSpace()).limit)) <= (GIV(newSpaceStart) + totalBytes));
	assert((((((eden()).start)) % (allocationUnit())) + ((((eden()).limit)) % (allocationUnit()))) == 0);
	assert((((((pastSpace()).start)) % (allocationUnit())) + ((((pastSpace()).limit)) % (allocationUnit()))) == 0);
	assert((((((futureSpace()).start)) % (allocationUnit())) + ((((futureSpace()).limit)) % (allocationUnit()))) == 0);
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	GIV(tenuringProportion) = 0.9;
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(freeOldSpaceStart) = memEnd;
	GIV(endOfMemory) = memLimit;
	return baseOfHeap;
}


/*	Reduce the number of indexable fields in objOop, an arrayFormat or
	longFormat object, to nSlots.
	Convert the unused residual to a free chunk (if in oldSpace).
	Answer the number of bytes returned to free memory, which may be zero. */

	/* SpurMemoryManager>>#shorten:toIndexableSize: */
sqInt
shortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{
    sqInt delta;

	assert((indexableSize >= 0)
	 && (indexableSize < (lengthOf(objOop))));
	delta = doShortentoIndexableSize(objOop, indexableSize);
	assert((lengthOf(followMaybeForwarded(objOop))) == indexableSize);
	runLeakCheckerFor(GCCheckShorten);
	return delta;
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#shortPrintObjectsFrom:to: */
void
shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress)) {
		if (!(((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun()))) {
			shortPrintOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Answer if the oop should be scavenged.. The method is called
	shouldRemapOop: for compatibility with ObjectMemory. */

	/* SpurMemoryManager>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop)
{
	return ((!(oop & (tagMask()))))
	 && (shouldRemapObj(oop));
}

	/* SpurMemoryManager>>#sizeOfObjStack: */
static NoDbgRegParms sqInt
sizeOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objStackPage;
    sqInt total;

	if (objStack == GIV(nilObj)) {
		return 0;
	}
	total = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
	objStackPage = objStack;
	while (1) {
		objStackPage = longAt((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord())))));
		if (!(objStackPage != 0)) break;
		total += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
	}
	return total;
}

	/* SpurMemoryManager>>#slidingCompactionInProgress */
static int
slidingCompactionInProgress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(gcPhaseInProgress) == SlidingCompactionInProgress;
}


/*	*DO NOT CONFUSE THIS WITH numSlotsOf:.
	This is an ObjectMemory compatibility method with questionable semantics.
	Answers the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	If the receiver is a short object, return the number of shorts.
	If the receiver is a word object, return the number of words.
	If the receiver is a double word object, return the number of double
	words. Otherwise return the number of pointers. */

	/* SpurMemoryManager>>#slotSizeOf: */
sqInt
slotSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;

	if (((oop & (tagMask())) != 0)) {
		return 0;
	}
	/* begin lengthOf: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Return one of the objects in the specialObjectsArray */

	/* SpurMemoryManager>>#splObj: */
sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
}


/*	Answer the start of objOop, which is either the address of the overflow
	size word, or objOop itself, depending on the size of the object. This may
	be applied to any kind of object, normal, forwarders or free chunks. */

	/* SpurMemoryManager>>#startOfObject: */
static NoDbgRegParms usqInt
startOfObject(sqInt objOop)
{
	return ((byteAt(objOop + 7)) == (numSlotsMask())
		? objOop - BaseHeaderSize
		: objOop);
}


/*	Part of InterpreterProxy's 1.14 API */

	/* SpurMemoryManager>>#statNumGCs */
sqInt
statNumGCs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statScavenges) + GIV(statIncrGCs)) + GIV(statFullGCs);
}


/*	A renaming for the Cogit, which can't make sense of GIV(oldSpaceStart) */

	/* SpurMemoryManager>>#storeCheckBoundary */
usqInt
storeCheckBoundary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(oldSpaceStart);
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
	This primitive will store a binary image segment (in the same format as
	objects in the heap) of the
	set of objects in arrayOfObjects. All pointers from within the set to
	objects outside the set will be
	copied into the array of outPointers. In their place in the image segment
	will be an oop equal to the
	offset in the outPointer array (the first would be 8), but with the high
	bit set.
	
	Since Spur has a class table the load primitive must insert classes that
	have instances into the
	class table. This primitive marks such classes using the isRemembered bit,
	which isn't meaningful
	as a remembered bit in the segment.
	
	The primitive expects the segmentWordArray and outPointerArray to be more
	than adequately long.
	In this case it returns normally, and truncates the two arrays to exactly
	the right size.
	
	The primitive can fail for the following reasons with the specified
	failure codes:
	PrimErrGenericFailure:		the segmentWordArray is too small for the version
	stamp PrimErrWritePastObject:		the segmentWordArray is too small to
	contain the reachable objects
	PrimErrBadIndex:				the outPointerArray is too small
	PrimErrNoMemory:			there is insufficient free space to store the array
	answered by objectsReachableFromRoots:,
	or the savedFirstFields and savedOutHashes arrays.
	PrimErrNeedCompaction:		a GC is needed to make room for the array answered
	by objectsReachableFromRoots:
	PrimErrLimitExceeded:		there is no room in the hash field to store out
	pointer indices or class references,
	or the outPointerArray is larger than the max value of the hash field.
	PrimErrNoModification:		the segmentWordArrayArg or outPointerArrayArg are
	immutable PrimErrObjectIsPinned:		the segmentWordArrayArg or
	outPointerArrayArg are pinned */

	/* SpurMemoryManager>>#storeImageSegmentInto:outPointers:roots: */
static NoDbgRegParms sqInt
storeImageSegmentIntooutPointersroots(sqInt segmentWordArrayArg, sqInt outPointerArrayArg, sqInt arrayOfRootsArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfObjects;
    sqInt arrayOfRoots;
    sqInt delta;
    sqInt delta1;
    usqInt endSeg;
    sqInt fillValue;
    sqInt hash;
    sqInt here;
    sqInt hereLimiT;
    sqInt i;
    sqInt iLimiT;
    sqInt indexableSize;
    sqInt nClasses;
    usqInt newSegAddrOrError;
    sqInt numClassesInSegment;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt numSlots5;
    sqInt numSlots6;
    sqInt objOop;
    sqInt objOop1;
    sqInt outIndex;
    sqInt outPointerArray;
    usqInt p;
    usqInt p1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt savedFirstFields;
    sqInt savedOutHashes;
    usqInt segAddr;
    sqInt segmentWordArray;
    usqInt segStart;
    sqInt tempObjOop;
    sqInt there;

	if ((
#  if IMMUTABILITY
		((((usqInt)((longAt(segmentWordArrayArg)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		)
	 || (
#  if IMMUTABILITY
		((((usqInt)((longAt(outPointerArrayArg)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		)) {
		return PrimErrNoModification;
	}
	if ((((((usqInt)((longAt(segmentWordArrayArg)))) >> (pinnedBitShift())) & 1) != 0)
	 || (((((usqInt)((longAt(outPointerArrayArg)))) >> (pinnedBitShift())) & 1) != 0)) {
		return PrimErrObjectIsPinned;
	}
	if (((	/* begin numSlotsOf: */
		assert((classIndexOf(outPointerArrayArg)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(outPointerArrayArg + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(outPointerArrayArg - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) > (identityHashHalfWordMask())) {
		return PrimErrLimitExceeded;
	}
	runLeakCheckerFor(GCCheckImageSegment);
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge);
	if ((!((longAt(segmentWordArrayArg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(segmentWordArrayArg));
		referent = longAt((segmentWordArrayArg + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		segmentWordArray = referent;
	}
	else {
		segmentWordArray = segmentWordArrayArg;
	}
	/* begin updatePostScavenge: */
	if ((!((longAt(outPointerArrayArg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(outPointerArrayArg));
		referent1 = longAt((outPointerArrayArg + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent1 & (tagMask()))))
		 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		outPointerArray = referent1;
	}
	else {
		outPointerArray = outPointerArrayArg;
	}
	/* begin updatePostScavenge: */
	if ((!((longAt(arrayOfRootsArg)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(arrayOfRootsArg));
		referent2 = longAt((arrayOfRootsArg + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent2 & (tagMask()))))
		 && ((!((longAt(referent2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		arrayOfRoots = referent2;
	}
	else {
		arrayOfRoots = arrayOfRootsArg;
	}
	assert(!((forwardersIn(outPointerArray))));
	assert(!((forwardersIn(arrayOfRoots))));
	arrayOfObjects = objectsReachableFromRoots(arrayOfRoots);
	if (!arrayOfObjects) {
		return PrimErrNoMemory;
	}
	if ((((arrayOfObjects) & 7) == 1)) {
		if ((GIV(totalFreeOldSpace) - 8 /* begin allocationUnit */) >= ((arrayOfObjects >> 3))) {
			return PrimErrNeedCompaction;
		}
		return PrimErrNoMemory;
	}
	assert(allObjectsUnmarked());
	assert(!((forwardersIn(arrayOfObjects))));
	/* begin moveClassesForwardsIn: */
	/* if > 0, this is the index of the first non-class past the first element. */
	nClasses = (there = 0);
	for (here = 1, hereLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(arrayOfObjects)) > (isForwardedObjectClassIndexPun())),
(((numSlots4 = byteAt(arrayOfObjects + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(arrayOfObjects - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots4))) - 1); here <= hereLimiT; here += 1) {
		objOop1 = longAt((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(here) << (shiftForWord())))));
		hash = (long32At(objOop1 + 4)) & (identityHashHalfWordMask());
		if ((hash > (lastClassIndexPun()))
		 && ((classOrNilAtIndex(hash)) == objOop1)) {
			nClasses += 1;
			if (there > 0) {
				/* if there is zero we're in a run of classes at the start so don't move */
				tempObjOop = longAt((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(there) << (shiftForWord())))));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(arrayOfObjects)));
				longAtput((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(there) << (shiftForWord())))), objOop1);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(arrayOfObjects)));
				longAtput((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(here) << (shiftForWord())))), tempObjOop);
				there += 1;
			}
		}
		else {
			if (there == 0) {
				there = here;
			}
		}
	}
	numClassesInSegment = nClasses;
	savedFirstFields = noInlineAllocateSlotsformatclassIndex(numSlotsOf(arrayOfObjects), wordIndexableFormat(), wordSizeClassIndexPun());
	savedOutHashes = noInlineAllocateSlotsformatclassIndex(numSlotsForBytes((numSlotsOf(outPointerArray)) * 4), firstLongFormat(), thirtyTwoBitLongsClassIndexPun());
	if ((!savedFirstFields)
	 || (!savedOutHashes)) {
		freeObject(arrayOfObjects);
		if ((savedFirstFields)
		 && (oopisGreaterThanOrEqualToandLessThan(savedFirstFields, GIV(oldSpaceStart), GIV(endOfMemory)))) {
			freeObject(savedFirstFields);
		}
		if ((savedOutHashes)
		 && (oopisGreaterThanOrEqualToandLessThan(savedOutHashes, GIV(oldSpaceStart), GIV(endOfMemory)))) {
			freeObject(savedOutHashes);
		}
		return PrimErrNoMemory;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(savedFirstFields)) > (isForwardedObjectClassIndexPun()));
	if (((numSlots1 = byteAt(savedFirstFields + 7))) == (numSlotsMask())) {
		/* overflow slots; at least (2^32)-1 slots, which is plenty */
		numSlots5 = ((((usqInt)(((sqInt)((usqInt)((longAt(savedFirstFields - BaseHeaderSize))) << 8)))))) >> 8;
	}
	else {
		numSlots5 = numSlots1;
	}
	/* begin fillObj:numSlots:with: */
	assert(oopisLessThan(((savedFirstFields + BaseHeaderSize) + (numSlots5 * BytesPerOop)) - 1, addressAfter(savedFirstFields)));
	for (p = (((usqInt)(savedFirstFields + BaseHeaderSize))); p <= (((usqInt)(((savedFirstFields + BaseHeaderSize) + (numSlots5 * BytesPerOop)) - 1))); p += 8 /* begin allocationUnit */) {
		longAtput(p, 0);
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(savedOutHashes)) > (isForwardedObjectClassIndexPun()));
	if (((numSlots2 = byteAt(savedOutHashes + 7))) == (numSlotsMask())) {
		/* overflow slots; at least (2^32)-1 slots, which is plenty */
		numSlots6 = ((((usqInt)(((sqInt)((usqInt)((longAt(savedOutHashes - BaseHeaderSize))) << 8)))))) >> 8;
	}
	else {
		numSlots6 = numSlots2;
	}
	fillValue = (((sqInt)((usqInt)(((identityHashHalfWordMask()) + 1)) << 32))) + ((identityHashHalfWordMask()) + 1);
	/* begin fillObj:numSlots:with: */
	assert(oopisLessThan(((savedOutHashes + BaseHeaderSize) + (numSlots6 * BytesPerOop)) - 1, addressAfter(savedOutHashes)));
	for (p1 = (((usqInt)(savedOutHashes + BaseHeaderSize))); p1 <= (((usqInt)(((savedOutHashes + BaseHeaderSize) + (numSlots6 * BytesPerOop)) - 1))); p1 += 8 /* begin allocationUnit */) {
		longAtput(p1, fillValue);
	}
	segAddr = segmentWordArray + BaseHeaderSize;
	/* Write a version number for byte order and version check. */
	endSeg = addressAfter(segmentWordArray);
	if (segAddr >= endSeg) {
		return PrimErrGenericFailure;
	}
	long32Atput(segAddr, imageSegmentVersion());
	long32Atput(segAddr + 4, imageSegmentVersion());
	segStart = (segAddr += 8 /* begin allocationUnit */);
	assert(arrayOfRoots == (fetchPointerofObject(0, arrayOfObjects)));
	for (i = 0, iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(arrayOfObjects)) > (isForwardedObjectClassIndexPun())),
(((numSlots3 = byteAt(arrayOfObjects + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(arrayOfObjects - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3))) - 1); i <= iLimiT; i += 1) {
		/* Check that classes in the segment are addressable.  Since the top bit of the hash field is used to tag
		   classes external to the segment, the segment offset must not inadvertently set this bit.  This limit still
		   allows for a million or more classes. */
		if ((i == numClassesInSegment)
		 && ((((segAddr - segStart) / 8 /* begin allocationUnit */) + (lastClassIndexPun())) >= TopHashBit)) {
			return returnrestoringObjectsInupTosavedFirstFields(PrimErrLimitExceeded, arrayOfObjects, i, savedFirstFields);
		}
		objOop = longAt((arrayOfObjects + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		assert(!(((isImmediate(objOop))
 || (isForwarded(objOop)))));
		newSegAddrOrError = copyObjtoAddrstopAtsavedFirstFieldsindex(objOop, segAddr, endSeg, savedFirstFields, i);
		if (oopisLessThan(newSegAddrOrError, segStart)) {
			return returnrestoringObjectsInupTosavedFirstFields(newSegAddrOrError, arrayOfObjects, i, savedFirstFields);
		}
		segAddr = newSegAddrOrError;
	}
	if ((endSeg != segAddr)
	 && ((endSeg - segAddr) < (BaseHeaderSize + BytesPerOop))) {
		return returnrestoringObjectsInupTosavedFirstFields(PrimErrWritePastObject, arrayOfObjects, -1, savedFirstFields);
	}
	if (((outIndex = mapOopsFromtooutPointersoutHashes(segStart, segAddr, outPointerArray, savedOutHashes))) < 0) {
		/* no room in outPointers; fail */
		return returnrestoringObjectsInsavedFirstFieldsandsavedHashes(PrimErrBadIndex, arrayOfObjects, savedFirstFields, outPointerArray, savedOutHashes);
	}
	indexableSize = (segAddr - (segmentWordArray + BaseHeaderSize)) / 4;
	/* begin shorten:toIndexableSize: */
	assert((indexableSize >= 0)
	 && (indexableSize < (lengthOf(segmentWordArray))));
	delta = doShortentoIndexableSize(segmentWordArray, indexableSize);
	assert((lengthOf(followMaybeForwarded(segmentWordArray))) == indexableSize);
	runLeakCheckerFor(GCCheckShorten);
	/* begin shorten:toIndexableSize: */
	assert((outIndex >= 0)
	 && (outIndex < (lengthOf(outPointerArray))));
	delta1 = doShortentoIndexableSize(outPointerArray, outIndex);
	assert((lengthOf(followMaybeForwarded(outPointerArray))) == outIndex);
	runLeakCheckerFor(GCCheckShorten);
	return returnrestoringObjectsInsavedFirstFieldsandsavedHashes(PrimNoErr, arrayOfObjects, savedFirstFields, outPointerArray, savedOutHashes);
}

	/* SpurMemoryManager>>#storeLong32:ofObject:withValue: */
int
storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt obj, sqInt valueWord)
{
	return long32Atput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))), valueWord);
}

	/* SpurMemoryManager>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isOopForwarded(objOop)));
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */
/*	See SistaCogit */

	/* SpurMemoryManager>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isForwarded(objOop)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(objOop)),
	oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer & (tagMask()))))
		 && (oopisLessThan(valuePointer, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory. */

	/* SpurMemoryManager>>#stringForCString: */
sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt len;
    usqInt newObj;
    sqInt newString;
    usqInt numBytes;
    sqInt numSlots;

	len = strlen(aCString);
	numSlots = (len + (BytesPerWord - 1)) / BytesPerWord;
	formatField = (firstByteFormat()) + ((8 - len) & (BytesPerWord - 1));
	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		if ((((usqInt)(numSlots)) >> 56) > 0) {
			newString = null;
			goto l1;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		newString = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {
		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(newObj, (((((usqLong) (numSlotsMask()))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + ClassByteStringCompactIndex);
	}
	else {
		longAtput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + ClassByteStringCompactIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newString = newObj;
	l1:	/* end allocateSlots:format:classIndex: */;
	if (!(newString == null)) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	This is ObjectMemory's funky entry-point into its incremental GC,
	which is a stop-the-world a young generation reclaimer. In Spur
	we run the scavenger. Answer if space is not low. */

	/* SpurMemoryManager>>#sufficientSpaceAfterGC: */
static NoDbgRegParms sqInt
sufficientSpaceAfterGC(sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt heapSizePostGC;

	assert(numBytes == 0);
	scavengingGCTenuringIf(TenureByAge);
	heapSizePostGC = ((/* begin totalOldSpaceCapacity */
	assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (2 * BaseHeaderSize)))) - GIV(totalFreeOldSpace);
	if (((((double) (heapSizePostGC - GIV(heapSizeAtPreviousGC)) )) / GIV(heapSizeAtPreviousGC)) >= GIV(heapGrowthToSizeGCRatio)) {
		fullGC();
	}
	else {
		/* Also attempt to shrink if there is plenty of free space and no need to GC */
		if (GIV(totalFreeOldSpace) > (GIV(shrinkThreshold) * 2)) {
			/* begin attemptToShrink */
			if ((GIV(totalFreeOldSpace) > GIV(shrinkThreshold))
			 && ((GIV(totalFreeOldSpace) > GIV(growHeadroom))
			 && (shrinkObjectMemory((((GIV(totalFreeOldSpace) - GIV(growHeadroom)) < GIV(growHeadroom)) ? GIV(growHeadroom) : (GIV(totalFreeOldSpace) - GIV(growHeadroom))))))) {
				GIV(statShrinkMemory) += 1;
			}
			return 1;
		}
	}
	while ((GIV(totalFreeOldSpace) < GIV(growHeadroom))
	 && ((growOldSpaceByAtLeast(0)))) {
		if (GIV(totalFreeOldSpace) >= GIV(growHeadroom)) {
			return 1;
		}
	}
	return GIV(lowSpaceThreshold) <= GIV(totalFreeOldSpace);
}


/*	On load, swizzle the pointers in an obj stack. Answer the obj stack's oop. */

	/* SpurMemoryManager>>#swizzleObjStackAt: */
static NoDbgRegParms sqInt
swizzleObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt page;
    sqInt stackOrNil;

	firstPage = (stackOrNil = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord()))))));
	if (stackOrNil == GIV(nilObj)) {
		return stackOrNil;
	}
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);
		/* swizzle fields including ObjStackNextx, excluding ObjStackFreex and leave field containing the next link. */
		index = (longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))))) + ObjStackNextx;
		do {
			field = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (!((field == 0)
				 || (((field & (tagMask())) != 0)))) {
				field = swizzleObj(field);
				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
				longAtput((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), field);
			}
		} while(((index -= 1)) >= ObjStackNextx);
	} while(((stackOrNil = field)) != 0);
	if (((stackOrNil = longAt((firstPage + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord()))))))) != 0) {
		page = firstPage;
		do {
			stackOrNil = swizzleObj(stackOrNil);
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(page)) == (wordIndexableFormat()));
			longAtput((page + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord())))), stackOrNil);
			page = stackOrNil;
		} while(((stackOrNil = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackFreex) << (shiftForWord()))))))) != 0);
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(objStackRootIndex) << (shiftForWord())))));
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. The selector tenuringIncrementalGC refers to the V3 incremental
	collector, which is the collector for young objects, equivalent in
	function to the scavenger.
	The Spur incremental collector is called the global incremental garbage
	collector or globalIGC for short.
 */

	/* SpurMemoryManager>>#tenuringIncrementalGC */
void
tenuringIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;


	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	GIV(tenureThreshold) = GIV(oldSpaceStart);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
}


/*	This assert is tricky. push:onObjStack: may call topOfObjStack: just after
	pushing an
	empty page on the stack, and will ask if the second page is valid. */

	/* SpurMemoryManager>>#topOfObjStack: */
static NoDbgRegParms sqInt
topOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt topx;

	eassert(isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), objStack == (fetchPointerofObject(fetchPointerofObject(ObjStackMyx, objStack), GIV(hiddenRootsObj)))));
	topx = longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	return longAt((objStack + BaseHeaderSize) + (((sqInt)((usqInt)(((topx + ObjStackFixedSlots) - 1)) << (shiftForWord())))));
}


/*	Answers the top of the remappable oop stack. Useful when writing loops.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#topRemappableOop */
sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}


/*	This method both computes the actual number of free bytes by traversing
	all free objects
	on the free lists/tree, and checks that the tree is valid. It is used
	mainly by checkFreeSpace. */

	/* SpurMemoryManager>>#totalFreeListBytes */
static sqInt
totalFreeListBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesInChunk;
    sqInt cameFrom;
    sqInt i;
    sqInt iLimiT;
    sqInt largeChild;
    sqInt listNode;
    sqInt nextNode;
    sqInt smallChild;
    sqInt totalFreeBytes;
    sqInt treeNode;
    sqInt treeNode1;

	treeNode = 0;
	totalFreeBytes = 0;
	for (i = 1, iLimiT = (0x3F); i <= iLimiT; i += 1) {
		bytesInChunk = i * 8 /* begin allocationUnit */;
		listNode = GIV(freeLists)[i];
		while (listNode != 0) {
			totalFreeBytes += bytesInChunk;
			/* begin assertValidFreeObject: */
			assert(assertInnerValidFreeObject(listNode));
			assert(bytesInChunk == (bytesInBody(listNode)));
			nextNode = longAt((listNode + BaseHeaderSize) + (0U << (shiftForWord())));
			assert(nextNode != listNode);
			listNode = nextNode;
		}
	}
	/* begin freeTreeNodesDo: */
	treeNode1 = GIV(freeLists)[0];
	if (treeNode1 == 0) {
		goto l1;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNode1)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = longAt((treeNode1 + BaseHeaderSize) + (3U << (shiftForWord())));
		largeChild = longAt((treeNode1 + BaseHeaderSize) + (4U << (shiftForWord())));
		assert((smallChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {
			bytesInChunk = bytesInBody(treeNode1);
			assert((bytesInChunk / (allocationUnit())) >= (numFreeLists()));
			listNode = treeNode1;
			while (listNode != 0) {
				/* self printFreeChunk: listNode */
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(listNode));
				assert((listNode == treeNode1)
				 || ((fetchPointerofFreeChunk(freeChunkParentIndex(), listNode)) == 0));
				totalFreeBytes += bytesInChunk;
				assert(bytesInChunk == (bytesInBody(listNode)));
				nextNode = longAt((listNode + BaseHeaderSize) + (0U << (shiftForWord())));
				assert(nextNode != listNode);
				listNode = nextNode;
			}
			cameFrom = treeNode1;
			treeNode1 = longAt((treeNode1 + BaseHeaderSize) + (2U << (shiftForWord())));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode1 = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode1 = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode1 != 0);
	l1:	/* end freeTreeNodesDo: */;
	return totalFreeBytes;
}

	/* SpurMemoryManager>>#trueObject */
sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}


/*	Unlink a free object from the free lists. Do not alter totalFreeOldSpace.
	Used for coalescing.
 */

	/* SpurMemoryManager>>#unlinkFreeChunk:chunkBytes: */
static NoDbgRegParms sqInt
unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt lilliputian;
    sqInt next;
    sqInt next1;
    sqInt nextFreeChunk;
    sqInt prev;


	/* Pathological 64 bits case - size 1 - single linked list */
	index = chunkBytes / 8 /* begin allocationUnit */;
	if ((	/* begin isLilliputianSize: */
		assert(chunkBytes >= (BaseHeaderSize + (allocationUnit()))),
	chunkBytes == (BaseHeaderSize + 8 /* begin allocationUnit */))) {
		return unlinkLilliputianChunkindex(freeChunk, index);
	}
	/* Has prev element: update double linked list */
	prev = longAt((freeChunk + BaseHeaderSize) + (1U << (shiftForWord())));
	if (prev != 0) {
		/* begin setNextFreeChunkOf:withValue:chunkBytes: */
		nextFreeChunk = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		/* begin isLilliputianSize: */
		assert(chunkBytes >= (BaseHeaderSize + (allocationUnit())));
		lilliputian = chunkBytes == (BaseHeaderSize + 8 /* begin allocationUnit */);
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(prev));
		assert((nextFreeChunk == 0)
		 || (isFreeObject(nextFreeChunk)));
		longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord())), nextFreeChunk);
		if ((nextFreeChunk != 0)
		 && (!lilliputian)) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(nextFreeChunk));
			assert((prev == 0)
			 || (isFreeObject(prev)));
			longAtput((nextFreeChunk + BaseHeaderSize) + (1U << (shiftForWord())), prev);
		}
		return freeChunk;
	}
	if ((index < 64 /* begin numFreeLists */)
	 && ((1ULL << index) <= GIV(freeListsMask))) {
		/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
		assert(((bytesInBody(freeChunk)) == (index * (allocationUnit())))
		 && ((index > 1)
		 && ((startOfObject(freeChunk)) == freeChunk)));
		GIV(freeLists)[index] = ((next1 = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())))));
		if (next1 != 0) {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(next1));
			assert(1);
			longAtput((next1 + BaseHeaderSize) + (1U << (shiftForWord())), 0);
		}
		return freeChunk;
	}
	next = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())));
	if (next == 0) {
		/* no list; remove the interior node */
		unlinkSolitaryFreeTreeNode(freeChunk);
	}
	else {
		/* list; replace node with it */
		inFreeTreeReplacewith(freeChunk, next);
	}
	return freeChunk;
}

	/* SpurMemoryManager>>#unlinkLilliputianChunk:index: */
static NoDbgRegParms NeverInline sqInt
unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt next;
    sqInt next1;
    sqInt node;
    sqInt prev;


	/* for profiling */
	node = GIV(freeLists)[index];
	prev = 0;
	while (node != 0) {
		assert(node == (startOfObject(node)));
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(node));
		next = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
		if (node == freeChunk) {
			if (prev == 0) {
				/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
				assert(((bytesInBody(freeChunk)) == (index * (allocationUnit())))
				 && ((index > 1)
				 && ((startOfObject(freeChunk)) == freeChunk)));
				GIV(freeLists)[index] = ((next1 = longAt((freeChunk + BaseHeaderSize) + (0U << (shiftForWord())))));
			}
			else {
				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				assert(isFreeObject(prev));
				assert((next == 0)
				 || (isFreeObject(next)));
				longAtput((prev + BaseHeaderSize) + (0U << (shiftForWord())), next);
			}
			return freeChunk;
		}
		prev = node;
		node = next;
	}
	error("freeChunk not found in lilliputian chunk free list");
	return 0;
}


/*	Unlink a freeTreeNode. Assumes the node has no list (null next link). */

	/* SpurMemoryManager>>#unlinkSolitaryFreeTreeNode: */
static NoDbgRegParms void
unlinkSolitaryFreeTreeNode(sqInt freeTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt larger;
    sqInt parent;
    sqInt smaller;

	assert((fetchPointerofFreeChunk(freeChunkNextIndex(), freeTreeNode)) == 0);
	smaller = longAt((freeTreeNode + BaseHeaderSize) + (3U << (shiftForWord())));
	larger = longAt((freeTreeNode + BaseHeaderSize) + (4U << (shiftForWord())));
	parent = longAt((freeTreeNode + BaseHeaderSize) + (2U << (shiftForWord())));
	if (parent == 0) {
		/* no parent; stitch the subnodes back into the root */
		if (smaller == 0) {
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(larger));
				assert(1);
				longAtput((larger + BaseHeaderSize) + (2U << (shiftForWord())), 0);
			}
			GIV(freeLists)[0] = larger;
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(smaller));
			assert(1);
			longAtput((smaller + BaseHeaderSize) + (2U << (shiftForWord())), 0);
			GIV(freeLists)[0] = smaller;
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
	else {
		/* parent; stitch back into appropriate side of parent. */
		if (smaller == 0) {
			fieldIndex = (freeTreeNode == (longAt((parent + BaseHeaderSize) + (3U << (shiftForWord()))))
				? 3 /* begin freeChunkSmallerIndex */
				: 4 /* begin freeChunkLargerIndex */);
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(parent));
			assert((larger == 0)
			 || (isFreeObject(larger)));
			longAtput((parent + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), larger);
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(larger));
				assert((parent == 0)
				 || (isFreeObject(parent)));
				longAtput((larger + BaseHeaderSize) + (2U << (shiftForWord())), parent);
			}
		}
		else {
			fieldIndex1 = (freeTreeNode == (longAt((parent + BaseHeaderSize) + (3U << (shiftForWord()))))
				? 3 /* begin freeChunkSmallerIndex */
				: 4 /* begin freeChunkLargerIndex */);
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(parent));
			assert((smaller == 0)
			 || (isFreeObject(smaller)));
			longAtput((parent + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex1) << (shiftForWord())))), smaller);
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(smaller));
			assert((parent == 0)
			 || (isFreeObject(parent)));
			longAtput((smaller + BaseHeaderSize) + (2U << (shiftForWord())), parent);
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
}

	/* SpurMemoryManager>>#unpinObject: */
sqInt
unpinObject(sqInt objOop)
{
	assert(isNonImmediate(objOop));
	/* begin setIsPinnedOf:to: */
	longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (pinnedBitShift()))));
	return 0;
}

	/* SpurMemoryManager>>#updateListStartingAt: */
static NoDbgRegParms void
updateListStartingAt(sqInt freeNode)
{
    sqInt obj;
    sqInt prev;

	if (freeNode == 0) {
		return;
	}
	assert(!((isLilliputianSize(bytesInBody(freeNode)))));
	prev = freeNode;
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(prev));
	assert(1);
	longAtput((prev + BaseHeaderSize) + (1U << (shiftForWord())), 0);
	while (1) {
		obj = longAt((prev + BaseHeaderSize) + (0U << (shiftForWord())));
		if (!(obj != 0)) break;
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(obj));
		assert((prev == 0)
		 || (isFreeObject(prev)));
		longAtput((obj + BaseHeaderSize) + (1U << (shiftForWord())), prev);
		prev = obj;
	}
}


/*	Check the hashes of classes in the table. The tricky thing here is that
	classes may be duplicated
	in the table. So each entry must be in the table at its hash, even if it
	is elsewhere in the table. */

	/* SpurMemoryManager>>#validClassTableHashes */
static sqInt
validClassTableHashes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt ignored1;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	classOrNil = 0;
	if (!(validClassTableRootPages())) {
		return 0;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		for (j = 0, jLimiT = ((1U << (classTableMajorIndexShift())) - 1); j <= jLimiT; j += 1) {
			classOrNil1 = longAt((page + BaseHeaderSize) + (((sqInt)((usqInt)(j) << (shiftForWord())))));
			if (classOrNil1 != GIV(nilObj)) {
				ignored1 = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
				if ((!((longAt(classOrNil1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					return 0;
				}
				hash = (long32At(classOrNil1 + 4)) & (identityHashHalfWordMask());
				if (hash == 0) {
					return 0;
				}
				if ((noCheckClassAtIndex(hash)) != classOrNil1) {
					return 0;
				}
			}
		}
	}
	return 1;
}


/*	Answer if hiddenRootsObj is of the right size with the
	expected contents, and if numClassTablePages is correct. */

	/* SpurMemoryManager>>#validClassTableRootPages */
static sqInt
validClassTableRootPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;

	if (!(((		/* begin numSlotsOf: */
			assert((classIndexOf(GIV(hiddenRootsObj))) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(GIV(hiddenRootsObj) + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(GIV(hiddenRootsObj) - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) == ((1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift()))) + 8 /* begin hiddenRootSlots */))) {
		return 0;
	}
	if (!((GIV(numClassTablePages) > 1)
		 && (GIV(numClassTablePages) <= (1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift())))))) {
		return 0;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		obj = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (!((addressCouldBeObj(obj))
			 && (((			/* begin numSlotsOf: */
				assert((classIndexOf(obj)) > (isForwardedObjectClassIndexPun())),
			(((numSlots1 = byteAt(obj + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1))) == (1U << (classTableMajorIndexShift()))))) {
			return 0;
		}
	}
	for (i = GIV(numClassTablePages), iLimiT = ((1U << (22 /* begin classIndexFieldWidth */ - (classTableMajorIndexShift()))) - 1); i <= iLimiT; i += 1) {
		if ((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))))) != GIV(nilObj)) {
			return 0;
		}
	}
	return 1;
}


/*	useful for debugging */

	/* SpurMemoryManager>>#validFreeTree */
int
validFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return !(validFreeTreeChunkparent(GIV(freeLists)[0], 0));
}

	/* SpurMemoryManager>>#validFreeTreeChunk: */
static NoDbgRegParms sqInt
validFreeTreeChunk(sqInt chunk)
{
	if (!(segmentContainingObj(chunk))) {
		return 0;
	}
	return !(validFreeTreeChunkparent(chunk, longAt((chunk + BaseHeaderSize) + (2U << (shiftForWord())))));
}

	/* SpurMemoryManager>>#validFreeTreeChunk:parent: */
static NoDbgRegParms const char *
validFreeTreeChunkparent(sqInt chunk, sqInt parent)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    const char *reason;

	if (chunk == 0) {
		return null;
	}
	if (!(		/* begin addressCouldBeOldObj: */
			((chunk & (BaseHeaderSize - 1)) == 0)
		 && (oopisGreaterThanOrEqualToandLessThan(chunk, GIV(oldSpaceStart), GIV(endOfMemory))))) {
		return "not in old space";
	}
	if (((bytesInBody(chunk)) / 8 /* begin allocationUnit */) < 64 /* begin numFreeLists */) {
		return "too small";
	}
	if (parent != (longAt((chunk + BaseHeaderSize) + (2U << (shiftForWord()))))) {
		return "bad parent";
	}
	if ((segmentContainingObj(chunk)) != (segmentContainingObj(addressAfter(chunk)))) {
		return "not in one segment";
	}
	reason = validFreeTreeChunkparent(longAt((chunk + BaseHeaderSize) + (3U << (shiftForWord()))), chunk);
	if (!(reason == null)) {
		return reason;
	}
	reason = validFreeTreeChunkparent(longAt((chunk + BaseHeaderSize) + (4U << (shiftForWord()))), chunk);
	if (!(reason == null)) {
		return reason;
	}
	return null;
}

	/* SpurMemoryManager>>#validObjStacks */
static sqInt
validObjStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(markStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(markStack))))
	 && (((GIV(weaklingStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(weaklingStack))))
	 && ((GIV(mournQueue) == GIV(nilObj))
	 || (isValidObjStack(GIV(mournQueue)))));
}


/*	This is a hook for the CoMemoryManagers to check for valid compiled code.
	It is a noop here. */

	/* SpurMemoryManager>>#validPostBecomeArrayContents: */
static NoDbgRegParms sqInt
validPostBecomeArrayContents(sqInt anArray)
{
	return 1;
}


/*	1 = big, 0 = little */

	/* SpurMemoryManager>>#vmEndianness */
sqInt
vmEndianness(void)
{
	return VMBIGENDIAN;
}


/*	Sweep all of old space, sliding unpinned marked objects down over free and
	unmarked objects.
	Let the segmentManager mark which segments contain pinned objects via
	notePinned:. 
 */

	/* SpurPlanningCompactor>>#compact */
static NeverInline void
compact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt finalPass;
    sqInt firstPass;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt highestSuitableFreeBlock;
    sqInt i;
    sqInt iLimiT;
    sqInt largestFreeChunk;
    sqInt largestFreeChunk1;
    sqInt largestFreeChunk2;
    usqInt numSlots;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt sizeOfEden;
    sqInt spaceEstimate;
    sqInt spaceEstimate1;
    sqInt stackOrNil;
    sqInt stackOrNil1;
    sqInt stackOrNil2;


	/* for profiling */
	if (initializeScanCheckingForFullyCompactedHeap()) {
		/* begin unmarkObjectsInFullyCompactedHeap */
		o = 0;
		objOop3 = 0;
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj1 = (prevObj1 = null);
		objOop11 = GIV(nilObj);
		while (1) {
			assert((objOop11 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
			assert((long64At(objOop11)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex = (longAt(objOop11)) & (classIndexMask())),
			assert((classIndex == (segmentBridgePun()))
				 || ((classIndex == (isForwardedObjectClassIndexPun()))
				 || (((long64At(objOop11)) != 0)
				 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex >= (isForwardedObjectClassIndexPun()))) {
				if (oopisGreaterThanOrEqualTo(objOop11, GIV(firstMobileObject))) {
					goto l10;
				}
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop11)));
				longAtput(objOop11, (longAt(objOop11)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			prevPrevObj1 = prevObj1;
			prevObj1 = objOop11;
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop11);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
				objOop11 = GIV(endOfMemory);
				goto l8;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			objOop11 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
	l8:	/* end objectAfter:limit: */;
		}
	l10:	/* end unmarkInitialImmobileObjects */;
		/* begin unmarkSurvivingObjectsForCompact */
		objOop4 = 0;
		objOop2 = 0;
		prevPrevObj = (prevObj = null);
		address = ((pastSpace()).start);
		/* begin objectStartingAt: */
		numSlots = byteAt(address + 7);
		objOop1 = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		while (oopisLessThan(objOop1, GIV(pastSpaceStart))) {
			assert(isEnumerableObjectNoAssert(objOop1));
			if (((((usqInt)((longAt(objOop1)))) >> (markedBitFullShift())) & 1) != 0) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1)));
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress = addressAfter(objOop1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
				objOop1 = GIV(pastSpaceStart);
				goto l11;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress + BaseHeaderSize)
				: followingWordAddress);
	l11:	/* end objectAfterMaybeSlimBridge:limit: */;
		}
		return;
	}
	/* begin initializeCompaction */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	/* begin selectSavedFirstFieldsSpace */
	spaceEstimate1 = ((endOfMemory()) - GIV(nilObj)) / 40;
	sizeOfEden = (((eden()).limit)) - (((eden()).start));
	if (spaceEstimate1 > sizeOfEden) {
		/* begin findHighestSuitableFreeBlock: */
		largestFreeChunk2 = findLargestFreeChunk();
		if (!(largestFreeChunk2 == null)) {
			if (((bytesInBody(largestFreeChunk2)) >= spaceEstimate1)
			 && ((((usqInt)largestFreeChunk2)) > (((usqInt)((endOfMemory()) - GIV(totalFreeOldSpace)))))) {
				highestSuitableFreeBlock = largestFreeChunk2;
				goto l2;
			}
		}
		highestSuitableFreeBlock = null;
	l2:	/* end findHighestSuitableFreeBlock: */;
		if (!(highestSuitableFreeBlock == null)) {
			if ((spaceEstimate1 > ((			/* begin sizeOfFree: */
				assert(isFreeObject(highestSuitableFreeBlock)),
			bytesInBody(highestSuitableFreeBlock))))
			 && (useSegmentForSavedFirstFieldsSpace(spaceEstimate1))) {
				goto l3;
			}
			if (((			/* begin sizeOfFree: */
				assert(isFreeObject(highestSuitableFreeBlock)),
			bytesInBody(highestSuitableFreeBlock))) > sizeOfEden) {
				/* begin useFreeChunkForSavedFirstFieldsSpace: */
				assert(validFreeTreeChunk(highestSuitableFreeBlock));
				(GIV(savedFirstFieldsSpace).start = highestSuitableFreeBlock + (4 /* begin freeChunkLargerIndex */ * BytesPerOop));
				(GIV(savedFirstFieldsSpace).limit = addressAfter(highestSuitableFreeBlock));
				GIV(savedFirstFieldsSpaceNotInOldSpace) = 0;
				assert(!((savedFirstFieldsSpaceWasAllocated())));
				goto l3;
			}
		}
		if (useSegmentForSavedFirstFieldsSpace(spaceEstimate1)) {
			goto l3;
		}
	}
	/* begin useEdenForSavedFirstFieldsSpace */
	(GIV(savedFirstFieldsSpace).start = ((eden()).start));
	(GIV(savedFirstFieldsSpace).limit = ((eden()).limit));
	GIV(savedFirstFieldsSpaceNotInOldSpace) = 1;
	assert(!((savedFirstFieldsSpaceWasAllocated())));
	l3:	/* end selectSavedFirstFieldsSpace */;
	/* begin unpinRememberedSet */
	GIV(firstFieldOfRememberedSet) = longAt(((longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))))) + BaseHeaderSize) + (0U << (shiftForWord())));
	objOop = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
	/* begin setIsPinnedOf:to: */
	longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1U << (pinnedBitShift()))));
	/* begin resetFreeListHeads */
	GIV(freeListsMask) = 0;
	for (i = 0, iLimiT = (0x3F); i <= iLimiT; i += 1) {
		GIV(freeLists)[i] = 0;
	}
	/* begin prepareObjStacksForPlanningCompactor */
	if (GIV(markStack) == GIV(nilObj)) {
		goto l5;
	}
	stackOrNil = GIV(markStack);
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		hash = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
		/* begin setHashBitsOf:to: */
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(stackOrNil + 4, ((((long32At(stackOrNil + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
	} while(((stackOrNil = longAt((stackOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord()))))))) != 0);
	l5:	/* end prepareObjStackForPlanningCompactor: */;
	/* begin prepareObjStackForPlanningCompactor: */
	if (GIV(weaklingStack) == GIV(nilObj)) {
		goto l6;
	}
	stackOrNil1 = GIV(weaklingStack);
	do {
		assert((numSlotsOfAny(stackOrNil1)) == ObjStackPageSlots);
		hash1 = longAt((stackOrNil1 + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
		/* begin setHashBitsOf:to: */
		assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
		long32Atput(stackOrNil1 + 4, ((((long32At(stackOrNil1 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
	} while(((stackOrNil1 = longAt((stackOrNil1 + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord()))))))) != 0);
	l6:	/* end prepareObjStackForPlanningCompactor: */;
	/* begin prepareObjStackForPlanningCompactor: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l4;
	}
	stackOrNil2 = GIV(mournQueue);
	do {
		assert((numSlotsOfAny(stackOrNil2)) == ObjStackPageSlots);
		hash2 = longAt((stackOrNil2 + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackTopx) << (shiftForWord())))));
		/* begin setHashBitsOf:to: */
		assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask()))));
		long32Atput(stackOrNil2 + 4, ((((long32At(stackOrNil2 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash2);
	} while(((stackOrNil2 = longAt((stackOrNil2 + BaseHeaderSize) + (((sqInt)((usqInt)(ObjStackNextx) << (shiftForWord()))))))) != 0);
	l4:	/* end prepareObjStackForPlanningCompactor: */;
	/* begin totalFreeOldSpace: */
	GIV(totalFreeOldSpace) = 0;
	GIV(gcPhaseInProgress) = SlidingCompactionInProgress;
	(GIV(savedFirstFieldsSpace).top = ((GIV(savedFirstFieldsSpace).start)) - BytesPerOop);
	firstPass = 1;
	while (1) {
		finalPass = planCompactSavingForwarders();
		assert((validRelocationPlanInPass(finalPass)) == 0);
		updatePointers();
		copyAndUnmark(firstPass);
		if (finalPass
		 || (GIV(biasForGC))) break;
		firstPass = 0;
		reinitializeScanFrom(GIV(firstFreeObject));
		if (!(GIV(firstMobileObject) > GIV(firstFreeObject))) {
			/* We get here when firstFreeObject is the last object in memory.
			   firstMobileObject may be random value from previous compaction
			   in this case, and heap is fully compacted. Abort compaction. */
			/* We set firstFreeObject to firstMobileObject for unmarking. */
			GIV(firstFreeObject) = GIV(firstMobileObject);
			unmarkObjectsFromFirstFreeObject();
			/* begin checkFreeSpace: */
			assert(bitsSetInFreeSpaceMaskForAllFreeLists());
			assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
			if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
				runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
			}
			endCompaction();
			return;
		}
		/* begin updateSavedFirstFieldsSpaceIfNecessary */
		if ((		/* begin savedFirstFieldsSpaceInFreeChunk */
			(!GIV(savedFirstFieldsSpaceNotInOldSpace))
		 && (oopisGreaterThan((GIV(savedFirstFieldsSpace).start), GIV(nilObj))))
		 && (((GIV(savedFirstFieldsSpace).start)) < GIV(lastMobileObject))) {
			spaceEstimate = ((GIV(savedFirstFieldsSpace).limit)) - ((GIV(savedFirstFieldsSpace).start));
			/* begin findHighestSuitableFreeBlock: */
			largestFreeChunk1 = findLargestFreeChunk();
			if (!(largestFreeChunk1 == null)) {
				if (((bytesInBody(largestFreeChunk1)) >= spaceEstimate)
				 && ((((usqInt)largestFreeChunk1)) > (((usqInt)((endOfMemory()) - GIV(totalFreeOldSpace)))))) {
					largestFreeChunk = largestFreeChunk1;
					goto l1;
				}
			}
			largestFreeChunk = null;
	l1:	/* end findHighestSuitableFreeBlock: */;
			if (largestFreeChunk == null) {
				/* begin useEdenForSavedFirstFieldsSpace */
				(GIV(savedFirstFieldsSpace).start = ((eden()).start));
				(GIV(savedFirstFieldsSpace).limit = ((eden()).limit));
				GIV(savedFirstFieldsSpaceNotInOldSpace) = 1;
				assert(!((savedFirstFieldsSpaceWasAllocated())));
			}
			else {
				/* begin useFreeChunkForSavedFirstFieldsSpace: */
				assert(validFreeTreeChunk(largestFreeChunk));
				(GIV(savedFirstFieldsSpace).start = largestFreeChunk + (4 /* begin freeChunkLargerIndex */ * BytesPerOop));
				(GIV(savedFirstFieldsSpace).limit = addressAfter(largestFreeChunk));
				GIV(savedFirstFieldsSpaceNotInOldSpace) = 0;
				assert(!((savedFirstFieldsSpaceWasAllocated())));
			}
		}
		(GIV(savedFirstFieldsSpace).top = ((GIV(savedFirstFieldsSpace).start)) - BytesPerOop);
	}
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	endCompaction();
}


/*	Sweep the mobile portion of the heap, moving objects to their eventual
	locations, and clearing their marked bits.
	Remember to update the savedFirstFields of pointer objects, as these have
	been forwarded.
	Answer if the end of the heap was reached (savedFirstFieldsSpace has not
	overflowed). 
	The enumerations in planCompactSavingForwarders,
	updatePointersInMobileObjects and copyAndUnmarkMobileObjects
	match. We could implement them as a single enumeration method taking
	several block arguments, but arguably that
	would make understanding an already tricky algorithm more difficult.
	Instead we tolerate the duplication and encourage
	the reader to diff the three methods to see where they diverge (e.g. via
	Cmd-shift-C).  */

	/* SpurPlanningCompactor>>#copyAndUnmarkMobileObjects */
static NeverInline sqInt
copyAndUnmarkMobileObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt availableSpace;
    usqInt bytes;
    sqInt destObj;
    sqInt finalObject;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt limit;
    sqInt n;
    usqInt next;
    usqInt nextBytes;
    sqInt nextObj;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt o;
    usqInt obj;
    usqInt objBytes;
    sqInt objOop;
    usqInt previousPin;
    sqInt prevObj;
    sqInt prevPrevObj;
    SpurSegmentInfo *seg;
    usqInt start;
    usqInt startOfPreviousPin;
    usqInt toFinger;
    usqInt top;

	n = 0;
	o = 0;
	previousPin = 0;
	assert(!((isMarked(GIV(firstFreeObject)))));
	toFinger = 
	/* begin startOfObject: */
((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask())
		? GIV(firstFreeObject) - BaseHeaderSize
		: GIV(firstFreeObject));
	top = (GIV(savedFirstFieldsSpace).start);
	startOfPreviousPin = 0;
	finalObject = (!(GIV(lastMobileObject))
		? GIV(nilObj)
		: GIV(lastMobileObject));
	/* begin allOldSpaceEntitiesForCompactingFrom:to:do: */
	assert(isOldObject(GIV(firstFreeObject)));
	assert(oopisLessThanOrEqualTo(finalObject, GIV(endOfMemory)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstFreeObject);
	if (oopisLessThan(finalObject, GIV(endOfMemory))) {
		limit = addressAfter(finalObject);
	}
	else {
		limit = GIV(endOfMemory);
	}
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, limit))) break;
		assert((long64At(objOop)) != 0);
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			nextObj = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		nextObj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l3:	/* end objectAfter:limit: */;
		assert((previousPin == null
			? toFinger <= (startOfObject(objOop))
			: (isMarked(previousPin))
				 && (toFinger <= startOfPreviousPin)));
		assert(GIV(savedFirstFieldsSpaceNotInOldSpace)
		 || (toFinger < top));
		if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0) {
				if (!previousPin) {
					previousPin = objOop;
					startOfPreviousPin = 
					/* begin startOfObject: */
((byteAt(objOop + 7)) == (numSlotsMask())
						? objOop - BaseHeaderSize
						: objOop);
				}
			}
			else {
				bytes = bytesInBody(objOop);
				while ((toFinger <= startOfPreviousPin)
				 && ((bytes != ((availableSpace = startOfPreviousPin - toFinger)))
				 && ((bytes + (16)) > availableSpace))) {
					/* The object does not fit in the space between toFinger and previousPin.
					   Move toFinger up to point at the first unmarked or mobile object after
					   previousPin, or, if previousPin is contiguous with o, to the start of this
					   object.  Update previousPin to be the next pinned object above toFInger
					   and below this object, or nil if no such pinned object exists.
					   Any unfillable gaps between adjacent pinned objects will be freed. */
					if (availableSpace > 0) {
						/* begin addFreeChunkWithBytes:at: */
						GIV(totalFreeOldSpace) += availableSpace;
						freeChunkWithBytesat(availableSpace, toFinger);
					}
					do {
						assert((isMarked(previousPin))
						 && (isPinned(previousPin)));
						/* begin unmarkPinned: */
						if (((longAt(previousPin)) & (classIndexMask())) == (segmentBridgePun())) {
							assert(isMarked(previousPin));
						}
						else {
							/* begin setIsMarkedOf:to: */
							assert(!(isFreeObject(previousPin)));
							longAtput(previousPin, (longAt(previousPin)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
							/* begin notePinned: */
							assert(isPinned(previousPin));
							assert(!((isSegmentBridge(previousPin))));
							seg = segmentContainingObj(previousPin);
							(seg->containsPinned = 1);
						}
						toFinger = addressAfter(previousPin);
						/* begin objectStartingAt: */
						numSlots = byteAt(toFinger + 7);
						previousPin = (numSlots == (numSlotsMask())
							? toFinger + BaseHeaderSize
							: toFinger);
					} while((((((usqInt)((longAt(previousPin)))) >> (markedBitFullShift())) & 1) != 0)
						 && ((((((usqInt)((longAt(previousPin)))) >> (pinnedBitShift())) & 1) != 0)
						 && (previousPin < objOop)));
					while (!((previousPin >= objOop)
					 || ((((((usqInt)((longAt(previousPin)))) >> (markedBitFullShift())) & 1) != 0)
					 && (((((usqInt)((longAt(previousPin)))) >> (pinnedBitShift())) & 1) != 0)))) {
						previousPin = oldSpaceObjectAfter(previousPin);
					}
					if (previousPin >= objOop) {
						previousPin = null;
						startOfPreviousPin = 0;
					}
					else {
						startOfPreviousPin = 
						/* begin startOfObject: */
((byteAt(previousPin + 7)) == (numSlotsMask())
							? previousPin - BaseHeaderSize
							: previousPin);
					}
				}
				assert(!(isFreeObject(objOop)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
				numSlots1 = byteAt(objOop + 7);
				destObj = (numSlots1 == (numSlotsMask())
					? toFinger + BaseHeaderSize
					: toFinger);
				/* memmove must be used since the ranges may overlap. */
				start = 
				/* begin startOfObject:given: */
(numSlots1 == (numSlotsMask())
					? objOop - BaseHeaderSize
					: objOop);
				memmove(((void *)toFinger), ((void *)start), bytes);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(destObj)));
				longAtput((destObj + BaseHeaderSize) + (0U << (shiftForWord())), longAt(top));
				toFinger += bytes;
				if (((top += BytesPerOop)) >= ((GIV(savedFirstFieldsSpace).limit))) {
					assert(((GIV(savedFirstFieldsSpace).top)) == (top - BytesPerOop));
					assert(nextObj == GIV(objectAfterLastMobileObject));
					if (!previousPin) {
						previousPin = nextObj;
						startOfPreviousPin = 
						/* begin startOfObject: */
((byteAt(nextObj + 7)) == (numSlotsMask())
							? nextObj - BaseHeaderSize
							: nextObj);
					}
					if (toFinger < startOfPreviousPin) {
						GIV(firstFreeObject) = initFreeChunkWithBytesat(startOfPreviousPin - toFinger, toFinger);
					}
					else {
						GIV(firstFreeObject) = previousPin;
					}
					return 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = nextObj;
	}
	freeFromupTonextObject(toFinger, endOfMemory(), (!(previousPin)
		? (!(GIV(objectAfterLastMobileObject))
				? objectAfter(GIV(firstFreeObject))
				: GIV(objectAfterLastMobileObject))
		: previousPin));
	/* begin coalesceFrom: */
	if (toFinger >= (endOfMemory())) {
		goto l5;
	}
	/* begin objectStartingAt: */
	numSlots2 = byteAt(toFinger + 7);
	obj = (numSlots2 == (numSlotsMask())
		? toFinger + BaseHeaderSize
		: toFinger);
	while (1) {
		next = oldSpaceObjectAfter(obj);
		if (!(next < (endOfMemory()))) break;
		if ((((longAt(obj)) & (classIndexMask())) == (isFreeObjectClassIndexPun()))
		 && (((longAt(next)) & (classIndexMask())) == (isFreeObjectClassIndexPun()))) {
			objBytes = bytesInBody(obj);
			nextBytes = bytesInBody(next);
			unlinkFreeChunkchunkBytes(obj, objBytes);
			unlinkFreeChunkchunkBytes(next, nextBytes);
			obj = freeChunkWithBytesat(objBytes + nextBytes, 
			/* begin startOfObject: */
((byteAt(obj + 7)) == (numSlotsMask())
				? obj - BaseHeaderSize
				: obj));
		}
		else {
			obj = next;
		}
	}
	l5:	/* end coalesceFrom: */;
	return 1;
}


/*	Sweep the heap, unmarking all objects and moving mobile objects to their
	correct positions,
	restoring their savedFirstFields. */

	/* SpurPlanningCompactor>>#copyAndUnmark: */
static NoDbgRegParms NeverInline void
copyAndUnmark(sqInt firstPass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt finalPass;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;

	if (firstPass) {
		/* begin unmarkInitialImmobileObjects */
		o = 0;
		objOop = 0;
		assert(isOldObject(GIV(nilObj)));
		prevPrevObj = (prevObj = null);
		objOop1 = GIV(nilObj);
		while (1) {
			assert((objOop1 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
			assert((long64At(objOop1)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex = (longAt(objOop1)) & (classIndexMask())),
			assert((classIndex == (segmentBridgePun()))
				 || ((classIndex == (isForwardedObjectClassIndexPun()))
				 || (((long64At(objOop1)) != 0)
				 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex >= (isForwardedObjectClassIndexPun()))) {
				if (oopisGreaterThanOrEqualTo(objOop1, GIV(firstMobileObject))) {
					goto l2;
				}
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1)));
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				objOop1 = GIV(endOfMemory);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
	l2:	/* end unmarkInitialImmobileObjects */;
	}
	finalPass = copyAndUnmarkMobileObjects();
	if ((GIV(lastMobileObject))
	 && ((!finalPass)
	 && (GIV(biasForGC)))) {
		/* only ever one pass if biasForGC is true. */
		unmarkObjectsFromFirstFreeObject();
	}
}

	/* SpurPlanningCompactor>>#endCompaction */
static void
endCompaction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt prevObj;
    sqInt prevPrevObj;


	/* begin unmarkSurvivingObjectsForCompact */
	objOop = 0;
	objOop2 = 0;
	prevPrevObj = (prevObj = null);
	address = ((pastSpace()).start);
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	while (oopisLessThan(objOop1, GIV(pastSpaceStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt)((longAt(objOop1)))) >> (markedBitFullShift())) & 1) != 0) {
			/* begin setIsMarkedOf:to: */
			assert(!(isFreeObject(objOop1)));
			longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
			objOop1 = GIV(pastSpaceStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	/* begin endSlidingCompaction */
	GIV(gcPhaseInProgress) = 0;
	if ((rememberedSetSize()) > 0) {
		objOop3 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(objOop3)));
		longAtput((objOop3 + BaseHeaderSize) + (0U << (shiftForWord())), GIV(firstFieldOfRememberedSet));
	}
	objOop11 = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
	/* begin setIsPinnedOf:to: */
	longAtput(objOop11, (longAt(objOop11)) | (1U << (pinnedBitShift())));
	/* begin relocateRememberedSet */
	GIV(rememberedSet) = firstIndexableField(longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord()))))));
	if (	/* begin savedFirstFieldsSpaceWasAllocated */
		GIV(savedFirstFieldsSpaceNotInOldSpace)
	 && (oopisGreaterThan((GIV(savedFirstFieldsSpace).start), GIV(nilObj)))) {
		sqDeallocateMemorySegmentAtOfSize(((void *)((GIV(savedFirstFieldsSpace).start))), ((GIV(savedFirstFieldsSpace).limit)) - ((GIV(savedFirstFieldsSpace).start)));
	}
}


/*	Free from toFinger up to limit, dealing with possible intervening pinned
	objects. 
 */

	/* SpurPlanningCompactor>>#freeFrom:upTo:nextObject: */
static NoDbgRegParms void
freeFromupTonextObject(usqInt initialToFinger, usqInt limit, sqInt nextObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    sqInt obj;
    usqInt objStart;
    SpurSegmentInfo *seg;
    usqInt toFinger;

	toFinger = initialToFinger;
	objStart = 
	/* begin startOfObject: */
((byteAt(nextObject + 7)) == (numSlotsMask())
		? nextObject - BaseHeaderSize
		: nextObject);
	if (toFinger < objStart) {
		/* begin addFreeChunkWithBytes:at: */
		GIV(totalFreeOldSpace) += objStart - toFinger;
		freeChunkWithBytesat(objStart - toFinger, toFinger);
	}
	toFinger = objStart;
	while (objStart < limit) {
		/* begin objectStartingAt: */
		numSlots = byteAt(objStart + 7);
		obj = (numSlots == (numSlotsMask())
			? objStart + BaseHeaderSize
			: objStart);
		if ((((((usqInt)((longAt(obj)))) >> (markedBitFullShift())) & 1) != 0)
		 && (((((usqInt)((longAt(obj)))) >> (pinnedBitShift())) & 1) != 0)) {
			/* begin unmarkPinned: */
			if (((longAt(obj)) & (classIndexMask())) == (segmentBridgePun())) {
				assert(isMarked(obj));
			}
			else {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(obj)));
				longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
				/* begin notePinned: */
				assert(isPinned(obj));
				assert(!((isSegmentBridge(obj))));
				seg = segmentContainingObj(obj);
				(seg->containsPinned = 1);
			}
			if (toFinger < objStart) {
				/* begin addFreeChunkWithBytes:at: */
				GIV(totalFreeOldSpace) += objStart - toFinger;
				freeChunkWithBytesat(objStart - toFinger, toFinger);
			}
			toFinger = (objStart = addressAfter(obj));
		}
		else {
			objStart = addressAfter(obj);
		}
	}
	if (limit > toFinger) {
		/* begin addFreeChunkWithBytes:at: */
		GIV(totalFreeOldSpace) += limit - toFinger;
		freeChunkWithBytesat(limit - toFinger, toFinger);
	}
}


/*	Scan for firstFreeObject and firstMobileObject from the start of memory.
	Answer if the heap is already fully compacted. */

	/* SpurPlanningCompactor>>#initializeScanCheckingForFullyCompactedHeap */
static int
initializeScanCheckingForFullyCompactedHeap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(firstMobileObject) = (GIV(lastMobileObject) = (GIV(objectAfterLastMobileObject) = null));
	reinitializeScanFrom(GIV(hiddenRootsObj));
	if (!GIV(firstFreeObject)) {
		error("uncompactable heap; no unmarked objects found");
	}
	return GIV(firstMobileObject) >= (endOfMemory());
}

	/* SpurPlanningCompactor>>#isMobile: */
static NoDbgRegParms sqInt
isMobile(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThanOrEqualToandLessThanOrEqualTo(obj, GIV(mobileStart), GIV(lastMobileObject)))
	 && (!(((((usqInt)((longAt(obj)))) >> (pinnedBitShift())) & 1) != 0));
}


/*	For asserts */

	/* SpurPlanningCompactor>>#isPostMobile: */
static NoDbgRegParms sqInt
isPostMobile(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThanOrEqualTo(obj, GIV(mobileStart), GIV(lastMobileObject));
}


/*	Sweep the heap from firstFreeObject forwarding marked objects to where
	they can be moved to, saving their forwarding pointer in
	savedFirstFieldsSpace. Continue until either the end of the heap is
	reached or savedFirstFieldsSpace is full.
	Answer if the end of the heap was reached (savedFirstFieldsSpace has not
	overflowed). 
	The enumerations in planCompactSavingForwarders,
	updatePointersInMobileObjects and copyAndUnmarkMobileObjects
	match. We could implement them as a single enumeration method taking
	several block arguments, but arguably that
	would make understanding an already tricky algorithm more difficult.
	Instead we tolerate the duplication and encourage
	the reader to diff the three methods to see where they diverge (e.g. via
	Cmd-shift-C).  */

	/* SpurPlanningCompactor>>#planCompactSavingForwarders */
static NeverInline sqInt
planCompactSavingForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt availableSpace;
    usqInt bytes;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    usqInt o;
    sqInt objOop;
    usqInt previousPin;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt startOfPreviousPin;
    usqInt toFinger;
    usqInt top;
    sqInt valuePointer;

	o = 0;
	previousPin = 0;
	if (((GIV(savedFirstFieldsSpace).top)) < ((GIV(savedFirstFieldsSpace).start))) {
	}
	assert(!((isMarked(GIV(firstFreeObject)))));
	toFinger = 
	/* begin startOfObject: */
((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask())
		? GIV(firstFreeObject) - BaseHeaderSize
		: GIV(firstFreeObject));
	top = (GIV(savedFirstFieldsSpace).start);
	startOfPreviousPin = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstFreeObject)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstFreeObject);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		assert((previousPin == null
			? toFinger <= (startOfObject(objOop))
			: (isMarked(previousPin))
				 && (toFinger <= startOfPreviousPin)));
		assert(GIV(savedFirstFieldsSpaceNotInOldSpace)
		 || (toFinger < top));
		if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0) {
				if (!previousPin) {
					previousPin = objOop;
					startOfPreviousPin = 
					/* begin startOfObject: */
((byteAt(objOop + 7)) == (numSlotsMask())
						? objOop - BaseHeaderSize
						: objOop);
				}
			}
			else {
				bytes = bytesInBody(objOop);
				while ((toFinger <= startOfPreviousPin)
				 && ((bytes != ((availableSpace = startOfPreviousPin - toFinger)))
				 && ((bytes + (16)) > availableSpace))) {
					/* The object does not fit in the space between toFinger and previousPin.
					   Move toFinger up to point at the first unmarked or mobile object after
					   previousPin, or, if previousPin is contiguous with o, to the start of this
					   object.  Update previousPin to be the next pinned object above toFInger
					   and below this object, or nil if no such pinned object exists.
					   Any unfillable gaps between adjacent pinned objects will be freed. */
					do {
						toFinger = addressAfter(previousPin);
						/* begin objectStartingAt: */
						numSlots = byteAt(toFinger + 7);
						previousPin = (numSlots == (numSlotsMask())
							? toFinger + BaseHeaderSize
							: toFinger);
					} while((((((usqInt)((longAt(previousPin)))) >> (markedBitFullShift())) & 1) != 0)
						 && ((((((usqInt)((longAt(previousPin)))) >> (pinnedBitShift())) & 1) != 0)
						 && (previousPin < objOop)));
					while (!((previousPin >= objOop)
					 || ((((((usqInt)((longAt(previousPin)))) >> (markedBitFullShift())) & 1) != 0)
					 && (((((usqInt)((longAt(previousPin)))) >> (pinnedBitShift())) & 1) != 0)))) {
						previousPin = oldSpaceObjectAfter(previousPin);
					}
					if (previousPin >= objOop) {
						previousPin = null;
						startOfPreviousPin = 0;
					}
					else {
						startOfPreviousPin = 
						/* begin startOfObject: */
((byteAt(previousPin + 7)) == (numSlotsMask())
							? previousPin - BaseHeaderSize
							: previousPin);
					}
				}
				GIV(lastMobileObject) = objOop;
				longAtput(top, longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord()))));
				valuePointer = ((byteAt(objOop + 7)) == (numSlotsMask())
					? toFinger + BaseHeaderSize
					: toFinger);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(objOop)));
				longAtput((objOop + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
				toFinger += bytes;
				if (((top += BytesPerOop)) >= ((GIV(savedFirstFieldsSpace).limit))) {
					(GIV(savedFirstFieldsSpace).top = top - BytesPerOop);
					GIV(objectAfterLastMobileObject) = oldSpaceObjectAfter(GIV(lastMobileObject));
					return 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l3:	/* end objectAfter:limit: */;
	}
	if (!(GIV(lastMobileObject) == null)) {
		(GIV(savedFirstFieldsSpace).top = top - BytesPerOop);
		GIV(objectAfterLastMobileObject) = oldSpaceObjectAfter(GIV(lastMobileObject));
	}
	return 1;
}


/*	Search for firstFreeObject and firstMobileObject from initialObject, which
	is the
	hiddenRootsObject on the first pass, and the objectAfterLastMobileObject
	on subsequent passes). */

	/* SpurPlanningCompactor>>#reinitializeScanFrom: */
static NoDbgRegParms void
reinitializeScanFrom(sqInt initialObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	o = 0;
	GIV(firstFreeObject) = scanForFirstFreeAndFirstMobileObjectFrom(initialObject);
	if (!(GIV(firstFreeObject) == null)) {
		GIV(mobileStart) = 
		/* begin startOfObject: */
((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask())
			? GIV(firstFreeObject) - BaseHeaderSize
			: GIV(firstFreeObject));
	}
	if (!(GIV(objectAfterLastMobileObject) == null)) {
		/* begin allOldSpaceEntitiesFrom:to:do: */
		assert((isNonImmediate(GIV(firstFreeObject)))
		 && (isInSegments(GIV(firstFreeObject))));
		assert((isNonImmediate(GIV(objectAfterLastMobileObject)))
		 && (isInSegments(GIV(objectAfterLastMobileObject))));
		prevPrevObj = (prevObj = null);
		objOop = GIV(firstFreeObject);
		while (1) {
			assert((objOop % (allocationUnit())) == 0);
			if (!(oopisLessThanOrEqualTo(objOop, GIV(objectAfterLastMobileObject)))) break;
			assert((long64At(objOop)) != 0);
			if (!((((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0)
				 || ((!(((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0))
				 || (GIV(objectAfterLastMobileObject) == objOop)))) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			prevPrevObj = prevObj;
			prevObj = objOop;
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				objOop = GIV(endOfMemory);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
		GIV(firstMobileObject) = GIV(objectAfterLastMobileObject);
	}
}


/*	Scavenge or simply follow objOop. Answer the new location of objOop.
	The send should have been guarded by a send of shouldRemapOop:.
	The method is called remapObj: for compatibility with ObjectMemory. */

	/* SpurPlanningCompactor>>#remapObj: */
sqInt
remapObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt resolvedObj;


	/* begin slidingCompactionRemapObj: */
	assert(shouldRemapOop(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(objOop));
		referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		resolvedObj = referent;
	}
	else {
		assert(!((isInFutureSpace(objOop))));
		resolvedObj = objOop;
	}
	if (GIV(gcPhaseInProgress) > 0) {
		if (GIV(gcPhaseInProgress) == ScavengeInProgress) {
			if ((			/* begin isReallyYoung: */
				((!(resolvedObj & (tagMask()))))
			 && ((assert(isNonImmediate(resolvedObj)),
			(oopisLessThan(resolvedObj, GIV(oldSpaceStart)))
				 && (oopisGreaterThanOrEqualTo(resolvedObj, GIV(newSpaceStart))))))
			 && (!(oopisGreaterThanOrEqualToandLessThan(resolvedObj, ((futureSpace()).start), futureSurvivorStart())))) {
				return copyAndForward(resolvedObj);
			}
		}
		else {
			assert(slidingCompactionInProgress());
			if (			/* begin isMobile: */
				(oopisGreaterThanOrEqualToandLessThanOrEqualTo(objOop, GIV(mobileStart), GIV(lastMobileObject)))
			 && (!(((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0))) {
				return longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
			}
		}
	}
	return resolvedObj;
}

	/* SpurPlanningCompactor>>#savedFirstFieldsSpaceWasAllocated */
static sqInt
savedFirstFieldsSpaceWasAllocated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedFirstFieldsSpaceNotInOldSpace)
	 && (oopisGreaterThan((GIV(savedFirstFieldsSpace).start), GIV(nilObj)));
}


/*	Scan from initialObject, setting firstMobileObject to the first marked
	object after the first free object found, or endOfMemory if none is found.
	Answer the first free object found, or nil if none. */

	/* SpurPlanningCompactor>>#scanForFirstFreeAndFirstMobileObjectFrom: */
static NoDbgRegParms sqInt
scanForFirstFreeAndFirstMobileObjectFrom(sqInt initialObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstFree;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	firstFree = 0;
	o = 0;
	GIV(firstMobileObject) = endOfMemory();
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(initialObject));
	prevPrevObj = (prevObj = null);
	objOop = initialObject;
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
			if (!(firstFree == null)) {
				GIV(firstMobileObject) = objOop;
				return firstFree;
			}
		}
		else {
			if (!firstFree) {
				firstFree = objOop;
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return firstFree;
}


/*	Answer if the obj should be scavenged, or simply followed. Sent via the
	compactor from shouldRemapObj:. We test for being already scavenged
	because mapStackPages
	via mapInterpreterOops may be applied twice in the context of a global GC
	where a
	scavenge, followed by a scan-mark-free, and final compaction passes may
	result in
	scavenged fields being visited twice. */

	/* SpurPlanningCompactor>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return 
	/* begin slidingCompactionShouldRemapObj: */
((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
	 || ((GIV(gcPhaseInProgress) > 0)
	 && ((GIV(gcPhaseInProgress) == ScavengeInProgress
		? ((			/* begin isReallyYoungObject: */
				assert(isNonImmediate(objOop)),
			(oopisLessThan(objOop, GIV(oldSpaceStart)))
				 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart)))))
			 && (!(oopisGreaterThanOrEqualToandLessThan(objOop, ((futureSpace()).start), futureSurvivorStart())))
		: 
			/* begin isMobile: */
(oopisGreaterThanOrEqualToandLessThanOrEqualTo(objOop, GIV(mobileStart), GIV(lastMobileObject)))
			 && (!(((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0)))));
}


/*	Sweep the final immobile heap, freeing and coalescing unmarked and free
	objects, and unmarking all marked objects up to the end of memory. */

	/* SpurPlanningCompactor>>#unmarkObjectsFromFirstFreeObject */
static void
unmarkObjectsFromFirstFreeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt freeBytes;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    SpurSegmentInfo *seg;
    usqInt startOfFree;

	o = 0;
	startOfFree = 0;
	freeBytes = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstFreeObject)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstFreeObject);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
			if (!(startOfFree == null)) {
				/* begin addFreeChunkWithBytes:at: */
				GIV(totalFreeOldSpace) += freeBytes;
				freeChunkWithBytesat(freeBytes, startOfFree);
				startOfFree = null;
				freeBytes = 0;
			}
			if (((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0) {
				/* begin unmarkPinned: */
				if (((longAt(objOop)) & (classIndexMask())) == (segmentBridgePun())) {
					assert(isMarked(objOop));
				}
				else {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop)));
					longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
					/* begin notePinned: */
					assert(isPinned(objOop));
					assert(!((isSegmentBridge(objOop))));
					seg = segmentContainingObj(objOop);
					(seg->containsPinned = 1);
				}
			}
			else {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
		}
		else {
			if (!startOfFree) {
				startOfFree = 
				/* begin startOfObject: */
((byteAt(objOop + 7)) == (numSlotsMask())
					? objOop - BaseHeaderSize
					: objOop);
			}
			freeBytes += bytesInBody(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l2:	/* end objectAfter:limit: */;
	}
	if (!(startOfFree == null)) {
		/* begin addFreeChunkWithBytes:at: */
		GIV(totalFreeOldSpace) += freeBytes;
		freeChunkWithBytesat(freeBytes, startOfFree);
	}
}


/*	Sweep the heap, updating all objects to their eventual locations.
	Remember to update the savedFirstFields of pointer objects, as these have
	been forwarded. */

	/* SpurPlanningCompactor>>#updatePointers */
static NeverInline void
updatePointers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt availableSpace;
    usqInt bytes;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt contextSize2;
    sqInt contextSize3;
    sqInt finishIndex;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt fmt3;
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt fwd;
    sqInt fwd1;
    sqInt fwd2;
    sqInt fwd3;
    sqInt fwd4;
    sqInt header;
    sqInt header1;
    sqInt header11;
    sqInt header12;
    sqInt header13;
    sqInt header2;
    sqInt header3;
    sqInt header4;
    sqInt heapEntity;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt numLiterals2;
    sqInt numLiterals3;
    usqInt numPointerSlots;
    usqInt numPointerSlots1;
    usqInt numPointerSlots2;
    usqInt numPointerSlots3;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt o;
    sqInt o1;
    usqInt o2;
    sqInt o3;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt onePass;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    usqInt previousPin;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj2;
    sqInt prevObj3;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj2;
    sqInt prevPrevObj3;
    sqInt sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sp3;
    usqInt startOfPreviousPin;
    usqInt toFinger;
    usqInt top;

	if (!(GIV(lastMobileObject))) {
		return;
	}
	assert((startOfObject(GIV(firstFreeObject))) == GIV(mobileStart));
	mapInterpreterOops();
	mapExtraRoots();
	/* begin updatePointersInManagerHeapEntities */
	GIV(markStack) = relocateObjStackForPlanningCompactorandContents(GIV(markStack), 0);
	GIV(weaklingStack) = relocateObjStackForPlanningCompactorandContents(GIV(weaklingStack), 0);
	GIV(mournQueue) = relocateObjStackForPlanningCompactorandContents(GIV(mournQueue), 1);
	if (((rememberedSetSize()) > 0)
	 && (	/* begin isMobile: */
		(oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(firstFieldOfRememberedSet), GIV(mobileStart), GIV(lastMobileObject)))
	 && (!(((((usqInt)((longAt(GIV(firstFieldOfRememberedSet))))) >> (pinnedBitShift())) & 1) != 0)))) {
		GIV(firstFieldOfRememberedSet) = longAt((GIV(firstFieldOfRememberedSet) + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	heapEntity = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (((sqInt)((usqInt)(RememberedSetRootIndex) << (shiftForWord())))));
	finishIndex = (rememberedSetSize()) - 1;
	/* begin relocateObjectsInHeapEntity:from:to: */
	for (i = 1; i <= finishIndex; i += 1) {
		oop = longAt((heapEntity + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (((!(oop & (tagMask()))))
		 && (		/* begin isMobile: */
			(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject)))
		 && (!(((((usqInt)((longAt(oop)))) >> (pinnedBitShift())) & 1) != 0)))) {
			assert(isMarked(oop));
			fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
			assert(isPostMobile(fwd));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(heapEntity)));
			longAtput((heapEntity + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), fwd);
		}
	}
	if (	/* begin isMobile: */
		(oopisGreaterThanOrEqualToandLessThanOrEqualTo(heapEntity, GIV(mobileStart), GIV(lastMobileObject)))
	 && (!(((((usqInt)((longAt(heapEntity)))) >> (pinnedBitShift())) & 1) != 0))) {
		/* begin fetchPointer:ofObject: */
		longAt((heapEntity + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	else {
	}
	/* begin updatePointersInSurvivingObjects */
	o = 0;
	objOop = 0;
	prevPrevObj = (prevObj = null);
	address = ((pastSpace()).start);
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	while (oopisLessThan(objOop1, GIV(pastSpaceStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		assert(isMarked(objOop1));
		/* begin updatePointersIn: */
		fmt = (((usqInt)((longAt(objOop1)))) >> (formatShift())) & (formatMask());
		if (fmt <= 5 /* begin lastPointerFormat */) {
			if ((fmt == (indexablePointersFormat()))
			 && (((longAt(objOop1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l4;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop1)));
				contextSize = (sp >> 3);
	l4:	/* end fetchStackPointerOf: */;
				numPointerSlots = CtxtTempFrameStart + contextSize;
				goto l3;
			}
			/* begin numSlotsOf: */
			assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
			if (((numSlots1 = byteAt(objOop1 + 7))) == (numSlotsMask())) {
				/* overflow slots; at least (2^32)-1 slots, which is plenty */
				numPointerSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop1 - BaseHeaderSize))) << 8)))))) >> 8;
			}
			else {
				numPointerSlots = numSlots1;
			}
			goto l3;
		}
		if (fmt == 7 /* begin forwardedFormat */) {
			numPointerSlots = 1;
			goto l3;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			numPointerSlots = 0;
			goto l3;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(objOop1));
		header1 = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		header = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		/* begin literalCountOfMethodHeader: */
		assert((((header) & 7) == 1));
		numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
		numPointerSlots = numLiterals + LiteralStart;
	l3:	/* end numPointerSlotsOf: */;
		for (i1 = 0; i1 < numPointerSlots; i1 += 1) {
			oop1 = longAt((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
			if (((!(oop1 & (tagMask()))))
			 && (			/* begin isMobile: */
				(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop1, GIV(mobileStart), GIV(lastMobileObject)))
			 && (!(((((usqInt)((longAt(oop1)))) >> (pinnedBitShift())) & 1) != 0)))) {
				assert((isMarked(oop1))
				 || (objOop1 == (hiddenRootsObject())));
				fwd1 = longAt((oop1 + BaseHeaderSize) + (0U << (shiftForWord())));
				assert(isPostMobile(fwd1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isOopForwarded(objOop1)));
				longAtput((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))), fwd1);
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
			objOop1 = GIV(pastSpaceStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	/* begin updatePointersInInitialImmobileObjects */
	o1 = 0;
	objOop2 = 0;
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(objOop11)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(objOop11)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if (oopisGreaterThanOrEqualTo(objOop11, GIV(firstFreeObject))) {
				goto l11;
			}
			/* begin updatePointersIn: */
			fmt1 = (((usqInt)((longAt(objOop11)))) >> (formatShift())) & (formatMask());
			if (fmt1 <= 5 /* begin lastPointerFormat */) {
				if ((fmt1 == (indexablePointersFormat()))
				 && (((longAt(objOop11)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp1 = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((((sp1) & 7) == 1))) {
						contextSize1 = 0;
						goto l9;
					}
					assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(objOop11)));
					contextSize1 = (sp1 >> 3);
	l9:	/* end fetchStackPointerOf: */;
					numPointerSlots1 = CtxtTempFrameStart + contextSize1;
					goto l7;
				}
				/* begin numSlotsOf: */
				assert((classIndexOf(objOop11)) > (isForwardedObjectClassIndexPun()));
				if (((numSlots2 = byteAt(objOop11 + 7))) == (numSlotsMask())) {
					/* overflow slots; at least (2^32)-1 slots, which is plenty */
					numPointerSlots1 = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop11 - BaseHeaderSize))) << 8)))))) >> 8;
				}
				else {
					numPointerSlots1 = numSlots2;
				}
				goto l7;
			}
			if (fmt1 == 7 /* begin forwardedFormat */) {
				numPointerSlots1 = 1;
				goto l7;
			}
			if (fmt1 < (firstCompiledMethodFormat())) {
				numPointerSlots1 = 0;
				goto l7;
			}
			/* begin methodHeaderOf: */
			assert(isCompiledMethod(objOop11));
			header11 = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
			header2 = ((((header11) & 7) == 1)
				? header11
				: (assert((((usqInt)header11)) < GIV(newSpaceStart)),
					assert((((((CogMethod *) header11))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
					((((CogMethod *) header11))->methodHeader)));
			/* begin literalCountOfMethodHeader: */
			assert((((header2) & 7) == 1));
			numLiterals1 = ((header2 >> 3)) & AlternateHeaderNumLiteralsMask;
			numPointerSlots1 = numLiterals1 + LiteralStart;
	l7:	/* end numPointerSlotsOf: */;
			for (i2 = 0; i2 < numPointerSlots1; i2 += 1) {
				oop2 = longAt((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord())))));
				if (((!(oop2 & (tagMask()))))
				 && (				/* begin isMobile: */
					(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop2, GIV(mobileStart), GIV(lastMobileObject)))
				 && (!(((((usqInt)((longAt(oop2)))) >> (pinnedBitShift())) & 1) != 0)))) {
					assert((isMarked(oop2))
					 || (objOop11 == (hiddenRootsObject())));
					fwd2 = longAt((oop2 + BaseHeaderSize) + (0U << (shiftForWord())));
					assert(isPostMobile(fwd2));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(objOop11)));
					longAtput((objOop11 + BaseHeaderSize) + (((sqInt)((usqInt)(i2) << (shiftForWord())))), fwd2);
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop11);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop11 = GIV(endOfMemory);
			goto l8;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop11 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l8:	/* end objectAfter:limit: */;
	}
	l11:	/* end updatePointersInInitialImmobileObjects */;
	/* begin updatePointersInMobileObjects */
	o2 = 0;
	previousPin = 0;
	assert(!((isMarked(GIV(firstFreeObject)))));
	toFinger = 
	/* begin startOfObject: */
((byteAt(GIV(firstFreeObject) + 7)) == (numSlotsMask())
		? GIV(firstFreeObject) - BaseHeaderSize
		: GIV(firstFreeObject));
	top = (GIV(savedFirstFieldsSpace).start);
	startOfPreviousPin = 0;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstFreeObject)));
	prevPrevObj2 = (prevObj2 = null);
	objOop3 = GIV(firstFreeObject);
	while (1) {
		assert((objOop3 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop3, GIV(endOfMemory)))) break;
		assert((long64At(objOop3)) != 0);
		assert((previousPin == null
			? toFinger <= (startOfObject(objOop3))
			: (isMarked(previousPin))
				 && (toFinger <= startOfPreviousPin)));
		if (((((usqInt)((longAt(objOop3)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((((usqInt)((longAt(objOop3)))) >> (pinnedBitShift())) & 1) != 0) {
				if (!previousPin) {
					previousPin = objOop3;
					startOfPreviousPin = 
					/* begin startOfObject: */
((byteAt(objOop3 + 7)) == (numSlotsMask())
						? objOop3 - BaseHeaderSize
						: objOop3);
				}
				fmt2 = (((usqInt)((longAt(objOop3)))) >> (formatShift())) & (formatMask());
				if (fmt2 <= 5 /* begin lastPointerFormat */) {
					if ((fmt2 == (indexablePointersFormat()))
					 && (((longAt(objOop3)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
						/* contexts end at the stack pointer */
						/* begin fetchStackPointerOf: */
						sp2 = longAt((objOop3 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
						if (!((((sp2) & 7) == 1))) {
							contextSize2 = 0;
							goto l15;
						}
						assert((ReceiverIndex + ((sp2 >> 3))) < (lengthOf(objOop3)));
						contextSize2 = (sp2 >> 3);
	l15:	/* end fetchStackPointerOf: */;
						numPointerSlots2 = CtxtTempFrameStart + contextSize2;
						goto l13;
					}
					/* begin numSlotsOf: */
					assert((classIndexOf(objOop3)) > (isForwardedObjectClassIndexPun()));
					if (((numSlots11 = byteAt(objOop3 + 7))) == (numSlotsMask())) {
						/* overflow slots; at least (2^32)-1 slots, which is plenty */
						numPointerSlots2 = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop3 - BaseHeaderSize))) << 8)))))) >> 8;
					}
					else {
						numPointerSlots2 = numSlots11;
					}
					goto l13;
				}
				if (fmt2 == 7 /* begin forwardedFormat */) {
					numPointerSlots2 = 1;
					goto l13;
				}
				if (fmt2 < (firstCompiledMethodFormat())) {
					numPointerSlots2 = 0;
					goto l13;
				}
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objOop3));
				header12 = longAt((objOop3 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
				header3 = ((((header12) & 7) == 1)
					? header12
					: (assert((((usqInt)header12)) < GIV(newSpaceStart)),
						assert((((((CogMethod *) header12))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
						((((CogMethod *) header12))->methodHeader)));
				/* begin literalCountOfMethodHeader: */
				assert((((header3) & 7) == 1));
				numLiterals2 = ((header3 >> 3)) & AlternateHeaderNumLiteralsMask;
				numPointerSlots2 = numLiterals2 + LiteralStart;
	l13:	/* end numPointerSlotsOf: */;
				for (i3 = 0; i3 < numPointerSlots2; i3 += 1) {
					oop3 = longAt((objOop3 + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord())))));
					if (((!(oop3 & (tagMask()))))
					 && (					/* begin isMobile: */
						(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop3, GIV(mobileStart), GIV(lastMobileObject)))
					 && (!(((((usqInt)((longAt(oop3)))) >> (pinnedBitShift())) & 1) != 0)))) {
						assert((isMarked(oop3))
						 || (objOop3 == (hiddenRootsObject())));
						fwd3 = longAt((oop3 + BaseHeaderSize) + (0U << (shiftForWord())));
						assert(isPostMobile(fwd3));
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isOopForwarded(objOop3)));
						longAtput((objOop3 + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord())))), fwd3);
					}
				}
			}
			else {
				bytes = bytesInBody(objOop3);
				while ((toFinger <= startOfPreviousPin)
				 && ((bytes != ((availableSpace = startOfPreviousPin - toFinger)))
				 && ((bytes + (16)) > availableSpace))) {
					/* The object does not fit in the space between toFinger and previousPin.
					   Move toFinger up to point at the first unmarked or mobile object after
					   previousPin, or, if previousPin is contiguous with o, to the start of this
					   object.  Update previousPin to be the next pinned object above toFInger
					   and below this object, or nil if no such pinned object exists.
					   Any unfillable gaps between adjacent pinned objects will be freed. */
					do {
						toFinger = addressAfter(previousPin);
						/* begin objectStartingAt: */
						numSlots3 = byteAt(toFinger + 7);
						previousPin = (numSlots3 == (numSlotsMask())
							? toFinger + BaseHeaderSize
							: toFinger);
					} while((((((usqInt)((longAt(previousPin)))) >> (markedBitFullShift())) & 1) != 0)
						 && ((((((usqInt)((longAt(previousPin)))) >> (pinnedBitShift())) & 1) != 0)
						 && (previousPin < objOop3)));
					while (!((previousPin >= objOop3)
					 || ((((((usqInt)((longAt(previousPin)))) >> (markedBitFullShift())) & 1) != 0)
					 && (((((usqInt)((longAt(previousPin)))) >> (pinnedBitShift())) & 1) != 0)))) {
						previousPin = oldSpaceObjectAfter(previousPin);
					}
					if (previousPin >= objOop3) {
						previousPin = null;
						startOfPreviousPin = 0;
					}
					else {
						startOfPreviousPin = 
						/* begin startOfObject: */
((byteAt(previousPin + 7)) == (numSlotsMask())
							? previousPin - BaseHeaderSize
							: previousPin);
					}
				}
				updatePointersInsavedFirstFieldPointer(objOop3, top);
				toFinger += bytes;
				if (((top += BytesPerOop)) >= ((GIV(savedFirstFieldsSpace).limit))) {
					assert(((GIV(savedFirstFieldsSpace).top)) == (top - BytesPerOop));
					onePass = 0;
					goto l17;
				}
			}
		}
		prevPrevObj2 = prevObj2;
		prevObj2 = objOop3;
		/* begin objectAfter:limit: */
		followingWordAddress2 = addressAfter(objOop3);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, GIV(endOfMemory))) {
			objOop3 = GIV(endOfMemory);
			goto l16;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2);
		objOop3 = ((((usqInt)(followingWord2)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	l16:	/* end objectAfter:limit: */;
	}
	assert(((GIV(savedFirstFieldsSpace).top)) == (top - BytesPerOop));
	onePass = 1;
	l17:	/* end updatePointersInMobileObjects */;
	if (!onePass) {
		/* begin updatePointersInObjectsOverflowingSavedFirstFieldsSpace */
		o3 = 0;
		objOop4 = 0;
		assert(isOldObject(GIV(objectAfterLastMobileObject)));
		prevPrevObj3 = (prevObj3 = null);
		objOop12 = GIV(objectAfterLastMobileObject);
		while (1) {
			assert((objOop12 % (allocationUnit())) == 0);
			if (!(oopisLessThan(objOop12, GIV(endOfMemory)))) break;
			assert((long64At(objOop12)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex1 = (longAt(objOop12)) & (classIndexMask())),
			assert((classIndex1 == (segmentBridgePun()))
				 || ((classIndex1 == (isForwardedObjectClassIndexPun()))
				 || (((long64At(objOop12)) != 0)
				 && (classIndex1 < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex1 >= (isForwardedObjectClassIndexPun()))) {
				if (((((usqInt)((longAt(objOop12)))) >> (markedBitFullShift())) & 1) != 0) {
					/* begin updatePointersIn: */
					fmt3 = (((usqInt)((longAt(objOop12)))) >> (formatShift())) & (formatMask());
					if (fmt3 <= 5 /* begin lastPointerFormat */) {
						if ((fmt3 == (indexablePointersFormat()))
						 && (((longAt(objOop12)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
							/* contexts end at the stack pointer */
							/* begin fetchStackPointerOf: */
							sp3 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
							if (!((((sp3) & 7) == 1))) {
								contextSize3 = 0;
								goto l20;
							}
							assert((ReceiverIndex + ((sp3 >> 3))) < (lengthOf(objOop12)));
							contextSize3 = (sp3 >> 3);
	l20:	/* end fetchStackPointerOf: */;
							numPointerSlots3 = CtxtTempFrameStart + contextSize3;
							goto l18;
						}
						/* begin numSlotsOf: */
						assert((classIndexOf(objOop12)) > (isForwardedObjectClassIndexPun()));
						if (((numSlots4 = byteAt(objOop12 + 7))) == (numSlotsMask())) {
							/* overflow slots; at least (2^32)-1 slots, which is plenty */
							numPointerSlots3 = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop12 - BaseHeaderSize))) << 8)))))) >> 8;
						}
						else {
							numPointerSlots3 = numSlots4;
						}
						goto l18;
					}
					if (fmt3 == 7 /* begin forwardedFormat */) {
						numPointerSlots3 = 1;
						goto l18;
					}
					if (fmt3 < (firstCompiledMethodFormat())) {
						numPointerSlots3 = 0;
						goto l18;
					}
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objOop12));
					header13 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					header4 = ((((header13) & 7) == 1)
						? header13
						: (assert((((usqInt)header13)) < GIV(newSpaceStart)),
							assert((((((CogMethod *) header13))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
							((((CogMethod *) header13))->methodHeader)));
					/* begin literalCountOfMethodHeader: */
					assert((((header4) & 7) == 1));
					numLiterals3 = ((header4 >> 3)) & AlternateHeaderNumLiteralsMask;
					numPointerSlots3 = numLiterals3 + LiteralStart;
	l18:	/* end numPointerSlotsOf: */;
					for (i4 = 0; i4 < numPointerSlots3; i4 += 1) {
						oop4 = longAt((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord())))));
						if (((!(oop4 & (tagMask()))))
						 && (						/* begin isMobile: */
							(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop4, GIV(mobileStart), GIV(lastMobileObject)))
						 && (!(((((usqInt)((longAt(oop4)))) >> (pinnedBitShift())) & 1) != 0)))) {
							assert((isMarked(oop4))
							 || (objOop12 == (hiddenRootsObject())));
							fwd4 = longAt((oop4 + BaseHeaderSize) + (0U << (shiftForWord())));
							assert(isPostMobile(fwd4));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isOopForwarded(objOop12)));
							longAtput((objOop12 + BaseHeaderSize) + (((sqInt)((usqInt)(i4) << (shiftForWord())))), fwd4);
						}
					}
				}
			}
			prevPrevObj3 = prevObj3;
			prevObj3 = objOop12;
			/* begin objectAfter:limit: */
			followingWordAddress3 = addressAfter(objOop12);
			if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory))) {
				objOop12 = GIV(endOfMemory);
				goto l19;
			}
			flag("endianness");
			followingWord3 = longAt(followingWordAddress3);
			objOop12 = ((((usqInt)(followingWord3)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress3 + BaseHeaderSize
				: followingWordAddress3);
	l19:	/* end objectAfter:limit: */;
		}
	}
}


/*	Sweep the pointer fields in obj, updating all references to mobile objects
	to their eventual locations.
	firstFieldPtr is supplied for mobile objects so that the saved first field
	can be updated, and so that
	the first field of a compiled method (which is its header, or reference to
	a CogMethod holding its header)
	can be retrieved. */

	/* SpurPlanningCompactor>>#updatePointersIn:savedFirstFieldPointer: */
static NoDbgRegParms void
updatePointersInsavedFirstFieldPointer(sqInt obj, sqInt firstFieldPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt fwd;
    sqInt header;
    sqInt i;
    sqInt numLiterals;
    sqInt numPointerSlots;
    usqInt numSlots;
    sqInt oop;
    sqInt sp;

	fmt = (((usqInt)((longAt(obj)))) >> (formatShift())) & (formatMask());
	/* begin numPointerSlotsWhileCompactingOf:withFormat:savedFirstFieldPointer: */
	assert((firstFieldPtr)
	 && (isMobile(obj)));
	if (fmt <= 5 /* begin lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(obj)));
			contextSize = (sp >> 3);
	l1:	/* end fetchStackPointerOf: */;
			numPointerSlots = ((usqInt) (CtxtTempFrameStart + contextSize));
			goto l3;
		}
		/* begin numSlotsOf: */
		assert((classIndexOf(obj)) > (isForwardedObjectClassIndexPun()));
		if (((numSlots = byteAt(obj + 7))) == (numSlotsMask())) {
			/* overflow slots; at least (2^32)-1 slots, which is plenty */
			numPointerSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8;
		}
		else {
			numPointerSlots = numSlots;
		}
		goto l3;
	}
	assert(!((fmt == (forwardedFormat()))));
	if (fmt < (firstCompiledMethodFormat())) {
		numPointerSlots = 0;
		goto l3;
	}
	field = longAt(firstFieldPtr);
	/* begin methodHeaderFromSavedFirstField: */
	if ((((field) & 7) == 1)) {
		header = field;
		goto l2;
	}
	assert((isNonImmediate(field))
	 && (field < GIV(newSpaceStart)));
	assert((((((CogMethod *) field))->objectHeader)) == (nullHeaderForMachineCodeMethod()));
	header = ((((CogMethod *) field))->methodHeader);
	l2:	/* end methodHeaderFromSavedFirstField: */;
	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numPointerSlots = ((usqInt) (numLiterals + LiteralStart));
	l3:	/* end numPointerSlotsWhileCompactingOf:withFormat:savedFirstFieldPointer: */;
	if ((fmt <= 5 /* begin lastPointerFormat */)
	 && (numPointerSlots > 0)) {
		/* Relocate the saved first field; Note that CompiledMethods can be excluded since their
		   first field is either a SmallInteger or a reference to a CogMethod outside of oldSpace. */
		oop = longAt(firstFieldPtr);
		if (((!(oop & (tagMask()))))
		 && (		/* begin isMobile: */
			(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject)))
		 && (!(((((usqInt)((longAt(oop)))) >> (pinnedBitShift())) & 1) != 0)))) {
			assert(isMarked(oop));
			fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
			assert(isPostMobile(fwd));
			longAtput(firstFieldPtr, fwd);
		}
	}
	for (i = 1; i < numPointerSlots; i += 1) {
		oop = longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (((!(oop & (tagMask()))))
		 && (		/* begin isMobile: */
			(oopisGreaterThanOrEqualToandLessThanOrEqualTo(oop, GIV(mobileStart), GIV(lastMobileObject)))
		 && (!(((((usqInt)((longAt(oop)))) >> (pinnedBitShift())) & 1) != 0)))) {
			assert((isMarked(oop))
			 || (obj == (hiddenRootsObject())));
			fwd = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
			assert(isPostMobile(fwd));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(obj)));
			longAtput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), fwd);
		}
	}
}


/*	Attempt to allocate a memory segment large enough to hold the
	savedFirstFieldsSpace. Invoked when neither eden nor a large free chunk
	are found to be big enough for the job. */

	/* SpurPlanningCompactor>>#useSegmentForSavedFirstFieldsSpace: */
static NoDbgRegParms sqInt
useSegmentForSavedFirstFieldsSpace(sqInt spaceEstimate)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocatedSize;
    sqInt roundedSize;
    void *segAddress;

	allocatedSize = 0;
	roundedSize = ((spaceEstimate + 0x3FF) / 0x400) * 0x400;
	segAddress = sqAllocateMemorySegmentOfSizeAboveAllocatedSizeInto(roundedSize, firstGapOfSizeAtLeast(roundedSize), (&allocatedSize));
	if (!(segAddress == null)) {
		(GIV(savedFirstFieldsSpace).start = ((usqIntptr_t)segAddress));
		(GIV(savedFirstFieldsSpace).limit = (((usqIntptr_t)segAddress)) + allocatedSize);
		GIV(savedFirstFieldsSpaceNotInOldSpace) = 1;
		assert(savedFirstFieldsSpaceWasAllocated());
		return 1;
	}
	return 0;
}


/*	Answer 0 if all the mobile objects from firstMobileObject to
	lastMobileObject have sane forwarding addresses, and that
	savedFirstFieldsSpace is of
	matching capacity. Otherwise answer an error code identifying the anomaly. */

	/* SpurPlanningCompactor>>#validRelocationPlanInPass: */
static NoDbgRegParms sqInt
validRelocationPlanInPass(sqInt onePass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt destination;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt nMobiles;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt toFinger;

	o = 0;
	nMobiles = 0;
	toFinger = GIV(mobileStart);
	GIV(anomaly) = null;
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(firstMobileObject)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(firstMobileObject);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
			if (!(((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0)) {
				nMobiles += 1;
				destination = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
				if (!(destination >= toFinger)) {
					GIV(anomaly) = objOop;
					return 1;
				}
				toFinger += bytesInBody(objOop);
				if (oopisGreaterThan(objOop, GIV(lastMobileObject))) {
					GIV(anomaly) = objOop;
					return 2;
				}
				if (objOop == GIV(lastMobileObject)) {
					return ((((((GIV(savedFirstFieldsSpace).top)) + BytesPerOop) - ((GIV(savedFirstFieldsSpace).start))) / BytesPerOop) == nMobiles
						? 0
						: 3);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return ((((((GIV(savedFirstFieldsSpace).top)) + BytesPerOop) - ((GIV(savedFirstFieldsSpace).start))) / BytesPerOop) == nMobiles
		? 0
		: 4);
}

	/* SpurSegmentInfo>>#segLimit */
static NoDbgRegParms usqInt
segLimit(SpurSegmentInfo *self_in_SpurSegmentInfo)
{
	return ((self_in_SpurSegmentInfo->segSize)) + ((self_in_SpurSegmentInfo->segStart));
}

	/* SpurSegmentManager>>#addSegmentOfSize: */
static NoDbgRegParms SpurSegmentInfo *
addSegmentOfSize(sqInt ammount)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocatedSize;
    sqInt i;
    sqInt idx;
    sqInt lastSegIndex;
    SpurSegmentInfo *newSeg;
    sqInt newSegIndex;
    void *segAddress;
    sqInt segAddress1;
    sqInt segIndex;

	newSegIndex = 0;
	allocatedSize = 0;
	segAddress = sqAllocateMemorySegmentOfSizeAboveAllocatedSizeInto(ammount, firstGapOfSizeAtLeast(ammount), (&allocatedSize));
	if (!(segAddress == null)) {
		segAddress1 = ((usqIntptr_t)segAddress);
		/* begin insertSegmentFor: */
		assert(segAddress1 >= (segLimit(&GIV(segments)[0])));
		if (GIV(numSegments) == GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		assert(GIV(numSegments) < GIV(numSegInfos));
		segIndex = (lastSegIndex = GIV(numSegments) - 1);
		GIV(numSegments) += 1;
		while (1) {
			if (segAddress1 >= ((((GIV(segments)[segIndex]).segSize)) + (((GIV(segments)[segIndex]).segStart)))) {
				segIndex += 1;
				for (idx = lastSegIndex; idx >= segIndex; idx += -1) {
					GIV(segments)[idx + 1] = (GIV(segments)[idx]);
				}
				newSegIndex = segIndex;
				goto l1;
			}
			segIndex -= 1;
		}
	l1:	/* end insertSegmentFor: */;
		newSeg = (&(GIV(segments)[newSegIndex]));
		(newSeg->segStart = ((usqIntptr_t)segAddress));
		(newSeg->segSize = allocatedSize);
		(newSeg->swizzle = 0);
		assert(!(segmentOverlap()));
		bridgeFromto((&(GIV(segments)[newSegIndex - 1])), newSeg);
		bridgeFromto(newSeg, (!(newSegIndex == (GIV(numSegments) - 1))
			? (&(GIV(segments)[newSegIndex + 1]))
			: 0));
		/* test isInMemory: */
		GIV(totalHeapSizeIncludingBridges) += allocatedSize;
		for (i = 0; i < GIV(numSegments); i += 1) {
			assert(isInSegments(((GIV(segments)[i]).segStart)));
			assert(isInSegments((segLimit(&GIV(segments)[i])) - BytesPerWord));
			assert((!(isInSegments(segLimit(&GIV(segments)[i]))))
			 || ((i < (GIV(numSegments) - 1))
			 && ((segLimit(&GIV(segments)[i])) == (((GIV(segments)[i + 1]).segStart)))));
			assert((!(isInSegments((((GIV(segments)[i]).segStart)) - BytesPerWord)))
			 || ((i > 0)
			 && ((segLimit(&GIV(segments)[i - 1])) == (((GIV(segments)[i]).segStart)))));
		}
		return newSeg;
	}
	return null;
}


/*	Adjust swizzles by firstSegmentShift. Also computes segStarts as
	they were in the image when it was written, so that oops' segments
	can be determined and hence oops correctly swizzled. */

	/* SpurSegmentManager>>#adjustSegmentSwizzlesBy: */
static NoDbgRegParms void
adjustSegmentSwizzlesBy(sqInt firstSegmentShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oldBaseAddr;
    SpurSegmentInfo *segInfo;

	oldBaseAddr = GIV(oldSpaceStart) - firstSegmentShift;
	for (i = 0; i < GIV(numSegments); i += 1) {
		segInfo = (&(GIV(segments)[i]));
		(segInfo->segStart = ((segInfo->segStart)) + oldBaseAddr);
		(segInfo->swizzle = ((segInfo->swizzle)) - oldBaseAddr);
	}
	GIV(canSwizzle) = 1;
}

	/* SpurSegmentManager>>#allBridgesMarked */
static sqInt
allBridgesMarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bridgeObj;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i < GIV(numSegments); i += 1) {
		/* begin bridgeAt: */
		address = (((((&(GIV(segments)[i])))->segSize)) + ((((&(GIV(segments)[i])))->segStart))) - (2 * BaseHeaderSize);
		numSlots = byteAt(address + 7);
		bridgeObj = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		assert(isValidSegmentBridge(bridgeObj));
		if (!(((((usqInt)((longAt(bridgeObj)))) >> (markedBitFullShift())) & 1) != 0)) {
			return 0;
		}
	}
	return 1;
}


/*	Increase the number of allocated segInfos by 16. */

	/* SpurSegmentManager>>#allocateOrExtendSegmentInfos */
static void
allocateOrExtendSegmentInfos(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newNumSegs;

	if (GIV(numSegInfos) == 0) {
		GIV(numSegInfos) = 16;
		GIV(segments) = calloc(GIV(numSegInfos), sizeof(SpurSegmentInfo));
		return;
	}
	newNumSegs = GIV(numSegInfos) + 16;
	GIV(segments) = realloc(GIV(segments), newNumSegs * (sizeof(SpurSegmentInfo)));
	if (GIV(segments) == 0) {
		error("out of memory; cannot allocate more segments");
	}
	memset(GIV(segments) + GIV(numSegInfos), 0, (newNumSegs - GIV(numSegInfos)) * (sizeof(SpurSegmentInfo)));
	GIV(numSegInfos) = newNumSegs;
}

	/* SpurSegmentManager>>#bridgeAt: */
static NoDbgRegParms sqInt
bridgeAt(sqInt segIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt numSlots;


	/* begin bridgeFor: */
	address = (((((&(GIV(segments)[segIndex])))->segSize)) + ((((&(GIV(segments)[segIndex])))->segStart))) - (2 * BaseHeaderSize);
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}

	/* SpurSegmentManager>>#bridgeFor: */
static NoDbgRegParms sqInt
bridgeFor(SpurSegmentInfo *aSegment)
{
    sqInt address;
    usqInt numSlots;

	address = (((aSegment->segSize)) + ((aSegment->segStart))) - (2 * BaseHeaderSize);
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}


/*	Create a bridge from aSegment to the next segment,
	or create a terminating bridge if there is no next segment. */

	/* SpurSegmentManager>>#bridgeFrom:to: */
static NoDbgRegParms void
bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil)
{
    sqInt bridgeSpan;
    sqInt clifton;
    usqInt segEnd;

	segEnd = ((aSegment->segSize)) + ((aSegment->segStart));
	/* clifton is where the Avon bridge begins... */
	clifton = segEnd - (2 * BaseHeaderSize);
	bridgeSpan = (nextSegmentOrNil == null
		? 2 * BaseHeaderSize
		: (((nextSegmentOrNil->segStart)) - segEnd) + (2 * BaseHeaderSize));
	assert(bridgeSpan >= 0);
	initSegmentBridgeWithBytesat(bridgeSpan, clifton);
	assert((addressAfter(objectStartingAt(clifton))) == ((nextSegmentOrNil == null
		? segLimit(aSegment)
		: (nextSegmentOrNil->segStart))));
}

	/* SpurSegmentManager>>#checkSegments */
static void
checkSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(numSegments) >= 1);
	for (i = 0; i < GIV(numSegments); i += 1) {
		assert(addressCouldBeObj(((GIV(segments)[i]).segStart)));
		assert(isValidSegmentBridge(bridgeAt(i)));
	}
	assert(((segLimit(&GIV(segments)[GIV(numSegments) - 1])) - (bridgeSize())) == (endOfMemory()));
}


/*	The image has been loaded, old segments reconstructed, and the heap
	swizzled into a single contiguous segment. Collapse the segments into one. */

	/* SpurSegmentManager>>#collapseSegmentsPostSwizzle */
static void
collapseSegmentsPostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo *cascade0;

	GIV(canSwizzle) = 0;
	GIV(numSegments) = 1;
	/* begin computeTotalHeapSizeIncludingBridges */
	GIV(totalHeapSizeIncludingBridges) = (endOfMemory()) - (oldSpaceStart());
	cascade0 = (&(GIV(segments)[0]));
	(cascade0->segStart = oldSpaceStart());
	(cascade0->segSize = GIV(totalHeapSizeIncludingBridges));
	assert(isSegmentBridge(bridgeAt(0)));
	assert((numSlotsOfAny(bridgeAt(0))) == 0);
}


/*	Answer the segment limit of the first segment followed by a gap of at
	least size bytes.
 */

	/* SpurSegmentManager>>#firstGapOfSizeAtLeast: */
static NoDbgRegParms void *
firstGapOfSizeAtLeast(sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bridge;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i <= (GIV(numSegments) - 2); i += 1) {
		/* begin bridgeAt: */
		address = (((((&(GIV(segments)[i])))->segSize)) + ((((&(GIV(segments)[i])))->segStart))) - (2 * BaseHeaderSize);
		numSlots = byteAt(address + 7);
		bridge = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		if (((bytesInBody(bridge)) - (2 * BaseHeaderSize)) >= size) {
			return ((void *)((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart))));
		}
	}
	return ((void *)((((GIV(segments)[GIV(numSegments) - 1]).segSize)) + (((GIV(segments)[GIV(numSegments) - 1]).segStart))));
}

	/* SpurSegmentManager>>#isEmptySegment: */
static NoDbgRegParms sqInt
isEmptySegment(SpurSegmentInfo *seg)
{
    sqInt address;
    sqInt firstObj;
    usqInt numSlots;

	address = (seg->segStart);
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	firstObj = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	return (((longAt(firstObj)) & (classIndexMask())) == (isFreeObjectClassIndexPun()))
	 && ((addressAfter(firstObj)) == ((((seg->segSize)) + ((seg->segStart))) - (2 * BaseHeaderSize)));
}

	/* SpurSegmentManager>>#isInSegments: */
static NoDbgRegParms sqInt
isInSegments(usqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}


/*	bridges bridge the gaps between segments. They are the last object in each
	segment. 
 */

	/* SpurSegmentManager>>#isValidSegmentBridge: */
static NoDbgRegParms sqInt
isValidSegmentBridge(sqInt objOop)
{
	return ((addressCouldBeObj(objOop))
	 || (objOop == (endOfMemory())))
	 && ((((longAt(objOop)) & (classIndexMask())) == (segmentBridgePun()))
	 && (((byteAt(objOop + 7)) == (numSlotsMask()))
	 || ((numSlotsOfAny(objOop)) == 0)));
}


/*	Answer the the next non-empty segment or nil. The size of a segment
	includes that of its bridge. A segment containing just a free object and a
	bridge will still
	have a size of manager bridgeSize after shortening it in
	prepareForSnapshot. 
 */

	/* SpurSegmentManager>>#nextNonEmptySegmentAfter: */
static NoDbgRegParms SpurSegmentInfo *
nextNonEmptySegmentAfter(sqInt i)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nextx;

	nextx = i;
	while (1) {
		if (((nextx += 1)) >= GIV(numSegments)) {
			return null;
		}
		if ((((GIV(segments)[nextx]).segSize)) > (2 * BaseHeaderSize)) {
			return (&(GIV(segments)[nextx]));
		}
	}
	return 0;
}


/*	Restore all shortened segments to their proper size, re-freeing the
	trailing space.
 */

	/* SpurSegmentManager>>#postSnapshot */
static void
postSnapshot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bytes;
    usqInt freeChunk;
    sqInt i;
    sqInt newEndOfMemory;
    SpurSegmentInfo *seg;


	/* Set endOfMemory first, to avoid assert fails in freeChunkWithBytes:at:. */
	seg = (&(GIV(segments)[GIV(numSegments) - 1]));
	if (((seg->lastFreeObject)) == null) {
		assert((endOfMemory()) == ((segLimit(seg)) - (bridgeSize())));
	}
	else {
		newEndOfMemory = (((seg->savedSegSize)) + ((seg->segStart))) - (2 * BaseHeaderSize);
		/* begin setEndOfMemory: */
		GIV(endOfMemory) = newEndOfMemory;
		if (GIV(freeOldSpaceStart) > newEndOfMemory) {
			GIV(freeOldSpaceStart) = newEndOfMemory;
		}
	}
	for (i = (GIV(numSegments) - 1); i >= 0; i += -1) {
		seg = (&(GIV(segments)[i]));
		freeChunk = (seg->lastFreeObject);
		if (!(freeChunk == null)) {
			address = (((seg->segSize)) + ((seg->segStart))) - (2 * BaseHeaderSize);
			(seg->segSize = (seg->savedSegSize));
			bridgeFromto(seg, (i < (GIV(numSegments) - 1)
				? (&(GIV(segments)[i + 1]))
				: 0));
			bytes = ((((seg->segSize)) + ((seg->segStart))) - address) - (2 * BaseHeaderSize);
			/* begin addFreeChunkWithBytes:at: */
			GIV(totalFreeOldSpace) += bytes;
			freeChunkWithBytesat(bytes, address);
		}
	}
	checkSegments();
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
}


/*	shorten all segments by any trailing free space. */

	/* SpurSegmentManager>>#prepareForSnapshot */
static NeverInline void
prepareForSnapshot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    SpurSegmentInfo *cascade0;
    usqInt chunkBytes;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt freeChunk;
    sqInt i;
    sqInt largeChild;
    sqInt limit;
    sqInt newEndOfMemory;
    sqInt next;
    usqInt node;
    SpurSegmentInfo *seg;
    sqInt smallChild;
    sqInt treeNode;

	freeChunk = 0;
	checkSegments();
	for (i = 0; i < GIV(numSegments); i += 1) {
		cascade0 = (&(GIV(segments)[i]));
		(cascade0->savedSegSize = ((GIV(segments)[i]).segSize));
		(cascade0->lastFreeObject = null);
	}
	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		goto l2;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = longAt((treeNode + BaseHeaderSize) + (3U << (shiftForWord())));
		largeChild = longAt((treeNode + BaseHeaderSize) + (4U << (shiftForWord())));
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {
			node = treeNode;
			while (node != 0) {
				limit = endOfMemory();
				/* begin objectAfter:limit: */
				followingWordAddress = addressAfter(node);
				if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
					next = limit;
					goto l1;
				}
				flag("endianness");
				followingWord = longAt(followingWordAddress);
				next = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
				if (((longAt(next)) & (classIndexMask())) == (segmentBridgePun())) {
					seg = segmentContainingObj(node);
					(seg->lastFreeObject = node);
					node = 0;
				}
				else {
					node = longAt((node + BaseHeaderSize) + (0U << (shiftForWord())));
				}
			}
			cameFrom = treeNode;
			treeNode = longAt((treeNode + BaseHeaderSize) + (2U << (shiftForWord())));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
	l2:	/* end freeTreeNodesDo: */;
	for (i = 0; i < GIV(numSegments); i += 1) {
		freeChunk = ((GIV(segments)[i]).lastFreeObject);
		if (!(freeChunk == null)) {
			/* begin detachFreeObject: */
			chunkBytes = bytesInBody(freeChunk);
			GIV(totalFreeOldSpace) -= chunkBytes;
			unlinkFreeChunkchunkBytes(freeChunk, chunkBytes);
			((GIV(segments)[i]).segSize = ((/* begin startOfObject: */
	((byteAt(freeChunk + 7)) == (numSlotsMask())
	? freeChunk - BaseHeaderSize
	: freeChunk)) + (2 * BaseHeaderSize)) - (((GIV(segments)[i]).segStart)));
			bridgeFromto((&(GIV(segments)[i])), (i < (GIV(numSegments) - 1)
				? (&(GIV(segments)[i + 1]))
				: 0));
		}
	}
	newEndOfMemory = ((((GIV(segments)[GIV(numSegments) - 1]).segSize)) + (((GIV(segments)[GIV(numSegments) - 1]).segStart))) - (2 * BaseHeaderSize);
	/* begin setEndOfMemory: */
	GIV(endOfMemory) = newEndOfMemory;
	if (GIV(freeOldSpaceStart) > newEndOfMemory) {
		GIV(freeOldSpaceStart) = newEndOfMemory;
	}
}


/*	Read numBytes of image data from f into memory at memoryBaseForImageRead.
	Answer the number of bytes written. In addition, read each segment, build
	up the
	segment info for swizzling, while eliminating the bridge objects at the
	end of each
	segment that specify the distance to and the size of the subsequent
	segment.  */

	/* SpurSegmentManager>>#readHeapFromImageFile:dataBytes: */
static NoDbgRegParms sqInt
readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bridge;
    sqInt bridgehead;
    usqLong bridgeSpan;
    sqInt bytesRead;
    usqInt newBase;
    usqInt nextSegmentSize;
    sqInt oldBase;
    SpurSegmentInfo *segInfo;
    sqInt totalBytesRead;

	allocateOrExtendSegmentInfos();
	GIV(numSegments) = (totalBytesRead = 0);
	/* N.B. still must be adjusted by oldBaseAddr. */
	oldBase = 0;
	newBase = oldSpaceStart();
	nextSegmentSize = GIV(firstSegmentSize);
	bridgehead = (GIV(firstSegmentSize) + (oldSpaceStart())) - (2 * BaseHeaderSize);
	while (1) {
		segInfo = (&(GIV(segments)[GIV(numSegments)]));
		(segInfo->segStart = oldBase);
		(segInfo->segSize = nextSegmentSize);
		(segInfo->swizzle = newBase - oldBase);
		bytesRead = sqImageFileRead(pointerForOop(newBase), sizeof(char), nextSegmentSize, f);
		if (bytesRead > 0) {
			totalBytesRead += bytesRead;
		}
		if (bytesRead != nextSegmentSize) {
			return totalBytesRead;
		}
		if (((GIV(numSegments) += 1)) >= GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		bridge = bridgehead + BaseHeaderSize;
		bridgeSpan = ((byteAt(bridgehead + 7)) == 0
			? 0
			: BytesPerOop * (((((usqInt)(((sqInt)((usqInt)((longAt(bridge - BaseHeaderSize))) << 8)))))) >> 8));
		oldBase = (oldBase + nextSegmentSize) + bridgeSpan;
		newBase = (newBase + nextSegmentSize) - (2 * BaseHeaderSize);
		nextSegmentSize = ((usqInt)(long64At(bridge)));
		if (!(nextSegmentSize != 0)) break;
		bridgehead = (bridgehead - (2 * BaseHeaderSize)) + nextSegmentSize;
	}
	assert((newBase - (oldSpaceStart())) == (totalBytesRead - (GIV(numSegments) * (bridgeSize()))));
	/* begin setFreeOldSpaceStart: */
	GIV(freeOldSpaceStart) = newBase;
	GIV(firstSegmentSize) = null;
	return totalBytesRead;
}


/*	Answer the segment containing an object. This is mostly for assert
	checking, but
	variations on the incremental GC may use it in anger. Binary search is (of
	course) marginally slower than linear search for a single segment (e.g. in
	a 720k object heap,
	67.1ms vs 61.3ms, or 9.5% slower to derive the segment containing every
	old space
	entity), but usefully faster for many segments (e.g. 92.7ms vs 116ms, or
	20% faster
	in the same heap extended with enough large arrays to require 11 segments;
	and this
	is pessimal; there are fewer objects at high addresses since the large
	arrays are there). */

	/* SpurSegmentManager>>#segmentContainingObj: */
SpurSegmentInfo *
segmentContainingObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt high;
    sqInt low;
    sqInt mid;
    SpurSegmentInfo *seg;

	low = 0;
	mid = GIV(numSegments) / 2;
	high = GIV(numSegments) - 1;
	do {
		seg = (&(GIV(segments)[mid]));
		if (oopisGreaterThanOrEqualTo(objOop, (seg->segStart))) {
			if (mid == high) {
				return (oopisLessThan(objOop, ((seg->segSize)) + ((seg->segStart)))
					? seg
					: 0);
			}
			else {
				low = mid;
				mid = ((mid + high) + 1) / 2;
			}
		}
		else {
			high = mid - 1;
			mid = (low + mid) / 2;
		}
	} while(low <= high);
	return null;
}


/*	Answers true if a segment overlaps with another one. */

	/* SpurSegmentManager>>#segmentOverlap */
static sqInt
segmentOverlap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endi;
    usqInt endj;
    sqInt i;
    sqInt j;
    usqInt starti;
    usqInt startj;

	for (i = 0; i < GIV(numSegments); i += 1) {
		starti = ((GIV(segments)[i]).segStart);
		endi = (((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart));
		for (j = 0; j < GIV(numSegments); j += 1) {
			startj = ((GIV(segments)[j]).segStart);
			endj = (((GIV(segments)[j]).segSize)) + (((GIV(segments)[j]).segStart));
			if (!(i == j)) {
				if (!((starti < startj)
					 || (starti >= endj))) {
					return 1;
				}
				if (!((endi <= startj)
					 || (endi >= endj))) {
					return 1;
				}
			}
		}
	}
	return 0;
}


/*	Answer if any shrinkage was achieved. */

	/* SpurSegmentManager>>#shrinkObjectMemory: */
static NoDbgRegParms int
shrinkObjectMemory(usqInt delta)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    SpurSegmentInfo *best;
    usqInt chunkBytes;
    usqInt currentEnd;
    sqInt delta1;
    SpurSegmentInfo *emptySeg;
    sqInt freeChunk;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt j;
    usqInt numSlots;
    SpurSegmentInfo *seg;
    SpurSegmentInfo *segInfo;
    usqInt shrinkage;


	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCCheckFreeSpace)) == (GCCheckFreeSpace | GCCheckFreeSpace))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	shrinkage = delta;
	while (1) {
		/* begin findEmptySegNearestInSizeTo: */
		best = null;
		delta1 = shrinkage;
		for (i = 0; i < GIV(numSegments); i += 1) {
			seg = (&(GIV(segments)[i]));
			if (isEmptySegment(seg)) {
				if (best == null) {
					best = seg;
				}
				else {
					if ((shrinkage >= (((seg->segSize)) * 0.75))
					 && ((SQABS((((sqInt) (((seg->segSize)) - shrinkage))))) < delta1)) {
						best = seg;
						delta1 = SQABS((((sqInt) (((seg->segSize)) - shrinkage))));
					}
				}
			}
		}
		emptySeg = best;
		if ((!emptySeg)
		 || (((emptySeg->segSize)) > shrinkage)) {
			/* begin checkFreeSpace: */
			assert(bitsSetInFreeSpaceMaskForAllFreeLists());
			assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
			if (((checkForLeaks & (GCCheckFreeSpace | GCCheckFreeSpace)) == (GCCheckFreeSpace | GCCheckFreeSpace))) {
				runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
			}
			return shrinkage < delta;
		}
		shrinkage -= (emptySeg->segSize);
		address = (emptySeg->segStart);
		/* begin objectStartingAt: */
		numSlots = byteAt(address + 7);
		freeChunk = (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		/* begin detachFreeObject: */
		chunkBytes = bytesInBody(freeChunk);
		GIV(totalFreeOldSpace) -= chunkBytes;
		unlinkFreeChunkchunkBytes(freeChunk, chunkBytes);
		/* begin removeSegment: */
		i2 = 0;
		for (i1 = 0; i1 < GIV(numSegments); i1 += 1) {
			if (((emptySeg->segStart)) == (((GIV(segments)[i1]).segStart))) {
				i2 = i1;
				goto l3;
			}
		}
		error("segment not found");
	l3:	/* end indexOfSegment: */;
		assert(i2 > 0);
		GIV(totalHeapSizeIncludingBridges) -= (emptySeg->segSize);
		sqDeallocateMemorySegmentAtOfSize(((void *)((emptySeg->segStart))), (emptySeg->segSize));
		for (j = i2; j <= (GIV(numSegments) - 2); j += 1) {
			GIV(segments)[j] = (GIV(segments)[j + 1]);
		}
		GIV(numSegments) -= 1;
		bridgeFromto((&(GIV(segments)[i2 - 1])), (i2 <= (GIV(numSegments) - 1)
			? (&(GIV(segments)[i2]))
			: 0));
		segInfo = (&(GIV(segments)[GIV(numSegments) - 1]));
		/* begin setLastSegment: */
		currentEnd = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * BaseHeaderSize);
		if (currentEnd <= GIV(endOfMemory)) {
			GIV(endOfMemory) = currentEnd;
			if (GIV(freeOldSpaceStart) > currentEnd) {
				GIV(freeOldSpaceStart) = currentEnd;
			}
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#someSegmentContainsPinned */
static sqInt
someSegmentContainsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (((GIV(segments)[i]).containsPinned)) {
			return 1;
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#swizzleObj: */
static NoDbgRegParms sqInt
swizzleObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(canSwizzle));
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}


/*	This ``slow'' count is for asserts only. */

	/* SpurSegmentManager>>#totalBytesInSegments */
static usqInt
totalBytesInSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt total;

	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	return total;
}

	/* SpurSegmentManager>>#writeImageSegmentsToFile: */
static NoDbgRegParms sqInt
writeImageSegmentsToFile(sqImageFile aBinaryStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt total;

	assert(((endOfMemory()) == (segLimit(&GIV(segments)[GIV(numSegments) - 1])))
	 || (((endOfMemory()) + (bridgeSize())) == (segLimit(&GIV(segments)[GIV(numSegments) - 1]))));
	if (!(GIV(firstSegmentSize) == null)) {
		assert(GIV(firstSegmentSize) == (((GIV(segments)[0]).segSize)));
	}
	assert((((GIV(segments)[0]).segSize)) > 0);
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		if ((((GIV(segments)[i]).segSize)) > (2 * BaseHeaderSize)) {
			total += writeSegmentnextSegmenttoFile((&(GIV(segments)[i])), nextNonEmptySegmentAfter(i), aBinaryStream);
		}
	}
	return total;
}


/*	Write the segment contents, the size of and the distance to the next
	segment to aBinaryStream.
 */

	/* SpurSegmentManager>>#writeSegment:nextSegment:toFile: */
static NoDbgRegParms sqInt
writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream)
{
    usqLong firstSavedBridgeWord;
    sqInt nWritten;
    sqInt pier1;
    sqInt pier2;
    usqLong secondSavedBridgeWord;

	pier1 = (((segment->segSize)) + ((segment->segStart))) - (2 * BaseHeaderSize);
	pier2 = pier1 + BaseHeaderSize;
	assert(isValidSegmentBridge(bridgeFor(segment)));
	assert((startOfObject(bridgeFor(segment))) == pier1);
	firstSavedBridgeWord = long64At(pier1);
	secondSavedBridgeWord = long64At(pier2);
	bridgeFromto(segment, nextSegment);
	long64Atput(pier2, (nextSegment == null
		? 0
		: (nextSegment->segSize)));
	nWritten = sqImageFileWrite(((void *)((segment->segStart))), 1, (segment->segSize), aBinaryStream);
	long64Atput(pier1, firstSavedBridgeWord);
	long64Atput(pier2, secondSavedBridgeWord);
	return nWritten;
}

	/* StackInterpreter>>#accessorDepthForPrimitiveMethod: */
sqInt
accessorDepthForPrimitiveMethod(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt flags;
    sqInt header;
    sqInt lit;
    sqInt methodHeader;
    sqInt primIndex;

	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(aMethodObj));
	header = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	primIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (aMethodObj + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	if ((primIndex == PrimNumberExternalCall)
	 && (isLinkedExternalPrimitive(aMethodObj))) {
		/* begin accessorDepthForExternalPrimitiveMethod: */
		assert(isLinkedExternalPrimitive(aMethodObj));
		lit = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		flags = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))));
		return (((flags >> 3))) >> SpurPrimitiveAccessorDepthShift;
	}
	else {
		return ((sqInt)((primitiveMetadataTable[primIndex]))) >> SpurPrimitiveAccessorDepthShift;
	}
}


/*	Answer the current activeProcess. */
/*	useful for VM debugging */

	/* StackInterpreter>>#activeProcess */
sqInt
activeProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	/* begin fetchPointer:ofObject: */
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
}


/*	The various poll/select calls in the VM should attempt to tally the
	ammount of time spent at idle here, so as to render the uptime value
	meaningful. 
 */

	/* StackInterpreter>>#addIdleUsecs: */
void
addIdleUsecs(sqInt idleUsecs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(statIdleUsecs) += idleUsecs;
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

	/* StackInterpreter>>#addLastLink:toList: */
static NoDbgRegParms void
addLastLinktoList(sqInt proc, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert(!((isForwarded(proc))));
	assert(!((isForwarded(aList))));
	assert((fetchPointerofObject(NextLinkIndex, proc)) == (nilObject()));
	if ((	/* begin isEmptyList: */
		assert(!(isForwarded(aList))),
	(longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(aList)),
		oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(proc & (tagMask()))))
			 && (oopisLessThan(proc, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(aList)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aList);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))), proc);
	}
	else {
		lastLink = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))));
		assert(lastLink != proc);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(lastLink)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(lastLink)),
		oopisGreaterThanOrEqualTo(lastLink, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(proc & (tagMask()))))
			 && (oopisLessThan(proc, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(lastLink)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(lastLink);
				}
			}
		}
		longAtput((lastLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))), proc);
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(aList)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(aList)),
	oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(proc & (tagMask()))))
		 && (oopisLessThan(proc, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(aList)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(aList);
			}
		}
	}
	longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))), proc);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(proc)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(proc)),
	oopisGreaterThanOrEqualTo(proc, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(aList & (tagMask()))))
		 && (oopisLessThan(aList, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(proc)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(proc);
			}
		}
	}
	longAtput((proc + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))), aList);
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static NoDbgRegParms sqInt
addressCouldBeClassObj(sqInt maybeClassObj)
{
	return (addressCouldBeObj(maybeClassObj))
	 && (objCouldBeClassObj(maybeClassObj));
}

	/* StackInterpreter>>#allOnesAsCharStar */
static char *
allOnesAsCharStar(void)
{
	return ((char *) (((usqInt) -1)));
}


/*	for Cogit */

	/* StackInterpreter>>#argumentCountOfClosure: */
sqInt
argumentCountOfClosure(sqInt closurePointer)
{
    sqInt oop;


	/* begin quickFetchInteger:ofObject: */
	oop = longAt((closurePointer + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	return (oop >> 3);
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
sqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
sqInt
argumentCountOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	header1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin argumentCountOfMethodHeader: */
	return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#arrayValueOf: */
void *
arrayValueOf(sqInt arrayOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (	/* begin isWordsOrBytes: */
		((!(arrayOop & (tagMask()))))
	 && (isWordsOrBytesNonImm(arrayOop))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Returns an integer object */

	/* StackInterpreter>>#asciiOfCharacter: */
static NoDbgRegParms sqInt
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (((characterObj & (characterTag())) != 0)) {
		return characterObj - ((characterTag()) - (smallIntegerTag()));
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	return ConstZero;
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s: */
void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp)
{
	assertValidExecutionPointersimbarline(lip, lifp, lisp, !((((usqInt)(longAt(lifp + FoxMethod)))) < (startOfMemory())), __LINE__);
}


/*	Order in the stackLimit checks is important because stackLimit is smashed
	by interrupts. So always check for unsmashed value first to avoid race
	condition. 
 */

	/* StackInterpreter>>#assertValidStackLimits: */
static NoDbgRegParms void
assertValidStackLimits(sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertl((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (allOnesAsCharStar())), ln);
	assertl((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (allOnesAsCharStar())), ln);
}


/*	convert true and false (Smalltalk) to true or false(C) */

	/* StackInterpreter>>#booleanValueOf: */
sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin success: */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	};
	return null;
}


/*	Re-enter the interpreter to execute a (non-Alien) callback. */

	/* StackInterpreter>>#callbackEnter: */
sqInt
callbackEnter(sqInt *callbackID)
{
	warning("callbackEnter: is obsolete");
	return 0;
}


/*	Leave from a previous callback */

	/* StackInterpreter>>#callbackLeave: */
sqInt
callbackLeave(sqInt cbID)
{
	warning("callbackLeave: is obsolete");
	return 0;
}


/*	Context switch should not be allowed on every method activation. In
	particular the
	implementation of ensure: and ifCurtailed: depends on there being no
	suspension point
	on failing primitive 198 (primitiveMarkUnwindMethod,
	primitiveMarkUnwindMethod). slowPrimitiveResponse used to state
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod and
	PrimNumberNoContextSwitch.  */

	/* StackInterpreter>>#canContextSwitchIfActivating:header: */
sqInt
canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;
    sqInt primitiveIndex;

	primitiveIndex = 
	/* begin primitiveIndexOfMethod:header: */
(((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	return (primitiveIndex != PrimNumberUnwindMarker)
			 && (primitiveIndex != PrimNumberNoContextSwitchMarker);
}


/*	Above ObjectMemory, arg must lie in range 0-255! */

	/* StackInterpreter>>#characterForAscii: */
sqInt
characterForAscii(sqInt ascii)
{
	return (((sqInt)((usqInt)(ascii) << (numTagBits())))) + (characterTag());
}


/*	Ensure that all accessible objects in the heap are okay. */
/*	useful for VM debugging */

	/* StackInterpreter>>#checkAllAccessibleObjectsOkay */
sqInt
checkAllAccessibleObjectsOkay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt followingWord;
    usqInt followingWordAddress;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt ok;
    sqInt oop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	oop = 0;
	ok = 1;
	/* begin allObjectsDoSafely: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots = byteAt(address + 7);
	startObject = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if (((longAt(obj)) & (classIndexMask())) > (lastClassIndexPun())) {
			ok = ok && (checkOkayFields(obj));
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	return ok;
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

	/* StackInterpreter>>#checkDeliveryOfLongRunningPrimitiveSignal */
#if LRPCheck
static NeverInline sqInt
checkDeliveryOfLongRunningPrimitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore))
	 && (GIV(longRunningPrimitiveSignalUndelivered)))) {
		/* but not yet delivered */
		GIV(longRunningPrimitiveSignalUndelivered) = 0;
		/* Signal the LRP check semaphore if it is present */
		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
		 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
			? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
			: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore));
	}
	return 0;
}
#endif /* LRPCheck */


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#checkedIntegerValueOf: */
sqInt
checkedIntegerValueOf(sqInt intOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((intOop) & 7) == 1)) {
		return (intOop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

	/* StackInterpreter>>#checkForEventsMayContextSwitch: */
static NoDbgRegParms sqInt
checkForEventsMayContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt now1;
    sqInt objOop;
    sqInt sema;
    sqInt switched;


	/* restore the stackLimit if it has been smashed. */
	GIV(statCheckForEvents) += 1;
	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	ioSynchronousCheckForEvents();
	/* begin checkCogCompiledCodeCompactionCalledFor */
	if (GIV(cogCompiledCodeCompactionCalledFor)) {
		commenceCogCompiledCodeCompaction();
	}
	if (GIV(needGCFlag)) {
		/* sufficientSpaceAfterGC: runs the incremental GC and
		   then, if not enough space is available, the fullGC. */
		if (!(sufficientSpaceAfterGC(0))) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
	}
	if (!mayContextSwitch) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
	 && ((ioHighResClock()) >= GIV(nextProfileTick)))) {
		/* begin zeroNextProfileTick */
		GIV(nextProfileTick) = 0;
		if (GIV(profileProcess) == GIV(nilObj)) {
			/* begin activeProcess */
			objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
			GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore)))) {
			switched = 1;
		}
	}
#  if LRPCheck
	if (checkDeliveryOfLongRunningPrimitiveSignal()) {
		switched = 1;
	}
#  endif

	if (GIV(signalLowSpace)) {
		/* begin signalLowSpace: */
		GIV(signalLowSpace) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	now1 = (now = ioUTCMicroseconds());
	/* begin checkInvokeIOProcessEvents: */
	if (now1 >= GIV(nextPollUsecs)) {
		GIV(statIOProcessEvents) += 1;
		ioProcessEvents();
		/* msecs to wait before next call to ioProcessEvents.  Note that strictly
		   speaking we might need to update 'now' at this point since
		   ioProcessEvents could take a very long time on some platforms */
		GIV(nextPollUsecs) = now1 + 20000;
	}
	if (GIV(interruptPending)) {
		/* reset interrupt flag */
		GIV(interruptPending) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs) != 0) {
		if (now >= GIV(nextWakeupUsecs)) {
			/* set timer interrupt to 0 for 'no timer' */
			GIV(nextWakeupUsecs) = 0;
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		GIV(pendingFinalizationSignals) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheFinalizationSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (signalExternalSemaphores()) {
		switched = 1;
	}
	return switched;
}


/*	Support for embedded images. Check that the first few bytes of a potential
	header and answer if it
	looks like something the VM can load,
	The method checks the first three fields of the header (magic, header size
	& data size) & the total size.
	The magic number should be correct.
	The header size should be correct.
	The size of the data should be at least as long as the headerSize plus the
	data size in the header */
/*	Need at least headerSize bytes; no point going further if not... */

	/* StackInterpreter>>#checkImageHeaderFromBytes:AndSize: */
sqInt
checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize)
{
    sqInt dataSize;
    sqInt headerSize;
    int version;

	if (totalSize < (BytesPerWord * 16)) {
		return 0;
	}
	version = long32At(bytes);
	headerSize = long32At(bytes + 4);
	dataSize = longAt(bytes + 8);
	if (!((((version | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */)) {
		if (!(((((SQ_SWAP_4_BYTES(version)) | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */)) {
			return 0;
		}
		headerSize = SQ_SWAP_8_BYTES(headerSize);
		dataSize = SQ_SWAP_8_BYTES(dataSize);
	}
	return (headerSize == (BytesPerWord * 16))
	 && (totalSize >= (headerSize + dataSize));
}


/*	Read and verify the image file version number and answer it.
	Assign through rawVersionPtr the unswapped version number. The caller can
	then infer if the given image file needs to be byte-swapped by seeing if
	the returned value
	equals tha assigned through rawVersionPtr.
	0 is answered if no valid version could be found. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt:assignRawVersion: */
static NoDbgRegParms sqInt
checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr)
{
    sqInt version;
    int w;
    int w1;
    int w2;
    int w3;


	/* check the version number */
	sqImageFileSeek(f, imageOffset);
	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	version = w;
	rawVersionPtr[0] = version;
	if ((((version | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */) {
		return version;
	}
	sqImageFileSeek(f, imageOffset);
	/* begin getWord32FromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(int), 1, f);
	version = SQ_SWAP_4_BYTES(w1);
	if ((((version | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */) {
		return version;
	}
	if (imageOffset == 0) {
		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 0x200);
		/* begin getWord32FromFile:swap: */
		w2 = 0;
		sqImageFileRead((&w2), sizeof(int), 1, f);
		version = w2;
		rawVersionPtr[0] = version;
		if ((((version | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */) {
			return version;
		}
		sqImageFileSeek(f, 0x200);
		/* begin getWord32FromFile:swap: */
		w3 = 0;
		sqImageFileRead((&w3), sizeof(int), 1, f);
		version = SQ_SWAP_4_BYTES(w3);
		if ((((version | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */) {
			return version;
		}
	}
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer 0 if all checks pass. */

	/* StackInterpreter>>#checkInterpreterIntegrity */
static sqInt
checkInterpreterIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;

	flags = 0;
	if (!(checkOopIntegritynamed(specialObjectsOop(), "specialObjectsOop"))) {
		flags = 1;
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod"))) {
		flags += 2;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess"))) {
		flags += 4;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod"))) {
		flags += 8;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore"))) {
		flags += 16;
	}
	if (!(GIV(tempOop) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop"))) {
			flags += 32;
		}
	}
	if (!(GIV(tempOop2) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop2), "tempOop2"))) {
			flags += 64;
		}
	}
	if (!(checkLogIntegrity())) {
		flags += 128;
	}
	return flags;
}


/*	Another version of isWidowedContext: for debugging.
	This will not bereave a widowed context. */

	/* StackInterpreter>>#checkIsStillMarriedContext:currentFP: */
static NoDbgRegParms sqInt
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *limitFP;
    char *maybeFP;
    sqInt maybeFrameCtxt;
    sqInt referent;
    sqInt senderOop;
    StackPage *thePage;

	if (!((		/* begin isContext: */
			((!(aContext & (tagMask()))))
		 && (((longAt(aContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)))) {
		return 0;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	maybeFP = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) maybeFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) maybeFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(maybeFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	limitFP = ((thePage == GIV(stackPage))
	 && (currentFP)
		? currentFP
		: (thePage->headFP));
	if (!((maybeFP >= limitFP)
		 && (((!((((sqInt)(pointerForOop(longAt(maybeFP + FoxSavedFP))))) & (tagMask()))))
		 && ((((		/* begin withSmallIntegerTags: */
			assert(((oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) & (BytesPerWord - 1)) == 0),
		(oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) + (smallIntegerTag()))) == (longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))))))
		 && (		/* begin frameHasContext: */
			((((usqInt)(longAt(maybeFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(maybeFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((maybeFP + FoxIFrameFlags) + 2)) != 0)))))) {
		return 0;
	}
	/* On Spur we need to follow the context to check for a match, but since the VM is
	   only speculating about maybeFrame being a frame, and only speculating about
	   maybeContext being a context, we need to be sure before we can safely follow. */
	maybeFrameCtxt = longAt(maybeFP + FoxThisContext);
	if ((!(isFree(thePage)))
	 && ((isFrameonPage(maybeFP, thePage))
	 && ((!((longAt(maybeFrameCtxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(maybeFrameCtxt));
		referent = longAt((maybeFrameCtxt + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		maybeFrameCtxt = referent;
	}
	return maybeFrameCtxt == aContext;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#checkOkayInterpreterObjects: */
sqInt
checkOkayInterpreterObjects(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt ok;
    sqInt oop;
    sqIntptr_t oopOrZero;

	ok = 1;
	ok = ok && (checkOkayFields(GIV(nilObj)));
	ok = ok && (checkOkayFields(GIV(falseObj)));
	ok = ok && (checkOkayFields(GIV(trueObj)));
	ok = ok && (checkOkayFields(specialObjectsOop()));
	ok = ok && (checkOkayFields(GIV(messageSelector)));
	ok = ok && (checkOkayFields(GIV(newMethod)));
	ok = ok && (checkOkayFields(GIV(lkupClass)));
	for (i = 0; i < MethodCacheEntries; i += MethodCacheEntrySize) {
		oopOrZero = GIV(methodCache)[i + MethodCacheSelector];
		if (!(oopOrZero == 0)) {
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheSelector]));
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheMethod]));
		}
	}
	for (i = 1, iLimiT = (remapBufferCount()); i <= iLimiT; i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!(((oop & (tagMask())) != 0))) {
			ok = ok && (checkOkayFields(oop));
		}
	}
	ok = ok && (checkOkayStackZone(writeBack));
	return ok;
}

	/* StackInterpreter>>#checkOkayStackPage: */
static NoDbgRegParms sqInt
checkOkayStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt ok;
    sqInt oop;
    char *theFP;
    char *theSP;

	theSP = (thePage->headSP);
	theFP = (thePage->headFP);
	/* Skip the instruction pointer on top of stack of inactive pages. */
	ok = 1;
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = 
		/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? theFP + FoxMFReceiver
			: theFP + FoxIFReceiver);
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((((oop) & 7) == 1))) {
				ok = ok && (checkOkayFields(oop));
			}
			theSP += BytesPerWord;
		}
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			ok = ok && (checkOkayFields(longAt(theFP + FoxThisContext)));
		}
		ok = ok && (checkOkayFields(		/* begin frameMethodObject: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((mframeHomeMethod(theFP))->methodObject)
			: longAt(theFP + FoxMethod))));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}
	/* caller ip is frameCallerContext in a base frame */
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((((oop) & 7) == 1))) {
			ok = ok && (checkOkayFields(oop));
		}
		theSP += BytesPerWord;
	}
	return ok;
}


/*	Check that all objects in the stack zone are okay */

	/* StackInterpreter>>#checkOkayStackZone: */
static NoDbgRegParms sqInt
checkOkayStackZone(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;
    StackPage *thePage;

	if (writeBack) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			ok = ok && (checkOkayStackPage(thePage));
		}
	}
	return ok;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

	/* StackInterpreter>>#checkProfileTick: */
static NoDbgRegParms void
checkProfileTick(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;

	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock()) >= GIV(nextProfileTick)) {
		/* begin activeProcess */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		GIV(profileProcess) = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		GIV(profileMethod) = (GIV(primFailCode)
			? GIV(nilObj)
			: aPrimitiveMethod);
		forceInterruptCheck();
		/* begin zeroNextProfileTick */
		GIV(nextProfileTick) = 0;
	}
}


/*	Version of stackPointerForMaybeMarriedContext: with no side-effects (does
	not widow).
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the stackPointer of a Context. */

	/* StackInterpreter>>#checkStackPointerForMaybeMarriedContext: */
static NoDbgRegParms sqInt
checkStackPointerForMaybeMarriedContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;
    sqInt methodPointer;
    sqInt sp;
    sqInt sp1;

	if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
		sp = checkStackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext)));
		return sp;
	}
	if (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		/* begin argumentCountOf: */
		methodPointer = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(methodPointer));
		header1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		header = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		/* begin argumentCountOfMethodHeader: */
		return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
	}
	sp1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((((sp1) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
	return (sp1 >> 3);
}


/*	Version of stackPointerIndexForFrame: that does not depend on writing back
	head frame pointers.
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#checkStackPointerIndexForFrame: */
static NoDbgRegParms sqInt
checkStackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (theFP == GIV(framePointer)) {
		/* begin stackPointerIndexForFrame:WithSP: */
		if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
			return (((usqInt)(((theFP + FoxMFReceiver) - GIV(stackPointer)))) >> (shiftForWord())) + (((mframeCogMethod(theFP))->cmNumArgs));
		}
		else {
			return (((usqInt)(((theFP + FoxIFReceiver) - GIV(stackPointer)))) >> (shiftForWord())) + (byteAt((theFP + FoxIFrameFlags) + 1));
		}
	}
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	startFrame = (thePage == GIV(stackPage)
		? GIV(framePointer)
		: (thePage->headFP));
	/* begin findSPOrNilOf:on:startingFrom: */
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {
			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = 
			/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? theFP + FoxMFReceiver
				: theFP + FoxIFReceiver);
			goto l2;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l2;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + (frameStackedReceiverOffset(prevFrame))) + BytesPerWord;
			goto l2;
		}
	}
	theSP = null;
	l2:	/* end findSPOrNilOf:on:startingFrom: */;
	if (!theSP) {
		return -1;
	}
	/* begin stackPointerIndexForFrame:WithSP: */
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		return (((usqInt)(((theFP + FoxMFReceiver) - theSP))) >> (shiftForWord())) + (((mframeCogMethod(theFP))->cmNumArgs));
	}
	else {
		return (((usqInt)(((theFP + FoxIFReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxIFrameFlags) + 1));
	}
}


/*	Check if aClass's name is className */

	/* StackInterpreter>>#classNameOf:Is: */
static NoDbgRegParms sqInt
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt i;
    sqInt length;
    sqInt name;
    usqInt numSlots;
    usqInt numSlots1;
    char *srcName;

	if (((	/* begin numSlotsOf: */
		assert((classIndexOf(aClass)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(aClass + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(aClass - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))));
	if (!(		/* begin isBytes: */
			((!(name & (tagMask()))))
		 && (((((usqInt)((longAt(name)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(name)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	length = (((/* begin numSlotsOf: */
	assert((classIndexOf(name)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(name + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(name - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt & 7);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i < length; i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}


/*	Does thisCntx have aContext in its sender chain?
	Cheapo implementation above extant machinery. */

	/* StackInterpreter>>#context:hasSender: */
static NoDbgRegParms int
contexthasSender(sqInt thisCntx, sqInt aContext)
{
    sqInt handlerOrNilOrZero;

	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCntx, aContext);
	return handlerOrNilOrZero == 0;
}


/*	For asserts. Check that theIP maps back correctly to the context's pc.
	The CallPrimitive bytecode presents a complication. */

	/* StackInterpreter>>#context:hasValidInversePCMappingOf:in: */
static NoDbgRegParms sqInt
contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP)
{
    sqInt encodedip;
    sqInt methodHeader;
    sqInt pc;

	pc = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	encodedip = contextInstructionPointerframe(theIP, theFP);
	return (pc == encodedip)
		 || (((methodHeader = methodHeaderOf(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord()))))))),
		(((methodHeader & AlternateHeaderHasPrimFlag) != 0))
			 && ((((encodedip >> 3)) - ((pc >> 3))) == 3 /* begin sizeOfCallPrimitiveBytecode: */)));
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfClosure: */
usqInt
copiedValueCountOfClosure(sqInt closureObj)
{
    usqInt numSlots;
    usqInt numSlots1;

	return (((((longAt((closureObj + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1)
		? (			/* begin copiedValueCountOfVanillaClosure: */
				assert(isVanillaBlockClosure(closureObj)),
			((/* begin numSlotsOf: */
	assert((classIndexOf(closureObj)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(closureObj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(closureObj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - ClosureFirstCopiedValueIndex)
		: (			/* begin copiedValueCountOfFullClosure: */
				assert(!((isVanillaBlockClosure(closureObj)))),
			((/* begin numSlotsOf: */
	assert((classIndexOf(closureObj)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(closureObj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(closureObj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) - FullClosureFirstCopiedValueIndex));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

	/* StackInterpreter>>#copyBits */
sqInt
copyBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#copyBitsFrom:to:at: */
sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}

	/* StackInterpreter>>#couldBeProcess: */
static NoDbgRegParms NeverInline sqInt
couldBeProcess(sqInt oop)
{
	return (addressCouldBeObj(oop))
	 && ((((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
	 && ((!(	/* begin isContext: */
		((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)))
	 && (((lengthOf(oop)) > MyListIndex)
	 && (isContext(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord()))))))))));
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

	/* StackInterpreter>>#createActualMessageTo: */
static NoDbgRegParms void
createActualMessageTo(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt argumentArray;
    sqInt i;
    usqInt message;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    sqInt numSlots;
    sqInt objFormat;
    char *sp;


	/* This is a useful break-point */
	assert((isImmediate(GIV(messageSelector)))
	 || (addressCouldBeObj(GIV(messageSelector))));
	/* begin mnuBreakpoint:receiver: */
	mnuBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), null);
	objFormat = arrayFormat();
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && ((knownClassAtIndex(ClassArrayCompactIndex)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(GIV(argumentCount) < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((GIV(argumentCount) < 1
	? 8 /* begin allocationUnit */
	: GIV(argumentCount) * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			argumentArray = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) GIV(argumentCount))) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassArrayCompactIndex);
	GIV(freeStart) += numBytes;
	argumentArray = newObj;
	l1:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	numSlots = MessageLookupClassIndex + 1;
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassMessageCompactIndex)) != GIV(nilObj)));
	assert((1 /* begin nonIndexablePointerFormat */) == (instSpecOfClass(knownClassAtIndex(ClassMessageCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj1 = GIV(freeStart);
	numBytes1 = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes1 % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes1) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			message = 0;
			goto l2;
		}
	}
	long64Atput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (1U << (formatShift()))) + ClassMessageCompactIndex);
	GIV(freeStart) += numBytes1;
	message = newObj1;
	l2:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	for (i = ((GIV(argumentCount) - 1) * BytesPerOop); i >= 0; i += (-BytesPerOop)) {
		longAtput((argumentArray + BaseHeaderSize) + i, popStack());
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(message)));
	longAtput((message + BaseHeaderSize) + (((sqInt)((usqInt)(MessageSelectorIndex) << (shiftForWord())))), GIV(messageSelector));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(message)));
	longAtput((message + BaseHeaderSize) + (((sqInt)((usqInt)(MessageArgumentsIndex) << (shiftForWord())))), argumentArray);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(message)));
	longAtput((message + BaseHeaderSize) + (((sqInt)((usqInt)(MessageLookupClassIndex) << (shiftForWord())))), lookupClass);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}


/*	Return the default number of stack pages allocate at startup.
	This V3 default suits Qwaq Forums (specifically general rendering).
	The Spur default reflects tuning for GC performance ast Cadence.
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

	/* StackInterpreter>>#defaultNumStackPages */
static sqInt
defaultNumStackPages(void)
{
	return 50;
}


/*	Release the VM to other threads and answer the current thread's index.
	Currently valid flags for the non-threaded VM are:
	DisownVMForThreading	- allow the VM to thread-switch; this is ignored
	DisownVMForFFICall		- informs the VM that it is entering an FFI call
	
	This is the entry-point for plugins and primitives that wish to release
	the VM while
	performing some operation that may potentially block, and for callbacks
	returning back to some blocking operation. While this exists for the
	threaded FFI VM we use
	it to reset newMethod and the argumentCount after a callback. */

	/* StackInterpreter>>#disownVM: */
void *
disownVM(sqInt flags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;
    void *vmHandle;

	assert(GIV(primFailCode) == 0);
	assert(flags != 0);
	/* We are either in disowning after a callback (see thunkEntry) or before an FFI
	   callout. */
	vmHandle = ((void *) flags);
	assert((flags == DisownVMFromCallback)
	 || ((flags == (flags & (DisownVMForFFICall + DisownVMForThreading)))
	 && (((flags & DisownVMForFFICall) != 0))));
	if (((flags & DisownVMForFFICall) != 0)) {
		assert((isOopCompiledMethod(GIV(newMethod)))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
		return (GIV(ffiCalloutVMHandle) = vmHandle);
	}
	if (((flags & DisownVMFromCallback) != 0)) {
		GIV(argumentCount) = ((popStack()) >> 3);
		assert(((GIV(argumentCount) >= 0) && (GIV(argumentCount) <= (argumentCountOfMethodHeader(-1)))));
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		assert((isOopCompiledMethod(GIV(newMethod)))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
		return null;
	}
	return vmHandle;
}

	/* StackInterpreter>>#divorceAllFrames */
static sqInt
divorceAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;

	if (!(GIV(stackPage) == null)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? ((longAt(GIV(framePointer) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((GIV(framePointer) + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
	l1:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			divorceFramesIn(aPage);
		}
	}
	/* begin nilStackPage */
	assert((!GIV(stackPage))
	 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
	GIV(stackPage) = null;
	return activeContext;
}

	/* StackInterpreter>>#divorceFramesIn: */
static NoDbgRegParms void
divorceFramesIn(StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt callerContextOrNil;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    sqInt valuePointer;
    sqInt valuePointer1;

	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);
	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			theContext = longAt(theFP + FoxThisContext);
			goto l1;
		}
		theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
		valuePointer = contextInstructionPointerframe(theIP, theFP);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(theContext)));
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer);
		assert((frameReceiver(theFP)) == (followFieldofObject(ReceiverIndex, theContext)));
		if (!(calleeContext == null)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(calleeContext)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(calleeContext)),
			oopisGreaterThanOrEqualTo(calleeContext, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(theContext & (tagMask()))))
				 && (oopisLessThan(theContext, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(calleeContext)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(calleeContext);
					}
				}
			}
			longAtput((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;
		/* theSP points at stacked hottest item on frame's stack */
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + (frameStackedReceiverOffset(calleeFP))) + BytesPerWord;
	}
	/* begin frameCallerContext: */
	assert(isBaseFrame(calleeFP));
	thePage = stackPageAtpages(
		(assert((((((char *) calleeFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) calleeFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(calleeFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(followMaybeForwarded(callerContextOrNil))));
	valuePointer1 = callerContextOrNil;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(theContext)),
	oopisGreaterThanOrEqualTo(theContext, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(valuePointer1 & (tagMask()))))
		 && (oopisLessThan(valuePointer1, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(theContext)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(theContext);
			}
		}
	}
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer1);
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

	/* StackInterpreter>>#doPrimitiveDiv:by: */
static NoDbgRegParms sqInt
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;

	integerArg = 0;
	integerRcvr = 0;
	if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
		integerRcvr = (rcvr >> 3);
		integerArg = (arg >> 3);
		/* begin success: */
		if (!(integerArg != 0)) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {
			/* round negative result toward negative infinity */
			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {
			/* round negative result toward negative infinity */
			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	if (!((((((usqInt)(result)) >> 60) + 1) & 15) <= 1)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return result;
}

	/* StackInterpreter>>#doPrimitiveMod:by: */
static NoDbgRegParms sqInt
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;

	integerArg = 0;
	integerRcvr = 0;
	if ((((rcvr & arg) & (smallIntegerTag())) != 0)) {
		integerRcvr = (rcvr >> 3);
		integerArg = (arg >> 3);
		/* begin success: */
		if (!(integerArg != 0)) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}
	/* ensure that the result has the same sign as the integerArg */
	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	if (!((((((usqInt)(integerResult)) >> 60) + 1) & 15) <= 1)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

	/* StackInterpreter>>#doSignalSemaphoreWithIndex: */
sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	assert(isArray(xArray));
	/* Note: semaphore indices are 1-based */
	sema = longAt((xArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
	assert(!(isOopForwarded(sema)));
	return (	/* begin isSemaphoreOop: */
		((!(sema & (tagMask()))))
	 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))))))))
	 && (synchronousSignal(sema));
}


/*	Presumably this exists to squash C compiler warnings about unused
	variables... 
 */

	/* StackInterpreter>>#dummyReferToProxy */
struct VirtualMachine * *
dummyReferToProxy(void)
{
	return (&interpreterProxy);
}


/*	The prim trace log is a circular buffer of entries. If there is
	an entry at primTraceLogIndex \\ PrimTraceLogSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* StackInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasParameter;
    sqInt i;
    sqInt remainder;

	if ((GIV(primTraceLog)[
		/* begin safe:mod: */
(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
			? remainder + PrimTraceLogSize
			: remainder)]) == 0) {
		return;
	}
	hasParameter = 0;
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			hasParameter = printPrimLogEntryAthasParameter(i, hasParameter);
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		hasParameter = printPrimLogEntryAthasParameter(i, hasParameter);
	}
}


/*	Print the prim trace log on a specific output stream. */
/*	essential for writing crash.dmp; use export: not api, so it will be
	accessible on win32 and won't be written to cointerp.h
 */

	/* StackInterpreter>>#dumpPrimTraceLogOn: */
void
dumpPrimTraceLogOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;


	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream == null
		? stdout
		: aStdioStream);
	dumpPrimTraceLog();
	GIV(transcript) = savedTranscript;
}


/*	For marking the end of a leak check print message */

	/* StackInterpreter>>#eekcr */
NeverInline void
eekcr(void)
{
	printf("\n");
}


/*	Answer the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

	/* StackInterpreter>>#ensureCallerContext: */
static NoDbgRegParms sqInt
ensureCallerContext(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    StackPage *thePage;
    char *theSP;

	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		/* base frame, context in saved ip slot (or base of stack in Cog) */
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil = longAt((thePage->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil))));
		return callerContextOrNil;
	}
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord;
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP)));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(callerFP, theSP);
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static NoDbgRegParms void
ensureImageFormatIsUpToDate(sqInt swapBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt fmt;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt objOop;
    sqInt objOop1;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt startObject;
    sqInt startObject1;
    sqInt stopAddr;
    int swapFloatWords;
    sqInt temp;
    int temp1;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		addr = GIV(oldSpaceStart);
		while (oopisLessThan(addr, GIV(endOfMemory))) {
			longAtput(addr, SQ_SWAP_8_BYTES((longAt(addr))));
			addr += BytesPerWord;
		}
		/* begin updateObjectsPostByteSwap */
		oop = 0;
		swapFloatWords = VMBIGENDIAN != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		objOop = 0;
		address = 
		/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		/* begin objectStartingAt: */
		numSlots1 = byteAt(address + 7);
		startObject = (numSlots1 == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
		/* begin allEntitiesFrom:do: */
		prevPrevObj = (prevObj = null);
		obj = startObject;
		enableObjectEnumerationFrom(startObject);
		while (1) {
			assert((obj % (allocationUnit())) == 0);
			if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
			assert((long64At(obj)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex = (longAt(obj)) & (classIndexMask())),
			assert((classIndex == (segmentBridgePun()))
				 || ((classIndex == (isForwardedObjectClassIndexPun()))
				 || (((long64At(obj)) != 0)
				 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex >= (isForwardedObjectClassIndexPun()))) {
				fmt = (((usqInt)((longAt(obj)))) >> (formatShift())) & (formatMask());
				if (fmt >= (firstByteFormat())) {
					/* oop contains bytes */
					wordAddr = obj + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat())) {
						/* compiled method; start after methodHeader and literals */
						methodHeader = longAt(obj + BaseHeaderSize);
						wordAddr += (((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
					}
					stopAddr = obj + ((((/* begin numSlotsOf: */
	assert((classIndexOf(obj)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(obj + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(obj - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) + BaseHeaderSize);
					/* begin reverseBytesFrom:to: */
					addr1 = wordAddr;
					while (oopisLessThan(addr1, stopAddr)) {
						longAtput(addr1, SQ_SWAP_8_BYTES((longAt(addr1))));
						addr1 += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat())) {
					/* Bitmap, Float etc */
					if (swapFloatWords
					 && (((longAt(obj)) & (classIndexMask())) == ClassFloatCompactIndex)) {
						temp = longAt(obj + BaseHeaderSize);
						longAtput(obj + BaseHeaderSize, longAt((obj + BaseHeaderSize) + 4));
						longAtput((obj + BaseHeaderSize) + 4, temp);
					}
					else {
					}
				}
			}
			prevPrevObj = prevObj;
			prevObj = obj;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress = addressAfter(obj);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				obj = GIV(endOfMemory);
				goto l2;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(obj, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress + BaseHeaderSize)
				: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
			assert(oopisGreaterThan(obj, prevObj));
		}
	}
	else {
		/* begin convertFloatsToPlatformOrder */
		obj2 = 0;
		if (VMBIGENDIAN == GIV(imageFloatsBigEndian)) {
			goto l5;
		}
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		objOop1 = 0;
		address1 = 
		/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		/* begin objectStartingAt: */
		numSlots2 = byteAt(address1 + 7);
		startObject1 = (numSlots2 == (numSlotsMask())
			? address1 + BaseHeaderSize
			: address1);
		/* begin allEntitiesFrom:do: */
		prevPrevObj1 = (prevObj1 = null);
		obj1 = startObject1;
		enableObjectEnumerationFrom(startObject1);
		while (1) {
			assert((obj1 % (allocationUnit())) == 0);
			if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
			assert((long64At(obj1)) != 0);
			if ((			/* begin isEnumerableObject: */
				(classIndex1 = (longAt(obj1)) & (classIndexMask())),
			assert((classIndex1 == (segmentBridgePun()))
				 || ((classIndex1 == (isForwardedObjectClassIndexPun()))
				 || (((long64At(obj1)) != 0)
				 && (classIndex1 < (GIV(numClassTablePages) * (classTablePageSize())))))),
			classIndex1 >= (isForwardedObjectClassIndexPun()))) {
				if (((longAt(obj1)) & (classIndexMask())) == ClassFloatCompactIndex) {
					temp1 = long32At(obj1 + BaseHeaderSize);
					long32Atput(obj1 + BaseHeaderSize, long32At((obj1 + BaseHeaderSize) + 4));
					long32Atput((obj1 + BaseHeaderSize) + 4, temp1);
				}
			}
			prevPrevObj1 = prevObj1;
			prevObj1 = obj1;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress1 = addressAfter(obj1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
				obj1 = GIV(endOfMemory);
				goto l4;
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1);
			obj1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
				? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
					 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
						? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress1 + BaseHeaderSize)
				: followingWordAddress1);
	l4:	/* end objectAfterMaybeSlimBridge:limit: */;
			assert(oopisGreaterThan(obj1, prevObj1));
		}
	l5:	/* end convertFloatsToPlatformOrder */;
	}
}

	/* StackInterpreter>>#establishFrameForContextToReturnTo: */
static NoDbgRegParms char *
establishFrameForContextToReturnTo(sqInt contextToReturnTo)
{
    sqInt senderOop;
    StackPage *thePage;

	if (!(		/* begin isContext: */
			((!(contextToReturnTo & (tagMask()))))
		 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		if (isWidowedContext(contextToReturnTo)) {
			/* error: home's sender is dead; cannot return */
			return 0;
		}
		/* begin frameOfMarriedContext: */
		senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		return (			/* begin withoutSmallIntegerTags: */
				assert((((senderOop) & 7) == 1)),
			pointerForOop(senderOop - (smallIntegerTag())));
	}
	if (!(((((longAt((contextToReturnTo + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1))) {
		return 0;
	}
	thePage = makeBaseFrameFor(contextToReturnTo);
	markStackPageMostRecentlyUsed(thePage);
	return (thePage->baseFP);
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */
/*	stackPage needs to have current head pointers to avoid confusion. */

	/* StackInterpreter>>#externalDivorceFrame:andContext: */
static NoDbgRegParms void
externalDivorceFrameandContext(char *theFP, sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    StackPage *lruOrFree;
    StackPage *newPage;
    int onCurrent;
    sqInt theIP;
    StackPage *thePage;
    StackPage *thePage1;
    char *theSP;
    char *theSP1;
    sqInt valuePointer;

	assert((!GIV(stackPage))
	 || (GIV(stackPage) == (mostRecentlyUsedPage())));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	theSP = findSPOfon(theFP, thePage);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {
		/* base frame, context in saved ip slot (or base of stack in Cog) */
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		thePage1 = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil))));
		callerCtx = callerContextOrNil;
		goto l6;
	}
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP1 = (theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord;
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(callerFP1 + FoxMethod)))) < (startOfMemory())
		? ((longAt(callerFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP1 + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP1)));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l6;
	}
	callerCtx = marryFrameSP(callerFP1, theSP1);
	l6:	/* end ensureCallerContext: */;
	if (((frameAbove = findFrameAboveinPage(theFP, thePage))) == 0) {
		/* If we're divorcing the top frame we can simply peel it off. */
		theIP = longAt((thePage->headSP));
	}
	else {
		/* othewise move all frames above to a new stack and then peel the frame off. */
		/* begin newStackPage */
		lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
		if (((lruOrFree->baseFP)) == 0) {
			newPage = lruOrFree;
			goto l2;
		}
		divorceFramesIn(lruOrFree);
		newPage = lruOrFree;
	l2:	/* end newStackPage */;
		theIP = oopForPointer(pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			assert(newPage);
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage);
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (newPage->headSP);
			GIV(framePointer) = (newPage->headFP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage);
		}
		assert((frameCallerContext(frameAbove)) == ctxt);
	}
	valuePointer = contextInstructionPointerframe(theIP, theFP);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(ctxt)));
	longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(ctxt)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(ctxt)),
	oopisGreaterThanOrEqualTo(ctxt, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(callerCtx & (tagMask()))))
		 && (oopisLessThan(callerCtx, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(ctxt)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(ctxt);
			}
		}
	}
	longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), callerCtx);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		/* theFP is a base frame; it is now alone; free the entire page */
		freeStackPage(thePage);
	}
	else {
		callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
		callerSP = ((/* begin frameCallerSP: */
	assert(!(isBaseFrame(theFP))),
(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord)) - BytesPerWord;
		longAtput(callerSP, callerIP);
		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

	/* StackInterpreter>>#externalEnsureIsBaseFrame: */
static NoDbgRegParms char *
externalEnsureIsBaseFrame(char *aFramePtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int onCurrent;
    char *theFP;
    StackPage *thePage;

	if ((longAt(aFramePtr + FoxSavedFP)) == 0) {
		return aFramePtr;
	}
	theFP = aFramePtr;
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	/* Storing the frame's sender with its caller's context
	   has the side effect of making theFP a base frame. */
	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP));
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	return theFP;
}

	/* StackInterpreter>>#externalInstVar:ofContext:put: */
static NoDbgRegParms sqInt
externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int onCurrentPage;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    sqInt thePC;

	assert(isContext(maybeMarriedContext));
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(!((isObjImmutable(maybeMarriedContext))));
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(maybeMarriedContext))))) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(maybeMarriedContext)),
		oopisGreaterThanOrEqualTo(maybeMarriedContext, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(anOop & (tagMask()))))
			 && (oopisLessThan(anOop, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(maybeMarriedContext)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(maybeMarriedContext);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), anOop);
		if (index == StackPointerIndex) {
			ensureContextIsExecutionSafeAfterAssignToStackPointer(maybeMarriedContext);
		}
		return null;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (index == SenderIndex) {
		storeSenderOfFramewithValue(theFP, anOop);
	}
	else {
		externalDivorceFrameandContext(theFP, maybeMarriedContext);
		if (		/* begin is:methodAssignmentToContextWithMachineCodePC: */
			(index == MethodIndex)
		 && (((((int) ((thePC = longAt((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))))) < 0)
		 && ((((thePC) & 7) == 1)))) {
			ensureContextHasBytecodePC(maybeMarriedContext);
		}
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(maybeMarriedContext)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(maybeMarriedContext)),
		oopisGreaterThanOrEqualTo(maybeMarriedContext, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(anOop & (tagMask()))))
			 && (oopisLessThan(anOop, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(maybeMarriedContext)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(maybeMarriedContext);
				}
			}
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), anOop);
		if (index == StackPointerIndex) {
			ensureContextIsExecutionSafeAfterAssignToStackPointer(maybeMarriedContext);
		}
	}
	if (onCurrentPage) {
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(pageListIsWellFormed());
	assert(validStackPageBaseFrames());
	return 0;
}


/*	Invoke a quick primitive.
	Called under the assumption that primFunctionPtr has been preloaded */

	/* StackInterpreter>>#externalQuickPrimitiveResponse */
static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 0xFF)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (((sqInt)((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 0x100) {
		return 1;
	}
	if (localPrimIndex == 0x101) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((0) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((0) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp3 = GIV(stackPointer) + ((0) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput((sp4 = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)(localPrimIndex - 261) << 3) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}


/*	not inlined for breakpoint value... */

	/* StackInterpreter>>#failUnbalancedPrimitive */
static void
failUnbalancedPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchArray:ofObject: */
void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	/* begin arrayValueOf: */
	if (	/* begin isWordsOrBytes: */
		((!(arrayOop & (tagMask()))))
	 && (isWordsOrBytesNonImm(arrayOop))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchFloat:ofObject: */
double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt floatOop;

	floatOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	return floatValueOf(floatOop);
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchInteger:ofObject: */
sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	intOop = longAt((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
	/* begin checkedIntegerValueOf: */
	if ((((intOop) & 7) == 1)) {
		return (intOop >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Fetch a slot from a married context. Compute the value
	of the relevant inst var from the spouse frame's state.
	
	This method assumes frame pointers have been written back. */

	/* StackInterpreter>>#fetchPointer:ofMarriedContext: */
static NoDbgRegParms sqInt
fetchPointerofMarriedContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt senderOop;
    sqInt senderOop1;
    char *spouseFP;
    StackPage *thePage;
    char *theSP;

	assert(isContext(aContext));
	assert((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer)));
	assert(checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer)));
	if (offset <= ReceiverIndex) {
		if (!(offset <= StackPointerIndex)) {
			return longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(offset) << (shiftForWord())))));
		}
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
		if (offset == SenderIndex) {
			/* begin ensureCallerContext: */
			callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
			if (callerFP == 0) {
				/* base frame, context in saved ip slot (or base of stack in Cog) */
				/* begin frameCallerContext: */
				assert(isBaseFrame(spouseFP));
				thePage = stackPageAtpages(
					(assert((((((char *) spouseFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) spouseFP)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(spouseFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				callerContextOrNil = longAt((thePage->baseAddress));
				assert(addressCouldBeObj(callerContextOrNil));
				assert((callerContextOrNil == (nilObject()))
				 || (isContext(followMaybeForwarded(callerContextOrNil))));
				return callerContextOrNil;
			}
			/* begin frameCallerStackPointer: */
			assert(!(isBaseFrame(spouseFP)));
			theSP = (spouseFP + (frameStackedReceiverOffset(spouseFP))) + BytesPerWord;
			/* begin ensureFrameIsMarried:SP: */
			if (			/* begin frameHasContext: */
				((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(callerFP)));
				return longAt(callerFP + FoxThisContext);
			}
			return marryFrameSP(callerFP, theSP);
		}
		if (offset == StackPointerIndex) {
			return (((usqInt)(stackPointerIndexForFrame(spouseFP)) << 3) | 1);
		}
		if (offset == InstructionPointerIndex) {
			return instructionPointerForFramecurrentFPcurrentIP(spouseFP, GIV(framePointer), GIV(instructionPointer));
		}
	}
	/* begin frameOfMarriedContext: */
	senderOop1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop1) & 7) == 1));
	spouseFP = pointerForOop(senderOop1 - (smallIntegerTag()));
	if ((((offset - ReceiverIndex) >= 1) && ((offset - ReceiverIndex) <= (stackPointerIndexForFrame(spouseFP))))) {
		/* begin temporary:in: */
		if ((((usqInt)(longAt(spouseFP + FoxMethod)))) < (startOfMemory())) {
			if ((offset - (ReceiverIndex + 1)) < ((frameNumArgs = ((mframeCogMethod(spouseFP))->cmNumArgs)))) {
				return longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord));
			}
			else {
				return longAt(((spouseFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord));
			}
		}
		else {
			return 
			/* begin itemporary:in: */
((offset - (ReceiverIndex + 1)) < ((frameNumArgs1 = byteAt((spouseFP + FoxIFrameFlags) + 1)))
				? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs1 - (offset - (ReceiverIndex + 1))) * BytesPerWord))
				: longAt(((spouseFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (offset - (ReceiverIndex + 1))) * BytesPerWord)));
		}
	}
	else {
		return GIV(nilObj);
	}
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static NoDbgRegParms sqInt
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((((sp) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext)));
	return (sp >> 3);
}


/*	Answer if file times, including those from the FilePlugin and
	FileAttributesPlugin, should be answered in UTC seconds from the epoch
	rather than local seconds. */

	/* StackInterpreter>>#fileTimesInUTC */
int
fileTimesInUTC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(imageHeaderFlags) & 0x200) != 0);
}

	/* StackInterpreter>>#findClassContainingMethod:startingAt: */
static NoDbgRegParms sqInt
findClassContainingMethodstartingAt(sqInt meth, sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methodArray;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt referent3;

	if (	/* begin isOopForwarded: */
		((!(classObj & (tagMask()))))
	 && ((!((longAt(classObj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(classObj));
		referent = longAt((classObj + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		currClass = referent;
	}
	else {
		currClass = classObj;
	}
	do {
		assert(!(isForwarded(currClass)));
		if (!(addressCouldBeClassObj(currClass))) {
			return GIV(nilObj);
		}
		/* begin noFixupFollowField:ofObject: */
		objOop = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop & (tagMask()))))
		 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop));
			referent1 = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent1 & (tagMask()))))
			 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			objOop = referent1;
		}
		classDict = objOop;
		assert(!(isForwarded(classDict)));
		/* begin numSlotsOf: */
		assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
		classDictSize = (((numSlots = byteAt(classDict + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(classDict - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		if (classDictSize > MethodArrayIndex) {
			/* begin noFixupFollowField:ofObject: */
			objOop1 = longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop1 & (tagMask()))))
			 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(objOop1));
				referent2 = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent2 & (tagMask()))))
				 && ((!((longAt(referent2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				objOop1 = referent2;
			}
			methodArray = objOop1;
			assert(!(isForwarded(methodArray)));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (noFixupFollowFieldofObject(i, methodArray))) {
					return currClass;
				}
				i += 1;
			}
		}
		/* begin noFixupSuperclassOf: */
		objOop2 = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop2 & (tagMask()))))
		 && ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop2));
			referent3 = longAt((objOop2 + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent3 & (tagMask()))))
			 && ((!((longAt(referent3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			objOop2 = referent3;
		}
		currClass = objOop2;
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}

	/* StackInterpreter>>#findClassOfMethod:forReceiver: */
sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rclass;
    sqInt tagBits;

	if ((	/* begin addressCouldBeOop: */
		(((rcvr & (tagMask())) != 0))
	 || (addressCouldBeObj(rcvr)))
	 && (!(((!(rcvr & (tagMask()))))
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))) {
		rclass = findClassContainingMethodstartingAt(meth, 
		/* begin fetchClassOf: */
(((tagBits = rcvr & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
			: fetchClassOfNonImm(rcvr)));
		if (rclass != GIV(nilObj)) {
			return rclass;
		}
	}
	if (!((addressCouldBeObj(meth))
		 && (((((usqInt)((longAt(meth)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return GIV(nilObj);
	}
	return findClassContainingMethodstartingAt(meth, safeMethodClassOf(meth));
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

	/* StackInterpreter>>#findFrameAbove:inPage: */
static NoDbgRegParms char *
findFrameAboveinPage(char *theFP, StackPage *thePage)
{
    char *callerFP;
    char *fp;

	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

	/* StackInterpreter>>#findHomeForContext: */
static NoDbgRegParms sqInt
findHomeForContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;

	if (!(		/* begin isContext: */
			((!(aContext & (tagMask()))))
		 && (((longAt(aContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return null;
	}
	closureOrNil = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	if ((((longAt(closureOrNil)) & (classIndexMask())) != ClassBlockClosureCompactIndex)
	 && (((longAt(closureOrNil)) & (classIndexMask())) != ClassFullBlockClosureCompactIndex)) {
		return null;
	};
	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureOuterContextIndex) << (shiftForWord()))))));
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */
/*	Being mutually-recursive with findMethodWithPrimitive:FromFP:UpToContext:
	gives the author's type inference algorithm headaches. Wimp out by
	declaring the return type.
 */

	/* StackInterpreter>>#findMethodWithPrimitive:FromContext:UpToContext: */
static NoDbgRegParms sqInt
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt objOop;
    sqInt objOop1;
    sqInt senderContext1;
    sqInt senderOop;
    char *startFP;
    sqInt theContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    sqInt theMethod1;
    StackPage *thePage;
    char *theSP;

	assert((senderContext == (nilObject()))
	 || (isContext(senderContext)));
	assert((homeContext == (nilObject()))
	 || (isContext(homeContext)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((((longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))))) != GIV(nilObj)))) {
			/* begin followObjField:ofObject: */
			objOop = longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop));
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(MethodIndex, theContext, objOop);
			}
			theMethod = objOop;
			if ((primitiveIndexOf(theMethod)) == primitive) {
				return theContext;
			}
		}
		/* begin followObjField:ofObject: */
		objOop1 = longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop1));
		if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SenderIndex, theContext, objOop1);
		}
		theContext = objOop1;
	}
	if (isWidowedContext(theContext)) {
		return GIV(nilObj);
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	startFP = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin findMethodWithPrimitive:FromFP:UpToContext: */
	theFP = startFP;
	theFPAbove = startFP;
	do {
		if ((		/* begin frameHasContext: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!((primitive == 0)
			 || (			/* begin frameIsBlockActivation: */
				((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)))) {
			/* begin frameMethodObject: */
			if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
				theMethod1 = ((mframeHomeMethod(theFP))->methodObject);
			}
			else {
				theMethod1 = longAt(theFP + FoxMethod);
			}
			if ((primitiveIndexOf(theMethod1)) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;
				}
				/* begin ensureFrameIsMarried:SP: */
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP);
			}
		}
		theFPAbove = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	/* begin frameCallerContext: */
	assert(isBaseFrame(theFPAbove));
	thePage = stackPageAtpages(
		(assert((((((char *) theFPAbove)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFPAbove)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFPAbove, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(followMaybeForwarded(callerContextOrNil))));
	senderContext1 = callerContextOrNil;
	if (!(		/* begin isContext: */
			((!(senderContext1 & (tagMask()))))
		 && (((longAt(senderContext1)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContext1, homeContext);
}

	/* StackInterpreter>>#findSelectorOfMethod: */
sqInt
findSelectorOfMethod(sqInt meth)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt classObj;
    sqInt i;
    sqInt methodArray;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt selector;

	if (!(addressCouldBeObj(meth))) {
		return GIV(nilObj);
	}
	if ((!((longAt(meth)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		return findSelectorOfMethod(followForwarded(meth));
	}
	if (!(		/* begin isOopCompiledMethod: */
			((!(meth & (tagMask()))))
		 && (((((usqInt)((longAt(meth)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return GIV(nilObj);
	}
	selector = maybeSelectorOfMethod(meth);
	if (!(selector == null)) {
		return selector;
	}
	classObj = safeMethodClassOf(meth);
	if (addressCouldBeClassObj(classObj)) {
		/* begin noFixupFollowField:ofObject: */
		objOop = longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop & (tagMask()))))
		 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(objOop));
			referent = longAt((objOop + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent & (tagMask()))))
			 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			objOop = referent;
		}
		classDict = objOop;
		/* begin numSlotsOf: */
		assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
		classDictSize = (((numSlots = byteAt(classDict + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(classDict - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		if (classDictSize > MethodArrayIndex) {
			/* begin noFixupFollowField:ofObject: */
			objOop1 = longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop1 & (tagMask()))))
			 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(objOop1));
				referent1 = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent1 & (tagMask()))))
				 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				objOop1 = referent1;
			}
			methodArray = objOop1;
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (noFixupFollowFieldofObject(i, methodArray))) {
					/* begin noFixupFollowField:ofObject: */
					objOop2 = longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)((i + SelectorStart)) << (shiftForWord())))));
					if (					/* begin isOopForwarded: */
						((!(objOop2 & (tagMask()))))
					 && ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(objOop2));
						referent2 = longAt((objOop2 + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent2 & (tagMask()))))
						 && ((!((longAt(referent2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						objOop2 = referent2;
					}
					return objOop2;
				}
				i += 1;
			}
		}
	}
	return GIV(nilObj);
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

	/* StackInterpreter>>#findSPOf:on: */
static NoDbgRegParms char *
findSPOfon(char *theFP, StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    char *theSP;

	assert(!((isFree(thePage))));
	startFrame = (thePage->headFP);
	/* begin findSPOrNilOf:on:startingFrom: */
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {
			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = 
			/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? theFP + FoxMFReceiver
				: theFP + FoxIFReceiver);
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
			? (thePage->headSP)
			: ((thePage->headSP)) + BytesPerWord);
		goto l1;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + (frameStackedReceiverOffset(prevFrame))) + BytesPerWord;
			goto l1;
		}
	}
	theSP = null;
	l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (!(theSP == null)) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}


/*	Search for either an unwind-protect (activation of method with primitive
	198, PrimNumberUnwindMarker)
	or homeContext along the sender chain, which ever is found first. Return
	values: 0			home context was found on sender chain with no intervening
	unwind-protects nilObj		home context could not be found => cannotReturn
	context		the context of an intervening unwind-protect implies home context
	was found */
/*	Almost always (98%) the home is on the same page, in which case we know it
	will be found.
 */

	/* StackInterpreter>>#findUnwindThroughContext: */
static NoDbgRegParms sqInt
findUnwindThroughContext(sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt ctxtOrNilOrZero;
    sqInt onSamePage;
    sqInt senderContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    sqInt theMethod1;
    StackPage *thePage;
    char *theSP;


	/* Since nothing changes we don't need to internalize. */
	onSamePage = (	/* begin isStillMarriedContext: */
		(((((longAt((homeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(homeContext))))
	 && (((assert((((((char *) GIV(framePointer))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) GIV(framePointer))) <= (((char *) GIV(pages)))))),
	pageIndexForstackBasePlus1bytesPerPage(GIV(framePointer), GIV(stackBasePlus1), GIV(bytesPerPage)))) == (pageIndexFor(frameOfMarriedContext(homeContext))));
	/* begin findMethodWithPrimitive:FromFP:UpToContext: */
	theFP = GIV(framePointer);
	theFPAbove = GIV(framePointer);
	do {
		if ((		/* begin frameHasContext: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			ctxtOrNilOrZero = 0;
			goto l3;
		}
		if (!(			/* begin frameIsBlockActivation: */
				((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0))) {
			/* begin frameMethodObject: */
			if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
				theMethod1 = ((mframeHomeMethod(theFP))->methodObject);
			}
			else {
				theMethod1 = longAt(theFP + FoxMethod);
			}
			if ((primitiveIndexOf(theMethod1)) == PrimNumberUnwindMarker) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;
				}
				/* begin ensureFrameIsMarried:SP: */
				if (				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
					assert(isContext(frameContext(theFP)));
					ctxtOrNilOrZero = longAt(theFP + FoxThisContext);
					goto l3;
				}
				ctxtOrNilOrZero = marryFrameSP(theFP, theSP);
				goto l3;
			}
		}
		theFPAbove = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	/* begin frameCallerContext: */
	assert(isBaseFrame(theFPAbove));
	thePage = stackPageAtpages(
		(assert((((((char *) theFPAbove)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFPAbove)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFPAbove, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(followMaybeForwarded(callerContextOrNil))));
	senderContext = callerContextOrNil;
	if (!(		/* begin isContext: */
			((!(senderContext & (tagMask()))))
		 && (((longAt(senderContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		ctxtOrNilOrZero = GIV(nilObj);
		goto l3;
	}
	ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, senderContext, homeContext);
	l3:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
	assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
	if (ctxtOrNilOrZero == 0) {
		theMethod = longAt((homeContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
		if ((primitiveIndexOf(theMethod)) == PrimNumberUnwindMarker) {
			return homeContext;
		}
		return 0;
	}
	if (!(onSamePage
		 || (ctxtOrNilOrZero == GIV(nilObj)))) {
		if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, homeContext)) == GIV(nilObj)) {
			return GIV(nilObj);
		}
	}
	return ctxtOrNilOrZero;
}

	/* StackInterpreter>>#flush */
void
flush(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fflush(GIV(transcript));
}


/*	methodObj is a CompiledMethod. If it contains an external primitive,
	flush the function address and session ID of the CM. Answer the prim
	index for the benefit of subclass overrides. */

	/* StackInterpreter>>#flushExternalPrimitiveOf: */
static NoDbgRegParms sqInt
flushExternalPrimitiveOf(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt header1;
    sqInt lit;
    usqInt numSlots;
    sqInt primIdx;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj));
	header1 = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	primIdx = 
	/* begin primitiveIndexOfMethod:header: */
(((header & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (methodObj + ((LiteralStart + (((header >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	if ((primIdx == PrimNumberExternalCall)
	 && (((	/* begin literalCountOfMethodHeader: */
		assert((((header) & 7) == 1)),
	((header >> 3)) & AlternateHeaderNumLiteralsMask)) > 0)) {
		/* If not, something's broken */
		lit = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
		if ((		/* begin isArray: */
			((!(lit & (tagMask()))))
		 && (((((usqInt)((longAt(lit)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((assert((classIndexOf(lit)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(lit + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(lit - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) == 4)) {
			/* If not, something's broken */
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(lit)));
			longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord())), ConstZero);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(lit)));
			longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord())), ConstZero);
		}
	}
	return primIdx;
}


/*	Flush the method caches of references to oldMethod. */

	/* StackInterpreter>>#flushMethodCacheForMethod: */
static NoDbgRegParms void
flushMethodCacheForMethod(sqInt oldMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt probe;

	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	flushExternalPrimitiveOf(oldMethod);
}


/*	follow pointers in the current stack frame up to theSP. */

	/* StackInterpreter>>#followForwardedFrameContents:stackPointer: */
static NoDbgRegParms void
followForwardedFrameContentsstackPointer(char *theFP, char *theSP)
{
    sqInt oop;
    char *ptr;
    sqInt referent;
    char *toDoLimit1;
    char *toDoLimit2;

	for (ptr = theSP, toDoLimit1 = (/* begin frameReceiverLocation: */
	((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
	? theFP + FoxMFReceiver
	: theFP + FoxIFReceiver)); ptr <= toDoLimit1; ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((!(oop & (tagMask()))))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			longAtput(ptr, followForwarded(oop));
		}
	}
	for (ptr = ((theFP + FoxCallerSavedIP) + BytesPerWord), toDoLimit2 = (theFP + (frameStackedReceiverOffset(theFP))); ptr <= toDoLimit2; ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((!(oop & (tagMask()))))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(oop));
			referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent & (tagMask()))))
			 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			oop = referent;
			longAtput(ptr, oop);
		}
	}
	if (	/* begin frameIsBlockActivation: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)) {
		assert(oop == (longAt(theFP + (frameStackedReceiverOffset(theFP)))));
		followForwardedObjectFieldstoDepth(oop, 0);
	}
	assert(!(isForwarded(frameMethodObject(theFP))));
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(!(isForwarded(frameContext(theFP))));
	}
}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

	/* StackInterpreter>>#forceInterruptCheck */
sqInt
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;


	/* Do _not_ set stackLimit until the stack system has been initialized.
	   stackLimit is the initialization flag for the stack system. */
	if (GIV(stackLimit) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	if ((thePage)
	 && (thePage != 0)) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence();
	if (((iccFunc = interruptCheckChain))) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
	return 0;
}

	/* StackInterpreter>>#frameContext: */
static NoDbgRegParms sqInt
frameContext(char *theFP)
{
	return longAt(theFP + FoxThisContext);
}

	/* StackInterpreter>>#frameOfMarriedContext: */
static NoDbgRegParms char *
frameOfMarriedContext(sqInt aContext)
{
    sqInt senderOop;

	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	return (		/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1)),
		pointerForOop(senderOop - (smallIntegerTag())));
}

	/* StackInterpreter>>#framePrintDescription: */
static NoDbgRegParms void
framePrintDescription(sqInt it)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (it != 0) {
		if (it == GIV(nilObj)) {
			fprintf(GIV(transcript), "=nil");
		}
		else {
			fprintf(GIV(transcript),
					"=%" PRIdSQINT "",
					it);
		}
	}
}


/*	Answer the offset in bytes from the the frame pointer to its stacked
	receiver. The receiver of a message send or the closure of a block
	activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#frameStackedReceiverOffset: */
static NoDbgRegParms sqInt
frameStackedReceiverOffset(char *theFP)
{
    sqInt numArgs;

	numArgs = 
	/* begin frameNumArgs: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? ((mframeCogMethod(theFP))->cmNumArgs)
		: byteAt((theFP + FoxIFrameFlags) + 1));
	return (FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))));
}


/*	Answer the stacked receiver given the frame's argument count.
	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#frameStackedReceiver:numArgs: */
static NoDbgRegParms sqInt
frameStackedReceivernumArgs(char *theFP, sqInt numArgs)
{
	return longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (((sqInt)((usqInt)(numArgs) << (shiftForWord()))))));
}


/*	Free any untraced stack pages. */

	/* StackInterpreter>>#freeUntracedStackPages */
static void
freeUntracedStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((!(isFree(thePage)))
		 && (((thePage->trace)) == StackPageUnreached)) {
			assert(noMarkedContextsOnPage(thePage));
			freeStackPage(thePage);
		}
		assert(((thePage->trace = StackPageTraceInvalid)) != 0);
	}
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

	/* StackInterpreter>>#fullDisplayUpdate */
sqInt
fullDisplayUpdate(void)
{
	updateDisplayLeftTopRightBottom(0, 0, displayWidth, displayHeight);
	ioForceDisplayUpdate();
	return 0;
}


/*	Find an actual function pointer for this primitiveIndex. This is an
	opportunity to specialise the prim for the relevant class (format for
	example). Default for now is simply the entry in the base primitiveTable. */

	/* StackInterpreter>>#functionPointerFor:inClass: */
static NoDbgRegParms void
(*functionPointerForinClass(sqInt primIdx, sqInt theClass))(void)
{
	return (primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx]);
}


/*	Answer an array of flags indicating various optional features of the Cog
	VM. If the bit is set then...
	Bit 0: supports two bytecode sets (MULTIPLEBYTECODESETS)
	Bit 1: supports immutablity (IMMUTABILITY)
	Bit 2: suffers from a UNIX setitimer signal-based heartbeat
	Bit 3: the VM provides cross-platform bit-identical floating point
	Bit 4: the VM can catch exceptions in FFI calls and answer them as
	primitive failures
	Bit 5: the VM has suspend primitives 568 & 578 which back up a process to
	before the wait if it was waiting on a condition variable */

	/* StackInterpreter>>#getCogVMFeatureFlags */
static sqInt
getCogVMFeatureFlags(void)
{
	return (((usqInt)(((((1 + (
#if IMMUTABILITY
	(IMMUTABILITY
		? 2
		: 0)
#else
	0
#endif
	)) + (
#if ITIMER_HEARTBEAT
	4
#else
	0
#endif
	)) + (
#if BIT_IDENTICAL_FLOATING_POINT
	8
#else
	0
#endif
	)) + ((ioCanCatchFFIExceptions()
	? 16
	: 0))) + 32) << 3) | 1);
}


/*	Answer the errorCode object to supply to a failing primitive method that
	accepts one.
	If there is a primitive error table and the primFailCode is a valid index
	there-in answer
	the corresponding entry in the table, otherwise simply answer the code as
	an integer.
 */

	/* StackInterpreter>>#getErrorObjectFromPrimFailCode */
static sqInt
getErrorObjectFromPrimFailCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt clone;
    sqInt errObj;
    sqInt i;
    usqInt newObj;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt objOop;
    sqInt table;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	if (GIV(primFailCode) > 0) {
		table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(PrimitiveErrorTableIndex) << (shiftForWord())))));
		if (GIV(primFailCode) <= ((		/* begin numSlotsOf: */
			assert((classIndexOf(table)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(table + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(table - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots)))) {
			/* begin followField:ofObject: */
			objOop = longAt((table + BaseHeaderSize) + (((sqInt)((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
			if (			/* begin isOopForwarded: */
				((!(objOop & (tagMask()))))
			 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(GIV(primFailCode) - 1, table, objOop);
			}
			errObj = objOop;
			if (((((usqInt)((longAt(errObj)))) >> (formatShift())) & (formatMask())) == 1 /* begin nonIndexablePointerFormat */) {
				/* begin cloneErrorObj: */
				assert((classIndexOf(errObj)) > (isForwardedObjectClassIndexPun()));
				numSlots2 = (((numSlots1 = byteAt(errObj + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(errObj - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1);
				classIndex = (longAt(errObj)) & (classIndexMask());
				/* begin eeInstantiateAnySmallClassIndex:format:numSlots: */
				assert((numSlots2 >= 0)
				 && ((classIndex != 0)
				 && ((classAtIndex(classIndex)) != GIV(nilObj))));
				assert((1 /* begin nonIndexablePointerFormat */) == (instSpecOfClass(classAtIndex(classIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots2 < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots2 < 1
	? 8 /* begin allocationUnit */
	: numSlots2 * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						clone = 0;
						goto l5;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots2)) << (numSlotsFullShift())) + (1U << (formatShift()))) + classIndex);
				GIV(freeStart) += numBytes;
				clone = newObj;
	l5:	/* end eeInstantiateAnySmallClassIndex:format:numSlots: */;
				for (i = 0; i < numSlots2; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(clone)));
					longAtput((clone + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((errObj + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
				}
				if ((numSlots2 > 2)
				 && (GIV(primFailCode) == PrimErrFFIException)) {
					valuePointer = positive64BitIntegerFor(((usqLong) GIV(secondaryErrorCode)));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(clone)));
					longAtput((clone + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
					valuePointer1 = positiveMachineIntegerFor(GIV(exceptionPC));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(clone)));
					longAtput((clone + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer1);
				}
				else {
					valuePointer2 = signed64BitIntegerFor(GIV(secondaryErrorCode));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isOopForwarded(clone)));
					longAtput((clone + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer2);
				}
				errObj = clone;
			}
			return errObj;
		}
	}
	return (((usqInt)GIV(primFailCode) << 3) | 1);
}

	/* StackInterpreter>>#getFullScreenFlag */
sqInt
getFullScreenFlag(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(fullScreenFlag);
}

	/* StackInterpreter>>#getInterruptKeycode */
sqInt
getInterruptKeycode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptKeycode);
}

	/* StackInterpreter>>#getInterruptPending */
sqInt
getInterruptPending(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptPending);
}

	/* StackInterpreter>>#getNextWakeupUsecs */
usqLong
getNextWakeupUsecs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nextWakeupUsecs);
}

	/* StackInterpreter>>#getSavedWindowSize */
sqInt
getSavedWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedWindowSize);
}


/*	Answer the next 16 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getShortFromFile:swap: */
static NoDbgRegParms sqInt
getShortFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    unsigned short w;

	w = 0;
	sqImageFileRead((&w), sizeof(unsigned short), 1, aFile);
	return (swapFlag
		? ((((usqInt)(w)) >> 8) & 0xFF) | (((sqInt)((usqInt)((w & 0xFF)) << 8)))
		: w);
}


/*	Answer the screen size to write to the snapshot.
	If the actual screen size is zero then write the savedWindowSize instead. */

	/* StackInterpreter>>#getSnapshotScreenSize */
static sqInt
getSnapshotScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt screenSize;

	screenSize = ioScreenSize();
	if (((screenSize & 0xFFFF) == 0)
	 || ((((usqInt)(screenSize)) >> 16) == 0)) {
		screenSize = GIV(savedWindowSize);
	}
	return screenSize;
}


/*	For Alien FFI */

	/* StackInterpreter>>#getStackPointer */
sqInt *
getStackPointer(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((sqInt *) GIV(stackPointer));
}


/*	return the global session ID value */

	/* StackInterpreter>>#getThisSessionID */
sqInt
getThisSessionID(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(globalSessionID);
}

	/* StackInterpreter>>#getTranscript */
FILE *
getTranscript(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(transcript);
}


/*	Handle a send fault that is due to a send using a forwarded selector.
	Unforward the selector and follow the current method and special
	selectors array to unforward the source of the forwarded selector. */

	/* StackInterpreter>>#handleForwardedSelectorFaultFor: */
static NoDbgRegParms sqInt
handleForwardedSelectorFaultFor(sqInt selectorOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;

	assert(isOopForwarded(selectorOop));
	followForwardedFieldsInCurrentMethod();
	followForwardedObjectFieldstoDepth(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord()))))), 0);
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(selectorOop));
	referent = longAt((selectorOop + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent & (tagMask()))))
	 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	return referent;
}


/*	Handle a send fault that may be due to a send to a forwarded object.
	Unforward the receiver on the stack and answer its actual class. */

	/* StackInterpreter>>#handleForwardedSendFaultForTag: */
static NoDbgRegParms sqInt
handleForwardedSendFaultForTag(sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt referent;
    sqInt tagBits;

	assert(isForwardedClassTag(classTag));
	/* should *not* be a super send, so the receiver should be forwarded. */
	rcvr = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	assert(isOopForwarded(rcvr));
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(rcvr));
	referent = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent & (tagMask()))))
	 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	rcvr = referent;
	/* begin stackValue:put: */
	longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord));
	if (isPointers(	/* begin frameReceiver: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? longAt(GIV(framePointer) + FoxMFReceiver)
		: longAt(GIV(framePointer) + FoxIFReceiver)))) {
		followForwardedObjectFieldstoDepth(		/* begin frameReceiver: */
			((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? longAt(GIV(framePointer) + FoxMFReceiver)
			: longAt(GIV(framePointer) + FoxIFReceiver)), 0);
	}
	return 
	/* begin fetchClassTagOf: */
(((tagBits = rcvr & (tagMask()))) != 0
		? tagBits
		: (longAt(rcvr)) & (classIndexMask()));
}


/*	Handle a special send fault that may be due to a special selector
	send accessing a forwarded object. obj is forwarded.
	Unforward stack contents and and inst vars and answer obj's target. */

	/* StackInterpreter>>#handleSpecialSelectorSendFaultFor:fp:sp: */
static NoDbgRegParms sqInt
handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP)
{
    sqInt rcvr;
    sqInt referent;

	assert(isOopForwarded(obj));
	followForwardedFrameContentsstackPointer(theFP, theSP);
	rcvr = 
	/* begin frameReceiver: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? longAt(theFP + FoxMFReceiver)
		: longAt(theFP + FoxIFReceiver));
	if (	/* begin isPointers: */
		((!(rcvr & (tagMask()))))
	 && (((((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)) {
		followForwardedObjectFieldstoDepth(rcvr, 0);
	}
	/* begin followForwarded: */
	assert(isUnambiguouslyForwarder(obj));
	referent = longAt((obj + BaseHeaderSize) + (0U << (shiftForWord())));
	while (	/* begin isOopForwarded: */
		((!(referent & (tagMask()))))
	 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
	}
	return referent;
}


/*	Check for stack overflow, moving frames to another stack if so.
	This should *only* be sent from checkForStackOverflow. */

	/* StackInterpreter>>#handleStackOverflow */
static NeverInline void
handleStackOverflow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    char *callerFP1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    sqInt source;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	assert(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)));
	/* begin maybeTraceStackOverflow */
	if (recordOverflowTrace()) {
		source = ((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
			? TraceIsFromMachineCode
			: TraceIsFromInterpreter);
		/* begin recordTrace:thing:source: */
		GIV(traceLog)[GIV(traceLogIndex)] = TraceStackOverflow;
		GIV(traceLog)[GIV(traceLogIndex) + 1] = TraceStackOverflow;
		GIV(traceLog)[GIV(traceLogIndex) + 2] = source;
		GIV(traceLogIndex) = (GIV(traceLogIndex) + 3) % TraceBufferSize;
	}
	if ((recordPrimTrace())
	 && (!primTracePluginName)) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = TraceStackOverflow;
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	   e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	   back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	   more than one frame.  The idea is to record which page has overflowed, and the first
	   time it overflows move one frame, the second time two frames, and so on.  We move no
	   more frames than would leave the page half occupied. */
	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = (GIV(extraFramesToMoveOnOverflow) += 1);
		while ((((overflowCount -= 1)) >= 0)
		 && ((((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) < overflowLimitAddress)
		 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}
	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {
		/* base frame, context in saved ip slot (or base of stack in Cog) */
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil = longAt((thePage->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil))));
		goto l3;
	}
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord;
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(callerFP1 + FoxMethod)))) < (startOfMemory())
		? ((longAt(callerFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP1 + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP1)));
		/* begin frameContext: */
		goto l3;
	}
	marryFrameSP(callerFP1, theSP);
	l3:	/* end ensureCallerContext: */;
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
	l1:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage);
	/* begin setStackPageAndLimit: */
	assert(newPage);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	assert(validInstructionPointerinFrame(GIV(instructionPointer) + 1, GIV(framePointer)));
	assert((!(frameHasContext(GIV(framePointer))))
	 || (isContext(frameContext(GIV(framePointer)))));
}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for stackOverflow and interrupts anddeal with each
	appropriately. Answer if a context switch occurred. */

	/* StackInterpreter>>#handleStackOverflowOrEventAllowContextSwitch: */
static NoDbgRegParms sqInt
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkForStackOverflow */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		return 0;
	}
	return checkForEventsMayContextSwitch(mayContextSwitch);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */
	shifted = anUnsignedValue;
	bitNo = 0;
#  if BytesPerWord > 4
	if (!(shifted < (0x100000000LL))) {
		shifted = (shifted) >> 32;
		bitNo += 32;
	}
#  endif

	if (!(shifted < (0x10000))) {
		shifted = (shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (0x100))) {
		shifted = (shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (16))) {
		shifted = (shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (4))) {
		shifted = (shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (2))) {
		shifted = (shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	If thePage is the stackPage and the stackPointer and/or the framePointer
	are pointing within it,
	answer if thePage's heapSP and headFP are equal to the stackPointer and
	framePointer respectively.
 */

	/* StackInterpreter>>#ifCurrentStackPageHasValidHeadPointers: */
static NoDbgRegParms sqInt
ifCurrentStackPageHasValidHeadPointers(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (thePage == GIV(stackPage)) {
		if (		/* begin addressIsInPage: */
			(((thePage->lastAddress)) < GIV(framePointer))
		 && (GIV(framePointer) < ((thePage->baseAddress)))) {
			if (((thePage->headFP)) != GIV(framePointer)) {
				return 0;
			}
		}
		if (		/* begin addressIsInPage: */
			(((thePage->lastAddress)) < GIV(stackPointer))
		 && (GIV(stackPointer) < ((thePage->baseAddress)))) {
			if (((thePage->headSP)) != GIV(stackPointer)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* StackInterpreter>>#iframeMethod: */
static NoDbgRegParms usqInt
iframeMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		/* begin superclassOf: */
		objOop = longAt((theClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, theClass, objOop);
		}
		theClass = objOop;
	}
	return 0;
}


/*	Initialize the stack pages and then invoke continuation. Use alloca'ed
	memory so that
	when we have a JIT its stack pointer will be on the native stack since
	alloca allocates
	memory on the stack. Certain thread systems use the native stack pointer
	as the
	frame ID so putting the stack anywhere else can confuse the thread system.
	
	This path is for the threaded VM where we may want to allocate the stack
	zone on
	the stack of a thread other than the main VM thread. */

	/* StackInterpreter>>#initStackPagesAndContinueInto:with: */
void
initStackPagesAndContinueIntowith(void (*continuation)(void *), void *argument)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackPageBytes;
    sqInt stackZoneBytes;
    void *theStackMemory;


	/* begin ensureInitializeStackZone */
	if (!GIV(pages)) {
		stackPageBytes = stackPageByteSize();
		stackZoneBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackZoneBytes);
		memset(theStackMemory, 0, stackZoneBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackZoneBytes / BytesPerWord, stackPageBytes / BytesPerWord);
	}
	continuation(argument);
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

	/* StackInterpreter>>#ioFilename:fromString:ofLength:resolveAliases: */
void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

	/* StackInterpreter>>#isBaseFrame: */
static NoDbgRegParms int
isBaseFrame(char *theFP)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}

	/* StackInterpreter>>#isBooleanObject: */
sqInt
isBooleanObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oop == GIV(trueObj))
	 || (oop == GIV(falseObj));
}

	/* StackInterpreter>>#isFloatObject: */
int
isFloatObject(sqInt oop)
{
    sqInt tagBits;

	return 
	/* begin isFloatInstance: */
(((tagBits = oop & (tagMask()))) != 0
		? tagBits == (smallFloatTag())
		: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
}

	/* StackInterpreter>>#isFrame:onPage: */
static NoDbgRegParms sqInt
isFrameonPage(char *aFrame, StackPage *aPage)
{
    char *prevFP;
    char *theFP;

	assert(!((isFree(aPage))));
	theFP = (aPage->headFP);
	prevFP = theFP - BytesPerWord;
	while (1) {
		if (theFP == aFrame) {
			return 1;
		}
		if (!((theFP > prevFP)
		 && (theFP < ((aPage->baseFP))))) break;
		prevFP = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	}
	return 0;
}


/*	Answer true if the oop is kind of Integer (Small or Large). */

	/* StackInterpreter>>#isKindOfInteger: */
sqInt
isKindOfInteger(sqInt oop)
{
	return ((((oop) & 7) == 1))
	 || (	/* begin isLargeIntegerInstance: */
		((!(oop & (tagMask()))))
	 && ((((usqInt)(((longAt(oop)) & (classIndexMask())) - ClassLargeNegativeIntegerCompactIndex))) <= 1));
}

	/* StackInterpreter>>#isLargeIntegerObject: */
sqInt
isLargeIntegerObject(sqInt oop)
{
	return 
	/* begin isLargeIntegerInstance: */
((!(oop & (tagMask()))))
	 && ((((usqInt)(((longAt(oop)) & (classIndexMask())) - ClassLargeNegativeIntegerCompactIndex))) <= 1);
}

	/* StackInterpreter>>#isLargeNegativeIntegerObject: */
sqInt
isLargeNegativeIntegerObject(sqInt oop)
{
	return 
	/* begin isInstanceOfClassLargeNegativeInteger: */
((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == ClassLargeNegativeIntegerCompactIndex);
}

	/* StackInterpreter>>#isLargePositiveIntegerObject: */
sqInt
isLargePositiveIntegerObject(sqInt oop)
{
	return 
	/* begin isInstanceOfClassLargePositiveInteger: */
((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == ClassLargePositiveIntegerCompactIndex);
}

	/* StackInterpreter>>#isLinkedExternalPrimitive: */
static NoDbgRegParms sqInt
isLinkedExternalPrimitive(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt header1;
    sqInt literal;
    usqInt numSlots;
    sqInt primIdx;
    sqInt targetFunctionIndex;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj));
	header1 = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	primIdx = 
	/* begin primitiveIndexOfMethod:header: */
(((header & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (methodObj + ((LiteralStart + (((header >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	return (primIdx == PrimNumberExternalCall)
	 && ((((	/* begin literalCountOfMethodHeader: */
		assert((((header) & 7) == 1)),
	((header >> 3)) & AlternateHeaderNumLiteralsMask)) > 0)
	 && ((isArray((literal = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord()))))))))
	 && ((((	/* begin numSlotsOf: */
		assert((classIndexOf(literal)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(literal + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(literal - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) == 4)
	 && (((targetFunctionIndex = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))))),
	((((targetFunctionIndex) & 7) == 1))
		 && (((targetFunctionIndex >> 3)) > 0))))));
}


/*	Answer if the argument, which can be any object, is a live context. */

	/* StackInterpreter>>#isLiveContext: */
static NoDbgRegParms sqInt
isLiveContext(sqInt oop)
{
	assert(!((isOopForwarded(oop))));
	if (!(		/* begin isContext: */
			((!(oop & (tagMask()))))
		 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if ((!((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())))) {
		return ((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1);
	}
	return !(isWidowedContext(oop));
}

	/* StackInterpreter>>#isMarriedOrWidowedContext: */
static NoDbgRegParms int
isMarriedOrWidowedContext(sqInt aContext)
{
	return ((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1);
}


/*	This virtual machine provides two primitives that executes arbitrary
	primitives, one
	for indexed primitivces and one for named primitives. These meta
	primitives are used
	in the debugger to execute primitives while simulating execution. Spur
	needs to know
	the accessor depth for a primitive so that failures due to forwarders can
	be fixed up
	and retried. This method identifies such meta primitives so that
	metaAccessorDepth can be substituted when appropriate. */

	/* StackInterpreter>>#isMetaPrimitiveIndex: */
static NoDbgRegParms sqInt
isMetaPrimitiveIndex(sqInt primIndex)
{
	return (primIndex == PrimNumberDoPrimitive)
	 || (primIndex == PrimNumberDoExternalCall);
}


/*	Answer if the method is an external primitive call (prim 117) with a null
	external primitive.
	This is just for an assert in the CoInterpreter. */

	/* StackInterpreter>>#isNullExternalPrimitiveCall: */
static NoDbgRegParms sqInt
isNullExternalPrimitiveCall(sqInt aMethodObj)
{
    sqInt lit;
    usqInt numSlots;

	if (!(((primitiveIndexOf(aMethodObj)) == PrimNumberExternalCall)
		 && ((literalCountOf(aMethodObj)) > 0))) {
		return 0;
	}
	lit = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
	return (	/* begin isArray: */
		((!(lit & (tagMask()))))
	 && (((((usqInt)((longAt(lit)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
	 && ((((	/* begin numSlotsOf: */
		assert((classIndexOf(lit)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(lit + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(lit - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) == 4)
	 && (((longAt((lit + BaseHeaderSize) + (3U << (shiftForWord())))) == ConstZero)
	 || ((longAt((lit + BaseHeaderSize) + (3U << (shiftForWord())))) == ConstMinusOne)));
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

	/* StackInterpreter>>#isPrimitiveFunctionPointerAnIndex */
static int
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
int
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 0x100) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
int
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}

	/* StackInterpreter>>#isSingleContext: */
static NoDbgRegParms int
isSingleContext(sqInt aContext)
{
	return (!((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())));
}


/*	Answer if aContext is married or widowed and still married.
	If a context is widowed then turn it into a single dead context. */

	/* StackInterpreter>>#isStillMarriedContext: */
static NoDbgRegParms sqInt
isStillMarriedContext(sqInt aContext)
{
	return (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(aContext)));
}


/*	Answer if aClosure is a vanilla BlockClosure as in the first Cog release,
	BlockClosure laid out as 
	'outerContext, startpc, numArgs. FullBlockClosure is laid out as
	outerContext, method, numArgs, receiver.
	So either answer true if we're not supporting FullBlockClosure, or test
	the startpc/method field. */

	/* StackInterpreter>>#isVanillaBlockClosure: */
static NoDbgRegParms int
isVanillaBlockClosure(sqInt aClosure)
{
	return ((((longAt((aClosure + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureStartPCIndex) << (shiftForWord()))))))) & 7) == 1);
}


/*	See if the argument is married to a live frame or not. i.e. see if there
	is a matching
	frame whose frameContext field is aOnceMarriedContext, or a forwarder to
	it. If aOnceMarriedContext is not married to a live frame, turn it into a
	bereaved single context.
	This version is for use during scavenging when stack references may be
	forwarded. Following what appear to be references to forwarded objects on
	the stack is dangerous;
	an instruction ponter may be correctly aligned and may point to bytes that
	just happen
	to look like a forwarder. So it is only safe to follow fields that we know
	are frameContext
	fields; hence the stack page is walked to check that aOnceMarriedContext
	is pointing to
	a live frame. This only has to happen during scavenging because after a
	become: all
	frameContext fields have been followed and so there is no need to follow
	forwarders.  */

	/* StackInterpreter>>#isWidowedContextDuringGC: */
static NoDbgRegParms sqInt
isWidowedContextDuringGC(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    char *maybeFrame;
    sqInt maybeFrameCtxt;
    sqInt referent;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    StackPage *thePage;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	maybeFrame = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) maybeFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) maybeFrame)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(maybeFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	if (!((isFree(thePage))
		 || (maybeFrame < ((thePage->headFP))))) {
		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - (smallIntegerTag()));
		if (((pointerForOop(longAt(maybeFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && (		/* begin frameHasContext: */
			((((usqInt)(longAt(maybeFrame + FoxMethod)))) < (startOfMemory())
			? ((longAt(maybeFrame + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((maybeFrame + FoxIFrameFlags) + 2)) != 0))) {
			/* On Spur we need to follow the context to check for a match, but since the VM is
			   only speculating about maybeFrame being a frame, and only speculating about
			   maybeContext being a context, we need to be sure before we can safely follow. */
			maybeFrameCtxt = longAt(maybeFrame + FoxThisContext);
			if ((isFrameonPage(maybeFrame, thePage))
			 && ((!((longAt(maybeFrameCtxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(maybeFrameCtxt));
				referent = longAt((maybeFrameCtxt + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent & (tagMask()))))
				 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				maybeFrameCtxt = referent;
				/* begin setFrameContext:to: */
				longAtput(maybeFrame + FoxThisContext, maybeFrameCtxt);
			}
			if (maybeFrameCtxt == aOnceMarriedContext) {
				/* It is still married! */
				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	assert(!(isOopForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	return 1;
}


/*	Answer if the argument is married to a live frame or not.
	This method is safe for use only when no frameContext fields may be
	forwarded (as maybe the case when scavenging). Post become: all
	frameContext fields are followed, and hence normally no following of
	frameContext fields is necessary. */
/*	i.e. inline into isWidowedContext: */

	/* StackInterpreter>>#isWidowedContextNoConvert: */
static NoDbgRegParms sqInt
isWidowedContextNoConvert(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {
		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - (smallIntegerTag()));
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && (		/* begin frameHasContext: */
			((((usqInt)(longAt(theFrame + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFrame + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFrame + FoxIFrameFlags) + 2)) != 0))) {
			assert(!(((isFrameonPage(theFrame, thePage))
 && (isForwarded(frameContext(theFrame))))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {
				/* It is still married! */
				return 0;
			}
		}
	}
	return 1;
}


/*	Answer if the argument is married to a live frame or not.
	If it is not, turn it into a bereaved single context. This version is safe
	for use
	only when no frameContext fields may be forwarded (as maybe the case
	when scavenging). Post become: all frameContext fields are followed, and
	hence normally no following of frameContext fields is necessary. But
	during a scavenge one must use isWidowedContextDuringGC:. */

	/* StackInterpreter>>#isWidowedContext: */
static NoDbgRegParms sqInt
isWidowedContext(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;
    sqInt widowed;


	/* begin isWidowedContextNoConvert: */
	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFrame = pointerForOop(senderOop - (smallIntegerTag()));
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {
		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((anInteger) & 7) == 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - (smallIntegerTag()));
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && (		/* begin frameHasContext: */
			((((usqInt)(longAt(theFrame + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFrame + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFrame + FoxIFrameFlags) + 2)) != 0))) {
			assert(!(((isFrameonPage(theFrame, thePage))
 && (isForwarded(frameContext(theFrame))))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {
				/* It is still married! */
				widowed = 0;
				goto l4;
			}
		}
	}
	widowed = 1;
	l4:	/* end isWidowedContextNoConvert: */;
	if (!widowed) {
		return 0;
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	assert(!(isOopForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	return 1;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
int
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt oopClass;
    sqInt tagBits;


	/* begin fetchClassOf: */
	if (((tagBits = oop & (tagMask()))) != 0) {
		oopClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))));
	}
	else {
		oopClass = fetchClassOfNonImm(oop);
	}
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		/* begin superclassOf: */
		objOop = longAt((oopClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, oopClass, objOop);
		}
		oopClass = objOop;
	}
	return 0;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOf: */
sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt oopClass;
    sqInt tagBits;


	/* begin fetchClassOf: */
	if (((tagBits = oop & (tagMask()))) != 0) {
		oopClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))));
	}
	else {
		oopClass = fetchClassOfNonImm(oop);
	}
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		/* begin superclassOf: */
		objOop = longAt((oopClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, oopClass, objOop);
		}
		oopClass = objOop;
	}
	return 0;
}


/*	Support for external primitives */

	/* StackInterpreter>>#is:MemberOf: */
sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oopClass;
    sqInt tagBits;

	oopClass = 
	/* begin fetchClassOf: */
(((tagBits = oop & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
		: fetchClassOfNonImm(oop));
	return classNameOfIs(oopClass, className);
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static NoDbgRegParms sqInt
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt objOop;


	/* begin numSlotsOf: */
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(classOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin lengthOf: */
	objOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))));
	/* begin lengthOf:format: */
	fmt = (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(objOop + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots11);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		return numSlots2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		return (numSlots2 << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots2 << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots2 << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots2;
	}
	return 0;
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#loadBitBltFrom: */
sqInt
loadBitBltFrom(sqInt bb)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

	/* StackInterpreter>>#loadInitialContext */
void
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;

	runLeakCheckerFor(GCModeFull);
	/* begin getClassTagOfLinkedList */
	objOop1 = longAt(((longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	obj = longAt((objOop1 + BaseHeaderSize) + (0U << (shiftForWord())));
	GIV(classLinkedListClassTag) = (longAt(obj)) & (classIndexMask());
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	activeContext = longAt((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int byte;
    char *className;
    sqInt cls;
    CogMethod *cogMethod;
    sqInt column;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt i;
    usqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt length;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt startIP;

	length = 0;
	if (((oop & (tagMask())) != 0)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	if (((cls = fetchClassOfNonImm(oop))) == null) {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
	}
	else {
		className = nameOfClasslengthInto(cls, (&length));
		fprintf(GIV(transcript),
				"%p: a(n) %.*s",
				((void *)oop),
				((int) length),
				className);
		fprintf(GIV(transcript),
				"(%" PRIxSQINT "=>%p)",
				(longAt(oop)) & (classIndexMask()),
				((void *)cls));
	}
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	fprintf(GIV(transcript),
			" format %" PRIxSQINT "",
			fmt);
	if (fmt > 5 /* begin lastPointerFormat */) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	else {
		if (		/* begin isIndexableFormat: */
			(fmt >= (arrayFormat()))
		 && ((fmt <= (weakArrayFormat()))
		 || (fmt >= (sixtyFourBitIndexableFormat())))) {
			/* begin lengthOf: */
			fmt1 = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
			/* begin numSlotsOfAny: */
			numSlots1 = byteAt(oop + 7);
			numSlots2 = (numSlots1 == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1);
			if (fmt1 <= 5 /* begin ephemeronFormat */) {
				len = numSlots2;
				goto l3;
			}
			if (fmt1 >= (firstByteFormat())) {
				/* bytes, including CompiledMethod */
				len = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
				goto l3;
			}
			if (fmt1 >= (firstShortFormat())) {
				len = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
				goto l3;
			}
			if (fmt1 >= (firstLongFormat())) {
				len = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
				goto l3;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat())) {
				len = numSlots2;
				goto l3;
			}
			len = 0;
	l3:	/* end lengthOf: */;
			fprintf(GIV(transcript),
					" size %" PRIdSQINT "",
					len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}
	/* begin printHeaderTypeOf:on: */
	fprintf(GIV(transcript),
			" hdr%d %c%c%c%c%c",
			((byteAt(oop + 7)) == (numSlotsMask())
		? 16
		: 8),
			(((((usqInt)((longAt(oop)))) >> (immutableBitShift())) & 1) != 0
		? 'i'
		: '.'),
			(((((usqInt)((longAt(oop)))) >> (rememberedBitShift())) & 1) != 0
		? 'r'
		: '.'),
			(((((usqInt)((longAt(oop)))) >> (pinnedBitShift())) & 1) != 0
		? 'p'
		: '.'),
			(((((usqInt)((longAt(oop)))) >> (markedBitFullShift())) & 1) != 0
		? 'm'
		: '.'),
			(((((usqInt)((longAt(oop)))) >> (greyBitShift())) & 1) != 0
		? 'g'
		: '.'));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" hash ");
	printHex((long32At(oop + 4)) & (identityHashHalfWordMask()));
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {
		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord()))))))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					((longAt(oop + BaseHeaderSize)) < 0
				? "indirect"
				: ((longAt(oop + BaseHeaderSize)) == 0
						? "pointer"
						: "direct")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord())))))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	if (fmt >= (firstCompiledMethodFormat())) {
		startIP = (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) / BytesPerWord;
	}
	else {
		/* begin numSlotsOf: */
		assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
		if (((numSlots = byteAt(oop + 7))) == (numSlotsMask())) {
			/* overflow slots; at least (2^32)-1 slots, which is plenty */
			startIP = ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8;
		}
		else {
			startIP = numSlots;
		}
	}
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((i - 1)) << (shiftForWord())))));
			/* begin space */
			printChar(' ');
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)(i - 1)));
			printChar(' ');
			printHex(fieldOop);
			/* begin space */
			printChar(' ');
			if ((i == 1)
			 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
				/* begin printMethodHeaderOop: */
				if ((				/* begin isCogMethodReference: */
					assert(((((fieldOop) & 7) == 1))
					 || (((((usqInt)fieldOop)) < (startOfMemory()))
					 && ((((usqInt)fieldOop)) >= (minCogMethodAddress())))),
				/* begin isNonIntegerObject: */
(!(fieldOop & (smallIntegerTag()))))) {
					cogMethod = methodFor(pointerForOop(fieldOop));
					if (!(cogMethod == null)) {
						printHex(fieldOop);
						/* begin space */
						printChar(' ');
						printDecodeMethodHeaderOop((cogMethod->methodHeader));
						goto l1;
					}
				}
				printDecodeMethodHeaderOop(fieldOop);
	l1:	/* end printMethodHeaderOop: */;
			}
			else {
				printOopShortInner(fieldOop);
			}
			cr();
		}
	}
	if (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		startIP = (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) + 1;
		/* begin lengthOf: */
		fmt2 = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOfAny: */
		numSlots11 = byteAt(oop + 7);
		numSlots3 = (numSlots11 == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt2 <= 5 /* begin ephemeronFormat */) {
			lastIndex = numSlots3;
			goto l5;
		}
		if (fmt2 >= (firstByteFormat())) {
			/* bytes, including CompiledMethod */
			lastIndex = (numSlots3 << (shiftForWord())) - (fmt2 & 7);
			goto l5;
		}
		if (fmt2 >= (firstShortFormat())) {
			lastIndex = (numSlots3 << ((shiftForWord()) - 1)) - (fmt2 & 3);
			goto l5;
		}
		if (fmt2 >= (firstLongFormat())) {
			lastIndex = (numSlots3 << ((shiftForWord()) - 2)) - (fmt2 & 1);
			goto l5;
		}
		if (fmt2 == (sixtyFourBitIndexableFormat())) {
			lastIndex = numSlots3;
			goto l5;
		}
		lastIndex = 0;
	l5:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p ",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = ((int) (byteAt((oop + BaseHeaderSize) + (index - 1))));
			fprintf(GIV(transcript),
					"%02x/%-+3d%c",
					byte,
					byte,
					(column == 8
				? '\n'
				: ' '));
			if (((column += 1)) > 8) {
				column = 1;
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"...");
		}
		if (((column >= 2) && (column <= 7))) {
			cr();
		}
	}
	else {
		if (startIP > lastIndex) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"...");
			cr();
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return ((((sqLong) methodHeader)) < 0
			? AltLongStoreBytecode
			: LongStoreBytecode);
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and classTag is found in the cache, set the values of
	'newMethod' and
	'primitiveFunctionPointer' and answer true. Otherwise, answer false. */

	/* StackInterpreter>>#lookupInMethodCacheSel:classTag: */
static NoDbgRegParms sqInt
lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;

	/* begin inlineLookupInMethodCacheSel:classTag: */
	/* shift drops two low-order zeros from addresses */
	hash = selector ^ (((sqInt)((usqInt)(classTag) << 2)));
	/* first probe */
	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	/* second probe */
	probe = (((usqInt)(hash)) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt)(hash)) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

	/* StackInterpreter>>#lookupMethodInClass: */
static NoDbgRegParms sqInt
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt tagBits;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(class));
	/* begin lookupBreakFor: */
	if ((breakSelectorLength <= 0)
	 && (	/* begin shouldBreakForLookupIn:given: */
		(breakLookupClassTag)
	 && ((class == breakLookupClassTag)
	 || (((long32At(class + 4)) & (identityHashHalfWordMask())) == breakLookupClassTag)))) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			/* MethodDict pointer is nil (hopefully due a swapped out stub)
			   -- raise exception #cannotInterpret:. */
			createActualMessageTo(class);
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorCannotInterpret) << (shiftForWord())))));
			/* begin sendBreakpoint:receiver: */
			sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), (((tagBits = 0)) != 0
				? tagBits
				: (longAt(null)) & (classIndexMask())));
			return lookupMethodInClass(superclassOf(currentClass));
		}
		/* begin lookupMethodInDictionary: */
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		length = (((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(nextSelector & (tagMask()))))
				 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop4 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					assert(isNonImmediate(objOop4));
					if ((!((longAt(objOop4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop4 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop4);
					}
					methodArray = objOop4;
					/* begin followField:ofObject: */
					objOop1 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					if (					/* begin isOopForwarded: */
						((!(objOop1 & (tagMask()))))
					 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop1);
					}
					GIV(newMethod) = objOop1;
					found = 1;
					goto l6;
				}
				index += 1;
			}
			found = 0;
			goto l6;
		}
		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((((GIV(messageSelector) & (tagMask())) != 0)
	? (GIV(messageSelector) >> 3)
	: (long32At(GIV(messageSelector) + 4)) & (identityHashHalfWordMask()))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l6;
			}
			if (			/* begin isOopForwarded: */
				((!(nextSelector & (tagMask()))))
			 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop2));
				if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop3 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop3 & (tagMask()))))
				 && ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop3);
				}
				GIV(newMethod) = objOop3;
				found = 1;
				goto l6;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l6;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l6:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		/* begin superclassOf: */
		objOop5 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop5));
		if ((!((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop5 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop5);
		}
		currentClass = objOop5;
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))));
	sendBreakpointclassTag(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), (long32At(class + 4)) & (identityHashHalfWordMask()));
	return lookupMethodInClass(class);
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

	/* StackInterpreter>>#lookupMNUInClass: */
static NoDbgRegParms sqInt
lookupMNUInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;


	/* begin lookupBreakFor: */
	if ((breakSelectorLength <= 0)
	 && (	/* begin shouldBreakForLookupIn:given: */
		(breakLookupClassTag)
	 && ((class == breakLookupClassTag)
	 || (((long32At(class + 4)) & (identityHashHalfWordMask())) == breakLookupClassTag)))) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			/* begin superclassOf: */
			objOop1 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop1));
			if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
			}
			GIV(lkupClass) = objOop1;
			return SelectorCannotInterpret;
		}
		/* begin lookupMethodInDictionary: */
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		length = (((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(nextSelector & (tagMask()))))
				 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop4 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					assert(isNonImmediate(objOop4));
					if ((!((longAt(objOop4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop4 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop4);
					}
					methodArray = objOop4;
					/* begin followField:ofObject: */
					objOop11 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					if (					/* begin isOopForwarded: */
						((!(objOop11 & (tagMask()))))
					 && ((!((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						objOop11 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop11);
					}
					GIV(newMethod) = objOop11;
					found = 1;
					goto l7;
				}
				index += 1;
			}
			found = 0;
			goto l7;
		}
		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((((GIV(messageSelector) & (tagMask())) != 0)
	? (GIV(messageSelector) >> 3)
	: (long32At(GIV(messageSelector) + 4)) & (identityHashHalfWordMask()))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l7;
			}
			if (			/* begin isOopForwarded: */
				((!(nextSelector & (tagMask()))))
			 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop2));
				if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop3 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop3 & (tagMask()))))
				 && ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop3);
				}
				GIV(newMethod) = objOop3;
				found = 1;
				goto l7;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l7;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l7:	/* end lookupMethodInDictionary: */;
		if (found) {
			addNewMethodToCache(class);
			return 0;
		}
		/* begin superclassOf: */
		objOop5 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop5));
		if ((!((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop5 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop5);
		}
		currentClass = objOop5;
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

	/* StackInterpreter>>#lookupOrdinaryNoMNUEtcInClass: */
static NoDbgRegParms sqInt
lookupOrdinaryNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt index;
    usqInt length;
    usqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt wrapAround;


	/* begin lookupBreakFor: */
	if ((breakSelectorLength <= 0)
	 && (	/* begin shouldBreakForLookupIn:given: */
		(breakLookupClassTag)
	 && ((class == breakLookupClassTag)
	 || (((long32At(class + 4)) & (identityHashHalfWordMask())) == breakLookupClassTag)))) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			/* begin superclassOf: */
			objOop1 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop1));
			if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop1);
			}
			GIV(lkupClass) = objOop1;
			return SelectorCannotInterpret;
		}
		/* begin lookupMethodInDictionary: */
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		length = (((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(nextSelector & (tagMask()))))
				 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
				}
				if (nextSelector == GIV(messageSelector)) {
					/* begin followObjField:ofObject: */
					objOop4 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					assert(isNonImmediate(objOop4));
					if ((!((longAt(objOop4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop4 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop4);
					}
					methodArray = objOop4;
					/* begin followField:ofObject: */
					objOop11 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
					if (					/* begin isOopForwarded: */
						((!(objOop11 & (tagMask()))))
					 && ((!((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						objOop11 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop11);
					}
					GIV(newMethod) = objOop11;
					found = 1;
					goto l7;
				}
				index += 1;
			}
			found = 0;
			goto l7;
		}
		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((((GIV(messageSelector) & (tagMask())) != 0)
	? (GIV(messageSelector) >> 3)
	: (long32At(GIV(messageSelector) + 4)) & (identityHashHalfWordMask()))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l7;
			}
			if (			/* begin isOopForwarded: */
				((!(nextSelector & (tagMask()))))
			 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == GIV(messageSelector)) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop2));
				if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop3 = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				if (				/* begin isOopForwarded: */
					((!(objOop3 & (tagMask()))))
				 && ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop3);
				}
				GIV(newMethod) = objOop3;
				found = 1;
				goto l7;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l7;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l7:	/* end lookupMethodInDictionary: */;
		if (found) {
			addNewMethodToCache(class);
			return 0;
		}
		/* begin superclassOf: */
		objOop5 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop5));
		if ((!((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop5 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop5);
		}
		currentClass = objOop5;
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Lookup selector in class. Answer the method or nil. This is a debugging
	routine. It does /not/ side-effect lookupClass or newMethod. */

	/* StackInterpreter>>#lookupSelector:inClass: */
sqInt
lookupSelectorinClass(sqInt selector, sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    usqInt index;
    usqInt length;
    usqInt mask;
    sqInt meth;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		/* begin followObjField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop));
		if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, currentClass, objOop);
		}
		dictionary = objOop;
		if (dictionary == GIV(nilObj)) {
			return null;
		}
		/* begin lookupMethodFor:InDictionary: */
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		length = (((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
		mask = (length - SelectorStart) - 1;
		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & ((((selector & (tagMask())) != 0)
	? (selector >> 3)
	: (long32At(selector + 4)) & (identityHashHalfWordMask()))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + (index << (shiftForWord())));
			if (nextSelector == GIV(nilObj)) {
				meth = null;
				goto l3;
			}
			if (			/* begin isOopForwarded: */
				((!(nextSelector & (tagMask()))))
			 && ((!((longAt(nextSelector)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
			}
			if (nextSelector == selector) {
				/* begin followObjField:ofObject: */
				objOop2 = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop2));
				if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop2);
				}
				methodArray = objOop2;
				/* begin followField:ofObject: */
				objOop1 = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << (shiftForWord())));
				if (				/* begin isOopForwarded: */
					((!(objOop1 & (tagMask()))))
				 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop1);
				}
				meth = objOop1;
				goto l3;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					meth = null;
					goto l3;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		meth = null;
	l3:	/* end lookupMethodFor:InDictionary: */;
		if (!(meth == null)) {
			return meth;
		}
		/* begin superclassOf: */
		objOop3 = longAt((currentClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop3));
		if ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop3 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop3);
		}
		currentClass = objOop3;
	}
	return null;
}


/*	Convert married contexts to widowed contexts, and in the CoInterpreter,
	map any machine code pcs to bytecode pcs, and then nil all slots beyond
	top of stack, so that the context can be resumed on any VM. */

	/* StackInterpreter>>#makeContextSnapshotSafe: */
static NoDbgRegParms void
makeContextSnapshotSafe(sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    usqInt numSlots;

	assert(isContext(ctxt));
	if (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		/* begin markContextAsDead: */
		assert(isContext(ctxt));
		assert(!(isOopForwarded(ctxt)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(ctxt)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		ensureContextHasBytecodePC(ctxt);
	}
	for (i = ((fetchStackPointerOf(ctxt)) + CtxtTempFrameStart), iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(ctxt)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(ctxt + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(ctxt - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(ctxt)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed */

	/* StackInterpreter>>#makePointwithxValue:yValue: */
usqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    usqInt pointResult;

	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassPoint) << (shiftForWord())))));
	numSlots = YIndex + 1;
	/* begin eeInstantiateSmallClass:numSlots: */
	assert((rawHashBitsOf(classObj)) != 0);
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	objFormat = (((usqInt)((((longAt((classObj + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)))) >> (fixedFieldsFieldWidth())) & (formatMask());
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots < 1
	? 8 /* begin allocationUnit */
	: numSlots * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
	l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)xValue << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (((sqInt)((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)yValue << 3) | 1));
	return pointResult;
}


/*	Map all oops in the interpreter's state to their new values 
	during garbage collection or a become: operation. */
/*	Assume: All traced variables contain valid oops. */

	/* StackInterpreter>>#mapInterpreterOops */
static void
mapInterpreterOops(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ipdelta;

	mapStackPages();
	/* begin mapMachineCode: */
	mapObjectReferencesInMachineCode(GIV(gcMode));
	mapPrimTraceLog();
	mapTraceLog();
	/* begin mapVMRegisters */
	ipdelta = 0;
	if (shouldRemapObj(GIV(method))) {
		ipdelta = (		/* begin method:includesAddress: */
			(GIV(instructionPointer) > GIV(method))
		 && (GIV(instructionPointer) < (GIV(method) + (((numSlotsOfAny(GIV(method))) << (shiftForWord())) + BaseHeaderSize)))
			? GIV(instructionPointer) - GIV(method)
			: 0);
		GIV(method) = remapObj(GIV(method));
		if (!(ipdelta == null)) {
			GIV(instructionPointer) = GIV(method) + ipdelta;
		}
	}
	if (	/* begin shouldRemapOop: */
		((!(GIV(newMethod) & (tagMask()))))
	 && (shouldRemapObj(GIV(newMethod)))) {
		/* maybe oop due to object-as-method */
		ipdelta = ((!ipdelta)
		 && (		/* begin method:includesAddress: */
			(GIV(instructionPointer) > GIV(newMethod))
		 && (GIV(instructionPointer) < (GIV(newMethod) + (((numSlotsOfAny(GIV(newMethod))) << (shiftForWord())) + BaseHeaderSize))))
			? GIV(instructionPointer) - GIV(newMethod)
			: 0);
		GIV(newMethod) = remapObj(GIV(newMethod));
		if (!(ipdelta == null)) {
			GIV(instructionPointer) = GIV(newMethod) + ipdelta;
		}
	}
	/* begin mapProfileState */
	if (shouldRemapObj(GIV(profileProcess))) {
		GIV(profileProcess) = remapObj(GIV(profileProcess));
	}
	if (shouldRemapObj(GIV(profileMethod))) {
		GIV(profileMethod) = remapObj(GIV(profileMethod));
	}
	if (shouldRemapObj(GIV(profileSemaphore))) {
		GIV(profileSemaphore) = remapObj(GIV(profileSemaphore));
	}
#  if LRPCheck
	/* The longRunningPrimitiveCheckMethod (LRPCM) is sampled in an interrupt.  Be very careful with it.
	   If longRunningPrimitiveCheckSequenceNumber (LRPCSN) = statCheckForEvents then LRPCM has
	   been recenty sampled and could be mapped or not, but it must be newMethod and we can simply
	   copy newMethod.  If LRPCSN ~= statCheckForEvents then LRPCM must be some extant object and
	   needs to be remapped. */
	sqLowLevelMFence();
	if (!(GIV(longRunningPrimitiveCheckMethod) == null)) {
		if (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)) {
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
		}
		else {
			if (shouldRemapObj(GIV(longRunningPrimitiveCheckMethod))) {
				GIV(longRunningPrimitiveCheckMethod) = remapObj(GIV(longRunningPrimitiveCheckMethod));
			}
		}
		sqLowLevelMFence();
	}
	if (!(GIV(longRunningPrimitiveCheckSemaphore) == null)) {
		if (shouldRemapObj(GIV(longRunningPrimitiveCheckSemaphore))) {
			GIV(longRunningPrimitiveCheckSemaphore) = remapObj(GIV(longRunningPrimitiveCheckSemaphore));
		}
	}
#  endif // LRPCheck

	if ((GIV(tempOop) != 0)
	 && (	/* begin shouldRemapOop: */
		((!(GIV(tempOop) & (tagMask()))))
	 && (shouldRemapObj(GIV(tempOop))))) {
		GIV(tempOop) = remapObj(GIV(tempOop));
	}
	if ((GIV(tempOop2) != 0)
	 && (	/* begin shouldRemapOop: */
		((!(GIV(tempOop2) & (tagMask()))))
	 && (shouldRemapObj(GIV(tempOop2))))) {
		GIV(tempOop2) = remapObj(GIV(tempOop2));
	}
}


/*	The prim trace log is a circular buffer of objects. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* StackInterpreter>>#mapPrimTraceLog */
static void
mapPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt entryOop;
    sqInt i;
    sqInt remainder;

	if ((GIV(primTraceLog)[
		/* begin safe:mod: */
(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
			? remainder + PrimTraceLogSize
			: remainder)]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			entryOop = GIV(primTraceLog)[i];
			if ((entryOop != 0)
			 && (			/* begin shouldRemapOop: */
				((!(entryOop & (tagMask()))))
			 && (shouldRemapObj(entryOop)))) {
				GIV(primTraceLog)[i] = (remapObj(entryOop));
			}
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		entryOop = GIV(primTraceLog)[i];
		if ((entryOop != 0)
		 && (		/* begin shouldRemapOop: */
			((!(entryOop & (tagMask()))))
		 && (shouldRemapObj(entryOop)))) {
			GIV(primTraceLog)[i] = (remapObj(entryOop));
		}
	}
}


/*	The prim trace log is a circular buffer of objects. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* StackInterpreter>>#markAndTracePrimTraceLog */
static void
markAndTracePrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt entryOop;
    sqInt i;
    sqInt remainder;

	if ((GIV(primTraceLog)[
		/* begin safe:mod: */
(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
			? remainder + PrimTraceLogSize
			: remainder)]) == 0) {
		return;
	}
	if ((GIV(primTraceLog)[GIV(primTraceLogIndex)]) != 0) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			entryOop = GIV(primTraceLog)[i];
			if ((entryOop != 0)
			 && ((!(entryOop & (tagMask()))))) {
				markAndTrace(entryOop);
			}
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		entryOop = GIV(primTraceLog)[i];
		if ((entryOop != 0)
		 && ((!(entryOop & (tagMask()))))) {
			markAndTrace(entryOop);
		}
	}
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

	/* StackInterpreter>>#markAndTraceStackPages: */
static NoDbgRegParms sqInt
markAndTraceStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt context;
    sqInt i;
    void *pointer;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;

	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(thePage))) {
				markAndTraceStackPage(thePage);
			}
		}
		return null;
	}
	if (!GIV(stackPage)) {
		return null;
	}
	thePage = GIV(stackPage);
	do {
		markAndTraceStackPage(thePage);
		theFP = (thePage->baseFP);
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		thePage1 = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil))));
		context = callerContextOrNil;
		if ((		/* begin isContext: */
			((!(context & (tagMask()))))
		 && (((longAt(context)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && ((((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(context)))))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			pointer = pointerForOop(senderOop - (smallIntegerTag()));
			/* begin stackPageFor: */
			thePage = stackPageAtpages(
				(assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage))),
				GIV(pages));
			assert(!(isFree(thePage)));
		}
	} while(((thePage->trace)) < StackPageTraced);
	return 0;
}


/*	Trace any untraced pages */

	/* StackInterpreter>>#markAndTraceUntracedReachableStackPages */
static void
markAndTraceUntracedReachableStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	do {
		foundToBeTracedPage = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if ((!(isFree(thePage)))
			 && (((thePage->trace)) == StackPageReachedButUntraced)) {
				foundToBeTracedPage = 1;
				markAndTraceStackPage(thePage);
			}
		}
	} while(foundToBeTracedPage);
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the state .
 */

	/* StackInterpreter>>#marriedContext:pointsTo:stackDeltaForCurrentFrame: */
static NoDbgRegParms sqInt
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *rcvrOffset;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    char *theSP;


	/* begin frameOfMarriedContext: */
	senderOop = longAt((spouseContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	theFP = pointerForOop(senderOop - (smallIntegerTag()));
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		theSP = findSPOfon(theFP, thePage);
	}
	if ((((anOop) & 7) == 1)) {
		/* Check stack and instruction pointer fields. */
		if ((anOop == ((((/* begin stackPointerIndexForFrame:WithSP: */
	((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
	? (((usqInt)(((theFP + FoxMFReceiver) - theSP))) >> (shiftForWord())) + (((mframeCogMethod(theFP))->cmNumArgs))
	: (((usqInt)(((theFP + FoxIFReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxIFrameFlags) + 1)))) << 3) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext)))) {
			return 1;
		}
	}
	else {
		/* Check method and sender fields, avoiding unnecessarily reifying sender context. */
		if (anOop == (		/* begin frameMethodObject: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((mframeHomeMethod(theFP))->methodObject)
			: longAt(theFP + FoxMethod)))) {
			return 1;
		}
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			if (anOop == (frameCallerContext(theFP))) {
				return 1;
			}
		}
		else {
			if ((			/* begin frameHasContext: */
				((((usqInt)(longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxMethod)))) < (startOfMemory())
				? ((longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt(((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxIFrameFlags) + 2)) != 0))
			 && (anOop == (longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxThisContext)))) {
				return 1;
			}
		}
	}
	rcvrOffset = 
	/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
		? theFP + FoxMFReceiver
		: theFP + FoxIFReceiver);
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + (frameStackedReceiverOffset(theFP));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Establish aContext at the base of a new stackPage, make the stackPage the
	active one and set-up the interreter registers. This is used to boot the
	system and bring it back after a snapshot. */

	/* StackInterpreter>>#marryContextInNewStackPageAndInitializeInterpreterRegisters: */
static NoDbgRegParms void
marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    StackPage *newPage;
    sqInt top;

	assert(!GIV(stackPage));
	newPage = makeBaseFrameFor(aContext);
	/* begin setStackPageAndLimit: */
	assert(newPage);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	aMethodObj = longAt(((GIV(stackPage)->headFP)) + FoxMethod);
	/* begin setMethod: */
	assert((((usqInt)aMethodObj)) >= (startOfMemory()));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
}


/*	Marry an unmarried frame. This means creating a spouse context
	initialized with a subset of the frame's state (state through the last
	argument) that references the frame. */

	/* StackInterpreter>>#marryFrame:SP: */
static NoDbgRegParms usqInt
marryFrameSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    CogMethod *cogMethod;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt i;
    sqInt methodFieldOrObj;
    usqInt numArgs;
    int numSlots;
    sqInt numStack;
    sqInt rcvr;
    usqInt theContext;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;


	/* begin marryFrame:SP:copyTemps: */
	assert(!(frameHasContext(theFP)));
	assert(!(isBaseFrame(theFP)));
	assert(addressCouldBeOop(longAt(theSP)));
	methodFieldOrObj = longAt(theFP + FoxMethod);
	if ((((usqInt)methodFieldOrObj)) < (startOfMemory())) {
		/* inline (self isMachineCodeFrame: theFP) */
		longAtput(theFP + FoxMethod, methodFieldOrObj + MFMethodFlagHasContextFlag);
		cogMethod = ((CogMethod *) (methodFieldOrObj & MFMethodMask));
		numArgs = (cogMethod->cmNumArgs);
		if (((cogMethod->cmType)) >= CMMethod) {
			closureOrNil = ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)
				? longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (numArgs << (shiftForWord()))))
				: GIV(nilObj));
		}
		else {
			cogMethod = 
			/* begin cmHomeMethod */
(((((CogBlockMethod *) cogMethod))->cpicHasMNUCaseOrCMIsFullBlock)
				? ((CogMethod *) (((CogBlockMethod *) cogMethod)))
				: ((CogMethod *) ((((usqInt)(((CogBlockMethod *) cogMethod)))) - (((((CogBlockMethod *) cogMethod))->homeOffset)))));
			closureOrNil = longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (numArgs << (shiftForWord()))));
		}
		numSlots = ((((cogMethod->methodHeader)) & LargeContextBit) != 0
			? LargeContextSlots
			: SmallContextSlots);
		methodFieldOrObj = (cogMethod->methodObject);
		rcvr = longAt(theFP + FoxMFReceiver);
		numStack = (((usqInt)(((theFP + FoxMFReceiver) - theSP))) >> (shiftForWord())) + numArgs;
	}
	else {
		/* begin setIFrameHasContext: */
		byteAtput((theFP + FoxIFrameFlags) + 2, 1);
		numArgs = byteAt((theFP + FoxIFrameFlags) + 1);
		if (methodHeaderIndicatesLargeFrame(methodHeaderOf(methodFieldOrObj))) {
			numSlots = LargeContextSlots;
		}
		else {
			numSlots = SmallContextSlots;
		}
		closureOrNil = ((byteAt((theFP + FoxIFrameFlags) + 3)) != 0
			? longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + (numArgs << (shiftForWord()))))
			: GIV(nilObj));
		rcvr = longAt(theFP + FoxIFReceiver);
		numStack = (((usqInt)(((theFP + FoxIFReceiver) - theSP))) >> (shiftForWord())) + numArgs;
	}
	theContext = allocateNewSpaceSlotsformatclassIndex(numSlots, indexablePointersFormat(), ClassMethodContextCompactIndex);
	/* begin setFrameContext:to: */
	longAtput(theFP + FoxThisContext, theContext);
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer(theFP)) + (smallIntegerTag());
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), valuePointer);
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(pointerForOop(longAt(theFP + FoxSavedFP)))) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(pointerForOop(longAt(theFP + FoxSavedFP)))) + (smallIntegerTag());
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)numStack << 3) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))), methodFieldOrObj);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord())))), closureOrNil);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(theContext)));
	longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord())))), rcvr);
	for (i = 1; i <= numArgs; i += 1) {
		valuePointer2 = 
		/* begin temporary:in: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((i - 1) < ((frameNumArgs = ((mframeCogMethod(theFP))->cmNumArgs)))
					? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (i - 1)) * BytesPerWord))
					: longAt(((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (i - 1)) * BytesPerWord)))
			: 
				/* begin itemporary:in: */
((i - 1) < ((frameNumArgs1 = byteAt((theFP + FoxIFrameFlags) + 1)))
					? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs1 - (i - 1)) * BytesPerWord))
					: longAt(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (i - 1)) * BytesPerWord))));
		assert(!(isOopForwarded(theContext)));
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), valuePointer2);
	}
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(theContext)));
		longAtput((theContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), GIV(nilObj));
	}
	assert(frameHasContext(theFP));
	assert((frameOfMarriedContext(theContext)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext)));
	return theContext;
}


/*	Assert-only check for leaks after external prim calls if checkForLeaks
	includes the GCCheckPrimCall flag.
	This is ionly really useful from a low-level C debugger, hence no
	accessors for checkedPluginName.
 */

	/* StackInterpreter>>#maybeLeakCheckExternalPrimCall: */
static NoDbgRegParms sqInt
maybeLeakCheckExternalPrimCall(sqInt aMethodObj)
{
	if ((((checkForLeaks & GCCheckPrimCall) != 0))
	 && (((primitiveIndexOf(aMethodObj)) == PrimNumberExternalCall)
	 && (checkedPluginName == (fetchPointerofObject(0, longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))))))))) {
		runLeakCheckerFor(GCCheckPrimCall);
	}
	return 1;
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence.
	With full blocks as of 9/2016 the last literal of a CompiledBlock is a
	back pointer
	to the enclosing block or compiled method. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
sqInt
maybeSelectorOfMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeSelector;
    usqInt numSlots;
    sqInt offset;
    sqInt offset1;
    sqInt penultimateLiteral;
    sqInt ultimateLiteral;

	assert(isOopCompiledMethod(methodObj));
	/* begin ultimateLiteralOf: */
	assert(isOopCompiledMethod(methodObj));
	offset = (literalCountOf(methodObj)) - 1;
	ultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (	/* begin isOopCompiledMethod: */
		((!(ultimateLiteral & (tagMask()))))
	 && (((((usqInt)((longAt(ultimateLiteral)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))) {
		return maybeSelectorOfMethod(ultimateLiteral);
	}
	/* begin penultimateLiteralOf: */
	assert(isOopCompiledMethod(methodObj));
	offset1 = (literalCountOf(methodObj)) - 2;
	penultimateLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)((offset1 + LiteralStart)) << (shiftForWord())))));
	if (	/* begin isWordsOrBytes: */
		((!(penultimateLiteral & (tagMask()))))
	 && (isWordsOrBytesNonImm(penultimateLiteral))) {
		return (((longAt(penultimateLiteral)) & (classIndexMask())) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))))
			? penultimateLiteral
			: 0);
	}
	return ((	/* begin isPointers: */
		((!(penultimateLiteral & (tagMask()))))
	 && (((((usqInt)((longAt(penultimateLiteral)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
	 && ((((	/* begin numSlotsOf: */
		assert((classIndexOf(penultimateLiteral)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(penultimateLiteral + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(penultimateLiteral - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) >= 2)
	 && (((longAt((penultimateLiteral + BaseHeaderSize) + (0U << (shiftForWord())))) == methodObj)
	 && (((maybeSelector = longAt((penultimateLiteral + BaseHeaderSize) + (1U << (shiftForWord())))),
	(		/* begin isWordsOrBytes: */
			((!(maybeSelector & (tagMask()))))
		 && (isWordsOrBytesNonImm(maybeSelector)))
		 && (((longAt(maybeSelector)) & (classIndexMask())) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))))))))))
		? maybeSelector
		: 0);
}

	/* StackInterpreter>>#methodArgumentCount */
sqInt
methodArgumentCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(argumentCount);
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer)
{
    sqInt offset;

	offset = (literalCountOf(methodPointer)) - 1;
	/* begin literal:ofMethod: */
	return longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	Answer the method class of a method which is the value of an Association
	in the last literal,
	or answer nil if there isn't one.
	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line. */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt objOop;
    sqInt objOop1;
    sqInt offset;

	/* begin followLiteral:ofMethod: */
	offset = (literalCountOf(methodPointer)) - 1;
	/* begin followField:ofObject: */
	objOop = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(offset + LiteralStart, methodPointer, objOop);
	}
	literal = objOop;
	if ((literal != GIV(nilObj))
	 && (	/* begin isPointers: */
		((!(literal & (tagMask()))))
	 && (((((usqInt)((longAt(literal)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))) {
		/* filters out fullBlock last literal */
		assert((numSlotsOf(literal)) > ValueIndex);
		/* begin followField:ofObject: */
		objOop1 = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop1 & (tagMask()))))
		 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, literal, objOop1);
		}
		return objOop1;
	}
	else {
		return GIV(nilObj);
	}
}

	/* StackInterpreter>>#methodHeaderIndicatesLargeFrame: */
static NoDbgRegParms int
methodHeaderIndicatesLargeFrame(sqInt methodHeader)
{
	return (methodHeader & LargeContextBit) != 0;
}

	/* StackInterpreter>>#methodPrimitiveIndex */
sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt methodHeader;

	if (!((addressCouldBeObj(GIV(newMethod)))
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		return -1;
	}
	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	/* begin primitiveIndexOfMethod:header: */
	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnBool: */
sqInt
methodReturnBool(sqInt boolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (boolean
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. */

	/* StackInterpreter>>#methodReturnFloat: */
sqInt
methodReturnFloat(double aFloat)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), floatObjectOf(aFloat));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnInteger: */
sqInt
methodReturnInteger(sqInt integer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 3) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method */

	/* StackInterpreter>>#methodReturnReceiver */
sqInt
methodReturnReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!((failed())));
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	return 0;
}


/*	Attempt to answer a ByteString for a given C string as the result of a
	primitive. 
 */

	/* StackInterpreter>>#methodReturnString: */
NeverInline sqInt
methodReturnString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt result;
    char *sp;

	assert(!((failed())));
	if (aCString == null) {
		GIV(primFailCode) = PrimErrOperationFailed;
	}
	else {
		result = stringForCString(aCString);
		if (result == null) {
			GIV(primFailCode) = PrimErrNoMemory;
		}
		else {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
			GIV(stackPointer) = sp;
		}
	}
	return 0;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnValue: */
sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* StackInterpreter>>#methodUsesAlternateBytecodeSet: */
int
methodUsesAlternateBytecodeSet(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodHeader;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(aMethodObj));
	header = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	/* begin headerIndicatesAlternateBytecodeSet: */
	return (((sqLong) methodHeader)) < 0;
}


/*	Answer if aMethodObj contains a primitive and uses the primitive error
	code. 
 */

	/* StackInterpreter>>#methodUsesPrimitiveErrorCode: */
static NoDbgRegParms sqInt
methodUsesPrimitiveErrorCode(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt methodHeader;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(aMethodObj));
	header = longAt((aMethodObj + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	return ((	/* begin primitiveIndexOfMethod:header: */
		(((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (aMethodObj + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0)) > 0)
	 && ((	/* begin longStoreBytecodeForHeader: */
		((((sqLong) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode)) == (fetchByteofObject(((((assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop) + 3 /* begin sizeOfCallPrimitiveBytecode: */, aMethodObj)));
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

	/* StackInterpreter>>#moduleUnloaded: */
EXPORT(void)
moduleUnloaded(char *aModuleName)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {
		/* Surface plugin went away. Should never happen. But  then, who knows */
		showSurfaceFn = 0;
	}
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static NoDbgRegParms char *
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;
    usqInt numSlots1;


	/* begin numSlotsOf: */
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(classOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord())))));
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClass(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))));
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))))),
		/* begin isBytes: */
((!(maybeNameOop & (tagMask()))))
			 && (((((usqInt)((longAt(maybeNameOop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop);
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass:lengthInto: */
static NoDbgRegParms char *
nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;
    usqInt numSlots1;


	/* begin numSlotsOf: */
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(classOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord())))));
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClasslengthInto(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))), lengthPtr);
		}
		lengthPtr[0] = 9;
		return "bad class";
	}
	if ((numSlots > GIV(classNameIndex))
	 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord())))))),
	/* begin isBytes: */
((!(maybeNameOop & (tagMask()))))
		 && (((((usqInt)((longAt(maybeNameOop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))))) {
		lengthPtr[0] = (numBytesOfBytes(maybeNameOop));
		return firstIndexableField(maybeNameOop);
	}
	lengthPtr[0] = 9;
	return "bad class";
}


/*	Answer true if there are no marked contexts on thePage. */

	/* StackInterpreter>>#noMarkedContextsOnPage: */
static NoDbgRegParms sqInt
noMarkedContextsOnPage(StackPage *thePage)
{
    char *theFP;

	assert(!(isFree(thePage)));
	theFP = (thePage->headFP);
	do {
		if (		/* begin frameHasContext: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
			assert(isContext(frameContext(theFP)));
			if (((((usqInt)((longAt(longAt(theFP + FoxThisContext))))) >> (markedBitFullShift())) & 1) != 0) {
				return 0;
			}
		}
	} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
	return 1;
}


/*	Answer the number of effective pointer fields in the given context. */

	/* StackInterpreter>>#numSlotsOfMarriedContext: */
static NoDbgRegParms sqInt
numSlotsOfMarriedContext(sqInt aContext)
{
    sqInt contextSize;

	contextSize = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
	return CtxtTempFrameStart + contextSize;
}

	/* StackInterpreter>>#numStkPages */
static sqInt
numStkPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(numStackPages);
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
sqInt
objCouldBeClassObj(sqInt objOop)
{
    sqInt fieldOop;

	return (((((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
	 && (((numSlotsOfAny(objOop)) > InstanceSpecificationIndex)
	 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))))),
	((addressCouldBeObj(fieldOop))
		 && ((((((usqInt)((longAt(fieldOop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
		 || ((		/* begin isOopForwarded: */
			((!(fieldOop & (tagMask()))))
		 && ((!((longAt(fieldOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))
		 && (isPointers(followForwarded(fieldOop))))))
		 && (((fieldOop = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))))),
		((addressCouldBeObj(fieldOop))
			 && ((((((usqInt)((longAt(fieldOop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
			 || ((			/* begin isOopForwarded: */
				((!(fieldOop & (tagMask()))))
			 && ((!((longAt(fieldOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))
			 && (isPointers(followForwarded(fieldOop))))))
			 && (((((longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord()))))))) & 7) == 1)))))));
}

	/* StackInterpreter>>#object:equalsString: */
static NoDbgRegParms sqInt
objectequalsString(sqInt anOop, char *aCString)
{
    sqInt len;

	len = strlen(aCString);
	return 
	/* begin object:equalsString:ofSize: */
(((!(anOop & (tagMask()))))
	 && (((((usqInt)((longAt(anOop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
	 && ((!(((((usqInt)((longAt(anOop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && (((numBytesOfBytes(anOop)) == len)
	 && ((strncmp(aCString, firstIndexableField(anOop), len)) == 0)));
}


/*	This is the entry-point for plugins and primitives that wish to reacquire
	the VM after having
	released it via disownVM or callbacks that want to acquire it without
	knowing their ownership
	status. While this exists for the threaded FFI VM we use it to reset
	newMethod and the
	argumentCount after a callback.
	
	Answer 0 if the current thread is known to the VM (and on return owns the
	VM). Answer 1 if the current thread is unknown to the VM and takes
	ownership. Answer -1 if the current thread is unknown to the VM and fails
	to take ownership. */

	/* StackInterpreter>>#ownVM: */
sqInt
ownVM(void *vmHandle)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    char *sp;
    char *sp1;

	assert((isOopCompiledMethod(GIV(newMethod)))
	 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
	if (!vmHandle) {
		assert(GIV(primFailCode) == 0);
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), (((usqInt)GIV(argumentCount) << 3) | 1));
		GIV(stackPointer) = sp1;
		return 1;
	}
	flags = ((sqInt) vmHandle);
	if (((flags & DisownVMForFFICall) != 0)) {
		GIV(ffiCalloutVMHandle) = null;
	}
	return 0;
}

	/* StackInterpreter>>#pcPreviousTo:inSqueakV3PlusClosuresOrSistaV1Method: */
sqInt
pcPreviousToinSqueakV3PlusClosuresOrSistaV1Method(sqInt theIP, sqInt aMethod)
{
    sqInt byte;
    sqInt byte1;
    unsigned char bytecode;
    static unsigned char  extensionSizes[] = {
		2, 2, 2, 2, 3, 2, 2, 1, 1, 1, 2, 3, 3, 3, 3, 4
	};
    sqInt previousPC;
    sqInt previousPC1;
    sqInt thisIP;
    sqInt thisIP1;

	if (methodUsesAlternateBytecodeSet(aMethod)) {
		/* begin pcPreviousTo:inSistaV1Method: */
		thisIP = ((((literalCountOf(aMethod)) + LiteralStart) * BytesPerOop) + aMethod) + BaseHeaderSize;
		assert(oopisLessThan(thisIP, theIP));
		while (oopisLessThan(thisIP, theIP)) {
			previousPC = thisIP;
			do {
				byte = byteAt(thisIP);
				thisIP += 
				/* begin sizeOfSistaV1Bytecode: */
(byte < 224
					? 1
					: (byte < 0xF8
							? 2
							: 3));
			} while(((byte >= 224) && (byte <= 225)));
		}
		return previousPC;
	}
	/* begin pcPreviousTo:inSqueakV3PlusClosuresMethod: */
	thisIP1 = ((((literalCountOf(aMethod)) + LiteralStart) * BytesPerOop) + aMethod) + BaseHeaderSize;
	assert(oopisLessThan(thisIP1, theIP));
	while (oopisLessThan(thisIP1, theIP)) {
		previousPC1 = thisIP1;
		byte1 = byteAt(thisIP1);
		/* begin sizeOfSqueakV3Bytecode: */
		bytecode = ((unsigned char) ((byte1 <= 125
	? 1
	: (byte1 >= 176
			? 1
			: (byte1 >= 160
					? 2
					: (byte1 >= 144
							? 1
							: (byte1 >= 128
									? extensionSizes[byte1 - 128]
									: (assertf("illegal bytecode in sizeOfSqueakV3Bytecode:"),
										1))))))));
		thisIP1 += bytecode;
	}
	return previousPC1;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#popStack */
sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop: */
sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop:thenPush: */
void
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

	/* StackInterpreter>>#positiveMachineIntegerFor: */
static NoDbgRegParms sqInt
positiveMachineIntegerFor(usqIntptr_t value)
{
    sqInt resultObj;

	resultObj = positive64BitIntegerFor(value);
	return resultObj;
}


/*	Update the displayBits after a GC may have moved it.
	Answer if the displayBits appear valid. The wrinkle here is that the
	displayBits could be a surface handle. */

	/* StackInterpreter>>#postGCUpdateDisplayBits */
static sqInt
postGCUpdateDisplayBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *bitsNow;
    sqInt bitsOop;
    sqInt displayObj;
    sqInt oop;
    sqInt oop1;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord())))));
	if (!((		/* begin isPointers: */
			((!(displayObj & (tagMask()))))
		 && (((((usqInt)((longAt(displayObj)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && ((lengthOf(displayObj)) >= 4))) {
		return 0;
	}
	/* begin followOopField:ofObject: */
	oop = longAt((displayObj + BaseHeaderSize) + (0U << (shiftForWord())));
	if (	/* begin isOopForwarded: */
		((!(oop & (tagMask()))))
	 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		oop = fixFollowedFieldofObjectwithInitialValue(0, displayObj, oop);
	}
	bitsOop = oop;
	if ((bitsOop == GIV(nilObj))
	 || ((((bitsOop) & 7) == 1))) {
		/* It's a surface; our work here is done... */
		return 1;
	}
	assert((addressCouldBeObj(bitsOop))
	 && (isWordsOrBytes(bitsOop)));
	if (!(((((usqInt)((longAt(bitsOop)))) >> (pinnedBitShift())) & 1) != 0)) {
		if (GIV(stackPage)) {
			/* If stackPage is nil we're snapshotting and now is not the time to pin. */
			pinObject(bitsOop);
			/* begin followOopField:ofObject: */
			oop1 = longAt((displayObj + BaseHeaderSize) + (0U << (shiftForWord())));
			if (			/* begin isOopForwarded: */
				((!(oop1 & (tagMask()))))
			 && ((!((longAt(oop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				oop1 = fixFollowedFieldofObjectwithInitialValue(0, displayObj, oop1);
			}
			bitsOop = oop1;
		}
		bitsNow = firstIndexableField(bitsOop);
		if (displayBits != bitsNow) {
			displayBits = bitsNow;
			ioNoteDisplayChangedwidthheightdepth(displayBits, displayWidth, displayHeight, displayDepth);
		}
	}
	return 1;
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

	/* StackInterpreter>>#primitiveEventProcessingControl */
EXPORT(void)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int enabled;
    char *sp;
    char *sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				return;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}

	/* StackInterpreter>>#primitiveFloatEqual:toArg: */
static NoDbgRegParms int
primitiveFloatEqualtoArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;


	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (rcvr == arg) {
		if ((((argOop) & 7) == 1)) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			return (((sqInt)rcvr)) == ((argOop >> 3));
		}
		if ((((rcvrOop) & 7) == 1)) {
			/* Same when used from bytecodePrim...
			   note that rcvr and arg cannot be both integer (case is already handled) */
			return ((rcvrOop >> 3)) == (((sqInt)arg));
		}
	}
	return rcvr == arg;
}

	/* StackInterpreter>>#primitiveFloatGreaterOrEqual:toArg: */
static NoDbgRegParms int
primitiveFloatGreaterOrEqualtoArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;


	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (rcvr == arg) {
		if ((((argOop) & 7) == 1)) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			return (((sqInt)rcvr)) >= ((argOop >> 3));
		}
		if ((((rcvrOop) & 7) == 1)) {
			/* Same when used from bytecodePrim...
			   note that rcvr and arg cannot be both integer (case is already handled) */
			return ((rcvrOop >> 3)) >= (((sqInt)arg));
		}
	}
	return rcvr >= arg;
}

	/* StackInterpreter>>#primitiveFloatGreater:thanArg: */
static NoDbgRegParms int
primitiveFloatGreaterthanArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;


	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (rcvr == arg) {
		if ((((argOop) & 7) == 1)) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			return (((sqInt)rcvr)) > ((argOop >> 3));
		}
		if ((((rcvrOop) & 7) == 1)) {
			/* Same when used from bytecodePrim...
			   note that rcvr and arg cannot be both integer (case is already handled) */
			return ((rcvrOop >> 3)) > (((sqInt)arg));
		}
	}
	return rcvr > arg;
}

	/* StackInterpreter>>#primitiveFloatLessOrEqual:toArg: */
static NoDbgRegParms int
primitiveFloatLessOrEqualtoArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;


	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (rcvr == arg) {
		if ((((argOop) & 7) == 1)) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			return (((sqInt)rcvr)) <= ((argOop >> 3));
		}
		if ((((rcvrOop) & 7) == 1)) {
			/* Same when used from bytecodePrim...
			   note that rcvr and arg cannot be both integer (case is already handled) */
			return ((rcvrOop >> 3)) <= (((sqInt)arg));
		}
	}
	return rcvr <= arg;
}

	/* StackInterpreter>>#primitiveFloatLess:thanArg: */
static NoDbgRegParms int
primitiveFloatLessthanArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqLong bits;
    usqLong bits1;
    double rcvr;
    double result;
    double result1;
    usqLong rot;
    usqLong rot1;
    sqInt tagBits;
    sqInt tagBits1;
    double value;
    double value1;


	/* begin loadFloatOrIntFrom: */
	if (((tagBits = rcvrOop & (tagMask()))) != 0) {
		if (tagBits == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(rcvrOop));
			rot = ((((usqInt)rcvrOop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			rcvr = value;
			goto l2;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits == (smallIntegerTag()))) {
			rcvr = ((double) ((rcvrOop >> 3)) );
			goto l2;
		}
	}
	else {
		if (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
			rcvr = result;
			goto l2;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
	l2:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((tagBits1 = argOop & (tagMask()))) != 0) {
		if (tagBits1 == (smallFloatTag())) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(argOop));
			rot1 = ((((usqInt)argOop))) >> (numTagBits());
			if (rot1 > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot1 += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot1 = (rot1 << 0x3F) + (((((usqInt)rot1))) >> 1);
			bits1 = rot1;
			memcpy((&value1), (&bits1), sizeof(value1));
			arg = value1;
			goto l4;
		}
		if ((primitiveDoMixedArithmetic())
		 && (tagBits1 == (smallIntegerTag()))) {
			arg = ((double) ((argOop >> 3)) );
			goto l4;
		}
	}
	else {
		if (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex) {
			fetchFloatAtinto(argOop + BaseHeaderSize, result1);
			arg = result1;
			goto l4;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
	l4:	/* end loadFloatOrIntFrom: */;
	if (rcvr == arg) {
		if ((((argOop) & 7) == 1)) {
			/* Resolve case of ambiguity so as to have comparison of exact values */
			return (((sqInt)rcvr)) < ((argOop >> 3));
		}
		if ((((rcvrOop) & 7) == 1)) {
			/* Same when used from bytecodePrim...
			   note that rcvr and arg cannot be both integer (case is already handled) */
			return ((rcvrOop >> 3)) < (((sqInt)arg));
		}
	}
	return rcvr < arg;
}


/*	Note: With the Squeak V3 format we now have 10 bits of primitive index,
	but they are
	in two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the
	Spur format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;

	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt header;
    sqInt methodHeader;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	/* begin primitiveIndexOfMethod:header: */
	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (methodPointer + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
}

	/* StackInterpreter>>#printActivationNameForSelector:startClass: */
static NoDbgRegParms void
printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methClass;
    usqInt numSlots;
    sqInt objOop;

	class = 0;
	if (addressCouldBeObj(startClass)) {
		/* begin findClassForSelector:lookupClass:do: */
		currClass = startClass;
		do {
			classDict = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
			/* begin numSlotsOf: */
			assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
			classDictSize = (((numSlots = byteAt(classDict + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(classDict - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots);
			i = SelectorStart;
			while (i < classDictSize) {
				if (aSelector == (longAt((classDict + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))))) {
					methClass = currClass;
					goto l2;
				}
				i += 1;
			}
			/* begin superclassOf: */
			objOop = longAt((currClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop));
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currClass, objOop);
			}
			currClass = objOop;
		} while(!(currClass == GIV(nilObj)));
		methClass = null;
	l2:	/* end findClassForSelector:lookupClass:do: */;
		if ((!methClass)
		 || (startClass == methClass)) {
			printNameOfClasscount(methClass, 5);
			printChar('>');
			if (!methClass) {
				printStringOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))));
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" ");
			}
		}
		else {
			printNameOfClasscount(startClass, 5);
			printChar('(');
			printNameOfClasscount(methClass, 5);
			printChar(')');
			printChar('>');
		}
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"INVALID CLASS");
	}
	if (	/* begin addressCouldBeOop: */
		(((aSelector & (tagMask())) != 0))
	 || (addressCouldBeObj(aSelector))) {
		if (		/* begin isBytes: */
			((!(aSelector & (tagMask()))))
		 && (((((usqInt)((longAt(aSelector)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))) {
			printStringOf(aSelector);
		}
		else {
			/* begin printOopShort: */
			printOopShortInner(aSelector);
			fflush(GIV(transcript));
		}
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"INVALID SELECTOR");
	}
}

	/* StackInterpreter>>#printActivationNameFor:receiver:isBlock:firstTemporary: */
static NoDbgRegParms void
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt methClass;
    sqInt methodSel;
    sqInt rclass;
    sqInt tagBits;
    sqInt tagBits1;

	if (isBlock) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"[] in ");
	}
	if ((	/* begin addressCouldBeOop: */
		(((anObject & (tagMask())) != 0))
	 || (addressCouldBeObj(anObject)))
	 && (!(((!(anObject & (tagMask()))))
	 && ((!((longAt(anObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))) {
		rclass = findClassContainingMethodstartingAt(aMethod, 
		/* begin fetchClassOf: */
(((tagBits1 = anObject & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits1) << (shiftForWord())))))
			: fetchClassOfNonImm(anObject)));
		if (rclass != GIV(nilObj)) {
			methClass = rclass;
			goto l1;
		}
	}
	if (!((addressCouldBeObj(aMethod))
		 && (((((usqInt)((longAt(aMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		methClass = GIV(nilObj);
		goto l1;
	}
	methClass = findClassContainingMethodstartingAt(aMethod, safeMethodClassOf(aMethod));
	l1:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethod(aMethod);
	if ((	/* begin addressCouldBeOop: */
		(((anObject & (tagMask())) != 0))
	 || (addressCouldBeObj(anObject)))
	 && ((!(	/* begin isOopForwarded: */
		((!(anObject & (tagMask()))))
	 && ((!((longAt(anObject)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))
	 && (addressCouldBeClassObj((classObj = (((tagBits = anObject & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
		: fetchClassOfNonImm(anObject))))))) {
		if ((classObj == methClass)
		 || ((!methClass)
		 || (methClass == GIV(nilObj)))) {
			printNameOfClasscount(classObj, 5);
		}
		else {
			printNameOfClasscount(classObj, 5);
			printChar('(');
			printNameOfClasscount(methClass, 5);
			printChar(')');
		}
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"INVALID RECEIVER");
	}
	printChar('>');
	if (	/* begin addressCouldBeOop: */
		(((methodSel & (tagMask())) != 0))
	 || (addressCouldBeObj(methodSel))) {
		if (methodSel == GIV(nilObj)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"(nil)");
		}
		else {
			printStringOf(methodSel);
		}
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"INVALID SELECTOR");
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))))
	 && ((addressCouldBeObj(maybeMessage))
	 && ((fetchClassOfNonImm(maybeMessage)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassMessage) << (shiftForWord()))))))))) {
		/* print arg message selector */
		methodSel = longAt((maybeMessage + BaseHeaderSize) + (((sqInt)((usqInt)(MessageSelectorIndex) << (shiftForWord())))));
		/* begin space */
		printChar(' ');
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */
/*	useful for VM debugging */

	/* StackInterpreter>>#printAllStacks */
void
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classPointer;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt linkedListClass;
    sqInt minProcessInstSize;
    sqInt myList;
    sqInt myListClass;
    sqInt n;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt oop;
    usqInt p;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt pri;
    sqInt proc;
    sqInt processClass;
    sqInt processList;
    sqInt schedLists;
    sqInt startObject;
    sqInt tagBits;
    sqInt tagBits1;

	obj = 0;
	/* begin activeProcess */
	objOop4 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	proc = longAt((objOop4 + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	printNameOfClasscount(	/* begin fetchClassOf: */
		(((tagBits = proc & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
		: fetchClassOfNonImm(proc)), 5);
	printChar(' ');
	printHex(proc);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" priority ");
	oop = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	n = (oop >> 3);
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n));
	cr();
	if (GIV(framePointer) == null) {
		printProcessStack(proc);
	}
	else {
		printCallStack();
	}
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	/* begin fetchPointer:ofObject: */
	schedLists = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	/* then the runnable processes */
	linkedListClass = null;
	p = (GIV(highestRunnableProcessPriority) == 0
		? (			/* begin numSlotsOf: */
				assert((classIndexOf(schedLists)) > (isForwardedObjectClassIndexPun())),
			(((numSlots = byteAt(schedLists + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(schedLists - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots))
		: GIV(highestRunnableProcessPriority));
	for (pri = (p - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + BaseHeaderSize) + (((sqInt)((usqInt)(pri) << (shiftForWord())))));
		if (!((			/* begin isEmptyList: */
				assert(!(isForwarded(processList))),
			(longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)))) {
			if (proc == GIV(nilObj)) {
				proc = longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
			}
			cr();
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"processes at priority ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)(pri + 1)));
			printProcsOnList(processList);
		}
		if (!linkedListClass) {
			linkedListClass = fetchClassOfNonImm(processList);
		}
	}
	if (!linkedListClass) {
		/* begin superclassOf: */
		classPointer = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord())))));
		/* begin followObjField:ofObject: */
		objOop1 = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop1));
		if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop1);
		}
		linkedListClass = objOop1;
	}
	if (proc == GIV(nilObj)) {
		cr();
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"Cannot find a runnable process. Cannot therefore determine class Process. Cannot therefore print suspended processes");
		return;
	}
	cr();
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"suspended processes");
	processClass = (!(proc == GIV(nilObj))
		? 
			/* begin fetchClassOf: */
(((tagBits1 = proc & (tagMask()))) != 0
				? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits1) << (shiftForWord())))))
				: fetchClassOfNonImm(proc))
		: 0);
	minProcessInstSize = MyListIndex + 1;
	while ((instanceSizeOf(superclassOf(processClass))) >= minProcessInstSize) {
		/* begin superclassOf: */
		objOop2 = longAt((processClass + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop2));
		if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, processClass, objOop2);
		}
		processClass = objOop2;
	}
	/* begin instanceSizeOf: */
	assert(addressCouldBeClassObj(processClass));
	/* look for all subInstances of process that have a context as a suspendedContext and are on a list other than a LinkedList */
	minProcessInstSize = (((longAt((processClass + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	objOop3 = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots2 = byteAt(address + 7);
	startObject = (numSlots2 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (((longAt(obj1)) & (classIndexMask())) > (lastClassIndexPun())) {
			if ((((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
			 && ((((			/* begin numSlotsOf: */
				assert((classIndexOf(obj1)) > (isForwardedObjectClassIndexPun())),
			(((numSlots1 = byteAt(obj1 + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(obj1 - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots1))) >= minProcessInstSize)
			 && ((isContext(longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))))))
			 && (isKindOfClass(obj1, processClass))))) {
				/* Is the process waiting on some delaying list?  This will be a subclass of LinkedList.
				   If so, assume it is blocked on the list. */
				myList = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))));
				if ((myList != GIV(nilObj))
				 && ((((myListClass = fetchClassOfNonImm(myList))) != linkedListClass)
				 && (isKindOfClass(myList, linkedListClass)))) {
					printProcessStack(obj1);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l6;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l6:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */
/*	useful for VM debugging */

	/* StackInterpreter>>#printAllStacksOn: */
void
printAllStacksOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;


	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream == null
		? stdout
		: aStdioStream);
	printAllStacks();
	GIV(transcript) = savedTranscript;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printCallStack */
void
printCallStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(framePointer) == null) {
		printCallStackOf(fetchPointerofObject(SuspendedContextIndex, activeProcess()));
	}
	else {
		printCallStackFP(GIV(framePointer));
	}
}

	/* StackInterpreter>>#printCallStackFP: */
static NoDbgRegParms sqInt
printCallStackFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP);
	while (!(context == GIV(nilObj))) {
		if (((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printCallStackOf: */
sqInt
printCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	if (	/* begin couldBeFramePointer: */
		(GIV(stackBasePlus1))
	 && ((((((usqInt)aContextOrProcessOrFrame)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)aContextOrProcessOrFrame)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)aContextOrProcessOrFrame)) <= (((usqInt)GIV(pages)))))))) {
		return printCallStackFP(((char *)aContextOrProcessOrFrame));
	}
	if (aContextOrProcessOrFrame == (activeProcess())) {
		return printCallStackOf(((sqInt)GIV(framePointer)));
	}
	if (couldBeProcess(aContextOrProcessOrFrame)) {
		return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord()))))));
	}
	context = aContextOrProcessOrFrame;
	while (!(context == GIV(nilObj))) {
		if (((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
	return 0;
}

	/* StackInterpreter>>#printCallStackOf:currentFP: */
static NoDbgRegParms sqInt
printCallStackOfcurrentFP(sqInt aContext, char *currFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    sqInt ctxt;
    sqInt referent;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			theFP = pointerForOop(senderOop - (smallIntegerTag()));
			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP)) {
				/* begin stackPageFor: */
				thePage = stackPageAtpages(
					(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				if (isFree(thePage)) {
					fprintf(GIV(transcript),
							"%p is on a free page?!\n",
							theFP);
					return null;
				}
				shortPrintFrameAndCallers(theFP);
				theFP = (thePage->baseFP);
				/* begin frameCallerContext: */
				assert(isBaseFrame(theFP));
				thePage1 = stackPageAtpages(
					(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
					pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
					GIV(pages));
				callerContextOrNil = longAt((thePage1->baseAddress));
				assert(addressCouldBeObj(callerContextOrNil));
				assert((callerContextOrNil == (nilObject()))
				 || (isContext(followMaybeForwarded(callerContextOrNil))));
				ctxt = callerContextOrNil;
				if ((!((longAt(ctxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(ctxt));
					referent = longAt((ctxt + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					ctxt = referent;
				}
			}
			else {
				fprintf(GIV(transcript),
						"widowed caller frame %p\n",
						theFP);
				return null;
			}
		}
		else {
			shortPrintContext(ctxt);
			ctxt = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		}
	}
	return 0;
}


/*	Print the call stack on a specific output stream. */
/*	useful for VM debugging */

	/* StackInterpreter>>#printCallStackOn: */
void
printCallStackOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;


	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream == null
		? stdout
		: aStdioStream);
	printCallStack();
	GIV(transcript) = savedTranscript;
}


/*	Print the call stack of aContext until it links to a frame. */

	/* StackInterpreter>>#printContextCallStackOf: */
static NoDbgRegParms sqInt
printContextCallStackOf(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
	 || (((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	return ctxt;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printContext: */
void
printContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ip;
    sqInt meth;
    sqInt sender;
    sqInt sp;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	ip = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	if ((((sender) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"married (assuming framePointer valid)");
			cr();
		}
		else {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"widowed (assuming framePointer valid)");
			cr();
		}
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"sender   ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)sender));
		fprintf(GIV(transcript),
				"%s",
				" (");
		printHexPtrnp(
			(			/* begin withoutSmallIntegerTags: */
				assert((((sender) & 7) == 1)),
			pointerForOop(sender - (smallIntegerTag()))));
		printChar(')');
		cr();
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"ip       ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)ip));
		fprintf(GIV(transcript),
				"%s",
				" (");
		printHexPtrnp(
			(			/* begin withoutSmallIntegerTags: */
				assert((((ip) & 7) == 1)),
			pointerForOop(ip - (smallIntegerTag()))));
		printChar(')');
		cr();
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"sender   ");
		shortPrintOop(sender);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"ip       ");
		if (ip == GIV(nilObj)) {
			shortPrintOop(ip);
		}
		else {
			/* begin printNum: */
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)ip));
			fprintf(GIV(transcript),
					"%s",
					" (");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)((ip >> 3))));
			printChar(' ');
			printHex((ip >> 3));
			printChar(')');
			cr();
		}
	}
	sp = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"sp       ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)((sp >> 3))));
	fprintf(GIV(transcript),
			"%s",
			" (");
	printHex(sp);
	printChar(')');
	cr();
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"method   ");
	meth = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	fprintf(GIV(transcript),
			"%p: ",
			((void *)meth));
	printOopShortInner(meth);
	if (methodHasCogMethod(meth)) {
		fprintf(GIV(transcript),
				" (%p)",
				cogMethodOf(meth));
	}
	cr();
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"closure  ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ClosureIndex) << (shiftForWord()))))));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"receiver ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	sp = (sp >> 3);
	sp = ((sp < ((lengthOf(aContext)) - ReceiverIndex)) ? sp : ((lengthOf(aContext)) - ReceiverIndex));
	for (i = 1; i <= sp; i += 1) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"       ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)i));
		printChar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
}

	/* StackInterpreter>>#printDecodeMethodHeaderOop: */
static NoDbgRegParms void
printDecodeMethodHeaderOop(sqInt methodHeaderOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt n;


	/* begin printOopShort: */
	printOopShortInner(methodHeaderOop);
	fflush(GIV(transcript));
	if (((methodHeaderOop & AlternateHeaderHasPrimFlag) != 0)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" hasPrim");
	}
	if ((methodHeaderOop & LargeContextBit) != 0) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" largeFrame");
	}
	if (((methodHeaderOop >> 3)) < 0) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" altSet");
	}
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" nLits ");
	/* begin literalCountOfMethodHeader: */
	assert((((methodHeaderOop) & 7) == 1));
	n = ((methodHeaderOop >> 3)) & AlternateHeaderNumLiteralsMask;
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n));
	fprintf(GIV(transcript),
			"%s",
			" nArgs ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)((((usqInt)(methodHeaderOop)) >> MethodHeaderArgCountShift) & 15)));
	fprintf(GIV(transcript),
			"%s",
			" nTemps ");
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)((((usqInt)(methodHeaderOop)) >> MethodHeaderTempCountShift) & 0x3F)));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printExternalHeadFrame */
void
printExternalHeadFrame(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer));
}

	/* StackInterpreter>>#printFrameAndCallers:SP:short: */
static NoDbgRegParms sqInt
printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(		/* begin couldBeFramePointer: */
			(GIV(stackBasePlus1))
		 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages))))))))) {
		return null;
	}
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		printFrameAndCallersSPshort(
			pointerForOop(longAt(theFP + FoxSavedFP)),
			(			/* begin frameCallerSP: */
				assert(!(isBaseFrame(theFP))),
			(theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord),
			printShort);
	}
	if (printShort) {
		shortPrintFrame(theFP);
		return null;
	}
	cr();
	printFrameWithSP(theFP, theSP);
	return 0;
}

	/* StackInterpreter>>#printFrameOop:at: */
static NoDbgRegParms void
printFrameOopat(char *name, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %16p\t=" /* begin pst: */,
			name,
			((void *)it));
	printOopShortInner(it);
	cr();
}

	/* StackInterpreter>>#printFrameOop:index:at: */
static NoDbgRegParms void
printFrameOopindexat(char *name, sqInt idx, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%s%10s%" PRIdSQINT ": %16p\t" /* begin pst: */,
			(idx > 9
		? ""
		: " "),
			name,
			idx,
			((void *)it));
	printOopShortInner(it);
	cr();
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFramesInPage: */
void
printFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 0);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFramesOnStackPageListInUse */
void
printFramesOnStackPageListInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"page ");
			printHexPtrnp(page);
			cr();
			printFramesInPage(page);
			cr();
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

	/* StackInterpreter>>#printFrameThing:andFrame:at: */
static NoDbgRegParms void
printFrameThingandFrameat(char *name, char *theFP, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %16p" /* begin pst: */,
			name,
			((void *)it));
	if (it != 0) {
		if (it == GIV(nilObj)) {
			fprintf(GIV(transcript), "=nil");
		}
		else {
			fprintf(GIV(transcript),
					"=%" PRIdSQINT "",
					it);
		}
	}
	fprintf(GIV(transcript),
			" frame: %p\n",
			theFP);
}

	/* StackInterpreter>>#printFrameThing:at:extraString: */
static NoDbgRegParms void
printFrameThingatextraString(char *name, char *address, char *extraStringOrNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);
	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%16p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %16p" /* begin pst: */,
			name,
			((void *)it));
	framePrintDescription(it);
	if (!(extraStringOrNil == null)) {
		fprintf(GIV(transcript),
				"%s",
				extraStringOrNil);
	}
	cr();
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFrame: */
sqInt
printFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *frameAbove;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (!(		/* begin couldBeFramePointer: */
			(GIV(stackBasePlus1))
		 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages))))))))) {
		if ((addressCouldBeObj(((sqInt)theFP)))
		 && ((isInMemory(((sqInt)theFP)))
		 && ((((longAt(((sqInt)theFP))) & (classIndexMask())) == ClassMethodContextCompactIndex)
		 && (checkIsStillMarriedContextcurrentFP(((sqInt)theFP), GIV(framePointer)))))) {
			return printFrame(frameOfMarriedContext(((sqInt)theFP)));
		}
		fprintf(GIV(transcript),
				"%p is not in the stack zone?!\n",
				theFP);
		return null;
	}
	frameAbove = null;
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		if (isFree(thePage)) {
			fprintf(GIV(transcript),
					"%p is on a free page?!\n",
					theFP);
			return null;
		}
		if ((thePage != GIV(stackPage))
		 && (theFP == ((thePage->headFP)))) {
			theSP = (thePage->headSP);
		}
		else {
			startFrame = ((thePage == GIV(stackPage))
			 && (((GIV(framePointer) >= ((thePage->realStackLimit))) && (GIV(framePointer) <= ((thePage->baseAddress)))))
				? GIV(framePointer)
				: (thePage->headFP));
			/* begin safeFindFrameAbove:on:startingFrom: */
			assert(!(isFree(thePage)));
			if (startFrame == theFP) {
				frameAbove = null;
				goto l2;
			}
			aFrame = startFrame;
			while (1) {
				prevFrame = aFrame;
				aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
				if (!(aFrame != 0)) break;
				if (theFP == aFrame) {
					frameAbove = prevFrame;
					goto l2;
				}
			}
			frameAbove = null;
	l2:	/* end safeFindFrameAbove:on:startingFrom: */;
			theSP = (!(frameAbove == null)
				? (					/* begin frameCallerSP: */
						assert(!(isBaseFrame(frameAbove))),
					(frameAbove + (frameStackedReceiverOffset(frameAbove))) + BytesPerWord)
				: 0);
		}
	}
	if (!theSP) {
		fprintf(GIV(transcript), "could not find sp; using bogus value\n");
		theSP = 
		/* begin frameReceiverLocation: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? theFP + FoxMFReceiver
			: theFP + FoxIFReceiver);
	}
	printFrameWithSP(theFP, theSP);
	if (!(frameAbove == null)) {
		/* begin printFrameThing:at: */
		printFrameThingatextraString("frame pc", frameAbove + FoxCallerSavedIP, ((char *)null));
	}
	return 0;
}


/*	Print p in hex, unpadded, in the form 0x1234 (C)/16r1234 (here) */

	/* StackInterpreter>>#printHexPtrnp: */
static NoDbgRegParms sqInt
printHexPtrnp(void *p)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fprintf(GIV(transcript),
			"%p",
			p);
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles). In the simulator use 16r as the prefix, padding to 11 characters
	in 32-bits
	or 19 characters in 64-bits. */

	/* StackInterpreter>>#printHex: */
void
printHex(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"%16p" /* begin pst: */,
			((void *)n));
}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */
/*	useful for VM debugging */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt methodClassAssociation;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt obj1;
    sqInt objOop;
    sqInt offset;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	obj = 0;
	/* begin allObjectsDo: */
	objOop = 0;
	address = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	/* begin objectStartingAt: */
	numSlots1 = byteAt(address + 7);
	startObject = (numSlots1 == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if ((		/* begin isEnumerableObject: */
			(classIndex = (longAt(obj1)) & (classIndexMask())),
		assert((classIndex == (segmentBridgePun()))
			 || ((classIndex == (isForwardedObjectClassIndexPun()))
			 || (((long64At(obj1)) != 0)
			 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize())))))),
		classIndex >= (isForwardedObjectClassIndexPun()))) {
			if ((((((usqInt)((longAt(obj1)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))
			 && ((maybeSelectorOfMethod(obj1)) == selector)) {
				/* try and print the key of the method class association (the name of the implementing class) */
				/* begin methodClassAssociationOf: */
				offset = (literalCountOf(obj1)) - 1;
				methodClassAssociation = longAt((obj1 + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				/* begin printHexnp: */
				fprintf(GIV(transcript),
						"%p",
						((void *)obj1));
				printChar(' ');
				printOopShortInner(((				/* begin isPointers: */
					((!(methodClassAssociation & (tagMask()))))
				 && (((((usqInt)((longAt(methodClassAssociation)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
				 && (((assert((classIndexOf(methodClassAssociation)) > (isForwardedObjectClassIndexPun())),
				(((numSlots = byteAt(methodClassAssociation + 7))) == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(methodClassAssociation - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots))) >= 2)
					? longAt((methodClassAssociation + BaseHeaderSize) + (0U << (shiftForWord())))
					: methodClassAssociation));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    sqInt i;
    sqIntptr_t m;
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;


	/* begin printMethodCacheFor: */
	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if ((		/* begin addressCouldBeOop: */
			(((s & (tagMask())) != 0))
		 || (addressCouldBeObj(s)))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(classForClassTag(c)))))) {
			n += 1;
			fprintf(GIV(transcript),
					"%" PRIdSQINT " %" PRIxSQINT "\n\t",
					i,
					i);
			if (((((usqInt)((longAt(s)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())) {
				fprintf(GIV(transcript),
						"%p %.*s\n",
						((void *)s),
						((int) (numBytesOfBytes(s))),
						((char *)(firstIndexableField(s))));
			}
			else {
				shortPrintOop(s);
			}
			/* begin tab */
			printChar('\t');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)c));
				printChar(' ');
				fprintf(GIV(transcript),
						"%p",
						((void *)c));
				printChar(' ');
				shortPrintOop(classForClassTag(c));
			}
			/* begin tab */
			printChar('\t');
			shortPrintOop(m);
			/* begin tab */
			printChar('\t');
			if (p > 0x400) {
				/* begin printHexnp: */
				fprintf(GIV(transcript),
						"%p",
						((void *)p));
			}
			else {
				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)p));
			}
			cr();
		}
	}
	if (n > 1) {
		/* begin printNum: */
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
		cr();
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt dictionary;
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    usqInt numSlots;
    sqInt selector;

	dictionary = longAt((behavior + BaseHeaderSize) + (((sqInt)((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
	/* begin printMethodDictionary: */
	methodArray = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
	for (index = SelectorStart, indexLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
			/* begin printOopShort: */
			printOopShortInner(selector);
			fflush(GIV(transcript));
			fprintf(GIV(transcript),
					"%s",
					" => ");
			printOopShortInner(meth);
			fflush(GIV(transcript));
			fprintf(GIV(transcript),
					"%s",
					" (");
			printHex(selector);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" => ");
			printHex(meth);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					")\n");
		}
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    usqInt numSlots;
    sqInt selector;

	methodArray = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(MethodArrayIndex) << (shiftForWord())))));
	for (index = SelectorStart, indexLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(dictionary + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(dictionary - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - SelectorStart)) << (shiftForWord())))));
			/* begin printOopShort: */
			printOopShortInner(selector);
			fflush(GIV(transcript));
			fprintf(GIV(transcript),
					"%s",
					" => ");
			printOopShortInner(meth);
			fflush(GIV(transcript));
			fprintf(GIV(transcript),
					"%s",
					" (");
			printHex(selector);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" => ");
			printHex(meth);
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					")\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static NoDbgRegParms void
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;

	if (!GIV(classNameIndex)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"??nil cnidx??");
		return;
	}
	if ((!classOop)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"bad class");
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = (((numSlots1 = byteAt(classOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))), cnt - 1);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"bad class");
		}
		else {
			printStringOf(longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(GIV(classNameIndex)) << (shiftForWord()))))));
		}
	}
}

	/* StackInterpreter>>#printOopShortInner: */
static NoDbgRegParms void
printOopShortInner(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bits;
    sqInt classLookupKey;
    sqInt classOop;
    double f;
    char *name;
    sqInt nameLen;
    usqInt numSlots;
    sqInt objOop;
    sqInt referent;
    double result;
    usqLong rot;
    char *s;
    sqInt tagBits;
    sqInt target;
    double value;

	if (((oop & (tagMask())) != 0)) {
		if (((oop & (characterTag())) != 0)) {
			fprintf(GIV(transcript),
					"$%c(%" PRIxSQINT ")",
					((int) (((((usqInt)oop))) >> (numTagBits()))),
					((((usqInt)oop))) >> (numTagBits()));
			return;
		}
		if ((((oop) & 7) == 1)) {
			fprintf(GIV(transcript),
					"%" PRIdSQINT "(0x%" PRIxSQINT ")",
					(oop >> 3),
					(oop >> 3));
			return;
		}
		if (((oop & (smallFloatTag())) != 0)) {
			fprintf(GIV(transcript),
					"%g(0x%" PRIxSQINT ")",
					noFailFloatValueOf(oop),
					oop);
			return;
		}
		fprintf(GIV(transcript),
				"unknown immediate %p",
				((void *)oop));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		if ((oop & (7)) != 0) {
			s = " is misaligned";
		}
		else {
			s = whereIs(oop);
		}
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				s);
		return;
	}
	if (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is a free chunk");
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(oop));
		referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		target = referent;
		fprintf(GIV(transcript),
				" is a forwarder to %p",
				((void *)target));
		return;
	}
	if (	/* begin isFloatInstance: */
		(((tagBits = oop & (tagMask()))) != 0
		? tagBits == (smallFloatTag())
		: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex)) {
		/* begin noFailFloatValueOf: */
		assert(isFloatInstance(oop));
		if ((oop & (tagMask())) != 0) {
			/* begin smallFloatValueOf: */
			assert(isImmediateFloat(oop));
			rot = ((((usqInt)oop))) >> (numTagBits());
			if (rot > 1) {
				/* a.k.a. ~= +/-0.0 */
				rot += ((sqInt)((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			}
			rot = (rot << 0x3F) + (((((usqInt)rot))) >> 1);
			bits = rot;
			memcpy((&value), (&bits), sizeof(value));
			result = value;
		}
		else {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
		}
		f = result;
		/* begin printFloat: */
		fprintf(GIV(transcript),
				"%g",
				f);
		return;
	}
	classOop = fetchClassOfNonImm(oop);
	if (!(addressCouldBeObj(classOop))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"a ??");
		return;
	}
	if (((	/* begin numSlotsOf: */
		assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun())),
	(((numSlots = byteAt(classOop + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(classOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots))) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		return;
	}
	if (oop == GIV(nilObj)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"nil");
		return;
	}
	if (oop == GIV(trueObj)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"true");
		return;
	}
	if (oop == GIV(falseObj)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"false");
		return;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (nameLen == 0) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"a ??");
		return;
	}
	name = nameOfClass(classOop);
	if ((	/* begin isBytes: */
		((!(oop & (tagMask()))))
	 && (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
	 && (nameLen >= 6)) {
		if ((strncmp((name + nameLen) - 6, "String", 6)) == 0) {
			/* strncmp is weird */
			printChar('\'');
			printStringOf(oop);
			printChar('\'');
			return;
		}
		if ((strncmp((name + nameLen) - 6, "Symbol", 6)) == 0) {
			/* strncmp is weird */
			printChar('#');
			printStringOf(oop);
			return;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		printChar('$');
		printChar(((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 3));
		return;
	}
	fprintf(GIV(transcript),
			"a(n) %.*s",
			((int) nameLen),
			name);
	if ((((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)
	 && ((((	/* begin instanceSizeOf: */
		assert(addressCouldBeClassObj(classOop)),
	(((longAt((classOop + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1))) == (ValueIndex + 1))
	 && (isBytes(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord()))))))))) {
		classLookupKey = fetchClassOfNonImm(splObj(SchedulerAssociation));
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				return;
			}
			if (((			/* begin instanceSizeOf: */
				assert(addressCouldBeClassObj(classLookupKey)),
			(((longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1))) == (KeyIndex + 1)) break;
			/* begin superclassOf: */
			objOop = longAt((classLookupKey + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop));
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classLookupKey, objOop);
			}
			classLookupKey = objOop;
		}
		if (includesBehaviorThatOf(classOop, classLookupKey)) {
			/* begin space */
			printChar(' ');
			printOopShortInner(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(KeyIndex) << (shiftForWord()))))));
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" -> ");
			fprintf(GIV(transcript),
					"%p",
					((void *)(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord()))))))));
		}
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printOop: */
void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    char *className;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt lastIndex;
    sqInt length;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt startIP;
    sqInt tagBits;

	length = 0;
	if (((oop & (tagMask())) != 0)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	if (!((cls = fetchClassOfNonImm(oop)))) {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
		return;
	}
	className = nameOfClasslengthInto(cls, (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s",
			((void *)oop),
			((int) length),
			className);
	if (	/* begin isFloatInstance: */
		(((tagBits = oop & (tagMask()))) != 0
		? tagBits == (smallFloatTag())
		: ((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex)) {
		fprintf(GIV(transcript),
				"\n%g\n",
				noFailFloatValueOf(oop));
		return;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if (fmt > 5 /* begin lastPointerFormat */) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {
		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassAlien) << (shiftForWord()))))))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					((longAt(oop + BaseHeaderSize)) < 0
				? "indirect"
				: ((longAt(oop + BaseHeaderSize)) == 0
						? "pointer"
						: "direct")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteString) << (shiftForWord())))))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	if (fmt >= (firstCompiledMethodFormat())) {
		startIP = (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) / BytesPerWord;
	}
	else {
		/* begin numSlotsOf: */
		assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
		if (((numSlots = byteAt(oop + 7))) == (numSlotsMask())) {
			/* overflow slots; at least (2^32)-1 slots, which is plenty */
			startIP = ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8;
		}
		else {
			startIP = numSlots;
		}
	}
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
			/* begin space */
			printChar(' ');
			if ((index % 5 /* begin elementsPerPrintOopLine */) == 0) {
				cr();
			}
		}
		if (!((lastIndex % 5 /* begin elementsPerPrintOopLine */) == 0)) {
			cr();
		}
	}
	if (((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
		startIP = (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) + 1;
		/* begin lengthOf: */
		fmt1 = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOfAny: */
		numSlots1 = byteAt(oop + 7);
		numSlots2 = (numSlots1 == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt1 <= 5 /* begin ephemeronFormat */) {
			lastIndex = numSlots2;
			goto l2;
		}
		if (fmt1 >= (firstByteFormat())) {
			/* bytes, including CompiledMethod */
			lastIndex = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
			goto l2;
		}
		if (fmt1 >= (firstShortFormat())) {
			lastIndex = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l2;
		}
		if (fmt1 >= (firstLongFormat())) {
			lastIndex = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l2;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			lastIndex = numSlots2;
			goto l2;
		}
		lastIndex = 0;
	l2:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			fprintf(GIV(transcript),
					" %02x/%-+3d",
					((int) byte),
					((int) byte));
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				cr();
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"...");
		}
		if (!(column == 1)) {
			cr();
		}
	}
	else {
		if (startIP > 64) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"...");
			cr();
		}
	}
}


/*	print the entry and answer if it takes a parameter (as the following
	entry) 
 */

	/* StackInterpreter>>#printPrimLogEntryAt:hasParameter: */
static NoDbgRegParms sqInt
printPrimLogEntryAthasParameter(sqInt i, sqInt hasParameter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *className;
    sqInt entryOop;
    sqInt length;
    sqInt methodClass;
    sqInt methodSel;
    sqInt referent;
    sqInt target;

	length = 0;
	entryOop = GIV(primTraceLog)[i];
	if (hasParameter) {
		if (addressCouldBeObj(entryOop)) {
			className = nameOfClasslengthInto(entryOop, (&length));
		}
		else {
			className = "bad class";
			length = 9;
		}
		fprintf(GIV(transcript),
				"%.*s\n",
				((int) length),
				className);
		return 0;
	}
	if (((entryOop & (tagMask())) != 0)) {
		if (entryOop == TraceIncrementalGC) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"**IncrementalGC**\n");
			return 0;
		}
		if (entryOop == TraceFullGC) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"**FullGC**\n");
			return 0;
		}
		if (entryOop == TraceCodeCompaction) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"**CompactCode**\n");
			return 0;
		}
		if (entryOop == TraceStackOverflow) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"**StackOverflow**\n");
			return 0;
		}
		if (entryOop == TracePrimitiveFailure) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"**PrimitiveFailure** ");
			return 1;
		}
		if (entryOop == TracePrimitiveRetry) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"**PrimitiveRetry**\n");
			return 0;
		}
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"???\n");
	}
	else {
		if (addressCouldBeObj(entryOop)) {
			if (((((usqInt)((longAt(entryOop)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
				className = "???";
				length = 3;
				methodClass = safeMethodClassOf(entryOop);
				if (methodClass != GIV(nilObj)) {
					className = nameOfClasslengthInto(methodClass, (&length));
				}
				methodSel = findSelectorOfMethod(entryOop);
				if (methodSel == GIV(nilObj)) {
					fprintf(GIV(transcript),
							"%.*s>>(selector not found)\n",
							((int) length),
							className);
				}
				else {
					fprintf(GIV(transcript),
							"%.*s>>#%.*s\n",
							((int) length),
							className,
							((int) (numBytesOfBytes(methodSel))),
							((char *)(firstIndexableField(methodSel))));
				}
			}
			else {
				/* begin safePrintStringOf: */
				if (				/* begin isOopForwarded: */
					((!(entryOop & (tagMask()))))
				 && ((!((longAt(entryOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(entryOop));
					referent = longAt((entryOop + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent & (tagMask()))))
					 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					target = referent;
				}
				else {
					target = entryOop;
				}
				printStringOf(target);
				cr();
			}
		}
		else {
			fprintf(GIV(transcript),
					"%" PRIdSQINT "!!!\n",
					i);
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printProcessStack: */
void
printProcessStack(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctx;
    sqInt n;
    sqInt objOop;
    sqInt oop;
    sqInt tagBits;

	cr();
	printNameOfClasscount(	/* begin fetchClassOf: */
		(((tagBits = aProcess & (tagMask()))) != 0
		? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))))
		: fetchClassOfNonImm(aProcess)), 5);
	printChar(' ');
	printHex(aProcess);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" priority ");
	oop = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	n = (oop >> 3);
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n));
	cr();
	/* begin followField:ofObject: */
	objOop = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, aProcess, objOop);
	}
	ctx = objOop;
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printProcsOnList: */
sqInt
printProcsOnList(sqInt procList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstProc;
    sqInt objOop;
    sqInt objOop1;
    sqInt proc;


	/* begin followField:ofObject: */
	objOop = longAt((procList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(objOop & (tagMask()))))
	 && ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FirstLinkIndex, procList, objOop);
	}
	proc = (firstProc = objOop);
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		/* begin followField:ofObject: */
		objOop1 = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		if (		/* begin isOopForwarded: */
			((!(objOop1 & (tagMask()))))
		 && ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			objOop1 = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, proc, objOop1);
		}
		proc = objOop1;
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackCallStackOf: */
sqInt
printStackCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    char *theFP;

	if (addressCouldBeObj(aContextOrProcessOrFrame)) {
		if ((		/* begin isContext: */
			((!(aContextOrProcessOrFrame & (tagMask()))))
		 && (((longAt(aContextOrProcessOrFrame)) & (classIndexMask())) == ClassMethodContextCompactIndex))
		 && (checkIsStillMarriedContextcurrentFP(aContextOrProcessOrFrame, null))) {
			return printStackCallStackOf(((sqInt)(frameOfMarriedContext(aContextOrProcessOrFrame))));
		}
		if (aContextOrProcessOrFrame == (activeProcess())) {
			return printStackCallStackOf(((sqInt)GIV(framePointer)));
		}
		if (couldBeProcess(aContextOrProcessOrFrame)) {
			return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord()))))));
		}
		return null;
	}
	theFP = ((void *)aContextOrProcessOrFrame);
	while (1) {
		context = shortReversePrintFrameAndCallers(theFP);
		if (!((((((longAt((context + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (((theFP = frameOfMarriedContext(context)),
			checkIsStillMarriedContextcurrentFP(context, theFP))))) {
			return null;
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPageList */
void
printStackPageList(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		/* begin printStackPage: */
		printStackPageuseCount(page, -1);
		cr();
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPageListInUse */
void
printStackPageListInUse(void)
{
    sqInt n;
    StackPage *page;

	page = mostRecentlyUsedPage();
	n = 0;
	do {
		if (!(isFree(page))) {
			printStackPageuseCount(page, (n += 1));
			cr();
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPages */
void
printStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *page;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(i, GIV(pages));
		printStackPageuseCount(page, -1);
		cr();
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPagesInUse */
void
printStackPagesInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt n;

	n = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		if (!(isFree(stackPageAt(i)))) {
			printStackPageuseCount(stackPageAt(i), (n += 1));
			cr();
		}
	}
}

	/* StackInterpreter>>#printStackPage:useCount: */
static NoDbgRegParms void
printStackPageuseCount(StackPage *page, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt n1;
    sqInt n2;
    sqInt n3;
    sqInt n4;


	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			"page ");
	printHexPtrnp(page);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" (");
	/* begin pageIndexFor: */
	assert((((((char *) ((page->realStackLimit)))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) ((page->realStackLimit)))) <= (((char *) GIV(pages))))));
	n1 = pageIndexForstackBasePlus1bytesPerPage((page->realStackLimit), GIV(stackBasePlus1), GIV(bytesPerPage));
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n1));
	if (n >= 0) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				",");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
	}
	fprintf(GIV(transcript),
			"%s",
			")  (trace: ");
	n2 = (page->trace);
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n2));
	printChar(')');
	if (isFree(page)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" (free)");
	}
	if (page == (mostRecentlyUsedPage())) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" (MRU)");
	}
	if (((page->prevPage)) == (mostRecentlyUsedPage())) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" (LRU)");
	}
	cr();
	/* begin tab */
	printChar('\t');
	fprintf(GIV(transcript),
			"%s",
			"ba: ");
	printHexPtrnp((page->baseAddress));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" - sl: ");
	printHexPtrnp((page->realStackLimit));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" - sl-so: ");
	printHexPtrnp(((page->realStackLimit)) - ((IFrameSlots + 64) * BytesPerWord));
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" - la:");
	printHexPtrnp((page->lastAddress));
	if (!(isFree(page))) {
		cr();
		/* begin tab */
		printChar('\t');
		fprintf(GIV(transcript),
				"%s",
				"baseFP ");
		printHexPtrnp((page->baseFP));
		/* begin tab */
		printChar('\t');
		fprintf(GIV(transcript),
				"%s",
				"headFP ");
		printHexPtrnp((page->headFP));
		/* begin tab */
		printChar('\t');
		fprintf(GIV(transcript),
				"%s",
				"headSP ");
		printHexPtrnp((page->headSP));
	}
	cr();
	/* begin tab */
	printChar('\t');
	fprintf(GIV(transcript),
			"%s",
			"prev ");
	printHexPtrnp(page->prevPage);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" (");
	/* begin pageIndexFor: */
	assert((((((char *) ((((page->prevPage))->realStackLimit)))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) ((((page->prevPage))->realStackLimit)))) <= (((char *) GIV(pages))))));
	n3 = pageIndexForstackBasePlus1bytesPerPage((((page->prevPage))->realStackLimit), GIV(stackBasePlus1), GIV(bytesPerPage));
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n3));
	printChar(')');
	/* begin tab */
	printChar('\t');
	fprintf(GIV(transcript),
			"%s",
			"next ");
	printHexPtrnp(page->nextPage);
	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" (");
	/* begin pageIndexFor: */
	assert((((((char *) ((((page->nextPage))->realStackLimit)))) >= (GIV(stackBasePlus1) - 1)) && ((((char *) ((((page->nextPage))->realStackLimit)))) <= (((char *) GIV(pages))))));
	n4 = pageIndexForstackBasePlus1bytesPerPage((((page->nextPage))->realStackLimit), GIV(stackBasePlus1), GIV(bytesPerPage));
	/* begin printNum: */
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n4));
	printChar(')');
	cr();
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackReferencesTo: */
void
printStackReferencesTo(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);
			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (				/* begin frameReceiverLocation: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? theFP + FoxMFReceiver
					: theFP + FoxIFReceiver))) {
					if (oop == (longAt(theSP))) {
						fprintf(GIV(transcript),
								"FP:%p @ %p\n",
								theFP,
								theSP);
					}
					theSP += BytesPerWord;
				}
				if ((				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0))
				 && (oop == (longAt(theFP + FoxThisContext)))) {
					fprintf(GIV(transcript),
							"FP:%p CTXT\n",
							theFP);
				}
				if (oop == (longAt(theFP + FoxMethod))) {
					fprintf(GIV(transcript),
							"FP:%p MTHD\n",
							theFP);
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			/* a.k.a. FoxCallerContext */
			theSP = theFP + FoxCallerSavedIP;
			while (theSP <= ((thePage->baseAddress))) {
				if (oop == (longAt(theSP))) {
					fprintf(GIV(transcript),
							"FP:%p @ %p\n",
							theFP,
							theSP);
				}
				theSP += BytesPerWord;
			}
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static NoDbgRegParms void
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt code;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if (((oop & (tagMask())) != 0)) {
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		return;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	if (fmt < (firstByteFormat())) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOf(oop)))) ? ((max = 128)) : ((len = lengthOf(oop))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassByteArray) << (shiftForWord()))))), GIV(classByteArrayCompactIndex)))
	 || (	/* begin isLargeIntegerInstance: */
		((!(oop & (tagMask()))))
	 && ((((usqInt)(((longAt(oop)) & (classIndexMask())) - ClassLargeNegativeIntegerCompactIndex))) <= 1))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			code = byteAt((oop + BaseHeaderSize) + i);
			switch (code) {
			case 10:
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"<LF>");
				break;
			case 13:
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"<CR>");
				break;
			default:
				printChar(code);
			}
			i += 1;
		}
	}
	if (len > max) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"...");
	}
	fflush(GIV(transcript));
}

	/* StackInterpreter>>#print: */
void
print(char *s)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"%s",
			s);
}

	/* StackInterpreter>>#pushBool: */
void
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	object = 
	/* begin booleanObjectOf: */
(trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#pushedReceiverOrClosureOfFrame: */
static NoDbgRegParms sqInt
pushedReceiverOrClosureOfFrame(char *theFP)
{
	return longAt(theFP + (frameStackedReceiverOffset(theFP)));
}

	/* StackInterpreter>>#pushFloat: */
void
pushFloat(double f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	object = floatObjectOf(f);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* StackInterpreter>>#pushInteger: */
sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;


	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)integerValue << 3) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#push: */
void
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Append aLong to aFile in this platform's 'natural' byte order. aLong is
	either 32 or 64 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putLong:toFile: */
static NoDbgRegParms void
putLongtoFile(sqInt aLong, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aLong), sizeof(sqInt), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platform's 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putShort:toFile: */
static NoDbgRegParms void
putShorttoFile(short aShort, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aShort), sizeof(short), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

	/* StackInterpreter>>#putToSleep:yieldingIf: */
static NoDbgRegParms void
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt objOop;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((((oop) & 7) == 1));
	priority = (oop >> 3);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	/* begin fetchPointer:ofObject: */
	processLists = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	processList = longAt((processLists + BaseHeaderSize) + (((sqInt)((usqInt)((priority - 1)) << (shiftForWord())))));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList);
	}
	else {
		/* begin addFirstLink:toList: */
		assert(!(isForwarded(processList)));
		assert((fetchPointerofObject(NextLinkIndex, aProcess)) == (nilObject()));
		firstLink = longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
		assert(firstLink != aProcess);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(processList)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(processList)),
		oopisGreaterThanOrEqualTo(processList, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(aProcess & (tagMask()))))
			 && (oopisLessThan(aProcess, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(processList)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(processList);
				}
			}
		}
		longAtput((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))), aProcess);
		if (firstLink == GIV(nilObj)) {
			/* a.k.a. (self isEmptyList: aList) */
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(processList)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(processList)),
			oopisGreaterThanOrEqualTo(processList, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(aProcess & (tagMask()))))
				 && (oopisLessThan(aProcess, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(processList)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(processList);
					}
				}
			}
			longAtput((processList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aProcess)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(aProcess)),
			oopisGreaterThanOrEqualTo(aProcess, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(firstLink & (tagMask()))))
				 && (oopisLessThan(firstLink, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(aProcess)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(aProcess);
					}
				}
			}
			longAtput((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))), firstLink);
		}
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aProcess)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(aProcess)),
		oopisGreaterThanOrEqualTo(aProcess, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(processList & (tagMask()))))
			 && (oopisLessThan(processList, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(aProcess)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aProcess);
				}
			}
		}
		longAtput((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))), processList);
	}
}


/*	Append aWord32 to aFile in this platform's 'natural' byte order. aWord32
	is 32 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putWord32:toFile: */
static NoDbgRegParms void
putWord32toFile(int aWord32, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aWord32), 4, 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Anwer if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (((imageVersion | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask)) == 68021 /* begin imageFormatVersion */;
}


/*	Assuming the primFailCode is non-zero, check if the method consumes the
	error code
	and if so, assign it through theSP. Then zero the primFailCode. This is
	infrequent code,
	so keep it out of the common path. */

	/* StackInterpreter>>#reapAndResetErrorCodeTo:header: */
static NoDbgRegParms NeverInline void
reapAndResetErrorCodeToheader(char *theSP, sqInt methodHeader)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt initialPC;

	assert(GIV(primFailCode) != 0);
	initialPC = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize) + 3 /* begin sizeOfCallPrimitiveBytecode: */;
	if ((byteAt(initialPC)) == (	/* begin longStoreBytecodeForHeader: */
		((((sqLong) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
		longAtPointerput(theSP, getErrorObjectFromPrimFailCode());
	}
	GIV(primFailCode) = 0;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

	/* StackInterpreter>>#reestablishContextPriorToCallback: */
sqInt
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;

	flag("obsolete");
	/* begin isLiveContext: */
	assert(!((isOopForwarded(callbackContext))));
	if (!(		/* begin isContext: */
			((!(callbackContext & (tagMask()))))
		 && (((longAt(callbackContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if ((!((longAt((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())))) {
		if (((((longAt((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1)) {
			goto l1;
		}
		else {
			return 0;
		}
	}
	if (!(isWidowedContext(callbackContext))) {
		goto l1;
	}
	else {
		return 0;
	}
	l1:;
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext);
	/* begin isLiveContext: */
	assert(!((isOopForwarded(calloutContext))));
	if (!(		/* begin isContext: */
			((!(calloutContext & (tagMask()))))
		 && (((longAt(calloutContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if ((!((longAt((calloutContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())))) {
		if (((((longAt((calloutContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord()))))))) & 7) == 1)) {
			goto l2;
		}
		else {
			return 0;
		}
	}
	if (!(isWidowedContext(calloutContext))) {
		goto l2;
	}
	else {
		return 0;
	}
	l2:;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((!((longAt((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())))) {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext));
		assert(!(isOopForwarded(callbackContext)));
		longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(callbackContext)));
		longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - (smallIntegerTag()));
		if (GIV(framePointer) == theFP) {
			/* common case */
			if ((longAt(theFP + FoxSavedFP)) == 0) {
				freeStackPage(GIV(stackPage));
			}
			else {
				/* calloutContext is immediately below on the same page.  Make it current. */
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP))));
				GIV(stackPointer) = (GIV(framePointer) + (frameStackedReceiverOffset(GIV(framePointer)))) + BytesPerWord;
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackContext));
			assert(!(isOopForwarded(callbackContext)));
			longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(callbackContext)));
			longAtput((callbackContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
		}
	}
	if (	/* begin isStillMarriedContext: */
		(((((longAt((calloutContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(calloutContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - (smallIntegerTag()));
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		thePage = makeBaseFrameFor(calloutContext);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	return 1;
}


/*	Remove the first process from the given linked list. */

	/* StackInterpreter>>#removeFirstLinkOfList: */
static NoDbgRegParms sqInt
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;

	assert(!((isForwarded(aList))));
	first = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	last = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))));
	assert(!((isForwarded(first))));
	assert(!((isForwarded(last))));
	if (first == last) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(aList)));
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(aList)));
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		next = longAt((first + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(aList)),
		oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(next & (tagMask()))))
			 && (oopisLessThan(next, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(aList)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aList);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))), next);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(first)));
	longAtput((first + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))), GIV(nilObj));
	return first;
}


/*	Attempt to remove a process from a linked list. Answer if the attempt
	succeeded. 
 */

	/* StackInterpreter>>#removeProcess:fromList: */
static NoDbgRegParms sqInt
removeProcessfromList(sqInt aProcess, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt lastLink;
    sqInt nextLink;
    usqInt numSlots;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt tempLink;

	assert(!((isForwarded(aProcess))));
	assert(!((isForwarded(aList))));
	/* begin followObjField:ofObject: */
	objOop = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(FirstLinkIndex, aList, objOop);
	}
	firstLink = objOop;
	/* begin followObjField:ofObject: */
	objOop1 = longAt((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop1));
	if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(LastLinkIndex, aList, objOop1);
	}
	lastLink = objOop1;
	if (aProcess == firstLink) {
		/* begin followObjField:ofObject: */
		objOop2 = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		assert(isNonImmediate(objOop2));
		if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
			objOop2 = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, aProcess, objOop2);
		}
		nextLink = objOop2;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(aList)),
		oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(nextLink & (tagMask()))))
			 && (oopisLessThan(nextLink, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(aList)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(aList);
				}
			}
		}
		longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))), nextLink);
		if (aProcess == lastLink) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(aList)));
			longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))), GIV(nilObj));
		}
	}
	else {
		tempLink = firstLink;
		while (1) {
			if (!((				/* begin isPointers: */
					((!(tempLink & (tagMask()))))
				 && (((((usqInt)((longAt(tempLink)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
				 && (((assert((classIndexOf(tempLink)) > (isForwardedObjectClassIndexPun())),
				(((numSlots = byteAt(tempLink + 7))) == (numSlotsMask())
						? ((((usqInt)(((sqInt)((usqInt)((longAt(tempLink - BaseHeaderSize))) << 8)))))) >> 8
						: numSlots))) > MyListIndex))) {
				return 0;
			}
			/* begin followObjField:ofObject: */
			objOop3 = longAt((tempLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop3));
			if ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop3 = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, tempLink, objOop3);
			}
			nextLink = objOop3;
			if (nextLink == aProcess) break;
			tempLink = nextLink;
		}
		nextLink = longAt((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(tempLink)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(tempLink)),
		oopisGreaterThanOrEqualTo(tempLink, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(nextLink & (tagMask()))))
			 && (oopisLessThan(nextLink, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(tempLink)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(tempLink);
				}
			}
		}
		longAtput((tempLink + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))), nextLink);
		if (aProcess == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aList)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(aList)),
			oopisGreaterThanOrEqualTo(aList, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(tempLink & (tagMask()))))
				 && (oopisLessThan(tempLink, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(aList)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(aList);
					}
				}
			}
			longAtput((aList + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))), tempLink);
		}
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(aProcess)));
	longAtput((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))), GIV(nilObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(aProcess)));
	longAtput((aProcess + BaseHeaderSize) + (((sqInt)((usqInt)(MyListIndex) << (shiftForWord())))), GIV(nilObj));
	return 1;
}


/*	In Spur two cases of primitive failure are handled specially. A primitive
	may fail due to validation
	encountering a forwarder. On failure, check the accessorDepth for the
	primitive and if non-negative
	scan the args to the depth, following any forwarders. Retry the primitive
	if any are found. Hence
	lazily and transparently following forwarders on primitive failure.
	Additionally a primitive might fail
	due to an allocation failing. Retry if external primitives have failed
	with PrimErrNoMemory after running
	first the scavenger and then on a subsequent failure, the global
	mark-sweep collector. Hence lazily
	and transparently GC on memory exhaustion. */

	/* StackInterpreter>>#retryPrimitiveOnFailure */
static sqInt
retryPrimitiveOnFailure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt accessorDepth;
    sqInt aMethodSelectorOrImmediate;
    sqInt canRetry;
    sqInt firstBytecode;
    sqInt firstBytecode1;
    sqInt firstBytecode2;
    sqInt flags;
    sqInt followDone;
    sqInt found;
    sqInt found1;
    sqInt gcDone;
    sqInt header;
    sqInt header1;
    sqInt header2;
    sqInt index;
    sqInt lit;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    sqInt oop;
    sqInt primIndex;
    sqInt primIndex1;
    sqInt primitiveIndex;
    sqInt referent;
    sqInt retried;
    sqInt retry;
    sqInt scannedStackFrame;
    sqInt tagBits;

	/* begin primitiveIndexOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	header = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	primitiveIndex = (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
	assert(saneFunctionPointerForFailureOfPrimIndex(primitiveIndex));
	gcDone = 0;
	followDone = (canRetry = (retried = 0));
	while (1) {
		retry = 0;
		if (GIV(primFailCode) == PrimErrNoMemory) {
			if (((gcDone += 1)) == 1) {
				canRetry = primitiveIndex == PrimNumberExternalCall;
			}
			if (canRetry) {
				if (gcDone == 1) {
					/* begin scavengingGC */
					scavengingGCTenuringIf(TenureByAge);
				}
				if (gcDone == 2) {
					fullGC();
				}
				retry = gcDone <= 2;
			}
		}
		else {
			if (!followDone) {
				followDone = 1;
				/* begin checkForAndFollowForwardedPrimitiveState */
				if ((recordPrimTrace())
				 && (!primTracePluginName)) {
					/* begin fastLogPrim: */
					GIV(primTraceLog)[GIV(primTraceLogIndex)] = TracePrimitiveFailure;
					primTraceLogIndex(GIV(primTraceLogIndex) + 1);
					/* begin fetchClassOf: */
					if (((tagBits = (longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord))) & (tagMask()))) != 0) {
						aMethodSelectorOrImmediate = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (((sqInt)((usqInt)(tagBits) << (shiftForWord())))));
					}
					else {
						aMethodSelectorOrImmediate = fetchClassOfNonImm(longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord)));
					}
					/* begin fastLogPrim: */
					GIV(primTraceLog)[GIV(primTraceLogIndex)] = aMethodSelectorOrImmediate;
					primTraceLogIndex(GIV(primTraceLogIndex) + 1);
				}
				assert(failed());
				found1 = 0;
				/* begin primitiveIndexOf: */
				assert(isCompiledMethod(GIV(newMethod)));
				header2 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
				methodHeader2 = ((((header2) & 7) == 1)
					? header2
					: (assert((((usqInt)header2)) < GIV(newSpaceStart)),
						assert((((((CogMethod *) header2))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
						((((CogMethod *) header2))->methodHeader)));
				primIndex = (((methodHeader2 & AlternateHeaderHasPrimFlag) != 0)
					? ((firstBytecode2 = (GIV(newMethod) + ((LiteralStart + (((methodHeader2 >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
						(byteAt(firstBytecode2 + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode2 + 2))) << 8))))
					: 0);
				assert((GIV(argumentCount) == (argumentCountOf(GIV(newMethod))))
				 || (isMetaPrimitiveIndex(primIndex)));
				if (((				/* begin isCalloutPrimitiveIndex: */
					(primIndex == PrimNumberExternalCall)
				 || (primIndex == PrimNumberFFICall))
				 || (primIndex == PrimNumberDoExternalCall))
				 && (unfollowFirstLiteralOfMaybeCalloutMethodprimitiveIndex(GIV(newMethod), primIndex))) {
					found1 = 1;
				}
				if ((				/* begin isMetaPrimitiveIndex: */
					(primIndex == PrimNumberDoPrimitive)
				 || (primIndex == PrimNumberDoExternalCall))
				 && (GIV(metaAccessorDepth) > -2)) {
					accessorDepth = GIV(metaAccessorDepth);
				}
				else {
					/* begin accessorDepthForPrimitiveMethod: */
					assert(isCompiledMethod(GIV(newMethod)));
					header1 = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
					methodHeader1 = ((((header1) & 7) == 1)
						? header1
						: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
							assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
							((((CogMethod *) header1))->methodHeader)));
					primIndex1 = (((methodHeader1 & AlternateHeaderHasPrimFlag) != 0)
						? ((firstBytecode1 = (GIV(newMethod) + ((LiteralStart + (((methodHeader1 >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
							(byteAt(firstBytecode1 + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode1 + 2))) << 8))))
						: 0);
					if ((primIndex1 == PrimNumberExternalCall)
					 && (isLinkedExternalPrimitive(GIV(newMethod)))) {
						/* begin accessorDepthForExternalPrimitiveMethod: */
						assert(isLinkedExternalPrimitive(GIV(newMethod)));
						lit = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))));
						flags = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))));
						accessorDepth = (((flags >> 3))) >> SpurPrimitiveAccessorDepthShift;
					}
					else {
						accessorDepth = ((sqInt)((primitiveMetadataTable[primIndex1]))) >> SpurPrimitiveAccessorDepthShift;
					}
				}
				assert(((accessorDepth >= -1) && (accessorDepth <= 5)));
				if (accessorDepth >= 0) {
					scannedStackFrame = 0;
					for (index = 0; index <= GIV(argumentCount); index += 1) {
						oop = longAt(GIV(stackPointer) + (index * BytesPerWord));
						if ((!(oop & (tagMask())))) {
							if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
								assert(index < GIV(argumentCount));
								found1 = 1;
								/* begin followForwarded: */
								assert(isUnambiguouslyForwarder(oop));
								referent = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
								while (								/* begin isOopForwarded: */
									((!(referent & (tagMask()))))
								 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
									referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
								}
								oop = referent;
								/* begin stackValue:put: */
								longAtput(GIV(stackPointer) + (index * BytesPerWord), oop);
								if (!scannedStackFrame) {
									scannedStackFrame = 1;
									followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord));
								}
							}
							if ((accessorDepth > 0)
							 && ((							/* begin hasPointerFields: */
								((!(oop & (tagMask()))))
							 && (hasPointerFieldsNonImm(oop)))
							 && (followForwardedObjectFieldstoDepth(oop, accessorDepth)))) {
								found1 = 1;
							}
						}
					}
				}
				found = found1;
				if (found
				 && (recordPrimTrace())) {
					/* begin fastLogPrim: */
					GIV(primTraceLog)[GIV(primTraceLogIndex)] = TracePrimitiveRetry;
					primTraceLogIndex(GIV(primTraceLogIndex) + 1);
				}
				retry = found;
			}
		}
		if (!(retry)) break;
		assert(GIV(primFailCode) != 0);
		retried = 1;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
	}
	return retried;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

	/* StackInterpreter>>#returnAs:ThroughCallback:Context: */
sqInt
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    sqInt aMethodObj1;
    sqInt calloutMethodContext;
    sqInt cFramePointer;
    sqInt cFramePointer1;
    sqInt cStackPointer;
    sqInt cStackPointer1;
    sqInt senderOop;
    sqInt senderOop1;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;

	assert(GIV(primFailCode) == 0);
	assert((((returnTypeOop) & 7) == 1));
	assert(!(isImmediate(((sqInt)vmCallbackContext))));
	assert((addressCouldBeObj(callbackMethodContext))
	 && (isContext(callbackMethodContext)));
	assert(((debugCallbackPath = 0)) == 0);
	if (!(((((returnTypeOop) & 7) == 1))
		 && (isLiveContext(callbackMethodContext)))) {
		assert(((debugCallbackPath = 1)) == 1);
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext);
	if (!(isLiveContext(calloutMethodContext))) {
		assert(((debugCallbackPath = 2)) == 2);
		return 0;
	}
	assert(((debugCallbackReturns += 1)) > 0);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((!((longAt((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))))) & (tagMask())))) {
		assert(((debugCallbackPath = debugCallbackPath | 4)) > 0);
		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext));
		assert(!(isOopForwarded(callbackMethodContext)));
		longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(callbackMethodContext)));
		longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 8)) > 0);
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - (smallIntegerTag()));
		assert((frameReceiver(theFP)) == (splObj(ClassAlien)));
		if (GIV(framePointer) == theFP) {
			/* common case */
			assert(((debugCallbackPath = debugCallbackPath | 16)) > 0);
			if (!((longAt(theFP + FoxSavedFP)) == 0)) {
				/* calloutMethodContext is immediately below on the same page.  Make it current. */
				assert(((debugCallbackPath = debugCallbackPath | 32)) > 0);
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
				GIV(stackPointer) = (theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord;
				GIV(framePointer) = pointerForOop(longAt(theFP + FoxSavedFP));
				aMethodObj = 
				/* begin frameMethodObject: */
((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
					? ((mframeHomeMethod(GIV(framePointer)))->methodObject)
					: longAt(GIV(framePointer) + FoxMethod));
				assert((((usqInt)aMethodObj)) >= (startOfMemory()));
				GIV(method) = aMethodObj;
				assert(isOopCompiledMethod(GIV(method)));
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
					? 0x100
					: 0);
				/* begin restoreCStackStateForCallbackContext: */
				cFramePointer = ((sqInt) ((vmCallbackContext->savedCFramePointer)));
				cStackPointer = ((sqInt) ((vmCallbackContext->savedCStackPointer)));
				/* begin setCFramePointer:setCStackPointer: */
				assert(!(((!cFramePointer)
 || (!cStackPointer))));
				GIV(CStackPointer) = cStackPointer;
				GIV(CFramePointer) = cFramePointer;
				/* begin assertValidExecutionPointe:r:s: */
				assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())), __LINE__);
				_longjmp((vmCallbackContext->trampoline), (returnTypeOop >> 3));
				return 1;
			}
			freeStackPage(GIV(stackPage));
		}
		else {
			assert(((debugCallbackPath = debugCallbackPath | 64)) > 0);
			externalDivorceFrameandContext(theFP, callbackMethodContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext));
			assert(!(isOopForwarded(callbackMethodContext)));
			longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(callbackMethodContext)));
			longAtput((callbackMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
		}
	}
	if (	/* begin isStillMarriedContext: */
		(((((longAt((calloutMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(calloutMethodContext)))) {
		assert(((debugCallbackPath = debugCallbackPath | 128)) > 0);
		/* begin frameOfMarriedContext: */
		senderOop1 = longAt((calloutMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop1) & 7) == 1));
		theFP = pointerForOop(senderOop1 - (smallIntegerTag()));
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (((thePage->headFP)) == theFP
			? (thePage->headSP)
			: (findSPOfon(theFP, thePage)) - BytesPerWord);
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 0x100)) > 0);
		thePage = makeBaseFrameFor(calloutMethodContext);
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
	aMethodObj1 = longAt((calloutMethodContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord())))));
	/* begin setMethod: */
	assert((((usqInt)aMethodObj1)) >= (startOfMemory()));
	GIV(method) = aMethodObj1;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 0x100
		: 0);
	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin restoreCStackStateForCallbackContext: */
	cFramePointer1 = ((sqInt) ((vmCallbackContext->savedCFramePointer)));
	cStackPointer1 = ((sqInt) ((vmCallbackContext->savedCStackPointer)));
	/* begin setCFramePointer:setCStackPointer: */
	assert(!(((!cFramePointer1)
 || (!cStackPointer1))));
	GIV(CStackPointer) = cStackPointer1;
	GIV(CFramePointer) = cFramePointer1;
	_longjmp((vmCallbackContext->trampoline), (returnTypeOop >> 3));
	return 1;
}


/*	Reverse the given range of Display pixels, rounded to whole word boundary.
	Used to give feedback during VM activities such as garbage collection when
	debugging. It is assumed that the given word range falls entirely within
	the first line of the Display. */

	/* StackInterpreter>>#reverseDisplayFrom:to: */
static NoDbgRegParms void
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt primFailCodeValue;
    sqInt ptr;
    unsigned int reversed;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	if (!(postGCUpdateDisplayBits())) {
		return;
	}
	if ((displayBits == 0)
	 || (((((((sqInt)displayBits)) & (tagMask())) != 0))
	 || (displayDepth <= 0))) {
		return;
	}
	wordStartIndex = ((((startIndex < 0) ? 0 : startIndex)) * displayDepth) / 32;
	wordEndIndex = ((((endIndex < displayWidth) ? endIndex : displayWidth)) * displayDepth) / 32;
	for (ptr = ((((sqInt)displayBits)) + (wordStartIndex * 4)); ptr <= ((((sqInt)displayBits)) + (wordEndIndex * 4)); ptr += 4) {
		reversed = (long32At(ptr)) ^ 0xFFFFFFFFU;
		long32Atput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	updateDisplayLeftTopRightBottom(0, 0, displayWidth, 1);
	ioForceDisplayUpdate();
	GIV(primFailCode) = primFailCodeValue;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims. */

	/* StackInterpreter>>#rewriteMethodCacheEntryForExternalPrimitiveToFunction: */
static NoDbgRegParms void
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)())
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((sqIntptr_t) localPrimAddress));
	}
}


/*	Safe version of methodClassOf: that deals with malformed compiled methods,
	etc, and does not fixup forwarding pointers.. */

	/* StackInterpreter>>#safeMethodClassOf: */
static NoDbgRegParms sqInt
safeMethodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt maybeClass;
    usqInt numSlots;
    sqInt offset;
    sqInt referent;
    sqInt referent1;

	offset = (literalCountOf(methodPointer)) - 1;
	/* begin literal:ofMethod: */
	literal = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(literal & (tagMask()))))
	 && ((!((longAt(literal)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(literal));
		referent = longAt((literal + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		literal = referent;
	}
	if (!((		/* begin isPointers: */
			((!(literal & (tagMask()))))
		 && (((((usqInt)((longAt(literal)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */))
		 && (((assert((classIndexOf(literal)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(literal + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(literal - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots))) > ValueIndex))) {
		return GIV(nilObj);
	}
	maybeClass = longAt((literal + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(maybeClass & (tagMask()))))
	 && ((!((longAt(maybeClass)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(maybeClass));
		referent1 = longAt((maybeClass + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent1 & (tagMask()))))
		 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		maybeClass = referent1;
	}
	return maybeClass;
}


/*	This is an assert function used to ensure consistency between the
	primitiveFunctionPointer and the primitive index when a primitive fails in
	Spur. Since Spur automagically retries
	failing primitives we want to know that the primitiveFunctionPointer is
	actually valid. This isn't
	always possible for the `indirect'' primitives (calling a plugin
	primitive, calling the ffi, using the
	receiver:tryPrimitive:withArgs: primitive evaluator in the simulator. We
	do the best we can. */

	/* StackInterpreter>>#saneFunctionPointerForFailureOfPrimIndex: */
static NoDbgRegParms sqInt
saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*basePrimitive)(void);


	/* begin functionPointerFor:inClass: */
	basePrimitive = ((void (*)(void)) ((primIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIndex])));
	return (primitiveFunctionPointer == basePrimitive)
	 || (((	/* begin isCalloutPrimitiveIndex: */
		(primIndex == PrimNumberExternalCall)
	 || (primIndex == PrimNumberFFICall))
	 && (!((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex)))
	 || ((	/* begin isMetaPrimitiveIndex: */
		(primIndex == PrimNumberDoPrimitive)
	 || (primIndex == PrimNumberDoExternalCall))
	 && (GIV(metaAccessorDepth) > -2)));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#setBreakMNUSelector: */
void
setBreakMNUSelector(char *aString)
{
	if (((breakSelector = aString)) == null) {
		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = -(strlen(aString));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#setBreakSelector: */
void
setBreakSelector(char *aString)
{
	if (((breakSelector = aString)) == null) {
		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
	else {
		breakSelectorLength = strlen(aString);
	}
}

	/* StackInterpreter>>#setFullScreenFlag: */
void
setFullScreenFlag(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(fullScreenFlag) = value;
}

	/* StackInterpreter>>#setInterruptCheckChain: */
void *
setInterruptCheckChain(void (*aFunction)())
{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

	/* StackInterpreter>>#setInterruptKeycode: */
void
setInterruptKeycode(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptKeycode) = value;
}

	/* StackInterpreter>>#setInterruptPending: */
void
setInterruptPending(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	forceInterruptCheck();
	GIV(interruptPending) = value;
}

	/* StackInterpreter>>#setNextWakeupUsecs: */
void
setNextWakeupUsecs(usqLong value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(nextWakeupUsecs) = value;
}

	/* StackInterpreter>>#setSavedWindowSize: */
void
setSavedWindowSize(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

	/* StackInterpreter>>#setSignalLowSpaceFlagAndSaveProcess */
static void
setSignalLowSpaceFlagAndSaveProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;
    sqInt objOop;
    sqInt objOop1;


	/* begin signalLowSpace: */
	GIV(signalLowSpace) = 1;
	/* N.B. The threshold > 0 guard eliminates a warning when
	   self lowSpaceThreshold: 0
	   is inlined into setSignalLowSpaceFlagAndSaveProcess */
	GIV(lowSpaceThreshold) = 0;
	assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
	lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessSignalingLowSpace) << (shiftForWord())))));
	if (lastSavedProcess == GIV(nilObj)) {
		/* begin activeProcess */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		/* begin splObj:put: */
		objOop1 = GIV(specialObjectsOop);
		assert(!(isForwarded(objOop1)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(objOop1)),
		oopisGreaterThanOrEqualTo(objOop1, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(activeProc & (tagMask()))))
			 && (oopisLessThan(activeProc, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(objOop1)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(objOop1);
				}
			}
		}
		longAtput((objOop1 + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessSignalingLowSpace) << (shiftForWord())))), activeProc);
	}
	forceInterruptCheck();
}

	/* StackInterpreter>>#setTraceFlagOnContextsFramesPageIfNeeded: */
static NoDbgRegParms void
setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *pointer;
    sqInt senderOop;
    StackPage *thePage;

	if (	/* begin isStillMarriedContextDuringGC: */
		(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContextDuringGC(aContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		pointer = pointerForOop(senderOop - (smallIntegerTag()));
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) pointer)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) pointer)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(pointer, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		assert(((((thePage->trace)) >= StackPageUnreached) && (((thePage->trace)) <= StackPageTraced)));
		if (((thePage->trace)) == StackPageUnreached) {
			(thePage->trace = StackPageReachedButUntraced);
		}
	}
}

	/* StackInterpreter>>#shortPrintContext: */
static NoDbgRegParms sqInt
shortPrintContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt home;
    sqInt rcvr;
    sqInt senderOop;
    char *theFP;

	if (!(		/* begin isContext: */
			((!(aContext & (tagMask()))))
		 && (((longAt(aContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		printHex(aContext);
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is not a context");
		cr();
		return null;
	}
	printHex(aContext);
	if (((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			theFP = pointerForOop(senderOop - (smallIntegerTag()));
			if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" M (");
			}
			else {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" I (");
			}
			printHex(((usqIntptr_t)theFP));
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					") ");
		}
		else {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" w ");
		}
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" s ");
	}
	home = findHomeForContext(aContext);
	if (home == null) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" BOGUS CONTEXT (can't determine home)");
		cr();
	}
	else {
		rcvr = longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)(ReceiverIndex) << (shiftForWord())))));
		printActivationNameForreceiverisBlockfirstTemporary(longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(MethodIndex) << (shiftForWord()))))), rcvr, home != aContext, longAt((home + BaseHeaderSize) + (((sqInt)((usqInt)((0 + CtxtTempFrameStart)) << (shiftForWord()))))));
		/* begin space */
		printChar(' ');
		shortPrintOop(rcvr);
	}
	return 0;
}

	/* StackInterpreter>>#shortPrintFrameAndCallers: */
static NoDbgRegParms sqInt
shortPrintFrameAndCallers(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(		/* begin couldBeFramePointer: */
			(GIV(stackBasePlus1))
		 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages))))))))) {
		return null;
	}
	shortPrintFrame(theFP);
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		shortPrintFrameAndCallers(pointerForOop(longAt(theFP + FoxSavedFP)));
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#shortPrintFramesInPage: */
void
shortPrintFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 1);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#shortPrintFramesOnStackPageListInUse */
void
shortPrintFramesOnStackPageListInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"page ");
			printHexPtrnp(page);
			cr();
			shortPrintFramesInPage(page);
			cr();
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#shortPrintFrame:AndNCallers: */
void
shortPrintFrameAndNCallers(char *theFP, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((n != 0)
	 && (	/* begin couldBeFramePointer: */
		(GIV(stackBasePlus1))
	 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theFP)) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages))))))))) {
		shortPrintFrame(theFP);
		shortPrintFrameAndNCallers(pointerForOop(longAt(theFP + FoxSavedFP)), n - 1);
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static NoDbgRegParms void
shortPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *className;
    sqInt length;

	length = 0;
	if (((oop & (tagMask())) != 0)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (((longAt(oop)) & (classIndexMask())) == (isFreeObjectClassIndexPun())) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	className = nameOfClasslengthInto(fetchClassOfNonImm(oop), (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s\n",
			((void *)oop),
			((int) length),
			className);
}

	/* StackInterpreter>>#shortReversePrintFrameAndCallers: */
static NoDbgRegParms sqInt
shortReversePrintFrameAndCallers(char *aFramePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt caller;
    sqInt callerContextOrNil;
    char *callerFP;
    sqInt referent;
    char *theFP;
    StackPage *thePage;

	if (aFramePointer == 0) {
		return GIV(nilObj);
	}
	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP);
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	/* begin frameCallerContext: */
	assert(isBaseFrame(theFP));
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	callerContextOrNil = longAt((thePage->baseAddress));
	assert(addressCouldBeObj(callerContextOrNil));
	assert((callerContextOrNil == (nilObject()))
	 || (isContext(followMaybeForwarded(callerContextOrNil))));
	caller = callerContextOrNil;
	if ((!((longAt(caller)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(caller));
		referent = longAt((caller + BaseHeaderSize) + (0U << (shiftForWord())));
		while (		/* begin isOopForwarded: */
			((!(referent & (tagMask()))))
		 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
		}
		caller = referent;
	}
	return caller;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#showDisplayBits:Left:Top:Right:Bottom: */
sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (deferDisplayUpdates
	 || (aForm != (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(TheDisplay) << (shiftForWord())))))))) {
		return null;
	}
	updateDisplayLeftTopRightBottom(l, t, r, b);
	return 0;
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

	/* StackInterpreter>>#signalExternalSemaphores */
static sqInt
signalExternalSemaphores(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	return doSignalExternalSemaphores(
		(		/* begin numSlotsOf: */
			assert((classIndexOf(xArray)) > (isForwardedObjectClassIndexPun())),
		(((numSlots = byteAt(xArray + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(xArray - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots)));
}


/*	Answer the size of the CallPrimitive bytecode that may be used to store a
	method's primitive.
 */
/*	NewsqueakV4:	249	11111001	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */
/*	SistaV1:		248	11111000 iiiiiiii	mssjjjjj	Call Primitive #iiiiiiii + (
	jjjjj * 256) */
/*	V3+Closures:	139	11101111	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 3;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

	/* StackInterpreter>>#sizeOfSTArrayFromCPrimitive: */
sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(		/* begin isWordsOrBytes: */
			((!(oop & (tagMask()))))
		 && (isWordsOrBytesNonImm(oop)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin lengthOf: */
	fmt = (((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Invoke a normal (non-quick) primitive.
	Called under the assumption that primFunctionPointer has been preloaded. */

	/* StackInterpreter>>#slowPrimitiveResponse */
static int
slowPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt nArgs;
    char *savedFramePointer;
    char *savedStackPointer;

	assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
	assert((remapBufferCount()) == 0);
	nArgs = GIV(argumentCount);
	savedStackPointer = GIV(stackPointer);
	savedFramePointer = GIV(framePointer);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	if (	/* begin recordPrimTraceForMethod: */
		(recordPrimTrace())
	 && ((primTracePluginName == null
		? 1
		: methodHasPrimitiveInPrimTracePlugin(GIV(newMethod))))) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(newMethod);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	dispatchFunctionPointer(primitiveFunctionPointer);
	assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
	/* begin maybeRetryPrimitiveOnFailure */
	if (GIV(primFailCode)) {
		retryPrimitiveOnFailure();
	}
	if ((!GIV(primFailCode))
	 && ((GIV(framePointer) == savedFramePointer)
	 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))))) {
		/* Don't fail if primitive has done something radical, e.g. perform: */
		if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			failUnbalancedPrimitive();
			GIV(stackPointer) = savedStackPointer;
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	return !GIV(primFailCode);
}


/*	update state of active context */

	/* StackInterpreter>>#snapshot: */
static NoDbgRegParms sqInt
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    CogMethod *cogMethod;
    sqInt i;
    usqInt initialIP;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt objOop;
    sqInt oop;
    sqInt rcvr;
    sqInt rcvr1;
    sqInt savedTenuringThreshold;
    void *setMacType;
    char *sp;
    char *sp1;
    char *sp10;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt stackIndex;


	/* For now the stack munging below doesn't deal with more than one argument.
	   It can, and should. */
	rcvr = 0;
	if (GIV(argumentCount) != 0) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* update state of active process */
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(1);
	/* begin activeProcess */
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(activeProc)));
	if ((	/* begin isOldObject: */
		assert(isNonImmediate(activeProc)),
	oopisGreaterThanOrEqualTo(activeProc, GIV(oldSpaceStart)))) {
		/* most stores into young objects */
		if (		/* begin isYoung: */
			((!(activeContext & (tagMask()))))
		 && (oopisLessThan(activeContext, GIV(oldSpaceStart)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt)((longAt(activeProc)))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(activeProc);
			}
		}
	}
	longAtput((activeProc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);
	GIV(tempOop) = activeContext;
	/* begin garbageCollectForSnapshot */
	savedTenuringThreshold = GIV(tenureThreshold);
	GIV(tenureThreshold) = GIV(oldSpaceStart);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
	flag("If we wanted to shrink the rememberedSet prior to snapshot this is the place to do it.");
	/* begin biasForSnapshot */
	GIV(biasForGC) = 0;
	fullGC();
	/* begin biasForGC */
	GIV(biasForGC) = 1;
	prepareForSnapshot();
	/* begin checkFreeSpace: */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (((checkForLeaks & (GCCheckFreeSpace | GCModeFull)) == (GCCheckFreeSpace | GCModeFull))) {
		runLeakCheckerForFreeSpaceignoring(GCCheckFreeSpace, null);
	}
	activeContext = GIV(tempOop);
	GIV(tempOop) = 0;
	if (!GIV(primFailCode)) {
		/* Without contexts or stacks simulate
		   rcvr := self popStack. ''pop rcvr''
		   self push: trueObj.
		   to arrange that the snapshot resumes with true.  N.B. stackIndex is one-relative. */
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		assert((((oop) & 7) == 1));
		stackIndex = (oop >> 3);
		rcvr = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(activeContext)));
		longAtput((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())))), GIV(trueObj));
		writeImageFileIO();
		if ((!GIV(primFailCode))
		 && (!embedded)) {
			/* set Mac file type and creator; this is a noop on other platforms */
			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(activeContext)));
		longAtput((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)(stackIndex - 1) << 3) | 1));
	}
	postSnapshot();
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
	if (GIV(primFailCode)) {
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp2;
		/* begin justActivateNewMethod: */
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		cogMethod = null;
		if ((		/* begin isCogMethodReference: */
			assert(((((methodHeader) & 7) == 1))
			 || (((((usqInt)methodHeader)) < (startOfMemory()))
			 && ((((usqInt)methodHeader)) >= (minCogMethodAddress())))),
		/* begin isNonIntegerObject: */
(!(methodHeader & (smallIntegerTag()))))) {
			cogMethod = ((CogMethod *) methodHeader);
			methodHeader = (cogMethod->methodHeader);
			cogMethod = null;
		}
		numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
		numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;
		/* could new rcvr be set at point of send? */
		rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr1)));
		if ((cogMethod)
		 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())))) {
			if (GIV(instructionPointer) >= (startOfMemory())) {
				/* begin iframeSavedIP:put: */
				assert(!(isMachineCodeFrame(GIV(framePointer))));
				longAtput(GIV(framePointer) + FoxIFSavedIP, GIV(instructionPointer));
			}
			GIV(instructionPointer) = ceReturnToInterpreterPC();
		}
		/* begin push: */
		longAtput((sp10 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp10;
		/* begin push: */
		longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp11;
		GIV(framePointer) = GIV(stackPointer);
		initialIP = (GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask))) * BytesPerOop)) + BaseHeaderSize;
		if (cogMethod == null) {
			/* begin push: */
			longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
			GIV(stackPointer) = sp21;
			/* begin setMethod:methodHeader: */
			GIV(method) = GIV(newMethod);
			assert(isOopCompiledMethod(GIV(method)));
			assert((methodHeaderOf(GIV(method))) == methodHeader);
			GIV(bytecodeSetSelector) = ((((sqLong) methodHeader)) < 0
				? 0x100
				: 0);
			/* begin push: */
			longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp3;
			object = 
			/* begin encodeFrameFieldHasContext:isBlock:numArgs: */
(VMBIGENDIAN
				? ((1 + (((sqInt)((usqInt)(numArgs) << ((BytesPerWord * 8) - 8))))) + (0)) + (0)
				: ((1 + (((sqInt)((usqInt)(numArgs) << 8)))) + (0)) + (0));
			/* begin push: */
			longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
			GIV(stackPointer) = sp4;
			/* begin push: */
			longAtput((sp5 = GIV(stackPointer) - BytesPerWord), 0);
			GIV(stackPointer) = sp5;
			GIV(instructionPointer) = initialIP - 1;
		}
		else {
			/* begin push: */
			longAtput((sp6 = GIV(stackPointer) - BytesPerWord), ((usqInt)cogMethod));
			GIV(stackPointer) = sp6;
			/* begin push: */
			longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp7;
			GIV(instructionPointer) = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
		}
		/* begin push: */
		longAtput((sp8 = GIV(stackPointer) - BytesPerWord), rcvr1);
		GIV(stackPointer) = sp8;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp9 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp9;
		}
		if (((methodHeader & AlternateHeaderHasPrimFlag) != 0)) {
			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			if (!cogMethod) {
				GIV(instructionPointer) += 3 /* begin sizeOfCallPrimitiveBytecode: */;
			}
			if (GIV(primFailCode) != 0) {
				reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
			}
		}
	}
	else {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp1;
	}
	return 0;
}

	/* StackInterpreter>>#specialSelector: */
sqInt
specialSelector(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)((index * 2)) << (shiftForWord())))));
}


/*	Insulate the stack zone from the effects of a become.
	All receivers must be unfollowed for two reasons:
	1. inst var access is direct with no read barrier
	2. super sends (always to the receiver) have no class check and so don't
	trap for forwarded receivers. This is an issue for primitives that assume
	their receiver
	is valid and don't validate.
	Super sends require an explicit check to ensure receivers in super sends
	are unforwarded.
	e.g. super doSomethingWith: (self become: other) forwards the receiver
	self pushed on the
	stack. So we could avoid following non-pointer receivers. But this is too
	tricky, Instead, we
	always follow receivers.
	Methods must be unfollowed since bytecode access is direct with no read
	barrier. But this only needs to be done if the becomeEffectsFlags indicate
	that a
	CompiledMethod was becommed.
	The scheduler state must be followed, but only if the becomeEffectsFlags
	indicate that a pointer object was becommed. */
/*	For VM profiling */

	/* StackInterpreter>>#spurPostBecomeAction: */
static NoDbgRegParms void
spurPostBecomeAction(sqInt theBecomeEffectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anArray;
    sqInt anArray1;
    sqInt anArray2;
    sqInt anArray3;
    sqIntptr_t c;
    sqIntptr_t c1;
    sqInt first;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt ipdelta;
    sqInt last;
    sqInt list;
    sqIntptr_t m;
    sqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt obj1;
    sqInt obj2;
    sqInt obj3;
    sqInt obj4;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt procLists;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent12;
    sqInt referent2;
    sqInt referent21;
    sqInt referent3;
    sqInt referent31;
    sqInt referent4;
    sqInt referent41;
    sqInt referent5;
    sqInt referent6;
    sqIntptr_t s;
    sqIntptr_t s1;
    sqInt sched;
    sqInt schedAssoc;
    sqInt xArray;

	if (theBecomeEffectsFlags != 0) {
		if (((theBecomeEffectsFlags & BecameActiveClassFlag) != 0)) {
			/* begin flushBecommedClassesInMethodCache */
			for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
				c = GIV(methodCache)[i + MethodCacheClass];
				s = GIV(methodCache)[i + MethodCacheSelector];
				if ((c != 0)
				 && ((s != 0)
				 && (isForwarded(classOrNilAtIndex(c))))) {
					GIV(methodCache)[i + MethodCacheClass] = 0;
					GIV(methodCache)[i + MethodCacheSelector] = 0;
				}
			}
			unlinkSendsLinkedForInvalidClasses();
		}
		if (((theBecomeEffectsFlags & BecamePointerObjectFlag) != 0)) {
			/* begin followForwardingPointersInScheduler */
			/* the GC follows pointers in the special objects array for us. */
			schedAssoc = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))));
			assert(!(isForwarded(schedAssoc)));
			followForwardedObjectFieldstoDepth(schedAssoc, 1);
			sched = longAt((schedAssoc + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
			/* begin followObjField:ofObject: */
			objOop = longAt((sched + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
			assert(isNonImmediate(objOop));
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				objOop = fixFollowedFieldofObjectwithInitialValue(ProcessListsIndex, sched, objOop);
			}
			procLists = objOop;
			for (i1 = 0, iLimiT = (((/* begin numSlotsOf: */
	assert((classIndexOf(procLists)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(procLists + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(procLists - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - 1); i1 <= iLimiT; i1 += 1) {
				/* begin followObjField:ofObject: */
				objOop1 = longAt((procLists + BaseHeaderSize) + (((sqInt)((usqInt)(i1) << (shiftForWord())))));
				assert(isNonImmediate(objOop1));
				if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop1 = fixFollowedFieldofObjectwithInitialValue(i1, procLists, objOop1);
				}
				list = objOop1;
				/* begin followObjField:ofObject: */
				objOop2 = longAt((list + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop2));
				if ((!((longAt(objOop2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop2 = fixFollowedFieldofObjectwithInitialValue(FirstLinkIndex, list, objOop2);
				}
				first = objOop2;
				/* begin followObjField:ofObject: */
				objOop3 = longAt((list + BaseHeaderSize) + (((sqInt)((usqInt)(LastLinkIndex) << (shiftForWord())))));
				assert(isNonImmediate(objOop3));
				if ((!((longAt(objOop3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					objOop3 = fixFollowedFieldofObjectwithInitialValue(LastLinkIndex, list, objOop3);
				}
				last = objOop3;
				while (first != last) {
					/* begin followObjField:ofObject: */
					objOop4 = longAt((first + BaseHeaderSize) + (((sqInt)((usqInt)(NextLinkIndex) << (shiftForWord())))));
					assert(isNonImmediate(objOop4));
					if ((!((longAt(objOop4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						objOop4 = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, first, objOop4);
					}
					next = objOop4;
					first = next;
				}
			}
			/* begin followForwardingPointersInSpecialObjectsArray */
			anArray = specialObjectsOop();
			obj = longAt((anArray + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))));
			if ((!((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj));
				referent12 = longAt((obj + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent12 & (tagMask()))))
				 && ((!((longAt(referent12)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent12 = longAt((referent12 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				obj = referent12;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(anArray)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(anArray)),
				oopisGreaterThanOrEqualTo(anArray, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(obj & (tagMask()))))
					 && (oopisLessThan(obj, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(anArray)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(anArray);
						}
					}
				}
				longAtput((anArray + BaseHeaderSize) + (((sqInt)((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))), obj);
			}
			anArray1 = specialObjectsOop();
			/* begin followSemaphoreIn:at: */
			obj1 = longAt((anArray1 + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord())))));
			if ((!((longAt(obj1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj1));
				referent21 = longAt((obj1 + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent21 & (tagMask()))))
				 && ((!((longAt(referent21)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent21 = longAt((referent21 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				obj1 = referent21;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(anArray1)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(anArray1)),
				oopisGreaterThanOrEqualTo(anArray1, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(obj1 & (tagMask()))))
					 && (oopisLessThan(obj1, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(anArray1)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(anArray1);
						}
					}
				}
				longAtput((anArray1 + BaseHeaderSize) + (((sqInt)((usqInt)(TheInterruptSemaphore) << (shiftForWord())))), obj1);
			}
			anArray2 = specialObjectsOop();
			/* begin followSemaphoreIn:at: */
			obj2 = longAt((anArray2 + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))));
			if ((!((longAt(obj2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj2));
				referent31 = longAt((obj2 + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent31 & (tagMask()))))
				 && ((!((longAt(referent31)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent31 = longAt((referent31 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				obj2 = referent31;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(anArray2)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(anArray2)),
				oopisGreaterThanOrEqualTo(anArray2, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(obj2 & (tagMask()))))
					 && (oopisLessThan(obj2, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(anArray2)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(anArray2);
						}
					}
				}
				longAtput((anArray2 + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), obj2);
			}
			anArray3 = specialObjectsOop();
			/* begin followSemaphoreIn:at: */
			obj3 = longAt((anArray3 + BaseHeaderSize) + (((sqInt)((usqInt)(TheFinalizationSemaphore) << (shiftForWord())))));
			if ((!((longAt(obj3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(obj3));
				referent41 = longAt((obj3 + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent41 & (tagMask()))))
				 && ((!((longAt(referent41)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent41 = longAt((referent41 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				obj3 = referent41;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(anArray3)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(anArray3)),
				oopisGreaterThanOrEqualTo(anArray3, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(obj3 & (tagMask()))))
					 && (oopisLessThan(obj3, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(anArray3)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(anArray3);
						}
					}
				}
				longAtput((anArray3 + BaseHeaderSize) + (((sqInt)((usqInt)(TheFinalizationSemaphore) << (shiftForWord())))), obj3);
			}
			xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
			if ((!((longAt(xArray)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(xArray));
				referent6 = longAt((xArray + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent6 & (tagMask()))))
				 && ((!((longAt(referent6)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent6 = longAt((referent6 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				xArray = referent6;
				/* begin splObj:put: */
				objOop5 = GIV(specialObjectsOop);
				assert(!(isForwarded(objOop5)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(objOop5)),
				oopisGreaterThanOrEqualTo(objOop5, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(xArray & (tagMask()))))
					 && (oopisLessThan(xArray, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(objOop5)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(objOop5);
						}
					}
				}
				longAtput((objOop5 + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalObjectsArray) << (shiftForWord())))), xArray);
			}
			for (i3 = 0, iLimiT1 = (((/* begin numSlotsOf: */
	assert((classIndexOf(xArray)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(xArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(xArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) - 1); i3 <= iLimiT1; i3 += 1) {
				/* begin followSemaphoreIn:at: */
				obj4 = longAt((xArray + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord())))));
				if ((!((longAt(obj4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(obj4));
					referent5 = longAt((obj4 + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent5 & (tagMask()))))
					 && ((!((longAt(referent5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent5 = longAt((referent5 + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					obj4 = referent5;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(xArray)));
					if ((					/* begin isOldObject: */
						assert(isNonImmediate(xArray)),
					oopisGreaterThanOrEqualTo(xArray, GIV(oldSpaceStart)))) {
						/* most stores into young objects */
						if (						/* begin isYoung: */
							((!(obj4 & (tagMask()))))
						 && (oopisLessThan(obj4, GIV(oldSpaceStart)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt)((longAt(xArray)))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(xArray);
							}
						}
					}
					longAtput((xArray + BaseHeaderSize) + (((sqInt)((usqInt)(i3) << (shiftForWord())))), obj4);
				}
			}
		}
		if (((theBecomeEffectsFlags & (BecamePointerObjectFlag + BecameCompiledMethodFlag)) != 0)) {
			/* begin followForwardingPointersInProfileState */
			if ((!((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileProcess)));
				referent = longAt((GIV(profileProcess) + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent & (tagMask()))))
				 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				GIV(profileProcess) = referent;
			}
			if ((!((longAt(GIV(profileMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileMethod)));
				referent1 = longAt((GIV(profileMethod) + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent1 & (tagMask()))))
				 && ((!((longAt(referent1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent1 = longAt((referent1 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				GIV(profileMethod) = referent1;
			}
			if ((!((longAt(GIV(profileProcess))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				/* begin followForwarded: */
				assert(isUnambiguouslyForwarder(GIV(profileSemaphore)));
				referent2 = longAt((GIV(profileSemaphore) + BaseHeaderSize) + (0U << (shiftForWord())));
				while (				/* begin isOopForwarded: */
					((!(referent2 & (tagMask()))))
				 && ((!((longAt(referent2)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					referent2 = longAt((referent2 + BaseHeaderSize) + (0U << (shiftForWord())));
				}
				GIV(profileSemaphore) = referent2;
			}
			if (((theBecomeEffectsFlags & BecameCompiledMethodFlag) != 0)) {
				/* begin followForwardedMethodsInMethodCache */
				for (i2 = 0; i2 < MethodCacheSize; i2 += MethodCacheEntrySize) {
					c1 = GIV(methodCache)[i2 + MethodCacheClass];
					s1 = GIV(methodCache)[i2 + MethodCacheSelector];
					m = GIV(methodCache)[i2 + MethodCacheMethod];
					if ((c1 != 0)
					 && ((s1 != 0)
					 && ((m != 0)
					 && (					/* begin isOopForwarded: */
						((!(m & (tagMask()))))
					 && ((!((longAt(m)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))))) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(m));
						referent3 = longAt((m + BaseHeaderSize) + (0U << (shiftForWord())));
						while (						/* begin isOopForwarded: */
							((!(referent3 & (tagMask()))))
						 && ((!((longAt(referent3)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
							referent3 = longAt((referent3 + BaseHeaderSize) + (0U << (shiftForWord())));
						}
						m = referent3;
						GIV(methodCache)[i2 + MethodCacheMethod] = m;
					}
				}
				/* begin followMethodNewMethodAndInstructionPointer */
				ipdelta = 0;
				if ((!((longAt(GIV(method))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					ipdelta = (					/* begin method:includesAddress: */
						(GIV(instructionPointer) > GIV(method))
					 && (GIV(instructionPointer) < (GIV(method) + (((numSlotsOfAny(GIV(method))) << (shiftForWord())) + BaseHeaderSize)))
						? GIV(instructionPointer) - GIV(method)
						: 0);
					assert(isUnambiguouslyForwarder(GIV(method)));
					referent4 = longAt((GIV(method) + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent4 & (tagMask()))))
					 && ((!((longAt(referent4)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent4 = longAt((referent4 + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					GIV(method) = referent4;
					if (!(ipdelta == null)) {
						GIV(instructionPointer) = GIV(method) + ipdelta;
					}
				}
				if (				/* begin isOopForwarded: */
					((!(GIV(newMethod) & (tagMask()))))
				 && ((!((longAt(GIV(newMethod))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
					/* maybe oop due to object-as-method */
					ipdelta = ((!ipdelta)
					 && (					/* begin method:includesAddress: */
						(GIV(instructionPointer) > GIV(newMethod))
					 && (GIV(instructionPointer) < (GIV(newMethod) + (((numSlotsOfAny(GIV(newMethod))) << (shiftForWord())) + BaseHeaderSize))))
						? GIV(instructionPointer) - GIV(newMethod)
						: 0);
					assert(isUnambiguouslyForwarder(GIV(newMethod)));
					referent11 = longAt((GIV(newMethod) + BaseHeaderSize) + (0U << (shiftForWord())));
					while (					/* begin isOopForwarded: */
						((!(referent11 & (tagMask()))))
					 && ((!((longAt(referent11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
						referent11 = longAt((referent11 + BaseHeaderSize) + (0U << (shiftForWord())));
					}
					GIV(newMethod) = referent11;
				}
				if (!(ipdelta == null)) {
					GIV(instructionPointer) = GIV(newMethod) + ipdelta;
				}
			}
		}
	}
	followForwardingPointersOfReceiversInStackZone();
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackFloatValue: */
double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return floatValueOf(longAt(GIV(stackPointer) + (offset * BytesPerWord)));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackIntegerValue: */
sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		return (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Answer the actual stackLimit offset in a page. Since stackPageByteSize may
	have chosen to shrink a page
	this may be less than stackPageFrameBytes, but it should be no more than
	stackPageFrameBytes. 
 */

	/* StackInterpreter>>#stackLimitBytes */
static sqInt
stackLimitBytes(void)
{
	return (((stackPageFrameBytes()) < (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom()))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - ((IFrameSlots + 64) * BytesPerWord)) - (osCogStackPageHeadroom())));
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackObjectValue: */
sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if (((oop & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer a page size that is a power-of-two and contains a useful number of
	frames. Room for 256 slots for frames gives around 40 frames a page which
	is a
	good compromise between overflow rate and latency in divorcing a page. */

	/* StackInterpreter>>#stackPageByteSize */
static sqInt
stackPageByteSize(void)
{
    sqInt largeSize;
    sqInt pageBytes;
    sqInt smallSize;

	pageBytes = ((stackPageFrameBytes()) + ((IFrameSlots + 64) * BytesPerWord)) + (osCogStackPageHeadroom());
	if ((pageBytes & (pageBytes - 1)) == 0) {
		/* = 0 => a power of two */
		return pageBytes;
	}
	largeSize = 1ULL << (highBit(pageBytes));
	smallSize = 1ULL << ((highBit(pageBytes)) - 1);
	assert((largeSize > pageBytes)
	 && (pageBytes > smallSize));
	return ((pageBytes - smallSize) <= (smallSize / 8)
		? smallSize
		: largeSize);
}


/*	Return the stackPointer of a Context or BlockContext. */

	/* StackInterpreter>>#stackPointerForMaybeMarriedContext: */
static NoDbgRegParms sqInt
stackPointerForMaybeMarriedContext(sqInt aContext)
{
    sqInt sp;
    sqInt sp1;

	if (	/* begin isStillMarriedContext: */
		(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(aContext)))) {
		sp = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext)));
		return sp;
	}
	/* begin fetchStackPointerOf: */
	sp1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((((sp1) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
	return (sp1 >> 3);
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPointerIndexForFrame: */
static NoDbgRegParms sqInt
stackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *thePage;
    char *theSP;


	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	theSP = findSPOfon(theFP, thePage);
	/* begin stackPointerIndexForFrame:WithSP: */
	if ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())) {
		return (((usqInt)(((theFP + FoxMFReceiver) - theSP))) >> (shiftForWord())) + (((mframeCogMethod(theFP))->cmNumArgs));
	}
	else {
		return (((usqInt)(((theFP + FoxIFReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxIFrameFlags) + 1));
	}
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPositiveMachineIntegerValue: */
usqIntptr_t
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt integerPointer;
    usqInt numSlots;
    int ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((((integerPointer) & 7) == 1)) {
		value = (integerPointer >> 3);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	if (((integerPointer & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(integerPointer)));
	ccIndex = (longAt(integerPointer)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt)((longAt(integerPointer)))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(integerPointer)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(integerPointer + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(integerPointer - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((integerPointer + BaseHeaderSize))));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerPointer + BaseHeaderSize))))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackSignedMachineIntegerValue: */
sqIntptr_t
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	return signedMachineIntegerValueOf(integerPointer);
}

	/* StackInterpreter>>#stackTop */
sqInt
stackTop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackValue: */
sqInt
stackValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
sqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return ((literalCountOf(aCompiledMethod)) + LiteralStart) * BytesPerOop;
}


/*	Return what ST would return for <obj> at: index. */

	/* StackInterpreter>>#stObject:at: */
sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;

	hdr = long64At(array);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l4;
	}
	totalLength = 0;
	l4:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l1;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l1;
	}
	class = fetchClassOfNonImm(array);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l1:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array)));
			stSize = sp;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(array)));
		stSize = (sp1 >> 3);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(array)))))) {
			return temporaryin(index - 1, frameOfMarriedContext(array));
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, 
	/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			return longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
		}
		if (fmt >= (firstByteFormat())) {
			return (((usqInt)(byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
		}
		if (fmt >= (firstShortFormat())) {
			return (((usqInt)(((unsigned short) (shortAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			return positive64BitIntegerFor(long64At((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))));
		}
		return ((((((usqInt)(long32At((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))))))) & 0xFFFFFFFFU) << 3) | 1);
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	return 0;
}


/*	Do what ST would return for <obj> at: index put: value. */

	/* StackInterpreter>>#stObject:at:put: */
sqInt
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt signedValueToStore;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;
    usqLong unsigned64BitValueToStore;
    unsigned int unsignedValueToStore;

	hdr = long64At(array);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(array + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(array - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l2;
	}
	totalLength = 0;
	l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(array);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(array)));
			stSize = sp;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(array)));
		stSize = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (		/* begin isStillMarriedContext: */
			(((((longAt((array + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(array)))))) {
			return temporaryinput(index - 1, frameOfMarriedContext(array), value);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, 
	/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(array)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(array)),
			oopisGreaterThanOrEqualTo(array, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(value & (tagMask()))))
				 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(array)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(array);
					}
				}
			}
			longAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l6;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l6;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l6;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))), signedValueToStore);
			goto l6;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			unsigned64BitValueToStore = positive64BitValueOf(value);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l6;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((array + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l6:;
	}
	else {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
	}
	return value;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#storeInteger:ofObject:withValue: */
sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((((usqInt)(integerValue)) >> 60) + 1) & 15) <= 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(objectPointer)));
		longAtput((objectPointer + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), (((usqInt)integerValue << 3) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

	/* StackInterpreter>>#storeSenderOfFrame:withValue: */
static NoDbgRegParms char *
storeSenderOfFramewithValue(char *theFP, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerContextOrNil;
    char *callerFP;
    StackPage *lruOrFree;
    StackPage *newPage;
    int onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;
    StackPage *thePage1;
    char *theSP;

	if ((longAt(theFP + FoxSavedFP)) == 0) {
		/* begin frameCallerContext:put: */
		assert((anOop == (nilObject()))
		 || (isContext(anOop)));
		assert(isBaseFrame(theFP));
		assert(((theFP + (frameStackedReceiverOffset(theFP))) + (2 * BytesPerWord)) == (((stackPageFor(theFP))->baseAddress)));
		assert((longAt((theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord)) == (frameContext(theFP)));
		longAtput((theFP + (frameStackedReceiverOffset(theFP))) + (2 * BytesPerWord), anOop);
		return theFP;
	}
	/* begin ensureCallerContext: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {
		/* base frame, context in saved ip slot (or base of stack in Cog) */
		/* begin frameCallerContext: */
		assert(isBaseFrame(theFP));
		thePage1 = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		callerContextOrNil = longAt((thePage1->baseAddress));
		assert(addressCouldBeObj(callerContextOrNil));
		assert((callerContextOrNil == (nilObject()))
		 || (isContext(followMaybeForwarded(callerContextOrNil))));
		goto l6;
	}
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + (frameStackedReceiverOffset(theFP))) + BytesPerWord;
	/* begin ensureFrameIsMarried:SP: */
	if (	/* begin frameHasContext: */
		((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
		? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
		: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)) {
		assert(isContext(frameContext(callerFP)));
		/* begin frameContext: */
		goto l6;
	}
	marryFrameSP(callerFP, theSP);
	l6:	/* end ensureCallerContext: */;
	/* begin stackPageFor: */
	thePage = stackPageAtpages(
		(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
		pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
		GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (!onCurrentPage) {
		/* Make sure the frame's page isn't divorced when a new page is allocated. */
		markStackPageNextMostRecentlyUsed(thePage);
	}
	/* begin newStackPage */
	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		newPage = lruOrFree;
		goto l2;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
	l2:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		assert(newPage);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
	}
	else {
		markStackPageMostRecentlyUsed(newPage);
	}
	assert(isBaseFrame(theMovedFP));
	/* begin frameCallerContext:put: */
	assert((anOop == (nilObject()))
	 || (isContext(anOop)));
	assert(isBaseFrame(theMovedFP));
	assert(((theMovedFP + (frameStackedReceiverOffset(theMovedFP))) + (2 * BytesPerWord)) == (((stackPageFor(theMovedFP))->baseAddress)));
	assert((longAt((theMovedFP + (frameStackedReceiverOffset(theMovedFP))) + BytesPerWord)) == (frameContext(theMovedFP)));
	longAtput((theMovedFP + (frameStackedReceiverOffset(theMovedFP))) + (2 * BytesPerWord), anOop);
	return theMovedFP;
}


/*	Answer the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not an immediate! */

	/* StackInterpreter>>#stSizeOf: */
sqInt
stSizeOf(sqInt oop)
{
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt totalLength;

	hdr = long64At(oop);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(oop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l2;
	}
	totalLength = 0;
	l2:	/* end lengthOf:baseHeader:format: */;
	if (	/* begin isPureBitsFormat: */
		(fmt >= (sixtyFourBitIndexableFormat()))
	 && (fmt < (firstCompiledMethodFormat()))) {
		return totalLength;
	}
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(oop);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l3:	/* end fixedFieldsOf:format:length: */;
	if (fmt == (indexablePointersFormat())) {
		assert(!(isContextHeader(hdr)));
	}
	return totalLength - fixedFields;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
sqInt
superclassOf(sqInt classPointer)
{
    sqInt objOop;


	/* begin followObjField:ofObject: */
	objOop = longAt((classPointer + BaseHeaderSize) + (((sqInt)((usqInt)(SuperclassIndex) << (shiftForWord())))));
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
	}
	return objOop;
}

	/* StackInterpreter>>#tempCountOf: */
sqInt
tempCountOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt header1;


	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	header1 = longAt((methodPointer + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	header = ((((header1) & 7) == 1)
		? header1
		: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header1))->methodHeader)));
	/* begin temporaryCountOfMethodHeader: */
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
sqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#ultimateLiteralOf: */
sqInt
ultimateLiteralOf(sqInt aMethodOop)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop));
	offset = (literalCountOf(aMethodOop)) - 1;
	/* begin literal:ofMethod: */
	return longAt((aMethodOop + BaseHeaderSize) + (((sqInt)((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	Follow the first literal of either a primitiveCallout or
	primitiveExternalCall primitive method. This
	will be an ExternalFunction for primitiveCallout or a four element Array
	for primitiveExternalCall.
	This is here to avoid following all the literals in a method, which would
	be slow. Remember
	forwarders are unlikely, so we only want to follow what is necessary, and
	for an FFI call or
	external primitive only the first literal is salient. */

	/* StackInterpreter>>#unfollowFirstLiteralOfMaybeCalloutMethod:primitiveIndex: */
static NoDbgRegParms sqInt
unfollowFirstLiteralOfMaybeCalloutMethodprimitiveIndex(sqInt methodObj, sqInt primIndex)
{
    sqInt firstLiteral;
    sqInt found;


	/* inlined self literal: 0 ofMethod: methodObj for clarity... */
	found = 0;
	firstLiteral = longAt((methodObj + BaseHeaderSize) + (((sqInt)((usqInt)(LiteralStart) << (shiftForWord())))));
	if (	/* begin isOopForwarded: */
		((!(firstLiteral & (tagMask()))))
	 && ((!((longAt(firstLiteral)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		found = 1;
		firstLiteral = fixFollowedFieldofObjectwithInitialValue(LiteralStart, methodObj, firstLiteral);
	}
	if (followForwardedObjectFieldstoDepth(firstLiteral, (primIndex == PrimNumberFFICall
		? (((sqInt)((primitiveMetadataTable[PrimNumberFFICall]))) >> SpurPrimitiveAccessorDepthShift) - 1
		: 0))) {
		found = 1;
	}
	return found;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object. */

	/* StackInterpreter>>#updateDisplayLeft:Top:Right:Bottom: */
static NoDbgRegParms sqInt
updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt left;
    sqInt right;
    sqInt surfaceHandle;
    sqInt top;

	left = ((l < 0) ? 0 : l);
	right = ((r < displayWidth) ? r : displayWidth);
	top = ((t < 0) ? 0 : t);
	bottom = ((b < displayHeight) ? b : displayHeight);
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (((((((sqInt)displayBits))) & 7) == 1)) {
		surfaceHandle = ((((sqInt)displayBits)) >> 3);
		if (showSurfaceFn == 0) {
			showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
			if (showSurfaceFn == 0) {
				return (GIV(primFailCode) = PrimErrNotFound);
			}
		}
		showSurfaceFn(surfaceHandle, left, top, right - left, bottom - top);
	}
	else {
		assert(isNonImmediate(((sqInt)displayBits)));
		ioShowDisplay(((sqInt)displayBits), displayWidth, displayHeight, displayDepth, left, right, top, bottom);
	}
	return 0;
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */

	/* StackInterpreter>>#validBCPC:inMethod: */
static NoDbgRegParms sqInt
validBCPCinMethod(sqInt thePC, usqInt aMethod)
{
	return (thePC >= (((literalCountOf(aMethod)) + LiteralStart) * BytesPerOop))
	 && (thePC < (numBytesOfBytes(aMethod)));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */

	/* StackInterpreter>>#validInstructionPointer:inFrame: */
static NoDbgRegParms sqInt
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp)
{
	return validInstructionPointerinMethodframePointer(anInstrPointer, 
	/* begin frameMethodObject: */
((((usqInt)(longAt(fp + FoxMethod)))) < (startOfMemory())
		? ((mframeHomeMethod(fp))->methodObject)
		: longAt(fp + FoxMethod)), fp);
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

	/* StackInterpreter>>#validStackPageBaseFrames */
static sqInt
validStackPageBaseFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			if (!(validStackPageBaseFrame(aPage))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

	/* StackInterpreter>>#voidLongRunningPrimitive: */
#if LRPCheck
static NoDbgRegParms NeverInline void
voidLongRunningPrimitive(char *reason)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence();
}
#endif /* LRPCheck */


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

	/* StackInterpreter>>#wakeHighestPriority */
static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    usqInt numSlots;
    sqInt objOop;
    sqInt p;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;


	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + (((sqInt)((usqInt)(ValueIndex) << (shiftForWord())))));
	/* begin fetchPointer:ofObject: */
	schedLists = longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	p = (GIV(highestRunnableProcessPriority) == 0
		? (			/* begin numSlotsOf: */
				assert((classIndexOf(schedLists)) > (isForwardedObjectClassIndexPun())),
			(((numSlots = byteAt(schedLists + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(schedLists - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots))
		: GIV(highestRunnableProcessPriority));
	while (((p -= 1)) >= 0) {
		processList = longAt((schedLists + BaseHeaderSize) + (((sqInt)((usqInt)(p) << (shiftForWord())))));
		while (1) {
			/* begin isEmptyList: */
			assert(!(isForwarded(processList)));
			if ((longAt((processList + BaseHeaderSize) + (((sqInt)((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)) break;
			/* Only answer processes with a runnable suspendedContext.
			   Discard those that aren't; the VM would crash otherwise. */
			proc = removeFirstLinkOfList(processList);
			ctxt = longAt((proc + BaseHeaderSize) + (((sqInt)((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
			if (isLiveContext(ctxt)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			if (			/* begin isOopForwarded: */
				((!(ctxt & (tagMask()))))
			 && ((!((longAt(ctxt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				ctxt = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, proc, ctxt);
			}
			if (isLiveContext(ctxt)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			warning("evicted zombie process from run queue");
		}
	}
	error("scheduler could not find a runnable process");
	return null;
}


/*	Write the image header and heap contents to imageFile for snapshot. c.f.
	writeImageFileIOSimulation. The game below is to maintain 64-bit alignment
	for all putLong:toFile: occurrences. */

	/* StackInterpreter>>#writeImageFileIO */
static NeverInline sqInt
writeImageFileIO(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt i;
    sqInt imageBytes;
    extern char imageName[];
    sqInt okToWrite;
    void *sCWIfn;
    sqInt total;

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!okToWrite) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	headerStart = 0;
	/* 64 or 128; header size in bytes; do not change! */
	headerSize = BytesPerWord * 16;
	f = sqImageFileOpen(imageName, "wb");
	if (invalidSqImageFile(f)) {
		/* could not open the image file for writing */
		return (GIV(primFailCode) = PrimErrOperationFailed);
	}
	/* begin imageSizeToWrite */
	assert(newSpaceIsEmpty());
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		if ((((GIV(segments)[i]).segSize)) > (2 * BaseHeaderSize)) {
			total += ((GIV(segments)[i]).segSize);
		}
	}
	imageBytes = total;
	headerStart = sqImageFileStartLocation(f, imageName, headerSize + imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putWord32toFile(	/* begin imageFormatVersionForSnapshot */
		(GIV(multipleBytecodeSetsActive)
		? 68021 /* begin imageFormatVersion */ | MultipleBytecodeSetsBitmask
		: 68021 /* begin imageFormatVersion */), f);
	putWord32toFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile(GIV(oldSpaceStart), f);
	putLongtoFile(specialObjectsOop(), f);
	putLongtoFile(newObjectHash(), f);
	putLongtoFile(getSnapshotScreenSize(), f);
	putLongtoFile(getImageHeaderFlags(), f);
	putWord32toFile(extraVMMemory, f);
	putShorttoFile(desiredNumStackPages, f);
	putShorttoFile((desiredCogCodeSize + 0x3FF) / 0x400, f);
	putWord32toFile(desiredEdenBytes, f);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
		? ioGetMaxExtSemTableSize()
		: 0), f);
	putShorttoFile(GIV(the2ndUnknownShort), f);
	putLongtoFile(((GIV(segments)[0]).segSize), f);
	putLongtoFile(GIV(totalFreeOldSpace), f);
		putLongtoFile(0, f);
	putLongtoFile(0, f);
		putLongtoFile(0, f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);
;
	assert((headerStart + headerSize) == (sqImageFilePosition(f)));
	sqImageFileSeek(f, headerStart + headerSize);
	if (GIV(primFailCode)) {
		/* file write or seek failure */
		sqImageFileClose(f);
		return null;
	}
	bytesWritten = writeImageSegmentsToFile(f);
	/* begin success: */
	if (!(bytesWritten == imageBytes)) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f);
	return 0;
}

	/* StackInterpreterPrimitives>>#cloneContext: */
static NoDbgRegParms usqInt
cloneContext(sqInt aContext)
{
    usqInt cloned;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqInt i;
    usqInt numSlots;
    sqInt senderOop;
    sqInt sp;
    char *spouseFP;
    usqInt sz;
    sqInt valuePointer;
    sqInt valuePointer1;


	/* begin numSlotsOf: */
	assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
	sz = (((numSlots = byteAt(aContext + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	cloned = allocateNewSpaceSlotsformatclassIndex(sz, indexablePointersFormat(), ClassMethodContextCompactIndex);
	assert(!((cloned == 0)));
	for (i = 0; i <= StackPointerIndex; i += 1) {
		valuePointer = externalInstVarofContext(i, aContext);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(cloned)));
		longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), valuePointer);
	}
	for (i = MethodIndex; i <= ReceiverIndex; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(cloned)));
		longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord()))))));
	}
	if (	/* begin isStillMarriedContext: */
		(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(aContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
		sp = (stackPointerIndexForFrame(spouseFP)) - 1;
		for (i = 0; i <= sp; i += 1) {
			valuePointer1 = 
			/* begin temporary:in: */
((((usqInt)(longAt(spouseFP + FoxMethod)))) < (startOfMemory())
				? (i < ((frameNumArgs = ((mframeCogMethod(spouseFP))->cmNumArgs)))
						? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - i) * BytesPerWord))
						: longAt(((spouseFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - i) * BytesPerWord)))
				: 
					/* begin itemporary:in: */
(i < ((frameNumArgs1 = byteAt((spouseFP + FoxIFrameFlags) + 1)))
						? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs1 - i) * BytesPerWord))
						: longAt(((spouseFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - i) * BytesPerWord))));
			assert(!(isOopForwarded(cloned)));
			longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))), valuePointer1);
		}
	}
	else {
		sp = (fetchStackPointerOf(aContext)) - 1;
		for (i = 0; i <= sp; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(cloned)));
			longAtput((cloned + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))), longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord()))))));
		}
	}
	return cloned;
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#fieldOrSenderFP:ofContext: */
static NoDbgRegParms sqInt
fieldOrSenderFPofContext(sqInt index, sqInt contextObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderOop;
    char *spouseFP;
    sqInt tempIndex;

	tempIndex = index - CtxtTempFrameStart;
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(contextObj))))) {
		if (tempIndex >= (fetchStackPointerOf(contextObj))) {
			return GIV(nilObj);
		}
		else {
			return longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
		}
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((contextObj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
	if (tempIndex >= (stackPointerIndexForFrame(spouseFP))) {
		return GIV(nilObj);
	}
	return fieldofFrame(index, spouseFP);
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#field:ofFrame: */
static NoDbgRegParms sqInt
fieldofFrame(sqInt index, char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;

	switch (index) {
	case SenderIndex:
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		return (callerFP == 0
			? frameCallerContext(theFP)
			: (				/* begin frameHasContext: */
					((((usqInt)(longAt(callerFP + FoxMethod)))) < (startOfMemory())
					? ((longAt(callerFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((callerFP + FoxIFrameFlags) + 2)) != 0)
					? (assert(checkIsStillMarriedContextcurrentFP(frameContext(callerFP), null)),
						/* begin frameContext: */
longAt(callerFP + FoxThisContext))
					: ((sqInt)callerFP)));

	case StackPointerIndex:
	case InstructionPointerIndex:
		return ConstZero;

	case MethodIndex:
		return 
		/* begin frameMethodObject: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((mframeHomeMethod(theFP))->methodObject)
			: longAt(theFP + FoxMethod));

	case ClosureIndex:
		return (		/* begin frameIsBlockActivation: */
			((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((longAt(theFP + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
			: (byteAt((theFP + FoxIFrameFlags) + 3)) != 0)
			? frameStackedReceivernumArgs(theFP, ((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
					? ((mframeCogMethod(theFP))->cmNumArgs)
					: byteAt((theFP + FoxIFrameFlags) + 1)))
			: GIV(nilObj));

	case ReceiverIndex:
		return 
		/* begin frameReceiver: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? longAt(theFP + FoxMFReceiver)
			: longAt(theFP + FoxIFReceiver));

	default:
		assert((((index - CtxtTempFrameStart) >= 0) && ((index - CtxtTempFrameStart) <= (stackPointerIndexForFrame(theFP)))));
		return 
		/* begin temporary:in: */
((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
			? ((index - CtxtTempFrameStart) < ((frameNumArgs = ((mframeCogMethod(theFP))->cmNumArgs)))
					? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord))
					: longAt(((theFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord)))
			: 
				/* begin itemporary:in: */
((index - CtxtTempFrameStart) < ((frameNumArgs1 = byteAt((theFP + FoxIFrameFlags) + 1)))
					? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs1 - (index - CtxtTempFrameStart)) * BytesPerWord))
					: longAt(((theFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (index - CtxtTempFrameStart)) * BytesPerWord))));
	}
	return 0;
}

	/* StackInterpreterPrimitives>>#isAppropriateForCopyObject: */
static NoDbgRegParms sqInt
isAppropriateForCopyObject(sqInt oop)
{
	if (!(((((usqInt)((longAt(oop)))) >> (formatShift())) & (formatMask())) <= 5 /* begin lastPointerFormat */)) {
		return 0;
	}
	if (	/* begin isContext: */
		((!(oop & (tagMask()))))
	 && (((longAt(oop)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		return !(		/* begin isStillMarriedContext: */
			(((((longAt((oop + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(oop))));
	}
	return 1;
}


/*	The function has not been loaded yet. Fetch module and function name. */

	/* StackInterpreterPrimitives>>#linkExternalCall:errInto: */
static NoDbgRegParms void
(*linkExternalCallerrInto(sqInt externalCallLiteral, sqInt *failPtr))()
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt i;
    sqInt index;
    sqInt metadata;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;

	metadata = 0;
	moduleName = longAt((externalCallLiteral + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralModuleNameIndex) << (shiftForWord())))));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(			/* begin isBytes: */
				((!(moduleName & (tagMask()))))
			 && (((((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
			if (!(failPtr == null)) {
				failPtr[0] = PrimErrBadMethod;
			}
			return 0;
		}
		/* begin numBytesOfBytes: */
		fmt = (((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask());
		assert(fmt >= (firstByteFormat()));
		moduleLength = (((/* begin numSlotsOf: */
	assert((classIndexOf(moduleName)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(moduleName + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(moduleName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
	}
	functionName = longAt((externalCallLiteral + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFunctionNameIndex) << (shiftForWord())))));
	if (!(		/* begin isBytes: */
			((!(functionName & (tagMask()))))
		 && (((((usqInt)((longAt(functionName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		if (!(failPtr == null)) {
			failPtr[0] = PrimErrBadMethod;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt)((longAt(functionName)))) >> (formatShift())) & (formatMask());
	assert(fmt1 >= (firstByteFormat()));
	functionLength = (((/* begin numSlotsOf: */
	assert((classIndexOf(functionName)) > (isForwardedObjectClassIndexPun())),
(((numSlots1 = byteAt(functionName + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(functionName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1))) << (shiftForWord())) - (fmt1 & 7);
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLengthMetadataInto(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength, (&metadata));
	if (addr == 0) {
		index = -1;
	}
	else {
		/* add the function to the external primitive table */
		assert(((((metadata) >> SpurPrimitiveAccessorDepthShift) >= -1) && (((metadata) >> SpurPrimitiveAccessorDepthShift) <= 5)));
		/* begin addToExternalPrimitiveTable: */
		for (i = GIV(externalPrimitiveTableFirstFreeIndex); i < MaxExternalPrimitiveTableSize; i += 1) {
			if ((externalPrimitiveTable[i]) == 0) {
				externalPrimitiveTable[i] = (((void *) addr));
				index = (GIV(externalPrimitiveTableFirstFreeIndex) = i + 1);
				goto l3;
			}
		}
		index = 0;
	l3:	/* end addToExternalPrimitiveTable: */;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(externalCallLiteral)));
		longAtput((externalCallLiteral + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))), (((usqInt)metadata << 3) | 1));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(externalCallLiteral)));
	longAtput((externalCallLiteral + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))), (((usqInt)index << 3) | 1));
	rewriteMethodCacheEntryForExternalPrimitiveToFunction((index >= 0
		? addr
		: 0));
	return addr;
}


/*	Return a shallow copy of the receiver.
	Special-case non-single contexts (because of context-to-stack mapping).
	Can't fail for contexts cuz of image context instantiation code (sigh). */
/*	because of cloneContext: below */

	/* StackInterpreterPrimitives>>#primitiveClone */
static void
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newCopy;
    sqInt rcvr;
    char *sp;

	newCopy = 0;
	rcvr = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)) {
		newCopy = rcvr;
	}
	else {
		if (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
			/* begin externalWriteBackHeadFramePointers */
			assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
			assert(GIV(stackPage) == (mostRecentlyUsedPage()));
			assert(!((isFree(GIV(stackPage)))));
			/* begin setHeadFP:andSP:inPage: */
			assert(GIV(stackPointer) < GIV(framePointer));
			assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
			 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
			assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
			 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
			(GIV(stackPage)->headFP = GIV(framePointer));
			(GIV(stackPage)->headSP = GIV(stackPointer));
			assert(pageListIsWellFormed());
			newCopy = cloneContext(rcvr);
		}
		else {
			if ((GIV(argumentCount) == 0)
			 || (!((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))))) {
				newCopy = cloneObject(rcvr);
			}
		}
		if (!newCopy) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveAt for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAt */
static void
primitiveContextAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    usqLong fmt;
    usqLong fmt1;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt senderOop;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 3);
	/* Duplicating much of stObject:at:put: here allows stObject:at:put: to omit tests for contexts. */
	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	hdr = long64At(aContext);
	if (!((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* might be an instance of a subclass */
		/* begin stObject:at: */
		hdr1 = long64At(aContext);
		fmt1 = (((usqLong)(hdr1)) >> (formatShift())) & (formatMask());
		/* begin lengthOf:baseHeader:format: */
		numSlots11 = byteAt(aContext + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt1 <= 5 /* begin ephemeronFormat */) {
			totalLength1 = numSlots2;
			goto l9;
		}
		if (fmt1 >= (firstByteFormat())) {
			/* bytes, including CompiledMethod */
			totalLength1 = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
			goto l9;
		}
		if (fmt1 >= (firstShortFormat())) {
			totalLength1 = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l9;
		}
		if (fmt1 >= (firstLongFormat())) {
			totalLength1 = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l9;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			totalLength1 = numSlots2;
			goto l9;
		}
		totalLength1 = 0;
	l9:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 >= (sixtyFourBitIndexableFormat()))
		 || (fmt1 == (arrayFormat()))) {
			fixedFields1 = 0;
			goto l8;
		}
		if (fmt1 < (arrayFormat())) {
			fixedFields1 = totalLength1;
			goto l8;
		}
		class1 = fetchClassOfNonImm(aContext);
		fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l8:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat()))
		 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if (			/* begin isStillMarriedContext: */
				(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l10;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp11) & 7) == 1))) {
				stSize1 = 0;
				goto l10;
			}
			assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 3);
	l10:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSize1))
			 && (			/* begin isStillMarriedContext: */
				(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))))) {
				value = temporaryin(index - 1, frameOfMarriedContext(aContext));
				goto l11;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, 
		/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt1 >= (firstCompiledMethodFormat())
			? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
		 && (oopisLessThanOrEqualTo(index, stSize1))) {
			/* begin subscript:with:format: */
			if (fmt1 <= 5 /* begin lastPointerFormat */) {
				value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))));
				goto l11;
			}
			if (fmt1 >= (firstByteFormat())) {
				value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1))) << 3) | 1);
				goto l11;
			}
			if (fmt1 >= (firstShortFormat())) {
				value = (((usqInt)(((unsigned short) (shortAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 1))))))) << 3) | 1);
				goto l11;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat())) {
				value = positive64BitIntegerFor(long64At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 3)))));
				goto l11;
			}
			value = ((((((usqInt)(long32At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))))))) & 0xFFFFFFFFU) << 3) | 1);
			goto l11;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		value = 0;
	l11:	/* end stObject:at: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
		/* begin lengthOf:baseHeader:format: */
		numSlots1 = byteAt(aContext + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 5 /* begin ephemeronFormat */) {
			totalLength = numSlots;
			goto l6;
		}
		if (fmt >= (firstByteFormat())) {
			/* bytes, including CompiledMethod */
			totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
			goto l6;
		}
		if (fmt >= (firstShortFormat())) {
			totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
			goto l6;
		}
		if (fmt >= (firstLongFormat())) {
			totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
			goto l6;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			totalLength = numSlots;
			goto l6;
		}
		totalLength = 0;
	l6:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt >= (sixtyFourBitIndexableFormat()))
		 || (fmt == (arrayFormat()))) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < (arrayFormat())) {
			fixedFields = totalLength;
			goto l4;
		}
		class = fetchClassOfNonImm(aContext);
		fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l4:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l1;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
		stSize = (sp1 >> 3);
	l1:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			value = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l2;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields) - 1))) << 3) | 1);
			goto l2;
		}
		if (fmt >= (firstShortFormat())) {
			value = (((usqInt)(((unsigned short) (shortAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))))))) << 3) | 1);
			goto l2;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			value = positive64BitIntegerFor(long64At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3)))));
			goto l2;
		}
		value = ((((((usqInt)(long32At((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))))))) & 0xFFFFFFFFU) << 3) | 1);
	l2:	/* end subscript:with:format: */;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin temporary:in: */
	if ((((usqInt)(longAt(spouseFP + FoxMethod)))) < (startOfMemory())) {
		if ((index - 1) < ((frameNumArgs = ((mframeCogMethod(spouseFP))->cmNumArgs)))) {
			value = longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord));
		}
		else {
			value = longAt(((spouseFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord));
		}
	}
	else {
		/* begin itemporary:in: */
		if ((index - 1) < ((frameNumArgs1 = byteAt((spouseFP + FoxIFrameFlags) + 1)))) {
			value = longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs1 - (index - 1)) * BytesPerWord));
		}
		else {
			value = longAt(((spouseFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs1 - (index - 1)) * BytesPerWord));
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveAtPut for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAtPut */
static void
primitiveContextAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    usqLong fmt;
    usqLong fmt1;
    sqInt frameNumArgs;
    sqInt frameNumArgs1;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt senderOop;
    sqInt signedValueToStore;
    sqInt signedValueToStore1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    usqLong unsigned64BitValueToStore;
    usqLong unsigned64BitValueToStore1;
    unsigned int unsignedValueToStore;
    unsigned int unsignedValueToStore1;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	hdr = long64At(aContext);
	index = (index >> 3);
	if (!((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* might be an instance of a subclass */
		/* begin stObject:at:put: */
		hdr1 = long64At(aContext);
		fmt1 = (((usqLong)(hdr1)) >> (formatShift())) & (formatMask());
		/* begin lengthOf:baseHeader:format: */
		numSlots11 = byteAt(aContext + 7);
		numSlots2 = (numSlots11 == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots11);
		if (fmt1 <= 5 /* begin ephemeronFormat */) {
			totalLength1 = numSlots2;
			goto l13;
		}
		if (fmt1 >= (firstByteFormat())) {
			/* bytes, including CompiledMethod */
			totalLength1 = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
			goto l13;
		}
		if (fmt1 >= (firstShortFormat())) {
			totalLength1 = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l13;
		}
		if (fmt1 >= (firstLongFormat())) {
			totalLength1 = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l13;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			totalLength1 = numSlots2;
			goto l13;
		}
		totalLength1 = 0;
	l13:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 >= (sixtyFourBitIndexableFormat()))
		 || (fmt1 == (arrayFormat()))) {
			fixedFields1 = 0;
			goto l9;
		}
		if (fmt1 < (arrayFormat())) {
			fixedFields1 = totalLength1;
			goto l9;
		}
		class1 = fetchClassOfNonImm(aContext);
		fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l9:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == (indexablePointersFormat()))
		 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if (			/* begin isStillMarriedContext: */
				(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 3))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l12;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((((sp11) & 7) == 1))) {
				stSize1 = 0;
				goto l12;
			}
			assert((ReceiverIndex + ((sp11 >> 3))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 3);
	l12:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSize1))
			 && (			/* begin isStillMarriedContext: */
				(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (!(isWidowedContext(aContext)))))) {
				temporaryinput(index - 1, frameOfMarriedContext(aContext), value);
				goto l14;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, 
		/* begin firstValidIndexOfIndexableObject:withFormat: */
(fmt1 >= (firstCompiledMethodFormat())
			? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
		 && (oopisLessThanOrEqualTo(index, stSize1))) {
			/* begin subscript:with:storing:format: */
			if (fmt1 <= 5 /* begin lastPointerFormat */) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(aContext)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(aContext)),
				oopisGreaterThanOrEqualTo(aContext, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(value & (tagMask()))))
					 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(aContext)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(aContext);
						}
					}
				}
				longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << (shiftForWord())))), value);
				goto l11;
			}
			if (fmt1 >= (firstByteFormat())) {
				if (!((((value) & 7) == 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l11;
				}
				signedValueToStore1 = (value >> 3);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l11;
				}
				/* begin storeByte:ofObject:withValue: */
				byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields1) - 1), signedValueToStore1);
				goto l11;
			}
			if (fmt1 >= (firstShortFormat())) {
				if (!((((value) & 7) == 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l11;
				}
				signedValueToStore1 = (value >> 3);
				if (!((signedValueToStore1 >= 0)
					 && (signedValueToStore1 <= 0xFFFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l11;
				}
				/* begin storeShort16:ofObject:withValue: */
				shortAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 1))), signedValueToStore1);
				goto l11;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat())) {
				unsigned64BitValueToStore1 = positive64BitValueOf(value);
				if (!GIV(primFailCode)) {
					/* begin storeLong64:ofObject:withValue: */
					long64Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 3))), unsigned64BitValueToStore1);
				}
				goto l11;
			}
			unsignedValueToStore1 = positive32BitValueOf(value);
			if (!GIV(primFailCode)) {
				/* begin storeLong32:ofObject:withValue: */
				long32Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields1) - 1)) << 2))), unsignedValueToStore1);
			}
	l11:;
		}
		else {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = (fmt1 <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
		}
	l14:	/* end stObject:at:put: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(		/* begin isStillMarriedContext: */
			(((((longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
		/* begin lengthOf:baseHeader:format: */
		numSlots1 = byteAt(aContext + 7);
		numSlots = (numSlots1 == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(aContext - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if (fmt <= 5 /* begin ephemeronFormat */) {
			totalLength = numSlots;
			goto l5;
		}
		if (fmt >= (firstByteFormat())) {
			/* bytes, including CompiledMethod */
			totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
			goto l5;
		}
		if (fmt >= (firstShortFormat())) {
			totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
			goto l5;
		}
		if (fmt >= (firstLongFormat())) {
			totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
			goto l5;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			totalLength = numSlots;
			goto l5;
		}
		totalLength = 0;
	l5:	/* end lengthOf:baseHeader:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt >= (sixtyFourBitIndexableFormat()))
		 || (fmt == (arrayFormat()))) {
			fixedFields = 0;
			goto l3;
		}
		if (fmt < (arrayFormat())) {
			fixedFields = totalLength;
			goto l3;
		}
		class = fetchClassOfNonImm(aContext);
		fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l3:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			stSize = 0;
			goto l1;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(aContext)));
		stSize = (sp1 >> 3);
	l1:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aContext)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(aContext)),
			oopisGreaterThanOrEqualTo(aContext, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(value & (tagMask()))))
				 && (oopisLessThan(value, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(aContext)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(aContext);
					}
				}
			}
			longAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l7;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l7;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((value) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			signedValueToStore = (value >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l7;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 1))), signedValueToStore);
			goto l7;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			unsigned64BitValueToStore = positive64BitValueOf(value);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l7;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
	l7:;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
	/* begin withoutSmallIntegerTags: */
	assert((((senderOop) & 7) == 1));
	spouseFP = pointerForOop(senderOop - (smallIntegerTag()));
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin temporary:in:put: */
	if ((((usqInt)(longAt(spouseFP + FoxMethod)))) < (startOfMemory())) {
		/* begin mtemporary:in:put: */
		longAtput(((index - 1) < ((frameNumArgs1 = ((mframeCogMethod(spouseFP))->cmNumArgs)))
			? (spouseFP + FoxCallerSavedIP) + ((frameNumArgs1 - (index - 1)) * BytesPerWord)
			: ((spouseFP + FoxMFReceiver) - BytesPerWord) + ((frameNumArgs1 - (index - 1)) * BytesPerWord)), value);
	}
	else {
		/* begin itemporary:in:put: */
		if ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxIFrameFlags) + 1)))) {
			longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
		}
		else {
			longAtput(((spouseFP + FoxIFReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveSize for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextSize */
static void
primitiveContextSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt sp;
    sqInt sp1;
    char *sp2;
    sqInt sz;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	hdr = long64At(rcvr);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l2;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l2;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l2;
	}
	totalLength = 0;
	l2:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l3:	/* end fixedFieldsOf:format:length: */;
	if ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(!((isFree(GIV(stackPage)))));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		/* begin stackPointerForMaybeMarriedContext: */
		if (		/* begin isStillMarriedContext: */
			(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(rcvr)));
			sz = sp;
			goto l4;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((((sp1) & 7) == 1))) {
			sz = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((sp1 >> 3))) < (lengthOf(rcvr)));
		sz = (sp1 >> 3);
	l4:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)sz << 3) | 1));
	GIV(stackPointer) = sp2;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

	/* StackInterpreterPrimitives>>#primitiveDeferDisplayUpdates */
static void
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	if (cannotDeferDisplayUpdates) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

	/* StackInterpreterPrimitives>>#primitiveDoNamedPrimitiveWithArgs */
static void
primitiveDoNamedPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    usqInt arraySize;
    sqInt ccIndex;
    sqInt firstBytecode;
    sqInt fmt;
    sqInt fmt1;
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt index;
    sqInt isArray;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt primRcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt spec;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt top;
    sqInt top1;
    sqInt top2;
    sqInt top3;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;
    sqInt valuePointer3;

	GIV(metaAccessorDepth) = -2;
	argumentArray = longAt(GIV(stackPointer));
	methodArg = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((		/* begin isArray: */
			((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && (((!(methodArg & (tagMask()))))
		 && (((((usqInt)((longAt(methodArg)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -2;
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	arraySize = (((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -2;
		return;
	}
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodArg));
	header = longAt((methodArg + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
	methodHeader = ((((header) & 7) == 1)
		? header
		: (assert((((usqInt)header)) < GIV(newSpaceStart)),
			assert((((((CogMethod *) header))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
			((((CogMethod *) header))->methodHeader)));
	if (!(((		/* begin literalCountOfMethodHeader: */
			assert((((methodHeader) & 7) == 1)),
		((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) > 2)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -3;
		return;
	}
	/* first literal */
	spec = longAt((methodArg + BaseHeaderSize) + (1U << (shiftForWord())));
	/* begin isInstanceOfClassArray: */
	if (((spec & (tagMask())) != 0)) {
		isArray = 0;
		goto l13;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(spec)));
	ccIndex = (longAt(spec)) & (classIndexMask());
	isArray = ClassArrayCompactIndex == ccIndex;
	l13:	/* end isInstanceOfClassArray: */;
	if (!(isArray
		 && ((((		/* begin numSlotsOf: */
			assert((classIndexOf(spec)) > (isForwardedObjectClassIndexPun())),
		(((numSlots1 = byteAt(spec + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(spec - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1))) == 4)
		 && ((		/* begin primitiveIndexOfMethod:header: */
			(((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = (methodArg + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize),
				(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0)) == PrimNumberExternalCall)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -3;
		return;
	}
	if (!(((((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15) == arraySize)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -2;
		return;
	}
	moduleName = longAt((spec + BaseHeaderSize) + (0U << (shiftForWord())));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		successBoolean = 
		/* begin isBytes: */
((!(moduleName & (tagMask()))))
		 && (((((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
		if (!successBoolean) {
			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin numBytesOfBytes: */
		fmt = (((usqInt)((longAt(moduleName)))) >> (formatShift())) & (formatMask());
		assert(fmt >= (firstByteFormat()));
		moduleLength = (((/* begin numSlotsOf: */
	assert((classIndexOf(moduleName)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(moduleName + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(moduleName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) << (shiftForWord())) - (fmt & 7);
	}
	functionName = longAt((spec + BaseHeaderSize) + (1U << (shiftForWord())));
	successBoolean1 = 
	/* begin isBytes: */
((!(functionName & (tagMask()))))
	 && (((((usqInt)((longAt(functionName)))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
	if (!successBoolean1) {
		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin numBytesOfBytes: */
	fmt1 = (((usqInt)((longAt(functionName)))) >> (formatShift())) & (formatMask());
	assert(fmt1 >= (firstByteFormat()));
	functionLength = (((/* begin numSlotsOf: */
	assert((classIndexOf(functionName)) > (isForwardedObjectClassIndexPun())),
(((numSlots3 = byteAt(functionName + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(functionName - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3))) << (shiftForWord())) - (fmt1 & 7);
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -3;
		return;
	}
	/* N.B. the accessor depth is the second byte of the primitive's metadata;
	   the first byte is various flags (currently l.s.b. = use fast C linkage). */
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLengthMetadataInto(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength, (&GIV(metaAccessorDepth)));
	GIV(metaAccessorDepth) = (addr == 0
		? -2
		: (((usqInt)(GIV(metaAccessorDepth))) >> 8));
	if (addr == 0) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -1;
		return;
	}
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((knownClassAtIndex(ClassArrayCompactIndex)) != GIV(nilObj));
	assert((arrayFormat()) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	GIV(tempOop) = allocateNewSpaceSlotsformatclassIndex(4, arrayFormat(), ClassArrayCompactIndex);
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer = (argumentArray = top);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer1 = (primRcvr = top1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer1);
	/* begin popStack */
	top2 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer2 = top2;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer2);
	/* begin popStack */
	top3 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer3 = top3;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(GIV(tempOop))));
	longAtput((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord())), valuePointer3);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), primRcvr);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp1;
	}
	/* begin callExternalPrimitive: */
	primitiveFunctionPointer = addr;
	dispatchFunctionPointer(addr);
	if (GIV(primFailCode)) {
		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord()))));
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord()))));
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord()))));
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord()))));
		GIV(stackPointer) = sp5;
		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(argumentCount) = 3;
		primitiveFunctionPointer = primitiveDoNamedPrimitiveWithArgs;
		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}


/*	Implement either ProtoObject>>tryPrimitive: primIndex withArgs: argArray
	or Context>>receiver: anObject tryPrimitive: primIndex withArgs: argArray.
	If this primitive fails, arrange that its error code is a negative
	integer, to
	distinguish between this failing and the primitive it invokes failing. */

	/* StackInterpreterPrimitives>>#primitiveDoPrimitiveWithArgs */
static void
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt index;
    sqInt nArgs;
    usqInt numSlots;
    sqInt primIdx;
    sqInt rcvr;
    sqInt referent;
    char *savedFramePointer;
    sqInt savedNumArgs;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	GIV(metaAccessorDepth) = -2;
	if (!(((GIV(argumentCount) >= 2) && (GIV(argumentCount) <= 3)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -PrimErrUnsupported;
		return;
	}
	argumentArray = longAt(GIV(stackPointer));
	primIdx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((		/* begin isArray: */
			((!(argumentArray & (tagMask()))))
		 && (((((usqInt)((longAt(argumentArray)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
		 && ((((primIdx) & 7) == 1)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -PrimErrBadArgument;
		return;
	}
	/* begin numSlotsOf: */
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	arraySize = (((numSlots = byteAt(argumentArray + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argumentArray - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots);
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -PrimErrLimitExceeded;
		return;
	}
	primIdx = (primIdx >> 3);
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIdx])));
	if (primitiveFunctionPointer == 0) {
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = -PrimErrBadIndex;
		return;
	}
	if (((savedNumArgs = GIV(argumentCount))) == 3) {
		/* ...and receiver if the three arg form */
		/* actual receiver */
		GIV(tempOop2) = longAt(GIV(stackPointer) + (4 * BytesPerWord));
		/* receiver for primitive */
		rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
		if (		/* begin isOopForwarded: */
			((!(rcvr & (tagMask()))))
		 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			/* begin followForwarded: */
			assert(isUnambiguouslyForwarder(rcvr));
			referent = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())));
			while (			/* begin isOopForwarded: */
				((!(referent & (tagMask()))))
			 && ((!((longAt(referent)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				referent = longAt((referent + BaseHeaderSize) + (0U << (shiftForWord())));
			}
			rcvr = referent;
		}
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp1;
		index += 1;
	}
	if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		GIV(tempOop2) = 0;
		return;
	}
	/* prim might alloc/gc */
	/* Run the primitive (sets primFailCode) */
	GIV(tempOop) = argumentArray;
	GIV(metaAccessorDepth) = ((sqInt)((primitiveMetadataTable[primIdx]))) >> SpurPrimitiveAccessorDepthShift;
	/* begin slowPrimitiveResponse */
	assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
	assert((remapBufferCount()) == 0);
	nArgs = GIV(argumentCount);
	savedStackPointer = GIV(stackPointer);
	savedFramePointer = GIV(framePointer);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	if (	/* begin recordPrimTraceForMethod: */
		(recordPrimTrace())
	 && ((primTracePluginName == null
		? 1
		: methodHasPrimitiveInPrimTracePlugin(GIV(newMethod))))) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(newMethod);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	dispatchFunctionPointer(primitiveFunctionPointer);
	assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));
	/* begin maybeRetryPrimitiveOnFailure */
	if (GIV(primFailCode)) {
		retryPrimitiveOnFailure();
	}
	if ((!GIV(primFailCode))
	 && ((GIV(framePointer) == savedFramePointer)
	 && (!((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory()))))) {
		/* Don't fail if primitive has done something radical, e.g. perform: */
		if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			failUnbalancedPrimitive();
			GIV(stackPointer) = savedStackPointer;
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	/* begin successful */
	if (GIV(primFailCode)) {
		/* If primitive failed, then restore state for failure code */
		if (GIV(tempOop) == 0) {
			/* the primitive failed in a recursive invocation.  can't fix things with no value... */
			return;
		}
		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		if (savedNumArgs == 3) {
			rcvr = longAt(GIV(stackPointer));
			/* begin stackTopPut: */
			longAtPointerput(GIV(stackPointer), GIV(tempOop2));
			longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
			GIV(stackPointer) = sp2;
		}
		/* begin pushInteger: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), (((usqInt)primIdx << 3) | 1));
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), GIV(tempOop));
		GIV(stackPointer) = sp4;
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		GIV(argumentCount) = savedNumArgs;
	}
	GIV(tempOop) = (GIV(tempOop2) = 0);
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol)
	* The function name (String | Symbol)
	* The session ID (SmallInteger) [OBSOLETE], or in Spur, the metadata
	(accessorDepth and flags; Integer))
	* The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:.
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */
/*	because the primitive accesses newMethod's first literal, which is checked
	for explicitly in checkForAndFollowForwardedPrimitiveState
 */
/*	since call may invoke a callback */
/*	since external primitive linkage is in first literal... */

	/* StackInterpreterPrimitives>>#primitiveExternalCall */
static void
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt index;
    sqInt lit;
    usqInt numSlots;
    sqInt reasonCode;


	/* Check for it being a method for primitiveDoPrimitiveWithArgs.
	   Fetch the first literal of the method; check its an Array of length 4.
	   Look at the function index in case it has been loaded before */
	if (!((		/* begin isOopCompiledMethod: */
			((!(GIV(newMethod) & (tagMask()))))
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
		 && (((literalCountOf(GIV(newMethod))) > 0)
		 && (((lit = longAt((GIV(newMethod) + BaseHeaderSize) + (((sqInt)((usqInt)((0 + LiteralStart)) << (shiftForWord())))))),
		(			/* begin isArray: */
				((!(lit & (tagMask()))))
			 && (((((usqInt)((longAt(lit)))) >> (formatShift())) & (formatMask())) == (arrayFormat())))
			 && ((((			/* begin numSlotsOf: */
				assert((classIndexOf(lit)) > (isForwardedObjectClassIndexPun())),
			(((numSlots = byteAt(lit + 7))) == (numSlotsMask())
					? ((((usqInt)(((sqInt)((usqInt)((longAt(lit - BaseHeaderSize))) << 8)))))) >> 8
					: numSlots))) == 4)
			 && (((index = longAt((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))))),
			(((index) & 7) == 1))))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadMethod;
		return;
	}
	/* Check if we have already looked up the function and failed. */
	index = (index >> 3);
	if (index < 0) {
		/* Function address was not found in this session,
		   Void the primitive function. */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNotFound;
		return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = externalPrimitiveTable[index - 1];
		if (addr != 0) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
			/* begin callExternalPrimitive: */
			primitiveFunctionPointer = addr;
			dispatchFunctionPointer(addr);
			/* begin maybeRetryPrimitiveOnFailure */
			if (GIV(primFailCode)) {
				retryPrimitiveOnFailure();
			}
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNamedInternal;
		return;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isOopForwarded(lit)));
	longAtput((lit + BaseHeaderSize) + (((sqInt)((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))), ConstZero);
	addr = linkExternalCallerrInto(lit, (&GIV(primFailCode)));
	if (addr == 0) {
		assert((fetchPointerofObject(ExternalCallLiteralFlagsIndex, lit)) == ConstZero);
		reasonCode = (GIV(primFailCode) == 0
			? PrimErrNotFound
			: GIV(primFailCode));
		GIV(primFailCode) = reasonCode;
		return;
	}
	/* begin callExternalPrimitive: */
	primitiveFunctionPointer = addr;
	dispatchFunctionPointer(addr);
	/* begin maybeRetryPrimitiveOnFailure */
	if (GIV(primFailCode)) {
		retryPrimitiveOnFailure();
	}
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

	/* StackInterpreterPrimitives>>#primitiveFindHandlerContext */
static void
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;


	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberHandlerMarker, longAt(GIV(stackPointer)), GIV(nilObj));
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

	/* StackInterpreterPrimitives>>#primitiveFindNextUnwindContext */
static void
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt callerContextOrNil;
    sqInt handlerOrNilOrZero;
    sqInt senderContext;
    sqInt senderOop;
    char *sp;
    sqInt startContext;
    char *startFP;
    sqInt stopContext;
    char *theFP;
    char *theFP1;
    char *theFPAbove;
    sqInt theMethod;
    StackPage *thePage;
    char *theSP;

	stopContext = longAt(GIV(stackPointer));
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (		/* begin isContext: */
			((!(stopContext & (tagMask()))))
		 && (((longAt(stopContext)) & (classIndexMask())) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	assert(stopContext != calleeContext);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (	/* begin isStillMarriedContext: */
		(((((longAt((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(calleeContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - (smallIntegerTag()));
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, frameCallerContext(theFP), stopContext);
		}
		else {
			startFP = pointerForOop(longAt(theFP + FoxSavedFP));
			/* begin findMethodWithPrimitive:FromFP:UpToContext: */
			theFP1 = startFP;
			theFPAbove = startFP;
			do {
				if ((				/* begin frameHasContext: */
					((((usqInt)(longAt(theFP1 + FoxMethod)))) < (startOfMemory())
					? ((longAt(theFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
					: (byteAt((theFP1 + FoxIFrameFlags) + 2)) != 0))
				 && (stopContext == (longAt(theFP1 + FoxThisContext)))) {
					handlerOrNilOrZero = 0;
					goto l4;
				}
				if (!(					/* begin frameIsBlockActivation: */
						((((usqInt)(longAt(theFP1 + FoxMethod)))) < (startOfMemory())
						? ((longAt(theFP1 + FoxMethod)) & MFMethodFlagIsBlockFlag) != 0
						: (byteAt((theFP1 + FoxIFrameFlags) + 3)) != 0))) {
					/* begin frameMethodObject: */
					if ((((usqInt)(longAt(theFP1 + FoxMethod)))) < (startOfMemory())) {
						theMethod = ((mframeHomeMethod(theFP1))->methodObject);
					}
					else {
						theMethod = longAt(theFP1 + FoxMethod);
					}
					if ((primitiveIndexOf(theMethod)) == PrimNumberUnwindMarker) {
						if (theFP1 == theFPAbove) {
							theSP = findSPOfon(theFP1, stackPageFor(theFP1));
						}
						else {
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(theFPAbove)));
							theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;
						}
						/* begin ensureFrameIsMarried:SP: */
						if (						/* begin frameHasContext: */
							((((usqInt)(longAt(theFP1 + FoxMethod)))) < (startOfMemory())
							? ((longAt(theFP1 + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
							: (byteAt((theFP1 + FoxIFrameFlags) + 2)) != 0)) {
							assert(isContext(frameContext(theFP1)));
							handlerOrNilOrZero = longAt(theFP1 + FoxThisContext);
							goto l4;
						}
						handlerOrNilOrZero = marryFrameSP(theFP1, theSP);
						goto l4;
					}
				}
				theFPAbove = theFP1;
				theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
			} while(theFP1 != 0);
			/* begin frameCallerContext: */
			assert(isBaseFrame(theFPAbove));
			thePage = stackPageAtpages(
				(assert((((((char *) theFPAbove)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFPAbove)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(theFPAbove, GIV(stackBasePlus1), GIV(bytesPerPage))),
				GIV(pages));
			callerContextOrNil = longAt((thePage->baseAddress));
			assert(addressCouldBeObj(callerContextOrNil));
			assert((callerContextOrNil == (nilObject()))
			 || (isContext(followMaybeForwarded(callerContextOrNil))));
			senderContext = callerContextOrNil;
			if (!(				/* begin isContext: */
					((!(senderContext & (tagMask()))))
				 && (((longAt(senderContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
				handlerOrNilOrZero = GIV(nilObj);
				goto l4;
			}
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, senderContext, stopContext);
	l4:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
		}
	}
	else {
		startContext = longAt((calleeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		if (		/* begin isContext: */
			((!(startContext & (tagMask()))))
		 && (((longAt(startContext)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, startContext, stopContext);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */
/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */

	/* StackInterpreterPrimitives>>#primitiveFullGC */
static void
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    char *sp;


	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	integer = fullGC();
	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 3) | 1));
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveGetSetFFIExceptionHandling */
static void
primitiveGetSetFFIExceptionHandling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt integer;
    char *sp;

	if (GIV(argumentCount) == 0) {
		integer = (ioCanCatchFFIExceptions()
			? ffiExceptionResponse
			: -1);
		/* begin methodReturnInteger: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 3) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (!(ioCanCatchFFIExceptions())) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrUnsupported;
		return;
	}
	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	if (!(((((arg) & 7) == 1))
		 && (((((arg = (arg >> 3))) >= -1) && (arg <= 1))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ffiExceptionResponse = arg;
	/* begin methodReturnReceiver */
	assert(!((failed())));
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */
/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

	/* StackInterpreterPrimitives>>#primitiveIncrementalGC */
static void
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;


	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge);
	integerVal = ((((GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart))) - (interpreterAllocationReserveBytes())) < 0) ? 0 : ((GIV(totalFreeOldSpace) + (GIV(scavengeThreshold) - GIV(freeStart))) - (interpreterAllocationReserveBytes())));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((0) * BytesPerWord)), (((usqInt)integerVal << 3) | 1));
	GIV(stackPointer) = sp;
}


/*	because of externalInstVar:ofContext: below */

	/* StackInterpreterPrimitives>>#primitiveInstVarAt */
static void
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;
    sqInt value;

	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((!(index & (smallIntegerTag()))))
	 || ((GIV(argumentCount) > 1)
	 && (	/* begin isOopForwarded: */
		((!(rcvr & (tagMask()))))
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 3);
	hdr = long64At(rcvr);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l4;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l4;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l4;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l4;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l4;
	}
	totalLength = 0;
	l4:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l2;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l2:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			value = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))));
			goto l1;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 3) | 1);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			value = (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))))))) << 3) | 1);
			goto l1;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			value = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 3)))));
			goto l1;
		}
		value = ((((((usqInt)(long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2))))))) & 0xFFFFFFFFU) << 3) | 1);
	l1:	/* end subscript:with:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAtPut */
static void
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    usqLong fmt;
    sqLong hdr;
    sqInt index;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt totalLength;
    usqLong unsigned64BitValueToStore;
    unsigned int unsignedValueToStore;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (((!(index & (smallIntegerTag()))))
	 || ((GIV(argumentCount) > 2)
	 && (	/* begin isOopForwarded: */
		((!(rcvr & (tagMask()))))
	 && ((!((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	index = (index >> 3);
	hdr = long64At(rcvr);
	fmt = (((usqLong)(hdr)) >> (formatShift())) & (formatMask());
	/* begin lengthOf:baseHeader:format: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots1);
	if (fmt <= 5 /* begin ephemeronFormat */) {
		totalLength = numSlots;
		goto l3;
	}
	if (fmt >= (firstByteFormat())) {
		/* bytes, including CompiledMethod */
		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l3;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l3;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l3;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = numSlots;
		goto l3;
	}
	totalLength = 0;
	l3:	/* end lengthOf:baseHeader:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l1;
	}
	if (fmt < (arrayFormat())) {
		fixedFields = totalLength;
		goto l1;
	}
	class = fetchClassOfNonImm(rcvr);
	fixedFields = (((longAt((class + BaseHeaderSize) + (((sqInt)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) >> 3)) & ((1U << (fixedFieldsFieldWidth())) - 1);
	l1:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		externalInstVarofContextput(index - 1, rcvr, newValue);
	}
	else {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5 /* begin lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(rcvr)),
			oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(newValue & (tagMask()))))
				 && (oopisLessThan(newValue, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << (shiftForWord())))), newValue);
			goto l5;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((((newValue) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l5;
			}
			signedValueToStore = (newValue >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l5;
			}
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + (index - 1), signedValueToStore);
			goto l5;
		}
		if (fmt >= (firstShortFormat())) {
			if (!((((newValue) & 7) == 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l5;
			}
			signedValueToStore = (newValue >> 3);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFFFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l5;
			}
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 1))), signedValueToStore);
			goto l5;
		}
		if (fmt == (sixtyFourBitIndexableFormat())) {
			unsigned64BitValueToStore = positive64BitValueOf(newValue);
			if (!GIV(primFailCode)) {
				/* begin storeLong64:ofObject:withValue: */
				long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 3))), unsigned64BitValueToStore);
			}
			goto l5;
		}
		unsignedValueToStore = positive32BitValueOf(newValue);
		if (!GIV(primFailCode)) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)((index - 1)) << 2))), unsignedValueToStore);
		}
	l5:;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitive */
#if LRPCheck
EXPORT(void)
primitiveLongRunningPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong gcms;
    sqInt lrpcm;
    sqLong primms;
    sqInt result;
    char *sp;

	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))))
	 && ((addressCouldBeObj(lrpcm))
	 && (((((usqInt)((longAt(lrpcm)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat()))))) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), 3);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(result)));
		if ((		/* begin isOldObject: */
			assert(isNonImmediate(result)),
		oopisGreaterThanOrEqualTo(result, GIV(oldSpaceStart)))) {
			/* most stores into young objects */
			if (			/* begin isYoung: */
				((!(lrpcm & (tagMask()))))
			 && (oopisLessThan(lrpcm, GIV(oldSpaceStart)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt)((longAt(result)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(result);
				}
			}
		}
		longAtput((result + BaseHeaderSize) + (0U << (shiftForWord())), lrpcm);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result)));
		longAtput((result + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)primms << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result)));
		longAtput((result + BaseHeaderSize) + (2U << (shiftForWord())), ((gcms << 3) | 1));
	}
	else {
		result = GIV(nilObj);
	}
	voidLongRunningPrimitive("get");
	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}
#endif /* LRPCheck */


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Works correctly for cogged methods too. */

	/* StackInterpreterPrimitives>>#primitiveObjectPointsTo */
static void
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong fmt;
    sqLong header;
    sqInt header1;
    sqInt i;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt thang;
    sqInt trueOrFalse;

	thang = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((rcvr & (tagMask())) != 0)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	header = long64At(rcvr);
	fmt = (((usqLong)(header)) >> (formatShift())) & (formatMask());
	if (fmt <= 5 /* begin lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && ((header & (classIndexMask())) == ClassMethodContextCompactIndex)) {
			if (((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				assert(!((isFree(GIV(stackPage)))));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				if (				/* begin isStillMarriedContext: */
					(((((longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
				 && (!(isWidowedContext(rcvr)))) {
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2);
					/* begin pop:thenPushBool: */
					longAtput((sp1 = GIV(stackPointer) + ((1) * BytesPerWord)), (trueOrFalse
						? GIV(trueObj)
						: GIV(falseObj)));
					GIV(stackPointer) = sp1;
					return;
				}
			}
			numSlots = CtxtTempFrameStart + (fetchStackPointerOf(rcvr));
		}
		else {
			/* begin numSlotsOf: */
			assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
			numSlots = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
				: numSlots1);
		}
	}
	else {
		if (fmt < (firstCompiledMethodFormat())) {
			/* no pointers */
			/* begin pop:thenPushBool: */
			longAtput((sp2 = GIV(stackPointer) + ((1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(rcvr));
		header1 = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(HeaderIndex) << (shiftForWord())))));
		methodHeader = ((((header1) & 7) == 1)
			? header1
			: (assert((((usqInt)header1)) < GIV(newSpaceStart)),
				assert((((((CogMethod *) header1))->objectHeader)) == (nullHeaderForMachineCodeMethod())),
				((((CogMethod *) header1))->methodHeader)));
		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp3 = GIV(stackPointer) + ((1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp3;
			return;
		}
		numSlots = ((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart;
	}
	assert((((numSlots - 1) * BytesPerOop) + BaseHeaderSize) == (lastPointerOf(rcvr)));
	for (i = BaseHeaderSize; i <= (((numSlots - 1) * BytesPerOop) + BaseHeaderSize); i += BytesPerOop) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp4 = GIV(stackPointer) + ((1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp4;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp5 = GIV(stackPointer) + ((1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp5;
}

	/* StackInterpreterPrimitives>>#primitivePerform */
static void
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt lookupClassTag;
    sqInt newReceiver;
    usqInt performMethod;
    sqInt tagBits;
    sqInt tagBits1;

	performMethod = GIV(newMethod);
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,
	   so we must adjust argumentCount and slide args now, so that will work. */
	/* Slide arguments down over selector */
	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	lookupClassTag = 
	/* begin fetchClassTagOf: */
(((tagBits = newReceiver & (tagMask()))) != 0
		? tagBits
		: (longAt(newReceiver)) & (classIndexMask()));
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), (((tagBits1 = newReceiver & (tagMask()))) != 0
		? tagBits1
		: (longAt(newReceiver)) & (classIndexMask())));
	if (printOnTrace()) {
		printActivationNameForSelectorstartClass(GIV(messageSelector), classForClassTag(lookupClassTag));
		cr();
	}
	findNewMethodInClassTag(lookupClassTag);
	if (!((		/* begin isOopCompiledMethod: */
			((!(GIV(newMethod) & (tagMask()))))
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)))) {
		/* Slide the args back up (sigh) and re-insert the selector. */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;
		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(newMethod) = performMethod;
		primitiveFunctionPointer = primitivePerform;
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	executeNewMethod();
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Pin or unpin the receiver, i.e. make it immobile or mobile, based on the
	argument. Answer whether the object was already pinned. N.B. pinning does
	*not* prevent
	an object from being garbage collected. */

	/* StackInterpreterPrimitives>>#primitivePin */
static void
primitivePin(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt boolean;
    sqInt obj;
    char *sp;
    sqInt wasPinned;

	obj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((((obj & (tagMask())) != 0))
	 || ((!((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	boolean = longAt(GIV(stackPointer));
	if (!((boolean == GIV(falseObj))
		 || (boolean == GIV(trueObj)))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((((usqInt)((longAt(obj)))) >> (pinnedBitShift())) & 1) != 0) {
		wasPinned = GIV(trueObj);
		if (boolean != wasPinned) {
			/* begin setIsPinnedOf:to: */
			longAtput(obj, (longAt(obj)) & (~(usqIntptr_t)(1U << (pinnedBitShift()))));
		}
	}
	else {
		wasPinned = GIV(falseObj);
		if (boolean == GIV(trueObj)) {
			if ((			/* begin isContext: */
				((!(obj & (tagMask()))))
			 && (((longAt(obj)) & (classIndexMask())) == ClassMethodContextCompactIndex))
			 && ((((((longAt((obj + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
			 && (!(isWidowedContext(obj))))) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadReceiver;
				return;
			}
			if ((pinObject(obj)) == 0) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrNoMemory;
				return;
			}
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), wasPinned);
	GIV(stackPointer) = sp;
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

	/* StackInterpreterPrimitives>>#primitiveSetGCSemaphore */
EXPORT(void)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;


	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		index = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtMilliseconds */
static void
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong deltaMsecs;
    sqLong limit;
    sqLong msecs;
    sqInt msecsObj;
    sqInt objOop;
    sqInt sema;

	msecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj);
	if (!GIV(primFailCode)) {
		if (		/* begin isSemaphoreOop: */
			((!(sema & (tagMask()))))
		 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
			/* begin splObj:put: */
			objOop = GIV(specialObjectsOop);
			assert(!(isForwarded(objOop)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(objOop)),
			oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(sema & (tagMask()))))
				 && (oopisLessThan(sema, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(objOop);
					}
				}
			}
			longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), sema);
			deltaMsecs = msecs - ((ioMSecs()) & MillisecondClockMask);
			/* Handle a roll-over that could happen in between image invocation of ioMSecs and this invocation.
			   This will limit the maximum relative duration to MillisecondClockMask/2, about 3 days currently.
			   Every delay longer than that limit may lead to undefined behavior (shorten delay, or no delay at all) */
			limit = ((usqInt)(MillisecondClockMask)) >> 1;
			if (deltaMsecs > limit) {
				deltaMsecs -= MillisecondClockMask;
			}
			GIV(nextWakeupUsecs) = (deltaMsecs > 0
				? (ioUTCMicroseconds()) + (deltaMsecs * 1000)
				: ioUTCMicroseconds());
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(specialObjectsOop())));
			longAtput(((specialObjectsOop()) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtUTCMicroseconds */
static void
primitiveSignalAtUTCMicroseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	usecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj);
	if (!GIV(primFailCode)) {
		if (		/* begin isSemaphoreOop: */
			((!(sema & (tagMask()))))
		 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
			/* begin splObj:put: */
			objOop = GIV(specialObjectsOop);
			assert(!(isForwarded(objOop)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(objOop)),
			oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(sema & (tagMask()))))
				 && (oopisLessThan(sema, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(objOop);
					}
				}
			}
			longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), sema);
			GIV(nextWakeupUsecs) = usecs;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isOopForwarded(specialObjectsOop())));
			longAtput(((specialObjectsOop()) + BaseHeaderSize) + (((sqInt)((usqInt)(TheTimerSemaphore) << (shiftForWord())))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;
			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Answer a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive answers the raw integral value
	at each slot. 
	e.g. for Strings it answers the character code, not the Character object
	at each slot. */
/*	because of externalInstVar:ofContext: below */

	/* StackInterpreterPrimitives>>#primitiveSlotAt */
static void
primitiveSlotAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt numLiveSlots;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt oop;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    sqInt value;

	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt <= 5 /* begin lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if ((((usqInt)index)) < numSlots) {
			if (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				assert(!((isFree(GIV(stackPage)))));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				numLiveSlots = (stackPointerForMaybeMarriedContext(rcvr)) + CtxtTempFrameStart;
				value = ((((usqInt)index)) < numLiveSlots
					? externalInstVarofContext(index, rcvr)
					: GIV(nilObj));
			}
			else {
				value = longAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))));
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		numSlots = (((/* begin numSlotsOf: */
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(rcvr + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) << (shiftForWord())) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(byteAt((rcvr + BaseHeaderSize) + index)) << 3) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstShortFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(((unsigned short) (shortAt((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))))))) << 3) | 1));
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			oop = positive64BitIntegerFor(long64At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3)))));
			/* begin pop:thenPush: */
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp3;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPush: */
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((((((usqInt)(long32At((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))))))) & 0xFFFFFFFFU) << 3) | 1));
			GIV(stackPointer) = sp4;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	return;
}


/*	Assign a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive assigns a raw integral value
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAtPut */
static void
primitiveSlotAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt index;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    int ok;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    usqIntptr_t value;
    sqInt value1;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (((rcvr & (tagMask())) != 0)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (
#  if IMMUTABILITY
		((((usqInt)((longAt(rcvr)))) >> (immutableBitShift())) & 1) != 0
#  else
		0
#  endif
		) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
	index = ((index >> 3)) - 1;
	if (fmt <= 5 /* begin lastPointerFormat */) {
		/* begin numSlotsOf: */
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots = (((numSlots1 = byteAt(rcvr + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots1);
		if ((((usqInt)index)) < numSlots) {
			if (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
				externalInstVarofContextput(index, rcvr, newValue);
			}
			else {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if ((				/* begin isOldObject: */
					assert(isNonImmediate(rcvr)),
				oopisGreaterThanOrEqualTo(rcvr, GIV(oldSpaceStart)))) {
					/* most stores into young objects */
					if (					/* begin isYoung: */
						((!(newValue & (tagMask()))))
					 && (oopisLessThan(newValue, GIV(oldSpaceStart)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt)((longAt(rcvr)))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << (shiftForWord())))), newValue);
			}
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin positiveMachineIntegerValueOf: */
	if ((((newValue) & 7) == 1)) {
		value1 = (newValue >> 3);
		if (value1 < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = null;
			goto l5;
		}
		value = value1;
		goto l5;
	}
	if (((newValue & (tagMask())) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(newValue)));
	ccIndex = (longAt(newValue)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l5;
	}
	/* begin numBytesOfBytes: */
	fmt2 = (((usqInt)((longAt(newValue)))) >> (formatShift())) & (formatMask());
	assert(fmt2 >= (firstByteFormat()));
	bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(newValue)) > (isForwardedObjectClassIndexPun())),
(((numSlots3 = byteAt(newValue + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(newValue - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots3))) << (shiftForWord())) - (fmt2 & 7);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l5;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		value = SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((newValue + BaseHeaderSize))));
		goto l5;
	}
	value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((newValue + BaseHeaderSize))))));
	l5:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return;
		}
		if ((((usqInt)value)) > 0xFF) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		/* begin numBytesOfBytes: */
		fmt1 = (((usqInt)((longAt(rcvr)))) >> (formatShift())) & (formatMask());
		assert(fmt1 >= (firstByteFormat()));
		numSlots = (((/* begin numSlotsOf: */
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun())),
(((numSlots2 = byteAt(rcvr + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(rcvr - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots2))) << (shiftForWord())) - (fmt1 & 7);
		if ((((usqInt)index)) < numSlots) {
			/* begin storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + index, value);
			longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp1;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstShortFormat())) {
		if ((((usqInt)value)) > 0xFFFF) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 1;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeShort16:ofObject:withValue: */
			shortAtput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 1))), value);
			longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp2;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong64:ofObject:withValue: */
			long64Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 3))), value);
			longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp3;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstLongFormat())) {
		if ((((usqInt)value)) > 0xFFFFFFFFU) {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* begin storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + (((sqInt)((usqInt)(index) << 2))), value);
			longAtput((sp4 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp4;
			return;
		}
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	return;
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

	/* StackInterpreterPrimitives>>#primitiveStoreStackp */
static void
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt integerPointer;
    sqInt newStackp;
    usqInt numSlots;
    int onCurrentPage;
    sqInt senderOop;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;

	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((((integerPointer) & 7) == 1)) {
		newStackp = (integerPointer >> 3);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
	}
	if (!((!GIV(primFailCode))
		 && (((newStackp >= 0) && (newStackp <= (((/* begin numSlotsOf: */
	assert((classIndexOf(ctxt)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(ctxt + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(ctxt - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) - CtxtTempFrameStart)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	assert(!((isFree(GIV(stackPage)))));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (	/* begin isStillMarriedContext: */
		(((((longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
	 && (!(isWidowedContext(ctxt)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
		/* begin withoutSmallIntegerTags: */
		assert((((senderOop) & 7) == 1));
		theFP = pointerForOop(senderOop - (smallIntegerTag()));
		/* begin stackPageFor: */
		thePage = stackPageAtpages(
			(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
			pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
			GIV(pages));
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt);
		if (onCurrentPage) {
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (GIV(stackPage)->headSP);
			GIV(framePointer) = (GIV(stackPage)->headFP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer))));
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((((sp) & 7) == 1))) {
		stackp = 0;
		goto l3;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(ctxt)));
	stackp = (sp >> 3);
	l3:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(ctxt)));
		longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(((i + CtxtTempFrameStart) - 1)) << (shiftForWord())))), GIV(nilObj));
	}
	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt)));
	assert(!(isOopForwarded(ctxt)));
	longAtput((ctxt + BaseHeaderSize) + (((sqInt)((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)newStackp << 3) | 1));
	ensureContextIsExecutionSafeAfterAssignToStackPointer(ctxt);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end (v3)/size(Spur) of old-space (0-based, read-only)
	2	end (v3)/size(Spur) of young/new-space (read-only)
	3	end (v3)/size(Spur) of heap (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs (SqueakV3) or scavenges (Spur) since startup (read-only)
	10	total milliseconds in incremental GCs (SqueakV3) or scavenges (Spur)
	since startup (read-only)
	11	tenures of surving objects since startup or reset (read-write)
	12-20 were specific to ikp's JITTER VM, now 12 16 open for use
	13	if started, the start time in utc microseconds of the high-priority
	ticker 14	if started, the number of checkHighPriorityTickees calls
	15	if started, the number of tickee calls from checkHighPriorityTickees
	16	total microseconds at idle since start-up (if non-zero)
	17	fraction of the code zone to use (Sista only; used to control code zone
	use to preserve sendAndBranchData on counter tripped callback)
	18	total milliseconds in compaction phase of full GC since start-up (Spur
	only) 19	scavenge threshold, the effective size of eden. When eden fills
	to the threshold a scavenge is scheduled. Newer Spur VMs only.
	20	utc microseconds at VM start-up (actually at time initialization, which
	precedes image load).
	21	root/remembered table size (occupancy) (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored
	in image file header).
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	Spur: bytes allocated in total since start-up or reset (read-write)
	(Used to be number of allocations done before current IGC/FGC (read-only))
	35	number of survivor objects after current IGC/FGC (read-only)
	36	millisecond clock when current IGC/FGC completed (read-only)
	37	number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38	milliseconds taken by current IGC (read-only)
	39	Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40	BytesPerOop for this image
	41	imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (stored in image file header; Cog only;
	otherwise nil)
	48	various header flags. See getImageHeaderFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	
		50	max literal count for JIT compile (stored in image file header; Cog
	only; otherwise nil)
	51 nil; reserved for VM parameters that persist in the image (such as eden
	above) 52	root/remembered table capacity
	53	number of segments (Spur only; otherwise nil)
	54	total size of free old space (Spur only, otherwise nil)
	55	ratio of growth and image size at or above which a GC will be performed
	post scavenge
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	65	various VM feature flags; see getCogVMFeatureFlags
	66	the byte size of a stack page
	67	the max allowed size of old space (Spur only; nil otherwise; 0 implies
	no limit except that of the underlying platform)
	68	the average number of live stack pages when scanned by GC (at
	scavenge/gc/become et al) (read-write)
	69	the maximum number of live stack pages when scanned by GC (at
	scavenge/gc/become et al) (read-write)
	70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
	71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
	72 total milliseconds in full GCs Mark phase since startup (read-only)
	73 total milliseconds in full GCs Sweep phase since startup (read-only,
	can be 0 depending on compactors)
	74 maximum pause time due to segment allocation
	75 whether the arithmetic primitives perform conversion in case of mixed
	SmallInteger/Float (true) or fail (false)
	76 the minimum unused headroom in all stack pages; Cog VMs only
	
	Note: Thanks to Ian Piumarta for this primitive. */

	/* StackInterpreterPrimitives>>#primitiveVMParameter */
static void
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    double aDouble;
    double aFloat;
    double aProportion;
    sqIntptr_t arg;
    sqInt argOop;
    sqInt bs;
    sqInt ccIndex;
    sqLong delta;
    sqInt fmt;
    sqInt i;
    sqInt i1;
    sqInt index;
    int mustFlush;
    usqInt numSlots;
    int ok;
    sqInt oldPrimitiveDoMixedArithmetic;
    sqInt oop;
    sqInt paramsArraySize;
    sqInt result;
    sqInt result1;
    sqInt result2;
    sqInt senderOop;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp3;
    sqInt tagBits;
    char *theFrame;
    StackPage *thePage;
    sqInt top;
    sqInt value;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer10;
    sqInt valuePointer11;
    sqInt valuePointer12;
    sqInt valuePointer13;
    sqInt valuePointer14;
    sqInt valuePointer15;
    sqInt valuePointer16;
    sqInt valuePointer17;
    sqInt valuePointer18;
    sqInt valuePointer19;
    sqInt valuePointer2;
    sqInt valuePointer20;
    sqInt valuePointer21;
    sqInt valuePointer22;
    sqInt valuePointer23;
    sqInt valuePointer24;
    sqInt valuePointer25;
    sqInt valuePointer26;
    sqInt valuePointer27;
    sqInt valuePointer28;
    sqInt valuePointer29;
    sqInt valuePointer3;
    sqInt valuePointer30;
    sqInt valuePointer31;
    sqInt valuePointer32;
    sqInt valuePointer33;
    sqInt valuePointer4;
    sqInt valuePointer5;
    sqInt valuePointer6;
    sqInt valuePointer7;
    sqInt valuePointer8;
    sqInt valuePointer9;

	paramsArraySize = 76;
	if (GIV(argumentCount) == 0) {
		/* begin primitiveAllVMParameters: */
		result1 = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (((sqInt)((usqInt)(ClassArray) << (shiftForWord()))))), paramsArraySize);
		valuePointer = positiveMachineIntegerFor(
			(			/* begin totalOldSpaceSize */
				assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
			GIV(totalHeapSizeIncludingBridges)));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
		valuePointer1 = (((usqInt)((GIV(freeStart) - (((eden()).start))) + (GIV(pastSpaceStart) - (((pastSpace()).start)))) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer1);
		valuePointer2 = positiveMachineIntegerFor((newSpaceCapacity()) + ((/* begin totalOldSpaceSize */
	assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges))));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer2);
		valuePointer3 = (((usqInt)(((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (5U << (shiftForWord())), valuePointer3);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (6U << (shiftForWord())), (((usqInt)GIV(statFullGCs) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (7U << (shiftForWord())), ((((GIV(statFullGCUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (8U << (shiftForWord())), (((usqInt)GIV(statScavenges) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (9U << (shiftForWord())), ((((GIV(statScavengeGCUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (10U << (shiftForWord())), (((usqInt)GIV(statTenures) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (11U << (shiftForWord())), (((usqInt)eventTraceMask << 3) | 1));
		valuePointer4 = 
#    if VM_TICKER
			positive64BitIntegerFor(ioVMTickerStartUSecs())
#    else
			ConstZero
#    endif
			;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (12U << (shiftForWord())), valuePointer4);
		valuePointer5 = 
#    if VM_TICKER
			positiveMachineIntegerFor(ioVMTickerCount())
#    else
			ConstZero
#    endif
			;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (13U << (shiftForWord())), valuePointer5);
		valuePointer6 = 
#    if VM_TICKER
			positiveMachineIntegerFor(ioVMTickeeCallCount())
#    else
			ConstZero
#    endif
			;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (14U << (shiftForWord())), valuePointer6);
		valuePointer7 = positive64BitIntegerFor(GIV(statIdleUsecs));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (15U << (shiftForWord())), valuePointer7);
		valuePointer8 = ConstZero;
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (16U << (shiftForWord())), valuePointer8);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (17U << (shiftForWord())), ((((GIV(statCompactionUsecs) + 500) / 1000) << 3) | 1));
		valuePointer9 = (((usqInt)(GIV(scavengeThreshold) - (((eden()).start))) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (18U << (shiftForWord())), valuePointer9);
		valuePointer10 = positive64BitIntegerFor(ioUTCStartMicroseconds());
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (19U << (shiftForWord())), valuePointer10);
		valuePointer11 = (((usqInt)(rootTableCount()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (20U << (shiftForWord())), valuePointer11);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (21U << (shiftForWord())), (((usqInt)GIV(statRootTableOverflows) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (22U << (shiftForWord())), (((usqInt)extraVMMemory << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (23U << (shiftForWord())), (((usqInt)GIV(shrinkThreshold) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (24U << (shiftForWord())), (((usqInt)GIV(growHeadroom) << 3) | 1));
		valuePointer12 = (((usqInt)(ioHeartbeatMilliseconds()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (25U << (shiftForWord())), valuePointer12);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (26U << (shiftForWord())), (((usqInt)GIV(statMarkCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (27U << (shiftForWord())), (((usqInt)0 /* begin statSweepCount */ << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (28U << (shiftForWord())), (((usqInt)0 /* begin statMkFwdCount */ << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (29U << (shiftForWord())), (((usqInt)GIV(statCompactPassCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (30U << (shiftForWord())), (((usqInt)GIV(statGrowMemory) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (0x1FU << (shiftForWord())), (((usqInt)GIV(statShrinkMemory) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (32U << (shiftForWord())), (((usqInt)GIV(statRootTableCount) << 3) | 1));
		valuePointer13 = positive64BitIntegerFor(currentAllocatedBytes());
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (33U << (shiftForWord())), valuePointer13);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (34U << (shiftForWord())), (((usqInt)GIV(statSurvivorCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (35U << (shiftForWord())), ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (36U << (shiftForWord())), (((usqInt)0 /* begin statSpecialMarkCount */ << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (37U << (shiftForWord())), ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (38U << (shiftForWord())), (((usqInt)GIV(statPendingFinalizationSignals) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (39U << (shiftForWord())), (((usqInt)BytesPerWord << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (40U << (shiftForWord())), (((usqInt)68021 /* begin imageFormatVersion */ << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (41U << (shiftForWord())), (((usqInt)GIV(numStackPages) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (42U << (shiftForWord())), (((usqInt)desiredNumStackPages << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (43U << (shiftForWord())), (((usqInt)(((GIV(eden).limit)) - ((GIV(eden).start))) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (44U << (shiftForWord())), (((usqInt)desiredEdenBytes << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (45U << (shiftForWord())), ((GIV(cogCodeSize) << 3) | 1));
		valuePointer14 = getDesiredCogCodeSize();
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (46U << (shiftForWord())), valuePointer14);
		valuePointer15 = (((usqInt)(((usqInt)((getImageHeaderFlags()))) >> 2) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (47U << (shiftForWord())), valuePointer15);
		valuePointer16 = (((usqInt)(ioGetMaxExtSemTableSize()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (48U << (shiftForWord())), valuePointer16);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (49U << (shiftForWord())), (((usqInt)maxLiteralCountForCompile << 3) | 1));
		valuePointer17 = (((usqInt)(((GIV(oldImageBaseAddress) != GIV(oldSpaceStart)
	? 1
	: 0)) + ((sqImageFileIsEmbedded()
	? 2
	: 0))) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (50U << (shiftForWord())), valuePointer17);
		valuePointer18 = (((usqInt)(rootTableCapacity()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (51U << (shiftForWord())), valuePointer18);
		valuePointer19 = (((usqInt)(numSegments()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (52U << (shiftForWord())), valuePointer19);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (53U << (shiftForWord())), ((GIV(totalFreeOldSpace) << 3) | 1));
		valuePointer20 = floatObjectOf(getHeapGrowthToSizeGCRatio());
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (54U << (shiftForWord())), valuePointer20);
		valuePointer21 = positive64BitIntegerFor(GIV(statProcessSwitch));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (55U << (shiftForWord())), valuePointer21);
		valuePointer22 = positive64BitIntegerFor(GIV(statIOProcessEvents));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (56U << (shiftForWord())), valuePointer22);
		valuePointer23 = positive64BitIntegerFor(GIV(statForceInterruptCheck));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (57U << (shiftForWord())), valuePointer23);
		valuePointer24 = positive64BitIntegerFor(GIV(statCheckForEvents));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (58U << (shiftForWord())), valuePointer24);
		valuePointer25 = positive64BitIntegerFor(GIV(statStackOverflow));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (59U << (shiftForWord())), valuePointer25);
		valuePointer26 = positive64BitIntegerFor(GIV(statStackPageDivorce));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (60U << (shiftForWord())), valuePointer26);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (61U << (shiftForWord())), (((usqInt)GIV(statCodeCompactionCount) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (0x3EU << (shiftForWord())), ((((GIV(statCodeCompactionUsecs) + 500) / 1000) << 3) | 1));
		valuePointer27 = (((usqInt)(numMethodsOfType(CMMethod)) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (0x3FU << (shiftForWord())), valuePointer27);
		valuePointer28 = getCogVMFeatureFlags();
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (64U << (shiftForWord())), valuePointer28);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (65U << (shiftForWord())), (((usqInt)GIV(bytesPerPage) << 3) | 1));
		valuePointer29 = positiveMachineIntegerFor(maxOldSpaceSize());
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (66U << (shiftForWord())), valuePointer29);
		valuePointer30 = floatObjectOf(statAverageLivePagesWhenMapping());
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (67U << (shiftForWord())), valuePointer30);
		valuePointer31 = (((usqInt)(statMaxPageCountWhenMapping()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (68U << (shiftForWord())), valuePointer31);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (69U << (shiftForWord())), (((usqInt)VM_PROXY_MAJOR /* begin vmProxyMajorVersion */ << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (70U << (shiftForWord())), (((usqInt)VM_PROXY_MINOR /* begin vmProxyMinorVersion */ << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (71U << (shiftForWord())), ((((GIV(statMarkUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (72U << (shiftForWord())), ((((GIV(statSweepUsecs) + 500) / 1000) << 3) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (73U << (shiftForWord())), (((usqInt)((GIV(statMaxAllocSegmentTime) + 500) / 1000) << 3) | 1));
		valuePointer32 = 
		/* begin booleanObjectOf: */
(primitiveDoMixedArithmetic()
			? GIV(trueObj)
			: GIV(falseObj));
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (74U << (shiftForWord())), valuePointer32);
		valuePointer33 = (((usqInt)(minimumUnusedHeadroom()) << 3) | 1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(result1)));
		longAtput((result1 + BaseHeaderSize) + (75U << (shiftForWord())), valuePointer33);
		beRootIfOld(result1);
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result1);
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) > 2) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	index = longAt(GIV(stackPointer) + (((GIV(argumentCount) == 1
	? 0
	: 1)) * BytesPerWord));
	if (!((((index) & 7) == 1))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 3);
	if ((index < 1)
	 || (index > paramsArraySize)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (GIV(argumentCount) == 1) {
		/* read VM parameter; written this way to avoid branch limits in V3 bytecode set */
		/* written thus to enable Slang inlining of primitiveGetVMParameter: */
		/* begin primitiveGetVMParameter: */
		switch (index) {
		case 1:
			result = positiveMachineIntegerFor(
				(				/* begin totalOldSpaceSize */
					assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
				GIV(totalHeapSizeIncludingBridges)));
			goto l36;
			break;
		case 2:
			result = (((usqInt)((GIV(freeStart) - (((eden()).start))) + (GIV(pastSpaceStart) - (((pastSpace()).start)))) << 3) | 1);
			goto l36;
			break;
		case 3:
			result = positiveMachineIntegerFor((newSpaceCapacity()) + ((/* begin totalOldSpaceSize */
	assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges)),
GIV(totalHeapSizeIncludingBridges))));
			goto l36;
			break;
		case 6:
			result = (((usqInt)(((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
			goto l36;
			break;
		case 7:
			result = (((usqInt)GIV(statFullGCs) << 3) | 1);
			goto l36;
			break;
		case 8:
			result = ((((GIV(statFullGCUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 9:
			result = (((usqInt)GIV(statScavenges) << 3) | 1);
			goto l36;
			break;
		case 10:
			result = ((((GIV(statScavengeGCUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 11:
			result = (((usqInt)GIV(statTenures) << 3) | 1);
			goto l36;
			break;
		case 12:
			result = (((usqInt)eventTraceMask << 3) | 1);
			goto l36;
			break;
		case 13:
			result = 
#      if VM_TICKER
				positive64BitIntegerFor(ioVMTickerStartUSecs())
#      else
				ConstZero
#      endif
				;
			goto l36;
			break;
		case 14:
			result = 
#      if VM_TICKER
				positiveMachineIntegerFor(ioVMTickerCount())
#      else
				ConstZero
#      endif
				;
			goto l36;
			break;
		case 15:
			result = 
#      if VM_TICKER
				positiveMachineIntegerFor(ioVMTickeeCallCount())
#      else
				ConstZero
#      endif
				;
			goto l36;
			break;
		case 16:
			result = positive64BitIntegerFor(GIV(statIdleUsecs));
			goto l36;
			break;
		case 17:
			result = ConstZero;
			goto l36;
			break;
		case 18:
			result = ((((GIV(statCompactionUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 19:
			result = (((usqInt)(GIV(scavengeThreshold) - (((eden()).start))) << 3) | 1);
			goto l36;
			break;
		case 20:
			result = positive64BitIntegerFor(ioUTCStartMicroseconds());
			goto l36;
			break;
		case 21:
			result = (((usqInt)(rootTableCount()) << 3) | 1);
			goto l36;
			break;
		case 22:
			result = (((usqInt)GIV(statRootTableOverflows) << 3) | 1);
			goto l36;
			break;
		case 23:
			result = (((usqInt)extraVMMemory << 3) | 1);
			goto l36;
			break;
		case 24:
			result = (((usqInt)GIV(shrinkThreshold) << 3) | 1);
			goto l36;
			break;
		case 25:
			result = (((usqInt)GIV(growHeadroom) << 3) | 1);
			goto l36;
			break;
		case 26:
			result = (((usqInt)(ioHeartbeatMilliseconds()) << 3) | 1);
			goto l36;
			break;
		case 27:
			result = (((usqInt)GIV(statMarkCount) << 3) | 1);
			goto l36;
			break;
		case 28:
			result = (((usqInt)0 /* begin statSweepCount */ << 3) | 1);
			goto l36;
			break;
		case 29:
			result = (((usqInt)0 /* begin statMkFwdCount */ << 3) | 1);
			goto l36;
			break;
		case 30:
			result = (((usqInt)GIV(statCompactPassCount) << 3) | 1);
			goto l36;
			break;
		case 0x1F:
			result = (((usqInt)GIV(statGrowMemory) << 3) | 1);
			goto l36;
			break;
		case 32:
			result = (((usqInt)GIV(statShrinkMemory) << 3) | 1);
			goto l36;
			break;
		case 33:
			result = (((usqInt)GIV(statRootTableCount) << 3) | 1);
			goto l36;
			break;
		case 34:
			result = positive64BitIntegerFor(currentAllocatedBytes());
			goto l36;
			break;
		case 35:
			result = (((usqInt)GIV(statSurvivorCount) << 3) | 1);
			goto l36;
			break;
		case 36:
			result = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 3) | 1);
			goto l36;
			break;
		case 37:
			result = (((usqInt)0 /* begin statSpecialMarkCount */ << 3) | 1);
			goto l36;
			break;
		case 38:
			result = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 39:
			result = (((usqInt)GIV(statPendingFinalizationSignals) << 3) | 1);
			goto l36;
			break;
		case 40:
			result = (((usqInt)BytesPerWord << 3) | 1);
			goto l36;
			break;
		case 41:
			result = (((usqInt)68021 /* begin imageFormatVersion */ << 3) | 1);
			goto l36;
			break;
		case 42:
			result = (((usqInt)GIV(numStackPages) << 3) | 1);
			goto l36;
			break;
		case 43:
			result = (((usqInt)desiredNumStackPages << 3) | 1);
			goto l36;
			break;
		case 44:
			result = (((usqInt)(((GIV(eden).limit)) - ((GIV(eden).start))) << 3) | 1);
			goto l36;
			break;
		case 45:
			result = (((usqInt)desiredEdenBytes << 3) | 1);
			goto l36;
			break;
		case 46:
			result = ((GIV(cogCodeSize) << 3) | 1);
			goto l36;
			break;
		case 47:
			result = getDesiredCogCodeSize();
			goto l36;
			break;
		case 48:
			result = (((usqInt)(((usqInt)((getImageHeaderFlags()))) >> 2) << 3) | 1);
			goto l36;
			break;
		case 49:
			result = (((usqInt)(ioGetMaxExtSemTableSize()) << 3) | 1);
			goto l36;
			break;
		case 50:
			result = (((usqInt)maxLiteralCountForCompile << 3) | 1);
			goto l36;
			break;
		case 51:
			result = (((usqInt)(((GIV(oldImageBaseAddress) != GIV(oldSpaceStart)
	? 1
	: 0)) + ((sqImageFileIsEmbedded()
	? 2
	: 0))) << 3) | 1);
			goto l36;
			break;
		case 52:
			result = (((usqInt)(rootTableCapacity()) << 3) | 1);
			goto l36;
			break;
		case 53:
			result = (((usqInt)(numSegments()) << 3) | 1);
			goto l36;
			break;
		case 54:
			result = ((GIV(totalFreeOldSpace) << 3) | 1);
			goto l36;
			break;
		case 55:
			result = floatObjectOf(getHeapGrowthToSizeGCRatio());
			goto l36;
			break;
		case 56:
			result = positive64BitIntegerFor(GIV(statProcessSwitch));
			goto l36;
			break;
		case 57:
			result = positive64BitIntegerFor(GIV(statIOProcessEvents));
			goto l36;
			break;
		case 58:
			result = positive64BitIntegerFor(GIV(statForceInterruptCheck));
			goto l36;
			break;
		case 59:
			result = positive64BitIntegerFor(GIV(statCheckForEvents));
			goto l36;
			break;
		case 60:
			result = positive64BitIntegerFor(GIV(statStackOverflow));
			goto l36;
			break;
		case 61:
			result = positive64BitIntegerFor(GIV(statStackPageDivorce));
			goto l36;
			break;
		case 0x3E:
			result = (((usqInt)GIV(statCodeCompactionCount) << 3) | 1);
			goto l36;
			break;
		case 0x3F:
			result = ((((GIV(statCodeCompactionUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 64:
			result = (((usqInt)(numMethodsOfType(CMMethod)) << 3) | 1);
			goto l36;
			break;
		case 65:
			result = getCogVMFeatureFlags();
			goto l36;
			break;
		case 66:
			result = (((usqInt)GIV(bytesPerPage) << 3) | 1);
			goto l36;
			break;
		case 67:
			result = positiveMachineIntegerFor(maxOldSpaceSize());
			goto l36;
			break;
		case 68:
			result = floatObjectOf(statAverageLivePagesWhenMapping());
			goto l36;
			break;
		case 69:
			result = (((usqInt)(statMaxPageCountWhenMapping()) << 3) | 1);
			goto l36;
			break;
		case 70:
			result = (((usqInt)VM_PROXY_MAJOR /* begin vmProxyMajorVersion */ << 3) | 1);
			goto l36;
			break;
		case 71:
			result = (((usqInt)VM_PROXY_MINOR /* begin vmProxyMinorVersion */ << 3) | 1);
			goto l36;
			break;
		case 72:
			result = ((((GIV(statMarkUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 73:
			result = ((((GIV(statSweepUsecs) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 74:
			result = (((usqInt)((GIV(statMaxAllocSegmentTime) + 500) / 1000) << 3) | 1);
			goto l36;
			break;
		case 75:
			result = 
			/* begin booleanObjectOf: */
(primitiveDoMixedArithmetic()
				? GIV(trueObj)
				: GIV(falseObj));
			goto l36;
			break;
		case 76:
			result = (((usqInt)(minimumUnusedHeadroom()) << 3) | 1);
			goto l36;
			break;
		default:
			result = null;
			goto l36;
		}
	l36:	/* end primitiveGetVMParameter: */;
		oop = (!(result)
			? GIV(nilObj)
			: result);
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp1;
		return;
	}
	argOop = longAt(GIV(stackPointer));
	/* begin primitiveSetVMParameter:arg: */
	switch (index) {
	case 17:
	case 55:
	case 68:
		if (!((			/* begin isFloatInstance: */
				(((tagBits = argOop & (tagMask()))) != 0
				? tagBits == (smallFloatTag())
				: ((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex))
			 || ((((argOop) & 7) == 1)))) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		break;
	case 67:
		/* begin positiveMachineIntegerValueOf: */
		if ((((argOop) & 7) == 1)) {
			value = (argOop >> 3);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg = ((usqIntptr_t) null);
				goto l44;
			}
			arg = ((usqIntptr_t) value);
			goto l44;
		}
		if (((argOop & (tagMask())) != 0)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			arg = 0;
			goto l44;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(argOop)));
		ccIndex = (longAt(argOop)) & (classIndexMask());
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			arg = 0;
			goto l44;
		}
		/* begin numBytesOfBytes: */
		fmt = (((usqInt)((longAt(argOop)))) >> (formatShift())) & (formatMask());
		assert(fmt >= (firstByteFormat()));
		bs = (((/* begin numSlotsOf: */
	assert((classIndexOf(argOop)) > (isForwardedObjectClassIndexPun())),
(((numSlots = byteAt(argOop + 7))) == (numSlotsMask())
		? ((((usqInt)(((sqInt)((usqInt)((longAt(argOop - BaseHeaderSize))) << 8)))))) >> 8
		: numSlots))) << (shiftForWord())) - (fmt & 7);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			arg = 0;
			goto l44;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			arg = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((long64At((argOop + BaseHeaderSize))))));
			goto l44;
		}
		arg = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((argOop + BaseHeaderSize))))))));
	l44:	/* end positiveMachineIntegerValueOf: */;
		break;
	case 75:
		/* begin booleanValueOf: */
		if (argOop == GIV(trueObj)) {
			arg = 1;
			goto l47;
		}
		if (argOop == GIV(falseObj)) {
			arg = 0;
			goto l47;
		}
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		};
		arg = null;
	l47:	/* end booleanValueOf: */;
		break;
	default:
		arg = (argOop >> 3);
	}
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l49;
	}
	/* begin primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	switch (index) {
	case 5:
		break;
	case 6:
		result2 = (((usqInt)(((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / (8 * BytesPerOop)))) << 3) | 1);
		/* begin tenuringThreshold: */
		if (arg < 0) {
			GIV(primFailCode) = PrimErrBadArgument;
			goto l37;
		}
		aProportion = (((double) (arg * (8 * BytesPerOop)) )) / (((double) (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) ));
		/* begin scavengerTenuringThreshold: */
		GIV(tenuringProportion) = aProportion;
		GIV(tenureThreshold) = (aProportion == 0.0
			? 0
			: (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - aProportion)))) + ((GIV(pastSpace).start)));
		GIV(primFailCode) = 0;
	l37:	/* end tenuringThreshold: */;
		break;
	case 12:
		result2 = (((usqInt)eventTraceMask << 3) | 1);
		eventTraceMask = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		break;
	case 11:
		if (arg >= 0) {
			result2 = (((usqInt)GIV(statTenures) << 3) | 1);
			/* begin statTenures: */
			GIV(statTenures) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 17:
		break;
	case 23:
		result2 = (((usqInt)extraVMMemory << 3) | 1);
		extraVMMemory = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		break;
	case 24:
		if (arg > 0) {
			result2 = (((usqInt)GIV(shrinkThreshold) << 3) | 1);
			/* begin shrinkThreshold: */
			GIV(shrinkThreshold) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 25:
		if (arg > 0) {
			result2 = (((usqInt)GIV(growHeadroom) << 3) | 1);
			/* begin growHeadroom: */
			GIV(growHeadroom) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 26:
		if (arg >= 0) {
			/* 0 turns off the heartbeat */
			result2 = (((usqInt)(ioHeartbeatMilliseconds()) << 3) | 1);
			ioSetHeartbeatMilliseconds(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 34:
		if (arg >= 0) {
			result2 = positive64BitIntegerFor(currentAllocatedBytes());
			/* begin setCurrentAllocatedBytesTo: */
			delta = (currentAllocatedBytes()) - GIV(statAllocatedBytes);
			GIV(statAllocatedBytes) = arg;
			GIV(oldSpaceUsePriorToScavenge) += delta;
			assert((currentAllocatedBytes()) == arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 43:
		if (((arg >= 0) && (arg <= 0xFFFF))) {
			result2 = (((usqInt)desiredNumStackPages << 3) | 1);
			desiredNumStackPages = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 45:
		if (arg >= 0) {
			result2 = (((usqInt)desiredEdenBytes << 3) | 1);
			desiredEdenBytes = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 47:
		if (((arg >= 0) && (arg <= (maxCogCodeSize())))) {
			result2 = (((usqInt)(getDesiredCogCodeSize()) << 3) | 1);
			/* begin setDesiredCogCodeSize: */
			desiredCogCodeSize = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 48:
		if (arg >= 0) {
			oldPrimitiveDoMixedArithmetic = primitiveDoMixedArithmetic;
			result2 = (((usqInt)(((usqInt)((getImageHeaderFlags()))) >> 2) << 3) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			if ((((usqInt)arg)) > 0x1FF) {
				/* begin primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				goto l39;
			}
			GIV(imageHeaderFlags) = (((arg & 1) != 0)
				? GIV(imageHeaderFlags) | 4
				: ((GIV(imageHeaderFlags) | 4) - 4));
			GIV(flagInterpretedMethods) = ((arg & 2) != 0);
			/* noThreadingOfGUIThread := flags anyMask: 8.. specific to CoInterpreterMT */
			GIV(preemptionYields) = (!(arg & 4));
			GIV(imageHeaderFlags) = (((arg & 8) != 0)
				? GIV(imageHeaderFlags) | 32
				: ((GIV(imageHeaderFlags) | 32) - 32));
			GIV(newFinalization) = ((arg & 16) != 0);
			sendWheelEvents = ((arg & 32) != 0);
			/* fileTimesInUTC := flags anyMask: 128. see FilePlugin & FileAttributesPlugin */
			primitiveDoMixedArithmetic = (!(arg & 64));
			GIV(imageHeaderFlags) = (((arg & 128) != 0)
				? GIV(imageHeaderFlags) | 0x200
				: ((GIV(imageHeaderFlags) | 0x200) - 0x200));
			upscaleDisplayIfHighDPI = (!(arg & 0x100));
	l39:	/* end setImageHeaderFlags: */;
			if ((GIV(primFailCode) == 0)
			 && (oldPrimitiveDoMixedArithmetic != primitiveDoMixedArithmetic)) {
				/* begin flushMethodCache */
				for (i = 1; i <= MethodCacheSize; i += 1) {
					GIV(methodCache)[i] = 0;
				}
				/* this for primitiveExternalMethod */
				GIV(lastMethodCacheProbeWrite) = 0;
				unlinkAllSends();
				flushMethodsWithMachineCodePrimitivesAndContinueAnswering(result2);
				goto l49;
			}
		}
		break;
	case 49:
		if (((arg >= 0) && (arg <= 0xFFFF))) {
			result2 = (((usqInt)(ioGetMaxExtSemTableSize()) << 3) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
		break;
	case 50:
		if (((arg >= 0) && (arg <= 0x7FFF))) {
			result2 = (((usqInt)((((usqInt)maxLiteralCountForCompile << 3) | 1)) << 3) | 1);
			/* begin setMaxLiteralCountForCompile: */
			maxLiteralCountForCompile = (GIV(the2ndUnknownShort) = arg);
			GIV(primFailCode) = 0;
			activeContext = divorceAllFramesSuchThat(isMachineCodeFrameForCogMethodWithTooManyLiterals);
			ensureAllContextsHaveBytecodePCsIf(methodHasTooManyLiterals);
			unlinkSendsToMethodsSuchThatAndFreeIf(cogMethodHasTooManyLiterals, 1);
			if (!(				/* begin isStillMarriedContext: */
					(((((longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord()))))))) & 7) == 1))
				 && (!(isWidowedContext(activeContext))))) {
				/* begin nilStackPage */
				assert((!GIV(stackPage))
				 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
				 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
				GIV(stackPage) = null;
				marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
				/* begin pop:thenPush: */
				longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 2) - 1) * BytesPerWord)), result2);
				GIV(stackPointer) = sp3;
				ceInvokeInterpret();
			}
			/* begin frameOfMarriedContext: */
			senderOop = longAt((activeContext + BaseHeaderSize) + (((sqInt)((usqInt)(SenderIndex) << (shiftForWord())))));
			/* begin withoutSmallIntegerTags: */
			assert((((senderOop) & 7) == 1));
			theFrame = pointerForOop(senderOop - (smallIntegerTag()));
			/* begin stackPageFor: */
			thePage = stackPageAtpages(
				(assert((((((char *) theFrame)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFrame)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(theFrame, GIV(stackBasePlus1), GIV(bytesPerPage))),
				GIV(pages));
			assert(((thePage->headFP)) == theFrame);
			/* begin setStackPageAndLimit: */
			assert(thePage);
			GIV(stackPage) = thePage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(thePage);
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (thePage->headSP);
			GIV(framePointer) = (thePage->headFP);
			/* begin popStack */
			top = longAt(GIV(stackPointer));
			GIV(stackPointer) += BytesPerWord;
			GIV(instructionPointer) = top;
			if (GIV(instructionPointer) == (ceReturnToInterpreterPC())) {
				GIV(instructionPointer) = ((usqInt)(longAt(GIV(framePointer) + FoxIFSavedIP)));
			}
			/* begin pop:thenPush: */
			longAtput((sp11 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result2);
			GIV(stackPointer) = sp11;
			goto l49;
		}
		break;
	case 55:
		result2 = floatObjectOf(getHeapGrowthToSizeGCRatio());
		aDouble = loadFloatOrIntFrom(argOop);
		/* begin setHeapGrowthToSizeGCRatio: */
		GIV(heapGrowthToSizeGCRatio) = aDouble;
		GIV(primFailCode) = 0;
		break;
	case 67:
		if ((arg >= 0)) {
			result2 = positiveMachineIntegerFor(maxOldSpaceSize());
			/* begin setMaxOldSpaceSize: */
			maxOldSpaceSize = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 68:
		result2 = floatObjectOf(statAverageLivePagesWhenMapping());
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		aFloat = loadFloatOrIntFrom(argOop);
		/* begin statAverageLivePagesWhenMapping: */
		if (aFloat == 0.0) {
			GIV(statPageCountWhenMappingSum) = (GIV(statNumMaps) = 0);
		}
		else {
			/* begin primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
		break;
	case 69:
		if (arg >= 0) {
			result2 = (((usqInt)(statMaxPageCountWhenMapping()) << 3) | 1);
			/* begin statMaxPageCountWhenMapping: */
			GIV(statMaxPageCountWhenMapping) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 74:
		if ((arg >= 0)) {
			result2 = (((usqInt)((GIV(statMaxAllocSegmentTime) + 500) / 1000) << 3) | 1);
			/* begin statMaxAllocSegmentTime: */
			GIV(statMaxAllocSegmentTime) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 75:
		result2 = 
		/* begin booleanObjectOf: */
(primitiveDoMixedArithmetic()
			? GIV(trueObj)
			: GIV(falseObj));
		GIV(primFailCode) = 0;
		mustFlush = primitiveDoMixedArithmetic != arg;
		primitiveDoMixedArithmetic = arg;
		if (mustFlush) {
			/* begin flushMethodCache */
			for (i1 = 1; i1 <= MethodCacheSize; i1 += 1) {
				GIV(methodCache)[i1] = 0;
			}
			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = 0;
			unlinkAllSends();
			flushMethodsWithMachineCodePrimitivesAndContinueAnswering(result2);
			goto l49;
		}
		break;
	default:
;
	}
	if (GIV(primFailCode)) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result2);
		GIV(stackPointer) = sp2;
	}
	l49:	/* end primitiveSetVMParameter:arg: */;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

	/* StackInterpreterPrimitives>>#primitiveVoidReceiver */
EXPORT(void)
primitiveVoidReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtPointerput(	/* begin frameReceiverLocation: */
		((((usqInt)(longAt(GIV(framePointer) + FoxMethod)))) < (startOfMemory())
		? GIV(framePointer) + FoxMFReceiver
		: GIV(framePointer) + FoxIFReceiver), 0);
}


/*	Prune the stack to contain only the path, removing stacked indices
	and mapping frame pointers to contexts The issue here is that a
	GC can occur during ensureFrameIsMarried:SP:, but frame pointers
	are not valid objects. So first prune back to objects and framePointers
	as integers, and then replace frame pointers as integers by contexts. */

	/* StackInterpreterPrimitives>>#pruneStack:stackp: */
static NoDbgRegParms void
pruneStackstackp(sqInt stack, sqInt stackp)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt finger;
    char *fp;
    sqInt i;
    sqInt iLimiT;
    sqInt objOrFP;
    sqInt oop;
    sqInt oop1;
    char *theFP;
    char *theFPAbove;
    StackPage *thePage;
    char *theSP;
    sqInt theStack;

	finger = 1;
	for (i = 2; i < stackp; i += 2) {
		objOrFP = longAt((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if (		/* begin couldBeFramePointer: */
			(GIV(stackBasePlus1))
		 && ((((((usqInt)(((char *) objOrFP)))) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)(((char *) objOrFP)))) >= (((usqInt)(GIV(stackBasePlus1) - 1)))) && ((((usqInt)(((char *) objOrFP)))) <= (((usqInt)GIV(pages)))))))) {
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(objOrFP)) & (BytesPerWord - 1)) == 0);
			objOrFP = (oopForPointer(objOrFP)) + (smallIntegerTag());
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(stack)));
		longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(finger) << (shiftForWord())))), objOrFP);
		finger += 1;
	}
	for (i = finger, iLimiT = ((lengthOf(stack)) - 1); i <= iLimiT; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isOopForwarded(stack)));
		longAtput((stack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}
	oop = (theStack = stack);
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	for (i = 1; i < finger; i += 1) {
		objOrFP = longAt((theStack + BaseHeaderSize) + (((sqInt)((usqInt)(i) << (shiftForWord())))));
		if ((((objOrFP) & 7) == 1)) {
			/* begin withoutSmallIntegerTags: */
			assert((((objOrFP) & 7) == 1));
			theFP = pointerForOop(objOrFP - (smallIntegerTag()));
			/* begin stackPageFor: */
			thePage = stackPageAtpages(
				(assert((((((char *) theFP)) >= (GIV(stackBasePlus1) - 1)) && ((((char *) theFP)) <= (((char *) GIV(pages)))))),
				pageIndexForstackBasePlus1bytesPerPage(theFP, GIV(stackBasePlus1), GIV(bytesPerPage))),
				GIV(pages));
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == theFP) {
				theFPAbove = 0;
				goto l2;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == theFP) {
					theFPAbove = fp;
					goto l2;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
	l2:	/* end findFrameAbove:inPage: */;
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(theFPAbove)));
			theSP = (theFPAbove + (frameStackedReceiverOffset(theFPAbove))) + BytesPerWord;
			/* begin ensureFrameIsMarried:SP: */
			if (			/* begin frameHasContext: */
				((((usqInt)(longAt(theFP + FoxMethod)))) < (startOfMemory())
				? ((longAt(theFP + FoxMethod)) & MFMethodFlagHasContextFlag) != 0
				: (byteAt((theFP + FoxIFrameFlags) + 2)) != 0)) {
				assert(isContext(frameContext(theFP)));
				objOrFP = longAt(theFP + FoxThisContext);
				goto l3;
			}
			objOrFP = marryFrameSP(theFP, theSP);
	l3:	/* end ensureFrameIsMarried:SP: */;
			theStack = GIV(remapBuffer)[GIV(remapBufferCount)];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(theStack)));
			if ((			/* begin isOldObject: */
				assert(isNonImmediate(theStack)),
			oopisGreaterThanOrEqualTo(theStack, GIV(oldSpaceStart)))) {
				/* most stores into young objects */
				if (				/* begin isYoung: */
					((!(objOrFP & (tagMask()))))
				 && (oopisLessThan(objOrFP, GIV(oldSpaceStart)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt)((longAt(theStack)))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(theStack);
					}
				}
			}
			longAtput((theStack + BaseHeaderSize) + (((sqInt)((usqInt)(finger) << (shiftForWord())))), objOrFP);
		}
	}
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
}

	/* StackInterpreterPrimitives>>#unmarkAfterPathTo */
static void
unmarkAfterPathTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt numSlots;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	unmarkAllFrames();
	/* begin unmarkAllObjects */
	obj = 0;
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((longAt(objOop)) & (classIndexMask())) > (lastClassIndexPun())) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop)));
				longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			else {
				if (!(((longAt(objOop)) & (classIndexMask())) == (segmentBridgePun()))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop)));
					longAtput(objOop, (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = 
	/* begin startAddressForBridgedHeapEnumeration */
(GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l4;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {
		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {
			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {
			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	/* begin objectStartingAt: */
	numSlots = byteAt(start + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? start + BaseHeaderSize
		: start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (((((usqInt)((longAt(objOop1)))) >> (markedBitFullShift())) & 1) != 0) {
			if (((longAt(objOop1)) & (classIndexMask())) > (lastClassIndexPun())) {
				/* begin setIsMarkedOf:to: */
				assert(!(isFreeObject(objOop1)));
				longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
			}
			else {
				if (!(((longAt(objOop1)) & (classIndexMask())) == (segmentBridgePun()))) {
					/* begin setIsMarkedOf:to: */
					assert(!(isFreeObject(objOop1)));
					longAtput(objOop1, (longAt(objOop1)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift()))));
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && ((followingWord1 & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l4:	/* end allNewSpaceEntitiesDo: */;
}

/*** Exports ***/

static char _m[] = "";
void* vm_exports[][3] = {
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveAddLargeIntegers\000\000\001", (void*)primitiveAddLargeIntegers},
	{(void*)_m, "primitiveAllInstances\000\000\000", (void*)primitiveAllInstances},
	{(void*)_m, "primitiveAllObjects\000\377\000", (void*)primitiveAllObjects},
#if VMBenchmarks
	{(void*)_m, "primitiveBenchmarkFollowForwardersInStackZone\000\377\000", (void*)primitiveBenchmarkFollowForwardersInStackZone},
#endif /* VMBenchmarks */
#if VMBenchmarks
	{(void*)_m, "primitiveBenchmarkFollowForwardersOfReceiverAndTemporariesInStackZone\000\377\000", (void*)primitiveBenchmarkFollowForwardersOfReceiverAndTemporariesInStackZone},
#endif /* VMBenchmarks */
#if VMBenchmarks
	{(void*)_m, "primitiveBenchmarkJITReceiver\000\000\000", (void*)primitiveBenchmarkJITReceiver},
#endif /* VMBenchmarks */
#if VMBenchmarks
	{(void*)_m, "primitiveBenchmarkScavenge\000\377\000", (void*)primitiveBenchmarkScavenge},
#endif /* VMBenchmarks */
	{(void*)_m, "primitiveBitAndLargeIntegers\000\000\001", (void*)primitiveBitAndLargeIntegers},
	{(void*)_m, "primitiveBitOrLargeIntegers\000\000\001", (void*)primitiveBitOrLargeIntegers},
	{(void*)_m, "primitiveBitShiftLargeIntegers\000\000\001", (void*)primitiveBitShiftLargeIntegers},
	{(void*)_m, "primitiveBitXorLargeIntegers\000\000\001", (void*)primitiveBitXorLargeIntegers},
	{(void*)_m, "primitiveBytecodeSetsAvailable\000\377\000", (void*)primitiveBytecodeSetsAvailable},
	{(void*)_m, "primitiveClockLogAddresses\000\000\000", (void*)primitiveClockLogAddresses},
	{(void*)_m, "primitiveCompareBytes\000\001\001", (void*)primitiveCompareBytes},
	{(void*)_m, "primitiveCompareWith\000\001\000", (void*)primitiveCompareWith},
	{(void*)_m, "primitiveCrashVM\000\000\000", (void*)primitiveCrashVM},
	{(void*)_m, "primitiveDisablePowerManager\000\000\000", (void*)primitiveDisablePowerManager},
	{(void*)_m, "primitiveDivideLargeIntegers\000\000\001", (void*)primitiveDivideLargeIntegers},
	{(void*)_m, "primitiveDivLargeIntegers\000\000\001", (void*)primitiveDivLargeIntegers},
	{(void*)_m, "primitiveEqualLargeIntegers\000\000\001", (void*)primitiveEqualLargeIntegers},
	{(void*)_m, "primitiveEventProcessingControl\000\000\000", (void*)primitiveEventProcessingControl},
	{(void*)_m, "primitiveExternalCallNoOp\000\377\000", (void*)primitiveExternalCallNoOp},
	{(void*)_m, "primitiveFastCNoOp\000\377\001", (void*)primitiveFastCNoOp},
	{(void*)_m, "primitiveFastCNoOpAlignedForFloats\000\377\003", (void*)primitiveFastCNoOpAlignedForFloats},
	{(void*)_m, "primitiveGetenv\000\000\000", (void*)primitiveGetenv},
	{(void*)_m, "primitiveGetLogDirectory\000\377\000", (void*)primitiveGetLogDirectory},
	{(void*)_m, "primitiveGetWindowLabel\000\377\000", (void*)primitiveGetWindowLabel},
	{(void*)_m, "primitiveGetWindowSize\000\377\000", (void*)primitiveGetWindowSize},
	{(void*)_m, "primitiveGreaterOrEqualLargeIntegers\000\000\001", (void*)primitiveGreaterOrEqualLargeIntegers},
	{(void*)_m, "primitiveGreaterThanLargeIntegers\000\000\001", (void*)primitiveGreaterThanLargeIntegers},
	{(void*)_m, "primitiveHeartbeatFrequency\000\000\000", (void*)primitiveHeartbeatFrequency},
	{(void*)_m, "primitiveHighResClock\000\377\001", (void*)primitiveHighResClock},
	{(void*)_m, "primitiveImageFormatVersion\000\377\000", (void*)primitiveImageFormatVersion},
	{(void*)_m, "primitiveInterruptChecksPerMSec\000\377\000", (void*)primitiveInterruptChecksPerMSec},
	{(void*)_m, "primitiveIsBigEnder\000\377\000", (void*)primitiveIsBigEnder},
	{(void*)_m, "primitiveIsWindowObscured\000\377\000", (void*)primitiveIsWindowObscured},
	{(void*)_m, "primitiveLessOrEqualLargeIntegers\000\000\001", (void*)primitiveLessOrEqualLargeIntegers},
	{(void*)_m, "primitiveLessThanLargeIntegers\000\000\001", (void*)primitiveLessThanLargeIntegers},
#if LRPCheck
	{(void*)_m, "primitiveLongRunningPrimitive\000\377\000", (void*)primitiveLongRunningPrimitive},
#endif /* LRPCheck */
#if LRPCheck
	{(void*)_m, "primitiveLongRunningPrimitiveSemaphore\000\000\000", (void*)primitiveLongRunningPrimitiveSemaphore},
#endif /* LRPCheck */
	{(void*)_m, "primitiveMethodPCData\000\000\000", (void*)primitiveMethodPCData},
	{(void*)_m, "primitiveMillisecondClockMask\000\377\000", (void*)primitiveMillisecondClockMask},
	{(void*)_m, "primitiveMinimumUnusedHeadroom\000\377\000", (void*)primitiveMinimumUnusedHeadroom},
	{(void*)_m, "primitiveModLargeIntegers\000\000\001", (void*)primitiveModLargeIntegers},
	{(void*)_m, "primitiveMultipleBytecodeSetsActive\000\000\000", (void*)primitiveMultipleBytecodeSetsActive},
	{(void*)_m, "primitiveMultiplyLargeIntegers\000\000\001", (void*)primitiveMultiplyLargeIntegers},
	{(void*)_m, "primitiveNotEqualLargeIntegers\000\000\001", (void*)primitiveNotEqualLargeIntegers},
	{(void*)_m, "primitivePathToUsing\000\000\000", (void*)primitivePathToUsing},
	{(void*)_m, "primitiveProfilePrimitive\000\377\001", (void*)primitiveProfilePrimitive},
	{(void*)_m, "primitiveProfileSample\000\377\001", (void*)primitiveProfileSample},
	{(void*)_m, "primitiveProfileSemaphore\000\000\014", (void*)primitiveProfileSemaphore},
	{(void*)_m, "primitiveProfileStart\000\000\001", (void*)primitiveProfileStart},
	{(void*)_m, "primitiveQuoLargeIntegers\000\000\001", (void*)primitiveQuoLargeIntegers},
	{(void*)_m, "primitiveRemLargeIntegers\000\000\001", (void*)primitiveRemLargeIntegers},
	{(void*)_m, "primitiveScreenDepth\000\377\000", (void*)primitiveScreenDepth},
	{(void*)_m, "primitiveScreenScaleFactor\000\377\000", (void*)primitiveScreenScaleFactor},
	{(void*)_m, "primitiveSetGCSemaphore\000\000\000", (void*)primitiveSetGCSemaphore},
	{(void*)_m, "primitiveSetLogDirectory\000\001\000", (void*)primitiveSetLogDirectory},
	{(void*)_m, "primitiveSetWindowLabel\000\001\000", (void*)primitiveSetWindowLabel},
	{(void*)_m, "primitiveSetWindowSize\000\000\000", (void*)primitiveSetWindowSize},
	{(void*)_m, "primitiveSubtractLargeIntegers\000\000\001", (void*)primitiveSubtractLargeIntegers},
	{(void*)_m, "primitiveSuspendBackingUpV2\000\002\000", (void*)primitiveSuspendBackingUpV2},
#if TestingPrimitives
	{(void*)_m, "primitiveTestShortenIndexableSize\000\001\000", (void*)primitiveTestShortenIndexableSize},
#endif /* TestingPrimitives */
	{(void*)_m, "primitiveUtcWithOffset\000\001\000", (void*)primitiveUtcWithOffset},
	{(void*)_m, "primitiveVoidReceiver\000\377\000", (void*)primitiveVoidReceiver},
	{NULL, NULL, NULL}
};
