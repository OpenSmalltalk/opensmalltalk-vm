/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-mt.3362 uuid: b8f74e14-6430-924d-93fb-2fc1cd50ba34
   from
	ImageLeakChecker VMMaker.oscog-mt.3362 uuid: b8f74e14-6430-924d-93fb-2fc1cd50ba34
 */
static char __buildInfo[] = "ImageLeakChecker VMMaker.oscog-mt.3362 uuid: b8f74e14-6430-924d-93fb-2fc1cd50ba34 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include "sq.h"
#include <stdio.h> /* for printf */
#include <stdlib.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "sqImageFileAccess.h"
#include "sqSetjmpShim.h"
#include "dispdbg.h"


/* ImageLeakChecker class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
EXPORT(void)
warning(const char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
EXPORT(void)
warningat(const char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline(on)

#define readImageFromFileHeapSizeStartingAt readImageFromFile
#if !defined(PharoVM)
# define PharoVM 0
#endif


void error(const char *msg) {
  warning(msg);
  abort();
}


/* end ImageLeakChecker class>>preambleCCode */


/*** Constants ***/
#define AlternateHeaderHasPrimFlag 0x20000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 245
#define AtCacheTotalSize 64
#define BecameActiveClassFlag 8
#define BecameCompiledMethodFlag 2
#define BecamePointerObjectFlag 1
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassCharacter 19
#define ClassDoubleByteArray 31
#define ClassDoubleWordArray 33
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassString 6
#define ClassUnsafeAlien 54
#define ClassWordArray 32
#define CtxtTempFrameStart 6
#define ExtraRootsSize 64
#define FalseObject 1
#define GCCheckFreeSpace 32
#define GCModeFull 1
#define GCModeNewSpace 2
#define HeaderIndex 0
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LiteralStart 1
#define LongStoreBytecode 129
#define MarkStackRootIndex 0x1000
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntrySize 4
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MournQueueRootIndex 4098
#define MultipleBytecodeSetsBitmask 0x200
#define NilObject 0
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define PrimitiveErrorTableIndex 51
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetRootIndex 4099
#define ScavengeInProgress 1
#define SchedulerAssociation 3
#define SelectorDoesNotUnderstand 20
#define SelectorStart 2
#define StackPointerIndex 2
#define SuperclassIndex 0
#define TheDisplay 14
#define TrueObject 2
#define V3PrimitiveBitsMask 0x200003FE
#define ValidatedClassDoubleByteArrayFlag 1
#define ValidatedClassDoubleWordArrayFlag 4
#define ValidatedClassWordArrayFlag 2
#define ValueIndex 1
#define WeaklingStackRootIndex 0x1001

typedef struct {
	usqInt	sEdenBytes;
	usqInt	sPastBytes;
	usqInt	sRememberedSetSize;
	usqInt	sRememberedSetRedZone;
	usqInt	sRememberedSetLimit;
	usqInt	sStatTenures;
	usqInt	tTenureCriterion;
	usqInt	tTenureThreshold;
	usqInt	tRefCountToShrinkRT;
	usqInt	eSurvivorBytes;
	usqInt	eRememberedSetSize;
	usqInt	eStatTenures;
 } SpurScavengeLogRecord;


typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
	usqInt	savedSegSize;
	usqInt	lastFreeObject;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

static sqInt NoDbgRegParms growOldSpaceByAtLeast(sqInt minAmmount);
static void NoDbgRegParms initializeInterpreter(sqInt bytesToShift);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern int main(int argc, char *argv[]);
extern int plugInNotifyUser(char *msg);
extern void printHex(usqInt n);
static void NoDbgRegParms printNum(sqInt n);
extern void print(char *s);
static sqInt NoDbgRegParms runLeakCheckerForResult(sqInt gcModes);
static char * NoDbgRegParms whereIsMaybeStackThing(sqInt thing);
static sqInt NoDbgRegParms isDirectAlien(sqInt oop);
static sqInt NoDbgRegParms isIndirectAlien(sqInt oop);
static sqInt NoDbgRegParms isPointerAlien(sqInt oop);
static sqInt NoDbgRegParms isPositiveMachineIntegerObject(sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
static usqInt NoDbgRegParms addressAfter(sqInt objOop);
static sqInt NoDbgRegParms allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
static sqInt NoDbgRegParms allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
extern sqInt byteSwapped(sqInt w);
static usqInt NoDbgRegParms bytesInBody(sqInt objOop);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
static sqInt defaultEdenBytes(void);
extern sqInt fetchClassTagOf(sqInt oop);
extern usqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
static void NoDbgRegParms hackSlimBridgeToat(sqInt objOop, sqInt startAddress);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
static sqInt imageFormatVersion(void);
static sqInt NoDbgRegParms initFreeChunkWithBytesat(usqLong numBytes, sqInt address);
static void NoDbgRegParms initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address);
static sqInt NoDbgRegParms integerObjectOf(sqInt value);
static sqInt NoDbgRegParms isImmediateFloat(sqInt oop);
static sqInt NoDbgRegParms isIntegerObject(sqInt oop);
extern sqInt isIntegerValue(sqInt intValue);
static sqInt NoDbgRegParms isLilliputianSize(sqInt chunkBytes);
extern sqInt isMarked(sqInt objOop);
static sqInt NoDbgRegParms isWordsNonImm(sqInt objOop);
static usqInt NoDbgRegParms largeObjectBytesForSlots(sqInt numSlots);
static sqInt NoDbgRegParms lengthOfformat(sqInt objOop, sqInt fmt);
static sqInt maxSlotsForAlloc(void);
static sqInt NoDbgRegParms normalisedFormatForindexableSize(sqInt objOop, sqInt indexableSize);
static sqInt numFreeLists(void);
static sqInt NoDbgRegParms objectAfterMaybeSlimBridgelimit(sqInt objOop, sqInt limit);
static usqInt NoDbgRegParms objectBytesForSlots(sqInt numSlots);
static void NoDbgRegParms setClassIndexOfto(sqInt objOop, sqInt classIndex);
static void NoDbgRegParms setFormatOfto(sqInt objOop, sqInt format);
static void NoDbgRegParms setIsImmutableOfto(sqInt objOop, sqInt aBoolean);
static void NoDbgRegParms setIsMarkedOfto(sqInt objOop, sqInt aBoolean);
static void NoDbgRegParms setIsPinnedOfto(sqInt objOop, sqInt aBoolean);
static void NoDbgRegParms setIsRememberedOfto(sqInt objOop, sqInt aBoolean);
extern usqInt smallObjectBytesForSlots(sqInt numSlots);
static sqInt wordIndexableFormat(void);
static sqInt wordSizeClassIndexPun(void);
static void NoDbgRegParms forgetObject(sqInt objOop);
static void growRememberedSet(void);
static sqInt initFutureSpaceStart(void);
static void initializeRememberedSet(void);
static sqInt NoDbgRegParms isInRememberedSet(sqInt objOop);
static void NoDbgRegParms newSpaceStartnewSpaceBytessurvivorBytes(sqInt startAddress, sqInt totalBytes, sqInt requestedSurvivorBytes);
extern void openScavengeLog(void);
extern void printRememberedSet(void);
extern sqInt remember(sqInt objOop);
static void NoDbgRegParms noteValidHeapExtent(sqInt bytesToShift);
static sqInt NoDbgRegParms swizzleObjin(sqInt objOop, sqInt containerOopOrNil);
static sqInt NoDbgRegParms NeverInline activeAndDeferredScan(sqInt anEphemeron);
static void NoDbgRegParms addFreeSubTree(sqInt freeTree);
extern sqInt addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeObj(sqInt address);
static sqInt NoDbgRegParms addressCouldBeOldObj(sqInt address);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt NoDbgRegParms addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes);
static sqInt NoDbgRegParms addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes);
static void NoDbgRegParms adjustAllOopsBy(sqInt bytesToShift);
static usqInt NoDbgRegParms allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static sqInt NoDbgRegParms allocateOldSpaceChunkOfBytes(usqInt chunkBytes);
extern sqInt allocatePinnedSlots(sqInt nSlots);
static sqInt allocationUnit(void);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms NeverInline assertInnerValidFreeObject(sqInt objOop);
static sqInt NoDbgRegParms becomeEffectFlagsFor(sqInt objOop);
extern void beRootIfOld(sqInt oop);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(void);
static sqInt bridgeSize(void);
static sqInt NoDbgRegParms byteFormatForNumBytes(sqInt numBytes);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern usqInt bytesPerElement(sqInt oop);
extern sqInt characterObjectOf(sqInt characterCode);
static void characterTable(void);
extern usqInt characterValueOf(sqInt oop);
extern sqInt checkedLongAt(sqInt byteAddress);
static void NoDbgRegParms checkFreeSpace(sqInt gcModes);
static sqInt NoDbgRegParms checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid);
extern sqInt checkOkayOop(usqInt oop);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classAtIndex(sqInt classIndex);
static sqInt classBitmap(void);
static sqInt classByteArray(void);
static sqInt classCharacter(void);
static sqInt classDoubleByteArray(void);
static sqInt classDoubleWordArray(void);
static sqInt classExternalAddress(void);
static sqInt classExternalData(void);
static sqInt classExternalFunction(void);
static sqInt classExternalLibrary(void);
static sqInt classExternalStructure(void);
static sqInt classFloat(void);
static sqInt classFloat32Array(void);
static sqInt classFloat64Array(void);
static sqInt NoDbgRegParms classForClassTag(sqInt classIndex);
static sqInt classIndexFieldWidth(void);
extern sqInt classIndexOf(sqInt objOop);
static sqInt classLargeNegativeInteger(void);
static sqInt classLargePositiveInteger(void);
extern sqInt classOrNilAtIndex(sqInt classIndex);
static sqInt classPoint(void);
static sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
static sqInt classString(void);
extern sqInt classTableMinorIndexMask(void);
extern sqInt classTablePageSize(void);
extern sqInt classTableRootObj(void);
static sqInt classTableRootSlots(void);
extern sqInt classTagForClass(sqInt classObj);
static sqInt classUnsafeAlien(void);
static sqInt classWordArray(void);
static void clearLeakMapAndMapAccessibleObjects(void);
static sqInt NoDbgRegParms cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning);
static sqInt NoDbgRegParms cloneObject(sqInt objOop);
static sqInt NoDbgRegParms compactIndexOfClass(sqInt objOop);
static void computeFreeSpacePostSwizzle(void);
extern void countMarkedAndUnmarkdObjects(sqInt printFlags);
static void NoDbgRegParms countNumClassPagesPreSwizzle(sqInt bytesToShift);
static sqInt displayObject(void);
static sqInt NoDbgRegParms doShortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern usqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots);
static void NoDbgRegParms enableObjectEnumerationFrom(sqInt initialObject);
static sqInt NoDbgRegParms ensureRoomOnObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms enterIntoClassTable(sqInt aBehavior);
static sqInt ephemeronFormat(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop);
static sqInt NoDbgRegParms NeverInline fetchClassOfNonImm(sqInt objOop);
static sqInt NoDbgRegParms fetchClassOf(sqInt oop);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt obj);
static sqInt NoDbgRegParms fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqLong NoDbgRegParms fetchLong64ofObject(sqInt longIndex, sqInt objOop);
static sqInt NoDbgRegParms fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop);
static sqInt NoDbgRegParms fetchPointerofMaybeForwardedObject(sqInt fieldIndex, sqInt objOop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop);
static sqInt NoDbgRegParms fetchShort16ofObject(sqInt shortIndex, sqInt objOop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
static void * NoDbgRegParms firstFixedField(sqInt objOop);
static void * NoDbgRegParms firstIndexableField(sqInt objOop);
extern sqInt fixedFieldsOfClassFormatMask(void);
extern sqInt fixedFieldsOfClassFormat(sqInt classFormat);
static sqInt NoDbgRegParms fixedFieldsOfClass(sqInt objOop);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms NeverInline fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue);
static sqInt NoDbgRegParms followFieldofObject(sqInt fieldIndex, sqInt anObject);
static sqInt NoDbgRegParms followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth);
extern sqInt followForwarded(sqInt objOop);
static sqInt NoDbgRegParms followMaybeForwarded(sqInt objOop);
static void followSpecialObjectsOop(void);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOf(sqInt objOop);
static sqInt forwardedFormat(void);
static void NoDbgRegParms forwardto(sqInt obj1, sqInt obj2);
static sqInt freeChunkLargerIndex(void);
static sqInt freeChunkNextIndex(void);
static sqInt freeChunkParentIndex(void);
static sqInt freeChunkPrevIndex(void);
static sqInt freeChunkSmallerIndex(void);
static sqInt NoDbgRegParms freeChunkWithBytesat(sqInt bytes, sqInt address);
extern sqInt freeObject(sqInt objOop);
static sqInt NoDbgRegParms hasOverflowHeader(sqInt objOop);
extern usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static sqInt hiddenRootSlots(void);
static sqInt identityHashFieldWidth(void);
#if IMMUTABILITY
extern sqInt immutableBitMask(void);
#endif /* IMMUTABILITY */
static void incrementalGC(void);
static void NoDbgRegParms inFreeTreeReplacewith(sqInt treeNode, sqInt newNode);
static void NoDbgRegParms initFreeTreeChunkbytes(sqInt freeChunk, sqInt chunkBytes);
static void NoDbgRegParms initializeFreeSpacePostLoad(sqInt freeListObj);
static void NeverInline initializeNewSpaceVariables(void);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
static void NoDbgRegParms initializeOldSpaceFirstFree(usqInt startOfFreeOldSpace);
extern void inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instSpecOfClassFormat(sqInt classFormat);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
static void NoDbgRegParms invalidCompactClassError(const char *className);
static sqInt NoDbgRegParms isAnyPointerFormat(sqInt format);
static sqInt NoDbgRegParms isArrayNonImm(sqInt oop);
static sqInt NoDbgRegParms isArray(sqInt oop);
static sqInt NoDbgRegParms isBytesNonImm(sqInt objOop);
static sqInt NoDbgRegParms isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
extern sqInt isCompiledMethod(sqInt objOop);
static sqInt NoDbgRegParms isEmptyObjStack(sqInt objStack);
static sqInt NoDbgRegParms isEnumerableObject(sqInt objOop);
static sqInt NoDbgRegParms isEphemeron(sqInt objOop);
extern sqInt isFixedSizePointerFormat(sqInt format);
extern sqInt isForwarded(sqInt objOop);
static sqInt NoDbgRegParms isFreeObject(sqInt objOop);
static sqInt NoDbgRegParms isFreeOop(sqInt oop);
static sqInt NoDbgRegParms isGrey(sqInt objOop);
static sqInt NoDbgRegParms isHiddenObj(sqInt objOop);
extern sqInt isImmediate(sqInt oop);
static sqInt NoDbgRegParms isImmutable(sqInt objOop);
static sqInt NoDbgRegParms isIndexableFormat(sqInt format);
static sqInt NoDbgRegParms isIndexable(sqInt objOop);
static sqInt NoDbgRegParms isInEden(sqInt objOop);
static sqInt NoDbgRegParms isInFutureSpace(sqInt address);
static sqInt NoDbgRegParms isInHeapBounds(sqInt address);
static sqInt NoDbgRegParms isInMemory(sqInt address);
static sqInt NoDbgRegParms isInNewSpace(sqInt objOop);
extern sqInt isInOldSpace(sqInt address);
static sqInt NoDbgRegParms isInPastSpace(sqInt address);
static sqInt NoDbgRegParms isInRangeCharacterCode(sqInt characterCode);
static sqInt NoDbgRegParms isInstanceOfClassLargeNegativeInteger(sqInt oop);
static sqInt NoDbgRegParms isInstanceOfClassLargePositiveInteger(sqInt oop);
static sqInt NoDbgRegParms isLargeFreeObject(sqInt objOop);
static sqInt NoDbgRegParms isLargeIntegerInstance(sqInt oop);
static sqInt NoDbgRegParms isLong64sNonImm(sqInt objOop);
extern sqInt isLong64s(sqInt oop);
extern sqInt isNonImmediate(sqInt oop);
static sqInt NoDbgRegParms isObjEphemeron(sqInt objOop);
static sqInt NoDbgRegParms isOldObject(sqInt objOop);
extern sqInt isOopCompiledMethod(sqInt oop);
extern sqInt isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt oop);
extern sqInt isOopMutable(sqInt oop);
extern sqInt isPinned(sqInt objOop);
static sqInt NoDbgRegParms isPointersFormat(sqInt format);
static sqInt NoDbgRegParms isPointersNonImm(sqInt objOop);
static sqInt NoDbgRegParms isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
extern sqInt isReallyYoungObject(sqInt obj);
static sqInt NoDbgRegParms isReallyYoung(sqInt oop);
static sqInt NoDbgRegParms isRemembered(sqInt objOop);
static sqInt NoDbgRegParms isSegmentBridge(sqInt objOop);
static sqInt NoDbgRegParms isShortsNonImm(sqInt objOop);
extern sqInt isShorts(sqInt oop);
static sqInt NoDbgRegParms isUnambiguouslyForwarder(sqInt objOop);
extern sqInt isUnmarked(sqInt objOop);
extern sqInt isValidClassTag(sqInt classIndex);
static sqInt NoDbgRegParms isValidObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx);
static sqInt NoDbgRegParms isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage);
static sqInt NoDbgRegParms isValidObjStack(sqInt objStack);
static sqInt NoDbgRegParms isWeakNonImm(sqInt objOop);
static sqInt NoDbgRegParms isWeak(sqInt oop);
static sqInt NoDbgRegParms isWordsOrBytesNonImm(sqInt objOop);
static sqInt NoDbgRegParms isWordsOrBytes(sqInt oop);
static sqInt NoDbgRegParms isWordsOrShortsNonImm(sqInt objOop);
extern sqInt isWordsOrShorts(sqInt oop);
static sqInt NoDbgRegParms isWords(sqInt oop);
extern sqInt isYoungObject(sqInt objOop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms keyOfEphemeron(sqInt objOop);
static sqInt NoDbgRegParms knownClassAtIndex(sqInt classIndex);
static sqInt lastPointerFormat(void);
static sqInt NoDbgRegParms lastPointerOfWhileSwizzling(sqInt objOop);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckNewSpaceGC(void);
static sqInt NoDbgRegParms lengthOf(sqInt objOop);
extern sqInt literalCountOfMethodHeader(sqInt header);
extern sqInt literalCountOf(sqInt methodPointer);
extern void longPrintInstancesOf(sqInt aClassOop);
extern void longPrintInstancesWithClassIndex(sqInt classIndex);
extern void longPrintReferencesTo(sqInt anOop);
static void NoDbgRegParms markAndTraceClassOf(sqInt objOop);
extern void NeverInline markAndTrace(sqInt objOop);
extern sqInt maxSlotsForNewSpaceAlloc(void);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj);
extern sqInt minSlotsForShortening(void);
static sqInt newSpaceIsEmpty(void);
static sqInt newSpaceRefCountMask(void);
extern sqInt nilObject(void);
static sqInt NoDbgRegParms noCheckClassAtIndex(sqInt classIndex);
static sqInt NoDbgRegParms noCheckPushonObjStack(sqInt objOop, sqInt objStack);
static sqInt NoDbgRegParms noInlineFollowForwarded(sqInt objOop);
static sqInt NoDbgRegParms noInlineObjectAfterlimit(sqInt objOop, sqInt limit);
extern sqInt nonIndexablePointerFormat(void);
static sqInt NoDbgRegParms numBytesOfBitsformat(sqInt objOop, sqInt format);
static sqInt NoDbgRegParms numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
static usqInt NoDbgRegParms numPointerSlotsOf(sqInt objOop);
static sqInt NoDbgRegParms numSlotsForBytes(sqInt numBytes);
static usqInt NoDbgRegParms numSlotsOfAny(sqInt objOop);
extern usqInt numSlotsOf(sqInt objOop);
static sqInt NoDbgRegParms numStrongSlotsOfInephemeral(sqInt objOop);
extern sqInt objectAfter(sqInt objOop);
extern sqInt objectBefore(sqInt objOop);
static sqInt NoDbgRegParms objectInPastSpaceBefore(sqInt objOop);
static sqInt NoDbgRegParms objectStartingAt(sqInt address);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
extern sqInt oldSpaceObjectAfter(sqInt objOop);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms popObjStack(sqInt objStack);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms postBecomeScanClassTable(sqInt effectsFlags);
extern sqInt primitiveErrorTable(void);
extern void printActivationsOf(sqInt aMethodObj);
extern void printBogons(void);
static void NoDbgRegParms printBridgeon(sqInt oop, FILE *aStream);
static void NoDbgRegParms printCantBeObjecton(sqInt oop, FILE *aStream);
extern void printContextReferencesTo(sqInt anOop);
extern void printEntity(sqInt oop);
extern void printForwarders(void);
static void NoDbgRegParms printForwarderon(sqInt oop, FILE *aStream);
extern void printFreeChunks(void);
extern void printFreeChunk(sqInt freeChunk);
static void NoDbgRegParms printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode);
extern void printFreeListHeads(void);
extern sqInt printFreeList(sqInt chunkOrIndex);
static void NoDbgRegParms printFreeObjecton(sqInt oop, FILE *aStream);
extern void printFreeTree(void);
static void NoDbgRegParms printFreeTreeChunk(sqInt chunkOrZero);
extern void printHeaderOf(sqInt objOop);
static void NoDbgRegParms printImmediateObjecton(sqInt oop, FILE *aStream);
extern void printInstancesOf(sqInt aClassOop);
extern void printInstancesWithClassIndex(sqInt classIndex);
extern void printInvalidClassTableEntries(void);
#if LLDB
extern void printMarkedOops(void);
#endif /* LLDB */
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
static void NoDbgRegParms printNonPointerDataOfon(sqInt oop, FILE *aStream);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printObjectsWithHash(sqInt hash);
extern void printObjStackAndContents(sqInt objStack);
static void NoDbgRegParms printObjStackPagemyIndexpageTypeprintContents(sqInt objStackPage, sqInt myx, sqInt pageType, sqInt printContents);
static void NoDbgRegParms printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType);
extern void printObjStack(sqInt objStack);
extern void NeverInline printOopsExcept(sqInt (*function)(sqInt));
extern void printOopsFromto(sqInt startAddress, sqInt endAddress);
extern void NeverInline printOopsSuchThat(sqInt (*function)(sqInt));
extern void printReferencesTo(sqInt anOop);
static void NoDbgRegParms printStringDataOfon(sqInt oop, FILE *aStream);
#if LLDB
extern void printUnmarkedOops(void);
#endif /* LLDB */
static sqInt NoDbgRegParms pushOnUnscannedEphemeronsStack(sqInt anEphemeron);
extern void pushRemappableOop(sqInt oop);
extern sqInt rawHashBitsOf(sqInt objOop);
static void NoDbgRegParms rememberedSetObj(sqInt anObj);
extern sqInt removeGCRoot(sqInt *varLoc);
static void NoDbgRegParms reverseBytesFromto(sqInt startAddr, sqInt stopAddr);
static void reverseBytesInMemory(void);
static usqInt NoDbgRegParms roundUpHeapSize(usqInt heapSize);
static sqInt scavengeInProgress(void);
static sqInt scavengerDenominator(void);
static void NoDbgRegParms setHashBitsOfto(sqInt objOop, sqInt hash);
static sqInt NoDbgRegParms NeverInline setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd);
static void NoDbgRegParms setHiddenRootsObj(sqInt anOop);
static void NoDbgRegParms setNextFreeChunkOfwithValuechunkBytes(sqInt freeChunk, sqInt nextFreeChunk, sqInt chunkBytes);
extern sqInt shortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress);
extern sqInt shouldRemapOop(sqInt oop);
static usqInt NoDbgRegParms sizeBitsOf(sqInt objOop);
static sqInt NoDbgRegParms slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
static usqInt NoDbgRegParms startOfObject(sqInt objOop);
extern sqInt statNumGCs(void);
extern usqInt storeCheckBoundary(void);
extern sqInt storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt obj, sqInt valueWord);
static sqInt NoDbgRegParms storePointerNoAssertofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
static sqInt NoDbgRegParms storePointerofForwarderwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
static sqInt NoDbgRegParms storePointerofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
static sqInt NoDbgRegParms storePointerofObjStackwithValue(sqInt fieldIndex, sqInt objStackPage, sqInt thang);
extern sqInt stringForCString(const char *aCString);
static sqInt NoDbgRegParms swizzleObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms topOfObjStack(sqInt objStack);
extern sqInt topRemappableOop(void);
static sqInt totalFreeListBytes(void);
static sqInt traceImmediatelySlotLimit(void);
extern sqInt trueObject(void);
static sqInt NoDbgRegParms unlinkFreeChunkatIndexchunkBytes(sqInt chunk, sqInt index, sqInt chunkBytes);
static sqInt NoDbgRegParms unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes);
static sqInt NoDbgRegParms NeverInline unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index);
static void NoDbgRegParms unlinkSolitaryFreeTreeNode(sqInt freeTreeNode);
extern sqInt unpinObject(sqInt objOop);
static void updateFreeLists(void);
static void NoDbgRegParms updateListStartingAt(sqInt freeNode);
static sqInt NoDbgRegParms updateRootOfObjStackAtwith(sqInt objStackRootIndex, sqInt newRootPage);
static sqInt validClassTableRootPages(void);
extern sqInt validFreeTree(void);
static const char * NoDbgRegParms validFreeTreeChunkparent(sqInt chunk, sqInt parent);
static sqInt validObjStacks(void);
extern sqInt vmEndianness(void);
static char * NoDbgRegParms whereIsMaybeHeapThing(sqInt anOop);
extern sqInt shouldRemapObj(sqInt objOop);
static usqInt NoDbgRegParms segLimit(SpurSegmentInfo * self_in_segLimit);
static void NoDbgRegParms adjustSegmentSwizzlesBy(sqInt firstSegmentShift);
static void allocateOrExtendSegmentInfos(void);
static sqInt NoDbgRegParms bridgeAt(sqInt segIndex);
static sqInt NoDbgRegParms bridgeFor(SpurSegmentInfo *aSegment);
static void checkSegments(void);
static void collapseSegmentsPostSwizzle(void);
static void computeTotalHeapSizeIncludingBridges(void);
static sqInt NoDbgRegParms isInSegments(usqInt address);
static sqInt NoDbgRegParms isValidSegmentBridge(sqInt objOop);
static SpurSegmentInfo lastSegment(void);
static sqInt NoDbgRegParms readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes);
extern SpurSegmentInfo * segmentContainingObj(sqInt objOop);
static sqInt someSegmentContainsPinned(void);
static sqInt NoDbgRegParms swizzleObj(sqInt objOop);
static usqInt totalBytesInSegments(void);
static sqInt totalOldSpaceCapacity(void);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
static sqInt NoDbgRegParms bailOutOfImageLoad(sqInt rawVersion);
static void checkAssumedCompactClasses(void);
extern sqInt checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize);
static sqInt NoDbgRegParms checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr);
static sqInt convertFloatsToPlatformOrder(void);
extern void dumpPrimTraceLog(void);
extern void NeverInline eekcr(void);
static sqInt elementsPerPrintOopLine(void);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms firstBytecodeOfAlternateHeadermethod(sqInt methodHeader, sqInt theMethod);
extern void flush(void);
static sqInt NoDbgRegParms followLiteralofMethod(sqInt offset, sqInt methodPointer);
static sqInt NoDbgRegParms getLongFromFileswap(sqImageFile aFile, sqInt swapFlag);
static sqInt NoDbgRegParms getShortFromFileswap(sqImageFile aFile, sqInt swapFlag);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
extern sqInt highBit(usqInt anUnsignedValue);
static sqInt imageFormatCompatibilityVersion(void);
static sqInt NoDbgRegParms imageFormatVersionFromSnapshot(sqInt imageVersion);
static sqInt NoDbgRegParms includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static void initializeExtraClassInstVarIndices(void);
static sqInt NoDbgRegParms isBooleanObject(sqInt oop);
extern sqInt isFloatObject(sqInt oop);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
extern sqInt maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
static sqInt NoDbgRegParms methodHeaderHasPrimitive(sqInt methodHeader);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static char * NoDbgRegParms nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr);
extern sqInt objCouldBeClassObj(sqInt objOop);
static sqInt NoDbgRegParms objectequalsString(sqInt anOop, char *aCString);
static sqInt NoDbgRegParms objectequalsStringofSize(sqInt anOop, char *aCString, sqInt aCStringStrlen);
static sqInt NoDbgRegParms penultimateLiteralOf(sqInt aMethodOop);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printDecodeMethodHeaderOop(sqInt methodHeaderOop);
static sqInt NoDbgRegParms printHexnpnp(usqInt n);
static sqInt NoDbgRegParms printHexnp(usqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printOopShortInner(sqInt oop);
extern void printOop(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern sqInt readableFormat(sqInt imageVersion);
static size_t NoDbgRegParms readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
static void reverseBytesInImage(void);
static void NoDbgRegParms setImageHeaderFlagsFrom(sqInt headerFlags);
static void NoDbgRegParms shortPrintOop(sqInt oop);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
static sqInt NoDbgRegParms superclassOf(sqInt classPointer);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static void updateObjectsPostByteSwap(void);
extern char * whereIs(sqInt anOop);
static char * NoDbgRegParms stretchcat(char *s1, char *s2);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss usqInt freeStart;
_iss usqInt pastSpaceStart;
_iss usqInt endOfMemory;
_iss sqInt nilObj;
_iss usqInt oldSpaceStart;
_iss FILE * transcript;
_iss sqInt specialObjectsOop;
_iss sqInt * freeLists;
_iss usqInt freeListsMask;
_iss sqInt markStack;
_iss sqInt hiddenRootsObj;
_iss SpurSegmentInfo * segments;
_iss sqInt numSegments;
_iss sqInt numClassTablePages;
_iss usqInt totalFreeOldSpace;
_iss sqInt classTableIndex;
_iss sqInt rememberedSetSize;
_iss sqInt weaklingStack;
_iss char * objStackInvalidBecause;
_iss sqInt invalidObjStackPage;
_iss sqInt classNameIndex;
_iss sqInt * rememberedSet;
_iss sqInt remapBufferCount;
_iss sqInt validatedIntegerClassFlags;
_iss sqInt extraRootCount;
_iss sqInt primFailCode;
_iss sqInt thisClassIndex;
_iss sqInt metaclassNumSlots;
_iss usqInt newSpaceStart;
_iss sqInt numSegInfos;
_iss sqInt classTableFirstPage;
_iss sqInt mournQueue;
_iss sqInt verbose;
_iss sqInt falseObj;
_iss sqInt rememberedSetLimit;
_iss usqInt scavengeThreshold;
_iss sqInt trueObj;
_iss sqInt edenBytes;
_iss usqInt freeOldSpaceStart;
_iss sqInt needGCFlag;
_iss sqInt firstSegmentSize;
_iss usqInt totalHeapSizeIncludingBridges;
_iss sqInt becomeEffectsFlags;
_iss sqInt canSwizzle;
_iss sqInt futureSurvivorStart;
_iss sqInt imageFloatsBigEndian;
_iss sqInt marking;
_iss sqInt rememberedSetRedZone;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt detectedInvalidOop;
_iss sqInt gcPhaseInProgress;
_iss sqInt globalSessionID;
_iss sqInt growHeadroom;
_iss sqInt oldHeapBase;
_iss sqInt oldHeapLimit;
_iss char * stackLimit;
_iss sqInt subsequentReport;
_iss sqInt biasForGC;
_iss sqInt fullScreenFlag;
_iss sqInt newFinalization;
_iss sqInt statFullGCs;
_iss sqInt statIncrGCs;
_iss sqInt statScavenges;
_iss sqInt theUnknownShort;
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt argumentCount;
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt bytecodeSetSelector;
_iss sqInt classLinkedListClassTag;
_iss sqInt currentBytecode;
_iss sqInt ephemeronList;
_iss usqInt exceptionPC;
_iss sqInt extA;
_iss sqInt extB;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt extraFramesToMoveOnOverflow;
_iss void * ffiCalloutVMHandle;
_iss sqInt firstFieldOfRememberedSet;
_iss usqInt firstFreeObject;
_iss usqInt firstMobileObject;
_iss char * framePointer;
_iss sqInt freeSpaceCheckOopToIgnore;
_iss sqInt gcSemaphoreIndex;
_iss usqInt heapSizeAtPreviousGC;
_iss sqInt highestRunnableProcessPriority;
_iss sqInt imageHeaderFlags;
_iss usqInt instructionPointer;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqInt lastHash;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt lkupClass;
_iss sqInt lkupClassTag;
_iss char * localFP;
_iss char * localIP;
_iss sqInt localReturnValue;
_iss char * localSP;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckMethod;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSemaphore;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveSignalUndelivered;
#endif
_iss usqInt lowSpaceThreshold;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt messageSelector;
_iss sqInt metaAccessorDepth;
_iss usqInt method;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt multipleBytecodeSetsActive;
_iss usqInt newMethod;
_iss sqInt numExtB;
_iss sqInt numRememberedEphemerons;
_iss sqInt numStackPages;
_iss usqInt objectAfterLastMobileObject;
_iss StackPage * overflowedPage;
_iss sqInt pendingFinalizationSignals;
_iss sqInt preemptionYields;
_iss sqInt previousRememberedSetSize;
_iss sqInt profileMethod;
_iss sqInt profileProcess;
_iss sqInt profileSemaphore;
_iss sqInt refCountToShrinkRT;
_iss sqInt savedFirstFieldsSpaceNotInOldSpace;
_iss sqInt savedWindowSize;
_iss FILE * scavengeLog;
_iss sqInt shrinkThreshold;
_iss sqInt signalLowSpace;
_iss StackPage * stackPage;
_iss char * stackPointer;
_iss sqInt statCoalesces;
_iss sqInt statCompactPassCount;
_iss sqInt statGrowMemory;
_iss sqInt statMarkCount;
_iss sqInt statMaxAllocSegmentTime;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statRootTableCount;
_iss sqInt statRootTableOverflows;
_iss sqInt statShrinkMemory;
_iss sqInt statSurvivorCount;
_iss sqInt statTenures;
_iss sqInt tempOop;
_iss sqInt tempOop2;
_iss sqInt tenureCriterion;
_iss sqInt tenureThreshold;
_iss sqInt tenuringClassIndex;
_iss sqInt the2ndUnknownShort;
_iss sqInt weakList;
_iss usqLong byteCount;
_iss usqLong compactionStartUsecs;
_iss usqLong gcMarkEndUsecs;
_iss usqLong gcStartUsecs;
_iss usqLong gcSweepEndUsecs;
#if LRPCheck
_iss usqLong longRunningPrimitiveGCUsecs;
#endif
#if LRPCheck
_iss usqLong longRunningPrimitiveStartUsecs;
#endif
#if LRPCheck
_iss usqLong longRunningPrimitiveStopUsecs;
#endif
_iss usqLong nextPollUsecs;
_iss sqLong nextProfileTick;
_iss usqLong nextWakeupUsecs;
_iss sqLong oldSpaceUsePriorToScavenge;
_iss sqLong secondaryErrorCode;
_iss usqLong statAllocatedBytes;
_iss usqLong statCheckForEvents;
_iss usqLong statCompactionUsecs;
_iss usqLong statFGCDeltaUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss usqLong statGCEndUsecs;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIOProcessEvents;
_iss usqLong statIdleUsecs;
_iss usqLong statIncrGCUsecs;
_iss usqLong statMarkUsecs;
_iss usqLong statProcessSwitch;
_iss usqLong statSGCDeltaUsecs;
_iss usqLong statScavengeGCUsecs;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss usqLong statSweepUsecs;
_iss SpurNewSpaceSpace eden;
_iss SpurNewSpaceSpace futureSpace;
_iss SpurNewSpaceSpace pastSpace;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss float heapGrowthToSizeGCRatio;
_iss jmp_buf reenterInterpreter;
_iss SpurContiguousObjStack savedFirstFieldsSpace;
_iss SpurScavengeLogRecord scavengeLogRecord;
_iss double tenuringProportion;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
# if SQ_USE_GLOBAL_STRUCT_REG
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# else
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
# endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
# if SQ_USE_GLOBAL_STRUCT_REG
#	define fooxstr(s) foostr(s)
#	define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
# else
static struct foo * foo = &fum;
# endif
#endif
static void *primitiveCalloutPointer = (void *)-1;
static void (*interruptCheckChain)(void) = 0;
static void (*primitiveFunctionPointer)();
static int (*sHEAFn)() = 0;
sqInt checkForLeaks;
sqInt primitiveDoMixedArithmetic = -1;
sqInt upscaleDisplayIfHighDPI = -1;
usqInt maxOldSpaceSize;
sqInt sendWheelEvents;
sqInt breakLookupClassTag;
char * breakSelector;
sqInt breakSelectorLength = MinSmallInteger;
sqInt cannotDeferDisplayUpdates;
sqInt checkedPluginName;
sqInt debugCallbackInvokes;
sqInt debugCallbackPath;
sqInt debugCallbackReturns;
sqInt deferDisplayUpdates;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
void * displayBits;
int displayDepth;
int displayHeight;
int displayWidth;
sqInt eventTraceMask;
sqInt extraVMMemory;
sqInt ffiExceptionResponse;
sqInt inIOProcessEvents;
struct VirtualMachine* interpreterProxy;
const char *interpreterVersion = "Open Smalltalk ImageChecker VM [ImageLeakChecker VMMaker.oscog-mt.3362]";
sqInt suppressHeartbeatFlag;
char expensiveAsserts = 0;
volatile int sendTrace;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);


/*** Macros ***/
#define cr() fputc('\n',transcript)
#define numTagBits() 2
#define shiftForWord() 2
#define tagMask() 0x3
#define wordSize() 4
#define eden() GIV(eden)
#define futureSpace() GIV(futureSpace)
#define futureSurvivorStart() GIV(futureSurvivorStart)
#define pastSpace() GIV(pastSpace)
#define rememberedSetLimit() GIV(rememberedSetLimit)
#define rememberedSetSize() GIV(rememberedSetSize)
#define arrayClassIndexPun() 16
#define characterTag() 2
#define classIndexMask() 0x3FFFFF
#define classIsItselfClassIndexPun() 31
#define classTableFirstPage() classTableFirstPage
#define classTableMajorIndexShift() 10
#define endOfMemory() GIV(endOfMemory)
#define extraAlignedBitShift() 24
#define firstByteFormat() 16
#define firstClassIndexPun() 16
#define firstCompiledMethodFormat() 24
#define firstLongFormat() 10
#define firstShortFormat() 12
#define fixedFieldsFieldWidth() 16
#define formatFieldWidthShift() 5
#define formatMask() 0x1F
#define formatShift() 24
#define freeStart() GIV(freeStart)
#define greyBitShift() 31
#define identityHashFullWordShift() 32
#define identityHashHalfWordMask() 0x3FFFFF
#define immutableBitShift() 23
#define indexablePointersFormat() 3
#define isForwardedObjectClassIndexPun() 8
#define isFreeObjectClassIndexPun() 0
#define lastClassIndexPun() 31
#define markedBitFullShift() 55
#define markedBitHalfShift() 23
#define maxOldSpaceSize() maxOldSpaceSize
#define numSlotsFullShift() 56
#define numSlotsHalfShift() 24
#define numSlotsMask() 0xFF
#define oldSpaceStart() GIV(oldSpaceStart)
#define pastSpaceStart() GIV(pastSpaceStart)
#define pinnedBitShift() 30
#define remapBufferCount() GIV(remapBufferCount)
#define rememberedBitShift() 29
#define rootTableCapacity() GIV(rememberedSetLimit)
#define rootTableCount() GIV(rememberedSetSize)
#define segmentBridgePun() 3
#define sixtyFourBitIndexableFormat() 9
#define sixtyFourBitLongsClassIndexPun() 19
#define smallIntegerTag() 1
#define startOfMemory() GIV(memory)
#define thirtyTwoBitLongsClassIndexPun() 18
#define weakArrayClassIndexPun() 17
#define weakArrayFormat() 4
#define numSegments() GIV(numSegments)
#define segments() GIV(segments)
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define printChar(aCharacter) fputc(aCharacter,transcript)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


	/* ImageLeakChecker>>#growOldSpaceByAtLeast: */
static sqInt NoDbgRegParms
growOldSpaceByAtLeast(sqInt minAmmount)
{
	error("growOldSpaceByAtLeast: was invoked; should not happen!");
	return 0;
}


/*	Initialize Interpreter state before starting execution of a new image.
	N.B. do *NOT* initialize variables that can be initialized via command
	line arguments since command line arguments are proicessed before the
	image is loaded and this initialization takes place after the image is
	loaded. Anything that us not initialized to either 0 or false (the C
	default value)
	should be initialized in StackInterpeeter class>>declareCVarsIn: */

	/* ImageLeakChecker>>#initializeInterpreter: */
static void NoDbgRegParms
initializeInterpreter(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	noteValidHeapExtent(bytesToShift);
	/* begin sqGetInterpreterProxy */
	interpreterProxy = null;
	initializeObjectMemory(bytesToShift);
	checkAssumedCompactClasses();
	initializeExtraClassInstVarIndices();
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));

	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = ((time(NULL)) + 1 /* ioMSecs */) & 0x7FFFFFFF;
	}
	GIV(metaAccessorDepth) = -2;
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin");
}

	/* ImageLeakChecker>>#ioLoadFunction:From: */
void *
ioLoadFunctionFrom(char *functionName, char *moduleName)
{
	return null;
}

	/* ImageLeakChecker>>#main:_: */
int
main(int argc, char *argv[])
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argi;
    sqInt forVersion;
    FILE *ifh;
    sqInt ok;
    int okSwizzle;

	argi = 1;
	forVersion = 0;
	while ((argi < argc)
	 && (((argv[argi])[0]) == '-')) {
		if ((strcmp((PharoVM
			? "--" "version"
			: "-" "version"), argv[argi])) == 0) {
			printf("%s\n", interpreterVersion);
			forVersion = 1;
		}
		if ((strcmp((PharoVM
			? "--" "verbose"
			: "-" "verbose"), argv[argi])) == 0) {
			GIV(verbose) = 1;
		}
		argi += 1;
	}
	if ((argc == argi)
	 && (forVersion)) {
		return 0;
	}
	if ((argc != (argi + 1))
	 || (((ifh = sqImageFileOpen(argv[argi], "rb"))) == 0)) {
		printf("Usage: %s [%s] [%s] imageFileName\n", argv[0],
				(PharoVM
			? "--" "verbose"
			: "-" "verbose"),
				(PharoVM
			? "--" "version"
			: "-" "version"));
		return 1;
	}
	readImageFromFileHeapSizeStartingAt(ifh, 0, 0);
	sqImageFileClose(ifh);
	okSwizzle = !GIV(detectedInvalidOop);
	ok = runLeakCheckerForResult(GCModeFull);
	if (GIV(verbose)
	 && (okSwizzle
	 && (ok))) {
		printf("Image %s is free of leaks\n", argv[argi]);
	}
	return (ok
		? 0
		: 2);
}


/*	This is used in macros in some sqPlatformSpecific.h, sigh... */

	/* ImageLeakChecker>>#plugInNotifyUser: */
int
plugInNotifyUser(char *msg)
{
	error(msg);
	return 0;
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles). In the simulator use 16r as the prefix, padding to 11 characters
	in 32-bits
	or 19 characters in 64-bits. */

	/* ImageLeakChecker>>#printHex: */
void
printHex(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(verbose)) {
		fprintf(GIV(transcript),
				"%10p",
				((void *)n));
	}
}

	/* ImageLeakChecker>>#printNum: */
static void NoDbgRegParms
printNum(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(verbose)) {
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
	}
}

	/* ImageLeakChecker>>#print: */
void
print(char *s)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(verbose)) {
		fprintf(GIV(transcript),
				"%s",
				s);
	}
}

	/* ImageLeakChecker>>#runLeakCheckerForResult: */
static sqInt NoDbgRegParms
runLeakCheckerForResult(sqInt gcModes)
{
	clearLeakMapAndMapAccessibleObjects();
	return checkHeapIntegrityclassIndicesShouldBeValid(0, 1);
}

	/* ImageLeakChecker>>#whereIsMaybeStackThing: */
static char * NoDbgRegParms
whereIsMaybeStackThing(sqInt thing)
{
	return null;
}

	/* InterpreterPrimitives>>#isDirectAlien: */
static sqInt NoDbgRegParms
isDirectAlien(sqInt oop)
{
	return (longAt(oop + BaseHeaderSize)) > 0;
}

	/* InterpreterPrimitives>>#isIndirectAlien: */
static sqInt NoDbgRegParms
isIndirectAlien(sqInt oop)
{
	return (longAt(oop + BaseHeaderSize)) < 0;
}

	/* InterpreterPrimitives>>#isPointerAlien: */
static sqInt NoDbgRegParms
isPointerAlien(sqInt oop)
{
	return (longAt(oop + BaseHeaderSize)) == 0;
}


/*	Answer if oop is a value of an integer in address range, i.e up to the
	size of a machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

	/* InterpreterPrimitives>>#isPositiveMachineIntegerObject: */
static sqInt NoDbgRegParms
isPositiveMachineIntegerObject(sqInt oop)
{
    sqInt ccIndex;
    sqInt ok;

	if ((oop & 1)) {
		return ((oop >> 1)) >= 0;
	}
	if (isImmediate(oop)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = classIndexOf(oop);
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	return ok
	 && ((numBytesOfBytes(oop)) <= (sizeof(usqIntptr_t)));
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return SQABS((longAt(oop + BaseHeaderSize)));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop))))) {
		/* begin primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) ((isDirectAlien(oop)
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Answer the address immediately following an object. */

	/* Spur32BitMemoryManager>>#addressAfter: */
static usqInt NoDbgRegParms
addressAfter(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	if (numSlots == 0) {
		return (objOop + (allocationUnit())) + BaseHeaderSize;
	}
	if (numSlots == (numSlotsMask())) {
		numSlots = longAt(objOop - BaseHeaderSize);
	}
	return (objOop + BaseHeaderSize) + (((numSlots + (numSlots & 1)) << (shiftForWord())));
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. Try
	and allocate in a segment that already includes pinned objects. The header
	of the
	result will have been filled-in but not the contents. */

	/* Spur32BitMemoryManager>>#allocateSlotsForPinningInOldSpace:bytes:format:classIndex: */
static sqInt NoDbgRegParms
allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt acceptedChunk;
    sqInt acceptedNode;
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt next1;
    sqInt next2;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    sqInt node;
    sqInt prev;

	/* begin allocateOldSpaceChunkOfBytes:suchThat: */

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= totalBytes;
	initialIndex = totalBytes / (allocationUnit());
	if ((initialIndex < (numFreeLists()))
	 && ((1U << initialIndex) <= GIV(freeListsMask))) {
		if (((GIV(freeListsMask) & (1U << initialIndex)) != 0)) {
			if (((node = GIV(freeLists)[initialIndex])) == 0) {
				GIV(freeListsMask) -= 1U << initialIndex;
			}
			else {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node));
					next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
					if (((segmentContainingObj(node))->containsPinned)) {
						if (prev == 0) {
							unlinkFreeChunkatIndexchunkBytes(node, initialIndex, totalBytes);
						}
						else {
							setNextFreeChunkOfwithValuechunkBytes(prev, next, totalBytes);
						}
						chunk = node;
						goto l3;
					}
					prev = node;
					node = next;
				}
			}
		}
		index = initialIndex;
		while ((((index += initialIndex)) < (numFreeLists()))
		 && ((1U << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1U << index)) != 0)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1U << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));
						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node));
						next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev == 0) {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInBody(node)) == (index * (allocationUnit())))
								 && ((index > 1)
								 && ((startOfObject(node)) == node)));
								GIV(freeLists)[index] = ((next1 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node)));
								if (next1 != 0) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next1, 0);
								}
							}
							else {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, next);
								if ((next != 0)
								 && (!0)) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, prev);
								}
							}
							freeChunkWithBytesat((index * (allocationUnit())) - totalBytes, (startOfObject(node)) + totalBytes);
							chunk = node;
							goto l3;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < (numFreeLists()))
		 && ((1U << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1U << index)) != 0)) {
				if (((node = GIV(freeLists)[index])) == 0) {
					GIV(freeListsMask) -= 1U << index;
				}
				else {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));
						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node));
						next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev == 0) {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInBody(node)) == (index * (allocationUnit())))
								 && ((index > 1)
								 && ((startOfObject(node)) == node)));
								GIV(freeLists)[index] = ((next2 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node)));
								if (next2 != 0) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next2, 0);
								}
							}
							else {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, next);
								if ((next != 0)
								 && (!0)) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, prev);
								}
							}
							freeChunkWithBytesat((index * (allocationUnit())) - totalBytes, (startOfObject(node)) + totalBytes);
							chunk = node;
							goto l3;
						}
						prev = node;
						node = next;
					}
				}
			}
		}
	}
	child = GIV(freeLists)[0];
	node = (acceptedChunk = (acceptedNode = 0));
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child));
		childBytes = bytesInBody(child);
		if (childBytes == totalBytes) {

			/* size match; try to remove from list at node. */
			node = child;
			while (1) {
				prev = node;
				node = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
				if (!(node != 0)) break;
				if (((segmentContainingObj(node))->containsPinned)) {
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node));
					/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
					nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
					storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, nextFreeChunk);
					if ((nextFreeChunk != 0)
					 && (!0)) {
						storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, prev);
					}
					chunk = startOfObject(node);
					goto l3;
				}
			}
			if (((segmentContainingObj(child))->containsPinned)) {
				next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, child);
				if (next == 0) {

					/* no list; remove the interior node */
					unlinkSolitaryFreeTreeNode(child);
				}
				else {

					/* list; replace node with it */
					inFreeTreeReplacewith(child, next);
				}
				chunk = startOfObject(child);
				goto l3;
			}
		}
		if (child != 0) {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (totalBytes + (allocationUnit()))) {

				/* node too small; walk down the larger size of the tree */
				child = fetchPointerofFreeChunk(freeChunkLargerIndex(), child);
			}
			else {
				flag("we can do better here; preferentially choosing the lowest node. That would be a form of best-fit since we are trying to compact down");
				node = child;
				child = fetchPointerofFreeChunk(freeChunkSmallerIndex(), node);
				if (acceptedNode == 0) {

					/* first search the list. */
					acceptedChunk = node;
					do {
						acceptedChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedChunk);
						if ((acceptedChunk != 0)
						 && (((segmentContainingObj(acceptedChunk))->containsPinned))) {
							acceptedNode = node;
						}
					} while((acceptedChunk != 0)
						 && (acceptedNode == 0));
					if ((acceptedNode == 0)
					 && (((segmentContainingObj(node))->containsPinned))) {
						acceptedNode = node;

						/* break out of loop now we have an acceptedNode */
						child = 0;
					}
				}
			}
		}
	}
	if (acceptedNode != 0) {
		if (acceptedChunk != 0) {
			assert((bytesInBody(acceptedChunk)) >= (totalBytes + (allocationUnit())));
			while (1) {
				next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedNode);
				if (!(next != acceptedChunk)) break;
				acceptedNode = next;
			}
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			nextFreeChunk1 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedChunk);
			storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, acceptedNode, nextFreeChunk1);
			if ((nextFreeChunk1 != 0)
			 && (!0)) {
				storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk1, acceptedNode);
			}
			freeChunkWithBytesat((bytesInBody(acceptedChunk)) - totalBytes, (startOfObject(acceptedChunk)) + totalBytes);
			chunk = startOfObject(acceptedChunk);
			goto l3;
		}
		next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedNode);
		if (next == 0) {

			/* no list; remove the interior node */
			unlinkSolitaryFreeTreeNode(acceptedNode);
		}
		else {

			/* list; replace node with it */
			inFreeTreeReplacewith(acceptedNode, next);
		}
		assert((bytesInBody(acceptedNode)) >= (totalBytes + (allocationUnit())));
		freeChunkWithBytesat((bytesInBody(acceptedNode)) - totalBytes, (startOfObject(acceptedNode)) + totalBytes);
		chunk = startOfObject(acceptedNode);
		goto l3;
	}

	/* optimism was unfounded */
	GIV(totalFreeOldSpace) += totalBytes;
	chunk = null;
	l3:	/* end allocateOldSpaceChunkOfBytes:suchThat: */;
	if (!chunk) {
		chunk = allocateOldSpaceChunkOfBytes(totalBytes);
		if (!chunk) {
			return null;
		}
		((segmentContainingObj(chunk))->containsPinned = 1);
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(chunk, numSlots);
		longAtput(chunk + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		long64Atput(chunk + BaseHeaderSize, (headerForSlotsformatclassIndex(numSlotsMask(), formatField, classIndex)) | (1U << (pinnedBitShift())));
		checkFreeSpace(GCModeNewSpace);
		return chunk + BaseHeaderSize;
	}
	long64Atput(chunk, ((((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex) | (1U << (pinnedBitShift())));
	checkFreeSpace(GCModeNewSpace);
	return chunk;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. The
	header will have been filled-in but not the contents. If no memory is
	available answer nil. */

	/* Spur32BitMemoryManager>>#allocateSlotsInOldSpace:bytes:format:classIndex: */
static sqInt NoDbgRegParms
allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{
    sqInt chunk;

	chunk = allocateOldSpaceChunkOfBytes(totalBytes);
	if (!chunk) {
		return null;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(chunk, numSlots);
		longAtput(chunk + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		long64Atput(chunk + BaseHeaderSize, headerForSlotsformatclassIndex(numSlotsMask(), formatField, classIndex));
		checkFreeSpace(GCModeNewSpace);
		return chunk + BaseHeaderSize;
	}
	long64Atput(chunk, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	checkFreeSpace(GCModeNewSpace);
	return chunk;
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* Spur32BitMemoryManager>>#byteSwapped: */
sqInt
byteSwapped(sqInt w)
{
	return SQ_SWAP_4_BYTES(w);
}


/*	Answer the total number of bytes in an object including header and
	possible overflow size header.
 */

	/* Spur32BitMemoryManager>>#bytesInBody: */
static usqInt NoDbgRegParms
bytesInBody(sqInt objOop)
{
    usqInt headerNumSlots;
    usqInt numSlots;

	headerNumSlots = byteAt(objOop + 7);
	if (headerNumSlots == (numSlotsMask())) {
		numSlots = longAt(objOop - BaseHeaderSize);
	}
	else {
		numSlots = (headerNumSlots == 0
			? 1
			: headerNumSlots);
	}
	return ((numSlots + (numSlots & 1)) << (shiftForWord())) + ((headerNumSlots == (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize));
}


/*	Answer the C double precision floating point value of the argument,
	or if it is not, answer 0. */

	/* Spur32BitMemoryManager>>#dbgFloatValueOf: */
static double NoDbgRegParms
dbgFloatValueOf(sqInt oop)
{
    sqInt isFloat;
    double result;

	isFloat = (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassFloatCompactIndex);
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	return 0.0;
}


/*	Answer the default amount of memory to allocate for the eden space.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file.
	The shootout tests seem to plateau at 5 or 6Mb.
	
	Originally, both the 32-bit and 64-bit versions used the same 4Mb default.
	Measuring the simulator on image start-up, the 64-bit system's eden at the
	same point in start-up
	(the first copyBits) is only 8% larger in bytes because it allocates 26%
	fewer objects.
	Some 21% of the objects in the 32-bit version's eden are large integers
	and floats that
	are representable as 64-bit immediates.
	
	But when running benchmarks such as the computer language shootout's
	binary trees,
	using the same amount of memory for the 64-bit system causes a significant
	slow-down and a lot of compactions. So we now use 4Mb for 32-bits and 7Mb
	for 64-bits. */

	/* Spur32BitMemoryManager>>#defaultEdenBytes */
static sqInt
defaultEdenBytes(void)
{
	return 0x400000;
}


/*	Answer the tag used in lookup caches for a receiver. This is the
	receiver's classIndex. */

	/* Spur32BitMemoryManager>>#fetchClassTagOf: */
sqInt
fetchClassTagOf(sqInt oop)
{
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? ((tagBits & 1) != 0
				? 1
				: tagBits)
		: classIndexOf(oop));
}

	/* Spur32BitMemoryManager>>#floatObjectOf: */
usqInt
floatObjectOf(double aFloat)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newFloatObj;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;

	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = firstLongFormat();
	numSlots = (sizeof(double)) / BytesPerOop;
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassFloatCompactIndex)) != GIV(nilObj)));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = smallObjectBytesForSlots(numSlots);
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newFloatObj = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(objFormat) << (formatShift()))))) + ClassFloatCompactIndex);
	GIV(freeStart) += numBytes;
	newFloatObj = newObj;
	l1:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* Spur32BitMemoryManager>>#floatValueOf: */
double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt isFloat;
    double result;

	isFloat = (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassFloatCompactIndex);
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	This is a horrible hack for getting to the first object in eden if
	pastSpace is almost full.
	If there is only one (64-bit) word at the end of pastSpace there is no
	room for a full
	bridge, but there is room for this hack. */

	/* Spur32BitMemoryManager>>#hackSlimBridgeTo:at: */
static void NoDbgRegParms
hackSlimBridgeToat(sqInt objOop, sqInt startAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	flag("endianness");
	assert(oopisLessThan(startAddress, objOop));
	assert(oopisLessThanOrEqualTo(objOop, GIV(oldSpaceStart)));
	assert(((startAddress + (allocationUnit())) == objOop)
	 || (((startAddress + (allocationUnit())) + (allocationUnit())) == objOop));
	longAtput(startAddress, ((startAddress + (allocationUnit())) == objOop
		? 0
		: 1));
	longAtput(startAddress + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
}


/*	A negative header selects the alternate bytecode set. */

	/* Spur32BitMemoryManager>>#headerIndicatesAlternateBytecodeSet: */
sqInt
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((int) methodHeader)) < 0;
}


/*	Return a magic constant that changes when the image format changes.
	Since the image reading code uses this to detect byte ordering, one
	must avoid version numbers that are invariant under byte reversal.
	N.B. Bit 4 (=16) is the isSpur bit */

	/* Spur32BitMemoryManager>>#imageFormatVersion */
static sqInt
imageFormatVersion(void)
{
	return 6521;
}


/*	must have room for a header (single or double) plus the next free pointer */

	/* Spur32BitMemoryManager>>#initFreeChunkWithBytes:at: */
static sqInt NoDbgRegParms
initFreeChunkWithBytesat(usqLong numBytes, sqInt address)
{
    sqLong numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BytesPerOop)));
	flag("endianness");
	if (numBytes >= ((((sqInt)((usqInt)((numSlotsMask())) << (shiftForWord())))) + BaseHeaderSize)) {
		numSlots = ((usqLong)(((numBytes - BaseHeaderSize) - BaseHeaderSize))) >> (shiftForWord());
		longAtput(address, numSlots);
		longAtput(address + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		longAtput(address + 8, 0);
		longAtput(address + 12, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		return address + 8;
	}
	numSlots = ((usqLong)((numBytes - BaseHeaderSize))) >> (shiftForWord());
	assert(numSlots < (numSlotsMask()));
	longAtput(address, 0);
	longAtput(address + 4, ((sqLong)((usqLong)(numSlots) << (numSlotsHalfShift()))));
	return address;
}


/*	Must have room for a double header or a short object with the forwarding
	slot (16 bytes either way).
 */

	/* Spur32BitMemoryManager>>#initSegmentBridgeWithBytes:at: */
static void NoDbgRegParms
initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address)
{
    sqLong numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BaseHeaderSize)));
	numSlots = ((usqLong)(((numBytes - BaseHeaderSize) - BaseHeaderSize))) >> (shiftForWord());
	flag("endianness");
	if (numSlots == 0) {

		/* short bridge for adjacent segments */
		longAtput(address, ((1U << (pinnedBitShift())) + (((sqInt)((usqInt)((wordIndexableFormat())) << (formatShift()))))) + (segmentBridgePun()));
		longAtput(address + 4, 1U << (markedBitHalfShift()));
	}
	else {

		/* long bridge */
		longAtput(address, numSlots);
		longAtput(address + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		longAtput(address + 8, ((1U << (pinnedBitShift())) + (((sqInt)((usqInt)((wordIndexableFormat())) << (formatShift()))))) + (segmentBridgePun()));
		longAtput(address + 12, (((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift())))) + (1U << (markedBitHalfShift())));
	}
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* Spur32BitMemoryManager>>#integerObjectOf: */
static sqInt NoDbgRegParms
integerObjectOf(sqInt value)
{
	return ((((usqInt)value)) << 1) + 1;
}

	/* Spur32BitMemoryManager>>#isImmediateFloat: */
static sqInt NoDbgRegParms
isImmediateFloat(sqInt oop)
{
	return 0;
}

	/* Spur32BitMemoryManager>>#isIntegerObject: */
static sqInt NoDbgRegParms
isIntegerObject(sqInt oop)
{
	return (oop & (smallIntegerTag())) != 0;
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In C, use a shift and XOR to set the sign bit if and only if the top two
	bits of the given
	value are the same, then test the sign bit. Note that the top two bits are
	equal for
	exactly those integers in the range that can be represented in 31-bits or
	63-bits. 
 */

	/* Spur32BitMemoryManager>>#isIntegerValue: */
sqInt
isIntegerValue(sqInt intValue)
{
	return (((sqInt)((((usqInt)intValue)) ^ ((((usqInt)intValue)) << 1)))) >= 0;
}


/*	Allocation unit, the minimum size, is enough for 2 pointers */

	/* Spur32BitMemoryManager>>#isLilliputianSize: */
static sqInt NoDbgRegParms
isLilliputianSize(sqInt chunkBytes)
{
	return 0;
}

	/* Spur32BitMemoryManager>>#isMarked: */
sqInt
isMarked(sqInt objOop)
{
	flag("endianness");
	return ((((usqInt)((longAt(objOop + 4)))) >> (markedBitHalfShift())) & 1) != 0;
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* Spur32BitMemoryManager>>#isWordsNonImm: */
static sqInt NoDbgRegParms
isWordsNonImm(sqInt objOop)
{
	return (formatOf(objOop)) == (firstLongFormat());
}


/*	Answer the total number of bytes in an object with an overflow header,
	including header bytes.
 */

	/* Spur32BitMemoryManager>>#largeObjectBytesForSlots: */
static usqInt NoDbgRegParms
largeObjectBytesForSlots(sqInt numSlots)
{
	return (BaseHeaderSize + BaseHeaderSize) + ((numSlots + (numSlots & 1)) * BytesPerOop);
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes)
	should be subtracted from the result of this method. */

	/* Spur32BitMemoryManager>>#lengthOf:format: */
static sqInt NoDbgRegParms
lengthOfformat(sqInt objOop, sqInt fmt)
{
    usqInt numSlots;


	/* don't let forwarders freak us out... */
	numSlots = numSlotsOfAny(objOop);
	if (fmt <= (ephemeronFormat())) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return (numSlots) >> 1;
	}
	return 0;
}


/*	Answer the maximum number of slots we are willing to attempt to allocate
	in an object.
	Must fit in 32-bits; c.f. bytesInObject:. Chosen so that maxSlotsForAlloc
	* self bytesPerWord is +ve.
 */

	/* Spur32BitMemoryManager>>#maxSlotsForAlloc */
static sqInt
maxSlotsForAlloc(void)
{
	return 0x1FFFFFFF;
}


/*	Answer the format for an objOop clone with indexableSize. Needs to work
	for longFormat and arrayFormat only. */

	/* Spur32BitMemoryManager>>#normalisedFormatFor:indexableSize: */
static sqInt NoDbgRegParms
normalisedFormatForindexableSize(sqInt objOop, sqInt indexableSize)
{
    sqInt instFormat;

	/* begin classFormatFromInstFormat: */
	instFormat = formatOf(objOop);
	if (instFormat >= (firstByteFormat())) {

		/* this is likely the common case */
		return instFormat & -8;
	}
	if (instFormat <= (sixtyFourBitIndexableFormat())) {
		return instFormat;
	}
	if (instFormat < (firstShortFormat())) {
		return instFormat & -2;
	}
	return instFormat & -4;
}


/*	Answer the number of free lists. We use freeListsMask, a bitmap, to avoid
	reading empty list heads. This should fit in a machine word to end up in a
	register during free chunk allocation. */

	/* Spur32BitMemoryManager>>#numFreeLists */
static sqInt
numFreeLists(void)
{
	return 32;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceding word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word.
	
	This variation on objectAfter:limit: allows for a single (64-bit) word
	bridge which may be needed
	to bridge from an almost full pastSpace to eden. It is only used in the
	flat enumerators that use
	startAddressForBridgedHeapEnumeration and enumerate over pastSpace, eden
	and oldSpace
	in that order. Note that the order for allObjects, and allInstances
	enumerates over oldSpace first.
	
	This hack is cheap. It increases the size of the objectAfter code, but
	saves two extra copies of
	the inner loop, since the inner loop now enumerates over all of pastSpace,
	eden and oldSpace.
	The test for a slim bridge is only performed if applied to an overflow
	header, and typically only
	1 in 400 objects have overflow headers in 32-bits, 1 in 500 in 64-bits.
	The complication is that
	image segment loading evaporates the word array by setting the overflow
	slots to 1, and this
	is ambiguous with a slimbridge. The resolution is that if the segmentArray
	has an overflow header,
	and is in new space, then its slot size can be zeroed and its overflow
	header changed to a slimbridge.
	
	At some point we should allow slimbridges (slivers?) throughout object
	memory, and use them to
	provide object alignment by slimbridges (slivers?) padding up to the
	following (aligned) object.
 */

	/* Spur32BitMemoryManager>>#objectAfterMaybeSlimBridge:limit: */
static sqInt NoDbgRegParms
objectAfterMaybeSlimBridgelimit(sqInt objOop, sqInt limit)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress + 4);
	return ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
		? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
			 && (1 == (longAt(followingWordAddress)))
				? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
				: followingWordAddress + BaseHeaderSize)
		: followingWordAddress);
}


/*	Answer the total number of bytes in an object with the given
	number of slots, including header and possible overflow size header. */

	/* Spur32BitMemoryManager>>#objectBytesForSlots: */
static usqInt NoDbgRegParms
objectBytesForSlots(sqInt numSlots)
{
	return (numSlots == 0
		? (allocationUnit()) + BaseHeaderSize
		: (((sqInt)((usqInt)((numSlots + (numSlots & 1))) << (shiftForWord())))) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)));
}

	/* Spur32BitMemoryManager>>#setClassIndexOf:to: */
static void NoDbgRegParms
setClassIndexOfto(sqInt objOop, sqInt classIndex)
{
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	flag("endianness");
	longAtput(objOop, ((longAt(objOop)) & ((unsigned int)~(classIndexMask()))) + classIndex);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable
	12 - 15 16-bit indexable
	16 - 23 byte indexable
	24 - 31 compiled method */

	/* Spur32BitMemoryManager>>#setFormatOf:to: */
static void NoDbgRegParms
setFormatOfto(sqInt objOop, sqInt format)
{
	assert(((format >= 0) && (format <= (formatMask()))));
	flag("endianness");
	longAtput(objOop, ((longAt(objOop)) & ((unsigned int)~(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + (((sqInt)((usqInt)(format) << (formatShift())))));
}

	/* Spur32BitMemoryManager>>#setIsImmutableOf:to: */
static void NoDbgRegParms
setIsImmutableOfto(sqInt objOop, sqInt aBoolean)
{
	flag("endianness");
	longAtput(objOop, (aBoolean
		? (longAt(objOop)) | (1U << (immutableBitShift()))
		: (longAt(objOop)) & ((unsigned int)~(1U << (immutableBitShift())))));
}

	/* Spur32BitMemoryManager>>#setIsMarkedOf:to: */
static void NoDbgRegParms
setIsMarkedOfto(sqInt objOop, sqInt aBoolean)
{
	assert(!(isFreeObject(objOop)));
	flag("endianness");
	longAtput(objOop + 4, (aBoolean
		? (longAt(objOop + 4)) | (1U << (markedBitHalfShift()))
		: (longAt(objOop + 4)) & ((unsigned int)~(1U << (markedBitHalfShift())))));
}

	/* Spur32BitMemoryManager>>#setIsPinnedOf:to: */
static void NoDbgRegParms
setIsPinnedOfto(sqInt objOop, sqInt aBoolean)
{
	flag("endianness");
	longAtput(objOop, (aBoolean
		? (longAt(objOop)) | (1U << (pinnedBitShift()))
		: (longAt(objOop)) & ((unsigned int)~(1U << (pinnedBitShift())))));
}

	/* Spur32BitMemoryManager>>#setIsRememberedOf:to: */
static void NoDbgRegParms
setIsRememberedOfto(sqInt objOop, sqInt aBoolean)
{
	flag("endianness");
	longAtput(objOop, (aBoolean
		? (longAt(objOop)) | (1U << (rememberedBitShift()))
		: (longAt(objOop)) & ((unsigned int)~(1U << (rememberedBitShift())))));
}


/*	Answer the total number of bytes in an object without an overflow header,
	including header bytes.
 */

	/* Spur32BitMemoryManager>>#smallObjectBytesForSlots: */
usqInt
smallObjectBytesForSlots(sqInt numSlots)
{
	return BaseHeaderSize + ((numSlots <= 1
	? allocationUnit()
	: (numSlots + (numSlots & 1)) * BytesPerOop));
}

	/* Spur32BitMemoryManager>>#wordIndexableFormat */
static sqInt
wordIndexableFormat(void)
{
	return firstLongFormat();
}

	/* Spur32BitMemoryManager>>#wordSizeClassIndexPun */
static sqInt
wordSizeClassIndexPun(void)
{
	return thirtyTwoBitLongsClassIndexPun();
}


/*	Forget the argument. */

	/* SpurGenerationScavenger>>#forgetObject: */
static void NoDbgRegParms
forgetObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	assert(GIV(rememberedSetSize) > 0);
	assert(isRemembered(objOop));
	setIsRememberedOfto(objOop, 0);
	if (!(objOop == (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]))) {
		index = 0;
		while (index < GIV(rememberedSetSize)) {
			if (objOop == (GIV(rememberedSet)[index])) {
				GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
				index = GIV(rememberedSetSize);
			}
			else {
				index += 1;
			}
		}
	}
	GIV(rememberedSetSize) -= 1;
	assert(GIV(rememberedSetSize) >= 0);
}

	/* SpurGenerationScavenger>>#growRememberedSet */
static void
growRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt *base;
    sqInt fudge;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    sqInt obj;


	/* Don't ruin locality in remember: */
	obj = fetchPointerofObject(RememberedSetRootIndex, GIV(hiddenRootsObj));
	numSlots = numSlotsOf(obj);
	assert(numSlots >= 0x400);
	newObj = allocatePinnedSlots(numSlots * 2);
	if (!newObj) {
		newObj = allocatePinnedSlots(numSlots + 0x400);
		if (!newObj) {
			if (!(growOldSpaceByAtLeast((numSlots + 0x400) * BytesPerOop))) {
				error("could not grow remembered set");
			}

			/* cannot fail */
			newObj = allocatePinnedSlots(numSlots + 0x400);
		}
	}
	rememberedSetObj(newObj);
	base = firstIndexableField(newObj);
	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		base[i] = (GIV(rememberedSet)[i]);
	}
	if (isMarked(obj)) {
		setIsMarkedOfto(newObj, 1);
		setIsMarkedOfto(obj, 0);
	}
	freeObject(obj);
	GIV(rememberedSet) = base;
	GIV(rememberedSetLimit) = numSlotsOf(newObj);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 0x400;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#initFutureSpaceStart */
static sqInt
initFutureSpaceStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oldStart;

	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	return oldStart;
}

	/* SpurGenerationScavenger>>#initializeRememberedSet */
static void
initializeRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fudge;
    sqInt obj;

	obj = fetchPointerofObject(RememberedSetRootIndex, GIV(hiddenRootsObj));
	if (obj == GIV(nilObj)) {
		obj = allocatePinnedSlots(0x400);
		rememberedSetObj(obj);
	}
	else {

		/* The Spur32to64BitBootstrap failed to set the type of rememberedSetObj to 64-bit indexability.
		   This is unimportant except for simulation; rememberedSet is declared as sqInt *, but to have
		   firstIndexableField: below answer a suitable type the format must be wordIndexableFormat. */
		setFormatOfto(obj, wordIndexableFormat());
	}
	assert((formatOf(obj)) == (wordIndexableFormat()));
	assert(isPinned(obj));
	GIV(rememberedSet) = firstIndexableField(obj);
	GIV(rememberedSetSize) = 0;
	GIV(rememberedSetLimit) = numSlotsOf(obj);
	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 0x400;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#isInRememberedSet: */
static sqInt NoDbgRegParms
isInRememberedSet(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		if ((GIV(rememberedSet)[i]) == objOop) {
			return 1;
		}
	}
	return 0;
}

	/* SpurGenerationScavenger>>#newSpaceStart:newSpaceBytes:survivorBytes: */
static void NoDbgRegParms
newSpaceStartnewSpaceBytessurvivorBytes(sqInt startAddress, sqInt totalBytes, sqInt requestedSurvivorBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualEdenBytes;
    sqInt survivorBytes;

	survivorBytes = (requestedSurvivorBytes & ~7);
	actualEdenBytes = (((totalBytes - survivorBytes) - survivorBytes) & ~7);
	assert((((totalBytes - actualEdenBytes) - survivorBytes) - survivorBytes) < (allocationUnit()));
	(GIV(pastSpace).start = startAddress);
	(GIV(pastSpace).limit = startAddress + survivorBytes);
	(GIV(futureSpace).start = (GIV(pastSpace).limit));
	(GIV(futureSpace).limit = ((GIV(pastSpace).limit)) + survivorBytes);
	(GIV(eden).start = (GIV(futureSpace).limit));
	(GIV(eden).limit = startAddress + totalBytes);
	assert((((futureSpace()).limit)) <= (startAddress + totalBytes));
	assert((((((eden()).start)) % (allocationUnit())) + ((((eden()).limit)) % (allocationUnit()))) == 0);
	assert((((((pastSpace()).start)) % (allocationUnit())) + ((((pastSpace()).limit)) % (allocationUnit()))) == 0);
	assert((((((futureSpace()).start)) % (allocationUnit())) + ((((futureSpace()).limit)) % (allocationUnit()))) == 0);
	initFutureSpaceStart();
	GIV(tenuringProportion) = 0.9;
}

	/* SpurGenerationScavenger>>#openScavengeLog */
void
openScavengeLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(scavengeLog) = fopen("scavenge.log", "a+");
}


/*	Print the objects in the remembered set. */
/*	useful for debugging */

	/* SpurGenerationScavenger>>#printRememberedSet */
void
printRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		printNum(i);
		/* begin space */
		printChar(' ');
		shortPrintOop(GIV(rememberedSet)[i]);
	}
}


/*	Add the argument to the remembered set and set its isRemembered bit to
	true. Answer the argument for the benefit of the Cogit. */

	/* SpurGenerationScavenger>>#remember: */
sqInt
remember(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	assert(!((isYoungObject(objOop))));
	assert(!((isRemembered(objOop))));
	assert(!((isInRememberedSet(objOop))));
	setIsRememberedOfto(objOop, 1);
	if (GIV(rememberedSetSize) >= GIV(rememberedSetLimit)) {
		growRememberedSet();
	}
	GIV(rememberedSet)[GIV(rememberedSetSize)] = objOop;
	if (((GIV(rememberedSetSize) += 1)) >= GIV(rememberedSetRedZone)) {
	}
	return objOop;
}

	/* SpurLeakCheckingSegmentManager>>#noteValidHeapExtent: */
static void NoDbgRegParms
noteValidHeapExtent(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(oldHeapBase) = GIV(oldSpaceStart) - bytesToShift;
	GIV(oldHeapLimit) = ((((lastSegment()).segStart)) + (((lastSegment()).segSize))) - (((lastSegment()).swizzle));
}


/*	Override to check that objOop is in bounds. */

	/* SpurLeakCheckingSegmentManager>>#swizzleObj:in: */
static sqInt NoDbgRegParms
swizzleObjin(sqInt objOop, sqInt containerOopOrNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	if (!(oopisGreaterThanOrEqualToandLessThan(objOop, GIV(oldHeapBase), GIV(oldHeapLimit)))) {
		if (GIV(verbose)) {
			if (!GIV(subsequentReport)) {
				printf("Swizzling:\n");
				GIV(subsequentReport) = 1;
			}
			if (containerOopOrNil == null) {
				printf("Oop %p is out of bounds\n", objOop);
			}
			else {
				printf("Oop %p is out of bounds at/in %p\n", objOop, containerOopOrNil - GIV(nilObj));
			}
		}
		GIV(detectedInvalidOop) = 1;
	}
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}


/*	Answer whether an ephemeron is active (has an unmarked
	key) and was pushed on the unscanned ephemerons stack. */

	/* SpurMemoryManager>>#activeAndDeferredScan: */
static sqInt NoDbgRegParms NeverInline
activeAndDeferredScan(sqInt anEphemeron)
{
    sqInt key;

	assert(isEphemeron(anEphemeron));
	if ((isImmediate((key = keyOfEphemeron(anEphemeron))))
	 || (isMarked(key))) {
		return 0;
	}
	return pushOnUnscannedEphemeronsStack(anEphemeron);
}


/*	Add a freeChunk sub tree back into the large free chunk tree.
	This is for allocateOldSpaceChunkOf[Exactly]Bytes:[suchThat:]. */
/*	N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */

	/* SpurMemoryManager>>#addFreeSubTree: */
static void NoDbgRegParms
addFreeSubTree(sqInt freeTree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInArg;
    usqInt bytesInNode;
    sqInt subNode;
    sqInt treeNode;

	assert(isFreeObject(freeTree));
	bytesInArg = bytesInBody(freeTree);
	assert(bytesInArg >= ((numFreeLists()) * (allocationUnit())));
	treeNode = GIV(freeLists)[0];
	assert(treeNode != 0);
	while (1) {

		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		bytesInNode = bytesInBody(treeNode);
		assert((oopisLessThanOrEqualTo((freeTree + bytesInArg) - BaseHeaderSize, treeNode))
		 || (oopisGreaterThanOrEqualTo(freeTree, (treeNode + bytesInNode) - BaseHeaderSize)));
		assert(bytesInNode >= ((numFreeLists()) * (allocationUnit())));
		assert(bytesInArg != bytesInNode);
		if (bytesInNode > bytesInArg) {
			subNode = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode);
			if (subNode == 0) {
				storePointerofFreeChunkwithValue(freeChunkSmallerIndex(), treeNode, freeTree);
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeTree, treeNode);
				return;
			}
		}
		else {
			subNode = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode);
			if (subNode == 0) {
				storePointerofFreeChunkwithValue(freeChunkLargerIndex(), treeNode, freeTree);
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeTree, treeNode);
				return;
			}
		}
		treeNode = subNode;
	}
}


/*	Add the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#addGCRoot: */
sqInt
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootsSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}

	/* SpurMemoryManager>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address)
{
	return ((address & (BaseHeaderSize - 1)) == 0)
	 && ((isInOldSpace(address))
	 || ((isInEden(address))
	 || ((isInPastSpace(address))
	 || ((scavengeInProgress())
	 && (isInFutureSpace(address))))));
}

	/* SpurMemoryManager>>#addressCouldBeOldObj: */
static sqInt NoDbgRegParms
addressCouldBeOldObj(sqInt address)
{
	return ((address & (BaseHeaderSize - 1)) == 0)
	 && (isInOldSpace(address));
}


/*	Answer if address appears to be that of either an immediate or an object.
	For code disassembly and assertions. */

	/* SpurMemoryManager>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address)
{
	return (isImmediate(address))
	 || (addressCouldBeObj(address));
}


/*	Add freeChunk to the relevant freeList.
	For the benefit of sortedFreeObject:, if freeChunk is large, answer the
	treeNode it
	is added to, if it is added to the next list of a freeTreeNode, otherwise
	answer 0. */
/*	coInterpreter transcript ensureCr. coInterpreter print: 'freeing '. self
	printFreeChunk: freeChunk.
 */

	/* SpurMemoryManager>>#addToFreeList:bytes: */
static sqInt NoDbgRegParms
addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInBody(freeChunk)));
	index = chunkBytes / (allocationUnit());
	if (index < (numFreeLists())) {
		setNextFreeChunkOfwithValuechunkBytes(freeChunk, GIV(freeLists)[index], chunkBytes);
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, freeChunk, 0);
		GIV(freeLists)[index] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | (1U << index);
		return 0;
	}
	return addToFreeTreebytes(freeChunk, chunkBytes);
}


/*	Add freeChunk to the large free chunk tree.
	For the benefit of sortedFreeObject:, answer the treeNode it is added
	to, if it is added to the next list of a freeTreeNode, otherwise answer 0. */

	/* SpurMemoryManager>>#addToFreeTree:bytes: */
static sqInt NoDbgRegParms
addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt nextFreeChunk;
    sqInt parent;

	initFreeTreeChunkbytes(freeChunk, chunkBytes);
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {

		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		childBytes = bytesInBody(child);
		assert((oopisLessThanOrEqualTo((freeChunk + chunkBytes) - BaseHeaderSize, child))
		 || (oopisGreaterThanOrEqualTo(freeChunk, (child + childBytes) - BaseHeaderSize)));
		if (childBytes == chunkBytes) {

			/* size match; add to list at node. */
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, child);
			storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, freeChunk, nextFreeChunk);
			if ((nextFreeChunk != 0)
			 && (!0)) {
				storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, freeChunk);
			}
			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, child, freeChunk);
			if ((freeChunk != 0)
			 && (!0)) {
				storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, freeChunk, child);
			}
			return child;
		}
		parent = child;
		child = fetchPointerofFreeChunk((childBytes > chunkBytes
			? freeChunkSmallerIndex()
			: freeChunkLargerIndex()), child);
	}
	if (parent == 0) {
		assert((GIV(freeLists)[0]) == 0);
		GIV(freeLists)[0] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | 1;
		return 0;
	}
	assert(((GIV(freeListsMask) & 1) != 0));
	storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeChunk, parent);
	storePointerofFreeChunkwithValue((childBytes > chunkBytes
		? freeChunkSmallerIndex()
		: freeChunkLargerIndex()), parent, freeChunk);
	return 0;
}


/*	Adjust all oop references by the given number of bytes. This is
	done just after reading in an image when the new base address
	of the object heap is different from the base address in the image,
	or when loading multiple segments that have been coalesced. Also
	set bits in the classTableBitmap corresponding to used classes. */

	/* SpurMemoryManager>>#adjustAllOopsBy: */
static void NoDbgRegParms
adjustAllOopsBy(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt chunkBytes;
    sqInt classIndex;
    sqInt field;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt index;
    sqInt indexLimiT;
    sqInt obj;

	assert(newSpaceIsEmpty());
	countNumClassPagesPreSwizzle(bytesToShift);
	if ((bytesToShift != 0)
	 || ((numSegments()) > 1)) {
		obj = objectStartingAt(GIV(oldSpaceStart));
		while (oopisLessThan(obj, GIV(freeOldSpaceStart))) {
			classIndex = classIndexOf(obj);
			if (classIndex >= (isForwardedObjectClassIndexPun())) {
				/* begin swizzleFieldsOfObject: */
				fieldAddr = obj + (lastPointerOfWhileSwizzling(obj));
				while (oopisGreaterThanOrEqualTo(fieldAddr, obj + BaseHeaderSize)) {
					fieldOop = longAt(fieldAddr);
					if (isNonImmediate(fieldOop)) {
						longAtput(fieldAddr, swizzleObjin(fieldOop, obj));
					}
					fieldAddr -= BytesPerOop;
				}
			}
			else {
				if (classIndex == (isFreeObjectClassIndexPun())) {
					/* begin swizzleFieldsOfFreeChunk: */
					field = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, obj);
					if (field != 0) {
						storePointerNoAssertofFreeChunkwithValue(0 /* freeChunkNextIndex */, obj, swizzleObjin(field, obj));
					}
					chunkBytes = bytesInBody(obj);
					if (chunkBytes >= ((numFreeLists()) * (allocationUnit()))) {
						for (index = 2 /* freeChunkParentIndex */, indexLimiT = (freeChunkLargerIndex()); index <= indexLimiT; index += 1) {
							field = fetchPointerofFreeChunk(index, obj);
							if (field != 0) {
								storePointerNoAssertofFreeChunkwithValue(index, obj, swizzleObjin(field, obj));
							}
						}
					}
				}
			}
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(obj);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				obj = GIV(endOfMemory);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress + 4);
			obj = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
		}
	}
}


/*	Allocate an object with numSlots in newSpace. This is for the `ee'
	execution engine allocations,
	and must be satisfied. If no memory is available, abort. If the allocation
	pushes freeStart past
	scavengeThreshold and a scavenge is not already scheduled, schedule a
	scavenge.  */
/*	Object headers are 8 bytes in length if the slot size fits in the num
	slots field (max implies overflow),
	16 bytes otherwise (num slots in preceding word).
	Objects always have at least one slot, for the forwarding pointer,
	and are multiples of 8 bytes in length. */

	/* SpurMemoryManager>>#allocateNewSpaceSlots:format:classIndex: */
static usqInt NoDbgRegParms
allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newObj;
    usqInt numBytes;

	if (numSlots >= (numSlotsMask())) {
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = largeObjectBytesForSlots(numSlots);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = smallObjectBytesForSlots(numSlots);
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateNewSpaceSlots:format:classIndex:");
			return 0;
		}
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		long64Atput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, classIndex));
	}
	else {
		long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}


/*	Answer a chunk of oldSpace from the free lists, if available,
	otherwise answer nil. Break up a larger chunk if one of the
	exact size does not exist. N.B. the chunk is simply a pointer, it
	has no valid header. The caller *must* fill in the header correctly. */
/*	for debugging: */
/*	totalFreeOldSpace := self totalFreeListBytes */

	/* SpurMemoryManager>>#allocateOldSpaceChunkOfBytes: */
static sqInt NoDbgRegParms
allocateOldSpaceChunkOfBytes(usqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt next1;
    sqInt nextFreeChunk;
    sqInt nextFreeChunk1;
    usqInt nodeBytes;
    sqInt parent;

	nodeBytes = 0;

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= chunkBytes;
	initialIndex = chunkBytes / (allocationUnit());
	if ((initialIndex < (numFreeLists()))
	 && ((1U << initialIndex) <= GIV(freeListsMask))) {
		if (((GIV(freeListsMask) & (1U << initialIndex)) != 0)) {
			if (((chunk = GIV(freeLists)[initialIndex])) != 0) {
				assert(chunk == (startOfObject(chunk)));
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk));
				unlinkFreeChunkatIndexchunkBytes(chunk, initialIndex, chunkBytes);
				return chunk;
			}
			GIV(freeListsMask) -= 1U << initialIndex;
		}
		index = initialIndex;
		while ((((index += index)) < (numFreeLists()))
		 && ((1U << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1U << index)) != 0)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk));
					/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
					assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = ((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk)));
					if (next != 0) {
						storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, 0);
					}
					assert((bytesInBody(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * (allocationUnit())) - chunkBytes, (startOfObject(chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1U << index;
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < (numFreeLists()))
		 && ((1U << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1U << index)) != 0)) {
				if (((chunk = GIV(freeLists)[index])) != 0) {
					assert(chunk == (startOfObject(chunk)));
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk));
					/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
					assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = ((next1 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk)));
					if (next1 != 0) {
						storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next1, 0);
					}
					assert((bytesInBody(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * (allocationUnit())) - chunkBytes, (startOfObject(chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1U << index;
			}
		}
	}
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child));
		childBytes = bytesInBody(child);
		if (childBytes == chunkBytes) {

			/* size match; try to remove from list at node. */
			chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, child);
			if (chunk != 0) {
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk));
				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk);
				storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, child, nextFreeChunk);
				if ((nextFreeChunk != 0)
				 && (!0)) {
					storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, child);
				}
				return startOfObject(chunk);
			}
			nodeBytes = childBytes;
			parent = child;

			/* break out of loop to remove interior node */
			child = 0;
		}
		else {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (chunkBytes + (allocationUnit()))) {

				/* node too small; walk down the larger size of the tree */
				child = fetchPointerofFreeChunk(freeChunkLargerIndex(), child);
			}
			else {

				/* parent will be smallest node >= chunkBytes + allocationUnit */
				parent = child;
				nodeBytes = childBytes;
				child = fetchPointerofFreeChunk(freeChunkSmallerIndex(), child);
			}
		}
	}
	if (parent == 0) {

		/* optimism was unfounded */
		GIV(totalFreeOldSpace) += chunkBytes;
		return null;
	}
	assert((nodeBytes == chunkBytes)
	 || (nodeBytes >= (chunkBytes + (2 * (allocationUnit())))));
	assert((bytesInBody(parent)) == nodeBytes);
	chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, parent);
	if (chunk != 0) {
		assert((chunkBytes == nodeBytes)
		 || ((chunkBytes + (allocationUnit())) < nodeBytes));
		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		nextFreeChunk1 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk);
		storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, parent, nextFreeChunk1);
		if ((nextFreeChunk1 != 0)
		 && (!0)) {
			storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk1, parent);
		}
		if (chunkBytes != nodeBytes) {
			freeChunkWithBytesat(nodeBytes - chunkBytes, (startOfObject(chunk)) + chunkBytes);
		}
		return startOfObject(chunk);
	}
	chunk = parent;
	unlinkSolitaryFreeTreeNode(chunk);
	if (chunkBytes != nodeBytes) {
		freeChunkWithBytesat(nodeBytes - chunkBytes, (startOfObject(chunk)) + chunkBytes);
	}
	return startOfObject(chunk);
}

	/* SpurMemoryManager>>#allocatePinnedSlots: */
sqInt
allocatePinnedSlots(sqInt nSlots)
{
    sqInt obj;
    usqInt p;

	obj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, objectBytesForSlots(nSlots), wordIndexableFormat(), wordSizeClassIndexPun());
	if (!(obj == null)) {
		assert(isPinned(obj));
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj)));
		for (p = (((usqInt)(obj + BaseHeaderSize))); p <= (((usqInt)(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1))); p += (allocationUnit())) {
			longAtput(p, 0);
			longAtput(p + 4, 0);
		}
	}
	return obj;
}


/*	All objects are a multiple of 8 bytes in length */

	/* SpurMemoryManager>>#allocationUnit */
static sqInt
allocationUnit(void)
{
	return 8;
}

	/* SpurMemoryManager>>#arrayFormat */
sqInt
arrayFormat(void)
{
	return 2;
}


/*	we don't want to inline so we can nest that in an assertion with the
	return true so the production VM does not generate any code here, while in
	simulation, the code breaks on the assertion we want to.
 */

	/* SpurMemoryManager>>#assertInnerValidFreeObject: */
static sqInt NoDbgRegParms NeverInline
assertInnerValidFreeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    sqInt chunk;
    usqInt index;
    sqInt largeChild;
    sqInt smallChild;
    sqInt treeNode;

	assert(oopisLessThanOrEqualTo(addressAfter(objOop), GIV(endOfMemory)));
	chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, objOop);
	assert((chunk == 0)
	 || (isFreeOop(chunk)));
	
	/* double linkedlist assertions */
	chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, objOop);
	if (!(chunk == 0)) {
		assert(isFreeOop(chunk));
		assert(objOop == (fetchPointerofFreeChunk(freeChunkPrevIndex(), chunk)));
	}
	chunk = fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, objOop);
	index = (bytesInBody(objOop)) / (allocationUnit());
	if ((index < (numFreeLists()))
	 && ((1U << index) <= GIV(freeListsMask))) {
		if ((GIV(freeLists)[index]) == objOop) {
			assert(chunk == 0);
		}
	}
	else {
		/* begin freeTreeNodesDo: */
		treeNode = GIV(freeLists)[0];
		if (treeNode == 0) {
			goto l1;
		}
		cameFrom = -1;
		do {
			assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
			smallChild = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode);
			largeChild = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode);
			assert((smallChild == 0)
			 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
			assert((largeChild == 0)
			 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
			if (((smallChild == 0)
			 && (largeChild == 0))
			 || ((largeChild == 0
				? cameFrom == smallChild
				: cameFrom == largeChild))) {

				/* and since we've applied we must move on up */
				if (treeNode == objOop) {
					assert(chunk == 0);
				}
				/* treeNode = */ treeNode;
				cameFrom = treeNode;
				treeNode = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, treeNode);
			}
			else {
				if ((smallChild != 0)
				 && (cameFrom != smallChild)) {
					treeNode = smallChild;
				}
				else {
					assert(largeChild != 0);
					treeNode = largeChild;
				}
				cameFrom = -1;
			}
		} while(treeNode != 0);
	l1:	/* end freeTreeNodesDo: */;
	}
	if (!(chunk == 0)) {
		assert(isFreeOop(chunk));
		assert(objOop == (fetchPointerofFreeChunk(freeChunkNextIndex(), chunk)));
	}
	if (isLargeFreeObject(objOop)) {

		/* Tree assertions */
		chunk = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, objOop);
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
		chunk = fetchPointerofFreeChunk(freeChunkSmallerIndex(), objOop);
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
		chunk = fetchPointerofFreeChunk(freeChunkLargerIndex(), objOop);
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
	}
	return 1;
}


/*	Answer the appropriate become effect flags for objOop, or 0 if none.
	The effect flags determine how much work is done after the become
	in following forwarding pointers, voiding method caches, etc. */

	/* SpurMemoryManager>>#becomeEffectFlagsFor: */
static sqInt NoDbgRegParms
becomeEffectFlagsFor(sqInt objOop)
{
    sqInt hash;

	return (isPointersNonImm(objOop)
		? ((((hash = rawHashBitsOf(objOop))) != 0)
			 && ((classAtIndex(hash)) == objOop)
				? BecamePointerObjectFlag + BecameActiveClassFlag
				: BecamePointerObjectFlag)
		: (isCompiledMethod(objOop)
				? BecameCompiledMethodFlag
				: 0));
}


/*	If this object is old, mark it as a root (because a new object
	may be stored into it). */

	/* SpurMemoryManager>>#beRootIfOld: */
void
beRootIfOld(sqInt oop)
{
	if (isOldObject(oop)) {

		/* No, oop is an old object */
		/* begin possibleRootStoreInto: */
		if (!(isRemembered(oop))) {
			remember(oop);
		}
	}
}

	/* SpurMemoryManager>>#bitsSetInFreeSpaceMaskForAllFreeLists */
static sqInt
bitsSetInFreeSpaceMaskForAllFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	for (i = 0, iLimiT = ((numFreeLists()) - 1); i <= iLimiT; i += 1) {
		if (((GIV(freeLists)[i]) != 0)
		 && ((!((1U << i) & GIV(freeListsMask))))) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#bridgeSize */
static sqInt
bridgeSize(void)
{
	return 2 * BaseHeaderSize;
}

	/* SpurMemoryManager>>#byteFormatForNumBytes: */
static sqInt NoDbgRegParms
byteFormatForNumBytes(sqInt numBytes)
{
	return (firstByteFormat()) + ((8 - numBytes) & (BytesPerWord - 1));
}

	/* SpurMemoryManager>>#byteFormatMask */
static sqInt
byteFormatMask(void)
{
	return 24;
}

	/* SpurMemoryManager>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numBytes;

	if (isImmediate(oop)) {
		return 0;
	}
	/* begin numBytesOf: */
	fmt = formatOf(oop);
	numBytes = numSlotsOf(oop);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
	}
	return numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
}


/*	Answer the basic element size for the receiver. Answer 0 for immediates
	and CompiledCode
	(element size could be wordSize for literals or 1 for bytes, so its
	indeterminable). Answer
	wordSize for pointer objects. Otherwise answer the actual element size of
	a bits container. */

	/* SpurMemoryManager>>#bytesPerElement: */
usqInt
bytesPerElement(sqInt oop)
{
    unsigned char byteSizes[16] =
								   {	wordSize(),  wordSize(),  wordSize(),  wordSize(),
									wordSize(),  wordSize(),  wordSize(),  0, /* forwarder */ wordSize(),
									8,
									4, 4,
									2, 2, 2, 2 };
    sqInt fmt;

	if (isImmediate(oop)) {
		return 0;
	}
	fmt = formatOf(oop);
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			return 0;
		}
		return 1;
	}
	return byteSizes[fmt];
}

	/* SpurMemoryManager>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode)
{
	return (((sqInt)((usqInt)(characterCode) << (numTagBits())))) + (characterTag());
}

	/* SpurMemoryManager>>#characterTable */
static void
characterTable(void)
{
	error("shouldNotImplement");
}


/*	Immediate characters are unsigned */

	/* SpurMemoryManager>>#characterValueOf: */
usqInt
characterValueOf(sqInt oop)
{
	return ((((usqInt)oop))) >> (numTagBits());
}


/*	Assumes zero-based array indexing. */

	/* SpurMemoryManager>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isInMemory(byteAddress))) {
		warning("checkedLongAt bad address");
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return longAt(byteAddress);
}

	/* SpurMemoryManager>>#checkFreeSpace: */
static void NoDbgRegParms
checkFreeSpace(sqInt gcModes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if ((gcModes > 0)
	 && (((checkForLeaks & (GCCheckFreeSpace | gcModes)) == (GCCheckFreeSpace | gcModes)))) {
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each (non-free)
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rememberedSet, remapBuffer and
	extraRootTable checking
	that every entry is a pointer to a header. Check that the number of roots
	is correct and that all
	rememberedSet entries have their isRemembered: flag set. Answer if all
	checks pass. */

	/* SpurMemoryManager>>#checkHeapIntegrity:classIndicesShouldBeValid: */
static sqInt NoDbgRegParms
checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classOop;
    sqInt containsYoung;
    sqInt fi;
    sqInt fieldOop;
    sqInt fiLimiT;
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt freeListOop;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt iLimiT;
    sqInt numOnThisPage;
    sqInt numRememberedObjectsInHeap;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objStackPage;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ri;
    usqInt start;

	ok = 1;
	numRememberedObjectsInHeap = 0;
	for (i = 0, iLimiT = ((numFreeLists()) - 1); i <= iLimiT; i += 1) {
		if (((freeListOop = GIV(freeLists)[i])) != 0) {
			if (isInOldSpace(freeListOop)) {
				if ((heapMapAtWord(pointerForOop(freeListOop))) != 0) {
					print("leak in free list ");
					printNum(i);
					print(" to non-free ");
					printHex(freeListOop);
					eekcr();
					ok = 0;
				}
			}
			else {
				print("leak in free list ");
				printNum(i);
				print(" to out-of-bounds ");
				printHex(freeListOop);
				eekcr();
				ok = 0;
			}
		}
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l2;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (isFreeObject(objOop)) {
			print("young object ");
			printHex(objOop);
			print(" is free");
			eekcr();
			ok = 0;
		}
		else {
			if (!((!(isMarked(objOop)))
				 && (excludeUnmarkedObjs))) {
				if (isRemembered(objOop)) {
					print("young object ");
					printHex(objOop);
					print(" is remembered");
					eekcr();
					ok = 0;
				}
			}
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				fieldOop = fetchPointerofMaybeForwardedObject(0, objOop);
				if (isInHeapBounds(fieldOop)) {
					if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
						print("object leak in forwarder ");
						printHex(objOop);
						print(" to unmapped ");
						printHex(fieldOop);
						eekcr();
						ok = 0;
					}
				}
				else {
					print("object leak in forwarder ");
					printHex(objOop);
					print(" to out-of-bounds ");
					printHex(fieldOop);
					eekcr();
					ok = 0;
				}
			}
			else {
				classOop = classOrNilAtIndex((classIndex = classIndexOf(objOop)));
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(isHiddenObj(objOop))))) {
					print("object leak in ");
					printHex(objOop);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					eekcr();
					ok = 0;
				}
				for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop)) - 1); fi <= fiLimiT; fi += 1) {
					fieldOop = fetchPointerofObject(fi, objOop);
					if (isNonImmediate(fieldOop)) {
						if (isInHeapBounds(fieldOop)) {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(objOop);
								print(" @ ");
								printNum(fi);
								print(" = ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
						}
						else {
							print("object leak in ");
							printHex(objOop);
							print(" to out-of-bounds ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l2:	/* end allNewSpaceEntitiesDo: */;
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (isFreeObject(objOop1)) {
			if ((heapMapAtWord(pointerForOop(objOop1))) != 0) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" is mapped?! ");
				eekcr();
				ok = 0;
			}
			fieldOop = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, objOop1);
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" @ 0 = ");
				printHex(fieldOop);
				print(" is mapped");
				eekcr();
				ok = 0;
			}
			fieldOop = fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, objOop1);
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
				print("leak in free chunk ");
				printHex(objOop1);
				print(" @ 1 = ");
				printHex(fieldOop);
				print(" is mapped");
				eekcr();
				ok = 0;
			}
			if (isLargeFreeObject(objOop1)) {
				for (fi = 2 /* freeChunkParentIndex */, fiLimiT = (freeChunkLargerIndex()); fi <= fiLimiT; fi += 1) {
					fieldOop = fetchPointerofFreeChunk(fi, objOop1);
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
						print("leak in free chunk ");
						printHex(objOop1);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is mapped");
						eekcr();
						ok = 0;
					}
				}
			}
		}
		else {
			if (!(excludeUnmarkedObjs
				 && (!(isMarked(objOop1))))) {
				containsYoung = 0;
				if (isRemembered(objOop1)) {
					numRememberedObjectsInHeap += 1;
					if (!(isInRememberedSet(objOop1))) {
						print("remembered object ");
						printHex(objOop1);
						print(" is not in remembered table");
						eekcr();
						ok = 0;
					}
				}
				if ((!((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					fieldOop = fetchPointerofMaybeForwardedObject(0, objOop1);
					if (isInHeapBounds(fieldOop)) {
						if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
							print("object leak in forwarder ");
							printHex(objOop1);
							print(" to unmapped ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
					}
					else {
						print("object leak in forwarder ");
						printHex(objOop1);
						print(" to out-of-bounds ");
						printHex(fieldOop);
						eekcr();
						ok = 0;
					}
					if (isReallyYoung(fieldOop)) {
						containsYoung = 1;
					}
				}
				else {
					classOop = classOrNilAtIndex((classIndex = classIndexOf(objOop1)));
					if (classIndicesShouldBeValid
					 && ((classOop == GIV(nilObj))
					 && (classIndex > (lastClassIndexPun())))) {
						print("object leak in ");
						printHex(objOop1);
						print(" invalid class index ");
						printHex(classIndex);
						print(" -> ");
						print((classOop == null
							? "nil"
							: "nilObj"));
						eekcr();
						ok = 0;
					}
					for (fi = 0, fiLimiT = ((numPointerSlotsOf(objOop1)) - 1); fi <= fiLimiT; fi += 1) {
						fieldOop = fetchPointerofObject(fi, objOop1);
						if (isNonImmediate(fieldOop)) {
							if (isInHeapBounds(fieldOop)) {
								if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
									print("object leak in ");
									printHex(objOop1);
									print(" @ ");
									printNum(fi);
									print(" = ");
									printHex(fieldOop);
									eekcr();
									ok = 0;
								}
							}
							else {
								print("object leak in ");
								printHex(objOop1);
								print(" to out-of-bounds ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
							if (isReallyYoung(fieldOop)) {
								containsYoung = 1;
							}
						}
					}
				}
				if (containsYoung) {
					if (!(isRemembered(objOop1))) {
						print("unremembered object ");
						printHex(objOop1);
						print(" contains young oop(s)");
						eekcr();
						ok = 0;
					}
				}
			}
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
	}
	if (numRememberedObjectsInHeap != (rememberedSetSize())) {
		print("root count mismatch. #heap roots ");
		printNum(numRememberedObjectsInHeap);
		print("; #roots ");
		printNum(rememberedSetSize());
		eekcr();
		flag("no support for remembered set overflow yet");
	}
	/* begin rememberedSetWithIndexDo: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		obj = GIV(rememberedSet)[i1];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned oop in remembered set @ ");
			printNum(i1);
			print(" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remembered set @ ");
				printNum(i1);
				print(" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
			else {
				if (isYoung(obj)) {
					print("non-root in remembered set @ ");
					printNum(i1);
					print(" = ");
					printHex(obj);
					eekcr();
					ok = 0;
				}
			}
		}
	}
	/* begin objStack:do: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l4;
	}
	eassert(isValidObjStack(GIV(mournQueue)));
	objStackPage = GIV(mournQueue);
	while (objStackPage != 0) {
		numOnThisPage = fetchPointerofObject(ObjStackTopx, objStackPage);
		for (i2 = ((numOnThisPage + ObjStackFixedSlots) - 1); i2 >= ObjStackFixedSlots; i2 += -1) {
			obj = fetchPointerofObject(i2, objStackPage);
			if ((obj & (BytesPerWord - 1)) != 0) {
				print("misaligned oop in mournQueue @ ");
				printNum(i2);
				print(" in ");
				printHex(objStackPage);
				print(" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
			else {
				if (!(excludeUnmarkedObjs
					 && (!(isMarked(obj))))) {
					if ((heapMapAtWord(pointerForOop(obj))) == 0) {
						print("object leak in mournQueue @ ");
						printNum(i2);
						print(" in ");
						printHex(objStackPage);
						print(" = ");
						printHex(obj);
						eekcr();
						ok = 0;
					}
				}
			}
		}
		objStackPage = fetchPointerofObject(ObjStackNextx, objStackPage);
	}
	l4:	/* end objStack:do: */;
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & (BytesPerWord - 1)) != 0) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */
/*	useful for debugging */

	/* SpurMemoryManager>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	if (isImmediate(oop)) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		print("oop ");
		printHex(oop);
		print(" is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		print("oop ");
		printHex(oop);
		print(" size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = classIndexOf(oop))) >= (firstClassIndexPun()))) {
		print("oop ");
		printHex(oop);
		print(" is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		print("oop ");
		printHex(oop);
		print(" header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = formatOf(oop);
	if ((fmt == 6) || (fmt == 8)) {
		print("oop ");
		printHex(oop);
		print(" has an unknown format type");
		return 0;
	}
	if ((fmt == (forwardedFormat())) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		print("oop ");
		printHex(oop);
		print(" has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1U << (classIndexFieldWidth())) | (1ULL << ((identityHashFieldWidth()) + 32));
	if (((long64At(oop)) & unusedBits) != 0) {
		print("oop ");
		printHex(oop);
		print(" has some unused header bits set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = newSpaceRefCountMask();
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		print("oop ");
		printHex(oop);
		print(" has some header bits unused in young objects set; should be zero");
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */
/*	useful for debugging */

	/* SpurMemoryManager>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj)
{
    usqInt objClass;
    sqInt objFormat;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) (fetchClassOfNonImm(obj)));
	if (isImmediate(objClass)) {
		print("obj ");
		printHex(obj);
		print(" an immediate is not a valid class or behavior");
		cr();
		return 0;
	}
	if (!(okayOop(objClass))) {
		print("obj ");
		printHex(obj);
		print(" class obj is not ok");
		cr();
		return 0;
	}
	if (!((isPointersNonImm(objClass))
		 && ((numSlotsOf(objClass)) >= 3))) {
		print("obj ");
		printHex(obj);
		print(" a class (behavior) must be a pointers object of size >= 3");
		cr();
		return 0;
	}
	objFormat = (isBytes(obj)
		? (((formatOf(obj)) | 7) - 7)
		: formatOf(obj));
	if ((instSpecOfClass(objClass)) != objFormat) {
		print("obj ");
		printHex(obj);
		print(" and its class (behavior) formats differ");
		cr();
		return 0;
	}
	return 1;
}

	/* SpurMemoryManager>>#classAlien */
static sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassAlien, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classArray */
sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassArray, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classAtIndex: */
sqInt
classAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask()))
	 || ((classIndex >= (arrayClassIndexPun()))
	 && (classIndex <= (classIndexMask())))));
	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}

	/* SpurMemoryManager>>#classBitmap */
static sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassBitmap, GIV(specialObjectsOop));
}


/*	a.k.a. self fetchPointer: ClassByteArrayCompactIndex ofObject:
	classTableFirstPage 
 */

	/* SpurMemoryManager>>#classByteArray */
static sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassByteArray, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classCharacter */
static sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassCharacter, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classDoubleByteArray */
static sqInt
classDoubleByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;

	/* begin accessIntegerClass:withValidationFlag: */
	classOop = fetchPointerofObject(ClassDoubleByteArray, GIV(specialObjectsOop));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassDoubleByteArrayFlag) != 0)) {
		return classOop;
	}
	if ((isImmediate(classOop))
	 || ((((hash = rawHashBitsOf(classOop))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassDoubleByteArrayFlag;
	return classOop;
}

	/* SpurMemoryManager>>#classDoubleWordArray */
static sqInt
classDoubleWordArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;

	/* begin accessIntegerClass:withValidationFlag: */
	classOop = fetchPointerofObject(ClassDoubleWordArray, GIV(specialObjectsOop));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassDoubleWordArrayFlag) != 0)) {
		return classOop;
	}
	if ((isImmediate(classOop))
	 || ((((hash = rawHashBitsOf(classOop))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassDoubleWordArrayFlag;
	return classOop;
}

	/* SpurMemoryManager>>#classExternalAddress */
static sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalAddress, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalData */
static sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalData, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalFunction */
static sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalFunction, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalLibrary */
static sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalLibrary, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalStructure */
static sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalStructure, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classFloat */
static sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassFloat, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classFloat32Array */
static sqInt
classFloat32Array(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}

	/* SpurMemoryManager>>#classFloat64Array */
static sqInt
classFloat64Array(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	No need to check this; classAtIndex: has a stricter assert:
	self assert: classIndex ~= self isForwardedObjectClassIndexPun. */

	/* SpurMemoryManager>>#classForClassTag: */
static sqInt NoDbgRegParms
classForClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	/* begin classAtIndex: */
	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask()))
	 || ((classIndex >= (arrayClassIndexPun()))
	 && (classIndex <= (classIndexMask())))));
	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}


/*	22-bit class mask => ~ 4M classes */

	/* SpurMemoryManager>>#classIndexFieldWidth */
static sqInt
classIndexFieldWidth(void)
{
	return 22;
}


/*	Answer objOop's classIndex from the object header.
	A note on performance:
	This routine uses longAt:, which does a 32-bit load on the 32-bit system,
	and a 64-bit load
	on the 64-bit system. Since the only 64-bit implementation(s) is/are
	little-endian, and
	since all of isGrey,isPinned,isRemembered,format,isUmmutable and
	classIndex fit within
	the least significant 32-bits we could use long32At: to access these, in
	the hope that the
	32-bit access will be quicker on 64-bits by virtue of fetching half the
	bits. But experiments
	show that doing this does not produce any increase; at least any signal is
	lost in the noise. */

	/* SpurMemoryManager>>#classIndexOf: */
sqInt
classIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & (classIndexMask());
}

	/* SpurMemoryManager>>#classLargeNegativeInteger */
static sqInt
classLargeNegativeInteger(void)
{
	return knownClassAtIndex(ClassLargeNegativeIntegerCompactIndex);
}

	/* SpurMemoryManager>>#classLargePositiveInteger */
static sqInt
classLargePositiveInteger(void)
{
	return knownClassAtIndex(ClassLargePositiveIntegerCompactIndex);
}

	/* SpurMemoryManager>>#classOrNilAtIndex: */
sqInt
classOrNilAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}

	/* SpurMemoryManager>>#classPoint */
static sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassPoint, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classSemaphore */
static sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassSemaphore, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classSmallInteger */
sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassSmallInteger, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classString */
static sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassByteString, GIV(specialObjectsOop));
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTableMinorIndexMask */

	/* SpurMemoryManager>>#classTableMinorIndexMask */
sqInt
classTableMinorIndexMask(void)
{
	return (1U << (classTableMajorIndexShift())) - 1;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTablePageSize */

	/* SpurMemoryManager>>#classTablePageSize */
sqInt
classTablePageSize(void)
{
	return 1U << (classTableMajorIndexShift());
}


/*	For Cogit & bootstrap */

	/* SpurMemoryManager>>#classTableRootObj */
sqInt
classTableRootObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	Answer the number of slots for class table pages in the hidden root
	object. 
 */

	/* SpurMemoryManager>>#classTableRootSlots */
static sqInt
classTableRootSlots(void)
{
	return 1U << ((classIndexFieldWidth()) - (classTableMajorIndexShift()));
}


/*	Answer the classObj's identityHash to use as a tag in the first-level
	method lookup cache.
 */

	/* SpurMemoryManager>>#classTagForClass: */
sqInt
classTagForClass(sqInt classObj)
{
    sqInt err;
    sqInt hash;

	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	flag("todo");
	return (((hash = rawHashBitsOf(classObj))) != 0
		? hash
		: (objCouldBeClassObj(classObj)
				? (((err = enterIntoClassTable(classObj))) != 0
						? -err
						: rawHashBitsOf(classObj))
				: -PrimErrBadReceiver));
}

	/* SpurMemoryManager>>#classUnsafeAlien */
static sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassUnsafeAlien, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classWordArray */
static sqInt
classWordArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;

	/* begin accessIntegerClass:withValidationFlag: */
	classOop = fetchPointerofObject(ClassWordArray, GIV(specialObjectsOop));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassWordArrayFlag) != 0)) {
		return classOop;
	}
	if ((isImmediate(classOop))
	 || ((((hash = rawHashBitsOf(classOop))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassWordArrayFlag;
	return classOop;
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	clearHeapMap();
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if (isEnumerableObject(obj)) {
			heapMapAtWordPut(pointerForOop(obj), 1);
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	}

	/* SpurMemoryManager>>#cloneInOldSpace:forPinning: */
static sqInt NoDbgRegParms
cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning)
{
    sqInt fmt;
    sqInt hash;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    sqInt oop;

	numSlots = numSlotsOf(objOop);
	fmt = formatOf(objOop);
	if (forPinning) {
		newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), fmt, classIndexOf(objOop));
	}
	else {
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), fmt, classIndexOf(objOop));
	}
	if (!newObj) {
		return 0;
	}
	if (isPointersFormat(fmt)) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = fetchPointerofObject(i, objOop);
			if ((isNonImmediate(oop))
			 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				oop = followForwarded(oop);
			}
			if ((isNonImmediate(oop))
			 && (isYoungObject(oop))) {
				hasYoung = 1;
			}
			storePointerUncheckedofObjectwithValue(i, newObj, oop);
		}
		if (hasYoung) {
			remember(newObj);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			storePointerUncheckedofObjectwithValue(i, newObj, fetchPointerofObject(i, objOop));
		}
		if (fmt >= (firstCompiledMethodFormat())) {
			if ((isYoungObject(objOop))
			 || (isRemembered(objOop))) {
				remember(newObj);
			}
		}
	}
	if (((hash = rawHashBitsOf(objOop))) != 0) {
		setHashBitsOfto(newObj, hash);
	}
	if (
#  if IMMUTABILITY
		isImmutable(objOop)
#  else
		0
#  endif
		) {
		setIsImmutableOfto(newObj, 1);
	}
	return newObj;
}

	/* SpurMemoryManager>>#cloneObject: */
static sqInt NoDbgRegParms
cloneObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt fmt;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numSlots;
    sqInt oop;

	numSlots = numSlotsOf(objOop);
	fmt = formatOf(objOop);
	if (numSlots > (maxSlotsForNewSpaceAlloc())) {
		/* begin allocateSlotsInOldSpace:format:classIndex: */
		classIndex = classIndexOf(objOop);
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), fmt, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		classIndex1 = classIndexOf(objOop);
		if (numSlots >= (numSlotsMask())) {
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = largeObjectBytesForSlots(numSlots);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = smallObjectBytesForSlots(numSlots);
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, fmt, classIndex1);
			goto l2;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), numSlots);
			longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
			long64Atput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), fmt, classIndex1));
		}
		else {
			long64Atput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(fmt) << (formatShift()))))) + classIndex1);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l2:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		if (isPointersFormat(fmt)) {
			hasYoung = 0;
			for (i = 0; i < numSlots; i += 1) {
				oop = fetchPointerofObject(i, objOop);
				if (isNonImmediate(oop)) {
					if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						oop = followForwarded(oop);
					}
					if ((isNonImmediate(oop))
					 && (isYoungObject(oop))) {
						hasYoung = 1;
					}
				}
				storePointerUncheckedofObjectwithValue(i, newObj, oop);
			}
			if (hasYoung
			 && (!(isYoungObject(newObj)))) {
				remember(newObj);
			}
		}
		else {
			for (i = 0; i < numSlots; i += 1) {
				storePointerUncheckedofObjectwithValue(i, newObj, fetchPointerofObject(i, objOop));
			}
			if (fmt >= (firstCompiledMethodFormat())) {
				if ((isOldObject(newObj))
				 && ((isYoungObject(objOop))
				 || (isRemembered(objOop)))) {
					remember(newObj);
				}
			}
		}
	}
	return newObj;
}

	/* SpurMemoryManager>>#compactIndexOfClass: */
static sqInt NoDbgRegParms
compactIndexOfClass(sqInt objOop)
{
	assert((rawHashBitsOf(objOop)) != 0);
	return rawHashBitsOf(objOop);
}

	/* SpurMemoryManager>>#computeFreeSpacePostSwizzle */
static void
computeFreeSpacePostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(totalFreeOldSpace) = totalFreeListBytes();
	checkFreeSpace(0);
}


/*	print the count of marked and unmarked objects.
	In addition if 1 is set in printFlags, short-print marked objects,
	and/or if 2 is set, short-print unmarked obejcts. */
/*	useful for debugging */

	/* SpurMemoryManager>>#countMarkedAndUnmarkdObjects: */
void
countMarkedAndUnmarkdObjects(sqInt printFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt nm;
    sqInt nu;
    sqInt obj;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	nm = (nu = 0);
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if (isEnumerableObject(obj)) {
			if (isMarked(obj)) {
				nm += 1;
				if (((printFlags & 1) != 0)) {
					shortPrintOop(obj);
				}
			}
			else {
				nu += 1;
				if (((printFlags & 2) != 0)) {
					shortPrintOop(obj);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	print("n marked: ");
	printNum(nm);
	cr();
	print("n unmarked: ");
	printNum(nu);
	cr();
}


/*	Compute the used size of the class table before swizzling. Needed to
	initialize the classTableBitmap which is populated during adjustAllOopsBy: */

	/* SpurMemoryManager>>#countNumClassPagesPreSwizzle: */
static void NoDbgRegParms
countNumClassPagesPreSwizzle(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTableRoot;
    sqInt firstObj;
    sqInt i;
    sqInt nilObjPreSwizzle;


	/* a.k.a. nilObj */
	/* first five objects are nilObj, falseObj, trueObj, freeListsObj, classTableRootObj */
	firstObj = objectStartingAt(GIV(oldSpaceStart));
	classTableRoot = noInlineObjectAfterlimit(noInlineObjectAfterlimit(noInlineObjectAfterlimit(noInlineObjectAfterlimit(firstObj, GIV(endOfMemory)), GIV(endOfMemory)), GIV(endOfMemory)), GIV(endOfMemory));
	nilObjPreSwizzle = GIV(oldSpaceStart) - bytesToShift;
	GIV(numClassTablePages) = numSlotsOf(classTableRoot);
	assert(GIV(numClassTablePages) == ((classTableRootSlots()) + (hiddenRootSlots())));
	for (i = 2; i < GIV(numClassTablePages); i += 1) {
		if ((fetchPointerofObject(i, classTableRoot)) == nilObjPreSwizzle) {
			GIV(numClassTablePages) = i;
			return;
		}
	}
}

	/* SpurMemoryManager>>#displayObject */
static sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(TheDisplay, GIV(specialObjectsOop));
}


/*	Reduce the number of indexable fields in objOop, a pointer object, to
	nSlots. Convert the
	unused residual to a free chunk. Without changes to
	numSlotsForShortening:toIndexableSize: this only works for arrayFormat and
	longFormat objects.
	Answer the number of bytes returned to free memory, which may be zero if
	no change
	was possible. */

	/* SpurMemoryManager>>#doShorten:toIndexableSize: */
static sqInt NoDbgRegParms
doShortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesBefore;
    sqInt classIndex;
    sqInt copy;
    sqInt delta;
    usqInt followingAddress;
    sqInt format;
    sqInt freeChunk;
    sqInt i;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;


	/* for assert checking */
	followingAddress = addressAfter(objOop);
	assert(oopisLessThanOrEqualTo(followingAddress, GIV(endOfMemory)));
	/* begin numSlotsForShortening:toIndexableSize: */
	switch (formatOf(objOop)) {
	case 2 /* arrayFormat */:
		numSlots = indexableSize;
		break;

	case firstLongFormat():
		numSlots = numSlotsForBytes(indexableSize * 4);
		break;

	default:
		assertf("invalid format for shortening");
		numSlots = 0;;
	}
	bytesBefore = bytesInBody(objOop);

	/* Since the system rounds objects up to 64-bits, losing a 32-bit
	   slot may not actually change the bytes occupied by the object. */
	delta = bytesBefore - (objectBytesForSlots(numSlots));
	if (delta == 0) {
		if (hasOverflowHeader(objOop)) {
			/* begin rawOverflowSlotsOf:put: */
			longAtput(objOop - BaseHeaderSize, numSlots);
		}
		else {
			byteAtput(objOop + 7, numSlots);
		}
		return 0;
	}
	if ((delta <= (allocationUnit()))
	 && (isOldObject(objOop))) {
		format = normalisedFormatForindexableSize(objOop, indexableSize);
		/* begin allocateSlots:format:classIndex: */
		classIndex = classIndexOf(objOop);
		if (numSlots >= (numSlotsMask())) {
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes = largeObjectBytesForSlots(numSlots);
		}
		else {
			newObj = GIV(freeStart);
			numBytes = smallObjectBytesForSlots(numSlots);
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
			}
			copy = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, format, classIndex);
			goto l4;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), numSlots);
			longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
			long64Atput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), format, classIndex));
		}
		else {
			long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(format) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		copy = newObj;
	l4:	/* end allocateSlots:format:classIndex: */;
		if (!copy) {
			error("shorten:toIndexableSize: attempted to shorten by allocationUnit and failed to allocate space for copy!");
		}
		if (isPureBitsFormat(format)) {
			memcpy(firstIndexableField(copy), firstIndexableField(objOop), numBytesOfBitsformat(copy, format));
		}
		else {
			for (i = 0; i < numSlots; i += 1) {
				storePointerUncheckedofObjectwithValue(i, copy, fetchPointerofObject(i, objOop));
			}
		}
		if (isRemembered(objOop)) {
			remember(copy);
		}
		forwardto(objOop, copy);
		return 0;
	}
	if (hasOverflowHeader(objOop)) {
		/* begin rawOverflowSlotsOf:put: */
		longAtput(objOop - BaseHeaderSize, numSlots);
		if (numSlots <= 1) {
			if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
				byteAtput(objOop + 7, numSlots);
				hackSlimBridgeToat(objOop, objOop - (allocationUnit()));
			}
		}
	}
	else {
		assert(numSlots < (numSlotsMask()));
		byteAtput(objOop + 7, numSlots);
	}
	delta = followingAddress - (addressAfter(objOop));
	assert((delta >= (allocationUnit()))
	 && ((delta % (allocationUnit())) == 0));
	if (delta == (allocationUnit())) {
		assert(!((isOldObject(objOop))));
		delta = 0;
		if (followingAddress == GIV(freeStart)) {
			GIV(freeStart) = addressAfter(objOop);
		}
		else {
			hackSlimBridgeToat(followingAddress, addressAfter(objOop));
		}
	}
	else {
		freeChunk = initFreeChunkWithBytesat(delta, addressAfter(objOop));
		assert((objectAfter(objOop)) == freeChunk);
		assert((addressAfter(freeChunk)) == followingAddress);
		if (isInOldSpace(objOop)) {
			GIV(totalFreeOldSpace) += delta;
			addToFreeListbytes(freeChunk, delta);
		}
		else {
			delta = 0;
			setClassIndexOfto(freeChunk, wordSizeClassIndexPun());
			setFormatOfto(freeChunk, firstLongFormat());
		}
	}
	return delta;
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* SpurMemoryManager>>#eeInstantiateClassIndex:format:numSlots: */
usqInt
eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
		? objFormat
		: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	return allocateNewSpaceSlotsformatclassIndex(numSlots, objFormat, knownClassIndex);
}


/*	We use bridges to stitch segments together to make it appear that the heap
	is one contiguous space.
	Bridges at the end of oldSpace segments are maintained. Bridges at the end
	of pastSpace and eden
	are temporary, and are established here, depending on the current sizes of
	pastSpace end eden.
	
	N.B. this introduces complications. Either or both pastSpace and eden may
	be empty, so the 
	bridge from pastSpace may skip eden. pastSpace may be full, so there may
	be no bridge at
	the end of pastSpace. Most difficult, pastSpace could be one 64-bit word
	short of full, but normal
	bridges are two word objects. To make this work we introduce a hack,
	objectAfterMaybeSlimBridge:limit:, which uses a fake overflow slot count
	to get to the start of the next object, which is either one or two
	words away, depending on whether the first object in eden has a normal or
	an overflow header. */

	/* SpurMemoryManager>>#enableObjectEnumerationFrom: */
static void NoDbgRegParms
enableObjectEnumerationFrom(sqInt initialObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (oopisLessThan(initialObject, GIV(oldSpaceStart))) {
		if (GIV(freeStart) > (((eden()).start))) {
			/* begin bridgeEdenAndOldSpace */
			initSegmentBridgeWithBytesat(GIV(oldSpaceStart) - GIV(freeStart), GIV(freeStart));
			/* begin bridgePastSpaceAndEden */
			if (GIV(pastSpaceStart) < (((eden()).start))) {

				/* past space can be entirely full (!!) */
				if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

					/* No room for a full bridge (!!); use the slim bridge hack */
					hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
					assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
				}
				else {

					/* Room for a regular bridge; this is straight-forward */
					initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
				}
			}
		}
		else {

			/* If eden is empty (e.g. at snapshot time), skip it entirely */
			/* begin bridgePastSpaceAndOldSpace */
			initSegmentBridgeWithBytesat(GIV(oldSpaceStart) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such as
	the markStack or the ephemeronQueue. It is a linked list of segments,
	with the hot end at the head of the list. It is a word object. The stack
	pointer is in ObjStackTopx and 0 means empty. The list goes through
	ObjStackNextx. We don't want to shrink objStacks, since they're used
	in GC and its good to keep their memory around. So unused pages
	created by popping emptying pages are kept on the ObjStackFreex list. */

	/* SpurMemoryManager>>#ensureRoomOnObjStackAt: */
static sqInt NoDbgRegParms
ensureRoomOnObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classIndex1;
    sqInt formatField;
    sqInt formatField1;
    sqInt freeOrNewPage;
    sqInt stackOrNil;

	stackOrNil = fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj));
	if ((stackOrNil == GIV(nilObj))
	 || ((fetchPointerofObject(ObjStackTopx, stackOrNil)) >= ObjStackLimit)) {
		freeOrNewPage = (stackOrNil == GIV(nilObj)
			? 0
			: fetchPointerofObject(ObjStackFreex, stackOrNil));
		if (freeOrNewPage != 0) {

			/* the free page list is always on the new page. */
			storePointerofObjStackwithValue(ObjStackFreex, stackOrNil, 0);
			assert((!GIV(marking))
			 || (isMarked(freeOrNewPage)));
		}
		else {
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			formatField1 = wordIndexableFormat();
			classIndex1 = wordSizeClassIndexPun();
			freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, objectBytesForSlots(ObjStackPageSlots), formatField1, classIndex1);
			if (!freeOrNewPage) {

				/* Allocate a new segment an retry. This is very uncommon. But it happened to me (Clement). */
				growOldSpaceByAtLeast(ObjStackPageSlots * BytesPerOop);
				/* begin allocateSlotsInOldSpace:format:classIndex: */
				formatField = wordIndexableFormat();
				classIndex = wordSizeClassIndexPun();
				freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, objectBytesForSlots(ObjStackPageSlots), formatField, classIndex);
				if (!freeOrNewPage) {
					error("no memory to allocate or extend obj stack");
				}
			}
			storePointerofObjStackwithValue(ObjStackFreex, freeOrNewPage, 0);
			if (GIV(marking)) {
				setIsMarkedOfto(freeOrNewPage, 1);
			}
		}
		storePointerofObjStackwithValue(ObjStackMyx, freeOrNewPage, objStackRootIndex);
		storePointerofObjStackwithValue(ObjStackNextx, freeOrNewPage, (stackOrNil == GIV(nilObj)
			? 0
			: stackOrNil));
		storePointerofObjStackwithValue(ObjStackTopx, freeOrNewPage, 0);
		storePointerofObjectwithValue(objStackRootIndex, GIV(hiddenRootsObj), freeOrNewPage);
		assert(isValidObjStackAt(objStackRootIndex));
		stackOrNil = updateRootOfObjStackAtwith(objStackRootIndex, freeOrNewPage);
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return stackOrNil;
}


/*	Enter aBehavior into the class table and answer 0. Otherwise answer a
	primitive failure code. */

	/* SpurMemoryManager>>#enterIntoClassTable: */
static sqInt NoDbgRegParms
enterIntoClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt formatField;
    sqInt i;
    sqInt iLimiT;
    sqInt initialMajorIndex;
    sqInt majorIndex;
    sqInt minorIndex;
    sqInt numSlots;
    sqInt numSlots1;
    usqInt p;
    sqInt page;

	majorIndex = ((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift());

	/* classTableIndex should never index the first page; it's reserved for known classes */
	initialMajorIndex = majorIndex;
	assert(initialMajorIndex > 0);
	minorIndex = GIV(classTableIndex) & (classTableMinorIndexMask());
	while (1) {
		page = fetchPointerofObject(majorIndex, GIV(hiddenRootsObj));
		if (page == GIV(nilObj)) {
			/* begin allocateSlotsInOldSpace:format:classIndex: */
			numSlots = classTablePageSize();
			formatField = 2 /* arrayFormat */;
			classIndex = arrayClassIndexPun();
			page = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), formatField, classIndex);
			if (!page) {
				return PrimErrNoMemory;
			}
			/* begin fillObj:numSlots:with: */
			numSlots1 = classTablePageSize();
			assert(oopisLessThan(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1, addressAfter(page)));
			for (p = (((usqInt)(page + BaseHeaderSize))); p <= (((usqInt)(((page + BaseHeaderSize) + (numSlots1 * BytesPerOop)) - 1))); p += (allocationUnit())) {
				longAtput(p, GIV(nilObj));
				longAtput(p + 4, GIV(nilObj));
			}
			storePointerofObjectwithValue(majorIndex, GIV(hiddenRootsObj), page);
			GIV(numClassTablePages) += 1;
			minorIndex = 0;
		}
		for (i = minorIndex, iLimiT = ((classTablePageSize()) - 1); i <= iLimiT; i += 1) {
			if ((fetchPointerofObject(i, page)) == GIV(nilObj)) {

				/* classTableIndex must never index the first page, which is reserved for classes known to the VM. */
				GIV(classTableIndex) = (((sqInt)((usqInt)(majorIndex) << (classTableMajorIndexShift())))) + i;
				assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
				storePointerofObjectwithValue(i, page, aBehavior);
				setHashBitsOfto(aBehavior, GIV(classTableIndex));
				assert((classAtIndex(rawHashBitsOf(aBehavior))) == aBehavior);
				return 0;
			}
		}
		majorIndex = ((((majorIndex + 1) & (classIndexMask())) < 1) ? 1 : ((majorIndex + 1) & (classIndexMask())));
		if (majorIndex == initialMajorIndex) {

			/* wrapped; table full */
			return PrimErrLimitExceeded;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#ephemeronFormat */
static sqInt
ephemeronFormat(void)
{
	return 5;
}

	/* SpurMemoryManager>>#falseObject */
sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* SpurMemoryManager>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt objOop)
{
	return byteAt((objOop + BaseHeaderSize) + byteIndex);
}

	/* SpurMemoryManager>>#fetchClassOfNonImm: */
static sqInt NoDbgRegParms NeverInline
fetchClassOfNonImm(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = classIndexOf(objOop);
	if (classIndex <= (classIsItselfClassIndexPun())) {
		if (classIndex == (classIsItselfClassIndexPun())) {
			return objOop;
		}
		if (classIndex == (isForwardedObjectClassIndexPun())) {
			return GIV(nilObj);
		}
	}
	assert(classIndex >= (arrayClassIndexPun()));
	return classOrNilAtIndex(classIndex);
}

	/* SpurMemoryManager>>#fetchClassOf: */
static sqInt NoDbgRegParms
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt tagBits;

	return (((tagBits = oop & (tagMask()))) != 0
		? fetchPointerofObject(tagBits, GIV(classTableFirstPage))
		: fetchClassOfNonImm(oop));
}


/*	In Spur an object's classIndex is the tag in all method caches. */

	/* SpurMemoryManager>>#fetchClassTagOfNonImm: */
static sqInt NoDbgRegParms
fetchClassTagOfNonImm(sqInt obj)
{
	return classIndexOf(obj);
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* SpurMemoryManager>>#fetchLong32:ofObject: */
static sqInt NoDbgRegParms
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))));
}

	/* SpurMemoryManager>>#fetchLong64:ofObject: */
static sqLong NoDbgRegParms
fetchLong64ofObject(sqInt longIndex, sqInt objOop)
{
	return long64At((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(longIndex) << 3))));
}

	/* SpurMemoryManager>>#fetchPointer:ofFreeChunk: */
static sqInt NoDbgRegParms
fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchPointer:ofMaybeForwardedObject: */
static sqInt NoDbgRegParms
fetchPointerofMaybeForwardedObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchShort16:ofObject: */
static sqInt NoDbgRegParms
fetchShort16ofObject(sqInt shortIndex, sqInt objOop)
{
	return shortAt((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(shortIndex) << 1))));
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */
/*	useful for debugging */

	/* SpurMemoryManager>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	aCStringStrlen = strlen(aCString);
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if (objectequalsStringofSize(obj1, aCString, aCStringStrlen)) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				printNum(lengthOfformat(obj1, formatOf(obj1)));
				/* begin space */
				printChar(' ');
				/* begin printOopShort: */
				printOopShortInner(obj1);
				/* begin flush */
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* SpurMemoryManager>>#findString: */
void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	aCStringStrlen = strlen(aCString);
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if (objectequalsStringofSize(obj1, aCString, aCStringStrlen)) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				/* begin printOopShort: */
				printOopShortInner(obj1);
				/* begin flush */
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}

	/* SpurMemoryManager>>#firstFixedField: */
static void * NoDbgRegParms
firstFixedField(sqInt objOop)
{
	return pointerForOop(objOop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes.
	There are only two important cases, both for objects with named inst vars,
	i.e. formats 2,3 & 5.
	The first indexable field for formats 2 & 5 is the slot count (by
	convention, even though that's off the end
	of the object). For 3 we must go to the class. */

	/* SpurMemoryManager>>#firstIndexableField: */
static void * NoDbgRegParms
firstIndexableField(sqInt objOop)
{
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;

	fmt = formatOf(objOop);
	if (fmt <= (weakArrayFormat())) {
		if (fmt == 2 /* arrayFormat */) {

			/* array starts at 0. */
			return pointerForOop(objOop + BaseHeaderSize);
		}
		if (fmt >= (indexablePointersFormat())) {

			/* indexable with inst vars; need to delve into the class format word */
			/* begin formatOfClass: */
			classPointer = fetchClassOfNonImm(objOop);
			classFormat = ((fetchPointerofObject(InstanceSpecificationIndex, classPointer)) >> 1);
			return pointerForOop((objOop + BaseHeaderSize) + (((sqInt)((usqInt)((fixedFieldsOfClassFormat(classFormat))) << (shiftForWord())))));
		}
		return 0;
	}
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 && (fmt < (firstCompiledMethodFormat()))) {
		return pointerForOop(objOop + BaseHeaderSize);
	}
	return 0;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormatMask */
sqInt
fixedFieldsOfClassFormatMask(void)
{
	return (1U << (fixedFieldsFieldWidth())) - 1;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormat: */
sqInt
fixedFieldsOfClassFormat(sqInt classFormat)
{
	return classFormat & (fixedFieldsOfClassFormatMask());
}

	/* SpurMemoryManager>>#fixedFieldsOfClass: */
static sqInt NoDbgRegParms
fixedFieldsOfClass(sqInt objOop)
{
	return fixedFieldsOfClassFormat(((fetchPointerofObject(InstanceSpecificationIndex, objOop)) >> 1));
}

	/* SpurMemoryManager>>#fixedFieldsOf:format:length: */
static sqInt NoDbgRegParms
fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength)
{
    sqInt class;


	/* N.B. written to fall through to fetchClassOfNonImm: et al for forwarders
	   so as to trigger an assert fail. */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2 /* arrayFormat */)) {
		return 0;
	}
	if (fmt < 2 /* arrayFormat */) {
		return wordLength;
	}
	class = fetchClassOfNonImm(objOop);
	return fixedFieldsOfClassFormat(((fetchPointerofObject(InstanceSpecificationIndex, class)) >> 1));
}


/*	Private helper for followField:ofObject: to avoid code duplication for
	rare case.
 */

	/* SpurMemoryManager>>#fixFollowedField:ofObject:withInitialValue: */
static sqInt NoDbgRegParms NeverInline
fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue)
{
    sqInt objOop;

	assert(isOopForwarded(initialValue));
	objOop = initialValue;
	do {
		objOop = fetchPointerofMaybeForwardedObject(0, objOop);
	} while(isOopForwarded(objOop));
	storePointerofObjectwithValue(fieldIndex, anObject, objOop);
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#followField:ofObject: */
static sqInt NoDbgRegParms
followFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = fetchPointerofObject(fieldIndex, anObject);
	if (isOopForwarded(objOop)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}


/*	Follow pointers in the object to depth.
	Answer if any forwarders were found.
	How to avoid cyclic structures?? A temporary mark bit? eem 6/22/2020 no
	need since depth is always finite. */

	/* SpurMemoryManager>>#followForwardedObjectFields:toDepth: */
static sqInt NoDbgRegParms
followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt found;
    sqInt header;
    sqInt i;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt oop;
    sqInt sp;

	found = 0;
	assert((isPointers(objOop))
	 || (isOopCompiledMethod(objOop)));
	/* begin numPointerSlotsOf: */
	fmt = formatOf(objOop);
	/* begin numPointerSlotsOf:format: */
	if (fmt <= (lastPointerFormat())) {
		if ((fmt == (indexablePointersFormat()))
		 && ((classIndexOf(objOop)) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = fetchPointerofObject(StackPointerIndex, objOop);
			if (!((sp & 1))) {
				contextSize = 0;
				goto l2;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
			contextSize = (sp >> 1);
	l2:	/* end fetchStackPointerOf: */;
			numSlots = CtxtTempFrameStart + contextSize;
			goto l3;
		}
		numSlots = numSlotsOf(objOop);
		goto l3;
	}
	if (fmt == (forwardedFormat())) {
		numSlots = 1;
		goto l3;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		numSlots = 0;
		goto l3;
	}
	header = methodHeaderOf(objOop);
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((header >> 1)) & AlternateHeaderNumLiteralsMask;
	numSlots = numLiterals + LiteralStart;
	l3:	/* end numPointerSlotsOf: */;
	for (i = 0; i < numSlots; i += 1) {
		oop = fetchPointerofObject(i, objOop);
		if (isNonImmediate(oop)) {
			if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				found = 1;
				oop = followForwarded(oop);
				storePointerofObjectwithValue(i, objOop, oop);
			}
			if ((depth > 0)
			 && (((isNonImmediate(oop))
			 && (isAnyPointerFormat(formatOf(oop))))
			 && (followForwardedObjectFieldstoDepth(oop, depth - 1)))) {
				found = 1;
			}
		}
	}
	return found;
}


/*	Follow a forwarding pointer. THis must be a loop because we cannot prevent
	forwarders to
	forwarders being created by lazy become. Consider the following example by
	Igor Stasenko:
	array := { a. b. c }.
	- array at: 1 points to &a. array at: 2 points to &b. array at: 3 points
	to &c
	a becomeForward: b
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	b becomeForward: c.
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	- when accessing array first one has to follow a forwarding chain:
	&a -> &b -> c */

	/* SpurMemoryManager>>#followForwarded: */
sqInt
followForwarded(sqInt objOop)
{
    sqInt referent;

	assert(isUnambiguouslyForwarder(objOop));
	referent = fetchPointerofMaybeForwardedObject(0, objOop);
	while (isOopForwarded(referent)) {
		referent = fetchPointerofMaybeForwardedObject(0, referent);
	}
	return referent;
}

	/* SpurMemoryManager>>#followMaybeForwarded: */
static sqInt NoDbgRegParms
followMaybeForwarded(sqInt objOop)
{
	return (isOopForwarded(objOop)
		? noInlineFollowForwarded(objOop)
		: objOop);
}

	/* SpurMemoryManager>>#followSpecialObjectsOop */
static void
followSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((!((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		GIV(validatedIntegerClassFlags) = 0;
		GIV(specialObjectsOop) = followForwarded(GIV(specialObjectsOop));
	}
	followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
}

	/* SpurMemoryManager>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer)
{
	return ((fetchPointerofObject(InstanceSpecificationIndex, classPointer)) >> 1);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable	(11 unused in 32 bits)
	12 - 15 16-bit indexable	(14 & 15 unused in 32-bits)
	16 - 23 byte indexable		(20-23 unused in 32-bits)
	24 - 31 compiled method	(28-31 unused in 32-bits) */
/*	A note on performance. Since the format field is, by design, aligned on a
	byte boundary
	in the fourth byte of the header we could access it via
	^(self byteAt: objOop + 3) bitAnd: self formatMask
	but al least on e.g. Core i7 x86-64 using the clang 6 compiler, this makes
	no difference,
	or at least any change is in the noise. */

	/* SpurMemoryManager>>#formatOf: */
static sqInt NoDbgRegParms
formatOf(sqInt objOop)
{
	return (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
}


/*	A special format used by the GC to follow only the first pointer. */

	/* SpurMemoryManager>>#forwardedFormat */
static sqInt
forwardedFormat(void)
{
	return 7;
}

	/* SpurMemoryManager>>#forward:to: */
static void NoDbgRegParms
forwardto(sqInt obj1, sqInt obj2)
{
    sqInt classIndex;
    sqInt format;

	/* begin set:classIndexTo:formatTo: */
	classIndex = isForwardedObjectClassIndexPun();
	format = forwardedFormat();
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	assert(((format >= 0) && (format <= (formatMask()))));
	flag("endianness");
	longAtput(obj1, ((longAt(obj1)) & ((unsigned int)~((((sqInt)((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + (classIndex + (((sqInt)((usqInt)(format) << (formatShift()))))));
#  if IMMUTABILITY
	setIsImmutableOfto(obj1, 0);
#  endif
	storePointerofForwarderwithValue(0, obj1, obj2);
	if ((byteAt(obj1 + 7)) == 0) {
		byteAtput(obj1 + 7, 1);
	}
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkLargerIndex */
static sqInt
freeChunkLargerIndex(void)
{
	return 4;
}


/*	for linking objecs on each free list, or, during pigCompact, doubly-
	linking the free objects in address order using the xor link hack. */

	/* SpurMemoryManager>>#freeChunkNextIndex */
static sqInt
freeChunkNextIndex(void)
{
	return 0;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkParentIndex */
static sqInt
freeChunkParentIndex(void)
{
	return 2;
}


/*	For linking objecs on each free list, doubly-linking the free objects.
	Free chunks of size 1 do not have a prev index. */

	/* SpurMemoryManager>>#freeChunkPrevIndex */
static sqInt
freeChunkPrevIndex(void)
{
	return 1;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkSmallerIndex */
static sqInt
freeChunkSmallerIndex(void)
{
	return 3;
}

	/* SpurMemoryManager>>#freeChunkWithBytes:at: */
static sqInt NoDbgRegParms
freeChunkWithBytesat(sqInt bytes, sqInt address)
{
    sqInt freeChunk;

	assert(isInOldSpace(address));
	assert((segmentContainingObj(address)) == (segmentContainingObj(address + bytes)));
	freeChunk = initFreeChunkWithBytesat(bytes, address);
	addToFreeListbytes(freeChunk, bytes);
	assert(freeChunk == (objectStartingAt(address)));
	return freeChunk;
}


/*	Free an object in oldSpace. Coalesce if possible to reduce fragmentation. */

	/* SpurMemoryManager>>#freeObject: */
sqInt
freeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytes;
    usqInt chunkBytes;
    sqInt next;
    usqInt start;

	assert(isInOldSpace(objOop));
	if (isRemembered(objOop)) {
		forgetObject(objOop);
	}
	bytes = bytesInBody(objOop);
	start = startOfObject(objOop);
	next = objectStartingAt(start + bytes);
	if (isFreeObject(next)) {
		/* begin detachFreeObject: */
		chunkBytes = bytesInBody(next);
		GIV(totalFreeOldSpace) -= chunkBytes;
		unlinkFreeChunkchunkBytes(next, chunkBytes);
		bytes += bytesInBody(next);
	}
	GIV(totalFreeOldSpace) += bytes;
	return freeChunkWithBytesat(bytes, start);
}

	/* SpurMemoryManager>>#hasOverflowHeader: */
static sqInt NoDbgRegParms
hasOverflowHeader(sqInt objOop)
{
	return (byteAt(objOop + 7)) == (numSlotsMask());
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,isExtraAligned})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:format:classIndex: */
usqLong
headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{
	return (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + classIndex;
}


/*	Answer the number of extra root slots in the root of the hidden root
	object. 
 */

	/* SpurMemoryManager>>#hiddenRootSlots */
static sqInt
hiddenRootSlots(void)
{
	return 8;
}

	/* SpurMemoryManager>>#identityHashFieldWidth */
static sqInt
identityHashFieldWidth(void)
{
	return 22;
}


/*	mask the immutable bit in the base header word */

	/* SpurMemoryManager>>#immutableBitMask */
#if IMMUTABILITY
sqInt
immutableBitMask(void)
{
	return 1U << (immutableBitShift());
}
#endif /* IMMUTABILITY */


/*	The selector incrementalGC refers to the V3 incremental collector, which
	is the collector for young objects, equivalent in function to the
	scavenger. The Spur incremental collector is called the global incremental
	garbage collector or globalIGC for short.
 */

	/* SpurMemoryManager>>#incrementalGC */
static void
incrementalGC(void)
{
	error("shouldNotImplement");
}


/*	Part of reorderReversedTreeList:. Switch treeNode with newNode in
	the tree, but do nothing to the list linked through freeChunkNextIndex. */

	/* SpurMemoryManager>>#inFreeTreeReplace:with: */
static void NoDbgRegParms
inFreeTreeReplacewith(sqInt treeNode, sqInt newNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt relative;

	storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, newNode, 0);
	for (i = 2 /* freeChunkParentIndex */, iLimiT = (freeChunkLargerIndex()); i <= iLimiT; i += 1) {
		relative = fetchPointerofFreeChunk(i, treeNode);
		if (i == 2 /* freeChunkParentIndex */) {
			if (relative == 0) {

				/* update root to point to newNode */
				assert((GIV(freeLists)[0]) == treeNode);
				GIV(freeLists)[0] = newNode;
			}
			else {

				/* replace link from parent to treeNode with link to newNode. */
				storePointerofFreeChunkwithValue((treeNode == (fetchPointerofFreeChunk(freeChunkSmallerIndex(), relative))
					? freeChunkSmallerIndex()
					: freeChunkLargerIndex()), relative, newNode);
			}
		}
		else {
			if (relative != 0) {
				assert((fetchPointerofFreeChunk(freeChunkParentIndex(), relative)) == treeNode);
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, relative, newNode);
			}
		}
		storePointerofFreeChunkwithValue(i, newNode, relative);
		storePointerofFreeChunkwithValue(i, treeNode, 0);
	}
}

	/* SpurMemoryManager>>#initFreeTreeChunk:bytes: */
static void NoDbgRegParms
initFreeTreeChunkbytes(sqInt freeChunk, sqInt chunkBytes)
{
	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInBody(freeChunk)));
	assert(chunkBytes >= ((numFreeLists()) * (allocationUnit())));
	storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, freeChunk, 0);
	storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, freeChunk, 0);
	storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeChunk, 0);
	storePointerofFreeChunkwithValue(freeChunkSmallerIndex(), freeChunk, 0);
	storePointerofFreeChunkwithValue(freeChunkLargerIndex(), freeChunk, 0);
}


/*	Reinitialize the free list info. The freeLists object needs to be swizzled
	because its neither a free, nor a pointer object. Free objects have
	already been swizzled in adjustAllOopsBy: */

	/* SpurMemoryManager>>#initializeFreeSpacePostLoad: */
static void NoDbgRegParms
initializeFreeSpacePostLoad(sqInt freeListObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	assert((numSlotsOf(freeListObj)) == (numFreeLists()));
	assert((formatOf(freeListObj)) == (wordIndexableFormat()));
	GIV(freeLists) = firstIndexableField(freeListObj);
	GIV(freeListsMask) = 0;
	for (i = 0, iLimiT = ((numFreeLists()) - 1); i <= iLimiT; i += 1) {
		if ((GIV(freeLists)[i]) != 0) {
			GIV(freeListsMask) = GIV(freeListsMask) | (1U << i);
			GIV(freeLists)[i] = (swizzleObjin(GIV(freeLists)[i], freeListObj));
		}
	}
}

	/* SpurMemoryManager>>#initializeNewSpaceVariables */
static void NeverInline
initializeNewSpaceVariables(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(scavengeThreshold) = ((((eden()).limit)) - ((((GIV(eden).limit)) - ((GIV(eden).start))) / 64));
	GIV(newSpaceStart) = (((((pastSpace()).start)) < (((futureSpace()).start))) ? (((pastSpace()).start)) : (((futureSpace()).start)));
	assert(GIV(newSpaceStart) < (((eden()).start)));
}


/*	Initialize object memory variables at startup time. Assume endOfMemory at
	al are
	initialised by the image-reading code via
	setHeapBase:memoryLimit:endOfMemory:. endOfMemory is assumed to point to
	the end of the last object in the image.
	Assume: image reader also initializes the following variables:
	specialObjectsOop
	lastHash */
/*	Catch mis-initializations leading to bad translations to C */

	/* SpurMemoryManager>>#initializeObjectMemory: */
static void NoDbgRegParms
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeListObj;

	assert(BaseHeaderSize == BaseHeaderSize);
	assert((((sqInt)((maxSlotsForAlloc()) * BytesPerWord))) > 0);
	initSegmentBridgeWithBytesat(bridgeSize(), GIV(endOfMemory) - (bridgeSize()));
	adjustSegmentSwizzlesBy(bytesToShift);
	adjustAllOopsBy(bytesToShift);

	/* heavily used special objects */
	GIV(specialObjectsOop) = swizzleObj(GIV(specialObjectsOop));
	GIV(nilObj) = fetchPointerofObject(NilObject, GIV(specialObjectsOop));
	GIV(falseObj) = fetchPointerofObject(FalseObject, GIV(specialObjectsOop));

	/* In Cog we insist that nil, true & false are next to each other (Cogit generates tighter
	   conditional branch code as a result).  In addition, Spur places the free lists and
	   class table root page immediately following them. */
	GIV(trueObj) = fetchPointerofObject(TrueObject, GIV(specialObjectsOop));
	assert(GIV(nilObj) == GIV(oldSpaceStart));
	assert(GIV(falseObj) == (oldSpaceObjectAfter(GIV(nilObj))));
	assert(GIV(trueObj) == (oldSpaceObjectAfter(GIV(falseObj))));
	freeListObj = oldSpaceObjectAfter(GIV(trueObj));
	setHiddenRootsObj(oldSpaceObjectAfter(freeListObj));
	GIV(markStack) = swizzleObjStackAt(MarkStackRootIndex);
	GIV(weaklingStack) = swizzleObjStackAt(WeaklingStackRootIndex);
	GIV(mournQueue) = swizzleObjStackAt(MournQueueRootIndex);
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	initializeFreeSpacePostLoad(freeListObj);
	collapseSegmentsPostSwizzle();
	updateFreeLists();
	computeFreeSpacePostSwizzle();
	initializeOldSpaceFirstFree(GIV(freeOldSpaceStart));
	initializeNewSpaceVariables();
	initializeRememberedSet();
	checkSegments();
	/* begin biasForGC */
	GIV(biasForGC) = 1;

	/* headroom when growing */
	GIV(growHeadroom) = 0x1000000;

	/* free space before shrinking */
	GIV(shrinkThreshold) = 0x2000000;
	/* begin setHeapSizeAtPreviousGC */
	GIV(heapSizeAtPreviousGC) = (totalOldSpaceCapacity()) - GIV(totalFreeOldSpace);
	/* begin resetAllocationAccountingAfterGC */
	GIV(oldSpaceUsePriorToScavenge) = (totalOldSpaceCapacity()) - GIV(totalFreeOldSpace);

	/* By default GC after scavenge if heap has grown by a third since the last GC */
	GIV(heapGrowthToSizeGCRatio) = 0.333333;
}

	/* SpurMemoryManager>>#initializeOldSpaceFirstFree: */
static void NoDbgRegParms
initializeOldSpaceFirstFree(usqInt startOfFreeOldSpace)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;
    usqInt freeOldStart;
    usqInt limit;

	limit = GIV(endOfMemory) - (bridgeSize());
	if (limit > startOfFreeOldSpace) {
		GIV(totalFreeOldSpace) += limit - startOfFreeOldSpace;
		freeOldStart = startOfFreeOldSpace;
		if (freeOldStart < limit) {
			freeChunk = freeChunkWithBytesat(limit - freeOldStart, freeOldStart);
			assert((addressAfter(freeChunk)) == limit);
		}
	}
	GIV(endOfMemory) -= bridgeSize();
	GIV(freeOldSpaceStart) = GIV(endOfMemory);
	checkFreeSpace(GCCheckFreeSpace);
}


/*	print free chunks in freeTree in order. */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#inOrderPrintFreeTree:printList: */
void
inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList)
{
    sqInt next;

	if (((next = fetchPointerofFreeChunk(freeChunkSmallerIndex(), freeChunk))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
	printFreeChunkprintAsTreeNode(freeChunk, 1);
	if (printNextList) {
		next = freeChunk;
		while (((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, next))) != 0) {
			/* begin tab */
			printChar('\t');
			printFreeChunkprintAsTreeNode(next, 0);
		}
	}
	if (((next = fetchPointerofFreeChunk(freeChunkLargerIndex(), freeChunk))) != 0) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* SpurMemoryManager>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj)
{
	assert(addressCouldBeClassObj(classObj));
	return (((fetchPointerofObject(InstanceSpecificationIndex, classObj)) >> 1)) & (fixedFieldsOfClassFormatMask());
}

	/* SpurMemoryManager>>#instSpecOfClassFormat: */
sqInt
instSpecOfClassFormat(sqInt classFormat)
{
	return (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
}


/*	This field in a class's format inst var corresponds to the 5-bit format
	field stored in every object header
 */

	/* SpurMemoryManager>>#instSpecOfClass: */
static sqInt NoDbgRegParms
instSpecOfClass(sqInt classPointer)
{
	return instSpecOfClassFormat(((fetchPointerofObject(InstanceSpecificationIndex, classPointer)) >> 1));
}

	/* SpurMemoryManager>>#invalidCompactClassError: */
static void NoDbgRegParms
invalidCompactClassError(const char *className)
{
	printf("\nClass %s does not have the required class index\n", className);
	exit(-1);
}


/*	the inverse of isPureBitsFormat: */

	/* SpurMemoryManager>>#isAnyPointerFormat: */
static sqInt NoDbgRegParms
isAnyPointerFormat(sqInt format)
{
	return (format <= (lastPointerFormat()))
	 || (format >= (firstCompiledMethodFormat()));
}


/*	Answer if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArrayNonImm: */
static sqInt NoDbgRegParms
isArrayNonImm(sqInt oop)
{
	return (formatOf(oop)) == 2 /* arrayFormat */;
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArray: */
static sqInt NoDbgRegParms
isArray(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isArrayNonImm(oop));
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isBytesNonImm: */
static sqInt NoDbgRegParms
isBytesNonImm(sqInt objOop)
{
	return (formatOf(objOop)) >= (firstByteFormat());
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* SpurMemoryManager>>#isBytes: */
static sqInt NoDbgRegParms
isBytes(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isBytesNonImm(oop));
}

	/* SpurMemoryManager>>#isCharacterObject: */
sqInt
isCharacterObject(sqInt oop)
{
	/* begin isImmediateCharacter: */
	return (oop & (tagMask())) == (characterTag());
}

	/* SpurMemoryManager>>#isCharacterValue: */
sqInt
isCharacterValue(sqInt anInteger)
{
	return isInRangeCharacterCode(anInteger);
}


/*	Answer whether the argument object is of compiled method format */

	/* SpurMemoryManager>>#isCompiledMethod: */
sqInt
isCompiledMethod(sqInt objOop)
{
	return (formatOf(objOop)) >= (firstCompiledMethodFormat());
}

	/* SpurMemoryManager>>#isEmptyObjStack: */
static sqInt NoDbgRegParms
isEmptyObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		return 1;
	}
	eassert(isValidObjStack(objStack));
	return (0 == (fetchPointerofObject(ObjStackTopx, objStack)))
	 && (0 == (fetchPointerofObject(ObjStackNextx, objStack)));
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	Non-objects should be excluded; these are bridges and free chunks. */

	/* SpurMemoryManager>>#isEnumerableObject: */
static sqInt NoDbgRegParms
isEnumerableObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = classIndexOf(objOop);
	assert((classIndex == (segmentBridgePun()))
	 || ((classIndex == (isForwardedObjectClassIndexPun()))
	 || (((long64At(objOop)) != 0)
	 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
	return classIndex >= (isForwardedObjectClassIndexPun());
}

	/* SpurMemoryManager>>#isEphemeron: */
static sqInt NoDbgRegParms
isEphemeron(sqInt objOop)
{
    sqInt format;

	assert(isNonImmediate(objOop));
	/* begin isEphemeronFormat: */
	format = formatOf(objOop);
	return format == (ephemeronFormat());
}

	/* SpurMemoryManager>>#isFixedSizePointerFormat: */
sqInt
isFixedSizePointerFormat(sqInt format)
{
	return (format <= 1 /* nonIndexablePointerFormat */)
	 || (format == (ephemeronFormat()));
}


/*	Answer if objOop is that if a forwarder. Take advantage of
	isForwardedObjectClassIndexPun being a power of two to generate a more
	efficient test than the straight-forward
	(self classIndexOf: objOop) = self isForwardedObjectClassIndexPun
	at the cost of this being ambiguous with free chunks. So either never
	apply this to free chunks
	or guard with (self isFreeObject: foo) not. So far the idiom has been to
	guard with isFreeObject: */
/*	self assert: (self isFreeObject: objOop) not. */

	/* SpurMemoryManager>>#isForwarded: */
sqInt
isForwarded(sqInt objOop)
{
	return (!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))));
}

	/* SpurMemoryManager>>#isFreeObject: */
static sqInt NoDbgRegParms
isFreeObject(sqInt objOop)
{
	return (classIndexOf(objOop)) == (isFreeObjectClassIndexPun());
}

	/* SpurMemoryManager>>#isFreeOop: */
static sqInt NoDbgRegParms
isFreeOop(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isFreeObject(oop));
}

	/* SpurMemoryManager>>#isGrey: */
static sqInt NoDbgRegParms
isGrey(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (greyBitShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isHiddenObj: */
static sqInt NoDbgRegParms
isHiddenObj(sqInt objOop)
{
	return (classIndexOf(objOop)) <= (lastClassIndexPun());
}

	/* SpurMemoryManager>>#isImmediate: */
sqInt
isImmediate(sqInt oop)
{
	return ((oop & (tagMask())) != 0);
}

	/* SpurMemoryManager>>#isImmutable: */
static sqInt NoDbgRegParms
isImmutable(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (immutableBitShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isIndexableFormat: */
static sqInt NoDbgRegParms
isIndexableFormat(sqInt format)
{
	return (format >= 2 /* arrayFormat */)
	 && ((format <= (weakArrayFormat()))
	 || (format >= (sixtyFourBitIndexableFormat())));
}

	/* SpurMemoryManager>>#isIndexable: */
static sqInt NoDbgRegParms
isIndexable(sqInt objOop)
{
    sqInt fmt;

	fmt = formatOf(objOop);
	return isIndexableFormat(fmt);
}

	/* SpurMemoryManager>>#isInEden: */
static sqInt NoDbgRegParms
isInEden(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(objOop, ((eden()).start), GIV(freeStart));
}

	/* SpurMemoryManager>>#isInFutureSpace: */
static sqInt NoDbgRegParms
isInFutureSpace(sqInt address)
{
	return oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), futureSurvivorStart());
}


/*	Answer if the given address is within the entire range ST object memory.
	For quick checking during leak checking only! */

	/* SpurMemoryManager>>#isInHeapBounds: */
static sqInt NoDbgRegParms
isInHeapBounds(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThanOrEqualTo(address, GIV(newSpaceStart)))
	 && (oopisLessThan(address, GIV(endOfMemory)));
}


/*	Answer if the given address is in ST object memory. */

	/* SpurMemoryManager>>#isInMemory: */
static sqInt NoDbgRegParms
isInMemory(sqInt address)
{
	if (isInNewSpace(address)) {
		return (isInEden(address))
		 || ((isInPastSpace(address))
		 || ((scavengeInProgress())
		 && (isInFutureSpace(address))));
	}
	return isInSegments(address);
}

	/* SpurMemoryManager>>#isInNewSpace: */
static sqInt NoDbgRegParms
isInNewSpace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisLessThan(objOop, GIV(oldSpaceStart)))
	 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart)));
}

	/* SpurMemoryManager>>#isInOldSpace: */
sqInt
isInOldSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory));
}

	/* SpurMemoryManager>>#isInPastSpace: */
static sqInt NoDbgRegParms
isInPastSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart));
}

	/* SpurMemoryManager>>#isInRangeCharacterCode: */
static sqInt NoDbgRegParms
isInRangeCharacterCode(sqInt characterCode)
{
	return ((characterCode >= 0) && (characterCode <= (0x3FFFFFFF)));
}


/*	Answer if the oop is a large negative integer instance. */

	/* SpurMemoryManager>>#isInstanceOfClassLargeNegativeInteger: */
static sqInt NoDbgRegParms
isInstanceOfClassLargeNegativeInteger(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassLargeNegativeIntegerCompactIndex);
}


/*	Answer if the oop is a large positive integer instance. */

	/* SpurMemoryManager>>#isInstanceOfClassLargePositiveInteger: */
static sqInt NoDbgRegParms
isInstanceOfClassLargePositiveInteger(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassLargePositiveIntegerCompactIndex);
}

	/* SpurMemoryManager>>#isLargeFreeObject: */
static sqInt NoDbgRegParms
isLargeFreeObject(sqInt objOop)
{
	return (bytesInBody(objOop)) >= ((numFreeLists()) * (allocationUnit()));
}


/*	Answer if the oop is a large positive or negative integer instance. */

	/* SpurMemoryManager>>#isLargeIntegerInstance: */
static sqInt NoDbgRegParms
isLargeIntegerInstance(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((((usqInt)((classIndexOf(oop)) - ClassLargeNegativeIntegerCompactIndex))) <= 1);
}


/*	Answer if the argument contains only indexable 64-bit double words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isLong64sNonImm: */
static sqInt NoDbgRegParms
isLong64sNonImm(sqInt objOop)
{
	return (formatOf(objOop)) == (sixtyFourBitIndexableFormat());
}


/*	Answer if the argument contains only indexable 64-bit double words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isLong64s: */
sqInt
isLong64s(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isLong64sNonImm(oop));
}

	/* SpurMemoryManager>>#isNonImmediate: */
sqInt
isNonImmediate(sqInt oop)
{
	return (!(oop & (tagMask())));
}

	/* SpurMemoryManager>>#isObjEphemeron: */
static sqInt NoDbgRegParms
isObjEphemeron(sqInt objOop)
{
    sqInt format;

	/* begin isEphemeronFormat: */
	format = formatOf(objOop);
	return format == (ephemeronFormat());
}


/*	Answer if obj is old. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isOldObject: */
static sqInt NoDbgRegParms
isOldObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart));
}


/*	Answer whether the oop is an object of compiled method format */

	/* SpurMemoryManager>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((formatOf(oop)) >= (firstCompiledMethodFormat()));
}

	/* SpurMemoryManager>>#isOopForwarded: */
sqInt
isOopForwarded(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))));
}

	/* SpurMemoryManager>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt oop)
{
	return (isImmediate(oop))
	 || (isImmutable(oop));
}

	/* SpurMemoryManager>>#isOopMutable: */
sqInt
isOopMutable(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (!(isImmutable(oop)));
}

	/* SpurMemoryManager>>#isPinned: */
sqInt
isPinned(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isPointersFormat: */
static sqInt NoDbgRegParms
isPointersFormat(sqInt format)
{
	return format <= (lastPointerFormat());
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointersNonImm: */
static sqInt NoDbgRegParms
isPointersNonImm(sqInt objOop)
{
	return (formatOf(objOop)) <= (lastPointerFormat());
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointers: */
static sqInt NoDbgRegParms
isPointers(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isPointersNonImm(oop));
}


/*	the inverse of isAnyPointerFormat: */

	/* SpurMemoryManager>>#isPureBitsFormat: */
static sqInt NoDbgRegParms
isPureBitsFormat(sqInt format)
{
	return (format >= (sixtyFourBitIndexableFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	Answer if obj is young. This for compatibility with SqueakV3 where
	the GC makes all objects young during full GC. Spur doesn't do so. */

	/* SpurMemoryManager>>#isReallyYoungObject: */
sqInt
isReallyYoungObject(sqInt obj)
{
	return isYoungObject(obj);
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isReallyYoung: */
static sqInt NoDbgRegParms
isReallyYoung(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isReallyYoungObject(oop));
}

	/* SpurMemoryManager>>#isRemembered: */
static sqInt NoDbgRegParms
isRemembered(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0;
}


/*	Maybe this should be in SpurSegmentManager only */

	/* SpurMemoryManager>>#isSegmentBridge: */
static sqInt NoDbgRegParms
isSegmentBridge(sqInt objOop)
{
	return (classIndexOf(objOop)) == (segmentBridgePun());
}


/*	Answer if the argument contains only indexable 16-bit half words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isShortsNonImm: */
static sqInt NoDbgRegParms
isShortsNonImm(sqInt objOop)
{
	return (((formatOf(objOop)) >= (firstShortFormat())) && ((formatOf(objOop)) <= ((firstByteFormat()) - 1)));
}


/*	Answer if the argument contains only indexable 16-bit half words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isShorts: */
sqInt
isShorts(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isShortsNonImm(oop));
}


/*	This version is private to SpurMemoryManager (for asserts, etc). It does
	not take advantage of the power-of-two optimization in isForwarded:. */

	/* SpurMemoryManager>>#isUnambiguouslyForwarder: */
static sqInt NoDbgRegParms
isUnambiguouslyForwarder(sqInt objOop)
{
	return (classIndexOf(objOop)) == (isForwardedObjectClassIndexPun());
}


/*	For debugging using printOopsSuchThat: */

	/* SpurMemoryManager>>#isUnmarked: */
sqInt
isUnmarked(sqInt objOop)
{
	return !(isMarked(objOop));
}

	/* SpurMemoryManager>>#isValidClassTag: */
sqInt
isValidClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;

	assert(((classIndex >= 0) && (classIndex <= ((1U << (classIndexFieldWidth())) - 1))));
	classOrNil = classOrNilAtIndex(classIndex);
	return (classOrNil != GIV(nilObj))
	 && ((rawHashBitsOf(classOrNil)) == classIndex);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackAt: */
static sqInt NoDbgRegParms
isValidObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackOrNil;

	stackOrNil = fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj));
	return (stackOrNil == GIV(nilObj))
	 || (isValidObjStackPagemyIndexfirstPage(stackOrNil, objStackRootIndex, 1));
}


/*	Just check the page itself. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex: */
static sqInt NoDbgRegParms
isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((classIndexOf(objStackPage)) == (wordSizeClassIndexPun()))) {
		GIV(objStackInvalidBecause) = "wrong class index";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((formatOf(objStackPage)) == (wordIndexableFormat()))) {
		GIV(objStackInvalidBecause) = "wrong format";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((numSlotsOfAny(objStackPage)) == ObjStackPageSlots)) {
		GIV(objStackInvalidBecause) = "wrong num slots";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(myx == (fetchPointerofObject(ObjStackMyx, objStackPage)))) {
		GIV(objStackInvalidBecause) = "wrong myx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (GIV(marking)
	 && (!(isMarked(objStackPage)))) {
		GIV(objStackInvalidBecause) = "marking but page is unmarked";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return 1;
}


/*	Answer if the obj stack at stackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex:firstPage: */
static sqInt NoDbgRegParms
isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    sqInt page;

	if (!(isValidObjStackPagemyIndex(objStackPage, myx))) {
		return 0;
	}
	freeOrNextPage = fetchPointerofObject(ObjStackFreex, objStackPage);
	while (freeOrNextPage != 0) {
		if (!isFirstPage) {
			GIV(objStackInvalidBecause) = "free page on other than first page";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (freeOrNextPage == (fetchPointerofObject(ObjStackNextx, objStackPage))) {
			GIV(objStackInvalidBecause) = "free page = next page";
			GIV(invalidObjStackPage) = freeOrNextPage;
			return 0;
		}
		if (!(isValidObjStackPagemyIndex(freeOrNextPage, myx))) {
			GIV(objStackInvalidBecause) = stretchcat(GIV(objStackInvalidBecause), ", on next page");
			return 0;
		}
		page = fetchPointerofObject(ObjStackFreex, freeOrNextPage);
		if ((page == freeOrNextPage)
		 || (page == objStackPage)) {
			GIV(objStackInvalidBecause) = "circularity in free page list";
			GIV(invalidObjStackPage) = page;
			return 0;
		}
		freeOrNextPage = page;
	}
	if (isFirstPage) {
		if (!(((myx >= (classTableRootSlots())) && (myx <= (((classTableRootSlots()) + (hiddenRootSlots())) - 1))))) {
			GIV(objStackInvalidBecause) = "myx out of range";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (!((fetchPointerofObject(myx, GIV(hiddenRootsObj))) == objStackPage)) {
			GIV(objStackInvalidBecause) = "firstPage is not root";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
	}
	index = fetchPointerofObject(ObjStackTopx, objStackPage);
	if (!(((index >= 0) && (index <= ObjStackLimit)))) {
		GIV(objStackInvalidBecause) = "bad topx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	freeOrNextPage = fetchPointerofObject(ObjStackNextx, objStackPage);
	if (freeOrNextPage == 0) {
		return 1;
	}
	if (freeOrNextPage == objStackPage) {
		GIV(objStackInvalidBecause) = "circularity in objStack page list";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(freeOrNextPage, myx, 0);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStack: */
static sqInt NoDbgRegParms
isValidObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((addressCouldBeObj(objStack))
		 && ((numSlotsOfAny(objStack)) == ObjStackPageSlots))) {
		GIV(objStackInvalidBecause) = "first page not obj or wrong size";
		GIV(invalidObjStackPage) = objStack;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), 1);
}

	/* SpurMemoryManager>>#isWeakNonImm: */
static sqInt NoDbgRegParms
isWeakNonImm(sqInt objOop)
{
    sqInt format;

	/* begin isWeakFormat: */
	format = formatOf(objOop);
	return format == (weakArrayFormat());
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWeak: */
static sqInt NoDbgRegParms
isWeak(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWeakNonImm(oop));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytesNonImm: */
static sqInt NoDbgRegParms
isWordsOrBytesNonImm(sqInt objOop)
{
	return isPureBitsFormat(formatOf(objOop));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytes: */
static sqInt NoDbgRegParms
isWordsOrBytes(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWordsOrBytesNonImm(oop));
}


/*	Answer if the argument contains only indexable 16-bit half words or 32-bit
	words (no oops).
	See comment in formatOf: */

	/* SpurMemoryManager>>#isWordsOrShortsNonImm: */
static sqInt NoDbgRegParms
isWordsOrShortsNonImm(sqInt objOop)
{
	return (((formatOf(objOop)) >= (firstLongFormat())) && ((formatOf(objOop)) <= ((firstByteFormat()) - 1)));
}


/*	Answer if the argument contains only indexable 16-bit half words or 32-bit
	indexable words (no oops).
	See comment in formatOf: */

	/* SpurMemoryManager>>#isWordsOrShorts: */
sqInt
isWordsOrShorts(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWordsOrShortsNonImm(oop));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWords: */
static sqInt NoDbgRegParms
isWords(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWordsNonImm(oop));
}


/*	Answer if obj is young. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isYoungObject: */
sqInt
isYoungObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisLessThan(objOop, GIV(oldSpaceStart));
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isYoung: */
sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (isNonImmediate(oop))
	 && (oopisLessThan(oop, GIV(oldSpaceStart)));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* SpurMemoryManager>>#is:instanceOf:compactClassIndex: */
static sqInt NoDbgRegParms
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if (isImmediate(oop)) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = classIndexOf(oop);
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	else {
		return classOop == (classAtIndex(ccIndex));
	}
}


/*	Answer the object the ephemeron guards. This is its first element. */

	/* SpurMemoryManager>>#keyOfEphemeron: */
static sqInt NoDbgRegParms
keyOfEphemeron(sqInt objOop)
{
	assert((isNonImmediate(objOop))
	 && (isObjEphemeron(objOop)));
	return fetchPointerofObject(0, objOop);
}

	/* SpurMemoryManager>>#knownClassAtIndex: */
static sqInt NoDbgRegParms
knownClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(((classIndex >= 1) && (classIndex <= (classTablePageSize()))));
	return fetchPointerofObject(classIndex, GIV(classTableFirstPage));
}

	/* SpurMemoryManager>>#lastPointerFormat */
static sqInt
lastPointerFormat(void)
{
	return 5;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects.
	Does not examine the stack pointer of contexts to be sure to swizzle
	the nils that fill contexts on snapshot.
	It is invariant that on image load no object contains a forwarding
	pointer, and the image contains no forwarders (see class comment). */

	/* SpurMemoryManager>>#lastPointerOfWhileSwizzling: */
static sqInt NoDbgRegParms
lastPointerOfWhileSwizzling(sqInt objOop)
{
    sqInt fmt;
    sqInt header;

	fmt = formatOf(objOop);
	assert(fmt != (forwardedFormat()));
	if (fmt <= (lastPointerFormat())) {
		return (((numSlotsOf(objOop)) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	header = methodHeaderOf(objOop);
	return (((((assert((header & 1)),
/* begin literalCountOfAlternateHeader: */
((header >> 1)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* SpurMemoryManager>>#leakCheckFullGC */
sqInt
leakCheckFullGC(void)
{
	return ((checkForLeaks & GCModeFull) != 0);
}

	/* SpurMemoryManager>>#leakCheckNewSpaceGC */
sqInt
leakCheckNewSpaceGC(void)
{
	return ((checkForLeaks & GCModeNewSpace) != 0);
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes) should
	be subtracted from the result. */

	/* SpurMemoryManager>>#lengthOf: */
static sqInt NoDbgRegParms
lengthOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numSlots;

	/* begin lengthOf:format: */
	fmt = formatOf(objOop);

	/* don't let forwarders freak us out... */
	numSlots = numSlotsOfAny(objOop);
	if (fmt <= (ephemeronFormat())) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return (numSlots) >> 1;
	}
	return 0;
}

	/* SpurMemoryManager>>#literalCountOfMethodHeader: */
sqInt
literalCountOfMethodHeader(sqInt header)
{
	assert((header & 1));
	return ((header >> 1)) & AlternateHeaderNumLiteralsMask;
}

	/* SpurMemoryManager>>#literalCountOf: */
sqInt
literalCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin literalCountOfMethodHeader: */
	header = methodHeaderOf(methodPointer);
	assert((header & 1));
	return ((header >> 1)) & AlternateHeaderNumLiteralsMask;
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = rawHashBitsOf(aClassOop);
	if (classIndex != (isFreeObjectClassIndexPun())) {
		longPrintInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing any and all objects whose classIndex equals the
	argument. 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintInstancesWithClassIndex: */
void
longPrintInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((classIndexOf(objOop)) == classIndex) {
			longPrintOop(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop1 = objectStartingAt(start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if ((classIndexOf(objOop1)) == classIndex) {
			longPrintOop(objOop1);
			cr();
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress1)))
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt prntObj;
    sqInt startObject;

	prntObj = 0;
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if ((isPointersNonImm(obj1))
			 || (isCompiledMethod(obj1))) {
				if (isCompiledMethod(obj1)) {
					i = (literalCountOf(obj1)) + LiteralStart;
				}
				else {
					if ((classIndexOf(obj1)) == ClassMethodContextCompactIndex) {
						i = CtxtTempFrameStart + (fetchStackPointerOf(obj1));
					}
					else {
						i = numSlotsOf(obj1);
					}
				}
				while (((i -= 1)) >= 0) {
					if (anOop == (fetchPointerofObject(i, obj1))) {
						printHex(obj1);
						print(" @ ");
						printNum(i);
						cr();
						prntObj = 1;
						i = 0;
					}
				}
				if (prntObj) {
					prntObj = 0;
					longPrintOop(obj1);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}


/*	Ensure the class of the argument is marked, pushing it on the markStack if
	not already marked.
	And for one-way become, which can create duplicate entries in the class
	table, make sure
	objOop's classIndex refers to the classObj's actual classIndex.
	Note that this is recursive, but the metaclass chain should terminate
	quickly. 
 */

	/* SpurMemoryManager>>#markAndTraceClassOf: */
static void NoDbgRegParms
markAndTraceClassOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classObj;
    sqInt objStack;
    sqInt realClassIndex;

	classIndex = classIndexOf(objOop);
	classObj = classOrNilAtIndex(classIndex);
	assert(objCouldBeClassObj(classObj));
	realClassIndex = rawHashBitsOf(classObj);
	if ((classIndex != realClassIndex)
	 && (classIndex > (lastClassIndexPun()))) {
		setClassIndexOfto(objOop, realClassIndex);
	}
	if (!(isMarked(classObj))) {
		setIsMarkedOfto(classObj, 1);
		markAndTraceClassOf(classObj);
		/* begin push:onObjStack: */
		objStack = GIV(markStack);
		assert(addressCouldBeOop(classObj));
		if (isImmediate(classObj)) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
				? fetchPointerofObject(ObjStackNextx, objStack)
				: objStack))));
		}
		else {

			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(classObj))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(classObj)));
		}
		noCheckPushonObjStack(classObj, objStack);
	}
}


/*	Mark the argument, and all objects reachable from it, and any remaining
	objects on the mark stack. Follow forwarding pointers in the scan. */
/*	if markAndTrace: is to follow and eliminate forwarding pointers
	in its scan it cannot be handed an r-value which is forwarded.
	The assert for this is in markAndShouldScan: */

	/* SpurMemoryManager>>#markAndTrace: */
void NeverInline
markAndTrace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt format1;
    sqInt format11;
    sqInt header;
    sqInt index;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objStack;
    sqInt objStack1;
    sqInt objStack2;
    sqInt objStack3;
    sqInt objStack4;
    sqInt objStack5;
    sqInt objStack6;
    sqInt objToScan;
    sqInt scanLargeObject;
    sqInt sp;

	numStrongSlots = 0;

	/* inline markAndShouldScan: */
	if (isImmediate(objOop)) {
		return;
	}
	assert(!(isForwarded(objOop)));
	if (isMarked(objOop)) {
		return;
	}
	setIsMarkedOfto(objOop, 1);
	format1 = formatOf(objOop);
	if (isPureBitsFormat(format1)) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if ((classIndexOf(objOop)) > (lastClassIndexPun())) {
			markAndTraceClassOf(objOop);
		}
		return;
	}
	if (format1 == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		/* begin push:onObjStack: */
		objStack = GIV(weaklingStack);
		assert(addressCouldBeOop(objOop));
		if (isImmediate(objOop)) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
				? fetchPointerofObject(ObjStackNextx, objStack)
				: objStack))));
		}
		else {

			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(objOop))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(objOop)));
		}
		noCheckPushonObjStack(objOop, objStack);
		return;
	}
	if ((format1 == (ephemeronFormat()))
	 && (activeAndDeferredScan(objOop))) {
		return;
	}
	/* begin markLoopFrom: */

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan = objOop;
	do {
		if (isImmediate(objToScan)) {
			scanLargeObject = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt = formatOf(objToScan);
			assert((fmt != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan))));
			if (fmt <= (lastPointerFormat())) {
				numSlots = numSlotsOf(objToScan);
				if (fmt <= 2 /* arrayFormat */) {
					numStrongSlots = numSlots;
					goto l11;
				}
				if (fmt == (indexablePointersFormat())) {
					if ((classIndexOf(objToScan)) == ClassMethodContextCompactIndex) {
						/* begin fetchStackPointerOf: */
						sp = fetchPointerofObject(StackPointerIndex, objToScan);
						if (!((sp & 1))) {
							contextSize = 0;
							goto l10;
						}
						assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objToScan)));
						contextSize = (sp >> 1);
	l10:	/* end fetchStackPointerOf: */;
						numStrongSlots = CtxtTempFrameStart + contextSize;
						goto l11;
					}
					numStrongSlots = numSlots;
					goto l11;
				}
				if (fmt == (weakArrayFormat())) {
					numStrongSlots = fixedFieldsOfClass(fetchClassOfNonImm(objToScan));
					goto l11;
				}
			}
			if (fmt == (forwardedFormat())) {
				numStrongSlots = 1;
				goto l11;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				numStrongSlots = 0;
				goto l11;
			}
			header = methodHeaderOf(objToScan);
			/* begin literalCountOfMethodHeader: */
			assert((header & 1));
			numLiterals = ((header >> 1)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots = numLiterals + LiteralStart;
	l11:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject = numStrongSlots > (traceImmediatelySlotLimit());
		}
		if (scanLargeObject) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if (isImmediate(objToScan)) {
				index = (objToScan >> 1);
				objToScan = topOfObjStack(GIV(markStack));
			}
			else {
				index = numStrongSlots;
				markAndTraceClassOf(objToScan);
			}
			while (index > 0) {
				index -= 1;
				field = fetchPointerofObject(index, objToScan);
				if (isNonImmediate(field)) {
					if ((!((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}
					if (isImmediate(field)) {
						goto l12;
					}
					assert(!(isForwarded(field)));
					if (isMarked(field)) {
						goto l12;
					}
					setIsMarkedOfto(field, 1);
					format11 = formatOf(field);
					if (isPureBitsFormat(format11)) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if ((classIndexOf(field)) > (lastClassIndexPun())) {
							markAndTraceClassOf(field);
						}
						goto l12;
					}
					if (format11 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						/* begin push:onObjStack: */
						objStack6 = GIV(weaklingStack);
						assert(addressCouldBeOop(field));
						if (isImmediate(field)) {
							assert(objStack6 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack6))
								? fetchPointerofObject(ObjStackNextx, objStack6)
								: objStack6))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack6 == GIV(markStack))
							 && (isWeakNonImm(field))));
							assert((objStack6 != GIV(weaklingStack))
							 || (isWeakNonImm(field)));
						}
						noCheckPushonObjStack(field, objStack6);
						goto l12;
					}
					if ((format11 == (ephemeronFormat()))
					 && (activeAndDeferredScan(field))) {
						goto l12;
					}
					if (index > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan) {
							/* begin push:onObjStack: */
							objStack1 = GIV(markStack);
							assert(addressCouldBeOop(objToScan));
							if (isImmediate(objToScan)) {
								assert(objStack1 == GIV(markStack));
								assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
									? fetchPointerofObject(ObjStackNextx, objStack1)
									: objStack1))));
							}
							else {

								/* There should be no weaklings on the mark stack. */
								assert(!((objStack1 == GIV(markStack))
								 && (isWeakNonImm(objToScan))));
								assert((objStack1 != GIV(weaklingStack))
								 || (isWeakNonImm(objToScan)));
							}
							noCheckPushonObjStack(objToScan, objStack1);
						}
						/* begin push:onObjStack: */
						objOop1 = (((usqInt)index << 1) | 1);
						objStack2 = GIV(markStack);
						assert(addressCouldBeOop(objOop1));
						if (isImmediate(objOop1)) {
							assert(objStack2 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack2))
								? fetchPointerofObject(ObjStackNextx, objStack2)
								: objStack2))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack2 == GIV(markStack))
							 && (isWeakNonImm(objOop1))));
							assert((objStack2 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop1)));
						}
						noCheckPushonObjStack(objOop1, objStack2);
					}
					objToScan = field;
					index = -1;
	l12:	;
				}
			}
			if (index >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan = popObjStack(GIV(markStack));
				if (objToScan == objOop) {
					objToScan = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index = numStrongSlots;
			markAndTraceClassOf(objToScan);
			while (index > 0) {
				index -= 1;
				field = fetchPointerofObject(index, objToScan);
				if (isNonImmediate(field)) {
					if ((!((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}
					if (isImmediate(field)) {
						goto l2;
					}
					assert(!(isForwarded(field)));
					if (isMarked(field)) {
						goto l2;
					}
					setIsMarkedOfto(field, 1);
					format11 = formatOf(field);
					if (isPureBitsFormat(format11)) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if ((classIndexOf(field)) > (lastClassIndexPun())) {
							markAndTraceClassOf(field);
						}
						goto l2;
					}
					if (format11 == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						/* begin push:onObjStack: */
						objStack3 = GIV(weaklingStack);
						assert(addressCouldBeOop(field));
						if (isImmediate(field)) {
							assert(objStack3 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack3))
								? fetchPointerofObject(ObjStackNextx, objStack3)
								: objStack3))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack3 == GIV(markStack))
							 && (isWeakNonImm(field))));
							assert((objStack3 != GIV(weaklingStack))
							 || (isWeakNonImm(field)));
						}
						noCheckPushonObjStack(field, objStack3);
						goto l2;
					}
					if ((format11 == (ephemeronFormat()))
					 && (activeAndDeferredScan(field))) {
						goto l2;
					}
					/* begin push:onObjStack: */
					objStack5 = GIV(markStack);
					assert(addressCouldBeOop(field));
					if (isImmediate(field)) {
						assert(objStack5 == GIV(markStack));
						assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack5))
							? fetchPointerofObject(ObjStackNextx, objStack5)
							: objStack5))));
					}
					else {

						/* There should be no weaklings on the mark stack. */
						assert(!((objStack5 == GIV(markStack))
						 && (isWeakNonImm(field))));
						assert((objStack5 != GIV(weaklingStack))
						 || (isWeakNonImm(field)));
					}
					noCheckPushonObjStack(field, objStack5);
					if (((byteAt(field + 7)) > (traceImmediatelySlotLimit()))
					 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > (traceImmediatelySlotLimit()))) {
						/* begin push:onObjStack: */
						objOop2 = (((usqInt)numStrongSlots << 1) | 1);
						objStack4 = GIV(markStack);
						assert(addressCouldBeOop(objOop2));
						if (isImmediate(objOop2)) {
							assert(objStack4 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack4))
								? fetchPointerofObject(ObjStackNextx, objStack4)
								: objStack4))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack4 == GIV(markStack))
							 && (isWeakNonImm(objOop2))));
							assert((objStack4 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop2)));
						}
						noCheckPushonObjStack(objOop2, objStack4);
					}
	l2:	;
				}
			}
			objToScan = popObjStack(GIV(markStack));
		}
	} while(objToScan != null);
}


/*	Almost entirely arbitrary, but we dont want 1Mb bitmaps allocated in eden.
	But this choice means no check for numSlots > maxSlotsForNewSpaceAlloc
	for non-variable allocations. */

	/* SpurMemoryManager>>#maxSlotsForNewSpaceAlloc */
sqInt
maxSlotsForNewSpaceAlloc(void)
{
	return fixedFieldsOfClassFormatMask();
}


/*	Answer the method header of a CompiledMethod object. */

	/* SpurMemoryManager>>#methodHeaderOf: */
static sqInt NoDbgRegParms
methodHeaderOf(sqInt methodObj)
{
	assert(isCompiledMethod(methodObj));
	return fetchPointerofObject(HeaderIndex, methodObj);
}


/*	Answer the minimum number of additional slots to allocate in an object to
	always be able to shorten it.
	This is enough slots to allocate a minimum-sized object. */

	/* SpurMemoryManager>>#minSlotsForShortening */
sqInt
minSlotsForShortening(void)
{
	return ((allocationUnit()) * 2) / BytesPerOop;
}

	/* SpurMemoryManager>>#newSpaceIsEmpty */
static sqInt
newSpaceIsEmpty(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(freeStart) == (((eden()).start)))
	 && (GIV(pastSpaceStart) == (((pastSpace()).start)));
}


/*	The three bit field { isGrey, isPinned, isRemembered } is for bits
	that are never set in young objects. This allows the remembered
	table to be pruned when full by using these bits as a reference
	count of newSpace objects from the remembered table. Objects
	with a high count should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#newSpaceRefCountMask */
static sqInt
newSpaceRefCountMask(void)
{
	return (1U << (greyBitShift())) | ((1U << (pinnedBitShift())) | (1U << (rememberedBitShift())));
}

	/* SpurMemoryManager>>#nilObject */
sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}

	/* SpurMemoryManager>>#noCheckClassAtIndex: */
static sqInt NoDbgRegParms
noCheckClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}


/*	Push an element on an objStack. Split from push:onObjStack: for testing. */

	/* SpurMemoryManager>>#noCheckPush:onObjStack: */
static sqInt NoDbgRegParms
noCheckPushonObjStack(sqInt objOop, sqInt objStack)
{
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = fetchPointerofObject(ObjStackTopx, objStack);
	if (topx >= ObjStackLimit) {
		noCheckPushonObjStack(objOop, ensureRoomOnObjStackAt(fetchPointerofObject(ObjStackMyx, objStack)));
	}
	else {
		storePointerofObjStackwithValue(ObjStackFixedSlots + topx, objStack, objOop);
		storePointerofObjStackwithValue(ObjStackTopx, objStack, topx + 1);
	}
	return objOop;
}

	/* SpurMemoryManager>>#noInlineFollowForwarded: */
static sqInt NoDbgRegParms
noInlineFollowForwarded(sqInt objOop)
{
	return followForwarded(objOop);
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word. */

	/* SpurMemoryManager>>#noInlineObjectAfter:limit: */
static sqInt NoDbgRegParms
noInlineObjectAfterlimit(sqInt objOop, sqInt limit)
{
    sqInt followingWord;
    usqInt followingWordAddress;

	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress + 4);
	return ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
}

	/* SpurMemoryManager>>#nonIndexablePointerFormat */
sqInt
nonIndexablePointerFormat(void)
{
	return 1;
}


/*	Answer the number of indexable bytes in the given non-immediate pure bits
	object with format.
 */

	/* SpurMemoryManager>>#numBytesOfBits:format: */
static sqInt NoDbgRegParms
numBytesOfBitsformat(sqInt objOop, sqInt format)
{
    usqInt numBytes;

	assert((isPureBitsFormat(format))
	 && ((formatOf(objOop)) == format));
	numBytes = numSlotsOf(objOop);
	numBytes = numBytes << (shiftForWord());
	if (format < (firstShortFormat())) {
		return (format <= (sixtyFourBitIndexableFormat())
			? numBytes
			: numBytes - (((sqInt)((usqInt)((format & 1)) << 2))));
	}
	return (format < (firstByteFormat())
		? numBytes - (((sqInt)((usqInt)((format & 3)) << 1)))
		: numBytes - (format & 7));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* SpurMemoryManager>>#numBytesOfBytes: */
static sqInt NoDbgRegParms
numBytesOfBytes(sqInt objOop)
{
    sqInt fmt;

	fmt = formatOf(objOop);
	assert(fmt >= (firstByteFormat()));
	return ((numSlotsOf(objOop)) << (shiftForWord())) - (fmt & 7);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* SpurMemoryManager>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numBytes;

	fmt = formatOf(objOop);
	numBytes = numSlotsOf(objOop);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((sqInt)((usqInt)((fmt & 3)) << 1)));
	}
	return numBytes - (((sqInt)((usqInt)((fmt & 1)) << 2)));
}


/*	Answer the number of pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numPointerSlotsOf: */
static usqInt NoDbgRegParms
numPointerSlotsOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    sqInt sp;

	fmt = formatOf(objOop);
	/* begin numPointerSlotsOf:format: */
	if (fmt <= (lastPointerFormat())) {
		if ((fmt == (indexablePointersFormat()))
		 && ((classIndexOf(objOop)) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = fetchPointerofObject(StackPointerIndex, objOop);
			if (!((sp & 1))) {
				contextSize = 0;
				goto l2;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
			contextSize = (sp >> 1);
	l2:	/* end fetchStackPointerOf: */;
			return CtxtTempFrameStart + contextSize;
		}
		return numSlotsOf(objOop);
	}
	if (fmt == (forwardedFormat())) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	header = methodHeaderOf(objOop);
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((header >> 1)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}

	/* SpurMemoryManager>>#numSlotsForBytes: */
static sqInt NoDbgRegParms
numSlotsForBytes(sqInt numBytes)
{
	return (numBytes + (BytesPerWord - 1)) / BytesPerWord;
}


/*	A private internal version of numSlotsOf: that is happy to be applied to
	free or forwarded objects.
 */

	/* SpurMemoryManager>>#numSlotsOfAny: */
static usqInt NoDbgRegParms
numSlotsOfAny(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask())
		? (/* begin rawOverflowSlotsOf: */
			longAt(objOop - BaseHeaderSize))
		: numSlots);
}

	/* SpurMemoryManager>>#numSlotsOf: */
usqInt
numSlotsOf(sqInt objOop)
{
    usqInt numSlots;

	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask())
		? (/* begin rawOverflowSlotsOf: */
			longAt(objOop - BaseHeaderSize))
		: numSlots);
}


/*	Answer the number of strong pointer fields in the given object,
	which is .expected not to be an active ephemeron.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numStrongSlotsOfInephemeral: */
static sqInt NoDbgRegParms
numStrongSlotsOfInephemeral(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt sp;

	fmt = formatOf(objOop);
	assert((fmt != (ephemeronFormat()))
	 || (isMarked(keyOfEphemeron(objOop))));
	if (fmt <= (lastPointerFormat())) {
		numSlots = numSlotsOf(objOop);
		if (fmt <= 2 /* arrayFormat */) {
			return numSlots;
		}
		if (fmt == (indexablePointersFormat())) {
			if ((classIndexOf(objOop)) == ClassMethodContextCompactIndex) {
				/* begin fetchStackPointerOf: */
				sp = fetchPointerofObject(StackPointerIndex, objOop);
				if (!((sp & 1))) {
					contextSize = 0;
					goto l2;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
				contextSize = (sp >> 1);
	l2:	/* end fetchStackPointerOf: */;
				return CtxtTempFrameStart + contextSize;
			}
			return numSlots;
		}
		if (fmt == (weakArrayFormat())) {
			return fixedFieldsOfClass(fetchClassOfNonImm(objOop));
		}
	}
	if (fmt == (forwardedFormat())) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	header = methodHeaderOf(objOop);
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((header >> 1)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#objectAfter: */
sqInt
objectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    sqInt followingWord2;
    sqInt followingWord3;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    usqInt followingWordAddress2;
    usqInt followingWordAddress3;
    sqInt limit;

	if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
		if (isInEden(objOop)) {
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				return GIV(freeStart);
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress + 4);
			return ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
		}
		if (isInPastSpace(objOop)) {
			/* begin objectAfter:limit: */
			followingWordAddress1 = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(pastSpaceStart))) {
				return GIV(pastSpaceStart);
			}
			flag("endianness");
			followingWord1 = longAt(followingWordAddress1 + 4);
			return ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
				? followingWordAddress1 + BaseHeaderSize
				: followingWordAddress1);
		}
		/* begin objectAfter:limit: */
		limit = futureSurvivorStart();
		followingWordAddress2 = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress2, limit)) {
			return limit;
		}
		flag("endianness");
		followingWord2 = longAt(followingWordAddress2 + 4);
		return ((((usqInt)(followingWord2)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress2 + BaseHeaderSize
			: followingWordAddress2);
	}
	/* begin objectAfter:limit: */
	followingWordAddress3 = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress3, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord3 = longAt(followingWordAddress3 + 4);
	return ((((usqInt)(followingWord3)) >> (numSlotsHalfShift())) == (numSlotsMask())
		? followingWordAddress3 + BaseHeaderSize
		: followingWordAddress3);
}


/*	useful for debugging */

	/* SpurMemoryManager>>#objectBefore: */
sqInt
objectBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prev;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	prev = null;
	if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((pastSpace()).start)) < (((eden()).start)));
		start = (GIV(pastSpaceStart) > (((pastSpace()).start))
			? ((pastSpace()).start)
			: (GIV(freeStart) > (((eden()).start))
					? ((eden()).start)
					: GIV(oldSpaceStart)));
		if (start > GIV(freeStart)) {
			goto l2;
		}
		/* begin bridgePastSpaceAndEden */
		if (GIV(pastSpaceStart) < (((eden()).start))) {

			/* past space can be entirely full (!!) */
			if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

				/* No room for a full bridge (!!); use the slim bridge hack */
				hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
				assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
			}
			else {

				/* Room for a regular bridge; this is straight-forward */
				initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
			}
		}
		objOop1 = objectStartingAt(start);
		while (oopisLessThan(objOop1, GIV(freeStart))) {
			if (oopisGreaterThanOrEqualTo(objOop1, objOop)) {
				return prev;
			}
			prev = objOop1;
			prevPrevObj = prevObj;
			prevObj = objOop1;
			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress = addressAfter(objOop1);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				objOop1 = GIV(freeStart);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress + 4);
			objOop1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
				? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
					 && (1 == (longAt(followingWordAddress)))
						? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
						: followingWordAddress + BaseHeaderSize)
				: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		}
	l2:	/* end allNewSpaceEntitiesDo: */;
		return prev;
	}
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop2 = GIV(nilObj);
	while (1) {
		assert((objOop2 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop2, GIV(endOfMemory)))) break;
		assert((long64At(objOop2)) != 0);
		if (oopisGreaterThanOrEqualTo(objOop2, objOop)) {
			return prev;
		}
		prev = objOop2;
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop2);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop2 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop2 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For assertions only... This ends the recursion in setting up the bridged
	enumerations of new space that need objectBefore: for assertion checking. */

	/* SpurMemoryManager>>#objectInPastSpaceBefore: */
static sqInt NoDbgRegParms
objectInPastSpaceBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj;
    sqInt prev;

	if (GIV(pastSpaceStart) <= (((pastSpace()).start))) {
		return null;
	}
	prev = null;
	obj = objectStartingAt(((pastSpace()).start));
	while (oopisLessThan(obj, GIV(pastSpaceStart))) {
		if (oopisGreaterThanOrEqualTo(obj, objOop)) {
			return prev;
		}
		prev = obj;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
			obj = GIV(pastSpaceStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For enumerating objects find the header of the first object in a space.
	If the object starts with an overflow size field it will start at the next
	allocationUnit. c.f. numSlotsOf: */

	/* SpurMemoryManager>>#objectStartingAt: */
static sqInt NoDbgRegParms
objectStartingAt(sqInt address)
{
    usqInt numSlots;

	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* SpurMemoryManager>>#okayOop: */
static sqInt NoDbgRegParms
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqInt oop;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	oop = ((usqInt) signedOop);
	if (isImmediate(oop)) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = classIndexOf(oop))) >= (firstClassIndexPun()))) {
		error("oop is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		error("oop header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = formatOf(oop);
	if ((fmt == 6) || (fmt == 8)) {
		error("oop has an unknown format type");
		return 0;
	}
	if ((fmt == (forwardedFormat())) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		error("oop has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1U << (classIndexFieldWidth())) | (1ULL << ((identityHashFieldWidth()) + 32));
	if (((long64At(oop)) & unusedBits) != 0) {
		error("some unused header bits are set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1U << (greyBitShift())) | (1U << (pinnedBitShift()))) | (1U << (rememberedBitShift()));
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		error("some header bits unused in young objects are set; should be zero");
		return 0;
	}
	return 1;
}


/*	useful for debugging */
/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#oldSpaceObjectAfter: */
sqInt
oldSpaceObjectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress + 4);
	return ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
		? followingWordAddress + BaseHeaderSize
		: followingWordAddress);
}


/*	Attempt to pin objOop, which must not be immediate.
	If the attempt succeeds answer objOop's (possibly moved) oop.
	If the attempt fails, which can only occur if there is no memory, answer
	0.  */

	/* SpurMemoryManager>>#pinObject: */
sqInt
pinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oldClone;
    SpurSegmentInfo *seg;

	assert(isNonImmediate(objOop));
	assert(!((isForwarded(objOop))));
	flag("policy decision here. if already old, do we clone in a segment containing pinned objects or merely pin?");
	if (isOldObject(objOop)) {
		if ((numBytesOf(objOop)) > (0x100000)) {
			setIsPinnedOfto(objOop, 1);
			return objOop;
		}
		seg = segmentContainingObj(objOop);
		if ((seg->containsPinned)) {
			setIsPinnedOfto(objOop, 1);
			return objOop;
		}
		if (!(someSegmentContainsPinned())) {
			setIsPinnedOfto(objOop, 1);
			(seg->containsPinned = 1);
			return objOop;
		}
	}
	oldClone = cloneInOldSpaceforPinning(objOop, 1);
	if (oldClone != 0) {
		GIV(becomeEffectsFlags) = becomeEffectFlagsFor(objOop);
		setIsPinnedOfto(oldClone, 1);
		forwardto(objOop, oldClone);
		followSpecialObjectsOop();
		postBecomeScanClassTable(GIV(becomeEffectsFlags));
		GIV(becomeEffectsFlags) = 0;
	}
	return oldClone;
}

	/* SpurMemoryManager>>#popObjStack: */
static sqInt NoDbgRegParms
popObjStack(sqInt objStack)
{
    sqInt myx;
    sqInt nextPage;
    sqInt top;
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = fetchPointerofObject(ObjStackTopx, objStack);
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	topx -= 1;
	top = fetchPointerofObject(topx + ObjStackFixedSlots, objStack);
	storePointerofObjStackwithValue(ObjStackTopx, objStack, topx);
	if ((topx == 0)
	 && (((nextPage = fetchPointerofObject(ObjStackNextx, objStack))) != 0)) {
		storePointerofObjStackwithValue(ObjStackFreex, nextPage, objStack);
		storePointerofObjStackwithValue(ObjStackNextx, objStack, 0);
		myx = fetchPointerofObject(ObjStackMyx, objStack);
		updateRootOfObjStackAtwith(myx, nextPage);
		eassert(isValidObjStack(nextPage));
	}
	else {
		eassert(isValidObjStack(objStack));
	}
	return top;
}


/*	Pop and return the possibly remapped object from the remap buffer.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#popRemappableOop */
sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	Scan the class table post-become (iff an active class object was becommed)
	to ensure no
	forwarding pointers, and no unhashed classes exist in the class table.
	
	Note that one-way become can cause duplications in the class table.
	So if pointer objects have been becommed, scan all pages in the class
	table and eliminate ay entries that have a zero hash.
	doBecome:and:copyHash: has
	already ensured that any becomed class has been stored at the right index. */

	/* SpurMemoryManager>>#postBecomeScanClassTable: */
static void NoDbgRegParms
postBecomeScanClassTable(sqInt effectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt i;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	assert(validClassTableRootPages());
	if (!(((effectsFlags & BecamePointerObjectFlag) != 0))) {
		return;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = fetchPointerofObject(i, GIV(hiddenRootsObj));
		assert(!(isForwarded(page)));
		for (j = 0, jLimiT = ((numSlotsOf(page)) - 1); j <= jLimiT; j += 1) {
			classOrNil = fetchPointerofObject(j, page);
			if (classOrNil != GIV(nilObj)) {
				if ((!((longAt(classOrNil)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					classOrNil = followForwarded(classOrNil);
					storePointerofObjectwithValue(j, page, classOrNil);
				}
				if ((rawHashBitsOf(classOrNil)) == 0) {
					storePointerUncheckedofObjectwithValue(j, page, GIV(nilObj));
					if (((((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j) < GIV(classTableIndex)) {
						GIV(classTableIndex) = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
}

	/* SpurMemoryManager>>#primitiveErrorTable */
sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(PrimitiveErrorTableIndex, GIV(specialObjectsOop));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printActivationsOf: */
void
printActivationsOf(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if (((classIndexOf(obj1)) == ClassMethodContextCompactIndex)
			 && (aMethodObj == (fetchPointerofObject(MethodIndex, obj1)))) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				/* begin printOopShort: */
				printOopShortInner(obj1);
				/* begin flush */
				fflush(GIV(transcript));
				print(" pc ");
				printHex(fetchPointerofObject(InstructionPointerIndex, obj1));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printBogons */
void
printBogons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anomaly;
    sqInt bogon;

	/* begin printTheBogons: */
	print("bogon ");
	printHexnp(bogon);
	cr();
	print("anomaly ");
	printHexnp(anomaly);
	cr();
}

	/* SpurMemoryManager>>#printBridge:on: */
static void NoDbgRegParms
printBridgeon(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a bridge hdr%d slot size %ul\n",
			((void *)oop),
			(hasOverflowHeader(oop)
		? 16
		: 8),
			numSlotsOfAny(oop));
}

	/* SpurMemoryManager>>#printCantBeObject:on: */
static void NoDbgRegParms
printCantBeObjecton(sqInt oop, FILE *aStream)
{
	if ((oop & ((allocationUnit()) - 1)) == 0) {
		if ((isInNewSpace(oop))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			printForwarderon(oop, aStream);
			return;
		}
		if (oop == (bridgeAt((numSegments()) - 1))) {
			printBridgeon(oop, aStream);
			return;
		}
	}
	fprintf(aStream,
			"%p%s\n",
			((void *)oop),
			((oop & ((allocationUnit()) - 1)) != 0
		? " is misaligned"
		: whereIs(oop)));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printContextReferencesTo: */
void
printContextReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if ((classIndexOf(obj1)) == ClassMethodContextCompactIndex) {
				i = CtxtTempFrameStart + (fetchStackPointerOf(obj1));
				while (((i -= 1)) >= 0) {
					if (anOop == (fetchPointerofObject(i, obj1))) {
						printHex(obj1);
						print(" @ ");
						printNum(i);
						/* begin space */
						printChar(' ');
						/* begin printOopShort: */
						printOopShortInner(obj1);
						/* begin flush */
						fflush(GIV(transcript));
						print(" pc ");
						printHex(fetchPointerofObject(InstructionPointerIndex, obj1));
						cr();
						i = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printEntity: */
void
printEntity(sqInt oop)
{
    sqInt printFlags;

	printFlags = 0;
	printHex(oop);
	/* begin space */
	printChar(' ');
	if (!(addressCouldBeObj(oop))) {
		print((isImmediate(oop)
			? "immediate"
			: "unknown"));
		return;
	}
	print((isFreeObject(oop)
		? "free"
		: (isSegmentBridge(oop)
				? "bridge"
				: ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))
						? "forwarder"
						: ((classIndexOf(oop)) <= (lastClassIndexPun())
								? ((printFlags = 1),
									"pun/obj stack")
								: ((printFlags = 1),
									"object"))))));
	/* begin space */
	printChar(' ');
	printHexnpnp(byteAt(oop + 7));
	print("/");
	printHexnpnp(bytesInBody(oop));
	print("/");
	printNum(bytesInBody(oop));
	if (printFlags) {
		/* begin space */
		printChar(' ');
		print(((formatOf(oop)) <= 15
			? "f:0"
			: "f:"));
		printHexnpnp(formatOf(oop));
		print((isGrey(oop)
			? " g"
			: " ."));
		print((isImmutable(oop)
			? "i"
			: "."));
		print((isMarked(oop)
			? "m"
			: "."));
		print((isPinned(oop)
			? "p"
			: "."));
		print((isRemembered(oop)
			? "r"
			: "."));
	}
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printForwarders */
void
printForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt objOop1;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop2 = GIV(nilObj);
	while (1) {
		assert((objOop2 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop2, GIV(endOfMemory)))) break;
		assert((long64At(objOop2)) != 0);
		if (isUnambiguouslyForwarder(objOop2)) {
			printHex(objOop2);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop2;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop2);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop2 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop2 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop1 = objectStartingAt(start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (isUnambiguouslyForwarder(objOop1)) {
			printHex(objOop1);
			cr();
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress1)))
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
}

	/* SpurMemoryManager>>#printForwarder:on: */
static void NoDbgRegParms
printForwarderon(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a forwarded hdr%d slot size %ul object to %p\n",
			((void *)oop),
			(hasOverflowHeader(oop)
		? 16
		: 8),
			numSlotsOfAny(oop),
			((void *)(followForwarded(oop))));
}


/*	This version goes through memory, printing all free chunks.
	Other versions go through the free lists. This one will show
	all free chunks even if the free lists are corrupt. */
/*	useful for debugging */

	/* SpurMemoryManager>>#printFreeChunks */
void
printFreeChunks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt seenNewFreeChunk;
    usqInt start;

	seenNewFreeChunk = 0;
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l2;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (isFreeObject(objOop)) {
			if (!seenNewFreeChunk) {
				print("NewSpace CONTAINS FREE OBJECT(S)!!");
				cr();
				seenNewFreeChunk = 1;
			}
			printFreeChunk(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l2:	/* end allNewSpaceEntitiesDo: */;
	/* begin allOldSpaceEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop1, GIV(endOfMemory)))) break;
		assert((long64At(objOop1)) != 0);
		if (isFreeObject(objOop1)) {
			printFreeChunk(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfter:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(endOfMemory))) {
			objOop1 = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress1 + BaseHeaderSize
			: followingWordAddress1);
	l3:	/* end objectAfter:limit: */;
	}
	}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeChunk: */
void
printFreeChunk(sqInt freeChunk)
{
	printFreeChunkprintAsTreeNode(freeChunk, 1);
}

	/* SpurMemoryManager>>#printFreeChunk:printAsTreeNode: */
static void NoDbgRegParms
printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numBytes;

	numBytes = bytesInBody(freeChunk);
	print("freeChunk ");
	printHexnp(freeChunk);
	if (printAsTreeNode) {
		print((freeChunk == (GIV(freeLists)[0])
			? " + "
			: " - "));
		printHexnp(addressAfter(freeChunk));
	}
	print(" bytes ");
	printNum(numBytes);
	print(" next ");
	printHexnp(fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk));
	print(" prev ");
	printHexnp(fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, freeChunk));
	if ((numBytes >= ((numFreeLists()) * (allocationUnit())))
	 && (printAsTreeNode)) {
		print(" ^ ");
		printHexnp(fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, freeChunk));
		print(" < ");
		printHexnp(fetchPointerofFreeChunk(freeChunkSmallerIndex(), freeChunk));
		print(" > ");
		printHexnp(fetchPointerofFreeChunk(freeChunkLargerIndex(), freeChunk));
	}
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeListHeads */
void
printFreeListHeads(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt expectedMask;
    sqInt i;
    sqInt iLimiT;

	expectedMask = 0;
	for (i = 0, iLimiT = ((numFreeLists()) - 1); i <= iLimiT; i += 1) {
		printHex(GIV(freeLists)[i]);
		if ((GIV(freeLists)[i]) != 0) {
			expectedMask += 1U << i;
		}
		if (((i + 1) % (8)) == 0) {
			cr();
		}
		else {
			print("  ");
		}
	}
	cr();
	print("mask: ");
	printHexnp(GIV(freeListsMask));
	print(" expected: ");
	printHexnp(expectedMask);
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeList: */
sqInt
printFreeList(sqInt chunkOrIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;

	if ((chunkOrIndex >= 0)
	 && (chunkOrIndex < (numFreeLists()))) {
		return printFreeList(GIV(freeLists)[chunkOrIndex]);
	}
	freeChunk = chunkOrIndex;
	while (freeChunk != 0) {
		printFreeChunk(freeChunk);
		freeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk);
	}
	return 0;
}

	/* SpurMemoryManager>>#printFreeObject:on: */
static void NoDbgRegParms
printFreeObjecton(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a free chunk of size %" PRIdSQINT " 0th field:%p\n",
			((void *)oop),
			bytesInBody(oop),
			((void *)(fetchPointerofFreeChunk(0, oop))));
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeTree */
void
printFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFreeTreeChunk(GIV(freeLists)[0]);
}


/*	Slang is blind-sided by the inlining of printFreeTreeChunk: into
	printFreeTree. 
 */

	/* SpurMemoryManager>>#printFreeTreeChunk: */
static void NoDbgRegParms
printFreeTreeChunk(sqInt chunkOrZero)
{
	if (chunkOrZero > 0) {
		printFreeTreeChunk(fetchPointerofFreeChunk(freeChunkSmallerIndex(), chunkOrZero));
		printFreeChunk(chunkOrZero);
		printFreeTreeChunk(fetchPointerofFreeChunk(freeChunkLargerIndex(), chunkOrZero));
	}
}


/*	useful for VM debugging */
/*	N.B. No safety bounds checks!! We need to look e.g. at corpses. */

	/* SpurMemoryManager>>#printHeaderOf: */
void
printHeaderOf(sqInt objOop)
{
	printHexnp(objOop);
	if (hasOverflowHeader(objOop)) {
		print(" hdr16 slotf ");
		printHexnp(numSlotsOfAny(objOop - (allocationUnit())));
		print(" slotc ");
		printHexnp(longAt(objOop - BaseHeaderSize));
		/* begin space */
		printChar(' ');
	}
	else {
		print(" hdr8 slots ");
		printHexnp(numSlotsOfAny(objOop));
	}
	/* begin space */
	printChar(' ');
	printChar((isMarked(objOop)
		? 'M'
		: 'm'));
	printChar((isGrey(objOop)
		? 'G'
		: 'g'));
	printChar((isPinned(objOop)
		? 'P'
		: 'p'));
	printChar((isRemembered(objOop)
		? 'R'
		: 'r'));
	printChar((isImmutable(objOop)
		? 'I'
		: 'i'));
	print(" hash ");
	printHexnp(rawHashBitsOf(objOop));
	print(" fmt ");
	printHexnp(formatOf(objOop));
	print(" cidx ");
	printHexnp(classIndexOf(objOop));
	cr();
}

	/* SpurMemoryManager>>#printImmediateObject:on: */
static void NoDbgRegParms
printImmediateObjecton(sqInt oop, FILE *aStream)
{
	assert(isImmediate(oop));
	if ((oop & 1)) {
		fprintf(aStream,
				"%p=%" PRIdSQINT "\n",
				((void *)oop),
				((sqInt)((oop >> 1))));
	}
	if ((oop & (tagMask())) == (characterTag())) {
		fprintf(aStream,
				"%p=$%" PRIdSQINT " ($%lc)\n",
				((void *)oop),
				((long)(characterValueOf(oop))),
				((wint_t) (characterValueOf(oop))));
	}
	}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = rawHashBitsOf(aClassOop);
	if (classIndex != (isFreeObjectClassIndexPun())) {
		printInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing the oops of any and all objects whose classIndex
	equals the argument.
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printInstancesWithClassIndex: */
void
printInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((classIndexOf(objOop)) == classIndex) {
			printHex(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop1 = objectStartingAt(start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if ((classIndexOf(objOop1)) == classIndex) {
			printHex(objOop1);
			cr();
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress1)))
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
}


/*	Print the objects in the classTable that have bad hashes. */
/*	useful for debugging */

	/* SpurMemoryManager>>#printInvalidClassTableEntries */
void
printInvalidClassTableEntries(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil1;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt j;
    sqInt jLimiT;
    sqInt page;

	if (!(validClassTableRootPages())) {
		print("class table invalid; cannot print");
		cr();
		return;
	}
	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = fetchPointerofObject(i, GIV(hiddenRootsObj));
		for (j = 0, jLimiT = ((classTablePageSize()) - 1); j <= jLimiT; j += 1) {
			classOrNil1 = fetchPointerofObject(j, page);
			if (classOrNil1 != GIV(nilObj)) {
				index = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
				if (((!((longAt(classOrNil1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
				 || ((((hash = rawHashBitsOf(classOrNil1))) == 0)
				 || ((noCheckClassAtIndex(hash)) != classOrNil1))) {
					print("entry ");
					printHex(index);
					print(" oop ");
					printHex(classOrNil1);
					print(" hash ");
					printHex(hash);
					print(" => ");
					printHex(classAtIndex(hash));
					cr();
				}
			}
		}
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMarkedOops */
#if LLDB
void
printMarkedOops(void)
{
	printOopsSuchThat(isMarked);
}
#endif /* LLDB */


/*	Scan the heap printing the oops of any and all methods that implement
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMethodImplementorsOf: */
void
printMethodImplementorsOf(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if ((isCompiledMethod(obj1))
			 && ((maybeSelectorOfMethod(obj1)) == anOop)) {
				printHex(obj1);
				/* begin space */
				printChar(' ');
				/* begin printOopShort: */
				printOopShortInner(obj1);
				/* begin flush */
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}


/*	Scan the heap printing the oops of any and all methods that refer to anOop */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if (isCompiledMethod(obj1)) {
				i = ((literalCountOf(obj1)) + LiteralStart) - 1;
				while (((i -= 1)) >= 0) {
					if (anOop == (fetchPointerofObject(i, obj1))) {
						printHex(obj1);
						print(" @ ");
						printNum(i);
						/* begin space */
						printChar(' ');
						/* begin printOopShort: */
						printOopShortInner(obj1);
						/* begin flush */
						fflush(GIV(transcript));
						cr();
						i = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}

	/* SpurMemoryManager>>#printNonPointerDataOf:on: */
static void NoDbgRegParms
printNonPointerDataOfon(sqInt oop, FILE *aStream)
{
    sqInt elementsPerLine;
    sqInt format;
    sqInt index;
    sqInt lastIndex;
    usqInt numSlots;

	format = formatOf(oop);
	assert(((format >= (sixtyFourBitIndexableFormat())) && (format <= ((firstCompiledMethodFormat()) - 1))));
	/* begin lengthOf:format: */

	/* don't let forwarders freak us out... */
	numSlots = numSlotsOfAny(oop);
	if (format <= (ephemeronFormat())) {
		lastIndex = numSlots;
		goto l1;
	}
	if (format >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		lastIndex = (numSlots << (shiftForWord())) - (format & 7);
		goto l1;
	}
	if (format >= (firstShortFormat())) {
		lastIndex = (numSlots << ((shiftForWord()) - 1)) - (format & 3);
		goto l1;
	}
	if (format >= (firstLongFormat())) {
		lastIndex = (numSlots << ((shiftForWord()) - 2)) - (format & 1);
		goto l1;
	}
	if (format == (sixtyFourBitIndexableFormat())) {
		lastIndex = (numSlots) >> 1;
		goto l1;
	}
	lastIndex = 0;
	l1:	/* end lengthOf:format: */;
	if (lastIndex == 0) {
		return;
	}
	if (format == (sixtyFourBitIndexableFormat())) {
		lastIndex = ((32 < lastIndex) ? 32 : lastIndex);

		/* 0x/16r0123456789ABCDEF<space|cr> x 4 = 76/80 */
		elementsPerLine = 4;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%18p%c",
					((usqLong) (fetchLong64ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
				? '\n'
				: ' '));
		}
		return;
	}
	if (format < (firstShortFormat())) {
		lastIndex = ((64 < lastIndex) ? 64 : lastIndex);

		/* 0x/16r12345678<space|cr> x 8 = 80/88 */
		elementsPerLine = 8;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%10p%c",
					((void *)(fetchLong32ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
				? '\n'
				: ' '));
		}
		return;
	}
	if (format < (firstByteFormat())) {
		lastIndex = ((128 < lastIndex) ? 128 : lastIndex);

		/* 0x/16r1234<space|cr> x 10 = 70/80 */
		elementsPerLine = 10;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%6p%c",
					((void *)(fetchShort16ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
				? '\n'
				: ' '));
		}
		return;
	}
	lastIndex = ((0x100 < lastIndex) ? 0x100 : lastIndex);

	/* 0x/16r12<space|cr> x 16 = 80/96 */
	elementsPerLine = 16;
	for (index = 1; index <= lastIndex; index += 1) {
		fprintf(aStream,
				"%4p%c",
				((void *)(fetchByteofObject(index - 1, oop))),
				(((index % elementsPerLine) == 0)
		 || (index == lastIndex)
			? '\n'
			: ' '));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress)) {
		if (!((isFreeObject(oop))
			 || (isSegmentBridge(oop)))) {
			printOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all objects whose hash equals
	the argument.
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printObjectsWithHash: */
void
printObjectsWithHash(sqInt hash)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((rawHashBitsOf(objOop)) == hash) {
			shortPrintOop(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop1 = objectStartingAt(start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if ((rawHashBitsOf(objOop1)) == hash) {
			shortPrintOop(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress1)))
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
}

	/* SpurMemoryManager>>#printObjStackAndContents: */
void
printObjStackAndContents(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printObjStack:printContents: */
	if (objStack == GIV(nilObj)) {
		print("nil");
		cr();
	}
	else {
		printObjStackPagemyIndexpageTypeprintContents(objStack, fetchPointerofObject(ObjStackMyx, objStack), ObjStackMyx, 1);
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:pageType:printContents: */
static void NoDbgRegParms
printObjStackPagemyIndexpageTypeprintContents(sqInt objStackPage, sqInt myx, sqInt pageType, sqInt printContents)
{
    sqInt freeOrNextPage;
    sqInt index;
    int isFirstPage;
    int isFreePage;
    int isNextPage;
    sqInt page;

	isFirstPage = pageType == ObjStackMyx;
	isNextPage = pageType == ObjStackNextx;
	isFreePage = pageType == ObjStackFreex;
	printObjStackPagemyIndextag(objStackPage, myx, (isFirstPage
		? "head"
		: (isFreePage
				? "free"
				: "next")));
	if (isFirstPage
	 || (isNextPage)) {
		/* begin tab */
		printChar('\t');
		print("topx: ");
		printNum(fetchPointerofObject(ObjStackTopx, objStackPage));
		print(" next: ");
		printHex(fetchPointerofObject(ObjStackNextx, objStackPage));
		if (isFirstPage) {
			print(" free: ");
			printHex(fetchPointerofObject(ObjStackFreex, objStackPage));
		}
		cr();
	}
	if (isFirstPage) {
		freeOrNextPage = fetchPointerofObject(ObjStackFreex, objStackPage);
		while (freeOrNextPage != 0) {
			printObjStackPagemyIndexpageTypeprintContents(freeOrNextPage, myx, ObjStackFreex, 0);
			page = fetchPointerofObject(ObjStackFreex, freeOrNextPage);
			if ((page == freeOrNextPage)
			 || (page == objStackPage)) {
				print("circularity in free page list!!");
				cr();
				page = 0;
			}
			freeOrNextPage = page;
		}
	}
	freeOrNextPage = fetchPointerofObject(ObjStackNextx, objStackPage);
	if (freeOrNextPage != 0) {
		printObjStackPagemyIndexpageTypeprintContents(freeOrNextPage, myx, ObjStackNextx, printContents);
	}
	if (printContents) {
		index = (fetchPointerofObject(ObjStackTopx, objStackPage)) + ObjStackNextx;
		while (index >= ObjStackFixedSlots) {
			/* begin space */
			printChar(' ');
			printHex(fetchPointerofObject(index, objStackPage));
			index -= 1;
		}
		if (((fetchPointerofObject(ObjStackTopx, objStackPage)) + ObjStackNextx) >= ObjStackFixedSlots) {
			cr();
		}
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:tag: */
static void NoDbgRegParms
printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType)
{
	print(pageType);
	/* begin space */
	printChar(' ');
	printHex(objStackPage);
	/* begin space */
	printChar(' ');
	print("cx ");
	printNum(classIndexOf(objStackPage));
	print(" (");
	printNum(wordSizeClassIndexPun());
	print(") fmt ");
	printNum(formatOf(objStackPage));
	print(" (");
	printNum(wordIndexableFormat());
	print(") sz ");
	printNum(numSlotsOfAny(objStackPage));
	print(" (");
	printNum(ObjStackPageSlots);
	print(") myx: ");
	printNum(fetchPointerofObject(ObjStackMyx, objStackPage));
	print(" (");
	printNum(myx);
	print((isMarked(objStackPage)
		? ") mkd"
		: ") unmkd"));
	cr();
}


/*	useful for debugging */

	/* SpurMemoryManager>>#printObjStack: */
void
printObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printObjStack:printContents: */
	if (objStack == GIV(nilObj)) {
		print("nil");
		cr();
	}
	else {
		printObjStackPagemyIndexpageTypeprintContents(objStack, fetchPointerofObject(ObjStackMyx, objStack), ObjStackMyx, 0);
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsExcept: */
void NeverInline
printOopsExcept(sqInt (*function)(sqInt))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt n;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (!(function(objOop))) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop1 = objectStartingAt(start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (!(function(objOop1))) {
			n += 1;
			printEntity(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress1)))
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
	if (n > 4) {

		/* rabbits */
		printNum(n);
		print(" objects");
		cr();
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsFrom:to: */
void
printOopsFromto(sqInt startAddress, sqInt endAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstNonEntity;
    sqInt inEmptySpace;
    sqInt lastNonEntity;
    sqInt limit;
    sqInt oop;

	firstNonEntity = 0;
	oop = objectBefore(startAddress);
	limit = (((((usqIntptr_t)endAddress)) < GIV(endOfMemory)) ? (((usqIntptr_t)endAddress)) : GIV(endOfMemory));
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	inEmptySpace = 0;
	while (oopisLessThan(oop, limit)) {
		printEntity(oop);
		while (1) {
			oop = objectAfter(oop);
			if (!((long64At(oop)) == 0)) break;
			if (!inEmptySpace) {
				inEmptySpace = 1;
				firstNonEntity = oop;
			}
			lastNonEntity = oop;
		}
		if (inEmptySpace) {
			inEmptySpace = 0;
			print("skipped empty space from ");
			printHexnp(firstNonEntity);
			print(" to ");
			printHexnp(lastNonEntity);
			cr();
			oop = objectStartingAt(oop);
		}
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsSuchThat: */
void NeverInline
printOopsSuchThat(sqInt (*function)(sqInt))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    sqInt followingWord1;
    usqInt followingWordAddress;
    usqInt followingWordAddress1;
    sqInt n;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    usqInt start;

	n = 0;
	/* begin allHeapEntitiesDo: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (function(objOop)) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
	l1:	/* end objectAfter:limit: */;
	}
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj1 = (prevObj1 = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	start = (GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart)));
	if (start > GIV(freeStart)) {
		goto l3;
	}
	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((eden()).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((eden()).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((eden()).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((eden()).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((eden()).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop1 = objectStartingAt(start);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		if (function(objOop1)) {
			n += 1;
			printEntity(objOop1);
		}
		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress1 = addressAfter(objOop1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress1, GIV(freeStart))) {
			objOop1 = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord1 = longAt(followingWordAddress1 + 4);
		objOop1 = ((((usqInt)(followingWord1)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress1)))
					? (followingWordAddress1 + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress1 + BaseHeaderSize)
			: followingWordAddress1);
	l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
	l3:	/* end allNewSpaceEntitiesDo: */;
	if (n > 4) {

		/* rabbits */
		printNum(n);
		print(" objects");
		cr();
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt header;
    sqInt i;
    sqInt numLiterals;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt sp;
    sqInt startObject;

	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			/* begin numPointerSlotsOf: */
			fmt = formatOf(obj1);
			/* begin numPointerSlotsOf:format: */
			if (fmt <= (lastPointerFormat())) {
				if ((fmt == (indexablePointersFormat()))
				 && ((classIndexOf(obj1)) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = fetchPointerofObject(StackPointerIndex, obj1);
					if (!((sp & 1))) {
						contextSize = 0;
						goto l5;
					}
					assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(obj1)));
					contextSize = (sp >> 1);
	l5:	/* end fetchStackPointerOf: */;
					i = ((usqInt) (CtxtTempFrameStart + contextSize));
					goto l6;
				}
				i = numSlotsOf(obj1);
				goto l6;
			}
			if (fmt == (forwardedFormat())) {
				i = 1;
				goto l6;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				i = 0;
				goto l6;
			}
			header = methodHeaderOf(obj1);
			/* begin literalCountOfMethodHeader: */
			assert((header & 1));
			numLiterals = ((header >> 1)) & AlternateHeaderNumLiteralsMask;
			i = ((usqInt) (numLiterals + LiteralStart));
	l6:	/* end numPointerSlotsOf: */;
			while (((i -= 1)) >= 0) {
				if (anOop == (fetchPointerofMaybeForwardedObject(i, obj1))) {
					printHex(obj1);
					print(" @ ");
					printNum(i);
					/* begin space */
					printChar(' ');
					/* begin printOopShort: */
					printOopShortInner(obj1);
					/* begin flush */
					fflush(GIV(transcript));
					cr();
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}

	/* SpurMemoryManager>>#printStringDataOf:on: */
static void NoDbgRegParms
printStringDataOfon(sqInt oop, FILE *aStream)
{
    char *buffer;
    sqInt byte;
    sqInt i;
    sqInt limit;
    sqInt n;
    unsigned int *wideBuffer;
    sqInt word;

	if (isBytesNonImm(oop)) {
		buffer = ((char *) (alloca(0x400)));
		n = (i = 0);
		limit = (((numBytesOfBytes(oop)) < 0x100) ? (numBytesOfBytes(oop)) : 0x100);
		while (n < limit) {
			byte = fetchByteofObject(i, oop);
			i += 1;
			if ((byte < 32)
			 && (byte != 9)) {
				buffer[n] = '<';
				n += 1;
				if ((byte == 10)
				 || (byte == 13)) {
					if (byte == 10) {
						buffer[n] = 'L';
						buffer[n + 1] = 'F';
					}
					else {
						buffer[n] = 'C';
						buffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (byte >= 10) {
						buffer[n] = ((byte / 10) + (((sqInt)'0')));
						n += 1;
					}
					buffer[n] = ((byte % 10) + (((sqInt)'0')));
					n += 1;
				}
				buffer[n] = '>';
				n += 1;
			}
			else {
				buffer[n] = byte;
				n += 1;
			}
		}
		fprintf(aStream,
				"%.*s%s\n",
				((int) n),
				buffer,
				((numBytesOfBytes(oop)) > limit
			? "..."
			: ""));
	}
	else {
		assert(isWordsNonImm(oop));
		wideBuffer = ((int *) (alloca(0x1000)));
		n = (i = 0);
		limit = (((lengthOf(oop)) < 0x100) ? (lengthOf(oop)) : 0x100);
		while (i < limit) {
			word = fetchLong32ofObject(i, oop);
			i += 1;
			if ((word < 32)
			 && (word != 9)) {
				wideBuffer[n] = '<';
				n += 1;
				if ((word == 10)
				 || (word == 13)) {
					if (word == 10) {
						wideBuffer[n] = 'L';
						wideBuffer[n + 1] = 'F';
					}
					else {
						wideBuffer[n] = 'C';
						wideBuffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (word >= 10) {
						wideBuffer[n] = ((word / 10) + (((sqInt)'0')));
						n += 1;
					}
					wideBuffer[n] = ((word % 10) + (((sqInt)'0')));
					n += 1;
				}
				wideBuffer[n] = '>';
				n += 1;
			}
			else {
				wideBuffer[n] = word;
				n += 1;
			}
		}
		fwprintf(aStream,
				L"%.*ls%s\n",
				((int) n),
				wideBuffer,
				((lengthOf(oop)) > limit
			? "..."
			: ""));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printUnmarkedOops */
#if LLDB
void
printUnmarkedOops(void)
{
	printOopsExcept(isMarked);
}
#endif /* LLDB */


/*	Attempt to push anEphemeron on the unscanned ephemerons stack
	and answer if the attempt succeeded. Note that the ephemeron
	stack overflowing isn't a disaster; it simply means treating the
	ephemeron as strong in this GC cycle. */

	/* SpurMemoryManager>>#pushOnUnscannedEphemeronsStack: */
static sqInt NoDbgRegParms
pushOnUnscannedEphemeronsStack(sqInt anEphemeron)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isEphemeron(anEphemeron));
	if (((GIV(unscannedEphemerons).top)) >= ((GIV(unscannedEphemerons).limit))) {
		return 0;
	}
	longAtput((GIV(unscannedEphemerons).top), anEphemeron);
	(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) + BytesPerOop);
	return 1;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that
	objects in temporary variables are properly remapped.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}

	/* SpurMemoryManager>>#rawHashBitsOf: */
sqInt
rawHashBitsOf(sqInt objOop)
{
	flag("endianness");
	return (long32At(objOop + 4)) & (identityHashHalfWordMask());
}

	/* SpurMemoryManager>>#rememberedSetObj: */
static void NoDbgRegParms
rememberedSetObj(sqInt anObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isOldObject(anObj));
	storePointerUncheckedofObjectwithValue(RememberedSetRootIndex, GIV(hiddenRootsObj), anObj);
}


/*	Remove the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#removeGCRoot: */
sqInt
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Byte-swap the given range of memory (not inclusive of stopAddr!). */

	/* SpurMemoryManager>>#reverseBytesFrom:to: */
static void NoDbgRegParms
reverseBytesFromto(sqInt startAddr, sqInt stopAddr)
{
    sqInt addr;

	addr = startAddr;
	while (oopisLessThan(addr, stopAddr)) {
		longAtput(addr, byteSwapped(longAt(addr)));
		addr += BytesPerWord;
	}
}

	/* SpurMemoryManager>>#reverseBytesInMemory */
static void
reverseBytesInMemory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	reverseBytesFromto(GIV(oldSpaceStart), GIV(endOfMemory));
}

	/* SpurMemoryManager>>#roundUpHeapSize: */
static usqInt NoDbgRegParms
roundUpHeapSize(usqInt heapSize)
{
    sqInt bit;

	bit = (((highBit(heapSize)) - 1) * 3) / 4;
	return (((heapSize & ((1U << bit) - 1)) != 0)
		? (((heapSize | ((1U << bit) - 1)) - ((1U << bit) - 1))) + (1U << bit)
		: heapSize);
}

	/* SpurMemoryManager>>#scavengeInProgress */
static sqInt
scavengeInProgress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(gcPhaseInProgress) == ScavengeInProgress;
}


/*	David's paper uses 140Kb eden + 2 x 28kb survivor spaces,
	which is 5 7ths for eden and 1 7th each for the survivor spaces.
	So express scavenger sizes in 7ths */

	/* SpurMemoryManager>>#scavengerDenominator */
static sqInt
scavengerDenominator(void)
{
	return 7;
}

	/* SpurMemoryManager>>#setHashBitsOf:to: */
static void NoDbgRegParms
setHashBitsOfto(sqInt objOop, sqInt hash)
{
	flag("endianness");
	assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
	long32Atput(objOop + 4, ((((long32At(objOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
}


/*	Set the dimensions of the heap, answering the start of oldSpace. edenBytes
	holds the desired ``size of eden''
	which is actually the total size of new space minus the reserve. edenBytes
	is then divided up between eden
	and the two survivor spaces, where each survivor space is a
	scavengerDenominator (one seventh) of the total. */
/*	Transcript
	cr; nextPutAll: 'heapBase: '; print: baseOfHeap; nextPut: $/; nextPutAll:
	baseOfHeap hex;
	nextPutAll: ' memLimit '; print: memLimit; nextPut: $/; nextPutAll:
	memLimit hex;
	nextPutAll: ' memEnd '; print: memEnd; nextPut: $/; nextPutAll: memEnd
	hex; cr; flush. */
/*	This is more than a little counter-intuitive. Eden must include
	interpreterAllocationReserveBytes. 
 */

	/* SpurMemoryManager>>#setHeapBase:memoryLimit:endOfMemory: */
static sqInt NoDbgRegParms NeverInline
setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt reserve;

	/* begin interpreterAllocationReserveBytes */
	reserve = 0;
	GIV(newSpaceStart) = baseOfHeap;
	GIV(oldSpaceStart) = (baseOfHeap + GIV(edenBytes)) + reserve;
	newSpaceStartnewSpaceBytessurvivorBytes(GIV(newSpaceStart), GIV(oldSpaceStart) - GIV(newSpaceStart), ((GIV(oldSpaceStart) - GIV(newSpaceStart)) - reserve) / (scavengerDenominator()));
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(freeOldSpaceStart) = memEnd;
	GIV(endOfMemory) = memLimit;
	return baseOfHeap;
}

	/* SpurMemoryManager>>#setHiddenRootsObj: */
static void NoDbgRegParms
setHiddenRootsObj(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt j;
    sqInt page;

	GIV(hiddenRootsObj) = anOop;
	assert(validClassTableRootPages());
	GIV(classTableFirstPage) = fetchPointerofObject(0, GIV(hiddenRootsObj));
	assert(((numSlotsOf(GIV(classTableFirstPage))) - 1) == (classTableMinorIndexMask()));
	flag("remove at some stage");
	if ((classIndexOf(GIV(classTableFirstPage))) != (arrayClassIndexPun())) {
		setClassIndexOfto(GIV(classTableFirstPage), arrayClassIndexPun());
	}
	GIV(numClassTablePages) = classTableRootSlots();
	GIV(classTableIndex) = ((sqInt)((usqInt)(GIV(numClassTablePages)) << (classTableMajorIndexShift())));
	for (i = 1; i < GIV(numClassTablePages); i += 1) {
		if (((page = fetchPointerofObject(i, GIV(hiddenRootsObj)))) == GIV(nilObj)) {
			if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) > i) {
				GIV(classTableIndex) = ((sqInt)((usqInt)(((((i - 1) < 1) ? 1 : (i - 1)))) << (classTableMajorIndexShift())));
			}
			GIV(numClassTablePages) = i;
			assert((classOrNilAtIndex(GIV(classTableIndex))) == GIV(nilObj));
			return;
		}
		else {
			if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) > i) {
				j = 0;
				while (j < (classTablePageSize())) {
					if ((fetchPointerofObject(j, page)) == GIV(nilObj)) {
						GIV(classTableIndex) = (((sqInt)((usqInt)(i) << (classTableMajorIndexShift())))) + j;
						j = classTablePageSize();
					}
					j += 1;
				}
			}
		}
	}
	if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) >= GIV(numClassTablePages)) {
		GIV(classTableIndex) = 1U << (classTableMajorIndexShift());
	}
	assert((classOrNilAtIndex(GIV(classTableIndex))) == GIV(nilObj));
}

	/* SpurMemoryManager>>#setNextFreeChunkOf:withValue:chunkBytes: */
static void NoDbgRegParms
setNextFreeChunkOfwithValuechunkBytes(sqInt freeChunk, sqInt nextFreeChunk, sqInt chunkBytes)
{
    sqInt lilliputian;

	/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
	lilliputian = isLilliputianSize(chunkBytes);
	storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, freeChunk, nextFreeChunk);
	if ((nextFreeChunk != 0)
	 && (!lilliputian)) {
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, freeChunk);
	}
}


/*	Reduce the number of indexable fields in objOop, an arrayFormat or
	longFormat object, to nSlots.
	Convert the unused residual to a free chunk (if in oldSpace).
	Answer the number of bytes returned to free memory, which may be zero. */

	/* SpurMemoryManager>>#shorten:toIndexableSize: */
sqInt
shortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{
    sqInt delta;

	assert((indexableSize >= 0)
	 && (indexableSize < (lengthOf(objOop))));
	delta = doShortentoIndexableSize(objOop, indexableSize);
	assert((lengthOf(followMaybeForwarded(objOop))) == indexableSize);
	return delta;
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#shortPrintObjectsFrom:to: */
void
shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while (oopisLessThan(oop, endAddress)) {
		if (!(isFreeObject(oop))) {
			shortPrintOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Answer if the oop should be scavenged.. The method is called
	shouldRemapOop: for compatibility with ObjectMemory. */

	/* SpurMemoryManager>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (shouldRemapObj(oop));
}


/*	Answer the number of bytes in the given object, including its base header,
	rounded up to an integral number of words.
	Hence, were it not for the fact that zero-sized objects have at least room
	for a forwarding pointer,
	objOop + (self sizeBitsOf: objOop) is the address immediately following
	objOop. 
 */
/*	Note: byte indexable objects need to have low bits subtracted from this
	size to find the address beyond the last byte.
 */

	/* SpurMemoryManager>>#sizeBitsOf: */
static usqInt NoDbgRegParms
sizeBitsOf(sqInt objOop)
{
	return ((numSlotsOf(objOop)) << (shiftForWord())) + BaseHeaderSize;
}


/*	*DO NOT CONFUSE THIS WITH numSlotsOf:.
	This is an ObjectMemory compatibility method with questionable semantics.
	Answers the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	If the receiver is a short object, return the number of shorts.
	If the receiver is a word object, return the number of words.
	If the receiver is a double word object, return the number of double
	words. Otherwise return the number of pointers. */

	/* SpurMemoryManager>>#slotSizeOf: */
static sqInt NoDbgRegParms
slotSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numSlots;

	if (isImmediate(oop)) {
		return 0;
	}
	/* begin lengthOf: */
	fmt = formatOf(oop);

	/* don't let forwarders freak us out... */
	numSlots = numSlotsOfAny(oop);
	if (fmt <= (ephemeronFormat())) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (numSlots << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return (numSlots) >> 1;
	}
	return 0;
}


/*	Return one of the objects in the specialObjectsArray */

	/* SpurMemoryManager>>#splObj: */
sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(index, GIV(specialObjectsOop));
}


/*	Answer the start of objOop, which is either the address of the overflow
	size word, or objOop itself, depending on the size of the object. This may
	be applied to any kind of object, normal, forwarders or free chunks. */

	/* SpurMemoryManager>>#startOfObject: */
static usqInt NoDbgRegParms
startOfObject(sqInt objOop)
{
	return (hasOverflowHeader(objOop)
		? objOop - BaseHeaderSize
		: objOop);
}


/*	Part of InterpreterProxy's 1.14 API */

	/* SpurMemoryManager>>#statNumGCs */
sqInt
statNumGCs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statScavenges) + GIV(statIncrGCs)) + GIV(statFullGCs);
}


/*	A renaming for the Cogit, which can't make sense of GIV(oldSpaceStart) */

	/* SpurMemoryManager>>#storeCheckBoundary */
usqInt
storeCheckBoundary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(oldSpaceStart);
}

	/* SpurMemoryManager>>#storeLong32:ofObject:withValue: */
sqInt
storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt obj, sqInt valueWord)
{
	return long32Atput((obj + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << 2))), valueWord);
}

	/* SpurMemoryManager>>#storePointerNoAssert:ofFreeChunk:withValue: */
static sqInt NoDbgRegParms
storePointerNoAssertofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isOopForwarded(objOop)));
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointer:ofForwarder:withValue: */
static sqInt NoDbgRegParms
storePointerofForwarderwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(isForwarded(objOop));
	assert(!(isOopForwarded(valuePointer)));
	if (isOldObject(objOop)) {

		/* most stores into young objects */
		if (isYoung(valuePointer)) {
			/* begin possibleRootStoreInto: */
			if (!(isRemembered(objOop))) {
				remember(objOop);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointer:ofFreeChunk:withValue: */
static sqInt NoDbgRegParms
storePointerofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(isFreeObject(objOop));
	assert((valuePointer == 0)
	 || (isFreeObject(valuePointer)));
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */
/*	See SistaCogit */

	/* SpurMemoryManager>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isForwarded(objOop)));
	if (isOldObject(objOop)) {

		/* most stores into young objects */
		if (isYoung(valuePointer)) {
			/* begin possibleRootStoreInto: */
			if (!(isRemembered(objOop))) {
				remember(objOop);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointer:ofObjStack:withValue: */
static sqInt NoDbgRegParms
storePointerofObjStackwithValue(sqInt fieldIndex, sqInt objStackPage, sqInt thang)
{
	assert((formatOf(objStackPage)) == (wordIndexableFormat()));
	return longAtput((objStackPage + BaseHeaderSize) + (((sqInt)((usqInt)(fieldIndex) << (shiftForWord())))), thang);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory. */

	/* SpurMemoryManager>>#stringForCString: */
sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt len;
    usqInt newObj;
    sqInt newString;
    usqInt numBytes;
    sqInt numSlots;

	len = strlen(aCString);
	/* begin allocateSlots:format:classIndex: */
	numSlots = numSlotsForBytes(len);
	formatField = byteFormatForNumBytes(len);
	if (numSlots >= (numSlotsMask())) {
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = largeObjectBytesForSlots(numSlots);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = smallObjectBytesForSlots(numSlots);
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
		}
		newString = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		long64Atput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, ClassByteStringCompactIndex));
	}
	else {
		long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (((sqInt)((usqInt)(formatField) << (formatShift()))))) + ClassByteStringCompactIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newString = newObj;
	l1:	/* end allocateSlots:format:classIndex: */;
	if (!(newString == null)) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	On load, swizzle the pointers in an obj stack. Answer the obj stack's oop. */

	/* SpurMemoryManager>>#swizzleObjStackAt: */
static sqInt NoDbgRegParms
swizzleObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt page;
    sqInt stackOrNil;

	firstPage = (stackOrNil = fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj)));
	if (stackOrNil == GIV(nilObj)) {
		return stackOrNil;
	}
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);

		/* swizzle fields including ObjStackNextx, excluding ObjStackFreex and leave field containing the next link. */
		index = (fetchPointerofObject(ObjStackTopx, stackOrNil)) + ObjStackNextx;
		do {
			field = fetchPointerofObject(index, stackOrNil);
			if (!((field == 0)
				 || (isImmediate(field)))) {
				field = swizzleObjin(field, stackOrNil);
				storePointerofObjStackwithValue(index, stackOrNil, field);
			}
		} while(((index -= 1)) >= ObjStackNextx);
	} while(((stackOrNil = field)) != 0);
	if (((stackOrNil = fetchPointerofObject(ObjStackFreex, firstPage))) != 0) {
		page = firstPage;
		do {
			stackOrNil = swizzleObjin(stackOrNil, firstPage);
			storePointerofObjStackwithValue(ObjStackFreex, page, stackOrNil);
			page = stackOrNil;
		} while(((stackOrNil = fetchPointerofObject(ObjStackFreex, page))) != 0);
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj));
}


/*	This assert is tricky. push:onObjStack: may call topOfObjStack: just after
	pushing an
	empty page on the stack, and will ask if the second page is valid. */

	/* SpurMemoryManager>>#topOfObjStack: */
static sqInt NoDbgRegParms
topOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt topx;

	eassert(isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), objStack == (fetchPointerofObject(fetchPointerofObject(ObjStackMyx, objStack), GIV(hiddenRootsObj)))));
	topx = fetchPointerofObject(ObjStackTopx, objStack);
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	return fetchPointerofObject((topx + ObjStackFixedSlots) - 1, objStack);
}


/*	Answers the top of the remappable oop stack. Useful when writing loops.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#topRemappableOop */
sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}


/*	This method both computes the actual number of free bytes by traversing
	all free objects
	on the free lists/tree, and checks that the tree is valid. It is used
	mainly by checkFreeSpace. */

	/* SpurMemoryManager>>#totalFreeListBytes */
static sqInt
totalFreeListBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesInChunk;
    sqInt cameFrom;
    sqInt i;
    sqInt iLimiT;
    sqInt largeChild;
    sqInt listNode;
    sqInt nextNode;
    sqInt smallChild;
    sqInt totalFreeBytes;
    sqInt treeNode1;

	totalFreeBytes = 0;
	for (i = 1, iLimiT = ((numFreeLists()) - 1); i <= iLimiT; i += 1) {
		bytesInChunk = i * (allocationUnit());
		listNode = GIV(freeLists)[i];
		while (listNode != 0) {
			totalFreeBytes += bytesInChunk;
			/* begin assertValidFreeObject: */
			assert(assertInnerValidFreeObject(listNode));
			assert(bytesInChunk == (bytesInBody(listNode)));
			nextNode = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, listNode);
			assert(nextNode != listNode);
			listNode = nextNode;
		}
	}
	/* begin freeTreeNodesDo: */
	treeNode1 = GIV(freeLists)[0];
	if (treeNode1 == 0) {
		goto l1;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNode1)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode1);
		largeChild = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode1);
		assert((smallChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			bytesInChunk = bytesInBody(treeNode1);
			assert((bytesInChunk / (allocationUnit())) >= (numFreeLists()));
			listNode = treeNode1;
			while (listNode != 0) {

				/* self printFreeChunk: listNode */
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(listNode));
				assert((listNode == treeNode1)
				 || ((fetchPointerofFreeChunk(freeChunkParentIndex(), listNode)) == 0));
				totalFreeBytes += bytesInChunk;
				assert(bytesInChunk == (bytesInBody(listNode)));
				nextNode = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, listNode);
				assert(nextNode != listNode);
				listNode = nextNode;
			}
			/* treeNode1 = */ treeNode1;
			cameFrom = treeNode1;
			treeNode1 = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, treeNode1);
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode1 = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode1 = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode1 != 0);
	l1:	/* end freeTreeNodesDo: */;
	return totalFreeBytes;
}


/*	Arbitrary level at which to defer tracing large objects until later.
	The average slot size of Smalltalk objects is typically near 8.
	We do require traceImmediatelySlotLimit to be < numSlotsMask. */

	/* SpurMemoryManager>>#traceImmediatelySlotLimit */
static sqInt
traceImmediatelySlotLimit(void)
{
	return 64;
}

	/* SpurMemoryManager>>#trueObject */
sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}

	/* SpurMemoryManager>>#unlinkFreeChunk:atIndex:chunkBytes: */
static sqInt NoDbgRegParms
unlinkFreeChunkatIndexchunkBytes(sqInt chunk, sqInt index, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lilliputian;
    sqInt next;

	/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
	lilliputian = isLilliputianSize(chunkBytes);
	assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
	 && ((index > 1)
	 && ((startOfObject(chunk)) == chunk)));
	GIV(freeLists)[index] = ((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk)));
	if ((!lilliputian)
	 && (next != 0)) {
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, 0);
	}
	return chunk;
}


/*	Unlink a free object from the free lists. Do not alter totalFreeOldSpace.
	Used for coalescing.
 */

	/* SpurMemoryManager>>#unlinkFreeChunk:chunkBytes: */
static sqInt NoDbgRegParms
unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt next;
    sqInt next1;
    sqInt prev;


	/* Pathological 64 bits case - size 1 - single linked list */
	index = chunkBytes / (allocationUnit());
	
	/* Has prev element: update double linked list */
	prev = fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, freeChunk);
	if (prev != 0) {
		setNextFreeChunkOfwithValuechunkBytes(prev, fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk), chunkBytes);
		return freeChunk;
	}
	if ((index < (numFreeLists()))
	 && ((1U << index) <= GIV(freeListsMask))) {
		/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
		assert(((bytesInBody(freeChunk)) == (index * (allocationUnit())))
		 && ((index > 1)
		 && ((startOfObject(freeChunk)) == freeChunk)));
		GIV(freeLists)[index] = ((next1 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk)));
		if (next1 != 0) {
			storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next1, 0);
		}
		return freeChunk;
	}
	next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk);
	if (next == 0) {

		/* no list; remove the interior node */
		unlinkSolitaryFreeTreeNode(freeChunk);
	}
	else {

		/* list; replace node with it */
		inFreeTreeReplacewith(freeChunk, next);
	}
	return freeChunk;
}

	/* SpurMemoryManager>>#unlinkLilliputianChunk:index: */
static sqInt NoDbgRegParms NeverInline
unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt next;
    sqInt next1;
    sqInt node;
    sqInt prev;


	/* for profiling */
	node = GIV(freeLists)[index];
	prev = 0;
	while (node != 0) {
		assert(node == (startOfObject(node)));
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(node));
		next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
		if (node == freeChunk) {
			if (prev == 0) {
				/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
				assert(((bytesInBody(freeChunk)) == (index * (allocationUnit())))
				 && ((index > 1)
				 && ((startOfObject(freeChunk)) == freeChunk)));
				GIV(freeLists)[index] = ((next1 = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk)));
							}
			else {
				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, next);
							}
			return freeChunk;
		}
		prev = node;
		node = next;
	}
	error("freeChunk not found in lilliputian chunk free list");
	return 0;
}


/*	Unlink a freeTreeNode. Assumes the node has no list (null next link). */

	/* SpurMemoryManager>>#unlinkSolitaryFreeTreeNode: */
static void NoDbgRegParms
unlinkSolitaryFreeTreeNode(sqInt freeTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt larger;
    sqInt parent;
    sqInt smaller;

	assert((fetchPointerofFreeChunk(freeChunkNextIndex(), freeTreeNode)) == 0);
	smaller = fetchPointerofFreeChunk(freeChunkSmallerIndex(), freeTreeNode);
	larger = fetchPointerofFreeChunk(freeChunkLargerIndex(), freeTreeNode);
	parent = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, freeTreeNode);
	if (parent == 0) {

		/* no parent; stitch the subnodes back into the root */
		if (smaller == 0) {
			if (larger != 0) {
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, larger, 0);
			}
			GIV(freeLists)[0] = larger;
		}
		else {
			storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, smaller, 0);
			GIV(freeLists)[0] = smaller;
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
	else {

		/* parent; stitch back into appropriate side of parent. */
		if (smaller == 0) {
			storePointerofFreeChunkwithValue((freeTreeNode == (fetchPointerofFreeChunk(freeChunkSmallerIndex(), parent))
				? freeChunkSmallerIndex()
				: freeChunkLargerIndex()), parent, larger);
			if (larger != 0) {
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, larger, parent);
			}
		}
		else {
			storePointerofFreeChunkwithValue((freeTreeNode == (fetchPointerofFreeChunk(freeChunkSmallerIndex(), parent))
				? freeChunkSmallerIndex()
				: freeChunkLargerIndex()), parent, smaller);
			storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, smaller, parent);
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
}

	/* SpurMemoryManager>>#unpinObject: */
sqInt
unpinObject(sqInt objOop)
{
	assert(isNonImmediate(objOop));
	setIsPinnedOfto(objOop, 0);
	return 0;
}


/*	Snapshot did not guarantee the state of the freelist prevLink, so we need
	to update it.
	Effectively transforms the freechunk single linked list in double linked
	list. 
 */
/*	Small chunks */
/*	Skip in 64 bits size 1 which is single linked list - pathological case */

	/* SpurMemoryManager>>#updateFreeLists */
static void
updateFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    sqInt i;
    sqInt iLimiT;
    sqInt largeChild;
    sqInt min;
    sqInt smallChild;
    sqInt treeNode;

	min = 2;
	for (i = min, iLimiT = ((numFreeLists()) - 1); i <= iLimiT; i += 1) {
		updateListStartingAt(GIV(freeLists)[i]);
	}
	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		goto l1;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode);
		largeChild = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode);
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */
			updateListStartingAt(treeNode);
			/* treeNode = */ treeNode;
			cameFrom = treeNode;
			treeNode = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, treeNode);
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
	l1:	/* end freeTreeNodesDo: */;
}

	/* SpurMemoryManager>>#updateListStartingAt: */
static void NoDbgRegParms
updateListStartingAt(sqInt freeNode)
{
    sqInt obj;
    sqInt prev;

	if (freeNode == 0) {
		return;
	}
	assert(!((isLilliputianSize(bytesInBody(freeNode)))));
	prev = freeNode;
	storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, prev, 0);
	while (1) {
		obj = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, prev);
		if (!(obj != 0)) break;
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, obj, prev);
		prev = obj;
	}
}

	/* SpurMemoryManager>>#updateRootOfObjStackAt:with: */
static sqInt NoDbgRegParms
updateRootOfObjStackAtwith(sqInt objStackRootIndex, sqInt newRootPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	storePointerofObjectwithValue(objStackRootIndex, GIV(hiddenRootsObj), newRootPage);
	switch (objStackRootIndex) {
	case MarkStackRootIndex:
		GIV(markStack) = newRootPage;
		break;
	case WeaklingStackRootIndex:
		GIV(weaklingStack) = newRootPage;
		break;
	case MournQueueRootIndex:
		GIV(mournQueue) = newRootPage;
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return newRootPage;
}


/*	Answer if hiddenRootsObj is of the right size with the
	expected contents, and if numClassTablePages is correct. */

	/* SpurMemoryManager>>#validClassTableRootPages */
static sqInt
validClassTableRootPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt obj;

	if (!((numSlotsOf(GIV(hiddenRootsObj))) == ((classTableRootSlots()) + (hiddenRootSlots())))) {
		return 0;
	}
	if (!((GIV(numClassTablePages) > 1)
		 && (GIV(numClassTablePages) <= (classTableRootSlots())))) {
		return 0;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		obj = fetchPointerofObject(i, GIV(hiddenRootsObj));
		if (!((addressCouldBeObj(obj))
			 && ((numSlotsOf(obj)) == (classTablePageSize())))) {
			return 0;
		}
	}
	for (i = GIV(numClassTablePages), iLimiT = ((classTableRootSlots()) - 1); i <= iLimiT; i += 1) {
		if ((fetchPointerofObject(i, GIV(hiddenRootsObj))) != GIV(nilObj)) {
			return 0;
		}
	}
	return 1;
}


/*	useful for debugging */

	/* SpurMemoryManager>>#validFreeTree */
sqInt
validFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (validFreeTreeChunkparent(GIV(freeLists)[0], 0)) == null;
}

	/* SpurMemoryManager>>#validFreeTreeChunk:parent: */
static const char * NoDbgRegParms
validFreeTreeChunkparent(sqInt chunk, sqInt parent)
{
    const char *reason;

	if (chunk == 0) {
		return null;
	}
	if (!(addressCouldBeOldObj(chunk))) {
		return "not in old space";
	}
	if (((bytesInBody(chunk)) / (allocationUnit())) < (numFreeLists())) {
		return "too small";
	}
	if (parent != (fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, chunk))) {
		return "bad parent";
	}
	if ((segmentContainingObj(chunk)) != (segmentContainingObj(addressAfter(chunk)))) {
		return "not in one segment";
	}
	reason = validFreeTreeChunkparent(fetchPointerofFreeChunk(freeChunkSmallerIndex(), chunk), chunk);
	if (!(reason == null)) {
		return reason;
	}
	reason = validFreeTreeChunkparent(fetchPointerofFreeChunk(freeChunkLargerIndex(), chunk), chunk);
	if (!(reason == null)) {
		return reason;
	}
	return null;
}

	/* SpurMemoryManager>>#validObjStacks */
static sqInt
validObjStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(markStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(markStack))))
	 && (((GIV(weaklingStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(weaklingStack))))
	 && ((GIV(mournQueue) == GIV(nilObj))
	 || (isValidObjStack(GIV(mournQueue)))));
}


/*	1 = big, 0 = little */

	/* SpurMemoryManager>>#vmEndianness */
sqInt
vmEndianness(void)
{
	return VMBIGENDIAN;
}

	/* SpurMemoryManager>>#whereIsMaybeHeapThing: */
static char * NoDbgRegParms
whereIsMaybeHeapThing(sqInt anOop)
{
	if (isInNewSpace(anOop)) {
		if (isInEden(anOop)) {
			return " is in eden";
		}
		if (isInFutureSpace(anOop)) {
			return " is in future space";
		}
		if (isInPastSpace(anOop)) {
			return " is in past space";
		}
		return " is in new space";
	}
	if (isInOldSpace(anOop)) {
		if (!((segmentContainingObj(anOop)) == null)) {
			return " is in old space";
		}
		return " is between old space segments";
	}
	return null;
}


/*	Answer if the obj should be scavenged, or simply followed. Sent via the
	compactor from shouldRemapObj:. We test for being already scavenged
	because mapStackPages
	via mapInterpreterOops may be applied twice in the context of a global GC
	where a
	scavenge, followed by a scan-mark-free, and final compaction passes may
	result in
	scavenged fields being visited twice. */

	/* SpurPlanningCompactor>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt lastMobileObject = null;
    sqInt mobileStart;

	/* begin slidingCompactionShouldRemapObj: */
	return ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
	 || ((GIV(gcPhaseInProgress) > 0)
	 && ((scavengeInProgress()
		? (isReallyYoungObject(objOop))
			 && (!(isInFutureSpace(objOop)))
		: (oopisGreaterThanOrEqualToandLessThanOrEqualTo(objOop, mobileStart, lastMobileObject))
			 && (!(isPinned(objOop))))));
}

	/* SpurSegmentInfo>>#segLimit */
static usqInt NoDbgRegParms
segLimit(SpurSegmentInfo * self_in_segLimit)
{
	return ((self_in_segLimit->segSize)) + ((self_in_segLimit->segStart));
}


/*	Adjust swizzles by firstSegmentShift. Also computes segStarts as
	they were in the image when it was written, so that oops' segments
	can be determined and hence oops correctly swizzled. */

	/* SpurSegmentManager>>#adjustSegmentSwizzlesBy: */
static void NoDbgRegParms
adjustSegmentSwizzlesBy(sqInt firstSegmentShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oldBaseAddr;
    SpurSegmentInfo *segInfo;

	oldBaseAddr = GIV(oldSpaceStart) - firstSegmentShift;
	for (i = 0; i < GIV(numSegments); i += 1) {
		segInfo = (&(GIV(segments)[i]));
		(segInfo->segStart = ((segInfo->segStart)) + oldBaseAddr);
		(segInfo->swizzle = ((segInfo->swizzle)) - oldBaseAddr);
	}
	GIV(canSwizzle) = 1;
}


/*	Increase the number of allocated segInfos by 16. */

	/* SpurSegmentManager>>#allocateOrExtendSegmentInfos */
static void
allocateOrExtendSegmentInfos(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newNumSegs;

	if (GIV(numSegInfos) == 0) {
		GIV(numSegInfos) = 16;
		GIV(segments) = calloc(GIV(numSegInfos), sizeof(SpurSegmentInfo));
		return;
	}
	newNumSegs = GIV(numSegInfos) + 16;
	GIV(segments) = realloc(GIV(segments), newNumSegs * (sizeof(SpurSegmentInfo)));
	if (GIV(segments) == 0) {
		error("out of memory; cannot allocate more segments");
	}
	memset(GIV(segments) + GIV(numSegInfos), 0, (newNumSegs - GIV(numSegInfos)) * (sizeof(SpurSegmentInfo)));
	GIV(numSegInfos) = newNumSegs;
}

	/* SpurSegmentManager>>#bridgeAt: */
static sqInt NoDbgRegParms
bridgeAt(sqInt segIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return bridgeFor((&(GIV(segments)[segIndex])));
}

	/* SpurSegmentManager>>#bridgeFor: */
static sqInt NoDbgRegParms
bridgeFor(SpurSegmentInfo *aSegment)
{
	return objectStartingAt((segLimit(aSegment)) - (bridgeSize()));
}

	/* SpurSegmentManager>>#checkSegments */
static void
checkSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(numSegments) >= 1);
	for (i = 0; i < GIV(numSegments); i += 1) {
		assert(addressCouldBeObj(((GIV(segments)[i]).segStart)));
		assert(isValidSegmentBridge(bridgeAt(i)));
	}
	assert(((segLimit(&GIV(segments)[GIV(numSegments) - 1])) - (bridgeSize())) == (endOfMemory()));
}


/*	The image has been loaded, old segments reconstructed, and the heap
	swizzled into a single contiguous segment. Collapse the segments into one. */

	/* SpurSegmentManager>>#collapseSegmentsPostSwizzle */
static void
collapseSegmentsPostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo * cascade0;

	GIV(canSwizzle) = 0;
	GIV(numSegments) = 1;
	computeTotalHeapSizeIncludingBridges();
	cascade0 = (&(GIV(segments)[0]));
	(cascade0->segStart = oldSpaceStart());
	(cascade0->segSize = GIV(totalHeapSizeIncludingBridges));
	assert(isSegmentBridge(bridgeAt(0)));
	assert((numSlotsOfAny(bridgeAt(0))) == 0);
}

	/* SpurSegmentManager>>#computeTotalHeapSizeIncludingBridges */
static void
computeTotalHeapSizeIncludingBridges(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(totalHeapSizeIncludingBridges) = (endOfMemory()) - (oldSpaceStart());
}

	/* SpurSegmentManager>>#isInSegments: */
static sqInt NoDbgRegParms
isInSegments(usqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < (segLimit(&GIV(segments)[i]))) {
			return 1;
		}
	}
	return 0;
}


/*	bridges bridge the gaps between segments. They are the last object in each
	segment. 
 */

	/* SpurSegmentManager>>#isValidSegmentBridge: */
static sqInt NoDbgRegParms
isValidSegmentBridge(sqInt objOop)
{
	return ((addressCouldBeObj(objOop))
	 || (objOop == (endOfMemory())))
	 && ((isSegmentBridge(objOop))
	 && ((hasOverflowHeader(objOop))
	 || ((numSlotsOfAny(objOop)) == 0)));
}

	/* SpurSegmentManager>>#lastSegment */
static SpurSegmentInfo
lastSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(segments)[GIV(numSegments) - 1];
}


/*	Read numBytes of image data from f into memory at memoryBaseForImageRead.
	Answer the number of bytes written. In addition, read each segment, build
	up the
	segment info for swizzling, while eliminating the bridge objects at the
	end of each
	segment that specify the distance to and the size of the subsequent
	segment.  */

	/* SpurSegmentManager>>#readHeapFromImageFile:dataBytes: */
static sqInt NoDbgRegParms
readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bridge;
    sqInt bridgehead;
    usqInt bridgeSpan;
    sqInt bytesRead;
    usqInt newBase;
    usqInt nextSegmentSize;
    sqInt oldBase;
    SpurSegmentInfo *segInfo;
    sqInt totalBytesRead;

	allocateOrExtendSegmentInfos();
	GIV(numSegments) = (totalBytesRead = 0);

	/* N.B. still must be adjusted by oldBaseAddr. */
	oldBase = 0;
	newBase = oldSpaceStart();
	nextSegmentSize = GIV(firstSegmentSize);
	bridgehead = (GIV(firstSegmentSize) + (oldSpaceStart())) - (bridgeSize());
	while (1) {
		segInfo = (&(GIV(segments)[GIV(numSegments)]));
		(segInfo->segStart = oldBase);
		(segInfo->segSize = nextSegmentSize);
		(segInfo->swizzle = newBase - oldBase);
		bytesRead = sqImageFileRead(pointerForOop(newBase), sizeof(char), nextSegmentSize, f);
		if (bytesRead > 0) {
			totalBytesRead += bytesRead;
		}
		if (bytesRead != nextSegmentSize) {
			return totalBytesRead;
		}
		if (((GIV(numSegments) += 1)) >= GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		bridge = bridgehead + BaseHeaderSize;
		bridgeSpan = ((byteAt(bridgehead + 7)) == 0
			? 0
			: BytesPerOop * (longAt(bridge - BaseHeaderSize)));
		oldBase = (oldBase + nextSegmentSize) + bridgeSpan;
		newBase = (newBase + nextSegmentSize) - (bridgeSize());
		nextSegmentSize = ((usqInt)(long64At(bridge)));
		if (!(nextSegmentSize != 0)) break;
		bridgehead = (bridgehead - (bridgeSize())) + nextSegmentSize;
	}
	assert((newBase - (oldSpaceStart())) == (totalBytesRead - (GIV(numSegments) * (bridgeSize()))));
	/* begin setFreeOldSpaceStart: */
	GIV(freeOldSpaceStart) = newBase;
	GIV(firstSegmentSize) = null;
	return totalBytesRead;
}


/*	Answer the segment containing an object. This is mostly for assert
	checking, but
	variations on the incremental GC may use it in anger. Binary search is (of
	course) marginally slower than linear search for a single segment (e.g. in
	a 720k object heap,
	67.1ms vs 61.3ms, or 9.5% slower to derive the segment containing every
	old space
	entity), but usefully faster for many segments (e.g. 92.7ms vs 116ms, or
	20% faster
	in the same heap extended with enough large arrays to require 11 segments;
	and this
	is pessimal; there are fewer objects at high addresses since the large
	arrays are there). */

	/* SpurSegmentManager>>#segmentContainingObj: */
SpurSegmentInfo *
segmentContainingObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt high;
    sqInt low;
    sqInt mid;
    SpurSegmentInfo *seg;

	low = 0;
	mid = GIV(numSegments) / 2;
	high = GIV(numSegments) - 1;
	do {
		seg = (&(GIV(segments)[mid]));
		if (oopisGreaterThanOrEqualTo(objOop, (seg->segStart))) {
			if (mid == high) {
				return (oopisLessThan(objOop, segLimit(seg))
					? seg
					: 0);
			}
			else {
				low = mid;
				mid = ((mid + high) + 1) / 2;
			}
		}
		else {
			high = mid - 1;
			mid = (low + mid) / 2;
		}
	} while(low <= high);
	return null;
}

	/* SpurSegmentManager>>#someSegmentContainsPinned */
static sqInt
someSegmentContainsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (((GIV(segments)[i]).containsPinned)) {
			return 1;
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#swizzleObj: */
static sqInt NoDbgRegParms
swizzleObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(canSwizzle));
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}


/*	This ``slow'' count is for asserts only. */

	/* SpurSegmentManager>>#totalBytesInSegments */
static usqInt
totalBytesInSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt total;

	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	return total;
}

	/* SpurSegmentManager>>#totalOldSpaceCapacity */
static sqInt
totalOldSpaceCapacity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges));
	return GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (bridgeSize()));
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static sqInt NoDbgRegParms
addressCouldBeClassObj(sqInt maybeClassObj)
{
	return (addressCouldBeObj(maybeClassObj))
	 && (objCouldBeClassObj(maybeClassObj));
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
sqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
sqInt
argumentCountOf(sqInt methodPointer)
{
	return argumentCountOfMethodHeader(methodHeaderOf(methodPointer));
}


/*	Abort on image load, because of invalid version info, etc, with an error
	message 
 */

	/* StackInterpreter>>#bailOutOfImageLoad: */
static sqInt NoDbgRegParms
bailOutOfImageLoad(sqInt rawVersion)
{
	print("This interpreter (vers. ");
	printNum(imageFormatVersion());
	print(") cannot read image file (vers. ");
	printNum(rawVersion);
	print(").");
	cr();
	print("Press CR to quit...");
	getchar();
	/* begin ioExitWithErrorCode: */
	exit(1);
	return 0;
}


/*	Check that the classes the VM assumes are compact have the right indices. */

	/* StackInterpreter>>#checkAssumedCompactClasses */
static void
checkAssumedCompactClasses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassArray, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassArrayCompactIndex))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassLargeNegativeInteger, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassLargeNegativeIntegerCompactIndex))) {
		invalidCompactClassError("LargeNegativeInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassLargePositiveInteger, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassFloat, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassFloatCompactIndex))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassBlockClosure, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassBlockClosureCompactIndex))) {
		invalidCompactClassError("BlockClosure");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassMethodContext, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassMethodContextCompactIndex))) {
		invalidCompactClassError("MethodContext");
	}
	GIV(classByteArrayCompactIndex) = compactIndexOfClass(fetchPointerofObject(ClassByteArray, GIV(specialObjectsOop)));
}


/*	Support for embedded images. Check that the first few bytes of a potential
	header and answer if it
	looks like something the VM can load,
	The method checks the first three fields of the header (magic, header size
	& data size) & the total size.
	The magic number should be correct.
	The header size should be correct.
	The size of the data should be at least as long as the headerSize plus the
	data size in the header */
/*	Need at least headerSize bytes; no point going further if not... */

	/* StackInterpreter>>#checkImageHeaderFromBytes:AndSize: */
sqInt
checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize)
{
    sqInt dataSize;
    sqInt headerSize;
    int version;

	if (totalSize < (BytesPerWord * 16)) {
		return 0;
	}
	version = long32At(bytes);
	headerSize = long32At(bytes + 4);
	dataSize = longAt(bytes + 8);
	if (!(readableFormat(version))) {
		if (!(readableFormat(SQ_SWAP_4_BYTES(version)))) {
			return 0;
		}
		headerSize = byteSwapped(headerSize);
		dataSize = byteSwapped(dataSize);
	}
	return (headerSize == (BytesPerWord * 16))
	 && (totalSize >= (headerSize + dataSize));
}


/*	Read and verify the image file version number and answer it.
	Assign through rawVersionPtr the unswapped version number. The caller can
	then infer if the given image file needs to be byte-swapped by seeing if
	the returned value
	equals tha assigned through rawVersionPtr.
	0 is answered if no valid version could be found. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt:assignRawVersion: */
static sqInt NoDbgRegParms
checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr)
{
    sqInt version;


	/* check the version number */
	sqImageFileSeek(f, imageOffset);
	version = getWord32FromFileswap(f, 0);
	rawVersionPtr[0] = version;
	if (readableFormat(version)) {
		return version;
	}
	sqImageFileSeek(f, imageOffset);
	version = getWord32FromFileswap(f, 1);
	if (readableFormat(version)) {
		return version;
	}
	if (imageOffset == 0) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 0x200);
		version = getWord32FromFileswap(f, 0);
		rawVersionPtr[0] = version;
		if (readableFormat(version)) {
			return version;
		}
		sqImageFileSeek(f, 0x200);
		version = getWord32FromFileswap(f, 1);
		if (readableFormat(version)) {
			return version;
		}
	}
	return 0;
}


/*	Byte-swap the words of all bytes objects in a range of the 
	image, including Strings, ByteArrays, and CompiledMethods.
	This returns these objects to their original byte ordering 
	after blindly byte-swapping the entire image. For compiled 
	methods, byte-swap only their bytecodes part.
	Ensure floats are in platform-order. */

	/* StackInterpreter>>#convertFloatsToPlatformOrder */
static sqInt
convertFloatsToPlatformOrder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;
    int temp;

	if ((vmEndianness()) == GIV(imageFloatsBigEndian)) {
		return null;
	}
	assert(ClassFloatCompactIndex != 0);
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if ((classIndexOf(obj1)) == ClassFloatCompactIndex) {
				temp = long32At(obj1 + BaseHeaderSize);
				long32Atput(obj1 + BaseHeaderSize, long32At((obj1 + BaseHeaderSize) + 4));
				long32Atput((obj1 + BaseHeaderSize) + 4, temp);
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
		return 0;
}


/*	Dummy definition to allow the StackInterpreter to link against the Cog
	run-time. 
 */

	/* StackInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(void)
{
}


/*	For marking the end of a leak check print message */

	/* StackInterpreter>>#eekcr */
void NeverInline
eekcr(void)
{
	printf("\n");
}

	/* StackInterpreter>>#elementsPerPrintOopLine */
static sqInt
elementsPerPrintOopLine(void)
{
	return 5;
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static void NoDbgRegParms
ensureImageFormatIsUpToDate(sqInt swapBytes)
{
	if (swapBytes) {
		reverseBytesInImage();
	}
	else {
		convertFloatsToPlatformOrder();
	}
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static sqInt NoDbgRegParms
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = fetchPointerofObject(StackPointerIndex, aContext);
	if (!((sp & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
	return (sp >> 1);
}

	/* StackInterpreter>>#firstBytecodeOfAlternateHeader:method: */
static sqInt NoDbgRegParms
firstBytecodeOfAlternateHeadermethod(sqInt methodHeader, sqInt theMethod)
{
	return (theMethod + ((LiteralStart + (((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
}

	/* StackInterpreter>>#flush */
void
flush(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fflush(GIV(transcript));
}

	/* StackInterpreter>>#followLiteral:ofMethod: */
static sqInt NoDbgRegParms
followLiteralofMethod(sqInt offset, sqInt methodPointer)
{
	return followFieldofObject(offset + LiteralStart, methodPointer);
}


/*	Answer the next 32 or 64 bit word read from aFile, byte-swapped according
	to the swapFlag.
 */

	/* StackInterpreter>>#getLongFromFile:swap: */
static sqInt NoDbgRegParms
getLongFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead((&w), sizeof(w), 1, aFile);
	return (swapFlag
		? byteSwapped(w)
		: w);
}


/*	Answer the next 16 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getShortFromFile:swap: */
static sqInt NoDbgRegParms
getShortFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    unsigned short w;

	w = 0;
	sqImageFileRead((&w), sizeof(unsigned short), 1, aFile);
	return (swapFlag
		? ((((usqInt)(w)) >> 8) & 0xFF) | (((int)((usqInt)((w & 0xFF)) << 8)))
		: w);
}


/*	Answer the next 32 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getWord32FromFile:swap: */
static sqInt NoDbgRegParms
getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    int w;

	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, aFile);
	return (swapFlag
		? SQ_SWAP_4_BYTES(w)
		: w);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */
	shifted = anUnsignedValue;
	bitNo = 0;
#  if BytesPerWord > 4
	if (!(shifted < (1ULL << 32))) {
		shifted = (shifted) >> 32;
		bitNo += 32;
	}
#  endif
	if (!(shifted < (0x10000))) {
		shifted = (shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (0x100))) {
		shifted = (shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (16))) {
		shifted = (shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (4))) {
		shifted = (shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (2))) {
		shifted = (shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	This VM is backward-compatible with the immediately preceding version. */

	/* StackInterpreter>>#imageFormatCompatibilityVersion */
static sqInt
imageFormatCompatibilityVersion(void)
{
	return 6504;
}


/*	Snapshot image format can include additional state flags.
	Currently that is the state of multipleBytecodeSetsActive.
	Mask it out when checking compatibility with this interpreter. */

	/* StackInterpreter>>#imageFormatVersionFromSnapshot: */
static sqInt NoDbgRegParms
imageFormatVersionFromSnapshot(sqInt imageVersion)
{
	return ((imageVersion | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask);
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
static sqInt NoDbgRegParms
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		theClass = followFieldofObject(SuperclassIndex, theClass);
	}
	return 0;
}


/*	Initialize metaclassNumSlots and thisClassIndex which are used in debug
	printing, and
	classNameIndex which is used not only for debug printing but for
	is:KindOf: & is:MemberOf:
	via classNameOf:is: (evil but a reality we have to accept). */

	/* StackInterpreter>>#initializeExtraClassInstVarIndices */
static void
initializeExtraClassInstVarIndices(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt i;
    sqInt iLimiT;
    sqInt oop;

	/* begin splObj: */
	classArrayObj = fetchPointerofObject(ClassArray, GIV(specialObjectsOop));
	classArrayClass = fetchClassOfNonImm(classArrayObj);

	/* determine actual Metaclass instSize */
	GIV(metaclassNumSlots) = numSlotsOf(classArrayClass);

	/* default */
	GIV(thisClassIndex) = 5;
	for (i = (InstanceSpecificationIndex + 1), iLimiT = (numSlotsOf(classArrayClass)); i <= iLimiT; i += 1) {
		if ((fetchPointerofObject(i - 1, classArrayClass)) == classArrayObj) {
			GIV(thisClassIndex) = i - 1;
		}
	}

	/* default */
	GIV(classNameIndex) = 6;
	for (i = (InstanceSpecificationIndex + 1), iLimiT = (numSlotsOf(classArrayObj)); i <= iLimiT; i += 1) {
		oop = fetchPointerofObject(i - 1, classArrayObj);
		if (objectequalsString(oop, "Array")) {
			GIV(classNameIndex) = i - 1;
		}
	}
}

	/* StackInterpreter>>#isBooleanObject: */
static sqInt NoDbgRegParms
isBooleanObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oop == GIV(trueObj))
	 || (oop == GIV(falseObj));
}

	/* StackInterpreter>>#isFloatObject: */
sqInt
isFloatObject(sqInt oop)
{
	/* begin isFloatInstance: */
	return (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassFloatCompactIndex);
}


/*	Answer true if the oop is kind of Integer (Small or Large). */

	/* StackInterpreter>>#isKindOfInteger: */
sqInt
isKindOfInteger(sqInt oop)
{
	return ((oop & 1))
	 || (isLargeIntegerInstance(oop));
}

	/* StackInterpreter>>#isLargeIntegerObject: */
sqInt
isLargeIntegerObject(sqInt oop)
{
	return isLargeIntegerInstance(oop);
}

	/* StackInterpreter>>#isLargeNegativeIntegerObject: */
sqInt
isLargeNegativeIntegerObject(sqInt oop)
{
	return isInstanceOfClassLargeNegativeInteger(oop);
}

	/* StackInterpreter>>#isLargePositiveIntegerObject: */
sqInt
isLargePositiveIntegerObject(sqInt oop)
{
	return isInstanceOfClassLargePositiveInteger(oop);
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
sqInt
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 0x100) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
sqInt
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
sqInt
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oopClass;

	oopClass = fetchClassOf(oop);
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = followFieldofObject(SuperclassIndex, oopClass);
	}
	return 0;
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static sqInt NoDbgRegParms
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;

	numSlots = numSlotsOf(classOop);
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(fetchPointerofObject(GIV(thisClassIndex), classOop));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin lengthOf: */
	objOop = fetchPointerofObject(GIV(classNameIndex), classOop);
	/* begin lengthOf:format: */
	fmt = formatOf(objOop);

	/* don't let forwarders freak us out... */
	numSlots1 = numSlotsOfAny(objOop);
	if (fmt <= (ephemeronFormat())) {
		return numSlots1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return (numSlots1 << (shiftForWord())) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return (numSlots1 << ((shiftForWord()) - 1)) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return (numSlots1 << ((shiftForWord()) - 2)) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return (numSlots1) >> 1;
	}
	return 0;
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return fetchPointerofObject(offset + LiteralStart, methodPointer);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    char *className;
    sqInt cls;
    sqInt column;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt i;
    usqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt length;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt startIP;

	length = 0;
	if (isImmediate(oop)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (isFreeObject(oop)) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	if (((cls = fetchClassOfNonImm(oop))) == null) {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
	}
	else {
		className = nameOfClasslengthInto(cls, (&length));
		fprintf(GIV(transcript),
				"%p: a(n) %.*s",
				((void *)oop),
				((int) length),
				className);
		fprintf(GIV(transcript),
				"(%" PRIxSQINT "=>%p)",
				classIndexOf(oop),
				((void *)cls));
	}
	fmt = formatOf(oop);
	fprintf(GIV(transcript),
			" format %" PRIxSQINT "",
			fmt);
	if (fmt > (lastPointerFormat())) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	else {
		if (isIndexableFormat(fmt)) {
			/* begin lengthOf: */
			fmt1 = formatOf(oop);

			/* don't let forwarders freak us out... */
			numSlots = numSlotsOfAny(oop);
			if (fmt1 <= (ephemeronFormat())) {
				len = numSlots;
				goto l1;
			}
			if (fmt1 >= (firstByteFormat())) {

				/* bytes, including CompiledMethod */
				len = (numSlots << (shiftForWord())) - (fmt1 & 7);
				goto l1;
			}
			if (fmt1 >= (firstShortFormat())) {
				len = (numSlots << ((shiftForWord()) - 1)) - (fmt1 & 3);
				goto l1;
			}
			if (fmt1 >= (firstLongFormat())) {
				len = (numSlots << ((shiftForWord()) - 2)) - (fmt1 & 1);
				goto l1;
			}
			if (fmt1 == (sixtyFourBitIndexableFormat())) {
				len = (numSlots) >> 1;
				goto l1;
			}
			len = 0;
	l1:	/* end lengthOf: */;
			fprintf(GIV(transcript),
					" size %" PRIdSQINT "",
					len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}
	/* begin printHeaderTypeOf:on: */
	fprintf(GIV(transcript),
			" hdr%d %c%c%c%c%c",
			(hasOverflowHeader(oop)
		? 16
		: 8),
			(isImmutable(oop)
		? 'i'
		: '.'),
			(isRemembered(oop)
		? 'r'
		: '.'),
			(isPinned(oop)
		? 'p'
		: '.'),
			(isMarked(oop)
		? 'm'
		: '.'),
			(isGrey(oop)
		? 'g'
		: '.'));
	print(" hash ");
	printHex(rawHashBitsOf(oop));
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop)))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					(isIndirectAlien(oop)
				? "indirect"
				: (isPointerAlien(oop)
						? "pointer"
						: "direct")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(fetchPointerofObject(ClassString, GIV(specialObjectsOop))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	startIP = (fmt >= (firstCompiledMethodFormat())
		? (startPCOfMethod(oop)) / BytesPerWord
		: numSlotsOf(oop));
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = fetchPointerofObject(i - 1, oop);
			/* begin space */
			printChar(' ');
			printNum(i - 1);
			/* begin space */
			printChar(' ');
			printHex(fieldOop);
			/* begin space */
			printChar(' ');
			if ((i == 1)
			 && (isCompiledMethod(oop))) {
				/* begin printMethodHeaderOop: */
				printDecodeMethodHeaderOop(fieldOop);
				/* return self */
			}
			else {
				printOopShortInner(fieldOop);
			}
			cr();
		}
	}
	if (isCompiledMethod(oop)) {
		startIP = (startPCOfMethod(oop)) + 1;
		/* begin lengthOf: */
		fmt2 = formatOf(oop);

		/* don't let forwarders freak us out... */
		numSlots1 = numSlotsOfAny(oop);
		if (fmt2 <= (ephemeronFormat())) {
			lastIndex = numSlots1;
			goto l2;
		}
		if (fmt2 >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			lastIndex = (numSlots1 << (shiftForWord())) - (fmt2 & 7);
			goto l2;
		}
		if (fmt2 >= (firstShortFormat())) {
			lastIndex = (numSlots1 << ((shiftForWord()) - 1)) - (fmt2 & 3);
			goto l2;
		}
		if (fmt2 >= (firstLongFormat())) {
			lastIndex = (numSlots1 << ((shiftForWord()) - 2)) - (fmt2 & 1);
			goto l2;
		}
		if (fmt2 == (sixtyFourBitIndexableFormat())) {
			lastIndex = (numSlots1) >> 1;
			goto l2;
		}
		lastIndex = 0;
	l2:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p ",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = fetchByteofObject(index - 1, oop);
			fprintf(GIV(transcript),
					"%02x/%-+3d%c",
					byte,
					byte,
					(column == 8
				? '\n'
				: ' '));
			if (((column += 1)) > 8) {
				column = 1;
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			print("...");
		}
		if (((column >= 2) && (column <= 7))) {
			cr();
		}
	}
	else {
		if (startIP > lastIndex) {
			print("...");
			cr();
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return ((((int) methodHeader)) < 0
				? AltLongStoreBytecode
				: LongStoreBytecode);
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence.
	With full blocks as of 9/2016 the last literal of a CompiledBlock is a
	back pointer
	to the enclosing block or compiled method. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
sqInt
maybeSelectorOfMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeSelector;
    sqInt penultimateLiteral;
    sqInt ultimateLiteral;

	assert(isOopCompiledMethod(methodObj));
	ultimateLiteral = ultimateLiteralOf(methodObj);
	if (isOopCompiledMethod(ultimateLiteral)) {
		return maybeSelectorOfMethod(ultimateLiteral);
	}
	penultimateLiteral = penultimateLiteralOf(methodObj);
	if (isWordsOrBytes(penultimateLiteral)) {
		return ((fetchClassTagOfNonImm(penultimateLiteral)) == (fetchClassTagOfNonImm(fetchPointerofObject(SelectorDoesNotUnderstand, GIV(specialObjectsOop))))
			? penultimateLiteral
			: 0);
	}
	return ((isPointers(penultimateLiteral))
	 && (((numSlotsOf(penultimateLiteral)) >= 2)
	 && (((fetchPointerofObject(0, penultimateLiteral)) == methodObj)
	 && (((maybeSelector = fetchPointerofObject(1, penultimateLiteral)),
	(isWordsOrBytes(maybeSelector))
		 && ((fetchClassTagOfNonImm(maybeSelector)) == (fetchClassTagOfNonImm(fetchPointerofObject(SelectorDoesNotUnderstand, GIV(specialObjectsOop)))))))))
		? maybeSelector
		: 0);
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer)
{
	return literalofMethod((literalCountOf(methodPointer)) - 1, methodPointer);
}


/*	Answer the method class of a method which is the value of an Association
	in the last literal,
	or answer nil if there isn't one.
	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line. */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;

	literal = followLiteralofMethod((literalCountOf(methodPointer)) - 1, methodPointer);
	return ((literal != GIV(nilObj))
	 && (isPointers(literal))
		? (assert((numSlotsOf(literal)) > ValueIndex),
			followFieldofObject(ValueIndex, literal))
		: /* begin nilObject */ GIV(nilObj));
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility. The time to unpack is negligible,
	since the derived primitive function pointer is stored in the method
	cache.  */

	/* StackInterpreter>>#methodHeaderHasPrimitive: */
static sqInt NoDbgRegParms
methodHeaderHasPrimitive(sqInt methodHeader)
{
	return (/* begin alternateHeaderHasPrimitiveFlag: */
	((methodHeader & AlternateHeaderHasPrimFlag) != 0));
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static char * NoDbgRegParms
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;

	numSlots = numSlotsOf(classOop);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = fetchPointerofObject(GIV(thisClassIndex), classOop);
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClass(fetchPointerofObject(GIV(thisClassIndex), classOop));
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = fetchPointerofObject(GIV(classNameIndex), classOop)),
		isBytes(maybeNameOop))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop);
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass:lengthInto: */
static char * NoDbgRegParms
nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;

	numSlots = numSlotsOf(classOop);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = fetchPointerofObject(GIV(thisClassIndex), classOop);
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClasslengthInto(fetchPointerofObject(GIV(thisClassIndex), classOop), lengthPtr);
		}
		lengthPtr[0] = 9;
		return "bad class";
	}
	if ((numSlots > GIV(classNameIndex))
	 && (((maybeNameOop = fetchPointerofObject(GIV(classNameIndex), classOop)),
	isBytes(maybeNameOop)))) {
		lengthPtr[0] = (numBytesOfBytes(maybeNameOop));
		return firstIndexableField(maybeNameOop);
	}
	lengthPtr[0] = 9;
	return "bad class";
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
sqInt
objCouldBeClassObj(sqInt objOop)
{
    sqInt fieldOop;

	return (isPointersNonImm(objOop))
	 && (((numSlotsOfAny(objOop)) > InstanceSpecificationIndex)
	 && (((fieldOop = fetchPointerofObject(SuperclassIndex, objOop)),
	((addressCouldBeObj(fieldOop))
		 && ((isPointersNonImm(fieldOop))
		 || ((isOopForwarded(fieldOop))
		 && (isPointers(followForwarded(fieldOop))))))
		 && (((fieldOop = fetchPointerofObject(MethodDictionaryIndex, objOop)),
		((addressCouldBeObj(fieldOop))
			 && ((isPointersNonImm(fieldOop))
			 || ((isOopForwarded(fieldOop))
			 && (isPointers(followForwarded(fieldOop))))))
			 && (((fetchPointerofObject(InstanceSpecificationIndex, objOop)) & 1)))))));
}

	/* StackInterpreter>>#object:equalsString: */
static sqInt NoDbgRegParms
objectequalsString(sqInt anOop, char *aCString)
{
    sqInt len;

	len = strlen(aCString);
	return objectequalsStringofSize(anOop, aCString, len);
}

	/* StackInterpreter>>#object:equalsString:ofSize: */
static sqInt NoDbgRegParms
objectequalsStringofSize(sqInt anOop, char *aCString, sqInt aCStringStrlen)
{
	return (isBytes(anOop))
	 && (((numBytesOfBytes(anOop)) == aCStringStrlen)
	 && ((strncmp(aCString, firstIndexableField(anOop), aCStringStrlen)) == 0));
}

	/* StackInterpreter>>#penultimateLiteralOf: */
static sqInt NoDbgRegParms
penultimateLiteralOf(sqInt aMethodOop)
{
	assert(isOopCompiledMethod(aMethodOop));
	return literalofMethod((literalCountOf(aMethodOop)) - 2, aMethodOop);
}


/*	Note: With the Squeak V3 format we now have 10 bits of primitive index,
	but they are
	in two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the
	Spur format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;

	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = firstBytecodeOfAlternateHeadermethod(methodHeader, theMethod)),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt firstBytecode;
    sqInt methodHeader;

	/* begin primitiveIndexOfMethod:header: */
	methodHeader = methodHeaderOf(methodPointer);
	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
		? ((firstBytecode = firstBytecodeOfAlternateHeadermethod(methodHeader, methodPointer)),
			(byteAt(firstBytecode + 1)) + (((sqInt)((usqInt)((byteAt(firstBytecode + 2))) << 8))))
		: 0);
}

	/* StackInterpreter>>#printDecodeMethodHeaderOop: */
static void NoDbgRegParms
printDecodeMethodHeaderOop(sqInt methodHeaderOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printOopShort: */
	printOopShortInner(methodHeaderOop);
	/* begin flush */
	fflush(GIV(transcript));
	if (methodHeaderHasPrimitive(methodHeaderOop)) {
		print(" hasPrim");
	}
	if ((methodHeaderOop & LargeContextBit) != 0) {
		print(" largeFrame");
	}
	if (((methodHeaderOop >> 1)) < 0) {
		print(" altSet");
	}
	print(" nLits ");
	printNum((assert((methodHeaderOop & 1)),
	((methodHeaderOop >> 1)) & AlternateHeaderNumLiteralsMask));
	print(" nArgs ");
	printNum(argumentCountOfMethodHeader(methodHeaderOop));
	print(" nTemps ");
	printNum((((usqInt)(methodHeaderOop)) >> MethodHeaderTempCountShift) & 0x3F);
}


/*	Print n in hex, in the form '1234' (no prefix), unpadded */

	/* StackInterpreter>>#printHexnpnp: */
static sqInt NoDbgRegParms
printHexnpnp(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fprintf(GIV(transcript),
			"%" PRIxSQINT "",
			n);
}


/*	Print n in hex, in the form '0x1234', unpadded */

	/* StackInterpreter>>#printHexnp: */
static sqInt NoDbgRegParms
printHexnp(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fprintf(GIV(transcript),
			"%p",
			((void *)n));
}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */
/*	useful for VM debugging */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt methodClassAssociation;
    sqInt obj1;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj1 = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj1 % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj1, GIV(endOfMemory)))) break;
		assert((long64At(obj1)) != 0);
		if (isEnumerableObject(obj1)) {
			if ((isCompiledMethod(obj1))
			 && ((maybeSelectorOfMethod(obj1)) == selector)) {

				/* try and print the key of the method class association (the name of the implementing class) */
				methodClassAssociation = methodClassAssociationOf(obj1);
				printHexnp(obj1);
				/* begin space */
				printChar(' ');
				printOopShortInner(((isPointers(methodClassAssociation))
				 && ((numSlotsOf(methodClassAssociation)) >= 2)
					? fetchPointerofObject(0, methodClassAssociation)
					: methodClassAssociation));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj1;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj1);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj1 = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj1 = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj1, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj1, prevObj));
	}
	}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(void)
{
	printMethodCacheFor(-1);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    sqInt i;
    sqIntptr_t m;
    sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;

	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = methodCache[i + MethodCacheSelector];
		c = methodCache[i + MethodCacheClass];
		m = methodCache[i + MethodCacheMethod];
		p = methodCache[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || (m == thing)))))
		 && ((addressCouldBeOop(s))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(classForClassTag(c))))))) {
			n += 1;
			printNum(i);
			/* begin space */
			printChar(' ');
			printHexnp(i);
			cr();
			/* begin tab */
			printChar('\t');
			if (isBytesNonImm(s)) {
				fprintf(GIV(transcript),
						"%p %.*s\n",
						s,
						((int) (numBytesOfBytes(s))),
						firstIndexableField(s));
			}
			else {
				shortPrintOop(s);
			}
			/* begin tab */
			printChar('\t');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				printNum(c);
				/* begin space */
				printChar(' ');
				shortPrintOop(classForClassTag(c));
			}
			/* begin tab */
			printChar('\t');
			shortPrintOop(m);
			/* begin tab */
			printChar('\t');
			if (p > 0x400) {
				printHexnp(p);
			}
			else {
				printNum(p);
			}
			cr();
		}
	}
	if (n > 1) {
		printNum(n);
		cr();
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior)
{
	printMethodDictionary(fetchPointerofObject(MethodDictionaryIndex, behavior));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	methodArray = fetchPointerofObject(MethodArrayIndex, dictionary);
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(dictionary)) - 1); index <= indexLimiT; index += 1) {
		selector = fetchPointerofObject(index, dictionary);
		if (selector != GIV(nilObj)) {
			meth = fetchPointerofObject(index - SelectorStart, methodArray);
			/* begin printOopShort: */
			printOopShortInner(selector);
			/* begin flush */
			fflush(GIV(transcript));
			print(" => ");
			/* begin printOopShort: */
			printOopShortInner(meth);
			/* begin flush */
			fflush(GIV(transcript));
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			print(")\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static void NoDbgRegParms
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;

	if (!GIV(classNameIndex)) {
		print("??nil cnidx??");
		return;
	}
	if ((classOop == null)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class");
		return;
	}
	numSlots = numSlotsOf(classOop);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(fetchPointerofObject(GIV(thisClassIndex), classOop), cnt - 1);
		print(" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class");
		}
		else {
			printStringOf(fetchPointerofObject(GIV(classNameIndex), classOop));
		}
	}
}

	/* StackInterpreter>>#printOopShortInner: */
static void NoDbgRegParms
printOopShortInner(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classLookupKey;
    sqInt classOop;
    double f;
    char *name;
    sqInt nameLen;
    sqInt target;
    sqInt theClass1;

	if (isImmediate(oop)) {
		if ((oop & (tagMask())) == (characterTag())) {
			fprintf(GIV(transcript),
					"$%c(%x)",
					characterValueOf(oop),
					characterValueOf(oop));
			return;
		}
		if ((oop & 1)) {
			fprintf(GIV(transcript),
					"%" PRIdSQINT "(0x%" PRIxSQINT ")",
					(oop >> 1),
					(oop >> 1));
			return;
		}
		fprintf(GIV(transcript),
				"unknown immediate %p",
				((void *)oop));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		print(((oop & ((allocationUnit()) - 1)) != 0
			? " is misaligned"
			: whereIs(oop)));
		return;
	}
	if (isFreeObject(oop)) {
		print(" is a free chunk");
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		target = followForwarded(oop);
		fprintf(GIV(transcript),
				" is a forwarder to %p",
				((void *)target));
		return;
	}
	if (isFloatObject(oop)) {
		/* begin printFloat: */
		f = dbgFloatValueOf(oop);
		fprintf(GIV(transcript),
				"%g",
				f);
		return;
	}
	classOop = fetchClassOfNonImm(oop);
	if (!(addressCouldBeObj(classOop))) {
		print("a ??");
		return;
	}
	if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		return;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		return;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		return;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		return;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (nameLen == 0) {
		print("a ??");
		return;
	}
	name = nameOfClass(classOop);
	if (nameLen == 10) {
		if ((strncmp(name, "ByteString", 10)) == 0) {

			/* strncmp is weird */
			printChar('\'');
			printStringOf(oop);
			printChar('\'');
			return;
		}
		if ((strncmp(name, "ByteSymbol", 10)) == 0) {

			/* strncmp is weird */
			printChar('#');
			printStringOf(oop);
			return;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		printChar('$');
		printChar(((fetchPointerofObject(0, oop)) >> 1));
		return;
	}
	fprintf(GIV(transcript),
			"a(n) %.*s",
			((int) nameLen),
			name);
	if ((isPointersNonImm(oop))
	 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
	 && (isBytes(fetchPointerofObject(KeyIndex, oop))))) {
		classLookupKey = fetchClassOfNonImm(fetchPointerofObject(SchedulerAssociation, GIV(specialObjectsOop)));
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				return;
			}
			if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
			classLookupKey = followFieldofObject(SuperclassIndex, classLookupKey);
		}
		if (classLookupKey == GIV(nilObj)) {
			goto l1;
		}
		theClass1 = classOop;
		while (1) {
			if (theClass1 == classLookupKey) {
				goto l2;
			}
			if (!(theClass1 != GIV(nilObj))) break;
			theClass1 = followFieldofObject(SuperclassIndex, theClass1);
		}
	l2:	;
		/* begin space */
		printChar(' ');
		printOopShortInner(fetchPointerofObject(KeyIndex, oop));
		print(" -> ");
		printHexnp(fetchPointerofObject(ValueIndex, oop));
	l1:	;
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printOop: */
void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    char *className;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt fmt1;
    sqInt index;
    sqInt lastIndex;
    sqInt length;
    usqInt numSlots;
    usqInt startIP;

	length = 0;
	if (isImmediate(oop)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (isFreeObject(oop)) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	if (!((cls = fetchClassOfNonImm(oop)))) {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
		return;
	}
	className = nameOfClasslengthInto(cls, (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s",
			((void *)oop),
			((int) length),
			className);
	if (cls == (fetchPointerofObject(ClassFloat, GIV(specialObjectsOop)))) {
		fprintf(GIV(transcript),
				"\n%g\n",
				dbgFloatValueOf(oop));
		return;
	}
	fmt = formatOf(oop);
	if (fmt > (lastPointerFormat())) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop)))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					(isIndirectAlien(oop)
				? "indirect"
				: (isPointerAlien(oop)
						? "pointer"
						: "direct")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(fetchPointerofObject(ClassString, GIV(specialObjectsOop))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	startIP = (fmt >= (firstCompiledMethodFormat())
		? (startPCOfMethod(oop)) / BytesPerWord
		: numSlotsOf(oop));
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(fetchPointerofObject(index - 1, oop));
			/* begin space */
			printChar(' ');
			if ((index % (elementsPerPrintOopLine())) == 0) {
				cr();
			}
		}
		if (!((lastIndex % (elementsPerPrintOopLine())) == 0)) {
			cr();
		}
	}
	if (isCompiledMethod(oop)) {
		startIP = (startPCOfMethod(oop)) + 1;
		/* begin lengthOf: */
		fmt1 = formatOf(oop);

		/* don't let forwarders freak us out... */
		numSlots = numSlotsOfAny(oop);
		if (fmt1 <= (ephemeronFormat())) {
			lastIndex = numSlots;
			goto l1;
		}
		if (fmt1 >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			lastIndex = (numSlots << (shiftForWord())) - (fmt1 & 7);
			goto l1;
		}
		if (fmt1 >= (firstShortFormat())) {
			lastIndex = (numSlots << ((shiftForWord()) - 1)) - (fmt1 & 3);
			goto l1;
		}
		if (fmt1 >= (firstLongFormat())) {
			lastIndex = (numSlots << ((shiftForWord()) - 2)) - (fmt1 & 1);
			goto l1;
		}
		if (fmt1 == (sixtyFourBitIndexableFormat())) {
			lastIndex = (numSlots) >> 1;
			goto l1;
		}
		lastIndex = 0;
	l1:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = fetchByteofObject(index - 1, oop);
			fprintf(GIV(transcript),
					" %02x/%-+3d",
					((int) byte),
					((int) byte));
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				cr();
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			print("...");
		}
		if (!(column == 1)) {
			cr();
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			cr();
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static void NoDbgRegParms
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt code;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if (isImmediate(oop)) {
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		return;
	}
	fmt = formatOf(oop);
	if (fmt < (firstByteFormat())) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOf(oop)))) ? ((max = 128)) : ((len = lengthOf(oop))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, fetchPointerofObject(ClassByteArray, GIV(specialObjectsOop)), GIV(classByteArrayCompactIndex)))
	 || (isLargeIntegerInstance(oop))) {
		while (i < cnt) {
			printHex(fetchByteofObject(i, oop));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			code = fetchByteofObject(i, oop);
			switch (code) {
			case 10:
				print("<LF>");
				break;
			case 13:
				print("<CR>");
				break;
			default:
				printChar(code);

			}
			i += 1;
		}
	}
	if (len > max) {
		print("...");
	}
	/* begin flush */
	fflush(GIV(transcript));
}


/*	Anwer if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (imageFormatVersionFromSnapshot(imageVersion)) == (imageFormatVersion());
}


/*	Read an image from the given file stream, allocating an amount of memory
	to its object heap.
	
	V3: desiredHeapSize is the total size of the heap. Fail if the image has
	an unknown format or
	requires more than the specified amount of memory.
	
	Spur: desiredHeapSize is ignored; this routine will attempt to provide at
	least extraVMMemory's
	ammount of free space after the image is loaded, taking any free space in
	teh image into account.
	extraVMMemory is stored in the image header and is accessible as
	vmParameterAt: 23. If
	extraVMMemory is 0, the value defaults to the default grow headroom. Fail
	if the image has an
	unknown format or if sufficient memory cannot be allocated.
	
	Details: This method detects when the image was stored on a machine with
	the opposite byte
	ordering from this machine and swaps the bytes automatically. Furthermore,
	it allows the header
	information to start 512 bytes into the file, since some file transfer
	programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix
	area could also be used to store an exec command on Unix systems, allowing
	one to launch
	Smalltalk by invoking the image name as a command. */

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
static size_t NoDbgRegParms
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt bytes;
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt freeOldSpaceInImage;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt headroom;
    sqInt headroom1;
    usqInt heapSize;
    usqInt mem;
    usqInt minimumMemory;
    sqInt oldImageBaseAddress;
    sqInt rawVersion;
    sqInt seed;
    int swapBytes;
    sqInt version;

	rawVersion = 0;

	/* stdout is not available at compile time.  this is the earliest available point. */
	GIV(transcript) = stdout;

	/* guess Metaclass instSize */
	GIV(metaclassNumSlots) = 6;

	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */
	GIV(classNameIndex) = 6;
	version = checkImageVersionFromstartingAtassignRawVersion(f, imageOffset, (&rawVersion));
	if (version == 0) {
		bailOutOfImageLoad(rawVersion);
	}
	swapBytes = rawVersion != version;
	GIV(multipleBytecodeSetsActive) = ((version & MultipleBytecodeSetsBitmask) != 0);

	/* record header start position */
	headerStart = (sqImageFilePosition(f)) - 4;
	headerSize = getWord32FromFileswap(f, swapBytes);
	dataSize = getLongFromFileswap(f, swapBytes);
	oldImageBaseAddress = getLongFromFileswap(f, swapBytes);
	/* begin specialObjectsOop: */
	anObject = getLongFromFileswap(f, swapBytes);
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	seed = getLongFromFileswap(f, swapBytes);
	GIV(lastHash) = seed;
	GIV(savedWindowSize) = getLongFromFileswap(f, swapBytes);
	headerFlags = getLongFromFileswap(f, swapBytes);
	setImageHeaderFlagsFrom(headerFlags);
	extraVMMemory = getWord32FromFileswap(f, swapBytes);

	/* 4 stack pages is small.  Should be able to run with as few as
	   three. 4 should be comfortable but slow.  8 is a reasonable
	   default.  Can be changed via vmParameterAt: 43 put: n.
	   Can be set as a preference (Info.plist, VM.ini, command line etc).
	   If desiredNumStackPages is already non-zero then it has been
	   set as a preference.  Ignore (but preserve) the header's default. */
	hdrNumStackPages = getShortFromFileswap(f, swapBytes);
	if (desiredNumStackPages != 0) {
		GIV(numStackPages) = desiredNumStackPages;
	}
	else {
		if (hdrNumStackPages == 0) {
			/* begin defaultNumStackPages */
			GIV(numStackPages) = 0;
		}
		else {
			GIV(numStackPages) = hdrNumStackPages;
		}
	}

	/* pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.
	   It is used for the cog code size in Cog.  Preserve it to be polite to other VMs. */
	desiredNumStackPages = hdrNumStackPages;
	GIV(theUnknownShort) = getShortFromFileswap(f, swapBytes);
	hdrEdenBytes = getWord32FromFileswap(f, swapBytes);
	/* begin edenBytes: */
	bytes = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes()
				: hdrEdenBytes));
	GIV(edenBytes) = bytes;
	desiredEdenBytes = hdrEdenBytes;
	hdrMaxExtSemTabSize = getShortFromFileswap(f, swapBytes);
	if (hdrMaxExtSemTabSize != 0) {
	}
	GIV(the2ndUnknownShort) = getShortFromFileswap(f, swapBytes);
	firstSegSize = getLongFromFileswap(f, swapBytes);
	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	/* begin interpreterAllocationReserveBytes */
	allocationReserve = 0;
	minimumMemory = (dataSize + GIV(edenBytes)) + allocationReserve;
	freeOldSpaceInImage = getLongFromFileswap(f, swapBytes);
	/* begin initialHeadroom:givenFreeOldSpaceInImage: */
	headroom1 = (extraVMMemory == 0
		? (!(GIV(growHeadroom))
				? 0x1000000
				: GIV(growHeadroom))
		: extraVMMemory);
	if (freeOldSpaceInImage >= headroom1) {
		headroom = 0;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 7) / 8)) {
		headroom = headroom1 / 8;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 3) / 4)) {
		headroom = headroom1 / 4;
		goto l2;
	}
	if (freeOldSpaceInImage >= ((headroom1 * 5) / 8)) {
		headroom = (headroom1 * 3) / 8;
		goto l2;
	}
	if (freeOldSpaceInImage >= (headroom1 / 2)) {
		headroom = headroom1 / 2;
		goto l2;
	}
	headroom = headroom1;
	l2:	/* end initialHeadroom:givenFreeOldSpaceInImage: */;
	heapSize = roundUpHeapSize(((dataSize + headroom) + GIV(edenBytes)) + ((headroom > allocationReserve
	? 0
	: allocationReserve)));
	mem = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	if (mem == null) {
		insufficientMemoryAvailableError();
	}
	else {
		setHeapBasememoryLimitendOfMemory(mem, mem + heapSize, mem + dataSize);
	}
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(oldSpaceStart) - oldImageBaseAddress;
	initializeInterpreter(bytesToShift);
	return dataSize;
}


/*	Byte-swap all words in memory after reading in the entire image file with
	bulk read. Contributed by Tim Rowledge.
 */
/*	First, byte-swap every word in the image. This fixes objects headers. */

	/* StackInterpreter>>#reverseBytesInImage */
static void
reverseBytesInImage(void)
{
	reverseBytesInMemory();
	updateObjectsPostByteSwap();
}


/*	Set the flags that are contained in the 7th long of the image header. */

	/* StackInterpreter>>#setImageHeaderFlagsFrom: */
static void NoDbgRegParms
setImageHeaderFlagsFrom(sqInt headerFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;

	/* processHasThreadAffinity := headerFlags anyMask: 4. specific to CoInterpreterMT */
	/* flagInterpretedMethods := headerFlags anyMask: 8. specific to CoInterpreter */
	GIV(imageFloatsBigEndian) = ((!(headerFlags & 2))
		? 1
		: 0);

	/* noThreadingOfGUIThread := headerFlags anyMask: 32. specific to CoInterpreterMT */
	GIV(preemptionYields) = (!(headerFlags & 16));
	GIV(newFinalization) = ((headerFlags & 64) != 0);
	sendWheelEvents = ((headerFlags & 128) != 0);
	if (primitiveDoMixedArithmetic < 0) {

		/* i.e. has it not been set on the command line? */
		primitiveDoMixedArithmetic = (!(headerFlags & 0x100));
	}
	if (upscaleDisplayIfHighDPI < 0) {

		/* i.e. has it not been set on the command line? */
		upscaleDisplayIfHighDPI = (!(headerFlags & 0x400));
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static void NoDbgRegParms
shortPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *className;
    sqInt length;

	length = 0;
	if (isImmediate(oop)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (isFreeObject(oop)) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	className = nameOfClasslengthInto(fetchClassOfNonImm(oop), (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s\n",
			((void *)oop),
			((int) length),
			className);
}


/*	Answer the size of the CallPrimitive bytecode that may be used to store a
	method's primitive.
 */
/*	NewsqueakV4:	249	11111001	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */
/*	SistaV1:		248	11111000 iiiiiiii	mssjjjjj	Call Primitive #iiiiiiii + (
	jjjjj * 256) */
/*	V3+Closures:	139	11101111	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 3;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
sqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return ((literalCountOf(aCompiledMethod)) + LiteralStart) * BytesPerOop;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
static sqInt NoDbgRegParms
superclassOf(sqInt classPointer)
{
	return followFieldofObject(SuperclassIndex, classPointer);
}

	/* StackInterpreter>>#tempCountOf: */
sqInt
tempCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin temporaryCountOfMethodHeader: */
	header = methodHeaderOf(methodPointer);
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
sqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#ultimateLiteralOf: */
sqInt
ultimateLiteralOf(sqInt aMethodOop)
{
	assert(isOopCompiledMethod(aMethodOop));
	return literalofMethod((literalCountOf(aMethodOop)) - 1, aMethodOop);
}


/*	Byte-swap the words of all bytes objects in the image, including Strings,
	ByteArrays, and CompiledMethods. This returns these objects to their
	original byte ordering
	after blindly byte-swapping the entire image. For compiled methods,
	byte-swap only their bytecodes part. Ensure floats are in platform-order. */

	/* StackInterpreter>>#updateObjectsPostByteSwap */
static void
updateObjectsPostByteSwap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt methodHeader;
    sqInt obj;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;
    int swapFloatWords;
    sqInt temp;
    sqInt wordAddr;

	swapFloatWords = (vmEndianness()) != GIV(imageFloatsBigEndian);
	assert(ClassFloatCompactIndex != 0);
	/* begin allObjectsDo: */
	startObject = objectStartingAt((GIV(pastSpaceStart) > (((pastSpace()).start))
		? ((pastSpace()).start)
		: (GIV(freeStart) > (((eden()).start))
				? ((eden()).start)
				: GIV(oldSpaceStart))));
	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);
		if (isEnumerableObject(obj)) {
			fmt = formatOf(obj);
			if (fmt >= (firstByteFormat())) {

				/* oop contains bytes */
				wordAddr = obj + BaseHeaderSize;
				if (fmt >= (firstCompiledMethodFormat())) {

					/* compiled method; start after methodHeader and literals */
					methodHeader = longAt(obj + BaseHeaderSize);
					wordAddr += (((assert((methodHeader & 1)),
((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
				}
				reverseBytesFromto(wordAddr, obj + (sizeBitsOf(obj)));
			}
			if (fmt == (firstLongFormat())) {

				/* Bitmap, Float etc */
				if (swapFloatWords
				 && ((classIndexOf(obj)) == ClassFloatCompactIndex)) {
					temp = longAt(obj + BaseHeaderSize);
					longAtput(obj + BaseHeaderSize, longAt((obj + BaseHeaderSize) + 4));
					longAtput((obj + BaseHeaderSize) + 4, temp);
				}
				else {
									}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;
		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress + 4);
		obj = ((((usqInt)(followingWord)) >> (numSlotsHalfShift())) == (numSlotsMask())
			? ((oopisLessThan(obj, GIV(oldSpaceStart)))
				 && (1 == (longAt(followingWordAddress)))
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
	l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	}


/*	useful for VM debugging */

	/* StackInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop)
{
    char *where;

	where = whereIsMaybeHeapThing(anOop);
	if (!(where == null)) {
		return where;
	}
	where = whereIsMaybeStackThing(anOop);
	if (!(where == null)) {
		return where;
	}
	return " is no where obvious";
}

	/* VMClass>>#stretch:cat: */
static char * NoDbgRegParms
stretchcat(char *s1, char *s2)
{
    char *ns;

	return ((ns = malloc(((strlen(s1)) + (strlen(s2))) + 2)),
		strcpy(ns, s1),
		strcat(ns, s2));
}


static char _m[] = "";
void* vm_exports[][3] = {
	{NULL, NULL, NULL}
};
