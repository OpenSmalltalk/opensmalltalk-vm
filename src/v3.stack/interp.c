/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
   from
	StackInterpreter VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include "sq.h"
#include <stdio.h> /* for printf */
#include <stdlib.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "sqImageFileAccess.h"
#include "sqSetjmpShim.h"
#include "dispdbg.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
EXPORT(void)
warning(const char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
EXPORT(void)
warningat(const char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set multiple breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
EXPORT(void)
warninginat(const char *s, const char *f, int l) { /* ditto with function name & line number. */
	/* use alloca to call warning so one does not have to remember to set multiple breakpoints... */
	char *sl = alloca(strlen(s) + strlen(f) + 17);
	sprintf(sl, "%s %s %d", s, f, l);
	warning(sl);
}
#pragma auto_inline(on)

/* end StackInterpreter class>>preambleCCode */


/*** Constants ***/
#define ActiveProcessIndex 1
#define AllButHashBits 0xE001FFFFU
#define AllButMarkBit 0x7FFFFFFF
#define AllButMarkBitAndTypeMask 0x7FFFFFFC
#define AllButRootBit 0xBFFFFFFFU
#define AllButTypeMask 0xFFFFFFFCU
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define CacheProbeMax 3
#define CharacterTable 24
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 3
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 11
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 6
#define ClassFullBlockClosure 37
#define ClassFullBlockClosureCompactIndex 38
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 4
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMessage 15
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 14
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWeakFinalizer 55
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactClasses 28
#define CompactClassMask 0x1F000
#define ConstMinusOne 0xFFFFFFFFU
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DisownVMForFFICall 16
#define DisownVMForThreading 32
#define DisownVMFromCallback 64
#define Done 4
#define EndOfRun 0x101
#define ExcessSignalsIndex 2
#define ExternalCallLiteralFlagsIndex 2
#define ExternalCallLiteralFunctionNameIndex 1
#define ExternalCallLiteralModuleNameIndex 0
#define ExternalCallLiteralTargetFunctionIndex 3
#define ExternalObjectsArray 38
#define ExtraRootSize 2048
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 4
#define FoxCallerSavedIP 4
#define FoxFrameFlags -8
#define FoxMethod -4
#define FoxReceiver -16
#define FoxSavedFP 0
#define FoxThisContext -12
#define FrameSlots 6
#define GCCheckPrimCall 128
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GCTopMarker 3
#define HashBits 0x1FFE0000
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HashMultiplyConstant 1664525
#define HeaderIndex 0
#define HeaderTypeClass 1
#define HeaderTypeFree 2
#define HeaderTypeGC 2
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#define ImmutabilityBit 0x20000000
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#if !defined(LOGPRIMITIVES) /* Allow this to be overridden on the compiler command line */
# define LOGPRIMITIVES 0
#endif
#define LongSizeMask 0xFFFFFFFCU
#define LongSizeNumBits 30
#define LongStoreBytecode 129
#define MarkBit 0x80000000U
#define MaxExternalPrimitiveTableSize 4096
#define MaxPrimitiveIndex 582
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MultipleBytecodeSetsBitmask 0x200
#define MyListIndex 3
#define NextLinkIndex 0
#define NilObject 0
#define PrimitiveErrorTableIndex 51
#define PrimNumberExternalCall 117
#define PrimNumberHandlerMarker 199
#define PrimNumberNoContextSwitchMarker 123
#define PrimNumberUnwindMarker 198
#define PrimTraceLogSize 256
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define ReturnToInterpreter 1
#define RootBit 0x40000000
#define RootTableRedZone 2400
#define RootTableSize 2500
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define Size4Bit 0
#define SizeMask 0xFC
#define SmallContextSlots 22
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define StartField 1
#define StartObj 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TraceCodeCompaction 13
#define TraceFullGC 11
#define TraceIncrementalGC 9
#define TracePrimitiveFailure 29
#define TracePrimitiveRetry 31
#define TraceStackOverflow 27
#define TrueObject 2
#define TypeMask 0x3
#define Upward 3
#define V3PrimitiveBitsMask 0x200003FE
#define ValueIndex 1
#define WeakRootTableSize 2625
#define WordMask 0xFFFFFFFFU
#define XIndex 0
#define YIndex 1

typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static NoDbgRegParms sqInt addressIsInPage(StackPage *self_in_CogStackPage, char *address);
static NoDbgRegParms int isFree(StackPage *self_in_CogStackPage);
static NoDbgRegParms sqInt freeStackPageNoAssert(StackPage *aPage);
static NoDbgRegParms void freeStackPage(StackPage *aPage);
static NoDbgRegParms sqInt markStackPageMostRecentlyUsed(StackPage *page);
static NoDbgRegParms sqInt markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static NoDbgRegParms StackPage * stackPageAt(sqInt index);
static NoDbgRegParms StackPage * stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
extern sqInt identityHashOf(sqInt anOop);
static NoDbgRegParms sqInt isNegativeIntegerValueOf(sqInt oop);
extern sqInt isPositiveMachineIntegerObject(sqInt oop);
static NoDbgRegParms sqInt magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static NoDbgRegParms usqLong magnitude64BitValueOf(sqInt oop);
static NoDbgRegParms int noInlineSigned32BitValueGutsOf(sqInt oop);
extern unsigned int positive32BitValueOf(sqInt oop);
extern usqLong positive64BitValueOf(sqInt oop);
extern usqIntptr_t positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHashArg(void);
static void primitiveArrayBecomeOneWayNoCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
EXPORT(sqInt) primitiveBytecodeSetsAvailable(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
static void primitiveCoarseLocalMicrosecondClock(void);
static void primitiveCoarseUTCMicrosecondClock(void);
EXPORT(sqInt) primitiveCompareBytes(void);
EXPORT(void) primitiveCompareWith(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
static void primitiveCosine(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc);
extern sqInt primitiveFailForOSError(sqLong osErrorCode);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailForwithSecondary(sqInt reasonCode, sqLong extraErrorCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFloatAdd(void);
static void primitiveFloatArrayAt(void);
static void primitiveFloatArrayAtPut(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
EXPORT(sqInt) primitiveForceTenure(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetenv(void);
#if IMMUTABILITY
static void primitiveGetImmutability(void);
#else
# define primitiveGetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveHashMultiply(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
static void primitiveHighBit(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
EXPORT(sqInt) primitiveIsRoot(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
EXPORT(sqInt) primitiveIsYoung(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
EXPORT(sqInt) primitiveMultipleBytecodeSetsActive(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
static void primitiveObjectsAccessibleFromRoots(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
static void primitivePinnedNew(void);
static void primitivePinnedNewWithArg(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
EXPORT(sqInt) primitiveRootTableAt(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
EXPORT(sqInt) primitiveScreenScaleFactor(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(sqInt) primitiveSetGCBiasToGrow(void);
EXPORT(sqInt) primitiveSetGCBiasToGrowGCLimit(void);
#if IMMUTABILITY
static void primitiveSetImmutability(void);
#else
# define primitiveSetImmutability (void (*)(void))0
#endif /* IMMUTABILITY */
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
#if TestingPrimitives
EXPORT(sqInt) primitiveTestShortenIndexableSize(void);
#endif /* TestingPrimitives */
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUninitializedNewWithArg(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
static void primitiveUtcAndTimezoneOffset(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
static void primitiveWait(void);
static void primitiveYield(void);
extern int signalNoResume(sqInt aSemaphore);
extern int signed32BitValueOf(sqInt oop);
extern sqLong signed64BitValueOf(sqInt oop);
extern sqIntptr_t signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static NoDbgRegParms void initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static NoDbgRegParms sqInt pageIndexFor(void *pointer);
static NoDbgRegParms sqInt accessibleObjectAfter(sqInt oop);
static NoDbgRegParms sqInt addressCouldBeObjWhileForwarding(sqInt address);
extern sqInt addressCouldBeObj(sqInt address);
static NoDbgRegParms sqInt adjustAllOopsBy(sqInt bytesToShift);
static NoDbgRegParms sqInt allInstancesOf(sqInt aBehavior);
static sqInt allObjectsUnmarked(void);
static NoDbgRegParms sqInt becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern sqInt characterValueOf(sqInt oop);
static sqInt checkHeapIntegrity(void);
extern sqInt checkOkayOop(usqInt oop);
static NoDbgRegParms sqInt checkOopIntegritynamed(sqInt obj, char *name);
static void clearLeakMapAndMapAccessibleObjects(void);
extern sqInt cloneObject(sqInt obj);
static int defaultEdenBytes(void);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
static NoDbgRegParms sqInt eeInstantiateClassindexableSize(sqInt classPointer, sqInt size);
static NoDbgRegParms sqInt eeInstantiateMethodContextSlots(sqInt numSlots);
static NoDbgRegParms sqInt eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots);
static NoDbgRegParms sqInt eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots);
static NoDbgRegParms sqInt fetchClassTagOfNonImm(sqInt oop);
extern sqInt fetchClassTagOf(sqInt oop);
static NoDbgRegParms void finalizeReference(usqInt oop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
static sqInt firstAccessibleObject(void);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
extern void fullGC(void);
static NoDbgRegParms sqInt fwdTableInit(sqInt blkSize);
static NoDbgRegParms sqInt fwdTableSize(sqInt blkSize);
static unsigned int imageSegmentVersion(void);
static usqInt incCompBody(void);
static sqInt incCompMakeFwd(void);
static NoDbgRegParms usqInt incCompMove(sqInt bytesFreed);
extern void incrementalGC(void);
static NoDbgRegParms void initializeMemoryFirstFree(sqInt firstFree);
static NoDbgRegParms void initializeObjectMemory(sqInt bytesToShift);
static NoDbgRegParms int isContextHeader(sqInt aHeader);
extern int isYoungObject(sqInt obj);
static NoDbgRegParms sqInt lastPointerOf(sqInt objOop);
extern int leakCheckFullGC(void);
extern int leakCheckNewSpaceGC(void);
extern usqInt literalCountOfMethodHeader(sqInt methodHeader);
static NoDbgRegParms sqInt loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintReferencesTo(sqInt anOop);
static NoDbgRegParms void mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd);
static NoDbgRegParms void markPhase(sqInt fullGCFlag);
extern sqInt objectAfter(sqInt oop);
static NoDbgRegParms sqInt okayOop(sqInt signedOop);
static NoDbgRegParms sqInt oopHasAcceptableClass(sqInt signedOop);
extern sqInt pinObject(sqInt objOop);
extern void printActivationsOf(sqInt aMethodObj);
static NoDbgRegParms void printCantBeObjecton(sqInt oop, FILE *aStream);
extern void printContextReferencesTo(sqInt anOop);
static NoDbgRegParms void printMemFieldnamesize(usqInt memField, char *name, sqInt length);
extern void printMemory(void);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printWronglySizedContexts(sqInt printContexts);
static NoDbgRegParms void restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut);
static NoDbgRegParms void runLeakCheckerFor(sqInt gcModes);
static NoDbgRegParms sqInt safePrintStringOf(sqInt oop);
extern sqInt shortentoIndexableSize(sqInt obj, sqInt nSlots);
static NoDbgRegParms usqInt sizeBitsOfSafe(sqInt oop);
static NoDbgRegParms usqInt sizeBitsOf(sqInt oop);
static NoDbgRegParms sqInt storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
static NoDbgRegParms sqInt sufficientSpaceAfterGC(sqInt minFree);
static NoDbgRegParms sqInt sufficientSpaceToAllocate(sqInt bytes);
static sqInt sweepPhase(void);
static sqInt sweepPhaseForFullGC(void);
extern void unpinObject(sqInt objOop);
extern sqInt addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt allObjects(void);
static NoDbgRegParms sqInt badContextSize(sqInt oop);
extern sqInt becomewith(sqInt array1, sqInt array2);
extern void beRootIfOld(sqInt oop);
static NoDbgRegParms void beRootWhileForwarding(sqInt oop);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt byteSwapped(sqInt w);
extern sqInt bytesPerElement(sqInt oop);
static NoDbgRegParms sqInt changeClassOfto(sqInt rcvr, sqInt argClass);
extern sqInt characterObjectOf(sqInt characterCode);
extern sqInt characterTable(void);
extern sqInt checkedLongAt(sqInt byteAddress);
extern sqInt checkOopHasOkayClass(usqInt obj);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classDoubleByteArray(void);
extern sqInt classDoubleWordArray(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
extern sqInt classFloat32Array(void);
extern sqInt classFloat64Array(void);
extern sqInt classHeader(sqInt oop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classUnsafeAlien(void);
extern sqInt classWordArray(void);
static void clearRootsTable(void);
extern sqInt compactClassAt(sqInt ccIndex);
extern usqInt compactClassIndexOfHeader(sqInt header);
static NoDbgRegParms sqInt copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr);
extern sqInt displayObject(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt oop);
extern sqInt fetchClassOf(sqInt oop);
extern int fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static NoDbgRegParms sqLong fetchLong64ofObject(sqInt longIndex, sqInt oop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt oop);
static NoDbgRegParms void * firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt oop);
extern void * firstIndexableField(sqInt oop);
static NoDbgRegParms sqInt fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength);
static NoDbgRegParms sqInt followFieldofObject(sqInt fieldIndex, sqInt anObject);
extern sqInt formatOfClass(sqInt classPointer);
static NoDbgRegParms sqInt fwdBlockValid(sqInt addr);
static NoDbgRegParms sqInt goodContextSize(sqInt oop);
static NoDbgRegParms int hasForwardingBlock(sqInt objOop);
static sqInt hasSixtyFourBitImmediates(void);
extern int headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
static NoDbgRegParms usqInt instSpecOfClass(sqInt classPointer);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt objectPointer);
static NoDbgRegParms void invalidCompactClassError(const char *className);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern int isCharacterValue(sqInt anInteger);
static NoDbgRegParms int isCompiledMethodHeader(sqInt objHeader);
extern int isCompiledMethod(sqInt oop);
static NoDbgRegParms int isContextNonImm(sqInt oop);
static NoDbgRegParms sqInt isContext(sqInt oop);
static NoDbgRegParms sqInt isFloatInstance(sqInt oop);
extern int isImmediate(sqInt anOop);
extern int isIndexable(sqInt oop);
extern sqInt isInMemory(sqInt address);
static NoDbgRegParms sqInt isInstanceOfClassLargeNegativeInteger(sqInt oop);
static NoDbgRegParms sqInt isInstanceOfClassLargePositiveInteger(sqInt oop);
extern int isIntegerObject(sqInt objectPointer);
extern int isIntegerValue(sqInt intValue);
extern sqInt isLong64s(sqInt oop);
extern int isMarked(sqInt oop);
extern int isNonImmediate(sqInt anOop);
extern int isNonIntegerObject(sqInt objectPointer);
static NoDbgRegParms sqInt isObjImmutable(sqInt anOop);
extern sqInt isOopCompiledMethod(sqInt oop);
static NoDbgRegParms sqInt isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt anOop);
extern sqInt isOopMutable(sqInt anOop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static NoDbgRegParms sqInt isPureBitsNonImm(sqInt objOop);
extern sqInt isShorts(sqInt oop);
static NoDbgRegParms int isWeakNonImm(sqInt oop);
extern sqInt isWeak(sqInt oop);
static NoDbgRegParms int isWordsNonImm(sqInt oop);
static NoDbgRegParms sqInt isWordsOrBytesNonImm(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWordsOrShorts(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isYoung(sqInt oop);
static NoDbgRegParms sqInt isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static NoDbgRegParms sqInt lengthOfMaybeImmediate(sqInt oop);
static NoDbgRegParms sqInt lengthOf(sqInt oop);
static NoDbgRegParms sqInt lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt);
extern usqInt literalCountOf(sqInt methodPointer);
static NoDbgRegParms double loadFloatOrIntFrom(sqInt floatOrInt);
extern void longPrintInstancesOf(sqInt aClassOop);
static NoDbgRegParms sqInt lowestFreeAfter(sqInt chunk);
extern sqInt markAndTrace(sqInt oop);
static NoDbgRegParms sqInt methodHeaderOf(sqInt methodObj);
extern sqInt minSlotsForShortening(void);
extern sqInt nilObject(void);
extern double noFailFloatValueOf(sqInt aFloatOop);
extern sqInt noShiftCompactClassIndexOfHeader(sqInt header);
static NoDbgRegParms sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
static NoDbgRegParms int numSlotsOfAny(sqInt obj);
extern int numSlotsOf(sqInt obj);
extern sqInt objectBefore(sqInt address);
extern sqInt objectExactlyBefore(sqInt oop);
static NoDbgRegParms sqInt oopFromChunk(sqInt chunk);
extern sqInt popRemappableOop(void);
static NoDbgRegParms void possibleRootStoreIntovalue(sqInt oop, sqInt valueObj);
extern sqInt primitiveErrorTable(void);
static NoDbgRegParms void printFreeObjecton(sqInt oop, FILE *aStream);
static NoDbgRegParms void printImmediateObjecton(sqInt oop, FILE *aStream);
extern void printInstancesOf(sqInt aClassOop);
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
static NoDbgRegParms void printNonPointerDataOfon(sqInt oop, FILE *aStream);
static NoDbgRegParms void printStringDataOfon(sqInt oop, FILE *aStream);
extern void pushRemappableOop(sqInt oop);
static NoDbgRegParms sqInt remapObj(sqInt obj);
extern sqInt remap(sqInt oop);
extern sqInt removeGCRoot(sqInt *varLoc);
static NoDbgRegParms sqInt removeYoungRoot(sqInt obj);
extern sqInt shouldRemapObj(sqInt oop);
extern sqInt shouldRemapOop(sqInt oop);
static sqInt sixtyFourBitIndexableFormat(void);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
extern sqInt statNumGCs(void);
extern int storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valueWord);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
extern void tenuringIncrementalGC(void);
extern sqInt topRemappableOop(void);
extern sqInt trueObject(void);
static NoDbgRegParms void updatePointersInRangeFromto(sqInt memStart, sqInt memEnd);
static NoDbgRegParms void updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd);
extern sqInt vmEndianness(void);
extern sqInt activeProcess(void);
extern void addIdleUsecs(sqInt idleUsecs);
static NoDbgRegParms void addLastLinktoList(sqInt proc, sqInt aList);
static NoDbgRegParms void addNewMethodToCache(sqInt classObj);
static NoDbgRegParms sqInt addressCouldBeClassObj(sqInt maybeClassObj);
static char * allOnesAsCharStar(void);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern usqInt argumentCountOfMethodHeader(sqInt header);
extern usqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static NoDbgRegParms sqInt asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static NoDbgRegParms void assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
static NoDbgRegParms void backupContexttoBlockingSendTo(sqInt suspendedContext, sqInt conditionVariable);
extern sqInt booleanValueOf(sqInt obj);
extern sqInt callbackEnter(sqInt *callbackID);
extern sqInt callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static NoDbgRegParms sqInt checkCodeIntegrity(sqInt fullGCFlag);
#if LRPCheck
static NeverInline sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
#endif /* LRPCheck */
extern sqInt checkedIntegerValueOf(sqInt intOop);
static NoDbgRegParms sqInt checkForEventsMayContextSwitch(sqInt mayContextSwitch);
extern sqInt checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize);
static NoDbgRegParms sqInt checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr);
static sqInt checkInterpreterIntegrity(void);
static NoDbgRegParms sqInt checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static NoDbgRegParms sqInt checkOkayFields(sqInt oop);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static NoDbgRegParms sqInt checkOkayStackPage(StackPage *thePage);
static NoDbgRegParms sqInt checkOkayStackZone(sqInt writeBack);
static NoDbgRegParms void checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
static NoDbgRegParms sqInt checkStackPointerForMaybeMarriedContext(sqInt aContext);
static NoDbgRegParms sqInt checkStackPointerIndexForFrame(char *theFP);
static NoDbgRegParms sqInt classNameOfIs(sqInt aClass, char *className);
static NoDbgRegParms sqInt contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern int copiedValueCountOfClosure(sqInt closureObj);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static NoDbgRegParms NeverInline sqInt couldBeProcess(sqInt oop);
static NoDbgRegParms void createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
#if SEND_PRINTING
extern void disableSendPrinting(void);
#endif /* SEND_PRINTING */
extern void * disownVM(sqInt flags);
static sqInt divorceAllFrames(void);
static NoDbgRegParms void divorceFramesIn(StackPage *aStackPage);
static NoDbgRegParms sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg);
static NoDbgRegParms sqInt doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
extern struct VirtualMachine * * dummyReferToProxy(void);
extern sqInt dumpImage(sqInt fileName);
extern void dumpPrimTraceLog(void);
extern void dumpPrimTraceLogOn(FILE *aStdioStream);
extern NeverInline void eekcr(void);
#if SEND_PRINTING
extern void enableSendPrinting(void);
#endif /* SEND_PRINTING */
static NoDbgRegParms sqInt ensureCallerContext(char *theFP);
static NoDbgRegParms void ensureImageFormatIsUpToDate(sqInt swapBytes);
static sqInt enterSmalltalkExecutiveImplementation(void);
static sqInt executeNewMethod(void);
static NoDbgRegParms void externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static NoDbgRegParms char * externalEnsureIsBaseFrame(char *aFramePtr);
static NoDbgRegParms sqInt externalInstVarofContext(sqInt offset, sqInt aContext);
static NoDbgRegParms sqInt externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static NoDbgRegParms sqInt fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static NoDbgRegParms sqInt fetchStackPointerOf(sqInt aContext);
extern int fileTimesInUTC(void);
static NoDbgRegParms sqInt findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static NoDbgRegParms char * findFrameAboveinPage(char *theFP, StackPage *thePage);
static NoDbgRegParms sqInt findHomeForContext(sqInt aContext);
static NoDbgRegParms sqInt findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static NoDbgRegParms sqInt findNewMethodInClassTag(sqInt classTagArg);
extern sqInt findSelectorOfMethod(sqInt aMethodOop);
static NoDbgRegParms char * findSPOfon(char *theFP, StackPage *thePage);
extern void flush(void);
static NoDbgRegParms sqInt flushExternalPrimitiveOf(sqInt methodObj);
extern sqInt forceInterruptCheck(void);
extern void forceInterruptCheckFromHeartbeat(void);
static NoDbgRegParms sqInt frameCallerContext(char *theFP);
static NoDbgRegParms char * frameCallerSP(char *theFP);
static NoDbgRegParms sqInt frameContext(char *theFP);
static NoDbgRegParms int frameHasContext(char *theFP);
static NoDbgRegParms int frameIsBlockActivation(char *theFP);
static NoDbgRegParms sqInt frameMethod(char *theFP);
static NoDbgRegParms usqInt frameNumArgs(char *theFP);
static NoDbgRegParms char * frameOfMarriedContext(sqInt aContext);
static NoDbgRegParms void framePrintDescription(sqInt it);
static NoDbgRegParms sqInt frameReceiver(char *theFP);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
static sqInt getCogVMFeatureFlags(void);
extern sqInt getCurrentBytecode(void);
static sqInt getErrorObjectFromPrimFailCode(void);
extern sqInt getFullScreenFlag(void);
static sqInt getImageHeaderFlags(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
static sqInt getSnapshotScreenSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
extern FILE * getTranscript(void);
static NeverInline void handleStackOverflow(void);
static NoDbgRegParms sqInt handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern sqInt highBit(usqInt anUnsignedValue);
extern sqInt homeMethodOf(sqInt aMethodOop);
static NoDbgRegParms sqInt ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static NoDbgRegParms usqInt iframeMethod(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
extern void initStackPagesAndContinueIntowith(void (*continuation)(void *), void *argument);
static NoDbgRegParms sqInt instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
static NeverInline sqInt interpreterAllocationReserveBytes(void);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static NoDbgRegParms int isBaseFrame(char *theFP);
extern sqInt isBooleanObject(sqInt oop);
static NoDbgRegParms int isEmptyList(sqInt aLinkedList);
extern sqInt isFloatObject(sqInt oop);
static NoDbgRegParms sqInt isFrameonPage(char *aFrame, StackPage *aPage);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
static NoDbgRegParms sqInt isLiveContext(sqInt oop);
static NoDbgRegParms int isMarriedOrWidowedContext(sqInt aContext);
static int isPrimitiveFunctionPointerAnIndex(void);
extern int isQuickPrimitiveIndex(sqInt anInteger);
extern int isReadMediatedContextInstVarIndex(sqInt index);
static NoDbgRegParms int isSingleContext(sqInt aContext);
static NoDbgRegParms sqInt isStillMarriedContext(sqInt aContext);
static NoDbgRegParms sqInt isVanillaBlockClosure(sqInt aClosure);
static NoDbgRegParms sqInt isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static NoDbgRegParms sqInt isWidowedContextNoConvert(sqInt aOnceMarriedContext);
static NoDbgRegParms sqInt isWidowedContext(sqInt aOnceMarriedContext);
extern int isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static NoDbgRegParms sqInt lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static NoDbgRegParms sqInt lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static NoDbgRegParms sqInt lookupMethodInClass(sqInt class);
static NoDbgRegParms sqInt lookupOrdinaryNoMNUEtcInClass(sqInt class);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static NoDbgRegParms StackPage * makeBaseFrameFor(sqInt aContext);
static NoDbgRegParms void makeContextSnapshotSafe(sqInt ctxt);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void mapPrimTraceLog(void);
static NeverInline void mapStackPages(void);
static NoDbgRegParms sqInt markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag);
static NoDbgRegParms void markAndTraceInterpreterOops(sqInt fullGCFlag);
static void markAndTracePrimTraceLog(void);
static NoDbgRegParms sqInt markAndTraceStackPages(sqInt fullGCFlag);
static NoDbgRegParms void markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
static NoDbgRegParms sqInt marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static NoDbgRegParms void marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static NoDbgRegParms sqInt marryFrameSP(char *theFP, char *theSP);
static NoDbgRegParms sqInt maybeLeakCheckExternalPrimCall(sqInt aMethodObj);
extern sqInt maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnBool(sqInt boolean);
extern sqInt methodReturnFloat(double aFloat);
extern sqInt methodReturnInteger(sqInt integer);
extern sqInt methodReturnReceiver(void);
extern NeverInline sqInt methodReturnString(const char *aCString);
extern sqInt methodReturnValue(sqInt oop);
extern int methodUsesAlternateBytecodeSet(sqInt aMethodObj);
static NoDbgRegParms sqInt methodUsesPrimitiveErrorCode(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static NoDbgRegParms char * moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static NoDbgRegParms char * nameOfClass(sqInt classOop);
static NoDbgRegParms char * nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr);
static NoDbgRegParms NeverInline sqInt noInlineSigned32BitIntegerGutsFor(sqInt integerValue);
static NoDbgRegParms sqInt noMarkedContextsOnPage(StackPage *thePage);
static sqInt numStkPages(void);
extern sqInt objCouldBeClassObj(sqInt objOop);
static NoDbgRegParms sqInt objectequalsString(sqInt anOop, char *aCString);
extern sqInt ownVM(void *vmHandle);
extern usqInt pcPreviousToinSqueakV3PlusClosuresMethod(sqInt theIP, sqInt aMethod);
static NoDbgRegParms sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(unsigned int integerValue);
extern sqInt positive64BitIntegerFor(usqLong integerValue);
static NoDbgRegParms sqInt positiveMachineIntegerFor(usqIntptr_t value);
static sqInt postGCUpdateDisplayBits(void);
EXPORT(void) primitiveEventProcessingControl(void);
static NoDbgRegParms int primitiveFloatEqualtoArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatGreaterOrEqualtoArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatGreaterthanArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatLessOrEqualtoArg(sqInt rcvrOop, sqInt argOop);
static NoDbgRegParms int primitiveFloatLessthanArg(sqInt rcvrOop, sqInt argOop);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static NoDbgRegParms void printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static NoDbgRegParms void printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printAllStacksOn(FILE *aStdioStream);
extern void printCallStack(void);
static NoDbgRegParms sqInt printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static NoDbgRegParms sqInt printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printCallStackOn(FILE *aStdioStream);
static NoDbgRegParms sqInt printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
extern void printExternalHeadFrame(void);
static NoDbgRegParms sqInt printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static NoDbgRegParms void printFrameFlagsForFP(char *theFP);
static NoDbgRegParms void printFrameOopat(char *name, char *address);
extern void printFramesInPage(StackPage *thePage);
extern void printFramesOnStackPageListInUse(void);
static NoDbgRegParms void printFrameThingandFrameat(char *name, char *theFP, char *address);
static NoDbgRegParms void printFrameThingatextraString(char *name, char *address, char *extraStringOrNil);
extern sqInt printFrame(char *theFP);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
static NoDbgRegParms sqInt printHexPtrnp(void *p);
extern void printHex(usqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static NoDbgRegParms void printNameOfClasscount(sqInt classOop, sqInt cnt);
static NoDbgRegParms void printNum(sqInt n);
static NoDbgRegParms void printOopShortInner(sqInt oop);
extern void printOop(sqInt oop);
static NoDbgRegParms sqInt printPrimLogEntryAthasParameter(sqInt i, sqInt hasParameter);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static NoDbgRegParms void printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static NoDbgRegParms void printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static NoDbgRegParms sqInt pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static NoDbgRegParms void putLongtoFile(sqInt aLong, sqImageFile aFile);
static NoDbgRegParms void putShorttoFile(short aShort, sqImageFile aFile);
static NoDbgRegParms void putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static NoDbgRegParms void putWord32toFile(int aWord32, sqImageFile aFile);
static NoDbgRegParms sqInt quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
static NoDbgRegParms NeverInline void reapAndResetErrorCodeToheader(char *theSP, sqInt methodHeader);
extern sqInt reestablishContextPriorToCallback(sqInt callbackContext);
static NoDbgRegParms sqInt removeFirstLinkOfList(sqInt aList);
static NoDbgRegParms sqInt removeProcessfromList(sqInt aProcess, sqInt aList);
static NoDbgRegParms sqInt resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
extern sqInt returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static NoDbgRegParms void reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static NoDbgRegParms void rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)());
static NoDbgRegParms sqInt safeMethodClassOf(sqInt methodPointer);
extern sqInt sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
extern void * setInterruptCheckChain(void (*aFunction)());
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static NoDbgRegParms void setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static NoDbgRegParms sqInt shortPrintContext(sqInt aContext);
static NoDbgRegParms sqInt shortPrintFrameAndCallers(char *theFP);
extern void shortPrintFramesInPage(StackPage *thePage);
extern void shortPrintFramesOnStackPageListInUse(void);
static NoDbgRegParms sqInt shortPrintFrame(char *theFP);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static NoDbgRegParms void shortPrintOop(sqInt oop);
static NoDbgRegParms sqInt shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static int slowPrimitiveResponse(void);
static NoDbgRegParms sqInt snapshot(sqInt embedded);
extern sqInt specialSelector(sqInt index);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static int stackLimitOffset(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt stackPageHeadroom(void);
static NoDbgRegParms sqInt stackPointerForMaybeMarriedContext(sqInt aContext);
static NoDbgRegParms usqInt stackPointerIndexForFrame(char *theFP);
extern usqIntptr_t stackPositiveMachineIntegerValue(sqInt offset);
extern sqIntptr_t stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern usqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static NoDbgRegParms char * storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
static NoDbgRegParms sqInt synchronousSignal(sqInt aSemaphore);
extern usqInt tempCountOf(sqInt methodPointer);
extern usqInt temporaryCountOfMethodHeader(sqInt header);
static NoDbgRegParms sqInt temporaryin(sqInt offset, char *theFP);
static NoDbgRegParms sqInt temporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static NoDbgRegParms sqInt transferTo(sqInt newProc);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static NoDbgRegParms sqInt updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b);
static NoDbgRegParms void updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static NoDbgRegParms sqInt validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static NoDbgRegParms sqInt validStackPageBaseFrame(StackPage *aPage);
#if LRPCheck
static NoDbgRegParms NeverInline void voidLongRunningPrimitive(char *reason);
#endif /* LRPCheck */
static NoDbgRegParms sqInt voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
extern char * whereIs(sqInt anOop);
static NeverInline sqInt writeImageFileIO(void);
static NoDbgRegParms sqInt fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static NoDbgRegParms sqInt fieldofFrame(sqInt index, char *theFP);
static NoDbgRegParms sqInt isAppropriateForCopyObject(sqInt oop);
static NoDbgRegParms void (*linkExternalCallerrInto(sqInt externalCallLiteral, sqInt *failPtr))();
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFullGC(void);
static void primitiveGetSetFFIExceptionHandling(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
#if LRPCheck
EXPORT(void) primitiveLongRunningPrimitive(void);
#endif /* LRPCheck */
#if LRPCheck
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
#endif /* LRPCheck */
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveSuspend(void);
static void primitiveSuspendBackingUpV1(void);
EXPORT(void) primitiveSuspendBackingUpV2(void);
static void primitiveTerminateTo(void);
static void primitiveUnloadModule(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static NoDbgRegParms void pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);
static void unmarkAllFrames(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss StackPage * stackPage;
_iss sqInt argumentCount;
_iss char * framePointer;
_iss usqInt freeStart;
_iss sqInt nilObj;
_iss FILE * transcript;
_iss usqInt method;
_iss usqInt newMethod;
_iss usqInt youngStart;
_iss sqInt messageSelector;
_iss usqInt instructionPointer;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss StackPage * pages;
_iss sqInt remapBufferCount;
_iss char * stackMemory;
_iss sqInt bytesPerPage;
_iss usqInt reserveStart;
_iss sqInt rootTableCount;
_iss char * stackLimit;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt memoryLimit;
_iss usqInt endOfMemory;
_iss sqInt tempOop;
_iss sqInt numStackPages;
_iss sqInt needGCFlag;
_iss sqInt performWithArgumentsRecursionGuard;
_iss usqInt scavengeThreshold;
_iss usqInt fwdTableNext;
_iss sqInt imageHeaderFlags;
_iss sqInt classNameIndex;
_iss usqInt compStart;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt profileProcess;
_iss sqInt tempOop2;
_iss sqInt statGrowMemory;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckMethod;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSemaphore;
#endif
_iss sqInt profileMethod;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt profileSemaphore;
_iss sqInt lkupClass;
_iss sqInt statMarkCount;
_iss sqInt thisClassIndex;
_iss sqInt weakRootCount;
_iss sqInt highestRunnableProcessPriority;
_iss sqInt metaclassNumSlots;
_iss sqInt statSweepCount;
_iss usqInt compEnd;
_iss sqInt lowSpaceThreshold;
_iss usqInt memory;
_iss sqInt rootTableOverflowed;
_iss sqInt shrinkThreshold;
_iss sqInt statShrinkMemory;
_iss sqInt statTenures;
_iss sqInt edenBytes;
_iss usqInt fwdTableLast;
_iss sqInt pendingFinalizationSignals;
_iss sqInt preemptionYields;
_iss sqInt printSends;
_iss sqInt statCompMoveCount;
_iss sqInt statFullGCs;
_iss sqInt statIncrGCs;
_iss sqInt statMkFwdCount;
_iss sqInt tenuringThreshold;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt forceTenureFlag;
_iss sqInt fullScreenFlag;
_iss sqInt multipleBytecodeSetsActive;
_iss sqInt signalLowSpace;
_iss sqInt statNumMaps;
_iss sqInt statRootTableOverflows;
_iss sqInt statSpecialMarkCount;
_iss sqInt totalObjectCount;
_iss sqInt classLinkedListClassTag;
_iss void * ffiCalloutVMHandle;
_iss usqInt gcBiasToGrowThreshold;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
#endif
_iss sqInt oldImageBaseAddress;
_iss sqInt savedWindowSize;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcBiasToGrow;
_iss sqInt gcBiasToGrowGCLimit;
_iss sqInt gcSemaphoreIndex;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
#if LRPCheck
_iss sqInt longRunningPrimitiveSignalUndelivered;
#endif
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt newFinalization;
_iss sqInt statRootTableCount;
_iss sqInt statSurvivorCount;
_iss usqInt exceptionPC;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt primTraceLog[256];
_iss sqInt rootTable[RootTableSize + 1 /* 2501 */];
_iss sqInt* extraRoots[ExtraRootSize + 1 /* 2049 */];
_iss sqInt weakRoots[WeakRootTableSize + 1 /* 2626 */];
_iss sqInt interruptCheckCounter;
_iss sqInt lastHash;
_iss sqInt metaAccessorDepth;
_iss sqInt oldSpaceStart;
_iss sqLong nextProfileTick;
_iss usqLong nextWakeupUsecs;
#if LRPCheck
_iss usqLong longRunningPrimitiveStartUsecs;
#endif
#if LRPCheck
_iss usqLong longRunningPrimitiveStopUsecs;
#endif
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss usqLong gcStartUsecs;
_iss sqLong secondaryErrorCode;
_iss usqLong statFullGCUsecs;
_iss usqLong statIncrGCUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIOProcessEvents;
_iss usqLong statIdleUsecs;
_iss usqLong statProcessSwitch;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
#if LRPCheck
_iss usqLong longRunningPrimitiveGCUsecs;
#endif
_iss usqLong nextPollUsecs;
_iss usqLong byteCount;
_iss unsigned char primTraceLogIndex;
_iss jmp_buf reenterInterpreter;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
# if SQ_USE_GLOBAL_STRUCT_REG
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# else
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
# endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
# if SQ_USE_GLOBAL_STRUCT_REG
#	define fooxstr(s) foostr(s)
#	define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
# else
static struct foo * foo = &fum;
# endif
#endif
static void *primitiveCalloutPointer = (void *)-1;
static const sqInt headerTypeBytes[] = {
		8, 4, 0, 0
	};
static void (*primitiveFunctionPointer)();
static void (*interruptCheckChain)(void) = 0;
static usqInt (* const pcPreviousToFunction)(sqInt,sqInt) = pcPreviousToinSqueakV3PlusClosuresMethod;
static int (*sHEAFn)() = 0;
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 584 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ (void (*)(void))0,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ primitiveObjectsAccessibleFromRoots,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ (void (*)(void))0,
	/* 108 */ (void (*)(void))0,
	/* 109 */ (void (*)(void))0,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ primitiveCosine,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ primitiveCompareWith,
	/* 159 */ primitiveHashMultiply,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ primitiveGetImmutability,
	/* 164 */ primitiveSetImmutability,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ (void (*)(void))0,
	/* 172 */ (void (*)(void))0,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ (void (*)(void))0,
	/* 181 */ (void (*)(void))0,
	/* 182 */ (void (*)(void))0,
	/* 183 */ (void (*)(void))0,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ primitiveGetSetFFIExceptionHandling,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ primitiveFloatArrayAt,
	/* 239 */ primitiveFloatArrayAtPut,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ primitiveUtcAndTimezoneOffset,
	/* 245 */ primitiveCoarseUTCMicrosecondClock,
	/* 246 */ primitiveCoarseLocalMicrosecondClock,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ primitiveArrayBecomeOneWayNoCopyHash,
	/* 249 */ primitiveArrayBecomeOneWayCopyHashArg,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ primitiveSuspendBackingUpV1,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ primitiveHighBit,
	/* 576 */ (void (*)(void))0,
	/* 577 */ (void (*)(void))0,
	/* 578 */ primitiveSuspendBackingUpV2,
	/* 579 */ (void (*)(void))0,
	/* 580 */ primitivePinnedNew,
	/* 581 */ primitivePinnedNewWithArg,
	/* 582 */ primitiveUninitializedNewWithArg,
 0 };
sqInt debugCallbackPath;
void * displayBits;
sqInt primitiveDoMixedArithmetic = -1;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
int displayWidth;
sqInt breakSelectorLength = MinSmallInteger;
int displayDepth;
sqInt eventTraceMask;
sqInt extraVMMemory;
int displayHeight;
sqInt checkForLeaks;
sqInt ffiExceptionResponse;
sqInt inIOProcessEvents;
sqInt upscaleDisplayIfHighDPI = -1;
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
sqInt sendWheelEvents;
sqInt breakLookupClassTag;
char * breakSelector;
sqInt debugCallbackInvokes;
sqInt debugCallbackReturns;
sqInt cannotDeferDisplayUpdates;
sqInt checkedPluginName;
const char *interpreterVersion = "Open Smalltalk Stack VM [StackInterpreterPrimitives VMMaker.oscog-eem.3456]";
sqInt suppressHeartbeatFlag;
char expensiveAsserts = 0;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);
volatile int sendTrace;


/*** Macros ***/
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define classFieldOffset() (0 - BaseHeaderSize)
#define compactClassFieldWidth() 5
#define freeStart() GIV(freeStart)
#define instFormatFieldLSB() 8
#define instFormatFieldWidth() 4
#define youngStart() GIV(youngStart)
#define arrayFormat() 2
#define compactClassFieldLSB() 12
#define firstByteFormat() 8
#define firstCompiledMethodFormat() 12
#define firstLongFormat() 6
#define indexablePointersFormat() 3
#define isForwarded(x) 0
#define shiftForWord() 2
#define startOfMemory() GIV(memory)
#define weakArrayFormat() 4
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define cr() fputc('\n',transcript)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define enterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define initialEnterSmalltalkExecutive() enterSmalltalkExecutiveImplementation()
#define primitiveDoMixedArithmetic() primitiveDoMixedArithmetic
#define primTraceLogIndex(aValue) (GIV(primTraceLogIndex) = (aValue))
#define printChar(aCharacter) fputc(aCharacter,transcript)
#define remoteIsInstVarAccess() 128
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


/*** Methods ***/


/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt lkupClassTag;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt stackPageBytes;
    sqInt stackZoneBytes;
    void *theStackMemory;

	if (!GIV(stackLimit)) {
		/* begin initStackPagesAndInterpret */
		/* begin ensureInitializeStackZone */
		if (!GIV(pages)) {
			stackPageBytes = stackPageByteSize();
			stackZoneBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
			theStackMemory = alloca(stackZoneBytes);
			memset(theStackMemory, 0, stackZoneBytes);
			initializeStacknumSlotspageSize(theStackMemory, stackZoneBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		}
		loadInitialContext();
		ioInitHeartbeat();
		initialEnterSmalltalkExecutive();
		return null;
	}
	browserPluginInitialiseIfNeeded();

	/* begin setMethod: */
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1, __LINE__);

	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));

	/* begin initExtensions */
	currentBytecode = byteAtPointer(++localIP);
	while (1) {
		/* begin dispatchBytecode */
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		case 0:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt((longAt(localFP + FoxReceiver)) + BaseHeaderSize));
			}
			break;
		case 1:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 4 /* (1 << shiftForWord) */));
			}
			break;
		case 2:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (2 << shiftForWord) */));
			}
			break;
		case 3:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 12 /* (3 << shiftForWord) */));
			}
			break;
		case 4:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (4 << shiftForWord) */));
			}
			break;
		case 5:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 20 /* (5 << shiftForWord) */));
			}
			break;
		case 6:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (6 << shiftForWord) */));
			}
			break;
		case 7:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 28 /* (7 << shiftForWord) */));
			}
			break;
		case 8:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (8 << shiftForWord) */));
			}
			break;
		case 9:   // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 36 /* (9 << shiftForWord) */));
			}
			break;
		case 10:  // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (10 << shiftForWord) */));
			}
			break;
		case 11:  // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 44 /* (11 << shiftForWord) */));
			}
			break;
		case 12:  // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (12 << shiftForWord) */));
			}
			break;
		case 13:  // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 52 /* (13 << shiftForWord) */));
			}
			break;
		case 14:  // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (14 << shiftForWord) */));
			}
			break;
		case 15:  // pushReceiverVariableBytecode
			{
				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 60 /* (15 << shiftForWord) */));
			}
			break;
		case 16:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(0 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + (frameNumArgs * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + (frameNumArgs * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(1 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(2 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(3 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(4 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(5 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(6 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(7 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(8 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(9 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(10 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(11 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(12 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(13 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(14 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:  // pushTemporaryVariableBytecode
			{
				usqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = /* temporary:in: */
						(15 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((0 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((1 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((2 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((3 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((4 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((5 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((6 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((7 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((8 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((9 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((10 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((11 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((12 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((13 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((14 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((15 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((16 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((17 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((18 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((19 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((20 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((21 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((22 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((23 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((24 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((25 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((26 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((27 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((28 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((29 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((30 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:  // pushLiteralConstantBytecode
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((31 + LiteralStart) << shiftForWord) */);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((0 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 65:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((1 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 66:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((2 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 67:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((3 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 68:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((4 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 69:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((5 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 70:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((6 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 71:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((7 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 72:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((8 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 73:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((9 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 74:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((10 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 75:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((11 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 76:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((12 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 77:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((13 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 78:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((14 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 79:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((15 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 80:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((16 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 81:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((17 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 82:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((18 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 83:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((19 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 84:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((20 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 85:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((21 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 86:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((22 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 87:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((23 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 88:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((24 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 89:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((25 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 90:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((26 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 91:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((27 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 92:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((28 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 93:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((29 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 94:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((30 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 95:  // pushLiteralVariableBytecode
			{
				sqInt litVar;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				litVar = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((31 + LiteralStart) << shiftForWord) */);
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* (ValueIndex << shiftForWord) */));
			}
			break;
		case 96:  // storeAndPopReceiverVariableBytecode
		case 97:  // storeAndPopReceiverVariableBytecode
		case 98:  // storeAndPopReceiverVariableBytecode
		case 99:  // storeAndPopReceiverVariableBytecode
		case 100: // storeAndPopReceiverVariableBytecode
		case 101: // storeAndPopReceiverVariableBytecode
		case 102: // storeAndPopReceiverVariableBytecode
		case 103: // storeAndPopReceiverVariableBytecode
			{
				usqInt instVarIndex;
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				rcvr = longAt(localFP + FoxReceiver);
				top = longAtPointer(localSP);
				instVarIndex = currentBytecode & 7;

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, top);
				}
				longAtput((rcvr + BaseHeaderSize) + ((instVarIndex << (shiftForWord()))), top);

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
			break;
		case 104: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (0 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + (frameNumArgs * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + (frameNumArgs * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (1 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (2 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (3 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (4 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (5 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (6 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111: // storeAndPopTemporaryVariableBytecode
			{
				usqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* temporary:in:put: */
				if (7 < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7) * BytesPerWord), longAtPointer(localSP));
				}

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112: // pushReceiverBytecode
			{
				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), longAt(localFP + FoxReceiver));
			}
			break;
		case 113: // pushConstantTrueBytecode
			{
				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
			break;
		case 114: // pushConstantFalseBytecode
			{
				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
			break;
		case 115: // pushConstantNilBytecode
			{
				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
			}
			break;
		case 116: // pushConstantMinusOneBytecode
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117: // pushConstantZeroBytecode
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118: // pushConstantOneBytecode
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119: // pushConstantTwoBytecode
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120: // returnReceiver
			{
				VM_LABEL(returnReceiver);
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */;
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt senderContext;
				sqInt senderOop;
				char *theFP;
				char *theFP1;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethodSqInt;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;

				VM_LABEL(commonReturn);

				/* If this is a method simply return to the  sender/caller. */
				frameToReturnTo = ((char *) 0);
				theFP = ((char *) 0);
				if (!(byteAt((localFP + FoxFrameFlags) + 3))) {
					goto commonCallerReturn;
					goto l76;
				}

				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				closure = longAt(localFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord()))))));

				/* avoid compiler warning */
				/* Walk the closure's lexical chain to find the context or frame to return from (home).
				   If home is missing (Sista closures) then throw cannotReturn rather than crash. */
				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
					if (!(/* isContext: */
							((home & 1) == 0)
						 && (((((usqInt)((longAt(home)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						/* begin internalCannotReturn: */
						/* begin ensureFrameIsMarried:SP: */
						if (byteAt((localFP + FoxFrameFlags) + 2)) {
							assert(isContext(frameContext(localFP)));
							ourContext = longAt(localFP + FoxThisContext);
							goto l80;
						}
						ourContext = marryFrameSP(localFP, localSP);
l80:	/* end ensureFrameIsMarried:SP: */;

						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext);
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l76;
					}
					closure = longAt((home + BaseHeaderSize) + ((((usqInt)(ClosureIndex) << (shiftForWord())))));
				}

				/* begin findUnwindThroughContext: */
				/* Since nothing changes we don't need to internalize. */
				onSamePage = (/* isStillMarriedContext: */
						(((longAt((home + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(home))))
					 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage))) == (pageIndexFor(frameOfMarriedContext(home))));

				/* begin findMethodWithPrimitive:FromFP:UpToContext: */
				theFP1 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP1 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l81;
					}
					if (!(byteAt((theFP1 + FoxFrameFlags) + 3))) {
						theMethodSqInt = longAt(theFP1 + FoxMethod);
						if ((primitiveIndexOf(theMethodSqInt)) == PrimNumberUnwindMarker) {
							if (theFP1 == theFPAbove) {
								theSP = findSPOfon(theFP1, stackPageFor(theFP1));
							}
							else {
								/* begin frameCallerStackPointer: */
								assert(!(isBaseFrame(theFPAbove)));
								theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
							}

							/* begin ensureFrameIsMarried:SP: */
							if (byteAt((theFP1 + FoxFrameFlags) + 2)) {
								assert(isContext(frameContext(theFP1)));
								ctxtOrNilOrZero = longAt(theFP1 + FoxThisContext);
								goto l81;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP1, theSP);
							goto l81;
						}
					}
					theFPAbove = theFP1;
					theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
				} while(theFP1 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(/* isContext: */
						((senderContext & 1) == 0)
					 && (((((usqInt)((longAt(senderContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
					ctxtOrNilOrZero = GIV(nilObj);
					goto l81;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, senderContext, home);
l81:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
				if (!ctxtOrNilOrZero) {
					theMethod = longAt((home + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
					if ((primitiveIndexOf(theMethod)) == PrimNumberUnwindMarker) {
						unwindContextOrNilOrZero = home;
						goto l77;
					}
					unwindContextOrNilOrZero = 0;
					goto l77;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home)) == GIV(nilObj)) {
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l77;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
l77:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */
					/* begin internalCannotReturn: */
					/* begin ensureFrameIsMarried:SP: */
					if (byteAt((localFP + FoxFrameFlags) + 2)) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l83;
					}
					ourContext = marryFrameSP(localFP, localSP);
l83:	/* end ensureFrameIsMarried:SP: */;

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l76;
				}
				if (unwindContextOrNilOrZero) {
					/* begin internalAboutToReturn:through: */
					/* begin ensureFrameIsMarried:SP: */
					if (byteAt((localFP + FoxFrameFlags) + 2)) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l79;
					}
					ourContext = marryFrameSP(localFP, localSP);
l79:	/* end ensureFrameIsMarried:SP: */;

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorAboutToReturn) << (shiftForWord())))));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l76;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));

					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
					if (longAt(theFP + FoxSavedFP)) {
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
					else {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
					if ((/* isContext: */
						((contextToReturnTo & 1) == 0)
					 && (((((usqInt)((longAt(contextToReturnTo)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));

						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						frameToReturnTo = pointerForOop(senderOop - 1 /* smallIntegerTag */);
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(/* isContext: */
							((contextToReturnTo & 1) == 0)
						 && (((((usqInt)((longAt(contextToReturnTo)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l78;
					}
					if (((longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */
							frameToReturnTo = 0;
							goto l78;
						}

						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						frameToReturnTo = pointerForOop(senderOop - 1 /* smallIntegerTag */);
						goto l78;
					}
					if (!(((longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))) {
						frameToReturnTo = 0;
						goto l78;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
l78:	/* end establishFrameForContextToReturnTo: */;
					if (!frameToReturnTo) {

						/* error: home's sender is dead; cannot return */
						/* begin internalCannotReturn: */
						/* begin ensureFrameIsMarried:SP: */
						if (byteAt((localFP + FoxFrameFlags) + 2)) {
							assert(isContext(frameContext(localFP)));
							ourContext = longAt(localFP + FoxThisContext);
							goto l82;
						}
						ourContext = marryFrameSP(localFP, localSP);
l82:	/* end ensureFrameIsMarried:SP: */;

						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext);
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l76;
					}
				}
				assert(pageListIsWellFormed());

				/* begin stackPageFor: */
				newPage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
							/* begin stackPageFor: */
							thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */
								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							currentCtx = longAt(((thePage->baseFP)) + FoxCallerContext);
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));

							/* begin markContextAsDead: */
							assert(isContext(currentCtx));

							/* storePointerUnchecked:ofObject:withValue: */
							longAtput((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

							/* storePointerUnchecked:ofObject:withValue: */
							longAtput((currentCtx + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
							currentCtx = nextCntx;
						}
					}

					/* begin setStackPageAndLimit: */
					assert(newPage);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */
					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = ((/* begin frameCallerSP: */
	assert(!(isBaseFrame(callerFP))),
(callerFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((callerFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord)) - BytesPerWord;
				}

				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* internalStackTopPut: */
				longAtPointerput(localSP, localReturnValue);
			}
l76:;
			break;
		case 121: // returnTrue
			{
				VM_LABEL(returnTrue);
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122: // returnFalse
			{
				VM_LABEL(returnFalse);
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123: // returnNil
			{
				VM_LABEL(returnNil);
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124: // returnTopFromMethod
			{
				VM_LABEL(returnTopFromMethod);
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125: // returnTopFromBlock
			{
				VM_LABEL(returnTopFromBlock);
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */;
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);

				/* TODO: Store/restore the nativeSP more properly, when it exists */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (!callersFPOrNull) {

					/* baseFrame */
					assert(localFP == ((GIV(stackPage)->baseFP)));

					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = /* isContext: */
							((contextToReturnTo & 1) == 0)
						 && (((((usqInt)((longAt(contextToReturnTo)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
					if (isAContext
					 && (/* isStillMarriedContext: */
						(((longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

						/* begin stackPageFor: */
						thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */
							/* begin findFrameAbove:inPage: */
							callerFP = ((char *) 0);
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l85;
							}
							while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l85;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
l85:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1)))) {
							/* begin internalCannotReturn: */
							/* begin ensureFrameIsMarried:SP: */
							if (byteAt((localFP + FoxFrameFlags) + 2)) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l86;
							}
							ourContext = marryFrameSP(localFP, localSP);
l86:	/* end ensureFrameIsMarried:SP: */;

							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorCannotReturn) << (shiftForWord())))));
							GIV(argumentCount) = 1;
							goto normalSend;
							goto l84;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}

					/* begin setStackPageAndLimit: */
					assert(thePage);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;

					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));
					localIP = pointerForOop(longAtPointer(localSP));

					/* internalStackTopPut: */
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l84;
				}
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((localFP + FoxFrameFlags) + 1))) << (shiftForWord())))));
				localFP = callersFPOrNull;

				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);

				/* internalStackTopPut: */
				longAtPointerput(localSP, localReturnValue);
			}
l84:;
			break;
		case 126: // unknownBytecode
		case 127: // unknownBytecode
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */;
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = /* maybeSplObj: */
						(SelectorUnknownBytecode < (lengthOf(GIV(specialObjectsOop)))
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorUnknownBytecode) << (shiftForWord())))))
							: 0);
				if ((!GIV(messageSelector))
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}

				/* begin ensureFrameIsMarried:SP: */
				if (byteAt((localFP + FoxFrameFlags) + 2)) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l87;
				}
				ourContext = marryFrameSP(localFP, localSP);
l87:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128: // extendedPushBytecode
			{
				sqInt descriptor;
				usqInt frameNumArgs;
				sqInt litVar;
				sqInt object;
				usqInt variableIndex;
				usqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				variableType = (((usqInt)(descriptor)) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (!variableType) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + ((variableIndex << (shiftForWord())))));
					goto l1;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					object = /* temporary:in: */
							(variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
								? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
								: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l1;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + (((variableIndex + LiteralStart) << (shiftForWord()))));

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l1;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((variableIndex + LiteralStart) << (shiftForWord()))));
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord()))))));
					goto l1;
				}
			}
l1:	/* end case */;
			break;
		case 129: // extendedStoreBytecode
			{
				sqInt descriptor;
				usqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				usqInt variableIndex;

				VM_LABEL(extendedStoreBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);
				switch ((((usqInt)(descriptor)) >> 6) & 3) {
				case 0:
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + ((variableIndex << (shiftForWord()))), value);
					break;
				case 1:
					/* temporary:in:put: */
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					break;
				case 2:
					error("illegal store");
					break;
				case 3:
					/* begin storeLiteralVariable:withValue: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((variableIndex + LiteralStart) << (shiftForWord()))));
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))), value);
					break;
				default:
					error("Case not found and no otherwise clause");
				}

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
			break;
		case 130: // extendedStoreAndPopBytecode
			{
				sqInt descriptor;
				usqInt frameNumArgs;
				sqInt litVar;
				sqInt value;
				usqInt variableIndex;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecodePop: */
				descriptor = byteAtPointer(++localIP);
				variableIndex = descriptor & 0x3F;
				value = longAtPointer(localSP);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
				switch ((((usqInt)(descriptor)) >> 6) & 3) {
				case 0:
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(longAt(localFP + FoxReceiver), GIV(youngStart))) {
						possibleRootStoreIntovalue(longAt(localFP + FoxReceiver), value);
					}
					longAtput(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + ((variableIndex << (shiftForWord()))), value);
					break;
				case 1:
					/* temporary:in:put: */
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), value);
					}
					break;
				case 2:
					error("illegal store");
					break;
				case 3:
					/* begin storeLiteralVariable:withValue: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + (((variableIndex + LiteralStart) << (shiftForWord()))));
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, value);
					}
					longAtput((litVar + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))), value);
					break;
				default:
					error("Case not found and no otherwise clause");
				}

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
			break;
		case 131: // singleExtendedSendBytecode
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((descriptor & 0x1F) + LiteralStart) << (shiftForWord()))));
				GIV(argumentCount) = ((usqInt)(descriptor)) >> 5;
				/* goto normalSend */;
			}
			
		normalSend:
			/* normalSend */
			{
				usqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(normalSend);
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				lkupClassTag = /* #fetchClassTagOf: #fetchClassOf: */
						((rcvr & 1)
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
							: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask));
				assert(lkupClassTag != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					usqInt ccIndex;
					sqInt hash;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					usqInt numTemps;
					sqInt object;
					usqInt probe;
					sqInt rcvr;
					int succeeded;

					VM_LABEL(commonSendOrdinary);
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));

					/* begin sendBreakpoint:receiver: */
					sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), /* #fetchClassTagOf: #fetchClassOf: */
						((rcvr & 1)
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
							: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)));
					if (
#          if SEND_PRINTING
						GIV(printSends)
#          else
						0
#          endif
						) {
						printActivationNameForSelectorstartClass(GIV(messageSelector), lkupClassTag);
						cr();
					}

					/* begin internalFindNewMethodOrdinary */
					/* begin inlineLookupInMethodCacheSel:classTag: */
					/* shift drops two low-order zeros from addresses */
					hash = GIV(messageSelector) ^ lkupClassTag;

					/* first probe */
					probe = hash & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						goto l88;
					}

					/* second probe */
					probe = (((usqInt)(hash)) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						goto l88;
					}
					probe = (((usqInt)(hash)) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
						GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
						goto l88;
					}

					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					GIV(lkupClass) = lkupClassTag;
					lookupMethodInClass(GIV(lkupClass));

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
l88:;

					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer) {
						if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((((usqInt)((localPrimIndex - 264)) << (shiftForWord()))))));
								goto l89;
							}
							if (localPrimIndex == 0x100) {
								goto l89;
							}
							if (localPrimIndex == 0x101) {
								/* internalStackTopPut: */
								longAtPointerput(localSP, GIV(trueObj));
								goto l89;
							}
							if (localPrimIndex == 258) {
								/* internalStackTopPut: */
								longAtPointerput(localSP, GIV(falseObj));
								goto l89;
							}
							if (localPrimIndex == 259) {
								/* internalStackTopPut: */
								longAtPointerput(localSP, GIV(nilObj));
								goto l89;
							}

							/* internalStackTopPut: */
							longAtPointerput(localSP, (((usqInt)(localPrimIndex - 261) << 1) | 1));
							goto l89;
						}

						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;

						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((GIV(remapBufferCount)) == 0);

						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						if (LOGPRIMITIVES) {
							/* begin fastLogPrim: */
							GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(newMethod);
							primTraceLogIndex(GIV(primTraceLogIndex) + 1);
						}
						dispatchFunctionPointer(primitiveFunctionPointer);
						assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));

						/* begin maybeRetryPrimitiveOnFailure */
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						succeeded = !GIV(primFailCode);

						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l89;
						}
					}

					/* begin internalActivateNewMethod */
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(GIV(newMethod)));
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
					numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

					/* could new rcvr be set at point of send? */
					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr)));

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert((methodHeaderOf(GIV(method))) == methodHeader);
					assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
					object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
							(VMBIGENDIAN
								? ((1 + ((((((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15) << ((BytesPerWord * 8) - 8)))))
								: ((1 + ((((((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15) << 8)))));

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), object);
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
						localIP += 0 /* sizeOfCallPrimitiveBytecode: */;
						if (GIV(primFailCode)) {
							reapAndResetErrorCodeToheader(localSP, methodHeader);
						}
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));

						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
					}
l89:	/* end internalExecuteNewMethod */;

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
			}
			break;
		case 132: // doubleExtendedDoAnythingBytecode
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt litVar;
				sqInt obj;
				sqInt object;
				int onCurrentPage;
				sqInt opType;
				sqInt senderOop;
				char *spouseFP;
				char *theFP;
				StackPage *thePage;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt)(byte2)) >> 5;
				if (!opType) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l3;
				}
				if (opType == 1) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l3;
				}
				if (opType == 2) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					obj = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((((usqInt)((longAt(obj)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						/* begin instVar:ofContext: */
						assert(byte3 < MethodIndex);
						assert(isContext(obj));
						if (!(((longAt((obj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))) {
							object = longAt((obj + BaseHeaderSize) + ((((usqInt)(byte3) << (shiftForWord())))));
							goto l2;
						}

						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(obj)) {
							object = longAt((obj + BaseHeaderSize) + ((((usqInt)(byte3) << (shiftForWord())))));
							goto l2;
						}

						/* begin frameOfMarriedContext: */
						senderOop = longAt((obj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOop & 1));
						spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
						if (!byte3) {
							/* begin ensureCallerContext: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (!callerFP) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */
								object = longAt(spouseFP + FoxCallerContext);
								goto l2;
							}

							/* begin ensureFrameIsMarried:SP: */
							if (byteAt((callerFP + FoxFrameFlags) + 2)) {
								assert(isContext(frameContext(callerFP)));
								object = longAt(callerFP + FoxThisContext);
								goto l2;
							}
							object = marryFrameSP(
									callerFP,
									(/* begin frameCallerStackPointer: */
										assert(!(isBaseFrame(spouseFP))),
									(spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((spouseFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord));
							goto l2;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(obj)));
							object = (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l2;
						}
						if (byte3 == InstructionPointerIndex) {
							object = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l2;
						}
						error("bad index");
						object = 0;
l2:	/* end instVar:ofContext: */;

						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), object);
					}
					else {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), longAt((obj + BaseHeaderSize) + ((((usqInt)(byte3) << (shiftForWord()))))));
					}
					goto l3;
				}
				if (opType == 3) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + ((((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));

					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l3;
				}
				if (opType == 4) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					litVar = longAt((GIV(method) + BaseHeaderSize) + ((((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord()))))));
					goto l3;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */
					litVar = longAt((GIV(method) + BaseHeaderSize) + ((((usqInt)((byte3 + LiteralStart)) << (shiftForWord())))));
					if (oopisLessThan(litVar, GIV(youngStart))) {
						possibleRootStoreIntovalue(litVar, top);
					}
					longAtput((litVar + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))), top);

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l3;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				obj = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((((usqInt)((longAt(obj)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
				 && (((longAt((obj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(obj));
					assert(!((isObjImmutable(obj))));

					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!(/* isStillMarriedContext: */
							(((longAt((obj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && (!(isWidowedContext(obj))))) {
						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(obj, GIV(youngStart))) {
							possibleRootStoreIntovalue(obj, top);
						}
						longAtput((obj + BaseHeaderSize) + ((((usqInt)(byte3) << (shiftForWord())))), top);
						goto l4;
					}

					/* begin frameOfMarriedContext: */
					senderOop = longAt((obj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
					if (!byte3) {
						/* begin stackPageFor: */
						thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
						assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l4;
					}

					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, obj);

					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj, top);
					}
					longAtput((obj + BaseHeaderSize) + ((((usqInt)(byte3) << (shiftForWord())))), top);

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
l4:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointerImmutabilityCheck:ofObject:withValue: */
					/* begin storePointer:ofObject:withValue: */
					if (oopisLessThan(obj, GIV(youngStart))) {
						possibleRootStoreIntovalue(obj, top);
					}
					longAtput((obj + BaseHeaderSize) + ((((usqInt)(byte3) << (shiftForWord())))), top);
				}

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
l3:;
			break;
		case 133: // singleExtendedSuperBytecode
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				descriptor = byteAtPointer(++localIP);

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((descriptor & 0x1F) + LiteralStart) << (shiftForWord()))));
				GIV(argumentCount) = ((usqInt)(descriptor)) >> 5;
				/* goto superclassSend */;
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt literal;
				sqInt offset;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin methodClassOf: */
				offset = (literalCountOf(GIV(method))) - 1;
				literal = longAt((GIV(method) + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
				classPointer = ((literal != GIV(nilObj))
					 && (/* isPointers: */
						((literal & 1) == 0)
					 && (((((usqInt)((longAt(literal)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
							? (assert((numSlotsOf(literal)) > ValueIndex),
							/* #followField:ofObject: #fetchPointer:ofObject: */
								longAt((literal + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord()))))))
							: GIV(nilObj));

				/* begin superclassOf: */
				superclass = longAt((classPointer + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));

				/* To maintain the invariant that all receivers are unforwarded we need an explicit
				   read barrier in the super send cases.  Even though we always follow receivers
				   on become  e.g. super doSomethingWith: (self become: other) forwards the receiver
				   self pushed on the stack. */
				lkupClassTag = superclass;
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 134: // secondExtendedSendBytecode
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((descriptor & 0x3F) + LiteralStart) << (shiftForWord()))));
				GIV(argumentCount) = ((usqInt)(descriptor)) >> 6;
				goto normalSend;
			}
			break;
		case 135: // popStackBytecode
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136: // duplicateTopBytecode
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				object = longAtPointer(localSP);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137: // pushActiveContextBytecode
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if (byteAt((localFP + FoxFrameFlags) + 2)) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l5;
				}
				ourContext = marryFrameSP(localFP, localSP);
l5:	/* end ensureFrameIsMarried:SP: */;

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138: // pushNewArrayBytecode
			{
				sqInt array;
				sqInt i;
				int popValues;
				sqInt size;

				VM_LABEL(pushNewArrayBytecode);
				size = byteAtPointer(++localIP);
				if ((popValues = size >= 128)) {
					size -= 128;
				}

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				array = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, arrayFormat(), size);
				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */
						/* storePointerUnchecked:ofObject:withValue: */
						longAtput((array + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}

					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* storePointerUnchecked:ofObject:withValue: */
						longAtput((array + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
					}
				}

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139: // unknownBytecode
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			break;
		case 140: // pushRemoteTempLongBytecode
			{
				usqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				tempVector = /* temporary:in: */
						(tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((tempVector + BaseHeaderSize) + ((((usqInt)(remoteTempIndex) << (shiftForWord()))))));
			}
			break;
		case 141: // storeRemoteTempLongBytecode
			{
				usqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				tempVector = /* temporary:in: */
						(tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));

				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + ((((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));
			}
			break;
		case 142: // storeAndPopRemoteTempLongBytecode
			{
				usqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				tempVector = /* temporary:in: */
						(tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
							? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
							: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));

				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(tempVector, GIV(youngStart))) {
					possibleRootStoreIntovalue(tempVector, longAtPointer(localSP));
				}
				longAtput((tempVector + BaseHeaderSize) + ((((usqInt)(remoteTempIndex) << (shiftForWord())))), longAtPointer(localSP));

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143: // pushClosureCopyCopiedValuesBytecode
			{
				sqInt blockSize;
				sqInt context;
				sqInt i;
				sqInt newClosure;
				usqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */
				numCopied = (((usqInt)(numArgsNumCopied)) >> 4);
				blockSize = ((sqInt)((usqInt)((byteAtPointer(++localIP))) << 8));
				blockSize += byteAtPointer(++localIP);

				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				/* begin ensureFrameIsMarried:SP: */
				if (byteAt((localFP + FoxFrameFlags) + 2)) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l6;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
l6:	/* end ensureFrameIsMarried:SP: */;

				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				newClosure = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), context);

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure + BaseHeaderSize) + ((((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)(((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize)) << 1) | 1));

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((newClosure + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), ((numArgs << 1) | 1));
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */
						/* storePointerUnchecked:ofObject:withValue: */
						longAtput((newClosure + BaseHeaderSize) + ((((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}

					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				offset = 1;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 145: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				offset = 2;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 146: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				offset = 3;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 147: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				offset = 4;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 148: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				offset = 5;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 149: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				offset = 6;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 150: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				offset = 7;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 151: // shortUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				offset = 8;

				/* begin jump: */
				localIP = (localIP + offset) + 1;
				currentBytecode = byteAtPointer(localIP);
			}
			break;
		case 152: // shortConditionalJumpFalse
		case 153: // shortConditionalJumpFalse
		case 154: // shortConditionalJumpFalse
		case 155: // shortConditionalJumpFalse
		case 156: // shortConditionalJumpFalse
		case 157: // shortConditionalJumpFalse
		case 158: // shortConditionalJumpFalse
		case 159: // shortConditionalJumpFalse
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				offset = (currentBytecode & 7) + 1;

				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l7;
					}

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				localSP += 1 * BytesPerOop;
l7:;
			}
			break;
		case 160: // longUnconditionalJump
		case 161: // longUnconditionalJump
		case 162: // longUnconditionalJump
		case 163: // longUnconditionalJump
		case 164: // longUnconditionalJump
		case 165: // longUnconditionalJump
		case 166: // longUnconditionalJump
		case 167: // longUnconditionalJump
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 0x100) + (byteAtPointer(++localIP));
				localIP += offset;

				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
			break;
		case 168: // longJumpIfTrue
		case 169: // longJumpIfTrue
		case 170: // longJumpIfTrue
		case 171: // longJumpIfTrue
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				offset = ((currentBytecode & 3) * 0x100) + (byteAtPointer(++localIP));

				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l8;
					}

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				localSP += 1 * BytesPerOop;
l8:;
			}
			break;
		case 172: // longJumpIfFalse
		case 173: // longJumpIfFalse
		case 174: // longJumpIfFalse
		case 175: // longJumpIfFalse
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				offset = ((currentBytecode & 3) * 0x100) + (byteAtPointer(++localIP));

				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorMustBeBoolean) << (shiftForWord())))));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l9;
					}

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
				}
				localSP += 1 * BytesPerOop;
l9:;
			}
			break;
		case 176: // bytecodePrimAdd
			{
				sqInt arg;
				double argDouble;
				usqInt ccIndex;
				sqInt classOop;
				sqInt isFloat;
				sqInt rcvr;
				double rcvrDouble;
				sqInt result;
				double resultDouble;
				char *sp;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ (((((usqInt)result)) << 1))))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += 1 * BytesPerOop), (((usqInt)result << 1) | 1));
						currentBytecode = byteAtPointer(++localIP);
						goto l10;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;

					/* begin primitiveFloatAdd:toArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvrDouble = ((double) ((rcvr >> 1)) );
						goto l14;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l12;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l12;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l12;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l12:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, resultDouble);
						rcvrDouble = resultDouble;
						goto l14;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvrDouble = 0.0;
l14:	/* end loadFloatOrIntFrom: */;

					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						argDouble = ((double) ((arg >> 1)) );
						goto l13;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat = 0;
						goto l11;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l11;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l11;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l11:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(arg + BaseHeaderSize, resultDouble);
						argDouble = resultDouble;
						goto l13;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					argDouble = 0.0;
l13:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvrDouble + argDouble));
						GIV(stackPointer) = sp;
					}

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l10;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (0U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l10:	/* end case */;
			break;
		case 177: // bytecodePrimSubtract
			{
				sqInt arg;
				double argDouble;
				usqInt ccIndex;
				sqInt classOop;
				sqInt isFloat;
				sqInt rcvr;
				double rcvrDouble;
				sqInt result;
				double resultDouble;
				char *sp;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)((((usqInt)result)) ^ (((((usqInt)result)) << 1))))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += 1 * BytesPerOop), (((usqInt)result << 1) | 1));
						currentBytecode = byteAtPointer(++localIP);
						goto l15;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;

					/* begin primitiveFloatSubtract:fromArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvrDouble = ((double) ((rcvr >> 1)) );
						goto l19;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l17;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l17;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l17;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l17:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, resultDouble);
						rcvrDouble = resultDouble;
						goto l19;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvrDouble = 0.0;
l19:	/* end loadFloatOrIntFrom: */;

					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						argDouble = ((double) ((arg >> 1)) );
						goto l18;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat = 0;
						goto l16;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l16;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l16;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l16:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(arg + BaseHeaderSize, resultDouble);
						argDouble = resultDouble;
						goto l18;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					argDouble = 0.0;
l18:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvrDouble - argDouble));
						GIV(stackPointer) = sp;
					}

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l15;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (2U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l15:	/* end case */;
			break;
		case 178: // bytecodePrimLessThan
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l20;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatLessthanArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l20;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (4U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l20:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);

				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l90;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */
						/* fetchByte */
						byteAtPointer(++localIP);

						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l90;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */
						offset = ((((usqInt)((bytecode - 168)) << 8))) + (byteAtPointer(++localIP));

						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = byteAtPointer(localIP);
						goto l90;
					}
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
l90:;
			break;
		case 179: // bytecodePrimGreaterThan
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */;
					}
					goto l21;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatGreaterthanArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l21;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (6U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l21:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				/* assume next bytecode is jumpIfFalse (99%) */
				bytecode = byteAtPointer(++localIP);

				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */
					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = byteAtPointer(localIP);
					goto l91;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */
					offset = byteAtPointer(++localIP);

					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = byteAtPointer(localIP);
					goto l91;
				}
				currentBytecode = bytecode;

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
l91:;
			break;
		case 180: // bytecodePrimLessOrEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l22;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatLessOrEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l22;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (8U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l22:	/* end case */;
			break;
		case 181: // bytecodePrimGreaterOrEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */
					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l23;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatGreaterOrEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l23;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (10U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l23:	/* end case */;
			break;
		case 182: // bytecodePrimEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l24;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l24;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (12U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l24:	/* end case */;
			break;
		case 183: // bytecodePrimNotEqual
			{
				int aBool;
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l25;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				aBool = primitiveFloatEqualtoArg(rcvr, arg);
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatFalse;
					}
					else {
						goto booleanCheatTrue;
					}
					goto l25;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (14U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l25:	/* end case */;
			break;
		case 184: // bytecodePrimMultiply
			{
				sqInt arg;
				double argDouble;
				usqInt ccIndex;
				sqInt classOop;
				sqInt isFloat;
				sqInt oop;
				int overflow;
				sqInt rcvr;
				double rcvrDouble;
				sqInt result;
				double resultDouble;
				char *sp;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					overflow = (rcvr > 0
								? (arg > 0
										? rcvr > ((MaxSmallInteger) / arg)
										: arg < ((MinSmallInteger) / rcvr))
								: (arg > 0
										? rcvr < ((MinSmallInteger) / arg)
										: (rcvr < 0)
										 && (arg < ((MaxSmallInteger) / rcvr))));
					if (!overflow) {
						result = rcvr * arg;
						oop = (((usqInt)result << 1) | 1);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += 1 * BytesPerOop), oop);
						currentBytecode = byteAtPointer(++localIP);
						goto l26;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;

					/* begin primitiveFloatMultiply:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvrDouble = ((double) ((rcvr >> 1)) );
						goto l30;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l28;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l28;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l28;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l28:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, resultDouble);
						rcvrDouble = resultDouble;
						goto l30;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvrDouble = 0.0;
l30:	/* end loadFloatOrIntFrom: */;

					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						argDouble = ((double) ((arg >> 1)) );
						goto l29;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat = 0;
						goto l27;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l27;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l27;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l27:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(arg + BaseHeaderSize, resultDouble);
						argDouble = resultDouble;
						goto l29;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					argDouble = 0.0;
l29:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvrDouble * argDouble));
						GIV(stackPointer) = sp;
					}

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l26;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (16U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l26:	/* end case */;
			break;
		case 185: // bytecodePrimDivide
			{
				sqInt arg;
				double argDouble;
				usqInt ccIndex;
				sqInt classOop;
				sqInt isFloat;
				sqInt rcvr;
				double rcvrDouble;
				sqInt result;
				double resultDouble;
				char *sp;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((rcvr & arg) & 1) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {
						/* generates C / operation */
						result = rcvr / arg;
						if ((((sqInt)((((usqInt)result)) ^ (((((usqInt)result)) << 1))))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += 1 * BytesPerOop), (((usqInt)result << 1) | 1));
							currentBytecode = byteAtPointer(++localIP);
							goto l31;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;

					/* begin primitiveFloatDivide:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvrDouble = ((double) ((rcvr >> 1)) );
						goto l35;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((rcvr & 1)) {
						isFloat = 0;
						goto l33;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((rcvr & 1)));
					ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l33;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l33;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l33:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(rcvr + BaseHeaderSize, resultDouble);
						rcvrDouble = resultDouble;
						goto l35;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvrDouble = 0.0;
l35:	/* end loadFloatOrIntFrom: */;

					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						argDouble = ((double) ((arg >> 1)) );
						goto l34;
					}

					/* begin floatValueOf: */
					/* begin isFloatInstance: */
					classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
					if ((arg & 1)) {
						isFloat = 0;
						goto l32;
					}

					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!((arg & 1)));
					ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F;
					if (!ccIndex) {
						isFloat = ((longAt(arg - BaseHeaderSize)) & AllButTypeMask) == classOop;
						goto l32;
					}
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l32;
					isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l32:	/* end isFloatInstance: */;
					if (isFloat) {
						fetchFloatAtinto(arg + BaseHeaderSize, resultDouble);
						argDouble = resultDouble;
						goto l34;
					}

					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					argDouble = 0.0;
l34:	/* end loadFloatOrIntFrom: */;

					/* begin success: */
					if (!(argDouble != 0.0)) {

						/* Don't overwrite an error code that has already been set. */
						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvrDouble / argDouble));
						GIV(stackPointer) = sp;
					}

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l31;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (18U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l31:	/* end case */;
			break;
		case 186: // bytecodePrimMod
			{
				sqInt mod;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += 1 * BytesPerOop), (((usqInt)mod << 1) | 1));
					currentBytecode = byteAtPointer(++localIP);
					goto l36;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (20U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l36:	/* end case */;
			break;
		case 187: // bytecodePrimMakePoint
			{
				sqInt arg;
				sqInt pt;
				sqInt rcvr;

				VM_LABEL(bytecodePrimMakePoint);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);
				if ((/* isFloatOrInt: */
					((rcvr & 1))
				 || (((((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))
				 && (/* isFloatOrInt: */
					((arg & 1))
				 || (((((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))) {
					pt = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);

					/* storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + ((((usqInt)(XIndex) << (shiftForWord())))), rcvr);

					/* storePointerUnchecked:ofObject:withValue: */
					longAtput((pt + BaseHeaderSize) + ((((usqInt)(YIndex) << (shiftForWord())))), arg);

					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += 1 * BytesPerOop), pt);
					currentBytecode = byteAtPointer(++localIP);
					goto l37;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (22U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l37:	/* end case */;
			break;
		case 188: // bytecodePrimBitShift
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				unsigned int integerValue;
				sqInt newLargeInteger;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;

				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l40;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = positive32BitValueOf(integerReceiver);
				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 1))) >= 0) {

						/* Left shift -- must fail bits would be lost */
						if (!(integerArgument <= 0x1F /* numSmallIntegerBits */)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l40;
						}
						shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
						if (!(integerReceiver == (((usqInt)(shifted)) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l40;
						}
					}
					else {

						/* Right shift -- OK to lose bits */
						if (!(integerArgument >= (-0x1F /* numSmallIntegerBits */))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l40;
						}
						shifted = ((usqInt)(integerReceiver)) >> (0 - integerArgument);
					}
					integerValue = shifted;

					/* begin positive32BitIntegerFor: */
					/* begin maybeInlinePositive32BitIntegerFor: */
					assert(!((hasSixtyFourBitImmediates())));
					if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
						shifted = ((integerValue << 1) | 1);
						goto l39;
					}
					newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

					/* storeLong32:ofObject:withValue: */
					long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
					shifted = newLargeInteger;
l39:	/* end positive32BitIntegerFor: */;

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
l40:	/* end primitiveBitShift */;

				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l38;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (24U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l38:	/* end case */;
			break;
		case 189: // bytecodePrimDiv
			{
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += 1 * BytesPerOop), (((usqInt)quotient << 1) | 1));
					currentBytecode = byteAtPointer(++localIP);
					goto l41;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (26U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l41:	/* end case */;
			break;
		case 190: // bytecodePrimBitAnd
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += 1 * BytesPerOop), arg & rcvr);
					currentBytecode = byteAtPointer(++localIP);
					goto l42;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();

				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l42;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (28U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l42:	/* end case */;
			break;
		case 191: // bytecodePrimBitOr
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += 1 * BytesPerOop), arg | rcvr);
					currentBytecode = byteAtPointer(++localIP);
					goto l43;
				}

				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();

				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l43;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (30U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l43:	/* end case */;
			break;
		case 192: // bytecodePrimAt
			{
				usqInt atIx;
				usqInt ccIndex;
				sqInt class;
				sqInt classFormat;
				sqInt fixedFields;
				usqInt fmt;
				sqInt fmtSqInt;
				sqInt hdr;
				sqInt index;
				unsigned int integerValue;
				sqInt newLargeInteger;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				int resultInt;
				sqInt stSize;
				unsigned int sz;
				sqInt totalLength;

				VM_LABEL(bytecodePrimAt);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & 1) == 0)
				 && ((index & 1))) {
					/* Index into atCache = 4N, for N = 0 ... 7 */
					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						lkupClassTag = /* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
								((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (32U << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l44;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = longAt(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;
							if ((fmt == (indexablePointersFormat()))
							 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l53;
							}

							/* begin lengthOf:baseHeader:format: */
							if (hdr & TypeMask) {
								sz = hdr & SizeMask;
							}
							else {
								sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
							}
							sz -= 0;
							if (fmt <= 4 /* lastPointerFormat */) {
								totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
								goto l46;
							}
							totalLength = (fmt < (firstByteFormat())
										? ((usqInt)((sz - BaseHeaderSize))) >> 2
										: (sz - BaseHeaderSize) - (fmt & 3));
l46:	/* end lengthOf:baseHeader:format: */;

							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 4 /* lastPointerFormat */)
							 || (fmt == (arrayFormat()))) {
								fixedFields = 0;
								goto l49;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l49;
							}
							class = /* fetchClassOfNonImm: */
									((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
										? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
										: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
							classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
							fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l49:	/* end fixedFieldsOf:format:length: */;
							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
l53:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr = longAt(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

								/* begin lengthOf:baseHeader:format: */
								if (hdr & TypeMask) {
									sz = hdr & SizeMask;
								}
								else {
									sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
								}
								sz -= 0;
								if (fmt <= 4 /* lastPointerFormat */) {
									totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
									goto l50;
								}
								totalLength = (fmt < (firstByteFormat())
											? ((usqInt)((sz - BaseHeaderSize))) >> 2
											: (sz - BaseHeaderSize) - (fmt & 3));
l50:	/* end lengthOf:baseHeader:format: */;
								fixedFields = 0;

								/* special flag for strings */
								fmt += 16 /* firstStringyFakeFormat */;
								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
l48:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l44;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo((index >> 1), 1))
						 && (oopisLessThanOrEqualTo((index >> 1), stSize))) {
							fmtSqInt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmtSqInt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(((((index >> 1)) + fixedFields) - 1)) << (shiftForWord())))));
								goto l51;
							}
							if (fmtSqInt < (firstByteFormat())) {

								/* 64, 32, & 16 bits */
								resultInt = long32At((rcvr + BaseHeaderSize) + ((((usqInt)((((index >> 1)) - 1)) << 2))));
								integerValue = resultInt;

								/* begin positive32BitIntegerFor: */
								/* begin maybeInlinePositive32BitIntegerFor: */
								assert(!((hasSixtyFourBitImmediates())));
								if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
									result = ((integerValue << 1) | 1);
									goto l51;
								}
								newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

								/* storeLong32:ofObject:withValue: */
								long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
								result = newLargeInteger;
								goto l51;
							}
							if (fmtSqInt >= 16 /* firstStringyFakeFormat */) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString and DoubleByteString */
								resultInt = byteAt((rcvr + BaseHeaderSize) + (((index >> 1)) - 1));
								result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CharacterTable) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(resultInt) << (shiftForWord())))));
								goto l51;
							}
							else {
								if ((fmtSqInt < (firstCompiledMethodFormat()))
								 || (((index >> 1)) >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (((index >> 1)) - 1))) << 1) | 1);
									goto l51;
								}
							}
						}
						reasonCode = (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) >= 2
									? PrimErrBadIndex
									: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
l51:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						longAtPointerput((localSP += 1 * BytesPerOop), result);
						goto l44;
					}

					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (32U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
l44:	/* end case */;
			break;
		case 193: // bytecodePrimAtPut
			{
				usqInt atIx;
				usqInt ccIndex;
				sqInt class;
				sqInt classFormat;
				sqInt classOop;
				sqInt correctRcvr;
				sqInt fixedFields;
				usqInt fmt;
				sqInt fmtSqInt;
				sqInt hdr;
				sqInt index;
				sqInt isCharacter;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				unsigned int sz;
				sqInt totalLength;
				int valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
#        if IMMUTABILITY
				correctRcvr = /* isOopMutable: */
						(!((rcvr & 1)))
					 && (!(
#          if IMMUTABILITY
						((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#          else
						0
#          endif
						));
#        else // IMMUTABILITY
				correctRcvr = (rcvr & 1) == 0;
#        endif

				if (correctRcvr
				 && ((index & 1))) {
					/* Index into atPutCache */
					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						lkupClassTag = /* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
								((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (34U << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l54;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = longAt(rcvr);

							/* For now the AtCache code doesn't support 16-bit indexability. */
							fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;
							if ((fmt == (indexablePointersFormat()))
							 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */
								/* primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadReceiver;
								goto l64;
							}

							/* begin lengthOf:baseHeader:format: */
							if (hdr & TypeMask) {
								sz = hdr & SizeMask;
							}
							else {
								sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
							}
							sz -= 0;
							if (fmt <= 4 /* lastPointerFormat */) {
								totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
								goto l56;
							}
							totalLength = (fmt < (firstByteFormat())
										? ((usqInt)((sz - BaseHeaderSize))) >> 2
										: (sz - BaseHeaderSize) - (fmt & 3));
l56:	/* end lengthOf:baseHeader:format: */;

							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 4 /* lastPointerFormat */)
							 || (fmt == (arrayFormat()))) {
								fixedFields = 0;
								goto l59;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l59;
							}
							class = /* fetchClassOfNonImm: */
									((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
										? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
										: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
							classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
							fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l59:	/* end fixedFieldsOf:format:length: */;
							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
l64:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr = longAt(rcvr);

								/* For now the AtCache code doesn't support 16-bit indexability. */
								fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

								/* begin lengthOf:baseHeader:format: */
								if (hdr & TypeMask) {
									sz = hdr & SizeMask;
								}
								else {
									sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
								}
								sz -= 0;
								if (fmt <= 4 /* lastPointerFormat */) {
									totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
									goto l61;
								}
								totalLength = (fmt < (firstByteFormat())
											? ((usqInt)((sz - BaseHeaderSize))) >> 2
											: (sz - BaseHeaderSize) - (fmt & 3));
l61:	/* end lengthOf:baseHeader:format: */;
								fixedFields = 0;

								/* special flag for strings */
								fmt += 16 /* firstStringyFakeFormat */;
								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
l58:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l54;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo((index >> 1), 1))
						 && (oopisLessThanOrEqualTo((index >> 1), stSize))) {
							fmtSqInt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmtSqInt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];

								/* begin storePointer:ofObject:withValue: */
								if (oopisLessThan(rcvr, GIV(youngStart))) {
									possibleRootStoreIntovalue(rcvr, value);
								}
								((void) (longAtput((rcvr + BaseHeaderSize) + ((((usqInt)(((((index >> 1)) + fixedFields) - 1)) << (shiftForWord())))), value)));
								goto l60;
							}
							if (fmtSqInt < (firstByteFormat())) {

								/* 64, 32, & 16 bits */
								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									/* storeLong32:ofObject:withValue: */
									long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)((((index >> 1)) - 1)) << 2))), valToPut);
									goto l60;
								}

								/* primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l60;
							}
							if (fmtSqInt >= 16 /* firstStringyFakeFormat */) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* begin isCharacterObject: */
								classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));
								if ((value & 1)) {
									isCharacter = 0;
									goto l62;
								}

								/* begin isClassOfNonImm:equalTo:compactClassIndex: */
								assert(!((value & 1)));
								ccIndex = (((usqInt)((longAt(value)))) >> (compactClassFieldLSB())) & 0x1F;
								if (!ccIndex) {
									isCharacter = ((longAt(value - BaseHeaderSize)) & AllButTypeMask) == classOop;
									goto l62;
								}
								isCharacter = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l62:	/* end isCharacterObject: */;
								if (!isCharacter) {
									/* primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadArgument;
									goto l60;
								}
								valToPut = longAt((value + BaseHeaderSize) + ((((usqInt)(CharacterValueIndex) << (shiftForWord())))));
								valToPut = ((valToPut & 1)
											? (valToPut >> 1)
											: -1);
							}
							else {
								if ((fmtSqInt >= (firstCompiledMethodFormat()))
								 && (((index >> 1)) < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									/* primitiveFailFor: */
									GIV(primFailCode) = PrimErrBadIndex;
									goto l60;
								}
								valToPut = ((value & 1)
											? (value >> 1)
											: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								/* primitiveFailFor: */
								GIV(primFailCode) = PrimErrBadArgument;
								goto l60;
							}

							/* storeByte:ofObject:withValue: */
							byteAtput((rcvr + BaseHeaderSize) + (((index >> 1)) - 1), valToPut);
							goto l60;
						}
						reasonCode = (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) >= 2
									? PrimErrBadIndex
									: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
l60:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						longAtPointerput((localSP += 2 * BytesPerOop), value);
						goto l54;
					}

					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (34U << (shiftForWord())));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
l54:	/* end case */;
			break;
		case 194: // bytecodePrimSize
			{
				usqInt ccIndex;
				sqInt classOop;
				sqInt fmt;
				sqInt header;
				sqInt isArray;
				sqInt isString;
				sqInt rcvr;
				sqInt sz;
				unsigned int sz1;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */
				rcvr = longAtPointer(localSP);
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isString = 0;
					goto l66;
				}

				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
				if (!ccIndex) {
					isString = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l66;
				}
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l66;
				isString = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l66:	/* end isInstanceOfClassByteString: */;
				if (isString) {
					/* begin lengthOf: */
					header = longAt(rcvr);
					fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

					/* begin lengthOf:baseHeader:format: */
					if (header & TypeMask) {
						sz1 = header & SizeMask;
					}
					else {
						sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					sz1 -= 0;
					if (fmt <= 4 /* lastPointerFormat */) {
						sz = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
						goto l67;
					}
					sz = (fmt < (firstByteFormat())
								? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
								: (sz1 - BaseHeaderSize) - (fmt & 3));
l67:	/* end lengthOf: */;

					/* internalStackTopPut: */
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l65;
				}

				/* begin isInstanceOfClassArray: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isArray = 0;
					goto l68;
				}

				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
				if (!ccIndex) {
					isArray = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l68;
				}
				isArray = ClassArrayCompactIndex == ccIndex;
				goto l68;
				isArray = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l68:	/* end isInstanceOfClassArray: */;
				if (isArray) {
					/* begin lengthOf: */
					header = longAt(rcvr);
					fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

					/* begin lengthOf:baseHeader:format: */
					if (header & TypeMask) {
						sz1 = header & SizeMask;
					}
					else {
						sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
					}
					sz1 -= 0;
					if (fmt <= 4 /* lastPointerFormat */) {
						sz = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
						goto l69;
					}
					sz = (fmt < (firstByteFormat())
								? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
								: (sz1 - BaseHeaderSize) - (fmt & 3));
l69:	/* end lengthOf: */;

					/* internalStackTopPut: */
					longAtPointerput(localSP, (((usqInt)sz << 1) | 1));

					/* begin fetchNextBytecode */
					currentBytecode = byteAtPointer(++localIP);
					goto l65;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (36U << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
l65:	/* end case */;
			break;
		case 195: // bytecodePrimNext
			{
				VM_LABEL(bytecodePrimNext);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (38U << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject(39, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 196: // bytecodePrimNextPut
			{
				VM_LABEL(bytecodePrimNextPut);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (40U << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject(41, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 197: // bytecodePrimAtEnd
			{
				VM_LABEL(bytecodePrimAtEnd);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (42U << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject(43, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 198: // bytecodePrimIdentical
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);

				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 199: // bytecodePrimClass
			{
				usqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				longAtPointerput(localSP, /* fetchClassOf: */
					((rcvr & 1)
						? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
						: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
								? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
								: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)));

				/* begin fetchNextBytecode */
				currentBytecode = byteAtPointer(++localIP);
			}
			break;
		case 200: // bytecodePrimNotIdentical
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimNotIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP);

				/* begin booleanCheat: */
				if (rcvr != arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 201: // bytecodePrimValue
			{
				usqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;

				/* begin isInstanceOfClassBlockClosure: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l71;
				}

				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
				if (!ccIndex) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l71;
				}
				isBlock = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l71:	/* end isInstanceOfClassBlockClosure: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;

					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l70;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (50U << (shiftForWord())));
				goto normalSend;
			}
l70:	/* end case */;
			break;
		case 202: // bytecodePrimValueWithArg
			{
				usqInt ccIndex;
				sqInt classOop;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;

				/* begin isInstanceOfClassBlockClosure: */
				classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassBlockClosure) << (shiftForWord())))));
				if ((rcvr & 1)) {
					isBlock = 0;
					goto l73;
				}

				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!((rcvr & 1)));
				ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F;
				if (!ccIndex) {
					isBlock = ((longAt(rcvr - BaseHeaderSize)) & AllButTypeMask) == classOop;
					goto l73;
				}
				isBlock = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l73:	/* end isInstanceOfClassBlockClosure: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;

					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l72;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (52U << (shiftForWord())));
				goto normalSend;
			}
l72:	/* end case */;
			break;
		case 203: // bytecodePrimDo
			{
				VM_LABEL(bytecodePrimDo);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (54U << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject(55, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord()))))))) >> 1);
				goto normalSend;
			}
			break;
		case 204: // bytecodePrimNew
			{
				VM_LABEL(bytecodePrimNew);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (56U << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 205: // bytecodePrimNewWithArg
			{
				VM_LABEL(bytecodePrimNewWithArg);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (58U << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 206: // bytecodePrimPointX
			{
				usqInt ccIndex;
				unsigned int cl;
				int ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				if (!(rcvr & 1)) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					cl = ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
								? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
								: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))));
					if (ok) {
						longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + ((((usqInt)(XIndex) << (shiftForWord()))))));

						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l74;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (60U << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
l74:	/* end case */;
			break;
		case 207: // bytecodePrimPointY
			{
				usqInt ccIndex;
				unsigned int cl;
				int ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				if (!(rcvr & 1)) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					cl = ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
								? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
								: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
					ok = cl == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))));
					if (ok) {
						longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + ((((usqInt)(YIndex) << (shiftForWord()))))));

						/* begin fetchNextBytecode */
						currentBytecode = byteAtPointer(++localIP);
						goto l75;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (0x3EU << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
l75:	/* end case */;
			break;
		case 208: // sendLiteralSelector0ArgsBytecode
		case 209: // sendLiteralSelector0ArgsBytecode
		case 210: // sendLiteralSelector0ArgsBytecode
		case 211: // sendLiteralSelector0ArgsBytecode
		case 212: // sendLiteralSelector0ArgsBytecode
		case 213: // sendLiteralSelector0ArgsBytecode
		case 214: // sendLiteralSelector0ArgsBytecode
		case 215: // sendLiteralSelector0ArgsBytecode
		case 216: // sendLiteralSelector0ArgsBytecode
		case 217: // sendLiteralSelector0ArgsBytecode
		case 218: // sendLiteralSelector0ArgsBytecode
		case 219: // sendLiteralSelector0ArgsBytecode
		case 220: // sendLiteralSelector0ArgsBytecode
		case 221: // sendLiteralSelector0ArgsBytecode
		case 222: // sendLiteralSelector0ArgsBytecode
		case 223: // sendLiteralSelector0ArgsBytecode
			{
				usqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((currentBytecode & 15) + LiteralStart) << (shiftForWord()))));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP);
				lkupClassTag = /* #fetchClassTagOf: #fetchClassOf: */
						((rcvr & 1)
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
							: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask));
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 224: // sendLiteralSelector1ArgBytecode
		case 225: // sendLiteralSelector1ArgBytecode
		case 226: // sendLiteralSelector1ArgBytecode
		case 227: // sendLiteralSelector1ArgBytecode
		case 228: // sendLiteralSelector1ArgBytecode
		case 229: // sendLiteralSelector1ArgBytecode
		case 230: // sendLiteralSelector1ArgBytecode
		case 231: // sendLiteralSelector1ArgBytecode
		case 232: // sendLiteralSelector1ArgBytecode
		case 233: // sendLiteralSelector1ArgBytecode
		case 234: // sendLiteralSelector1ArgBytecode
		case 235: // sendLiteralSelector1ArgBytecode
		case 236: // sendLiteralSelector1ArgBytecode
		case 237: // sendLiteralSelector1ArgBytecode
		case 238: // sendLiteralSelector1ArgBytecode
		case 239: // sendLiteralSelector1ArgBytecode
			{
				usqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((currentBytecode & 15) + LiteralStart) << (shiftForWord()))));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				lkupClassTag = /* #fetchClassTagOf: #fetchClassOf: */
						((rcvr & 1)
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
							: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask));
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 240: // sendLiteralSelector2ArgsBytecode
		case 241: // sendLiteralSelector2ArgsBytecode
		case 242: // sendLiteralSelector2ArgsBytecode
		case 243: // sendLiteralSelector2ArgsBytecode
		case 244: // sendLiteralSelector2ArgsBytecode
		case 245: // sendLiteralSelector2ArgsBytecode
		case 246: // sendLiteralSelector2ArgsBytecode
		case 247: // sendLiteralSelector2ArgsBytecode
		case 248: // sendLiteralSelector2ArgsBytecode
		case 249: // sendLiteralSelector2ArgsBytecode
		case 250: // sendLiteralSelector2ArgsBytecode
		case 251: // sendLiteralSelector2ArgsBytecode
		case 252: // sendLiteralSelector2ArgsBytecode
		case 253: // sendLiteralSelector2ArgsBytecode
		case 254: // sendLiteralSelector2ArgsBytecode
		case 255: // sendLiteralSelector2ArgsBytecode
			{
				usqInt ccIndex;
				sqInt rcvr;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((currentBytecode & 15) + LiteralStart) << (shiftForWord()))));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				lkupClassTag = /* #fetchClassTagOf: #fetchClassOf: */
						((rcvr & 1)
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
							: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask));
				assert(lkupClassTag != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		}
	}

	/* undo the pre-increment of IP (in fetchByte in fetchNextBytecode) before returning */
	localIP -= 1;

	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static NoDbgRegParms sqInt
addressIsInPage(StackPage *self_in_CogStackPage, char *address)
{
	return (((self_in_CogStackPage->lastAddress)) < address)
	 && (address < ((self_in_CogStackPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static NoDbgRegParms int
isFree(StackPage *self_in_CogStackPage)
{
	return ((self_in_CogStackPage->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static NoDbgRegParms sqInt
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;
    StackPage *self_in_CogStackPage;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return null;
	}
	self_in_CogStackPage = (prev = (aPage->prevPage));
	if (!((self_in_CogStackPage->baseFP))) {
		return null;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
	return 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static NoDbgRegParms void
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static NoDbgRegParms sqInt
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return null;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return null;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
	return 0;
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static NoDbgRegParms sqInt
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return null;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
	return 0;
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (!((lruOrFree->baseFP))) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static NoDbgRegParms StackPage *
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static NoDbgRegParms StackPage *
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statNumMaps)
			? (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps)
			: 0.0);
}


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    char *cString;
    sqInt fmt;
    sqInt header;
    sqInt isString;
    sqInt len;
    unsigned int sz;

	/* begin isInstanceOfClassByteString: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord())))));
	if ((oop & 1)) {
		isString = 0;
		goto l2;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isString = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;
	isString = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l2:	/* end isInstanceOfClassByteString: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}

	/* begin lengthOf: */
	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		len = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	len = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf: */;
	if (!len) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!cString) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer the identity hash of an object, assigning a hash if it doesn't have
	one. On Spur refuse to assign a hash to something that looks like a
	behavior. 
 */

	/* InterpreterPrimitives>>#identityHashOf: */
sqInt
identityHashOf(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isCharacterObjectRV;

	if ((anOop & 1)) {
		/* begin immediateAsInteger:ifFail: */
		if ((anOop & 1)) {
			return (anOop >> 1);
		}

		/* begin isCharacterObject: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));
		if ((anOop & 1)) {
			isCharacterObjectRV = 0;
			goto l2;
		}

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((anOop & 1)));
		ccIndex = (((usqInt)((longAt(anOop)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			isCharacterObjectRV = ((longAt(anOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		isCharacterObjectRV = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l2:	/* end isCharacterObject: */;
		if (isCharacterObjectRV) {
			/* begin characterValueOf: */
			/* begin isCharacterObject: */
			classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));
			if ((anOop & 1)) {
				isCharacterObjectRV = 0;
				goto l1;
			}

			/* begin isClassOfNonImm:equalTo:compactClassIndex: */
			assert(!((anOop & 1)));
			ccIndex = (((usqInt)((longAt(anOop)))) >> (compactClassFieldLSB())) & 0x1F;
			if (!ccIndex) {
				isCharacterObjectRV = ((longAt(anOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
				goto l1;
			}
			isCharacterObjectRV = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isCharacterObject: */;
			if (!isCharacterObjectRV) {
				/* primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				return -1;
			}
			return ((longAt((anOop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 1);
		}
		return -1;
	}
	return (((usqInt)((longAt(anOop)))) >> HashBitsOffset) & HashMaskUnshifted;
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static NoDbgRegParms sqInt
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt smallInt;

	if ((oop & 1)) {
		smallInt = (oop >> 1);
		return smallInt < 0;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 0;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
	goto l2;
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 1;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Answer if oop is a value of an integer in address range, i.e up to the
	size of a machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

	/* InterpreterPrimitives>>#isPositiveMachineIntegerObject: */
sqInt
isPositiveMachineIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    int ok;

	if ((oop & 1)) {
		return ((oop >> 1)) >= 0;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	return ok
	 && ((numBytesOfBytes(oop)) <= (sizeof(usqIntptr_t)));
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static NoDbgRegParms sqInt
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    usqInt header1;
    usqInt highWord;
    int isSmall;
    int largeClassIndex;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newLargeInteger;
    sqInt objFormat;
    unsigned int sizeInBytes;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
				? magnitude <= ((MaxSmallInteger) + 1)
				: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return (((usqInt)smallVal << 1) | 1);
	}
	largeClassIndex = (isNegative
				? ClassLargeNegativeIntegerCompactIndex
				: ClassLargePositiveIntegerCompactIndex);
	if ((highWord = (magnitude) >> 32)) {
		sz = 5;
		if ((highWord = (highWord) >> 8)) {
			sz += 1;
			if ((highWord = (highWord) >> 8)) {
				sz += 1;
				if ((highWord = (highWord) >> 8)) {
					sz += 1;
				}
			}
		}
	}
	else {
		sz = 4;
	}
	objFormat = (firstByteFormat()) + ((4 - sz) & 3);

	/* begin eeInstantiateSmallClassIndex:format:numBytes: */
	assert((sz >= 0)
	 && (largeClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
			? objFormat
			: objFormat & (byteFormatMask()))) == (instSpecOfClass(compactClassAt(largeClassIndex))));
	sizeInBytes = ((sz + (BytesPerWord - 1)) & LongSizeMask) + BaseHeaderSize;
	assert(sizeInBytes <= 0xFC);
	hash = (GIV(freeStart)) >> (shiftForWord());
	header1 = (((((usqInt)(objFormat) << (instFormatFieldLSB())))) | ((((usqInt)(largeClassIndex) << 12)))) | (((hash & HashMaskUnshifted) << HashBitsOffset));
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));

	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes);
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newLargeInteger = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newLargeInteger = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newLargeInteger = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newLargeInteger = null;
l1:	/* end allocateInterpreterChunk: */;
	if (!newLargeInteger) {
		goto l2;
	}
	longAtput(newLargeInteger, header1 | HeaderTypeShort);
l2:	/* end eeInstantiateSmallClassIndex:format:numBytes: */;
	if (sz > 4) {
		/* begin storeLong64:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude));
		long32Atput(((newLargeInteger + BaseHeaderSize)) + 4, ((SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude))) >> 32);
		SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude);
	}
	else {
		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude));
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or up to an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static NoDbgRegParms usqLong
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt smallIntValue;
    sqInt sz;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return smallIntValue;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}


/*	Convert the given object into an integer value.
	The object may be a four-byte LargeInteger. */

	/* InterpreterPrimitives>>#noInlineSigned32BitValueGutsOf: */
static NoDbgRegParms int
noInlineSigned32BitValueGutsOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    unsigned int magnitude;
    sqInt negative;
    int ok;
    int value;

	assert(!((hasSixtyFourBitImmediates())));
	assert(!(((oop & 1))));
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	if ((numBytesOfBytes(oop)) > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	if ((negative
			? magnitude > 0x80000000U
			: magnitude >= 0x80000000U)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive32BitValueOf: */
unsigned int
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt sz;
    sqInt value;

	/* begin maybeInlinePositive32BitValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	sz = numBytesOfBytes(oop);
	if (sz > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or up to an eight-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt smallIntValue;
    sqInt sz;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return smallIntValue;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	sz = numBytesOfBytes(oop);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (sz > 4) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
usqIntptr_t
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));

	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ (((((usqInt)integerResult)) << 1))))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((arg & 1))
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & 1))
	 || (!(objCouldBeClassObj(rcvr)))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	err = changeClassOfto(arg, rcvr);
	if (err) {

		/* changeClassOf:to: answers errors as if rcvr (the class) is an argument... */
		if (err == PrimErrBadReceiver) {
			err = PrimErrBadArgument;
		}
		else {
			if (err == PrimErrBadArgument) {
				err = PrimErrBadReceiver;
			}
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = err;
	}
	else {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt deltaSqInt;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt result;
    char *sp;

	result = allInstancesOf(longAt(GIV(stackPointer)));
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = ((((headerTypeBytes[HeaderTypeSizeAndClass]) / BytesPerWord) + 1) + ((result >> 1))) * BytesPerOop;
		deltaSqInt = ((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom));

		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), deltaSqInt);
		if (!(limit == GIV(memoryLimit))) {
			newMemoryLimit = limit - 24;

			/* begin setMemoryLimit: */
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		result = allInstancesOf(longAt(GIV(stackPointer)));
		if ((result & 1)) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt deltaSqInt;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt result;
    char *sp;

	result = allObjects();
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = ((((headerTypeBytes[HeaderTypeSizeAndClass]) / BytesPerWord) + 1) + ((result >> 1))) * BytesPerOop;
		deltaSqInt = ((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom));

		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), deltaSqInt);
		if (!(limit == GIV(memoryLimit))) {
			newMemoryLimit = limit - 24;

			/* begin setMemoryLimit: */
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		result = allObjects();
		if ((result & 1)) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Computes arctan of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	aValue = floatObjectOf(atan(doubleValue));

	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Invoke the two-way become primitive.
	We must at least flush the method cache here, to eliminate stale
	references to mutated classes and/or selectors.
	
	If in the CoInterpreter, we must deal with jitted methods being becommed.
	In the conception of the abstract VM,
	unless a CompiledMethod is becommed to one with equivalent bytecode
	contexts referring to the becommed
	method will likely fetch invalid bytecodes on resumption. The
	responsibility for validity here lies with the user of
	the become primitive, not the VM. So one could imagine checking for
	methods becomming equivalent methods
	and updating Cog methods to refer to their becommed duals. But that
	requires machinery to compare two
	compiled methods to check if their code is equivalent. A much simpler
	approach, which also gets the VM to fail
	in a less confusing place if it is going to fail because the programmer
	has not ensured compiled code validity
	across become, is to simply divorce all frames and map context pcs back to
	bytecode pcs when becomming
	jitted methods. However, mapping native pcs in contexts whose methods are
	flagged for become will not ensure
	that pcs are mapped reliably. Consider this arc: a context on a method
	that has been jitted exists with a native pc.
	The method is unjitted to make room for other methods to be jitted. The
	method is becommed. So the scan is only
	effective for methods in the jit. Slowing down become so that a rare case
	may fail more comprehensibly, when its
	going to fail anyway, is a waste of effort. So we do divorce frames (since
	machine code frames refer to CogMethods,
	not methods), but don't scan the entire heap looking for native pcs in
	contexts. Hence the primitive must be
	prepared to have its calling frame divorced. We store the context for the
	top frame in activeProcess.
	BTW, as of late '22/early '23 this is only done for Spur.
	See preBecomeAction: and postBecomeAction: */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0);

	/* begin primitiveBecomeReturn: */
	if (ec) {
		/* primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
	else {
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Invoke the one-way become primitive.
	See the comment in primitiveArrayBecome for handling pervasive effects on
	method cacheing and jitting. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);

	/* begin primitiveBecomeReturn: */
	if (ec) {
		/* primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
	else {
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's elements identity hashes over the argument's elements
	identity hashes.
	See the comment in primitiveArrayBecome for handling pervasive effects on
	method cacheing and jitting.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHashArg */
static void
primitiveArrayBecomeOneWayCopyHashArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag);

	/* begin primitiveBecomeReturn: */
	if (ec) {
		/* primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
	else {
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but does /not/ copy the receiver's
	elements identity hashes over the argument's elements identity hashes.
	See the comment in primitiveArrayBecome for handling pervasive effects on
	method cacheing and jitting. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayNoCopyHash */
static void
primitiveArrayBecomeOneWayNoCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 0);

	/* begin primitiveBecomeReturn: */
	if (ec) {
		/* primitiveFailFor: */
		GIV(primFailCode) = ec;
	}
	else {
		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((characterCode & 1))
		 && (((characterCode = (characterCode >> 1)),
		/* isInRangeCharacterCode: */
			((characterCode >= 0) && (characterCode <= 0xFF)))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = (GIV(argumentCount)
					? PrimErrBadArgument
					: PrimErrBadReceiver);
		return;
	}
	characterObject = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CharacterTable) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(characterCode) << (shiftForWord())))));

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((rcvr & 1));

	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer)), floatObjectOf(((double) ((rcvr >> 1)) )));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt stSize;
    unsigned int sz;
    sqInt totalLength;

	/* begin commonAt: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l5;
	}
	if (((index & 1) == 0)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l5;
	}
	index = (index >> 1);

	/* begin stObject:at: */
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(rcvr)));
			stSize = spUsqInt;
			goto l3;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l3;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(rcvr)));
		stSize = (spSqInt >> 1);
l3:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = temporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l4;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
		(fmt >= (firstCompiledMethodFormat())
			? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			result = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l4;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l4;
		}
		integerValue = long32At((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l4;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		result = newLargeInteger;
		goto l4;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = (fmt <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
	result = 0;
l4:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l5:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt stSize;
    unsigned int sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;
    sqInt value;

	/* begin commonAtPut: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l11;
	}
	if (((index & 1) == 0)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l11;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l11;
	}
	index = (index >> 1);

	/* begin stObject:at:put: */
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l7;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l7:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l6;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l6;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l6:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(rcvr)));
			stSize = spUsqInt;
			goto l8;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l8;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(rcvr)));
		stSize = (spSqInt >> 1);
l8:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			temporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l10;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
		(fmt >= (firstCompiledMethodFormat())
			? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, value);
			}
			longAtput((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l9;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l9;
			}
			signedValueToStore = (value >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l9;
			}

			/* storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l9;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
l9:	/* end subscript:with:storing:format: */;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = (fmt <= 1
					? PrimErrBadReceiver
					: PrimErrBadIndex);
	}
l10:	/* end stObject:at:put: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l11:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (!GIV(argumentCount)) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}

	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		successBoolean = (/* isPointers: */
				((cursorObj & 1) == 0)
			 && (((((usqInt)((longAt(cursorObj)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			 && ((lengthOf(cursorObj)) >= 5);

		/* begin success: */
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0U << (shiftForWord())));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4U << (shiftForWord())));
		successBoolean = (/* isPointers: */
				((offsetObj & 1) == 0)
			 && (((((usqInt)((longAt(offsetObj)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			 && ((lengthOf(offsetObj)) >= 2);

		/* begin success: */
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */
			successBoolean = (extentX > 0)
				 && (extentY > 0);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (offsetX >= (extentX * -1))
				 && (offsetX <= 0);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (offsetY >= (extentY * -1))
				 && (offsetY <= 0);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (/* isWords: */
					((bitsObj & 1) == 0)
				 && (((((usqInt)((longAt(bitsObj)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
				 && ((lengthOf(bitsObj)) == (extentX * extentY));

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
		else {
			successBoolean = (extentX == 16)
				 && ((extentY == 16)
				 && (depth == 1));

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (offsetX >= -16)
				 && (offsetX <= 0);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (offsetY >= -16)
				 && (offsetY <= 0);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (/* isWords: */
					((bitsObj & 1) == 0)
				 && (((((usqInt)((longAt(bitsObj)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
				 && ((lengthOf(bitsObj)) == 16);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (GIV(argumentCount) == 1) {
		successBoolean = (/* isPointers: */
				((maskObj & 1) == 0)
			 && (((((usqInt)((longAt(maskObj)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			 && ((lengthOf(maskObj)) >= 5);

		/* begin success: */
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0U << (shiftForWord())));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			successBoolean = (extentX == 16)
				 && ((extentY == 16)
				 && (depth == 1));

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			successBoolean = (/* isWords: */
					((bitsObj & 1) == 0)
				 && (((((usqInt)((longAt(bitsObj)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))
				 && ((lengthOf(bitsObj)) == 16);

			/* begin success: */
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount)) {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		else {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}

		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable,
	and if possible pin the display bitmap. Further, invoke ioBeDisplay
	to alow the VM to record the location, width heigth & depth of the bitmap. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsOop;
    void *bitsOrHandle;
    sqInt depthOop;
    sqInt heightOop;
    sqInt rcvr;
    sqInt widthOop;

	rcvr = longAt(GIV(stackPointer));
	if (!((/* isPointers: */
			((rcvr & 1) == 0)
		 && (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && (((lengthOf(rcvr)) >= 4)
		 && (((bitsOop = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())))),
		((/* isWordsOrBytes: */
				((bitsOop & 1) == 0)
			 && (isWordsOrBytesNonImm(bitsOop)))
			 || ((bitsOop & 1)))
			 && (((((widthOop = longAt((rcvr + BaseHeaderSize) + (1U << (shiftForWord()))))) & 1))
			 && (((((heightOop = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord()))))) & 1))
			 && ((((depthOop = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord()))))) & 1))))))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}

	/* begin splObj:put: */
	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(specialObjectsOop), rcvr);
	}
	longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheDisplay) << (shiftForWord())))), rcvr);
	bitsOrHandle = (bitsOop & 1
				? ((void *)bitsOop)
				: firstIndexableField(bitsOop));

	/* begin ioBeDisplay:width:height:depth: */
	displayBits = bitsOrHandle;
	displayWidth = (widthOop >> 1);
	displayHeight = (heightOop >> 1);
	displayDepth = (depthOop >> 1);
	ioNoteDisplayChangedwidthheightdepth(bitsOrHandle, (widthOop >> 1), (heightOop >> 1), (depthOop >> 1));
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(void)
{
	ioBeep();
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hashOrError;
    char *sp;

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	hashOrError = (((usqInt)((longAt(longAt(GIV(stackPointer)))))) >> HashBitsOffset) & HashMaskUnshifted;
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)hashOrError << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = -hashOrError;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    int ok;
    sqInt oop;
    char *sp;
    sqInt value;

	oop = longAt(GIV(stackPointer));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l2;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l2;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l2;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l2;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l2;
	}
	integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))))));
l2:	/* end positiveMachineIntegerValueOf: */;
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l4;
		}
		integerReceiverValue = ((usqIntptr_t) value);
		goto l4;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l3;
l3:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l4;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l4;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l4;
	}
	integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))))));
l4:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		oop = positiveMachineIntegerFor(integerArgumentValue & integerReceiverValue);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Note no short-cut for SmallIntegers. Either the inline interpreter
	bytecode or the JIT primitive will handle this case. */

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    usqInt integerArgumentValue;
    usqInt integerReceiverValue;
    int ok;
    sqInt oop;
    char *sp;
    sqInt value;

	oop = longAt(GIV(stackPointer));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = ((usqIntptr_t) null);
			goto l2;
		}
		integerArgumentValue = ((usqIntptr_t) value);
		goto l2;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l2;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgumentValue = 0;
		goto l2;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l2;
	}
	integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))))));
l2:	/* end positiveMachineIntegerValueOf: */;
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = ((usqIntptr_t) null);
			goto l4;
		}
		integerReceiverValue = ((usqIntptr_t) value);
		goto l4;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l3;
l3:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l4;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiverValue = 0;
		goto l4;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l4;
	}
	integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))))));
l4:	/* end positiveMachineIntegerValueOf: */;
	if (!GIV(primFailCode)) {
		oop = positiveMachineIntegerFor(integerArgumentValue | integerReceiverValue);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt shifted;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	if (!((integerArgument & 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = positive32BitValueOf(integerReceiver);
	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 1))) >= 0) {

			/* Left shift -- must fail bits would be lost */
			if (!(integerArgument <= 0x1F /* numSmallIntegerBits */)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((sqInt)((usqInt)(integerReceiver) << integerArgument));
			if (!(integerReceiver == (((usqInt)(shifted)) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {

			/* Right shift -- OK to lose bits */
			if (!(integerArgument >= (-0x1F /* numSmallIntegerBits */))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((usqInt)(integerReceiver)) >> (0 - integerArgument);
		}
		integerValue = shifted;

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			shifted = ((integerValue << 1) | 1);
			goto l1;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		shifted = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		shift = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
	}
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */
		/* This is to avoid undue (usqInt) cast */
		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > ((result) >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = (a << shift);
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = (a) >> shift;
		}
		if (aIsNegative
		 && (((result << shift)) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    sqInt integerArgument;
    usqInt integerArgumentValue;
    sqInt integerReceiver;
    usqInt integerReceiverValue;
    int ok;
    sqInt oop;
    char *sp;
    sqInt value;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerArgument & 1))
	 && ((integerReceiver & 1))) {

		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (integerArgument ^ integerReceiver) + 1 /* smallIntegerTag */);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin positiveMachineIntegerValueOf: */
		if ((integerArgument & 1)) {
			value = (integerArgument >> 1);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerArgumentValue = ((usqIntptr_t) null);
				goto l2;
			}
			integerArgumentValue = ((usqIntptr_t) value);
			goto l2;
		}
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((integerArgument & 1)));
		ccIndex = (((usqInt)((longAt(integerArgument)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(integerArgument - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l1;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l2;
		}
		bs = numBytesOfBytes(integerArgument);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerArgumentValue = 0;
			goto l2;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			integerArgumentValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerArgument)))));
			goto l2;
		}
		integerArgumentValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerArgument + BaseHeaderSize))))))));
l2:	/* end positiveMachineIntegerValueOf: */;

		/* begin positiveMachineIntegerValueOf: */
		if ((integerReceiver & 1)) {
			value = (integerReceiver >> 1);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				integerReceiverValue = ((usqIntptr_t) null);
				goto l4;
			}
			integerReceiverValue = ((usqIntptr_t) value);
			goto l4;
		}
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((integerReceiver & 1)));
		ccIndex = (((usqInt)((longAt(integerReceiver)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(integerReceiver - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l3;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l3;
l3:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l4;
		}
		bs = numBytesOfBytes(integerReceiver);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			integerReceiverValue = 0;
			goto l4;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			integerReceiverValue = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerReceiver)))));
			goto l4;
		}
		integerReceiverValue = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerReceiver + BaseHeaderSize))))))));
l4:	/* end positiveMachineIntegerValueOf: */;
		if (!GIV(primFailCode)) {
			oop = positiveMachineIntegerFor(integerArgumentValue ^ integerReceiverValue);

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oop);
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArg;
    usqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Answer the encoder names for the supported bytecode sets. */

	/* InterpreterPrimitives>>#primitiveBytecodeSetsAvailable */
EXPORT(sqInt)
primitiveBytecodeSetsAvailable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt encoderNames;
    char *sp;
    sqInt valuePointer;

	if (GIV(argumentCount) > 0) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	encoderNames = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), 3);
	valuePointer = stringForCString("EncoderForV3");

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(encoderNames, GIV(youngStart))) {
		possibleRootStoreIntovalue(encoderNames, valuePointer);
	}
	longAtput((encoderNames + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
	valuePointer = stringForCString("EncoderForV3PlusClosures");

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(encoderNames, GIV(youngStart))) {
		possibleRootStoreIntovalue(encoderNames, valuePointer);
	}
	longAtput((encoderNames + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	valuePointer = stringForCString("EncoderForSistaV1");

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(encoderNames, GIV(youngStart))) {
		possibleRootStoreIntovalue(encoderNames, valuePointer);
	}
	longAtput((encoderNames + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer);

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), encoderNames);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    char *sp;

	if (!GIV(argumentCount)) {

		/* old behavior - just return the size of free memory */
		integerVal = /* freeSize */
				(oopisLessThan(GIV(freeStart), GIV(reserveStart))
					? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
					: 0);

		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer)), (((usqInt)integerVal << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* Spur behavior; if argument is nil answer size of largest free chunk in oldSpace. */

		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}

		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		aBool = null;
l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			integerVal = (/* freeSize */
	(oopisLessThan(GIV(freeStart), GIV(reserveStart))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0)) + (sqMemoryExtraBytesLeft(aBool));

			/* begin pop:thenPushInteger: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)integerVal << 1) | 1));
			GIV(stackPointer) = sp;
			return;
		}
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */
/*	Manually copied from primitiveCalloutAccessorDepth in the
	ThreadedFFIPlugins... 
 */
/*	since call may invoke a callback */
/*	since call signature is in first literal... */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	if ((((sqInt)primitiveCalloutPointer)) == -1) {
		/* begin reloadPrimitiveCalloutPointer */
		primitiveCalloutPointer = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	primitiveCallout = ((void (*)(void)) primitiveCalloutPointer);
	if (primitiveCallout) {
		dispatchFunctionPointer(primitiveCallout);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    usqInt ccIndex;
    sqInt err;
    sqInt oop;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	argClass = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(arg - BaseHeaderSize)) & AllButTypeMask);
	err = changeClassOfto(rcvr, argClass);
	if (err) {
		/* primitiveFailFor: */
		GIV(primFailCode) = err;
	}
	else {

		/* Flush at cache because rcvr's class has changed. */
		/* begin flushAtCache */
		memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt instance;
    char *sp;

	instance = longAt(GIV(stackPointer));

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* fetchClassOf: */
		((instance & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(instance)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(instance - BaseHeaderSize)) & AllButTypeMask)));
	GIV(stackPointer) = sp;
}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();

	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(/* isBytes: */
				((s & 1) == 0)
			 && (((((usqInt)((longAt(s)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			sz = numBytesOfBytes(s);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);

			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		if (!(sufficientSpaceToAllocate(sz))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt newLargeInteger;
    sqInt oop;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;


	/* bypass type inference which would deduce int */
	midx = 0;
	msecs = ((void *) 0);
	uidx = 0;
	usecs = ((void *) 0);
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), 5);
	if (!result) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}

	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)runInNOut << 1) | 1));

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) (((usqInt)usecs)))) <= (MaxSmallInteger)) {
		v1 = (((((usqInt)usecs)) << 1) | 1);
		goto l1;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN((((usqInt)usecs))));
	v1 = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) (((usqInt)msecs)))) <= (MaxSmallInteger)) {
		v2 = (((((usqInt)msecs)) << 1) | 1);
		goto l2;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN((((usqInt)msecs))));
	v2 = newLargeInteger;
l2:	/* end positive32BitIntegerFor: */;
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(remapBuffer)[GIV(remapBufferCount)], GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v1);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (1U << (shiftForWord())), v1);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (2U << (shiftForWord())), (((usqInt)uidx << 1) | 1));

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(GIV(remapBuffer)[GIV(remapBufferCount)], GIV(youngStart))) {
		possibleRootStoreIntovalue(GIV(remapBuffer)[GIV(remapBufferCount)], v2);
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (3U << (shiftForWord())), v2);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + BaseHeaderSize) + (4U << (shiftForWord())), (((usqInt)midx << 1) | 1));

	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    int numCopied;
    sqInt object;
    sqInt oop;
    sqInt outerContext;
    char *sp;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));

	/* begin argumentCountOfClosure: */
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(/* isContext: */
			((outerContext & 1) == 0)
		 && (((((usqInt)((longAt(outerContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(/* isOopCompiledMethod: */
			((closureMethod & 1) == 0)
		 && (((((usqInt)((longAt(closureMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	assert(isVanillaBlockClosure(blockClosure));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp;
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((((usqInt)(numArgs) << ((BytesPerWord * 8) - 8)))))) + (1U << ((BytesPerWord * 8) - 24))
				: ((1 + ((((usqInt)(numArgs) << 8))))) + (0x1000000));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop & 1));
	closureIP = (oop >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;

	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    int numCopied;
    sqInt object;
    sqInt oop;
    sqInt outerContext;
    char *sp;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));

	/* begin argumentCountOfClosure: */
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(/* isContext: */
			((outerContext & 1) == 0)
		 && (((((usqInt)((longAt(outerContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(/* isOopCompiledMethod: */
			((closureMethod & 1) == 0)
		 && (((((usqInt)((longAt(closureMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	assert(isVanillaBlockClosure(blockClosure));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp;
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((((usqInt)(numArgs) << ((BytesPerWord * 8) - 8)))))) + (1U << ((BytesPerWord * 8) - 24))
				: ((1 + ((((usqInt)(numArgs) << 8))))) + (0x1000000));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop & 1));
	closureIP = (oop >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;

	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0);
	}
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    int arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    int numCopied;
    sqInt object;
    sqInt oop;
    sqInt outerContext;
    char *sp;
    unsigned int sz;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(/* isArray: */
			((argumentArray & 1) == 0)
		 && (((((usqInt)((longAt(argumentArray)))) >> (instFormatFieldLSB())) & 15) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask);
	arraySize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));

	/* begin argumentCountOfClosure: */
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))));
	if (!(/* isContext: */
			((outerContext & 1) == 0)
		 && (((((usqInt)((longAt(outerContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */
	closureMethod = longAt((outerContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!(/* isOopCompiledMethod: */
			((closureMethod & 1) == 0)
		 && (((((usqInt)((longAt(closureMethod)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
		index += 1;
	}

	/* begin activateNewClosure:outer:method:numArgs:mayContextSwitch: */
	assert(isContext(outerContext));
	assert(isVanillaBlockClosure(blockClosure));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	assert(closureMethod == (fetchPointerofObject(MethodIndex, outerContext)));
	assert(isOopCompiledMethod(closureMethod));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), closureMethod);
	GIV(stackPointer) = sp;
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((((usqInt)(numArgs) << ((BytesPerWord * 8) - 8)))))) + (1U << ((BytesPerWord * 8) - 24))
				: ((1 + ((((usqInt)(numArgs) << 8))))) + (0x1000000));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((outerContext + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + ((((usqInt)(ClosureStartPCIndex) << (shiftForWord())))));
	assert((oop & 1));
	closureIP = (oop >> 1);
	GIV(instructionPointer) = ((closureMethod + closureIP) + BaseHeaderSize) - 2;

	/* begin setMethod: */
	GIV(method) = closureMethod;
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	Return the value of the microsecond clock in the local timezone, as
	updated by the heartbeat, as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseLocalMicrosecondClock */
static void
primitiveCoarseLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioLocalMicroseconds());

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the microsecond clock as updated by the heartbeat as
	an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. The
	coarse clock is
	updated by the heartbeat thread and as such is much cheaper than
	primitiveUTCMicrosecondClock, which always entails a system call. */

	/* InterpreterPrimitives>>#primitiveCoarseUTCMicrosecondClock */
static void
primitiveCoarseUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioUTCMicroseconds());

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(sqInt)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt i;
    sqInt len;
    char *sp;

	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Quick identity test */
	arg2 = longAt(GIV(stackPointer));
	if (arg1 == arg2) {
		/* begin methodReturnBool: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return 0;
	}
	if (!((/* isBytes: */
			((arg1 & 1) == 0)
		 && (((((usqInt)((longAt(arg1)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && (/* isBytes: */
			((arg2 & 1) == 0)
		 && (((((usqInt)((longAt(arg2)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	len = numBytesOfBytes(arg1);
	if (!(len == (numBytesOfBytes(arg2)))) {
		/* begin methodReturnBool: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return 0;
	}
	for (i = 0; i < len; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin methodReturnBool: */
			assert(!((failed())));
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp;
			return 0;
		}
	}

	/* begin methodReturnBool: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp;
	return 0;
}


/*	<string1> primitiveCompareWith: string2 [collated: order] */
/*	1 - fetch the parameters from the stack */

	/* InterpreterPrimitives>>#primitiveCompareWith */
EXPORT(void)
primitiveCompareWith(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt c1;
    sqInt c2;
    sqInt i;
    sqInt min;
    sqInt order;
    sqInt result;
    char *sp;
    sqInt string1;
    sqInt string2;
    sqInt strLength1;
    sqInt strLength2;

	order = 0;
	if (!(GIV(argumentCount) == 1)) {
		if (GIV(argumentCount) != 2) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		order = longAt(GIV(stackPointer));
		if (!((/* isBytes: */
				((order & 1) == 0)
			 && (((((usqInt)((longAt(order)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
			 && ((numBytesOfBytes(order)) == 0x100))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	string1 = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));

	/* 2 - check their types - all parameters are ByteObject */
	string2 = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));
	if (!((/* isBytes: */
			((string1 & 1) == 0)
		 && (((((usqInt)((longAt(string1)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && (/* isBytes: */
			((string2 & 1) == 0)
		 && (((((usqInt)((longAt(string2)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	strLength1 = numBytesOfBytes(string1);
	strLength2 = numBytesOfBytes(string2);
	if (order) {
		/* begin rawCompare:length:with:length:accessBlock: */
		min = ((strLength1 < strLength2) ? strLength1 : strLength2);
		for (i = 0; i < min; i += 1) {
			c1 = byteAt((order + BaseHeaderSize) + ((byteAt((string1 + BaseHeaderSize) + i)) + 1));
			c2 = byteAt((order + BaseHeaderSize) + ((byteAt((string2 + BaseHeaderSize) + i)) + 1));
			if (!(c1 == c2)) {
				result = c1 - c2;
				goto l2;
			}
		}
		result = strLength1 - strLength2;
l2:	/* end rawCompare:length:with:length:accessBlock: */;
	}
	else {
		/* begin rawCompare:length:with:length:accessBlock: */
		min = ((strLength1 < strLength2) ? strLength1 : strLength2);
		for (i = 0; i < min; i += 1) {
			c1 = byteAt((string1 + BaseHeaderSize) + i);
			c2 = byteAt((string2 + BaseHeaderSize) + i);
			if (!(c1 == c2)) {
				result = c1 - c2;
				goto l1;
			}
		}
		result = strLength1 - strLength2;
l1:	/* end rawCompare:length:with:length:accessBlock: */;
	}

	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)result << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Fill the receiver, which must be an indexable non-pointer
	object, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    int fillValue;
    usqInt i;
    sqInt rcvr;
    sqInt successBoolean;

	/* begin primitiveConstantFillV3 */
	fillValue = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	successBoolean = /* isWordsOrBytes: */
			((rcvr & 1) == 0)
		 && (isWordsOrBytesNonImm(rcvr));

	/* begin success: */
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (/* isBytes: */
		((rcvr & 1) == 0)
	 && (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {
		successBoolean = (fillValue >= 0)
			 && (fillValue <= 0xFF);

		/* begin success: */
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		fillValue = ((fillValue + ((((usqInt)(fillValue) << 8)))) + ((((usqInt)(fillValue) << 16)))) + ((((usqInt)(fillValue) << 24)));
	}
	if (!GIV(primFailCode)) {
		end = rcvr + (sizeBitsOf(rcvr));
		i = rcvr + BaseHeaderSize;
		while (i < end) {
			long32Atput(i, fillValue);
			i += 4;
		}

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), (((usqInt)numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    usqInt ccIndex;
    usqInt ccIndexUsqInt;
    sqInt header;
    sqInt i;
    sqInt length;
    sqInt rcvr;
    unsigned int sz;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((arg & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if ((/* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
		((ccIndexUsqInt = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndexUsqInt - 1)) << (shiftForWord())))))
			: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)) != (/* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(arg - BaseHeaderSize)) & AllButTypeMask))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (isWordsOrBytesNonImm(rcvr)) {
		length = numBytesOf(rcvr);
		if (!((((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) == ((((usqInt)((longAt(arg)))) >> (instFormatFieldLSB())) & 15))
			 && (length == (numBytesOf(arg))))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}

		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask);
		length = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		if (!((isAppropriateForCopyObject(arg))
			 && (length == (lengthOf(arg))))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		for (i = 0; i < length; i += 1) {
			valuePointer = longAt((arg + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))));

			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, valuePointer);
			}
			longAtput((rcvr + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), valuePointer);
		}
	}

	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Computes cosine of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveCosine */
static void
primitiveCosine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	aValue = floatObjectOf(cos(doubleValue));

	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((longAt(GIV(stackPointer))) & 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 1);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}

		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		crashInThisThread = null;
l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
	}
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));

	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)quotient)) ^ (((((usqInt)quotient)) << 1))))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
	}
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((sqInt)((((usqInt)(integerReceiver / integerArgument))) ^ (((((usqInt)(integerReceiver / integerArgument))) << 1))))) >= 0) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)(integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!b) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (a) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */
			rem = a % b;
			if (rem) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */
				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt oop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;

	if (GIV(argumentCount) > 0) {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));

		/* begin activeProcess */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + ((((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(criticalSection, GIV(youngStart))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + ((((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);

		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp;
	addLastLinktoList(activeProc, criticalSection);
	transferTo(wakeHighestPriority());
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & 1) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerReceiver == integerArgument
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) == (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
				(result
					? GIV(trueObj)
					: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerRcvr == integerArg
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;

	/* rcvr */
	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	if ((/* begin isEmptyList: */
		assert(!(isForwarded(criticalSection))),
	(longAt((criticalSection + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((criticalSection + BaseHeaderSize) + ((((usqInt)(owningProcessIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */
		owningProcess = removeFirstLinkOfList(criticalSection);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((criticalSection + BaseHeaderSize) + ((((usqInt)(owningProcessIndex) << (shiftForWord())))), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields));
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power.
	Receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	aValue = floatObjectOf(exp(doubleValue));

	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Exponent part of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double doubleValue;
    int pwr;
    sqInt rcvr;

	pwr = 0;
	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	frexp(doubleValue, (&pwr));

	/* stackTopPut: */
	longAtPointerput(GIV(stackPointer), (((usqInt)(pwr - 1) << 1) | 1));
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set PrimErrFFIException primitive failure and associated exceptionCode
	(a.k.a. 
	secondaryErrorCode) and exceptionPC. Under control of the
	ffiExceptionResponse flag,
	if in a primitive with an error code and ffiCalloutVMHandle indicates
	we're in an FFI call,
	then fail the primitive.
	ffiExceptionResponse < 0 never fail
	ffiExceptionResponse = 0 fail if method has a primitive error code
	(default) ffiExceptionResponse > 0 always fail */

	/* InterpreterPrimitives>>#primitiveFailForFFIException:at: */
sqInt
primitiveFailForFFIExceptionat(usqLong exceptionCode, usqInt pc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt i;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;

	if ((!GIV(ffiCalloutVMHandle))
	 || (ffiExceptionResponse < 0)) {

		/* i.e. never fail */
		return 0;
	}
	GIV(secondaryErrorCode) = ((sqLong) exceptionCode);
	GIV(exceptionPC) = pc;
	GIV(primFailCode) = PrimErrFFIException;
	if ((ffiExceptionResponse > 0)
	 || ((/* isOopCompiledMethod: */
		((GIV(newMethod) & 1) == 0)
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && (methodUsesPrimitiveErrorCode(GIV(newMethod))))) {
		ownVM(GIV(ffiCalloutVMHandle));

		/* begin activateFailingPrimitiveMethod */
		assert(GIV(primFailCode) != 0);
		assert(addressCouldBeObj(GIV(newMethod)));
		assert(isCompiledMethod(GIV(newMethod)));
		assert((primitiveIndexOf(GIV(newMethod))) != 0);

		/* begin justActivateNewMethod: */
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
		numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
		numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

		/* could new rcvr be set at point of send? */
		rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvr)));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp;
		GIV(framePointer) = GIV(stackPointer);

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp;

		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method)));
		assert((methodHeaderOf(GIV(method))) == methodHeader);
		assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
		object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
				(VMBIGENDIAN
					? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
					: ((1 + ((numArgs << 8)))));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
		if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
			if (GIV(primFailCode)) {
				reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
			}
		}
		_longjmp(GIV(reenterInterpreter), ReturnToInterpreter);
	}
	return 0;
}


/*	Set PrimErrOSError primitive failure and associated osErrorCode. */

	/* InterpreterPrimitives>>#primitiveFailForOSError: */
sqInt
primitiveFailForOSError(sqLong osErrorCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(secondaryErrorCode) = osErrorCode;
	return (GIV(primFailCode) = PrimErrOSError);
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}


/*	Set primFailCode primitive failure and associated secondaryErrorCode. */

	/* InterpreterPrimitives>>#primitiveFailFor:withSecondary: */
sqInt
primitiveFailForwithSecondary(sqInt reasonCode, sqLong extraErrorCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(secondaryErrorCode) = extraErrorCode;
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    sqInt rcvrOop;
    double result;
    char *sp;

	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));

	/* begin primitiveFloatAdd:toArg: */
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Index the receiver, which must be an indexable non-pointer object, and
	yield a float.
 */

	/* InterpreterPrimitives>>#primitiveFloatArrayAt */
static void
primitiveFloatArrayAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}


/*	Index the receiver, which must be an indexable non-pointer object, and
	store a float.
 */

	/* InterpreterPrimitives>>#primitiveFloatArrayAtPut */
static void
primitiveFloatArrayAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt rcvr;
    usqInt result;
    char *sp;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		integerValue = long32At((rcvr + BaseHeaderSize) + ((((usqInt)(((VMBIGENDIAN
		? 0
		: 1))) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l1;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		result = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		integerValue = long32At((rcvr + BaseHeaderSize) + ((((usqInt)(((VMBIGENDIAN
		? 1
		: 0))) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l2;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		result = newLargeInteger;
l2:	/* end positive32BitIntegerFor: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = ((index & 1)
				? PrimErrBadIndex
				: PrimErrBadArgument);
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    char *sp;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (index == ConstOne) {
		/* storeLong32:ofObject:withValue: */
		long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)(((VMBIGENDIAN
		? 0
		: 1))) << 2))), valueToStore);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* storeLong32:ofObject:withValue: */
		long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)(((VMBIGENDIAN
		? 1
		: 0))) << 2))), valueToStore);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = ((index & 1)
				? PrimErrBadIndex
				: PrimErrBadArgument);
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    sqInt rcvrOop;
    double result;
    char *sp;

	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));

	/* begin primitiveFloatDivide:byArg: */
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;

	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(aBool
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterOrEqual */
static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatGreaterOrEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(aBool
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterThan */
static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatGreaterthanArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(aBool
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessOrEqual */
static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatLessOrEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(aBool
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessThan */
static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatLessthanArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(aBool
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatMultiply */
static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    sqInt rcvrOop;
    double result;
    char *sp;

	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));

	/* begin primitiveFloatMultiply:byArg: */
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatNotEqual */
static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int aBool;
    char *sp;

	aBool = primitiveFloatEqualtoArg(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(aBool
				? GIV(falseObj)
				: GIV(trueObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatSubtract */
static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    sqInt rcvrOop;
    double result;
    char *sp;

	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));

	/* begin primitiveFloatSubtract:fromArg: */
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

	/* InterpreterPrimitives>>#primitiveFlushCache */
static void
primitiveFlushCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin flushMethodCache */
	memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invocation.
 */

	/* InterpreterPrimitives>>#primitiveFlushExternalPrimitives */
static void
primitiveFlushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oopSqInt;
    unsigned int sz;

	/* begin flushExternalPrimitives */
	/* begin allObjectsDo: */
	oopSqInt = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oopSqInt)) < GIV(freeStart)) {
		if (!(((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt)((longAt(oopSqInt)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				flushExternalPrimitiveOf(oopSqInt);
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oopSqInt, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oopSqInt)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oopSqInt);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oopSqInt - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oopSqInt = (oopSqInt + sz) + (headerTypeBytes[(longAt(oopSqInt + sz)) & TypeMask]);
	}

	/* begin flushMethodCache */
	memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
	memset(externalPrimitiveTable, 0, MaxExternalPrimitiveTableSize * (sizeof(externalPrimitiveTable[0])));
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

	/* InterpreterPrimitives>>#primitiveForceDisplayUpdate */
static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	Set force tenure flag to true, this forces a tenure operation on the next
	incremental GC
 */

	/* InterpreterPrimitives>>#primitiveForceTenure */
EXPORT(sqInt)
primitiveForceTenure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* forceTenureFlag: */
	GIV(forceTenureFlag) = 1;
	return 0;
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

	/* InterpreterPrimitives>>#primitiveFormPrint */
static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    usqInt ccIndex;
    sqInt classOop;
    sqInt depth;
    sqInt h;
    double hScale;
    sqInt isFloat;
    sqInt landscapeFlag;
    sqInt oop;
    int pixelsPerWord;
    sqInt rcvr;
    double result;
    sqInt successBoolean;
    double vScale;
    sqInt w;
    sqInt wordsPerLine;

	bitsArray = 0;
	depth = 0;
	h = 0;
	w = 0;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l1;
	}

	/* begin success: */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	landscapeFlag = null;
l1:	/* end booleanValueOf: */;
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l2;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l2:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		vScale = result;
		goto l3;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	vScale = 0.0;
l3:	/* end floatValueOf: */;
	oop = longAt(GIV(stackPointer) + (2 * BytesPerWord));

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l4;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l4;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l4;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l4:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		hScale = result;
		goto l5;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	hScale = 0.0;
l5:	/* end floatValueOf: */;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if (!((/* isPointers: */
			((rcvr & 1) == 0)
		 && (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && ((lengthOf(rcvr)) >= 4))) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0U << (shiftForWord())));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if (/* isWordsOrBytes: */
			((bitsArray & 1) == 0)
		 && (isWordsOrBytesNonImm(bitsArray))) {
			bitsArraySize = numBytesOf(bitsArray);

			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {

				/* Don't overwrite an error code that has already been set. */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		successBoolean = ioFormPrint(bitsArray + BaseHeaderSize, w, h, depth, hScale, vScale, landscapeFlag);

		/* begin success: */
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			/* begin methodReturnReceiver */
			assert(!((failed())));
			GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		}
	}
}


/*	Fractional part of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveFractionalPart */
static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;
    double trunc;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	aValue = floatObjectOf(modf(doubleValue, (&trunc)));

	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Fetch the system attribute with the given integer ID. The result is a
	string, or nil if the attribute is not defined.
 */

	/* InterpreterPrimitives>>#primitiveGetAttribute */
static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    const char *attributeString;
    char *sp;

	attr = longAt(GIV(stackPointer));
	if (!((attr & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	attributeString = getAttributeString((attr >> 1));
	if (attributeString) {
		methodReturnString(attributeString);
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Access to environment variables via getenv. No putenv or setenv as yet. */

	/* InterpreterPrimitives>>#primitiveGetenv */
EXPORT(sqInt)
primitiveGetenv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *key;
    sqInt oop;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    char *var;

	result = 0;
	if (sHEAFn) {

		/* secHasEnvironmentAccess */
		if (!(sHEAFn())) {
			return (GIV(primFailCode) = PrimErrInappropriate);
		}
	}
	key = cStringOrNullFor(longAt(GIV(stackPointer)));
	if (!key) {
		if (!GIV(primFailCode)) {
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
		reasonCode = GIV(primFailCode);

		/* begin primitiveFailFor: */
		return (GIV(primFailCode) = reasonCode);
	}
	var = getenv(key);
	free(key);
	if (var) {
		result = stringForCString(var);
		if (!result) {
			return (GIV(primFailCode) = PrimErrNoMemory);
		}
	}
	assert(GIV(primFailCode) == 0);
	oop = (var
				? result
				: GIV(nilObj));

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGetImmutability */
#if IMMUTABILITY
static void
primitiveGetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;
    sqInt trueOrFalse;

	rcvr = longAt(GIV(stackPointer));
	trueOrFalse = /* isOopImmutable: */
			((rcvr & 1))
		 || (
#    if IMMUTABILITY
			((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#    else
			0
#    endif
			);

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(trueOrFalse
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Primitive. Answer the VM's current log directory */

	/* InterpreterPrimitives>>#primitiveGetLogDirectory */
EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (!ptr) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	for (i = 0; i < sz; i += 1) {
		/* storeByte:ofObject:withValue: */
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), stringOop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Return the next input event from the VM event queue. */

	/* InterpreterPrimitives>>#primitiveGetNextEvent */
static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqIntptr_t eventTypeIs;
    static char * eventTypeNames[] = {
		"None", "Mouse", "Keyboard", "DragDropFiles", "Menu", "Window", "Complex", "MouseWheel",
		"Plugin"
	};
    sqIntptr_t evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqIntptr_t value;

	arg = longAt(GIV(stackPointer));
	if (!((/* isArray: */
			((arg & 1) == 0)
		 && (((((usqInt)((longAt(arg)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (GIV(primFailCode)) {
		return;
	}
	if ((eventTraceMask != 0)
	 && (((eventTraceMask & ((((evtBuf[0]) < 0) ? (((usqInt)(1)) >> (-(evtBuf[0]))) : (1U << (evtBuf[0]))))) != 0))) {
		fprintf(stderr,
				"Event%s/%" PRIdSQINT " @ %" PRIuSQINT "\t\t%" PRIdSQINT "/%" PRIxSQINT " %" PRIdSQINT "/%" PRIxSQINT "\n\t%" PRIdSQINT "/%" PRIxSQINT " %" PRIdSQINT "/%" PRIxSQINT "\t %" PRIdSQINT "/%" PRIxSQINT " %p\n",
				((((evtBuf[0]) >= 0) && ((evtBuf[0]) <= 8))
				? eventTypeNames[evtBuf[0]]
				: "?"),
				evtBuf[0],
				evtBuf[1],
				evtBuf[2],
				evtBuf[2],
				evtBuf[3],
				evtBuf[3],
				evtBuf[4],
				evtBuf[4],
				evtBuf[5],
				evtBuf[5],
				evtBuf[6],
				evtBuf[6],
				((void *)(evtBuf[7])));
	}
	eventTypeIs = evtBuf[0];

	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((((usqInt)(evtBuf[0]))) ^ (((((usqInt)(evtBuf[0]))) << 1))))) >= 0) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((arg + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)(evtBuf[0]) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	if (eventTypeIs == 6) {

		/* Event is Complex, assume evtBuf is populated correctly and return */
		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];

			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(arg, GIV(youngStart))) {
				possibleRootStoreIntovalue(arg, value);
			}
			longAtput((arg + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), value);
		}
	}
	else {

		/* Event time stamp */
		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)((((usqInt)((evtBuf[1]) & MillisecondClockMask))) ^ (((((usqInt)((evtBuf[1]) & MillisecondClockMask))) << 1))))) >= 0) {
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((arg + BaseHeaderSize) + (1U << (shiftForWord())), ((((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode)) {
			return;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if ((((sqInt)((((usqInt)value)) ^ (((((usqInt)value)) << 1))))) >= 0) {
				/* begin storeInteger:ofObject:withValue: */
				if ((((sqInt)((((usqInt)value)) ^ (((((usqInt)value)) << 1))))) >= 0) {
					/* storePointerUnchecked:ofObject:withValue: */
					longAtput((arg + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), (((usqInt)value << 1) | 1));
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
			}
			else {
				value = positiveMachineIntegerFor(value);

				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(arg, GIV(youngStart))) {
					possibleRootStoreIntovalue(arg, value);
				}
				longAtput((arg + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), value);
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's label */

	/* InterpreterPrimitives>>#primitiveGetWindowLabel */
EXPORT(sqInt)
primitiveGetWindowLabel(void)
{
	methodReturnString(ioGetWindowLabel());
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveGetWindowSize */
EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt object;
    sqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;

	/* begin makePointwithxValue:yValue: */
	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + ((((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)w << 1) | 1));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + ((((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)h << 1) | 1));
	object = pointResult;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveGreaterOrEqual */
static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & 1) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerReceiver >= integerArgument
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterOrEqualLargeIntegers */
EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerRcvr >= integerArg
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGreaterThan */
static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & 1) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerReceiver > integerArgument
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterThanLargeIntegers */
EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerRcvr > integerArg
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* InterpreterPrimitives>>#primitiveHashMultiply */
static void
primitiveHashMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt ok;
    char *sp;
    unsigned int value;

	value = longAt(GIV(stackPointer));
	if ((value & 1)) {
		value = (value >> 1);
	}
	else {
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

		/* begin is:instanceOf:compactClassIndex: */
		if ((value & 1)) {
			ok = 0;
			goto l1;
		}

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((value & 1)));
		ccIndex = (((usqInt)((longAt(value)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(value - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l1;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l1;
l1:	/* end is:instanceOf:compactClassIndex: */;
		if (!ok) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		value = SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((value + BaseHeaderSize))));
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), (((((((usqInt) value)) * HashMultiplyConstant) & 0xFFFFFFF) << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

	/* InterpreterPrimitives>>#primitiveHeartbeatFrequency */
EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
		 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	integerValue = ioHeartbeatFrequency(reset);

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		oop = ((integerValue << 1) | 1);
		goto l1;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
	oop = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveHighBit */
static void
primitiveHighBit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt highestBitZeroBased;
    sqInt integerReceiverOop;
    sqInt leadingZeroCount;
    char *sp;

	/* Convert the receiver Oop to use a single tag bit */
	integerReceiverOop = longAt(GIV(stackPointer));
#  if defined(__GNUC__)

	/* Note: in gcc, result is undefined if input is zero (for compatibility with BSR fallback when no CLZ instruction available).
	   but input is never zero because we pass the oop with tag bits set, so we are safe */
	leadingZeroCount = __builtin_clz(integerReceiverOop);
	if (!leadingZeroCount) {

		/* highBit is not defined for negative Integer */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)(leadingZeroCount ^ ((BytesPerWord * 8) - 1)) << 1) | 1));
	GIV(stackPointer) = sp;
#  elif (defined(_MSC_VER)) || (defined(__ICC))

	/* In MSVC, _lzcnt and _lzcnt64 builtins do not fallback to BSR when not supported by CPU
	   Instead of messing with __cpuid() we always use the BSR intrinsic */
	/* Trick: we test the oop sign rather than the integerValue. Assume oop are signed (so far, they are, sqInt are signed) */
	if (integerReceiverOop < 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* We do not even test the return value, because integerReceiverOop is never zero */
	highestBitZeroBased = 0;
	_BitScanReverse((&highestBitZeroBased), integerReceiverOop);

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)highestBitZeroBased << 1) | 1));
	GIV(stackPointer) = sp;
#  else // defined(__GNUC__) || (defined(_MSC_VER)) || (defined(__ICC))

	/* not gcc/clang, nor MSVC/ICC, you have to implement if your compiler provides useful builtins */
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
#  endif // defined(__GNUC__) || (defined(_MSC_VER)) || (defined(__ICC))
}


/*	Return the value of the high resolution clock if this system has any.
	The exact frequency of the high res clock is undefined specifically so
	that we can use
	processor dependent instructions (like RDTSC). The only use for the high
	res clock is for
	profiling where we can allocate time based on sub-msec resolution of the
	high res clock.
	If no high-resolution counter is available, the platform should return
	zero. ar 6/22/2007 */

	/* InterpreterPrimitives>>#primitiveHighResClock */
EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioHighResClock());

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveIdentical */
static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	thisObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	otherObject = longAt(GIV(stackPointer));

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(thisObject == otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveIdentityHash */
static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if (((thisReceiver & 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((((((usqInt)((longAt(thisReceiver)))) >> HashBitsOffset) & HashMaskUnshifted) << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer an integer identifying the type of image. The image version number
	may identify the format of the image (e.g. 32 or 64-bit word size) or
	specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveImageFormatVersion */
EXPORT(sqInt)
primitiveImageFormatVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    char *sp;

	integerValue = /* imageFormatVersionForSnapshot */
			(GIV(multipleBytecodeSetsActive)
				? 7017 /* (imageFormatVersion bitOr: MultipleBytecodeSetsBitmask) */
				: 6505 /* imageFormatVersion */);

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		oop = ((integerValue << 1) | 1);
		goto l1;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
	oop = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	When called with a single string argument, record the string as the
	current image file name.
	When called with zero arguments, return a string containing the current
	image file name.
 */

	/* InterpreterPrimitives>>#primitiveImageName */
static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isString;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));

		/* begin isInstanceOfClassByteString: */
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord())))));
		if ((s & 1)) {
			isString = 0;
			goto l1;
		}

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((s & 1)));
		ccIndex = (((usqInt)((longAt(s)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			isString = ((longAt(s - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l1;
		}
		isString = ClassByteStringCompactIndex == ccIndex;
		goto l1;
		isString = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isInstanceOfClassByteString: */;
		if (!isString) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				return;
			}
		}
		imageNamePutLength(s + BaseHeaderSize, numBytesOf(s));

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		return;
	}
	sz = imageNameSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	imageNameGetLength(s + BaseHeaderSize, sz);

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

	/* InterpreterPrimitives>>#primitiveInputSemaphore */
static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    usqInt ccIndex;

	arg = longAt(GIV(stackPointer));
	if ((arg & 1)) {

		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */
		ioSetInputSemaphore((arg >> 1));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
	if ((arg == GIV(nilObj))
	 || (/* isSemaphoreOop: */
		((arg & 1) == 0)
	 && ((/* fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(arg - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheInputSemaphore) << (shiftForWord())))), arg);

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

	/* InterpreterPrimitives>>#primitiveInputWord */
static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)0 << 1) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveIntegerAt */
static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt header;
    sqInt index;
    int intValue;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt sz;
    unsigned int sz1;

	/* begin primitiveV3IntegerAt */
	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l3;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(/* isWords: */
			((rcvr & 1) == 0)
		 && (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l3;
	}
	index = (index >> 1);

	/* begin lengthOf: */
	header = longAt(rcvr);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz1 = header & SizeMask;
	}
	else {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz1 -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		sz = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
		goto l2;
	}
	sz = (fmt < (firstByteFormat())
				? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
				: (sz1 - BaseHeaderSize) - (fmt & 3));
l2:	/* end lengthOf: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l3;
	}

	/* for zero indexing */
	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	intValue = intAt(addr);

	/* begin signed32BitIntegerFor: */
	if ((((sqInt)((((usqInt)intValue)) ^ (((((usqInt)intValue)) << 1))))) >= 0) {
		result = (((usqInt)intValue << 1) | 1);
		goto l1;
	}
	result = noInlineSigned32BitIntegerGutsFor(intValue);
l1:	/* end signed32BitIntegerFor: */;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), result);
	GIV(stackPointer) = sp;
l3:	/* end primitiveV3IntegerAt */;
}

	/* InterpreterPrimitives>>#primitiveIntegerAtPut */
static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt header;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    unsigned int sz1;
    int value;
    sqInt valueOop;

	/* begin primitiveV3IntegerAtPut */
	valueOop = longAt(GIV(stackPointer));
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}

	/* begin signed32BitValueOf: */
	if ((valueOop & 1)) {
		value = (valueOop >> 1);
		goto l1;
	}
	value = noInlineSigned32BitValueGutsOf(valueOop);
l1:	/* end signed32BitValueOf: */;
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l3;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(/* isWords: */
			((rcvr & 1) == 0)
		 && (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l3;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l3;
	}

	/* begin lengthOf: */
	header = longAt(rcvr);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz1 = header & SizeMask;
	}
	else {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz1 -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		sz = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
		goto l2;
	}
	sz = (fmt < (firstByteFormat())
				? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
				: (sz1 - BaseHeaderSize) - (fmt & 3));
l2:	/* end lengthOf: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l3;
	}

	/* for zero indexing */
	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	value = intAtput(addr, value);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), valueOop);
	GIV(stackPointer) = sp;
l3:	/* end primitiveV3IntegerAtPut */;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

	/* InterpreterPrimitives>>#primitiveInterruptChecksPerMSec */
EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (GIV(argumentCount)) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	oop = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

	/* InterpreterPrimitives>>#primitiveInterruptSemaphore */
static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    usqInt ccIndex;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (/* isSemaphoreOop: */
		((arg & 1) == 0)
	 && ((/* fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(arg - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheInterruptSemaphore) << (shiftForWord())))), arg);

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

	/* InterpreterPrimitives>>#primitiveInvokeObjectAsMethod */
static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt i;
    usqInt iUsqInt;
    sqInt lookupClassTag;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt rcvr;
    sqInt runArgs;
    sqInt runReceiver;
    char *sp;
    sqInt top;
    sqInt valuePointer;

	runArgs = eeInstantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), GIV(argumentCount));
	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top;

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((runArgs + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), valuePointer);
	}
	runReceiver = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorRunWithIn) << (shiftForWord())))));
	GIV(argumentCount) = 3;
	lookupClassTag = /* #fetchClassTagOf: #fetchClassOf: */
			((GIV(newMethod) & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(GIV(newMethod))))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(GIV(newMethod) - BaseHeaderSize)) & AllButTypeMask));
	findNewMethodInClassTag(lookupClassTag);

	/* begin executeNewMethod */
	if (primitiveFunctionPointer) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}

	/* begin activateNewMethod */
	/* begin justActivateNewMethod: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
				: ((1 + ((numArgs << 8)))));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp;
	for (iUsqInt = (numArgs + 1); iUsqInt <= numTemps; iUsqInt += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode)) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer if running on a big endian machine. */

	/* InterpreterPrimitives>>#primitiveIsBigEnder */
EXPORT(sqInt)
primitiveIsBigEnder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer)), GIV(falseObj));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Answer whether the argument to the primitive is a root for
	young space
 */

	/* InterpreterPrimitives>>#primitiveIsRoot */
EXPORT(sqInt)
primitiveIsRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oopSqInt;
    char *sp;

	/* begin stackObjectValue: */
	oopSqInt = longAt(GIV(stackPointer));
	if ((oopSqInt & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oopSqInt;
l1:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
			((longAt(oop)) & RootBit
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

	/* InterpreterPrimitives>>#primitiveIsWindowObscured */
EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	trueOrFalse = ioIsWindowObscured();

	/* begin pushBool: */
	object = /* booleanObjectOf: */
			(trueOrFalse
				? GIV(trueObj)
				: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Primitive. Answer whether the argument to the primitive resides in young
	space. 
 */

	/* InterpreterPrimitives>>#primitiveIsYoung */
EXPORT(sqInt)
primitiveIsYoung(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oopSqInt;
    char *sp;
    sqInt trueOrFalse;


	/* for now... */
	/* begin stackObjectValue: */
	oopSqInt = longAt(GIV(stackPointer));
	if ((oopSqInt & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		oop = null;
		goto l1;
	}
	oop = oopSqInt;
l1:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		trueOrFalse = oopisGreaterThanOrEqualTo(oop, GIV(youngStart));

		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
			(trueOrFalse
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveLessOrEqual */
static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & 1) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerReceiver <= integerArgument
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessOrEqualLargeIntegers */
EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerRcvr <= integerArg
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessThan */
static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & 1) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerReceiver < integerArgument
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessThanLargeIntegers */
EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerRcvr < integerArg
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

	/* InterpreterPrimitives>>#primitiveListBuiltinModule */
static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *moduleName;
    char *sp;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (GIV(primFailCode)
	 || (index <= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName) {
		methodReturnString(moduleName);
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Answer the n-th loaded external module name. */

	/* InterpreterPrimitives>>#primitiveListExternalModule */
static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *moduleName;
    char *sp;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (GIV(primFailCode)
	 || (index <= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName) {
		methodReturnString(moduleName);
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	This primitive is called from Smalltalk as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray.
	
	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well
	formed. It will return as its value the original array of roots, and the
	erstwhile segmentWordArray will have been truncated to a size of one word,
	i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to
	an unrecognizable and unusable jumble. But what more could you have done
	with it anyway?
	[How about saving it so the system functions as primitives are intended?
	eem 5/9/2017 16:31]
	
	In Spur, if the primitive succeeds, the segmentWordArray is also becomed
	into the array of loaded
	objects, to allow fixing up of loaded objects directly without nextObject,
	which Spur doesn't support. */

	/* InterpreterPrimitives>>#primitiveLoadImageSegment */
static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((/* isArray: */
			((outPointerArray & 1) == 0)
		 && (((((usqInt)((longAt(outPointerArray)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (/* isWords: */
			((segmentWordArray & 1) == 0)
		 && (((((usqInt)((longAt(segmentWordArray)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()))))) {

		/* Must be indexable words */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray);
	if (oopisGreaterThan(result, segmentWordArray)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = result;
	}
}


/*	Return the value of the microsecond clock in the local timezone as an
	integer. This is the number of microseconds since the Smalltalk epoch,
	1901/1/1 12:00am.
	The microsecond clock is at least 60 bits wide which means it'll get to
	around August
	38435 before it wraps around. Be sure to put it on your calendar. This
	primitive accesses the time as answered by the OS. */

	/* InterpreterPrimitives>>#primitiveLocalMicrosecondClock */
static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioLocalMicrosecondsNow());

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveLogN */
static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	aValue = floatObjectOf(log(doubleValue));

	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

	/* InterpreterPrimitives>>#primitiveLowSpaceSemaphore */
static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    usqInt ccIndex;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (/* isSemaphoreOop: */
		((arg & 1) == 0)
	 && ((/* fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(arg - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), arg);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))), arg);

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveMakePoint */
static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt pt;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg = longAt(GIV(stackPointer));
	if (!(/* isFloatOrInt: */
			((arg & 1))
		 || (((((usqInt)((longAt(arg)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	pt = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pt + BaseHeaderSize) + ((((usqInt)(XIndex) << (shiftForWord())))), rcvr);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pt + BaseHeaderSize) + ((((usqInt)(YIndex) << (shiftForWord())))), arg);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMaxIdentityHash */
static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)HashMaskUnshifted << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

	/* InterpreterPrimitives>>#primitiveMethod */
usqInt
primitiveMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

	/* InterpreterPrimitives>>#primitiveMillisecondClock */
static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = ((((ioMSecs()) & MillisecondClockMask) << 1) | 1);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

	/* InterpreterPrimitives>>#primitiveMillisecondClockMask */
EXPORT(sqInt)
primitiveMillisecondClockMask(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)MillisecondClockMask << 1) | 1));
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveMod */
static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));

	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)mod)) ^ (((((usqInt)mod)) << 1))))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)mod << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveModLargeIntegers */
EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!b) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Handle remainder of same sign as argument */
	result = a % b;
	if (result) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Given one boolean parameter, set multipleBytecodeSetsActive to inform
	the VM that alternate bytecode sets such as SistaV1 are now in use and
	that the image format number should be updated accordingly. With zero
	parameters, answer the current value of multipleBytecodeSetsActive. */

	/* InterpreterPrimitives>>#primitiveMultipleBytecodeSetsActive */
EXPORT(sqInt)
primitiveMultipleBytecodeSetsActive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (GIV(argumentCount) > 1) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			return (GIV(primFailCode) = PrimErrUnsupported);
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				GIV(multipleBytecodeSetsActive) = 0;
			}
			else {
				return (GIV(primFailCode) = PrimErrBadArgument);
			}
		}
	}

	/* begin methodReturnBool: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(GIV(multipleBytecodeSetsActive)
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitiveMultiply */
static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerRcvr;
    sqInt integerResult;
    int overflow;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		integerArg = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
	}
	if (!GIV(primFailCode)) {
		overflow = (integerRcvr > 0
					? (integerArg > 0
							? integerRcvr > ((MaxSmallInteger) / integerArg)
							: integerArg < ((MinSmallInteger) / integerRcvr))
					: (integerArg > 0
							? integerRcvr < ((MinSmallInteger) / integerArg)
							: (integerRcvr < 0)
							 && (integerArg < ((MaxSmallInteger) / integerRcvr))));
		if (overflow) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		else {
			integerResult = integerRcvr * integerArg;

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveMultiplyLargeIntegers */
EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNew */
static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocSize;
    usqInt format;
    sqInt minFree;
    sqInt oop;
    char *sp;
    sqInt spaceOkay;


	/* begin sufficientSpaceToInstantiate:indexableSize: */
	if (((format = (((usqInt)(((longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1))) >> (instFormatFieldLSB())) & 15)) < (firstByteFormat())) {

		/* indexable fields are words or pointers */
		allocSize = 0;
	}
	else {

		/* indexable fields are bytes */
		/* fail if attempting to allocate over 2 Gb, since this overflows 32-bit arithmetic */
		if ((((usqInt)(0)) >> LongSizeNumBits) > 0) {
			spaceOkay = 0;
			goto l1;
		}
		allocSize = 0;
	}

	/* begin sufficientSpaceToAllocate: */
	/* check for low-space */
	minFree = ((((((GIV(lowSpaceThreshold) + (2500 + allocSize)) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		spaceOkay = 1;
		goto l1;
	}
	spaceOkay = sufficientSpaceAfterGC(minFree);
l1:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	if (spaceOkay) {
		oop = instantiateClassindexableSize(longAt(GIV(stackPointer)), 0);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
	}
}

	/* InterpreterPrimitives>>#primitiveNewMethod */
static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt header;
    sqInt i;
    usqInt literalCount;
    usqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	bytecodeCount = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((header & 1))
		 && (((bytecodeCount & 1))
		 && (((bytecodeCount = (bytecodeCount >> 1))) >= 0)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));

	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	literalCount = ((((int) header)) < 0
				? ((header >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header)) >> 10) & 0xFF);
	size = ((literalCount + LiteralStart) * BytesPerOop) + bytecodeCount;
	theMethod = instantiateClassindexableSize(class, size);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((theMethod + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))), header);
	for (i = 1; i <= literalCount; i += 1) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((theMethod + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveNewWithArg */
static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocSize;
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    usqInt format;
    sqInt minFree;
    int ok;
    sqInt oop;
    usqIntptr_t size;
    char *sp;
    sqInt spaceOkay;
    sqInt value;

	oop = longAt(GIV(stackPointer));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l2;
		}
		size = value;
		goto l2;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l2;
	}
	size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}

	/* begin sufficientSpaceToInstantiate:indexableSize: */
	if (((format = (((usqInt)(((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1))) >> (instFormatFieldLSB())) & 15)) < (firstByteFormat())) {

		/* indexable fields are words or pointers */
		if (size) {

			/* fail if attempting to call new: on non-indexable class */
			if (format < (arrayFormat())) {
				spaceOkay = 0;
				goto l3;
			}
			if (((size) >> (LongSizeNumBits - (shiftForWord()))) > 0) {
				spaceOkay = 0;
				goto l3;
			}
		}
		allocSize = size * BytesPerWord;
	}
	else {

		/* indexable fields are bytes */
		/* fail if attempting to allocate over 2 Gb, since this overflows 32-bit arithmetic */
		if (((size) >> LongSizeNumBits) > 0) {
			spaceOkay = 0;
			goto l3;
		}
		allocSize = size;
	}

	/* begin sufficientSpaceToAllocate: */
	/* check for low-space */
	minFree = ((((((GIV(lowSpaceThreshold) + (2500 + allocSize)) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		spaceOkay = 1;
		goto l3;
	}
	spaceOkay = sufficientSpaceAfterGC(minFree);
l3:	/* end sufficientSpaceToInstantiate:indexableSize: */;
	if (spaceOkay) {
		oop = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size);

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoMemory;
	}
}

	/* InterpreterPrimitives>>#primitiveNextInstance */
static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classPointer;
    sqInt header;
    sqInt object;
    char *sp;
    sqInt subsequentObject;
    sqInt subsequentObjectSqInt;
    unsigned int sz;

	object = longAt(GIV(stackPointer));
	if (!((object & 1))) {
		/* begin instanceAfter: */
		classPointer = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(object)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(object - BaseHeaderSize)) & AllButTypeMask);
		if (!(asserta(oopisLessThan(object, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(object)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(object)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(object);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(object - (BytesPerWord * 2))) & LongSizeMask)));
		}
		subsequentObjectSqInt = (object + sz) + (headerTypeBytes[(longAt(object + sz)) & TypeMask]);
		while (oopisLessThan(subsequentObjectSqInt, GIV(freeStart))) {
			if ((!(((longAt(subsequentObjectSqInt)) & TypeMask) == HeaderTypeFree))
			 && ((/* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(subsequentObjectSqInt)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(subsequentObjectSqInt - BaseHeaderSize)) & AllButTypeMask)) == classPointer)) {
				subsequentObject = subsequentObjectSqInt;
				goto l1;
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(subsequentObjectSqInt, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(subsequentObjectSqInt)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(subsequentObjectSqInt)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(subsequentObjectSqInt);
				sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(subsequentObjectSqInt - (BytesPerWord * 2))) & LongSizeMask)));
			}
			subsequentObjectSqInt = (subsequentObjectSqInt + sz) + (headerTypeBytes[(longAt(subsequentObjectSqInt + sz)) & TypeMask]);
		}
		subsequentObject = null;
l1:	/* end instanceAfter: */;
		if (subsequentObject) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

	/* InterpreterPrimitives>>#primitiveNextObject */
static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt instance;
    sqInt obj;
    sqInt oop;
    char *sp;
    unsigned int sz;

	oop = longAt(GIV(stackPointer));

	/* begin accessibleObjectAfter: */
	/* begin objectAfter: */
	if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
		error("no objects after the end of memory");
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
	}
	obj = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			instance = obj;
			goto l1;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	instance = null;
l1:	/* end accessibleObjectAfter: */;
	if (instance) {
		assert(isInMemory(instance));

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)0 << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

	/* InterpreterPrimitives>>#primitiveNoop */
static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveNotEqual */
static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    int result;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerReceiver & integerArgument) & 1) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerReceiver != integerArgument
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) != (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
				(result
					? GIV(trueObj)
					: GIV(falseObj)));
			GIV(stackPointer) = sp;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveNotEqualLargeIntegers */
EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(integerRcvr != integerArg
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */
/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveNotIdentical */
static void
primitiveNotIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	thisObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	otherObject = longAt(GIV(stackPointer));

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(thisObject != otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

	/* InterpreterPrimitives>>#primitiveObjectAt */
static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((literalCountOf(thisReceiver)) + LiteralStart)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), longAt((thisReceiver + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
 */

	/* InterpreterPrimitives>>#primitiveObjectAtPut */
static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & 1) == 0)
	 || ((index == ConstOne)
	 && ((newValue & 1) == 0))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 1);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (
#  if IMMUTABILITY
		((longAt(thisReceiver)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	if (!((index > 0)
		 && (index <= ((literalCountOf(thisReceiver)) + LiteralStart)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(thisReceiver, GIV(youngStart))) {
		possibleRootStoreIntovalue(thisReceiver, newValue);
	}
	longAtput((thisReceiver + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord())))), newValue);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	This primitive is called from Squeak as...
	arrayOfRoots uniquelyAccessibleObjects */
/*	This primitive answers an array of the receiver and every object in its
	proper tree of subParts (ie, that is not refered to from anywhere else
	outside the tree).
 */
/*	This primitive could be used to implement the primitiveStoreImageSegment
	segment, thanks to a suggestion from Igor Stassenko. Currently it is
	used only to debug that primitive. */

	/* InterpreterPrimitives>>#primitiveObjectsAccessibleFromRoots */
static void
primitiveObjectsAccessibleFromRoots(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt result;
    char *sp;

	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer));
	if (!(/* isArray: */
			((arrayOfRoots & 1) == 0)
		 && (((((usqInt)((longAt(arrayOfRoots)))) >> (instFormatFieldLSB())) & 15) == 2))) {

		/* Must be indexable pointers */
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = (((usqInt)PrimErrUnsupported << 1) | 1);
	if ((result & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = (result >> 1);
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
}


/*	primitivePathTo: anObject using: stack <Array> followWeak: boolean
	Answer a path to anObject from the root that does not pass through
	the current context */

	/* InterpreterPrimitives>>#primitivePathToUsing */
EXPORT(sqInt)
primitivePathToUsing(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt current;
    sqInt err;
    sqInt fmt;
    usqInt freeStartAtStart;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt iSqInt;
    sqInt next;
    sqInt path;
    char *sp;
    sqInt stack;
    sqInt stackp;
    sqInt stackSize;
    unsigned int sz;
    sqInt toDoLimit;
    sqInt toDoLimitSqInt;

	err = 0;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(GIV(argumentCount) >= 2)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (!(((longAt(GIV(stackPointer))) == GIV(trueObj))
		 || ((longAt(GIV(stackPointer))) == GIV(falseObj)))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	stack = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin pathTo:using:followWeak: */
	if (!(/* isArray: */
			((stack & 1) == 0)
		 && (((((usqInt)((longAt(stack)))) >> (instFormatFieldLSB())) & 15) == 2))) {
		err = PrimErrBadArgument;
		goto l4;
	}
	assert(allObjectsUnmarked());

	/* check no allocations during search */
	freeStartAtStart = GIV(freeStart);
	beRootIfOld(stack);

	/* begin lengthOf: */
	header = longAt(stack);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(stack - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		stackSize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	stackSize = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf: */;

	/* begin mark: */
	/* baseHeader:put: */
	longAtput(stack, (longAt(stack)) | MarkBit);
	current = GIV(specialObjectsOop);

	/* begin mark: */
	/* baseHeader:put: */
	longAtput(current, (longAt(current)) | MarkBit);
	header = longAt(current);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(current - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		index = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l2;
	}
	index = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l2:	/* end lengthOf: */;
	stackp = 0;
	while (1) {
		while (((index -= 1)) >= -1) {
			if (/* couldBeFramePointer: */
				(((((usqInt)current)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)current)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)current)) <= (((usqInt)GIV(pages))))))) {
				next = (index >= 0
							? fieldofFrame(index, ((char *) current))
							: GIV(nilObj));
			}
			else {
				if (index >= 0) {
					next = (((((usqInt)((longAt(current)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex
								? fieldOrSenderFPofContext(index, current)
								: longAt((current + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord()))))));
				}
				else {
					next = /* fetchClassOfNonImm: */
							((ccIndex = (((usqInt)((longAt(current)))) >> (compactClassFieldLSB())) & 0x1F)
								? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
								: (longAt(current - BaseHeaderSize)) & AllButTypeMask);
				}
			}
			if (/* couldBeFramePointer: */
				(((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))) {
				assert(isFrameonPage(((char *) next), stackPageFor(((char *) next))));
			}
			else {
				assert(checkOkayOop(next));
			}
			if (next == (longAt(GIV(stackPointer) + (2 * BytesPerWord)))) {
				assert(freeStartAtStart == (GIV(freeStart)));
				unmarkAfterPathTo();

				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(stack, GIV(youngStart))) {
					possibleRootStoreIntovalue(stack, current);
				}
				longAtput((stack + BaseHeaderSize) + ((((usqInt)(stackp) << (shiftForWord())))), current);
				pruneStackstackp(stack, stackp);
				err = 0;
				goto l4;
			}
			if (((next & 1) == 0)
			 && ((/* couldBeFramePointer: */
				(((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))
					? !(((longAt(next + FoxFrameFlags)) & 2) != 0)
					: (!(((longAt(next)) & MarkBit) != 0))
					 && (((/* isPointers: */
						((next & 1) == 0)
					 && (((((usqInt)((longAt(next)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
					 || (((((usqInt)((longAt(next)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
					 && (((longAt(GIV(stackPointer))) == GIV(trueObj))
					 || (!(((((usqInt)((longAt(next)))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())))))))) {
				if ((stackp + 2) > stackSize) {
					assert(freeStartAtStart == (GIV(freeStart)));
					unmarkAfterPathTo();

					/* begin nilFieldsOf: */
					toDoLimit = (lengthOf(stack)) - 1;
					for (i = 0; i <= toDoLimit; i += 1) {
						/* storePointerUnchecked:ofObject:withValue: */
						longAtput((stack + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
					}
					err = PrimErrBadIndex;
					goto l4;
				}

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((stack + BaseHeaderSize) + ((((usqInt)(stackp) << (shiftForWord())))), current);

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((stack + BaseHeaderSize) + ((((usqInt)((stackp + 1)) << (shiftForWord())))), (((usqInt)index << 1) | 1));
				stackp += 2;
				if (/* couldBeFramePointer: */
					(((((usqInt)(((char *) next)))) & (BytesPerWord - 1)) == 0)
				 && ((((((usqInt)(((char *) next)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) next)))) <= (((usqInt)GIV(pages))))))) {
					/* begin markFrame: */
					longAtput(next + FoxFrameFlags, (longAt(next + FoxFrameFlags)) | 2);
					index = CtxtTempFrameStart + (stackPointerIndexForFrame(((char *) next)));
				}
				else {
					/* begin mark: */
					/* baseHeader:put: */
					longAtput(next, (longAt(next)) | MarkBit);
					if (((((usqInt)((longAt(next)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
						index = (literalCountOf(next)) + LiteralStart;
					}
					else {
						/* begin lengthOf: */
						header = longAt(next);
						fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

						/* begin lengthOf:baseHeader:format: */
						if (header & TypeMask) {
							sz = header & SizeMask;
						}
						else {
							sz = (longAt(next - (BytesPerWord * 2))) & LongSizeMask;
						}
						sz -= 0;
						if (fmt <= 4 /* lastPointerFormat */) {
							index = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
							goto l3;
						}
						index = (fmt < (firstByteFormat())
									? ((usqInt)((sz - BaseHeaderSize))) >> 2
									: (sz - BaseHeaderSize) - (fmt & 3));
l3:	/* end lengthOf: */;
					}
				}
				current = next;
			}
		}
		if (current == GIV(specialObjectsOop)) {
			assert(freeStartAtStart == (GIV(freeStart)));
			unmarkAfterPathTo();

			/* begin nilFieldsOf: */
			toDoLimitSqInt = (lengthOf(stack)) - 1;
			for (iSqInt = 0; iSqInt <= toDoLimitSqInt; iSqInt += 1) {
				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((stack + BaseHeaderSize) + ((((usqInt)(iSqInt) << (shiftForWord())))), GIV(nilObj));
			}
			err = PrimErrNotFound;
			goto l4;
		}
		index = ((longAt((stack + BaseHeaderSize) + ((((usqInt)((stackp - 1)) << (shiftForWord())))))) >> 1);
		current = longAt((stack + BaseHeaderSize) + ((((usqInt)((stackp - 2)) << (shiftForWord())))));
		stackp -= 2;
	}
l4:	/* end pathTo:using:followWeak: */;
	if (err) {
		return (GIV(primFailCode) = err);
	}
	path = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), path);
	GIV(stackPointer) = sp;
	return 0;
}

	/* InterpreterPrimitives>>#primitivePerformInSuperclass */
static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argumentArray;
    int arraySize;
    usqInt ccIndex;
    sqInt currentClass;
    sqInt delta;
    sqInt header;
    sqInt index;
    sqInt lookupClass;
    int offset;
    sqInt performArgCount;
    sqInt rcvr;
    usqInt savedNewMethod;
    sqInt selector;
    char *sp;
    unsigned int sz;
    sqInt top;

	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	lookupClass = longAt(GIV(stackPointer));
	if (GIV(argumentCount) != 3) {

		/* e.g. object:perform:withArguments:inClass: */
		if (GIV(argumentCount) != 4) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
	}
	currentClass = /* fetchClassOf: */
			((rcvr & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask));
	while (currentClass != lookupClass) {
		currentClass = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
		if (currentClass == GIV(nilObj)) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	selector = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	if (!(/* isArray: */
			((argumentArray & 1) == 0)
		 && (((((usqInt)((longAt(argumentArray)))) >> (instFormatFieldLSB())) & 15) == 2))) {
		GIV(performWithArgumentsRecursionGuard) = null;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}

	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask);
	arraySize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(performWithArgumentsRecursionGuard) = null;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l1;
	}

	/* Recursion check:
	   | a |
	   a := Array with: #perform:withArguments: with: nil.
	   a at: 2 put: a.
	   a perform: a first withArguments: a.
	   | a |
	   a := Array with: #perform:withArguments: with: (Array with: #perform:withArguments: with: nil).
	   a last at: 2 put: a.
	   a perform: a first withArguments: a */
	performArgCount = GIV(argumentCount);
	if (!GIV(performWithArgumentsRecursionGuard)) {
		GIV(performWithArgumentsRecursionGuard) = (lookupClass
					? longAt(GIV(stackPointer) + (1 * BytesPerWord))
					: longAt(GIV(stackPointer)));
	}
	savedNewMethod = GIV(newMethod);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp;
	for (index = 1; index <= arraySize; index += 1) {
		arg = longAt((argumentArray + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord())))));
		if (arg == GIV(performWithArgumentsRecursionGuard)) {
			GIV(performWithArgumentsRecursionGuard) = null;
		}

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), arg);
		GIV(stackPointer) = sp;
	}
	if (!GIV(performWithArgumentsRecursionGuard)) {
		/* begin pop: */
		GIV(stackPointer) += (2 + arraySize) * BytesPerWord;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;

	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), /* #fetchClassTagOf: #fetchClassOf: */
		((rcvr & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)));
	if (
#  if SEND_PRINTING
		GIV(printSends)
#  else
		0
#  endif
		) {
		printActivationNameForSelectorstartClass(GIV(messageSelector), (lookupClass
				? lookupClass
				: /* fetchClassOf: */
					((rcvr & 1)
						? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
						: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
								? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
								: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask))));
		cr();
	}
	findNewMethodInClassTag((lookupClass
			? lookupClass
			: /* #fetchClassTagOf: #fetchClassOf: */
				((rcvr & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask))));
	if ((/* isOopCompiledMethod: */
		((GIV(newMethod) & 1) == 0)
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
				? rcvr
				: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);

		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;

		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(performWithArgumentsRecursionGuard) = null;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l1;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	if ((primitiveFunctionPointer == primitivePerformWithArgs)
	 || (primitiveFunctionPointer == primitivePerformInSuperclass)) {

		/* This should of course be a tail call, which could be done via setjmp/longjmp.
		   But this is vanity code. After all how often is a recursive invocation of
		   primitivePerformWithArgs et al made? */
		GIV(newMethod) = savedNewMethod;
		GIV(argumentCount) = performArgCount;

		/* begin pop: */
		GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
		slowPrimitiveResponse();
		GIV(performWithArgumentsRecursionGuard) = null;
		goto l1;
	}
	GIV(performWithArgumentsRecursionGuard) = null;

	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	executeNewMethod();

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l1:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePerformWithArgs */
static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualReceiver;
    sqInt arg;
    sqInt argumentArray;
    int arraySize;
    usqInt ccIndex;
    sqInt delta;
    sqInt header;
    sqInt index;
    int offset;
    sqInt performArgCount;
    usqInt savedNewMethod;
    sqInt selector;
    char *sp;
    unsigned int sz;
    sqInt top;

	actualReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	selector = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer));

	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	if (!(/* isArray: */
			((argumentArray & 1) == 0)
		 && (((((usqInt)((longAt(argumentArray)))) >> (instFormatFieldLSB())) & 15) == 2))) {
		GIV(performWithArgumentsRecursionGuard) = null;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}

	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask);
	arraySize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(performWithArgumentsRecursionGuard) = null;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l1;
	}

	/* Recursion check:
	   | a |
	   a := Array with: #perform:withArguments: with: nil.
	   a at: 2 put: a.
	   a perform: a first withArguments: a.
	   | a |
	   a := Array with: #perform:withArguments: with: (Array with: #perform:withArguments: with: nil).
	   a last at: 2 put: a.
	   a perform: a first withArguments: a */
	performArgCount = GIV(argumentCount);
	if (!GIV(performWithArgumentsRecursionGuard)) {
		GIV(performWithArgumentsRecursionGuard) = longAt(GIV(stackPointer));
	}
	savedNewMethod = GIV(newMethod);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp;
	for (index = 1; index <= arraySize; index += 1) {
		arg = longAt((argumentArray + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord())))));
		if (arg == GIV(performWithArgumentsRecursionGuard)) {
			GIV(performWithArgumentsRecursionGuard) = null;
		}

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), arg);
		GIV(stackPointer) = sp;
	}
	if (!GIV(performWithArgumentsRecursionGuard)) {
		/* begin pop: */
		GIV(stackPointer) += (2 + arraySize) * BytesPerWord;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;

	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), /* #fetchClassTagOf: #fetchClassOf: */
		((actualReceiver & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(actualReceiver)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(actualReceiver - BaseHeaderSize)) & AllButTypeMask)));
	if (
#  if SEND_PRINTING
		GIV(printSends)
#  else
		0
#  endif
		) {
		printActivationNameForSelectorstartClass(GIV(messageSelector), /* fetchClassOf: */
			((actualReceiver & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(actualReceiver)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(actualReceiver - BaseHeaderSize)) & AllButTypeMask)));
		cr();
	}
	findNewMethodInClassTag(/* #fetchClassTagOf: #fetchClassOf: */
		((actualReceiver & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(actualReceiver)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(actualReceiver - BaseHeaderSize)) & AllButTypeMask)));
	if ((/* isOopCompiledMethod: */
		((GIV(newMethod) & 1) == 0)
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */
		assert((stackTop()) == ((arraySize == 0
				? actualReceiver
				: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);

		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;

		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(performWithArgumentsRecursionGuard) = null;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l1;
	}

	/* +2 = receiver + saved newMethod */
	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	if ((primitiveFunctionPointer == primitivePerformWithArgs)
	 || (primitiveFunctionPointer == primitivePerformInSuperclass)) {

		/* This should of course be a tail call, which could be done via setjmp/longjmp.
		   But this is vanity code. After all how often is a recursive invocation of
		   primitivePerformWithArgs et al made? */
		GIV(newMethod) = savedNewMethod;
		GIV(argumentCount) = performArgCount;

		/* begin pop: */
		GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
		slowPrimitiveResponse();
		GIV(performWithArgumentsRecursionGuard) = null;
		goto l1;
	}
	GIV(performWithArgumentsRecursionGuard) = null;

	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	executeNewMethod();

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l1:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePinnedNew */
static void
primitivePinnedNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}


/*	Allocate a new pinned indexable instance. Fail if the allocation would
	leave less than lowSpaceThreshold bytes free.
 */

	/* InterpreterPrimitives>>#primitivePinnedNewWithArg */
static void
primitivePinnedNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt oop;
    usqIntptr_t size;
    sqInt value;

	oop = longAt(GIV(stackPointer));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l2;
		}
		size = value;
		goto l2;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l2;
	}
	size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

	/* InterpreterPrimitives>>#primitiveProfilePrimitive */
EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
	return 0;
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

	/* InterpreterPrimitives>>#primitiveProfileSample */
EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
	return 0;
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

	/* InterpreterPrimitives>>#primitiveProfileSemaphore */
EXPORT(sqInt)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt sema;

	if (!(GIV(argumentCount) == 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	sema = longAt(GIV(stackPointer));
	if (!((sema == GIV(nilObj))
		 || (/* isSemaphoreOop: */
			((sema & 1) == 0)
		 && ((/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(sema)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(sema - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord())))))))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	GIV(profileSemaphore) = sema;
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	return 0;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

	/* InterpreterPrimitives>>#primitiveProfileStart */
EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;

	deltaTicks = longAt(GIV(stackPointer));
	if ((deltaTicks & 1)) {
		GIV(nextProfileTick) = (ioHighResClock()) + ((deltaTicks >> 1));

		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		return 0;
	}
	return (GIV(primFailCode) = PrimErrBadArgument);
}

	/* InterpreterPrimitives>>#primitiveQuit */
static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
			? ((longAt(GIV(stackPointer))) >> 1)
			: 0));
}


/*	Rounds negative results towards zero. */

	/* InterpreterPrimitives>>#primitiveQuo */
static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	integerResult = 0;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		integerArg = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
	}

	/* begin success: */
	if (!integerArg) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		integerResult = /* quot:ient: */
				(integerRcvr > 0
					? (integerArg > 0
							? integerRcvr / integerArg
							: 0 - (integerRcvr / (0 - integerArg)))
					: (integerArg > 0
							? 0 - ((0 - integerRcvr) / integerArg)
							: (0 - integerRcvr) / (0 - integerArg)));
	}

	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ (((((usqInt)integerResult)) << 1))))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveQuoLargeIntegers */
EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!b) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

	/* InterpreterPrimitives>>#primitiveRelinquishProcessor */
static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
	}
	if (!GIV(primFailCode)) {

		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */
		if (!GIV(nextProfileTick)) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveRemLargeIntegers */
EXPORT(void)
primitiveRemLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!b) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

	/* InterpreterPrimitives>>#primitiveResume */
static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt proc;

	/* rcvr */
	/* Alas in Spur we need a read barrier */
	proc = longAt(GIV(stackPointer));

	/* written this way to get better Slang inlining */
	ctxt = longAt((proc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!(/* isContext: */
			((ctxt & 1) == 0)
		 && (((((usqInt)((longAt(ctxt)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	resumepreemptedYieldingIf(proc, GIV(preemptionYields));
}


/*	Primitive. Answer the nth element of the root table.
	This primitive avoids the creation of an extra array;
	it is intended for enumerations of the form:
	index := 1.
	[root := Smalltalk rootTableAt: index.
	root == nil] whileFalse:[index := index + 1].
	 */

	/* InterpreterPrimitives>>#primitiveRootTableAt */
EXPORT(sqInt)
primitiveRootTableAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt successBoolean;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	successBoolean = (index > 0)
		 && (index <= GIV(rootTableCount));

	/* begin success: */
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(rootTable)[index]);
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	The character scanner primitive. */

	/* InterpreterPrimitives>>#primitiveScanCharacters */
static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
	}
	stops = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((integerPointer & 1)) {
		scanRightX = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
	}
	sourceString = longAt(GIV(stackPointer) + (3 * BytesPerWord));

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	if ((integerPointer & 1)) {
		scanStopIndex = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	if ((integerPointer & 1)) {
		scanStartIndex = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
	}
	rcvr = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if (GIV(primFailCode)) {
		return;
	}
	if (!((/* isArray: */
			((stops & 1) == 0)
		 && (((((usqInt)((longAt(stops)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((slotSizeOf(stops)) >= 258)
		 && ((/* isBytes: */
			((sourceString & 1) == 0)
		 && (((((usqInt)((longAt(sourceString)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
		 && ((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && ((scanStopIndex <= (byteSizeOf(sourceString)))
		 && ((/* isPointers: */
			((rcvr & 1) == 0)
		 && (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && ((slotSizeOf(rcvr)) >= 4))))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2U << (shiftForWord())));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3U << (shiftForWord())));
	if (!((/* isArray: */
			((scanXTable & 1) == 0)
		 && (((((usqInt)((longAt(scanXTable)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((/* isArray: */
			((scanMap & 1) == 0)
		 && (((((usqInt)((longAt(scanMap)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (((slotSizeOf(scanMap)) == 0x100)
		 && (!GIV(primFailCode)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */
	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */
		/* Known to be okay since stops size >= 258 */
		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + ((((usqInt)(ascii) << (shiftForWord()))))))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */
			if (!((((sqInt)((((usqInt)scanDestX)) ^ (((((usqInt)scanDestX)) << 1))))) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}

			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanDestX)) ^ (((((usqInt)scanDestX)) << 1))))) >= 0) {
				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}

			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanLastIndex)) ^ (((((usqInt)scanLastIndex)) << 1))))) >= 0) {
				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (6 * BytesPerWord)), stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */
		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */
		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */
			if (!((((sqInt)((((usqInt)scanDestX)) ^ (((((usqInt)scanDestX)) << 1))))) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}

			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanDestX)) ^ (((((usqInt)scanDestX)) << 1))))) >= 0) {
				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}

			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)((((usqInt)scanLastIndex)) ^ (((((usqInt)scanLastIndex)) << 1))))) >= 0) {
				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}

			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + (6 * BytesPerWord)), longAt((stops + BaseHeaderSize) + ((((usqInt)((CrossedX - 1)) << (shiftForWord()))))));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((((sqInt)((((usqInt)scanDestX)) ^ (((((usqInt)scanDestX)) << 1))))) >= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((((usqInt)scanDestX)) ^ (((((usqInt)scanDestX)) << 1))))) >= 0) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((rcvr + BaseHeaderSize) + (0U << (shiftForWord())), (((usqInt)scanDestX << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}

	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((((usqInt)scanStopIndex)) ^ (((((usqInt)scanStopIndex)) << 1))))) >= 0) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((rcvr + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)scanStopIndex << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (6 * BytesPerWord)), longAt((stops + BaseHeaderSize) + ((((usqInt)((EndOfRun - 1)) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

	/* InterpreterPrimitives>>#primitiveScreenDepth */
EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)depth << 1) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Answer a float indicating the current scale factor for pixels of the
	Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveScreenScaleFactor */
EXPORT(sqInt)
primitiveScreenScaleFactor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double factor;
    char *sp;

	factor = ioScreenScaleFactor();
	if (!GIV(primFailCode)) {
		/* begin methodReturnFloat: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), floatObjectOf(factor));
		GIV(stackPointer) = sp;
	}
	return 0;
}


/*	Answer a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the
	point is encoded into a single 32bit value in the image header.
	This might well become a problem one day */

	/* InterpreterPrimitives>>#primitiveScreenSize */
static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;

	pointWord = ioScreenSize();

	/* begin makePointwithxValue:yValue: */
	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + ((((usqInt)(XIndex) << (shiftForWord())))), ((((((usqInt)(pointWord)) >> 16) & 0xFFFF) << 1) | 1));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + ((((usqInt)(YIndex) << (shiftForWord())))), (((pointWord & 0xFFFF) << 1) | 1));
	oop = pointResult;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

	/* InterpreterPrimitives>>#primitiveSecondsClock */
static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt oop;
    char *sp;

	integerValue = ioSecondsNow();

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		oop = ((integerValue << 1) | 1);
		goto l1;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
	oop = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Ask the GUI to set the requested display mode.
	See DisplayScreen class depth:width:height:fullscreen: */

	/* InterpreterPrimitives>>#primitiveSetDisplayMode */
static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt okay;
    char *sp;
    sqInt w;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}

	/* begin success: */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	fsFlag = null;
l1:	/* end booleanValueOf: */;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((integerPointer & 1)) {
		w = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((integerPointer & 1)) {
		d = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
	}
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	okay = ioSetDisplayMode(w, h, d, fsFlag);
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}

	/* begin methodReturnBool: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(okay
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

	/* InterpreterPrimitives>>#primitiveSetFullScreen */
static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin setFullScreenFlag: */
		GIV(fullScreenFlag) = argOop == GIV(trueObj);
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Indicate if the GC logic should have bias to grow */

	/* InterpreterPrimitives>>#primitiveSetGCBiasToGrow */
EXPORT(sqInt)
primitiveSetGCBiasToGrow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;
    sqInt integerPointer;


	/* for now... */
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		flag = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		flag = 0;
	}
	if (!GIV(primFailCode)) {
		/* gcBiasToGrow: */
		GIV(gcBiasToGrow) = flag;

		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Primitive. If the GC logic has bias to grow, set growth limit */

	/* InterpreterPrimitives>>#primitiveSetGCBiasToGrowGCLimit */
EXPORT(sqInt)
primitiveSetGCBiasToGrowGCLimit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    sqInt integerPointer;
    sqInt value;


	/* for now... */
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
	}
	if (!GIV(primFailCode)) {
		/* gcBiasToGrowGCLimit: */
		GIV(gcBiasToGrowGCLimit) = value;
		aValue = (GIV(youngStart)) - (((sqInt)(startOfMemory())));

		/* begin gcBiasToGrowThreshold: */
		GIV(gcBiasToGrowThreshold) = aValue;
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveSetImmutability */
#if IMMUTABILITY
static void
primitiveSetImmutability(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt processLists;
    sqInt rcvr;
    sqInt scheduler;
    char *sp;
    sqInt wasImmutable;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	wasImmutable = 
#    if IMMUTABILITY
			((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#    else
			0
#    endif
			;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		/* begin canBeImmutable: */
		assert(isNonImmediate(rcvr));
		if (/* isContext: */
			((rcvr & 1) == 0)
		 && (((((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			goto l1;
		}
		if (isEphemeron(rcvr)) {
			goto l1;
		}
		if (((((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
			goto l1;
		}
		if ((/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord()))))))) {
			goto l1;
		}

		/* begin fetchPointer:ofObject: */
		scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
		processLists = longAt((scheduler + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));
		if (rcvr == scheduler) {
			goto l1;
		}
		if (rcvr == processLists) {
			goto l1;
		}
		if ((classIndexOf(longAt((processLists + BaseHeaderSize) + (1U << (shiftForWord()))))) == (classIndexOf(rcvr))) {
			goto l1;
		}
		if ((classIndexOf(longAt((scheduler + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord()))))))) == (classIndexOf(rcvr))) {
			goto l1;
		}
		goto l2;
l1:;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
l2:;
		setIsImmutableOfto(rcvr, 1);
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			setIsImmutableOfto(rcvr, 0);
		}
		else {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(wasImmutable
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
}
#endif /* IMMUTABILITY */


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

	/* InterpreterPrimitives>>#primitiveSetInterruptKey */
static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
	}
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

	/* InterpreterPrimitives>>#primitiveSetLogDirectory */
EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(/* isBytes: */
			((stringOop & 1) == 0)
		 && (((((usqInt)((longAt(stringOop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}

	/* begin byteSizeOf: */
	if ((stringOop & 1)) {
		sz = 0;
		goto l1;
	}
	sz = numBytesOf(stringOop);
l1:	/* end byteSizeOf: */;
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}

	/* InterpreterPrimitives>>#primitiveSetOrHasIdentityHash */
static void
primitiveSetOrHasIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasHash;
    sqInt hash;
    sqInt isReceiverAClass;
    sqInt lastArg;
    usqInt oldHash;
    char *sp;
    sqInt thisReceiver;

	if (!GIV(argumentCount)) {
		hasHash = ((longAt(GIV(stackPointer))) & 1) == 0;

		/* begin methodReturnBool: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
			(hasHash
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	isReceiverAClass = 0;
	if (GIV(argumentCount) == 2) {
		lastArg = longAt(GIV(stackPointer));
		if ((lastArg & 1)) {

			/* e.g. Symbol primitiveSetIdentityHashOf: aSymbol to: hash */
			hash = lastArg;
			thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		}
		else {

			/* anObject primitiveSetIdentityHash: hashValue isBehavior: boolean */
			thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
			hash = longAt(GIV(stackPointer) + (1 * BytesPerWord));
			if (lastArg == GIV(trueObj)) {
				isReceiverAClass = 1;
			}
			else {
				if (!(lastArg == GIV(falseObj))) {
					/* primitiveFailFor: */
					GIV(primFailCode) = PrimErrBadArgument;
					return;
				}
			}
		}
	}
	else {

		/* anObject primitiveSetIdentityHashTo: hash */
		thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		hash = longAt(GIV(stackPointer));
	}
	if (!(((hash & 1))
		 && ((/* if written naturally, clang warns: unsequenced modification and access to 'hash' */
			(hash = (hash >> 1)),
		(hash & HashMaskUnshifted) == hash)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (thisReceiver & 1) {
		/* primitiveFailFor: */
		GIV(primFailCode) = (thisReceiver == (longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord)))
					? PrimErrBadReceiver
					: PrimErrBadArgument);
		return;
	}
	oldHash = (((usqInt)((longAt(thisReceiver)))) >> HashBitsOffset) & HashMaskUnshifted;

	/* begin setHashBitsOf:to: */
	longAtput(thisReceiver, ((((longAt(thisReceiver)) | HashBits) - HashBits)) | (((hash & HashMaskUnshifted) << HashBitsOffset)));

	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((oldHash << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Set the OS window's label */

	/* InterpreterPrimitives>>#primitiveSetWindowLabel */
EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt labelOop;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(/* isBytes: */
			((labelOop & 1) == 0)
		 && (((((usqInt)((longAt(labelOop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}

	/* begin byteSizeOf: */
	if ((labelOop & 1)) {
		sz = 0;
		goto l1;
	}
	sz = numBytesOf(labelOop);
l1:	/* end byteSizeOf: */;
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveSetWindowSize */
EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		w = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
	}
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);

		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	return 0;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as
	an array of signed 16-bit values. Answer the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word.  */

	/* InterpreterPrimitives>>#primitiveShortAt */
static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(/* isWordsOrBytes: */
			((rcvr & 1) == 0)
		 && (isWordsOrBytesNonImm(rcvr)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 1);
	if (!((index >= 1)
		 && (index <= (((usqInt)((numBytesOf(rcvr)))) >> 1)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	value = shortAt((rcvr + BaseHeaderSize) + ((((usqInt)((index - 1)) << 1))));

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

	/* InterpreterPrimitives>>#primitiveShortAtPut */
static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((value & 1))
		 && (((index & 1))
		 && (((value = (value >> 1)),
		(value >= -32768)
			 && (value <= 0x7FFF)))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(/* isWordsOrBytes: */
			((rcvr & 1) == 0)
		 && (isWordsOrBytesNonImm(rcvr)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	index = (index >> 1);
	if (!((index >= 1)
		 && (index <= (((usqInt)((numBytesOf(rcvr)))) >> 1)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* storeShort16:ofObject:withValue: */
	shortAtput((rcvr + BaseHeaderSize) + ((((usqInt)((index - 1)) << 1))), value);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), (((usqInt)value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

	/* InterpreterPrimitives>>#primitiveShowDisplayRect */
static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		top = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((integerPointer & 1)) {
		right = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((integerPointer & 1)) {
		left = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
	}
	if (!GIV(primFailCode)) {
		updateDisplayLeftTopRightBottom(left, top, right, bottom);
		ioForceDisplayUpdate();

		/* begin methodReturnReceiver */
		assert(!((failed())));
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveSignal */
static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	synchronousSignal(longAt(GIV(stackPointer)));
}


/*	Set the low-water mark for free space. When the free space falls
	below this level, the new and new: primitives fail and system attempts
	to allocate space (e.g., to create a method context) cause the low-space
	semaphore (if one is registered) to be signalled. */

	/* InterpreterPrimitives>>#primitiveSignalAtBytesLeft */
static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;

	bytes = longAt(GIV(stackPointer));
	if (((bytes & 1))
	 && (((bytes = (bytes >> 1))) >= 0)) {
		/* lowSpaceThreshold: */
		GIV(lowSpaceThreshold) = bytes;

		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Computes sine of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveSine */
static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	aValue = floatObjectOf(sin(doubleValue));

	/* begin stackTopPut: */
	longAtPointerput(GIV(stackPointer), aValue);
}

	/* InterpreterPrimitives>>#primitiveSize */
static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt rcvr;
    char *sp;
    unsigned int sz;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if (((rcvr & 1))
	 || (((hdr = longAt(rcvr)),
	((fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15)) < (arrayFormat())))) {

		/* And if Spur, this is a forwarder. */
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		primitiveContextSize();
		return;
	}

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;

	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(totalLength - fixedFields) << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Save a normal snapshot under the same name as it was loaded unless it has
	been renamed by the last primitiveImageName.
	Note that when executed this primitive answers false, but when the
	resulting image is run afresh, the primitive answers true.
 */

	/* InterpreterPrimitives>>#primitiveSnapshot */
static void
primitiveSnapshot(void)
{
	snapshot(0);
}


/*	save an embedded snapshot */

	/* InterpreterPrimitives>>#primitiveSnapshotEmbedded */
static void
primitiveSnapshotEmbedded(void)
{
	snapshot(1);
}

	/* InterpreterPrimitives>>#primitiveSomeInstance */
static void
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt header;
    sqInt instance;
    sqInt obj;
    char *sp;
    unsigned int sz;
    sqInt thisClass;
    sqInt thisObj;

	class = longAt(GIV(stackPointer));

	/* begin initialInstanceOf: */
	/* begin firstAccessibleObject */
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			thisObj = obj;
			goto l1;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	thisObj = null;
l1:	/* end firstAccessibleObject */;
	while (!(thisObj == null)) {
		thisClass = /* fetchClassOf: */
				((thisObj & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(thisObj)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(thisObj - BaseHeaderSize)) & AllButTypeMask));
		if (thisClass == class) {
			instance = thisObj;
			goto l3;
		}

		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(thisObj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(thisObj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(thisObj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(thisObj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(thisObj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (thisObj + sz) + (headerTypeBytes[(longAt(thisObj + sz)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				thisObj = obj;
				goto l2;
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		thisObj = null;
l2:	/* end accessibleObjectAfter: */;
	}
	instance = null;
l3:	/* end initialInstanceOf: */;
	if (instance) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Return the first object in the heap. */

	/* InterpreterPrimitives>>#primitiveSomeObject */
static void
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt obj;
    sqInt object;
    char *sp;
    unsigned int sz;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;

	/* begin firstAccessibleObject */
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			object = obj;
			goto l1;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	object = null;
l1:	/* end firstAccessibleObject */;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

	/* InterpreterPrimitives>>#primitiveSpecialObjectsOop */
static void
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}


/*	Computes square root of float receiver; receiver *must* be a float
	instance. 
 */

	/* InterpreterPrimitives>>#primitiveSquareRoot */
static void
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aValue;
    double doubleValue;
    sqInt rcvr;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	if (doubleValue >= 0.0) {
		aValue = floatObjectOf(sqrt(doubleValue));

		/* begin stackTopPut: */
		longAtPointerput(GIV(stackPointer), aValue);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* InterpreterPrimitives>>#primitiveStoreImageSegment */
static void
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Essential type checks */
	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((/* isArray: */
			((arrayOfRoots & 1) == 0)
		 && (((((usqInt)((longAt(arrayOfRoots)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((/* isArray: */
			((outPointerArray & 1) == 0)
		 && (((((usqInt)((longAt(outPointerArray)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (/* isWords: */
			((segmentWordArray & 1) == 0)
		 && (((((usqInt)((longAt(segmentWordArray)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat())))))) {

		/* Must be indexable words */
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ecode = storeImageSegmentIntooutPointersroots(segmentWordArray, outPointerArray, arrayOfRoots);
	if (ecode) {
		/* primitiveFailFor: */
		GIV(primFailCode) = ecode;
	}
	else {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveStringAt */
static void
primitiveStringAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt rcvr;
    sqInt result;
    char *sp;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt stSize;
    unsigned int sz;
    sqInt totalLength;

	/* begin commonAt: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l5;
	}
	if (((index & 1) == 0)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l5;
	}
	index = (index >> 1);

	/* begin stObject:at: */
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(rcvr)));
			stSize = spUsqInt;
			goto l3;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l3;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(rcvr)));
		stSize = (spSqInt >> 1);
l3:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = temporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l4;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
		(fmt >= (firstCompiledMethodFormat())
			? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			result = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l4;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l4;
		}
		integerValue = long32At((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			result = ((integerValue << 1) | 1);
			goto l4;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		result = newLargeInteger;
		goto l4;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = (fmt <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
	result = 0;
l4:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		if (!(((result >= 0) && (result <= 0xFF)))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			goto l5;
		}
		result = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CharacterTable) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(((result >> 1))) << (shiftForWord())))));

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l5:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveStringAtPut */
static void
primitiveStringAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt stSize;
    unsigned int sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;
    sqInt value;
    sqInt valueSqInt;

	/* begin commonAtPut: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		goto l11;
	}
	if (((index & 1) == 0)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l11;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l11;
	}
	index = (index >> 1);
	valueSqInt = asciiOfCharacter(value);

	/* begin stObject:at:put: */
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(rcvr)));
			stSize = spUsqInt;
			goto l4;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(rcvr)));
		stSize = (spSqInt >> 1);
l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			temporaryinput(index - 1, frameOfMarriedContext(rcvr), valueSqInt);
			goto l5;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
		(fmt >= (firstCompiledMethodFormat())
			? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, valueSqInt);
			}
			longAtput((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), valueSqInt);
			goto l2;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((valueSqInt & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}
			signedValueToStore = (valueSqInt >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}

			/* storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l2;
		}
		unsignedValueToStore = positive32BitValueOf(valueSqInt);
		if (!GIV(primFailCode)) {
			/* storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
l2:	/* end subscript:with:storing:format: */;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = (fmt <= 1
					? PrimErrBadReceiver
					: PrimErrBadIndex);
	}
l5:	/* end stObject:at:put: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l11:	/* end commonAtPut: */;
}


/*	<array> primReplaceFrom: start to: stop with: replacement startingAt:
	repStart 
	<primitive: 105> */

	/* InterpreterPrimitives>>#primitiveStringReplace */
static void
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    usqInt arrayFmt;
    sqInt arrayInstSize;
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt hdr;
    sqInt i;
    sqInt integerPointer;
    sqInt repl;
    usqInt replFmt;
    sqInt replInstSize;
    sqInt replStart;
    sqInt srcIndex;
    sqInt start;
    sqInt stop;
    unsigned int sz;
    sqInt totalLength;
    sqInt valuePointer;

	/* begin primitiveV3StringReplace */
	array = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((integerPointer & 1)) {
		start = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		start = 0;
	}

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if ((integerPointer & 1)) {
		stop = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stop = 0;
	}
	repl = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		replStart = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		replStart = 0;
	}
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l5;
	}
	if ((repl & 1)) {

		/* can happen in LgInt copy */
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l5;
	}
	if ((stop >= start)
	 && (
#  if IMMUTABILITY
		((longAt(array)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		goto l5;
	}
	hdr = longAt(array);
	arrayFmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (arrayFmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (arrayFmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (arrayFmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt > 4 /* lastPointerFormat */)
	 || (arrayFmt == (arrayFormat()))) {
		arrayInstSize = 0;
		goto l3;
	}
	if (arrayFmt < 2) {
		arrayInstSize = totalLength;
		goto l3;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(array)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(array - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	arrayInstSize = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && ((stop + arrayInstSize) <= totalLength)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l5;
	}
	hdr = longAt(repl);
	replFmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(repl - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (replFmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l2;
	}
	totalLength = (replFmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (replFmt & 3));
l2:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((replFmt > 4 /* lastPointerFormat */)
	 || (replFmt == (arrayFormat()))) {
		replInstSize = 0;
		goto l4;
	}
	if (replFmt < 2) {
		replInstSize = totalLength;
		goto l4;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(repl)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(repl - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	replInstSize = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart >= 1)
		 && ((((stop - start) + replStart) + replInstSize) <= totalLength))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		goto l5;
	}
	if (arrayFmt < (firstByteFormat())) {
		if (!(arrayFmt == replFmt)) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			goto l5;
		}
	}
	else {
		if (!((arrayFmt & 12 /* byteFormatMask */) == (replFmt & 12 /* byteFormatMask */))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrInappropriate;
			goto l5;
		}
	}

	/* - 1 for 0-based access */
	srcIndex = (replStart + replInstSize) - 1;
	if (arrayFmt <= 4 /* lastPointerFormat */) {
		for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
			valuePointer = longAt((repl + BaseHeaderSize) + ((((usqInt)(srcIndex) << (shiftForWord())))));

			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(array, GIV(youngStart))) {
				possibleRootStoreIntovalue(array, valuePointer);
			}
			longAtput((array + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), valuePointer);
			srcIndex += 1;
		}
	}
	else {
		if (arrayFmt < (firstByteFormat())) {

			/* 32-bit-word type objects */
			for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
				/* storeLong32:ofObject:withValue: */
				long32Atput((array + BaseHeaderSize) + ((((usqInt)(i) << 2))), long32At((repl + BaseHeaderSize) + ((((usqInt)(srcIndex) << 2)))));
				srcIndex += 1;
			}
		}
		else {

			/* byte-type objects */
			for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
				/* storeByte:ofObject:withValue: */
				byteAtput((array + BaseHeaderSize) + i, byteAt((repl + BaseHeaderSize) + srcIndex));
				srcIndex += 1;
			}
		}
	}

	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
l5:	/* end primitiveV3StringReplace */;
}

	/* InterpreterPrimitives>>#primitiveSubtract */
static void
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));

	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)((((usqInt)integerResult)) ^ (((((usqInt)integerResult)) << 1))))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), (((usqInt)integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveSubtractLargeIntegers */
EXPORT(void)
primitiveSubtractLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative != bIsNegative) {

		/* Protect against overflow */
		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveTestAndSetOwnershipOfCriticalSection */
static void
primitiveTestAndSetOwnershipOfCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt oop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;

	if (GIV(argumentCount) > 0) {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {
		/* rcvr */
		criticalSection = longAt(GIV(stackPointer));

		/* begin activeProcess */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	}

	/* CriticalSections are laid out like Semaphores */
	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + ((((usqInt)(owningProcessIndex) << (shiftForWord())))));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(criticalSection, GIV(youngStart))) {
			possibleRootStoreIntovalue(criticalSection, activeProc);
		}
		longAtput((criticalSection + BaseHeaderSize) + ((((usqInt)(owningProcessIndex) << (shiftForWord())))), activeProc);

		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
	GIV(stackPointer) = sp;
}


/*	Return true if the host OS does support the given display depth. */

	/* InterpreterPrimitives>>#primitiveTestDisplayDepth */
static void
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	okay = 0;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		bitsPerPixel = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
	}
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(okay
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Given an object with indexable pointer fields, reduce the size of the
	indexable fields
	to the requested size. Answer the number of bytes freed, or zero if the
	object cannot
	be shortened.
 */

	/* InterpreterPrimitives>>#primitiveTestShortenIndexableSize */
#if TestingPrimitives
EXPORT(sqInt)
primitiveTestShortenIndexableSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt integer;
    sqInt newSizeOop;
    char *sp;

	newSizeOop = longAt(GIV(stackPointer));
	array = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((newSizeOop & 1))
		 && (((((newSizeOop >> 1)) >= 0) && (((newSizeOop >> 1)) <= ((stSizeOf(array)) - 1)))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	if (!(canShorten(array))) {
		return (GIV(primFailCode) = PrimErrBadReceiver);
	}
	integer = shortentoIndexableSize(array, (newSizeOop >> 1));

	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 1) | 1));
	GIV(stackPointer) = sp;
	return 0;
}
#endif /* TestingPrimitives */


/*	Multiply the receiver by the power of the argument.
	Receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveTimesTwoPower */
static void
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aFloatOop;
    sqInt arg;
    double rcvr;
    double result;
    char *sp;

	arg = longAt(GIV(stackPointer));
	if (!((arg & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	arg = (arg >> 1);
	aFloatOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(aFloatOop));
	fetchFloatAtinto(aFloatOop + BaseHeaderSize, rcvr);
	result = ldexp(rcvr, ((int) arg));

	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), floatObjectOf(result));
	GIV(stackPointer) = sp;
}


/*	Integral part of float receiver; receiver *must* be a float instance. */

	/* InterpreterPrimitives>>#primitiveTruncated */
static void
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double doubleValue;
    sqInt rcvr;
    double trunc;

	rcvr = longAt(GIV(stackPointer));

	/* begin noFailFloatValueOf: */
	assert(isFloatInstance(rcvr));
	fetchFloatAtinto(rcvr + BaseHeaderSize, doubleValue);
	if (!GIV(primFailCode)) {
		modf(doubleValue, (&trunc));
		if (((trunc >= (((double) (MinSmallInteger) ))) && (trunc <= (((double) (MaxSmallInteger) ))))) {
			/* stackTopPut: */
			longAtPointerput(GIV(stackPointer), (((usqInt)(((sqInt)trunc)) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveUninitializedNewWithArg */
static void
primitiveUninitializedNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    int ok;
    sqInt oop;
    usqIntptr_t size;
    sqInt value;

	oop = longAt(GIV(stackPointer));

	/* begin positiveMachineIntegerValueOf: */
	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l2;
		}
		size = value;
		goto l2;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	bs = numBytesOfBytes(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		size = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)))));
		goto l2;
	}
	size = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

	/* InterpreterPrimitives>>#primitiveUpdateTimezone */
static void
primitiveUpdateTimezone(void)
{
	ioUpdateVMTimezone();
}


/*	Return the value of the microsecond clock in UTC as an integer.
	This is the number of microseconds since the Smalltalk epoch, 1901/1/1
	12:00am. The microsecond clock is at least 60 bits wide which means it'll
	get to around August
	38435 before it wraps around. Be sure to put it on your calendar. This
	primitive accesses the time as answered by the OS. */

	/* InterpreterPrimitives>>#primitiveUTCMicrosecondClock */
static void
primitiveUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	oop = positive64BitIntegerFor(ioUTCMicrosecondsNow());

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Smalltalk epoch and the
	current seconds offset from GMT in the local time zone. Any pointer object
	with two or more slots) may be supplied as a parameter. */

	/* InterpreterPrimitives>>#primitiveUtcAndTimezoneOffset */
static void
primitiveUtcAndTimezoneOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadNumArgs;
			return;
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((/* isPointers: */
				((resultArray & 1) == 0)
			 && (((((usqInt)((longAt(resultArray)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			 && ((lengthOf(resultArray)) >= 2))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	else {
		resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), 2);
	}
	valuePointer = (((usqInt)(ioLocalSecondsOffset()) << 1) | 1);

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	valuePointer = positive64BitIntegerFor(ioUTCMicroseconds());

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(resultArray, GIV(youngStart))) {
		possibleRootStoreIntovalue(resultArray, valuePointer);
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Posix epoch and the
	current seconds offset from GMT in the local time zone. An empty two
	element array (or any object with two or more slots) may be supplied
	as a parameter.
	This is a named (not numbered) primitive in the null module (ie the VM) */

	/* InterpreterPrimitives>>#primitiveUtcWithOffset */
EXPORT(sqInt)
primitiveUtcWithOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static usqLong epochDelta = 2177452800000000ULL;
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;

	if (GIV(argumentCount) > 0) {
		if (GIV(argumentCount) > 1) {
			return (GIV(primFailCode) = PrimErrBadNumArgs);
		}
		resultArray = longAt(GIV(stackPointer));
		if (!((/* isPointers: */
				((resultArray & 1) == 0)
			 && (((((usqInt)((longAt(resultArray)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			 && ((lengthOf(resultArray)) >= 2))) {
			return (GIV(primFailCode) = PrimErrBadArgument);
		}
	}
	else {
		resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), 2);
	}
	valuePointer = (((usqInt)(ioLocalSecondsOffset()) << 1) | 1);

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((resultArray + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	valuePointer = positive64BitIntegerFor((ioUTCMicrosecondsNow()) - epochDelta);

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(resultArray, GIV(youngStart))) {
		possibleRootStoreIntovalue(resultArray, valuePointer);
	}
	longAtput((resultArray + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
	return 0;
}


/*	Return a string containing the path name of VM's directory. */

	/* InterpreterPrimitives>>#primitiveVMPath */
static void
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord()))))), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

	/* InterpreterPrimitives>>#primitiveVMProfileSamplesInto */
static void
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt numSamples;
    sqInt running;
    sqInt sampleBuffer;
    char *sp;

	bufferSize = 0;
	running = 0;
	ioNewProfileStatus((&running), (&bufferSize));
	if (!GIV(argumentCount)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer)), /* booleanObjectOf: */
			(running
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (!(GIV(argumentCount) == 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	sampleBuffer = longAt(GIV(stackPointer));
	if (!(((sampleBuffer & 1) == 0)
		 && ((isPureBitsNonImm(sampleBuffer))
		 && ((numBytesOf(sampleBuffer)) >= (bufferSize * BytesPerWord))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	numSamples = ioNewProfileSamplesInto(pointerForOop(sampleBuffer + BaseHeaderSize));

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveWait */
static void
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    sqInt oop;
    sqInt sema;

	/* rcvr */
	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)((((usqInt)(excessSignals - 1))) ^ (((((usqInt)(excessSignals - 1))) << 1))))) >= 0) {
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((sema + BaseHeaderSize) + ((((usqInt)(ExcessSignalsIndex) << (shiftForWord())))), (((usqInt)(excessSignals - 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin activeProcess */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		addLastLinktoList(activeProc, sema);
		transferTo(wakeHighestPriority());
	}
}


/*	Primitively do the equivalent of Process>yield, avoiding the overhead of a
	fork and a wait in the standard implementation.
 */

	/* InterpreterPrimitives>>#primitiveYield */
static void
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;
    sqInt scheduler;

	scheduler = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((scheduler + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + ((((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	priority = (oop >> 1);
	processLists = longAt((scheduler + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	processList = longAt((processLists + BaseHeaderSize) + ((((usqInt)((priority - 1)) << (shiftForWord())))));
	if (!((/* begin isEmptyList: */
			assert(!(isForwarded(processList))),
		(longAt((processList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)))) {
		addLastLinktoList(activeProc, processList);
		transferTo(wakeHighestPriority());
	}
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

	/* InterpreterPrimitives>>#signalNoResume: */
int
signalNoResume(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int empty;

	/* begin isEmptyList: */
	assert(!(isForwarded(aSemaphore)));
	empty = (longAt((aSemaphore + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj);
	if (!empty) {
		putToSleepyieldingIf(removeFirstLinkOfList(aSemaphore), 1);
	}
	return empty;
}


/*	Convert the given object into an integer value.
	The object may be either a SmallInteger or a four-byte LargeInteger. */

	/* InterpreterPrimitives>>#signed32BitValueOf: */
int
signed32BitValueOf(sqInt oop)
{
	if ((oop & 1)) {
		return (oop >> 1);
	}
	return noInlineSigned32BitValueGutsOf(oop);
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#signed64BitValueOf: */
sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    usqLong magnitude;
    sqInt negative;
    int ok;
    sqInt sz;

	if ((oop & 1)) {
		return ((sqLong) ((oop >> 1)));
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	sz = numBytesOfBytes(oop);
	if (sz > 4) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
		if ((sz > (sizeof(sqLong)))
		 || ((negative
				? magnitude > 0x8000000000000000ULL
				: magnitude >= 0x8000000000000000ULL))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	else {
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	}
	return (negative
			? 0 - magnitude
			: magnitude);
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

	/* InterpreterPrimitives>>#signedMachineIntegerValueOf: */
sqIntptr_t
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    usqIntptr_t limit;
    usqIntptr_t magnitude;
    sqInt negative;
    int ok;
    sqInt value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((oop & 1)));
		ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l2;
		}
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l2;
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	bs = numBytesOf(oop);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(sqIntptr_t)) == 8)
	 && (bs > 4)) {
		magnitude = SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, oop)));
	}
	else {
		magnitude = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((oop + BaseHeaderSize))))));
	}
	limit = ((((usqIntptr_t)1)) << (((sizeof(sqIntptr_t)) * 8) - 1));
	if ((negative
			? magnitude > limit
			: magnitude >= limit)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (negative) {
		value = 0 - magnitude;
	}
	else {
		value = magnitude;
	}
	return value;
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oopClass;

	/* begin is:KindOfClass: */
	oopClass = /* fetchClassOf: */
			((oop & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord()))))))) {
			goto l1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	return 0;
l1:;
	return SQABS((longAt(oop + BaseHeaderSize)));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oopClass;

	/* begin is:KindOfClass: */
	oopClass = /* fetchClassOf: */
			((oop & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord()))))))) {
			goto l1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	return 0;
l1:;
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
		? (oop + BaseHeaderSize) + BytesPerOop
		: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

	/* InterpreterPrimitives>>#success: */
sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return 0;
}


/*	Initialize the stack pages. For testing I want stack addresses to be
	disjoint from
	normal memory addresses so stack addresses are negative. The first address
	is -pageSize bytes. So for example if there are 1024 bytes per page and 3
	pages then the pages are organized as
	
	byte address: -1024 <-> -2047 | -2048 <-> -3071 | -3072 <-> -4096 |
	page 3			page 2			page 1
	mem index: 769 <-> 513 | 512 <-> 257 | 256 <-> 1 |
	
	The byte address is the external address corresponding to a real address
	in the VM.
	mem index is the index in the memory Array holding the stack, an index
	internal to
	the stack pages. The first stack page allocated will be the last page in
	the array of pages
	at the highest effective address. Its base address be -1024 and grow down
	towards -2047. */
/*	The lFoo's are to get around the foo->variable scheme in the C call to
	allocStackPages below.
 */

	/* InterpreterStackPages>>#initializeStack:numSlots:pageSize: */
static NoDbgRegParms void
initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt index;
    sqInt numPages;
    StackPage *page;
    char *pageStructBase;
    usqIntptr_t structStackPageSize;
    sqInt theIndex;

	/* For initialization in the C code. */
	GIV(stackMemory) = theStackPages;
	structStackPageSize = sizeof(CogStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;

	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	   subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	   push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */
	numPages = GIV(numStackPages);
	pageStructBase = (theStackPages + (numPages * GIV(bytesPerPage))) + BytesPerWord;

	/* Simulation only.  Since addresses are negative the offset is positive.  To make all
	   stack addresses negative we make the offset a page more than it needs to be so the
	   address of the last slot in memory (the highest address in the stack, or its start) is
	   - pageByteSize
	   and the address of the first slot (the lowest address, or its end) is
	   - pageByteSize * (numPages + 1) */
	GIV(pages) = (StackPage *)pageStructBase;
	assert((((stackPageByteSize()) - (stackLimitBytes())) - (stackLimitOffset())) >= (stackPageHeadroom()));
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		(page->lastAddress = (char *)theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = ((page->baseAddress)) - ((((stackPageFrameBytes()) < (((stackPageByteSize()) - (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord)))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord))))));
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (numPages - 1)
				? 0
				: index + 1)));
		(page->prevPage = stackPageAt((index
				? index - 1
				: numPages - 1)));
	}

	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages));
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index < numPages; index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		assert((pageIndexFor((page->baseAddress))) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord))) == index);
		assert((stackPageFor((page->baseAddress))) == page);
		assert((stackPageFor((page->stackLimit))) == page);

		/* begin initializePageTraceToInvalid: */
		(page->trace = StackPageTraceInvalid);
	}
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages));
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		theIndex = pageIndexForstackMemorybytesPerPage((page->baseAddress), GIV(stackMemory), GIV(bytesPerPage));
		assert((stackPageAt(theIndex)) == page);
		assert((pageIndexFor((page->baseAddress))) == theIndex);
		assert((pageIndexFor((page->stackLimit))) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + BytesPerWord)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == numPages);
	assert(pageListIsWellFormed());
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

	/* InterpreterStackPages>>#pageIndexFor: */
static NoDbgRegParms sqInt
pageIndexFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
}


/*	Return the accessible object following the given object or 
	free chunk in the heap. Return nil when heap is exhausted. */

	/* NewObjectMemory>>#accessibleObjectAfter: */
static NoDbgRegParms sqInt
accessibleObjectAfter(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt obj;
    unsigned int sz;

	/* begin objectAfter: */
	if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
		error("no objects after the end of memory");
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
	}
	obj = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			return obj;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	return null;
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

	/* NewObjectMemory>>#addressCouldBeObjWhileForwarding: */
static NoDbgRegParms sqInt
addressCouldBeObjWhileForwarding(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= (startOfMemory()))
	 && ((((usqInt)address)) < GIV(freeStart)));
}


/*	Answer if address appears to be that of an object, which implies it is
	safe to fetch the class and size. For code disassembly and assertions. */

	/* NewObjectMemory>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & 3) == 0)
	 && (((((usqInt)address)) >= (startOfMemory()))
	 && (((((usqInt)address)) < GIV(freeStart))
	 && (((longAt(address)) & TypeMask) != HeaderTypeGC)));
}


/*	Adjust all oop references by the given number of bytes. This is
	done just after reading in an image when the new base address
	of the object heap is different from the base address in the image. */
/*	di 11/18/2000 - return number of objects found */

	/* NewObjectMemory>>#adjustAllOopsBy: */
static NoDbgRegParms sqInt
adjustAllOopsBy(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt header;
    unsigned int newClassOop;
    sqInt nextOop;
    sqInt oop;
    unsigned int sz;
    sqInt totalObjects;

	if (!bytesToShift) {
		return 300000;
	}
	totalObjects = 0;
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(oop, GIV(freeStart))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			totalObjects += 1;

			/* begin adjustFieldsAndClassOf:by: */
			fieldAddr = oop + (lastPointerOf(oop));
			while (oopisGreaterThan(fieldAddr, oop)) {
				fieldOop = longAt(fieldAddr);
				if (!((fieldOop & 1))) {
					longAtput(fieldAddr, fieldOop + bytesToShift);
				}
				fieldAddr -= BytesPerOop;
			}
			if (((longAt(oop)) & TypeMask) != HeaderTypeShort) {

				/* adjust class header if not a compact class */
				classHeader = longAt(oop - BytesPerWord);
				newClassOop = (classHeader & AllButTypeMask) + bytesToShift;
				longAtput(oop - BytesPerWord, newClassOop | (classHeader & TypeMask));
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		nextOop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		assert(oopisLessThan(oop, nextOop));
		oop = nextOop;
	}
	return totalObjects;
}


/*	Attempt to answer all instances of aBehavior, failing if there is not
	enough room.
 */
/*	Allocate a large header Array of sufficient size to require a large
	header. Reset its size later. */

	/* NewObjectMemory>>#allInstancesOf: */
static NoDbgRegParms sqInt
allInstancesOf(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt afterPreAllocatedObject;
    sqInt byteSize;
    usqInt ccIndex;
    sqInt container;
    sqInt count;
    sqInt fillPointer;
    sqInt header;
    sqInt obj;
    sqInt objSqInt;
    unsigned int sz;

	container = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), 0x100 /* minLargeHeaderSize */);

	/* begin sizeHeader:putBodySize: */
	longAtput(container - (BytesPerWord * 2), ((0 + BytesPerWord) & LongSizeMask) | ((((longAt(container - (BytesPerWord * 2))) | LongSizeMask) - LongSizeMask)));
	afterPreAllocatedObject = GIV(freeStart);
	GIV(freeStart) = (fillPointer = ((sqInt)(pointerForOop(container + BaseHeaderSize))));
	count = 0;
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, container)) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			if ((/* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(obj)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(obj - BaseHeaderSize)) & AllButTypeMask)) == aBehavior) {
				count += 1;
				if (fillPointer < GIV(reserveStart)) {
					longAtput(fillPointer, obj);
					fillPointer += BytesPerOop;
				}
			}
		}

		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		objSqInt = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		while (oopisLessThan(objSqInt, GIV(freeStart))) {
			if (!(((longAt(objSqInt)) & TypeMask) == HeaderTypeFree)) {
				obj = objSqInt;
				goto l1;
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(objSqInt, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(objSqInt)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(objSqInt)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(objSqInt);
				sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(objSqInt - (BytesPerWord * 2))) & LongSizeMask)));
			}
			objSqInt = (objSqInt + sz) + (headerTypeBytes[(longAt(objSqInt + sz)) & TypeMask]);
		}
		obj = null;
l1:	/* end accessibleObjectAfter: */;
	}
	if (fillPointer >= GIV(reserveStart)) {

		/* didn't fit; answer instance count so large enough container can be allocated. */
		return (((usqInt)count << 1) | 1);
	}
	byteSize = fillPointer - (((sqInt)(pointerForOop(container + BaseHeaderSize))));

	/* begin sizeHeader:putBodySize: */
	assert((byteSize % 4) == 0);
	longAtput(container - (BytesPerWord * 2), ((byteSize + BytesPerWord) & LongSizeMask) | ((((longAt(container - (BytesPerWord * 2))) | LongSizeMask) - LongSizeMask)));
	GIV(freeStart) = fillPointer;
	return container;
}

	/* NewObjectMemory>>#allObjectsUnmarked */
static sqInt
allObjectsUnmarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oop;
    unsigned int sz;

	/* begin allObjectsDo: */
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if ((longAt(oop)) & MarkBit) {
				return 0;
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return 1;
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced with with pointers to the other. The arguments must be arrays
	of the same length. 
	Returns PrimNoErr if the primitive succeeds.
 */
/*	Implementation: Uses forwarding blocks to update references as done in
	compaction. 
 */

	/* NewObjectMemory>>#become:with:twoWay:copyHash: */
static NoDbgRegParms sqInt
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt entriesAvailable;
    sqInt entriesNeeded;
    sqInt fieldOffset;
    usqInt fmt;
    sqInt fwdBlkSize;
    usqInt fwdBlock;
    usqInt fwdBlockUsqInt;
    sqInt fwdHeader;
    sqInt fwdHeaderSqInt;
    sqInt hdr1;
    sqInt hdr2;
    sqInt header;
    usqInt numLiterals;
    sqInt objHeader;
    sqInt objHeaderBytes;
    sqInt objHeaderSqInt;
    usqInt objHeaderType;
    usqInt objSize;
    sqInt oop1;
    sqInt oop2;
    sqInt originalHeader;
    sqInt originalHeaderSqInt;
    usqInt originalHeaderType;
    usqInt originalHeaderTypeUsqInt;
    sqInt sp;
    usqInt start;

	runLeakCheckerFor(GCModeBecome);
	if (!(/* isArray: */
			((array1 & 1) == 0)
		 && (((((usqInt)((longAt(array1)))) >> (instFormatFieldLSB())) & 15) == 2))) {
		return PrimErrBadReceiver;
	}
	if (!((/* isArray: */
			((array2 & 1) == 0)
		 && (((((usqInt)((longAt(array2)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((lastPointerOf(array1)) == (lastPointerOf(array2))))) {
		return PrimErrBadArgument;
	}
	if (twoWayFlag
	 || (copyHashFlag)) {
		/* begin containOnlyOops:and: */
		/* begin lastPointerOf: */
		header = longAt(array1);
		fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
		if (fmt <= 4 /* lastPointerFormat */) {
			if ((fmt == (indexablePointersFormat()))
			 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l3;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
				contextSize = (sp >> 1);
l3:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l4;
			}
			fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
			goto l4;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			fieldOffset = 0;
			goto l4;
		}

		/* begin methodHeaderOf: */
		assert(isCompiledMethod(array1));
		header = longAt((array1 + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin lastPointerOfMethodHeader: */
		/* begin literalCountOfMethodHeader: */
		assert((header & 1));
		numLiterals = ((((int) header)) < 0
					? ((header >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt)(header)) >> 10) & 0xFF);
		fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l4:	/* end lastPointerOf: */;
		while (fieldOffset >= BaseHeaderSize) {
			if (((longAt(array1 + fieldOffset)) & 1)) {
				return PrimErrInappropriate;
			}
			if (((longAt(array2 + fieldOffset)) & 1)) {
				return PrimErrInappropriate;
			}
			fieldOffset -= BytesPerOop;
		}
	}
	else {
		/* begin containOnlyOops: */
		/* begin lastPointerOf: */
		header = longAt(array1);
		fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
		if (fmt <= 4 /* lastPointerFormat */) {
			if ((fmt == (indexablePointersFormat()))
			 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l5;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
				contextSize = (sp >> 1);
l5:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l6;
			}
			fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
			goto l6;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			fieldOffset = 0;
			goto l6;
		}

		/* begin methodHeaderOf: */
		assert(isCompiledMethod(array1));
		header = longAt((array1 + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin lastPointerOfMethodHeader: */
		/* begin literalCountOfMethodHeader: */
		assert((header & 1));
		numLiterals = ((((int) header)) < 0
					? ((header >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt)(header)) >> 10) & 0xFF);
		fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l6:	/* end lastPointerOf: */;
		while (fieldOffset >= BaseHeaderSize) {
			if (((longAt(array1 + fieldOffset)) & 1)) {
				return PrimErrInappropriate;
			}
			fieldOffset -= BytesPerOop;
		}
	}

	/* begin prepareForwardingTableForBecoming:with:twoWay: */
	/* need enough entries for all oops */
	/* Note: Forward blocks must be quadword aligned - see fwdTableInit:. */
	entriesNeeded = (lastPointerOf(array1)) / BytesPerWord;
	if (twoWayFlag) {

		/* Double the number of blocks for two-way become */
		entriesNeeded = entriesNeeded * 2;
		fwdBlkSize = BytesPerWord * 2;
	}
	else {

		/* One-way become needs backPointers in fwd blocks. */
		fwdBlkSize = BytesPerWord * 4;
	}
	entriesAvailable = fwdTableInit(fwdBlkSize);
	if (entriesAvailable < entriesNeeded) {
		initializeMemoryFirstFree(GIV(freeStart));
		return PrimErrNoMemory;
	}

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l2;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l2;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l2;
	}

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(array1));
	header = longAt((array1 + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
				? ((header >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header)) >> 10) & 0xFF);
	fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		oop1 = longAt(array1 + fieldOffset);

		/* if oop1 == oop2, no need to do any work for this pair.
		   May still be other entries in the arrays though so keep looking */
		oop2 = longAt(array2 + fieldOffset);
		if (oop1 != oop2) {
			if (!((longAt(oop1)) & MarkBit)) {

				/* Don't allocate multiple forwarding entries for duplicates. */
				/* begin fwdBlockGet: */
				GIV(fwdTableNext) += fwdBlkSize;
				if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
					fwdBlock = GIV(fwdTableNext);
				}
				else {
					fwdBlock = null;
				}

				/* begin initForwardBlock:mapping:to:withBackPtr: */
				assert(fwdBlock != null);
				assert(!((hasForwardingBlock(oop1))));
				originalHeader = longAt(oop1);
				originalHeaderType = originalHeader & TypeMask;
				longAtput(fwdBlock, oop2);
				longAtput(fwdBlock + BytesPerWord, originalHeader);
				if (!twoWayFlag) {
					longAtput(fwdBlock + (BytesPerWord * 2), oop1);
				}
				longAtput(oop1, ((fwdBlock) >> 1) | (MarkBit | originalHeaderType));
			}
			if (twoWayFlag
			 && (!(((longAt(oop2)) & MarkBit) != 0))) {

				/* Again don't get confused by duplicates */
				/* Second block maps oop2 back to oop1 for two-way become */
				/* begin fwdBlockGet: */
				GIV(fwdTableNext) += fwdBlkSize;
				if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
					fwdBlock = GIV(fwdTableNext);
				}
				else {
					fwdBlock = null;
				}

				/* begin initForwardBlock:mapping:to:withBackPtr: */
				assert(fwdBlock != null);
				assert(!((hasForwardingBlock(oop2))));
				originalHeaderSqInt = longAt(oop2);
				originalHeaderTypeUsqInt = originalHeaderSqInt & TypeMask;
				longAtput(fwdBlock, oop1);
				longAtput(fwdBlock + BytesPerWord, originalHeaderSqInt);
				if (!twoWayFlag) {
					longAtput(fwdBlock + (BytesPerWord * 2), oop2);
				}
				longAtput(oop2, ((fwdBlock) >> 1) | (MarkBit | originalHeaderTypeUsqInt));
			}
		}
		fieldOffset -= BytesPerWord;
	}

	/* begin allYoung:and: */
	if (oopisLessThan(array1, GIV(youngStart))) {
		goto l10;
	}
	if (oopisLessThan(array2, GIV(youngStart))) {
		goto l10;
	}

	/* begin lastPointerOf: */
	header = longAt(array1);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((array1 + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l7;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
			contextSize = (sp >> 1);
l7:	/* end fetchStackPointerOf: */;
			fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l8;
		}
		fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
		goto l8;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		fieldOffset = 0;
		goto l8;
	}

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(array1));
	header = longAt((array1 + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
				? ((header >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header)) >> 10) & 0xFF);
	fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l8:	/* end lastPointerOf: */;
	while (fieldOffset >= BaseHeaderSize) {
		if (oopisLessThan(longAt(array1 + fieldOffset), GIV(youngStart))) {
			goto l10;
		}
		if ((oopisLessThan(longAt(array2 + fieldOffset), GIV(youngStart)))
		 && (((longAt(array2 + fieldOffset)) & 1) == 0)) {
			goto l10;
		}
		fieldOffset -= BytesPerWord;
	}

	/* sweep only the young objects plus the roots */
	start = GIV(youngStart);
	goto l9;
l10:;

	/* sweep all objects */
	start = startOfMemory();
l9:;

	/* begin preBecomeAction: */
	if (GIV(stackPage)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	mapPointersInObjectsFromto(start, GIV(freeStart));
	if (twoWayFlag) {
		/* begin restoreHeadersAfterBecoming:with: */
		/* begin lastPointerOf: */
		header = longAt(array1);
		fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
		if (fmt <= 4 /* lastPointerFormat */) {
			if ((fmt == (indexablePointersFormat()))
			 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */
				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l11;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
				contextSize = (sp >> 1);
l11:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l12;
			}
			fieldOffset = (sizeBitsOfSafe(array1)) - BaseHeaderSize;
			goto l12;
		}
		if (fmt < (firstCompiledMethodFormat())) {
			fieldOffset = 0;
			goto l12;
		}

		/* begin methodHeaderOf: */
		assert(isCompiledMethod(array1));
		header = longAt((array1 + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin lastPointerOfMethodHeader: */
		/* begin literalCountOfMethodHeader: */
		assert((header & 1));
		numLiterals = ((((int) header)) < 0
					? ((header >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt)(header)) >> 10) & 0xFF);
		fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l12:	/* end lastPointerOf: */;
		while (fieldOffset >= BaseHeaderSize) {
			oop1 = longAt(array1 + fieldOffset);
			oop2 = longAt(array2 + fieldOffset);
			if (!(oop1 == oop2)) {
				/* begin restoreHeaderOf: */
				fwdHeader = longAt(oop1);
				fwdBlock = ((fwdHeader & AllButMarkBitAndTypeMask) << 1);
				assert((fwdHeader & MarkBit) != 0);
				assert(fwdBlockValid(fwdBlock));
				objHeader = longAt(fwdBlock + BytesPerWord);

				/* begin restoreHeaderOf:to: */
				longAtput(oop1, objHeader);
				if (((((usqInt)(objHeader)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					if (!(asserta(!(isStillMarriedContext(oop1))))) {
						error("attempt to become married context");
					}
				}

				/* begin restoreHeaderOf: */
				fwdHeaderSqInt = longAt(oop2);
				fwdBlockUsqInt = ((fwdHeaderSqInt & AllButMarkBitAndTypeMask) << 1);
				assert((fwdHeaderSqInt & MarkBit) != 0);
				assert(fwdBlockValid(fwdBlockUsqInt));
				objHeaderSqInt = longAt(fwdBlockUsqInt + BytesPerWord);

				/* begin restoreHeaderOf:to: */
				longAtput(oop2, objHeaderSqInt);
				if (((((usqInt)(objHeaderSqInt)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					if (!(asserta(!(isStillMarriedContext(oop2))))) {
						error("attempt to become married context");
					}
				}
				hdr1 = longAt(oop1);
				hdr2 = longAt(oop2);
				longAtput(oop1, (hdr1 & AllButHashBits) | (hdr2 & HashBits));
				longAtput(oop2, (hdr2 & AllButHashBits) | (hdr1 & HashBits));
			}
			fieldOffset -= BytesPerWord;
		}
	}
	else {
		/* begin restoreHeadersAfterForwardBecome: */
		fwdBlock = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
		flag("Dan");

		/* fwdBlockGet: did a pre-increment */
		fwdBlock += BytesPerWord * 4;
		while (oopisLessThanOrEqualTo(fwdBlock, GIV(fwdTableNext))) {
			/* Backpointer to mutated object. */
			oop1 = longAt(fwdBlock + (BytesPerWord * 2));
			oop2 = longAt(fwdBlock);

			/* begin restoreHeaderOf: */
			fwdHeader = longAt(oop1);
			fwdBlockUsqInt = ((fwdHeader & AllButMarkBitAndTypeMask) << 1);
			assert((fwdHeader & MarkBit) != 0);
			assert(fwdBlockValid(fwdBlockUsqInt));
			objHeader = longAt(fwdBlockUsqInt + BytesPerWord);

			/* begin restoreHeaderOf:to: */
			longAtput(oop1, objHeader);
			if (((((usqInt)(objHeader)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				if (!(asserta(!(isStillMarriedContext(oop1))))) {
					error("attempt to become married context");
				}
			}
			if (copyHashFlag) {

				/* Change the hash of the new oop (oop2) to be that of the old (oop1)
				   so mutated objects in hash structures will be  happy after the change. */
				hdr1 = longAt(oop1);
				hdr2 = longAt(oop2);
				longAtput(oop2, (hdr2 & AllButHashBits) | (hdr1 & HashBits));
			}

			/* begin freeObject: */
			objHeaderSqInt = longAt(oop1);
			if (((((usqInt)(objHeaderSqInt)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				if (!(asserta(!(isStillMarriedContext(oop1))))) {
					error("attempt to free married context");
				}
			}
			if (objHeaderSqInt & RootBit) {
				removeYoungRoot(oop1);
			}
			objHeaderType = objHeaderSqInt & TypeMask;
			objHeaderBytes = headerTypeBytes[objHeaderType];
			if ((objHeaderType & 1) == 1) {

				/* HeaderTypeClass or HeaderTypeShort */
				objSize = objHeaderSqInt & SizeMask;
			}
			else {
				if (objHeaderType == HeaderTypeFree) {
					goto l13;
				}
				objSize = (longAt(oop1 - (BytesPerWord * 2))) & LongSizeMask;
			}
			assert(((objSize + objHeaderBytes) & AllButTypeMask) == (objSize + objHeaderBytes));
			longAtput(oop1 - objHeaderBytes, (objSize + objHeaderBytes) | HeaderTypeFree);
l13:	/* end freeObject:header: */;
			fwdBlock += BytesPerWord * 4;
		}
	}

	/* begin postBecomeAction: */
	initializeMemoryFirstFree(GIV(freeStart));
	runLeakCheckerFor(GCModeBecome);
	return PrimNoErr;
}

	/* NewObjectMemory>>#characterValueOf: */
sqInt
characterValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isCharacterObjectRV;

	/* begin isCharacterObject: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));
	if ((oop & 1)) {
		isCharacterObjectRV = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isCharacterObjectRV = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isCharacterObjectRV = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isCharacterObject: */;
	if (!isCharacterObjectRV) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrUnsupported;
		return -1;
	}
	return ((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 1);
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rootTable, remapBuffer and
	extraRootTable checking that every entry is a pointer to a header.
	Check that the number of roots is correct and that all rootTable
	entries have their rootBit set. Answer if all checks pass. */

	/* NewObjectMemory>>#checkHeapIntegrity */
static sqInt
checkHeapIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fi;
    unsigned int fieldOop;
    usqInt fmt;
    sqInt fmtSqInt;
    sqInt hdr;
    sqInt header;
    sqInt headerSqInt;
    sqInt numRootsInHeap;
    sqInt obj;
    sqInt ok;
    sqInt ri;
    unsigned int sz;
    unsigned int sz1;

	ok = 1;
	numRootsInHeap = 0;
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			hdr = longAt(obj);
			if (hdr & RootBit) {
				numRootsInHeap += 1;
			}
			if (!((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F)) {
				fieldOop = (longAt(obj - BaseHeaderSize)) & AllButTypeMask;
				if (((fieldOop & 1))
				 || ((heapMapAtWord(pointerForOop(fieldOop))) == 0)) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"object leak in ");
					printHex(obj);

					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" class = ");
					printHex(fieldOop);
					eekcr();
					ok = 0;
				}
			}
			fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;
			if ((fmt <= 4)
			 || (fmt >= 12)) {
				if (fmt >= 12) {
					fi = (literalCountOf(obj)) + LiteralStart;
				}
				else {
					if ((fmt == 3)
					 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
						fi = CtxtTempFrameStart + (fetchStackPointerOf(obj));
					}
					else {
						/* begin lengthOf: */
						headerSqInt = longAt(obj);
						fmtSqInt = (((usqInt)(headerSqInt)) >> (instFormatFieldLSB())) & 15;

						/* begin lengthOf:baseHeader:format: */
						if (headerSqInt & TypeMask) {
							sz1 = headerSqInt & SizeMask;
						}
						else {
							sz1 = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
						}
						sz1 -= 0;
						if (fmtSqInt <= 4 /* lastPointerFormat */) {
							fi = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
							goto l1;
						}
						fi = (fmtSqInt < (firstByteFormat())
									? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
									: (sz1 - BaseHeaderSize) - (fmtSqInt & 3));
l1:	/* end lengthOf: */;
					}
				}
				while (((fi -= 1)) >= 0) {
					fieldOop = longAt((obj + BaseHeaderSize) + ((((usqInt)(fi) << (shiftForWord())))));
					if (!(fieldOop & 1)) {
						if (fieldOop & (BytesPerWord - 1)) {
							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									"misaligned oop in ");
							printHex(obj);

							/* begin print: */
							fprintf(GIV(transcript),
									"%s",
									" @ ");
							fprintf(GIV(transcript),
									"%" PRIdSQINT "",
									((sqInt)fi));
							fprintf(GIV(transcript),
									"%s",
									" = ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
						else {
							if (!(heapMapAtWord(pointerForOop(fieldOop)))) {
								/* begin print: */
								fprintf(GIV(transcript),
										"%s",
										"object leak in ");
								printHex(obj);

								/* begin print: */
								fprintf(GIV(transcript),
										"%s",
										" @ ");
								fprintf(GIV(transcript),
										"%" PRIdSQINT "",
										((sqInt)fi));
								fprintf(GIV(transcript),
										"%s",
										" = ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
						}
					}
				}
			}

			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	if (numRootsInHeap != GIV(rootTableCount)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"root count mismatch. #heap roots ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)numRootsInHeap));
		fprintf(GIV(transcript),
				"%s",
				"; #roots ");
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)GIV(rootTableCount)));
		cr();
		ok = GIV(rootTableOverflowed)
			 && (GIV(needGCFlag));
	}
	for (ri = 1; ri <= GIV(rootTableCount); ri += 1) {
		obj = GIV(rootTable)[ri];
		if (obj & (BytesPerWord - 1)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"misaligned oop in rootTable @ ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)ri));
			fprintf(GIV(transcript),
					"%s",
					" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if (heapMapAtWord(pointerForOop(obj))) {
				hdr = longAt(obj);
				if (!(hdr & RootBit)) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							"non-root in rootTable @ ");
					fprintf(GIV(transcript),
							"%" PRIdSQINT "",
							((sqInt)ri));
					fprintf(GIV(transcript),
							"%s",
							" = ");
					printHex(obj);
					eekcr();
					ok = 0;
				}
			}
			else {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"object leak in rootTable @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)ri));
				fprintf(GIV(transcript),
						"%s",
						" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if (obj & (BytesPerWord - 1)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"misaligned remapRoot @ ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)ri));
			fprintf(GIV(transcript),
					"%s",
					" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if (!(heapMapAtWord(pointerForOop(obj)))) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"object leak in remapRoots @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)ri));
				fprintf(GIV(transcript),
						"%s",
						" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if (obj & (BytesPerWord - 1)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"misaligned extraRoot @ ");
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)ri));
			fprintf(GIV(transcript),
					"%s",
					" => ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if (!(heapMapAtWord(pointerForOop(obj)))) {
				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						"object leak in extraRoots @ ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)ri));
				fprintf(GIV(transcript),
						"%s",
						" => ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */
/*	useful for debugging */
/*	address and size checks */

	/* NewObjectMemory>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt fmt;
    sqInt header;
    usqInt sz;
    usqInt type;
    sqInt unusedBit;

	if ((oop & 1)) {
		return 1;
	}
	if (!((oopisGreaterThanOrEqualTo(oop, startOfMemory()))
		 && (oopisLessThan(oop, GIV(freeStart))))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is not a valid address");
		cr();
		return 0;
	}
	if (oop % BytesPerWord) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is not a word-aligned address");
		cr();
		return 0;
	}

	/* begin sizeBitsOf: */
	header = longAt(oop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask);
	if (!(oopisLessThanOrEqualTo(oop + sz, GIV(freeStart)))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" size would make it extend beyond the end of memory");
		cr();
		return 0;
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is a free chunk, not an object");
		cr();
		return 0;
	}
	if (type == HeaderTypeShort) {
		if (!((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"oop ");
			printHex(oop);

			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" cannot have zero compact class field in a short header");
			cr();
			return 0;
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= BytesPerWord)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"oop ");
			printHex(oop);

			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" class header word has wrong type");
			cr();
			return 0;
		}
	}
	if (!type) {
		if (!((oop >= (BytesPerWord * 2))
			 && ((((longAt(oop - (BytesPerWord * 2))) & TypeMask) == type)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type)))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"oop ");
			printHex(oop);

			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" class header word has wrong type");
			cr();
			return 0;
		}
	}
	fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has an unknown format type");
		cr();
		return 0;
	}
	unusedBit = 0x20000000;
	if ((longAt(oop)) & unusedBit) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" unused header bit 30 is set; should be zero");
		cr();
		return 0;
	}
	if ((((longAt(oop)) & RootBit) != 0)
	 && (oop >= GIV(youngStart))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"oop ");
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" root bit is set in a young object");
		cr();
		return 0;
	}
	return 1;
}

	/* NewObjectMemory>>#checkOopIntegrity:named: */
static NoDbgRegParms sqInt
checkOopIntegritynamed(sqInt obj, char *name)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (heapMapAtWord(pointerForOop(obj))) {
		return 1;
	}

	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			name);
	fprintf(GIV(transcript),
			"%s",
			" leak ");
	printHex(obj);
	cr();
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

	/* NewObjectMemory>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    usqInt nextHeader;
    usqInt obj;
    usqInt sz;

	clearHeapMap();
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			heapMapAtWordPut(pointerForOop(obj), 1);

			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = (header & TypeMask
						? header & SizeMask
						: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask);
		}
		nextHeader = obj + sz;
		obj = nextHeader + (headerTypeBytes[(longAt(nextHeader)) & TypeMask]);
	}
}


/*	Return a shallow copy of the given object. May cause GC.
	Assume: Oop is a real object, not a small integer.
	Override to assert it's not a married context and maybe fix cloned
	methods.  */

	/* NewObjectMemory>>#cloneObject: */
sqInt
cloneObject(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytes;
    sqInt extraHdrBytes;
    usqInt fromIndex;
    usqInt hash;
    usqInt header;
    sqInt headerSqInt;
    usqInt lastFrom;
    sqInt newChunk;
    usqInt newChunkUsqInt;
    usqInt newFreeStart;
    sqInt newOop;
    sqInt remappedOop;
    sqInt toIndex;

	assert((!(isContext(obj)))
	 || (!(isMarriedOrWidowedContext(obj))));
	assert(isNonIntegerObject(obj));
	extraHdrBytes = headerTypeBytes[(longAt(obj)) & TypeMask];

	/* begin sizeBitsOf: */
	headerSqInt = longAt(obj);
	bytes = (headerSqInt & TypeMask
				? headerSqInt & SizeMask
				: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask);

	/* allocate space for the copy, remapping obj in case of a GC */
	bytes += extraHdrBytes;

	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(obj));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = obj;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	if (!(sufficientSpaceToAllocate(2500 + bytes))) {
		return null;
	}

	/* begin allocateChunk: */
	newChunkUsqInt = GIV(freeStart);
	newFreeStart = GIV(freeStart) + bytes;
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newChunk = oopForPointer(newChunkUsqInt);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newChunk = oopForPointer(newChunkUsqInt);
		goto l1;
	}
	newChunk = 0;
l1:	/* end allocateChunk: */;

	/* begin popRemappableOop */
	remappedOop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;

	/* loop below uses pre-increment */
	toIndex = newChunk - BytesPerWord;
	fromIndex = (remappedOop - extraHdrBytes) - BytesPerWord;
	lastFrom = fromIndex + bytes;
	while (fromIndex < lastFrom) {
		longAtput((toIndex += BytesPerWord), longAt((fromIndex += BytesPerWord)));
	}

	/* convert from chunk to oop */
	/* fix base header: compute new hash and clear Mark and Root bits */
	newOop = newChunk + extraHdrBytes;
	hash = (GIV(freeStart)) >> (shiftForWord());

	/* use old ccIndex, format, size, and header-type fields */
	header = (longAt(newOop)) & 0x1FFFF;
	header = header | (((hash << HashBitsOffset)) & HashBits);
	longAtput(newOop, header);
	if ((((header) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
	}
	return newOop;
}


/*	Return the default amount of memory to allocate before doing a scavenge
	(incremental GC).
	This default suits Qwaq Forums (specifically loading). The actual value
	can be set via
	vmParameterAt: and/or a preference in the ini file. */

	/* NewObjectMemory>>#defaultEdenBytes */
static int
defaultEdenBytes(void)
{
	return 0x200000;
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* NewObjectMemory>>#eeInstantiateClassIndex:format:numSlots: */
sqInt
eeInstantiateClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSize;
    usqInt hash;
    sqInt hdrSize;
    usqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;


	/* cannot have a negative indexable field count */
	header2 = 0;
	header3 = 0;
	assert((numSlots >= 0)
	 && (compactClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
			? objFormat
			: objFormat & (byteFormatMask()))) == (instSpecOfClass(compactClassAt(compactClassIndex))));

	/* Low 2 bits are 0 */
	hash = (GIV(freeStart)) >> (shiftForWord());
	header1 = (((((usqInt)(objFormat) << (instFormatFieldLSB())))) | ((((usqInt)(compactClassIndex) << 12)))) | (((hash & HashMaskUnshifted) << HashBitsOffset));
	assert(((((formatOfClass(compactClassAt(compactClassIndex))) & 0x60000)) >> 9) == 0);
	flag("sizeLowBits");
	byteSize = ((((usqInt)(numSlots) << ((shiftForWord()) + ((shiftForWord()) - 2))))) + BaseHeaderSize;
	if (byteSize > 0xFF) {

		/* requires size header word/full header */
		header3 = byteSize;
		hdrSize = 3;
		header2 = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((compactClassIndex - 1)) << (shiftForWord())))));
	}
	else {
		header1 = header1 | byteSize;
		hdrSize = 1;
	}

	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (!newObj) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3);
		longAtput(newObj + BytesPerWord, header2);
		longAtput(newObj + (BytesPerWord * 2), header1);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	return newObj;
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
	Will *not* cause a GC.
	Note that the instantiated object IS NOT FILLED and must be completed
	before returning it to Smalltalk. Since this call is used in routines that
	do just that we are
	safe. Break this rule and die. */
/*	cannot have a negative indexable field count */

	/* NewObjectMemory>>#eeInstantiateClass:indexableSize: */
static NoDbgRegParms sqInt
eeInstantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    usqInt byteSize;
    usqInt cClass;
    sqInt classFormat;
    usqInt format;
    usqInt hash;
    int hdrSize;
    usqInt header1;
    sqInt header2;
    sqInt header3;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    usqInt sizeHiBits;

	assert(size >= 0);
	hash = (GIV(freeStart)) >> (shiftForWord());

	/* Low 2 bits are 0 */
	classFormat = (longAt((classPointer + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	header1 = (classFormat & 0x1FF00) | (((hash & HashMaskUnshifted) << HashBitsOffset));
	header2 = classPointer;
	header3 = 0;
	sizeHiBits = ((classFormat & 0x60000)) >> 9;

	/* compact class field from format word */
	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
	   to 4 bytes per field.  Need another shift for 8 bytes per word... */
	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = (byteSize << ((shiftForWord()) - 2));
	format = (((usqInt)(classFormat)) >> (instFormatFieldLSB())) & 15;
	flag("sizeLowBits");
	if (format < (firstByteFormat())) {
		if (format == (firstLongFormat())) {

			/* long32 bitmaps */
			bm1 = BytesPerWord - 1;

			/* round up */
			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */
			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */
		bm1 = BytesPerWord - 1;

		/* round up */
		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */
		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
		header1 = header1 | (((binc & 3) << (instFormatFieldLSB())));
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 0xFF) {

		/* requires size header word */
		header3 = byteSize;
	}
	else {
		header1 = header1 | byteSize;
	}
	hdrSize = (header3 > 0
				? 3
				: (cClass
						? 1
						: 2));

	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (!newObj) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3);
		longAtput(newObj + BytesPerWord, header2);
		longAtput(newObj + (BytesPerWord * 2), header1);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	return newObj;
}


/*	This version of instantiateClass assumes that the total object 
	size is under 256 bytes, the limit for objects with only one or 
	two header words. Note that the size is specified in bytes 
	and should include four bytes for the base header word.
	Will *not* cause a GC. Result is guaranteed to be young. */

	/* NewObjectMemory>>#eeInstantiateMethodContextSlots: */
static NoDbgRegParms sqInt
eeInstantiateMethodContextSlots(sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    usqInt header1;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeInBytes;

	assert((numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots));
	sizeInBytes = (numSlots * BytesPerOop) + BaseHeaderSize;
	assert(sizeInBytes <= SizeMask);
	hash = (GIV(freeStart)) >> (shiftForWord());
	header1 = (((hash & HashMaskUnshifted) << HashBitsOffset)) | (((((usqInt)(ClassMethodContextCompactIndex) << 12))) + ((((usqInt)((indexablePointersFormat())) << (instFormatFieldLSB())))));
	assert((header1 & CompactClassMask) > 0);
	assert((header1 & SizeMask) == 0);
	header1 += sizeInBytes;

	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes);
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (!newObj) {
		return newObj;
	}
	longAtput(newObj, header1 | HeaderTypeShort);
	return newObj;
}


/*	This version of instantiateClass assumes that the total object size is
	under 256 bytes, the limit for objects with only one or two header words. 
	NOTE this code will only work for sizes that are an integral number of
	words (hence not a 32-bit LargeInteger in a 64-bit system).
	Note that the created small object IS NOT FILLED and must be completed
	before returning it to Squeak.
	Since this call is used in routines that do just that we are safe. Break
	this rule and die in GC.
	Will *not* cause a GC. Result is guaranteed to be young. */
/*	cannot have a negative indexable field count */

	/* NewObjectMemory>>#eeInstantiateSmallClassIndex:format:numSlots: */
static NoDbgRegParms sqInt
eeInstantiateSmallClassIndexformatnumSlots(sqInt compactClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    usqInt header1;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeInBytes;

	assert((numSlots >= 0)
	 && (compactClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
			? objFormat
			: objFormat & (byteFormatMask()))) == (instSpecOfClass(compactClassAt(compactClassIndex))));
	sizeInBytes = ((((usqInt)(numSlots) << (shiftForWord())))) + BaseHeaderSize;
	assert(sizeInBytes <= 0xFC);
	hash = (GIV(freeStart)) >> (shiftForWord());
	header1 = (((((usqInt)(objFormat) << (instFormatFieldLSB())))) | ((((usqInt)(compactClassIndex) << 12)))) | (((hash & HashMaskUnshifted) << HashBitsOffset));
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));

	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes);
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (!newObj) {
		return newObj;
	}
	longAtput(newObj, header1 | HeaderTypeShort);
	return newObj;
}


/*	This version of instantiateClass assumes that the total object size is
	under 256 bytes, the limit for objects with only one or two header words. 
	NOTE this code will only work for sizes that are an integral number of
	words (hence not a 32-bit LargeInteger in a 64-bit system).
	Note that the created small object IS NOT FILLED and must be completed
	before returning it to Squeak.
	Since this call is used in routines that do just that we are safe. Break
	this rule and die in GC.
	Will *not* cause a GC. Result is guaranteed to be young. */

	/* NewObjectMemory>>#eeInstantiateSmallClass:numSlots: */
static NoDbgRegParms sqInt
eeInstantiateSmallClassnumSlots(sqInt classPointer, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt hash;
    int hdrSize;
    usqInt header1;
    sqInt header2;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    sqInt sizeInBytes;

	sizeInBytes = ((((usqInt)(numSlots) << (shiftForWord())))) + BaseHeaderSize;
	assert(sizeInBytes <= 0xFC);
	hash = (GIV(freeStart)) >> (shiftForWord());
	header1 = (((hash & HashMaskUnshifted) << HashBitsOffset)) | ((longAt((classPointer + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1);
	header2 = classPointer;
	hdrSize = ((header1 & CompactClassMask) > 0
				? 1
				: 2);
	header1 += sizeInBytes - (header1 & (SizeMask + Size4Bit));

	/* begin eeAllocate:headerSize:h1:h2:h3: */
	/* begin allocateInterpreterChunk: */
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (sizeInBytes + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	if (GIV(freeStart) < GIV(scavengeThreshold)) {
		/* begin scheduleIncrementalGC */
		GIV(needGCFlag) = 1;
		forceInterruptCheck();
	}
	if (newFreeStart < GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(endOfMemory)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	error("out of memory");
	newObj = null;
l1:	/* end allocateInterpreterChunk: */;
	if (!newObj) {
		return newObj;
	}
	if (hdrSize == 3) {
		longAtput(newObj, 0 /* (0 bitOr: HeaderTypeSizeAndClass) */);
		longAtput(newObj + BytesPerWord, header2);
		longAtput(newObj + (BytesPerWord * 2), header1);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, header2 | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	return newObj;
}


/*	Compatibility with SpurObjectMemory. In ObjectMemory there is no
	distinction between a
	classTag in the first-level method cache and a class itself. */

	/* NewObjectMemory>>#fetchClassTagOfNonImm: */
static NoDbgRegParms sqInt
fetchClassTagOfNonImm(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;

	return /* fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
}


/*	Compatibility with SpurObjectMemory. In ObjectMemory there is no
	distinction between a
	classTag in the first-level method cache and a class itself. */

	/* NewObjectMemory>>#fetchClassTagOf: */
sqInt
fetchClassTagOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;

	return /* fetchClassOf: */
		((oop & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
}


/*	During sweep phase we have encountered a weak reference. Check if its
	object has gone away (or is about to) and if so, signal a semaphore. Do
	*not* inline
	this in sweepPhase - it is quite an unlikely case to run into a weak
	reference. Override to ask the coInterpreter to signal finalization. */

	/* NewObjectMemory>>#finalizeReference: */
static NoDbgRegParms void
finalizeReference(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt chunk;
    sqInt class;
    sqInt classFormat;
    sqInt contextSize;
    sqInt firstField;
    usqInt fmt;
    sqInt header;
    sqInt i;
    sqInt lastField;
    sqInt listItemOop;
    sqInt listOop;
    sqInt numFields;
    usqInt numLiterals;
    int oopGone;
    sqInt sp;
    usqInt weakOop;

	/* begin nonWeakFieldsOf: */
	assert(isWeakNonImm(oop));
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	numFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
	firstField = BaseHeaderSize + ((((usqInt)(numFields) << (shiftForWord()))));

	/* begin lastPointerOf: */
	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((oop + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop)));
			contextSize = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
			lastField = (CtxtTempFrameStart + contextSize) * BytesPerOop;
			goto l2;
		}
		lastField = (sizeBitsOfSafe(oop)) - BaseHeaderSize;
		goto l2;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		lastField = 0;
		goto l2;
	}

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(oop));
	header = longAt((oop + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
				? ((header >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header)) >> 10) & 0xFF);
	lastField = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l2:	/* end lastPointerOf: */;
	for (i = firstField; i <= lastField; i += BytesPerWord) {
		/* ar 1/18/2005: Added oop < youngStart test to make sure we're not testing
		   objects in non-GCable region. This could lead to a forward reference in
		   old space with the oop pointed to not being marked and thus treated as free. */
		weakOop = longAt(oop + i);
		if (!((weakOop == GIV(nilObj))
			 || (((weakOop & 1))
			 || (weakOop < GIV(youngStart))))) {

			/* Check if the object is being collected.
			   If the weak reference points
			   * backward: check if the weakOops chunk is free
			   * forward: check if the weakOoop has been marked by GC */
			if (weakOop < oop) {
				chunk = weakOop - (headerTypeBytes[(longAt(weakOop)) & TypeMask]);
				oopGone = ((longAt(chunk)) & TypeMask) == HeaderTypeFree;
			}
			else {
				oopGone = !(((longAt(weakOop)) & MarkBit) != 0);
			}
			if (oopGone) {

				/* Store nil in the pointer and signal the  interpreter */
				longAtput(oop + i, GIV(nilObj));
#        if PharoVM
				if (numFields >= 2) {
					/* begin weakFinalizerCheck: */
					listOop = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
					if ((/* fetchClassOf: */
						((listOop & 1)
							? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
							: ((ccIndex = (((usqInt)((longAt(listOop)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(listOop - BaseHeaderSize)) & AllButTypeMask))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassWeakFinalizer) << (shiftForWord()))))))) {
						listItemOop = longAt((listOop + BaseHeaderSize) + (0U << (shiftForWord())));

						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(oop, GIV(youngStart))) {
							possibleRootStoreIntovalue(oop, listItemOop);
						}
						longAtput((oop + BaseHeaderSize) + (1U << (shiftForWord())), listItemOop);

						/* begin storePointer:ofObject:withValue: */
						if (oopisLessThan(listOop, GIV(youngStart))) {
							possibleRootStoreIntovalue(listOop, oop);
						}
						longAtput((listOop + BaseHeaderSize) + (0U << (shiftForWord())), oop);
					}
				}
#        endif // PharoVM


				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}
		}
	}
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */
/*	Useful for debugging */

	/* NewObjectMemory>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    sqInt fmt;
    sqInt header;
    sqInt headerSqInt;
    sqInt n;
    sqInt obj;
    unsigned int sz;
    unsigned int sz1;

	aCStringStrlen = strlen(aCString);
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			if (/* object:beginsWithString:ofSize: */
				(/* isBytes: */
				((obj & 1) == 0)
			 && (((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
			 && ((!(((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
			 && (((numBytesOfBytes(obj)) >= aCStringStrlen)
			 && ((strncmp(aCString, firstIndexableField(obj), aCStringStrlen)) == 0)))) {
				printHex(obj);

				/* begin space */
				printChar(' ');
				headerSqInt = longAt(obj);
				fmt = (((usqInt)(headerSqInt)) >> (instFormatFieldLSB())) & 15;

				/* begin lengthOf:baseHeader:format: */
				if (headerSqInt & TypeMask) {
					sz1 = headerSqInt & SizeMask;
				}
				else {
					sz1 = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
				}
				sz1 -= 0;
				if (fmt <= 4 /* lastPointerFormat */) {
					n = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
					goto l1;
				}
				n = (fmt < (firstByteFormat())
							? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
							: (sz1 - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf: */;

				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)n));
				printChar(' ');
				printOopShortInner(obj);
				fflush(GIV(transcript));
				cr();
			}

			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* NewObjectMemory>>#findString: */
void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    sqInt header;
    sqInt obj;
    unsigned int sz;

	aCStringStrlen = strlen(aCString);
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			if (/* object:equalsString:ofSize: */
				(/* isBytes: */
				((obj & 1) == 0)
			 && (((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
			 && ((!(((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
			 && (((numBytesOfBytes(obj)) == aCStringStrlen)
			 && ((strncmp(aCString, firstIndexableField(obj), aCStringStrlen)) == 0)))) {
				printHex(obj);

				/* begin space */
				printChar(' ');
				printOopShortInner(obj);
				fflush(GIV(transcript));
				cr();
			}

			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
}


/*	Return the first accessible object in the heap. */

	/* NewObjectMemory>>#firstAccessibleObject */
static sqInt
firstAccessibleObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt obj;
    unsigned int sz;

	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			return obj;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	return null;
}

	/* NewObjectMemory>>#floatObjectOf: */
sqInt
floatObjectOf(double aFloat)
{
    sqInt newFloatObj;

	newFloatObj = eeInstantiateSmallClassIndexformatnumSlots(ClassFloatCompactIndex, firstLongFormat(), (sizeof(double)) / BytesPerOop);
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* NewObjectMemory>>#floatValueOf: */
double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double result;

	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Do a mark/sweep garbage collection of the entire object memory.
	Free inaccessible objects but do not move them. */

	/* NewObjectMemory>>#fullGC */
void
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeSizeNow;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt sz;

	runLeakCheckerFor(GCModeFull);

	/* begin preGCAction: */
	if (GIV(stackPage)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statSweepCount) = (GIV(statMarkCount) = (GIV(statMkFwdCount) = (GIV(statCompMoveCount) = 0)));
	clearRootsTable();

	/* begin initWeakTableForIncrementalGC: */
	GIV(weakRootCount) = -1;

	/* process all of memory */
	GIV(youngStart) = startOfMemory();
	markPhase(1);
	GIV(totalObjectCount) = sweepPhaseForFullGC();
	runLeakCheckerFor(GCModeFull);

	/* begin fullCompaction */
	assert(GIV(compStart) == (lowestFreeAfter(startOfMemory())));
	if (GIV(compStart) == GIV(freeStart)) {

		/* memory is already compact; only free chunk is at the end */
		initializeMemoryFirstFree(GIV(freeStart));
		goto l1;
	}
	if (((sz = fwdTableSize(8))) < GIV(totalObjectCount)) {

		/* Try to grow OM to make a single pass full GC */
		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), ((GIV(totalObjectCount) - sz) + 10000) * 8);
		if (!(limit == GIV(memoryLimit))) {
			newMemoryLimit = limit - 24;

			/* begin setMemoryLimit: */
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}
	while (GIV(compStart) < GIV(freeStart)) {

		/* free chunk returned by incCompBody becomes start of next compaction */
		GIV(compStart) = incCompBody();
	}
l1:	/* end fullCompaction */;
	GIV(statFullGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);

	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);

	/* reset the young object boundary */
	GIV(youngStart) = GIV(freeStart);
	freeSizeNow = /* freeSize */
			(oopisLessThan(GIV(freeStart), GIV(reserveStart))
				? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
				: 0);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {
		/* begin shrinkObjectMemory: */
		GIV(statShrinkMemory) += 1;
		limit = sqShrinkMemoryBy(GIV(memoryLimit), freeSizeNow - GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			newMemoryLimit = limit - 24;

			/* begin setMemoryLimit: */
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}

	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	postGCUpdateDisplayBits();
	runLeakCheckerFor(GCModeFull);
}


/*	Set the limits for a table of two- or three-word forwarding blocks above
	the last used oop. The pointer fwdTableNext moves up to fwdTableLast. Used
	for compaction of memory and become-ing objects. Returns the number of
	forwarding blocks available.
 */
/*	set endOfMemory to just after a minimum-sized free block */

	/* NewObjectMemory>>#fwdTableInit: */
static NoDbgRegParms sqInt
fwdTableInit(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newEndOfMemory;

	/* begin setSizeOfFree:to: */
	longAtput(GIV(freeStart), (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	newEndOfMemory = GIV(freeStart) + BaseHeaderSize;

	/* begin setEndOfMemory: */
	assert((newEndOfMemory & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = newEndOfMemory;
	if (!GIV(freeStart)) {
		GIV(freeStart) = newEndOfMemory;
	}

	/* begin setSizeOfFree:to: */
	longAtput(GIV(endOfMemory), (BaseHeaderSize & AllButTypeMask) | HeaderTypeFree);
	GIV(fwdTableNext) = ((GIV(endOfMemory) + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */
	GIV(fwdTableLast) = GIV(memoryLimit) - blkSize;
	return (GIV(fwdTableLast) - GIV(fwdTableNext)) / blkSize;
}


/*	Estimate the number of forwarding blocks available for compaction */

	/* NewObjectMemory>>#fwdTableSize: */
static NoDbgRegParms sqInt
fwdTableSize(sqInt blkSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt eom;
    usqInt fwdFirst;
    sqInt fwdLast;

	/* use all memory free between freeStart and memoryLimit for forwarding table */
	/* Note: Forward blocks must be quadword aligned. */
	eom = GIV(freeStart) + BaseHeaderSize;
	fwdFirst = ((eom + BaseHeaderSize) + 7) & (WordMask - 7);
	flag("Dan");

	/* last forwarding table entry */
	/* return the number of forwarding blocks available */
	fwdLast = GIV(memoryLimit) - blkSize;
	return (fwdLast - fwdFirst) / blkSize;
}


/*	a more complex version that tells both the word reversal and the
	endianness of the machine it came from. Low half of word is 6502. Top byte
	is top byte of #doesNotUnderstand: on this machine. ($d on the Mac or $s
	on the PC)
 */

	/* NewObjectMemory>>#imageSegmentVersion */
static unsigned int
imageSegmentVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt wholeWord;

	/* first data word, 'does' */
	wholeWord = longAt((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))) + BaseHeaderSize);
	return 6505 /* imageFormatVersion */ | (wholeWord & 0xFF000000U);
}


/*	Move objects to consolidate free space into one big chunk. Return the
	newly created free chunk.
 */

	/* NewObjectMemory>>#incCompBody */
static usqInt
incCompBody(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToBeFreed;


	/* reserve memory for forwarding table */
	fwdTableInit(BytesPerWord * 2);

	/* update pointers to point at new oops */
	bytesToBeFreed = incCompMakeFwd();
	mapPointersInObjectsFromto(GIV(youngStart), GIV(freeStart));
	return incCompMove(bytesToBeFreed);
}


/*	Create and initialize forwarding blocks for all non-free objects 
	following compStart. If the supply of forwarding blocks is exhausted, 
	set compEnd to the first chunk above the area to be compacted;
	otherwise, set it to endOfMemory. Return the number of bytes to be freed. */

	/* NewObjectMemory>>#incCompMakeFwd */
static sqInt
incCompMakeFwd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToBeFreed;
    usqInt fwdBlock;
    usqInt fwdBlockUsqInt;
    sqInt header;
    sqInt headerSqInt;
    sqInt newOop;
    sqInt oop;
    sqInt originalHeader;
    usqInt originalHeaderType;
    sqInt realHeader;
    unsigned int sz;
    unsigned int sz1;

	bytesToBeFreed = 0;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	assert(oopisGreaterThanandLessThan(oop, startOfMemory(), GIV(freeStart)));
	while (oopisLessThan(oop, GIV(freeStart))) {
		GIV(statMkFwdCount) += 1;
		assert(oopisGreaterThanandLessThan(oop, startOfMemory(), GIV(freeStart)));
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			bytesToBeFreed += (longAt(oop)) & AllButTypeMask;
		}
		else {

			/* create a forwarding block for oop */
			/* begin fwdBlockGet: */
			GIV(fwdTableNext) += BytesPerWord * 2;
			if (GIV(fwdTableNext) <= GIV(fwdTableLast)) {
				fwdBlock = GIV(fwdTableNext);
			}
			else {
				fwdBlock = null;
			}
			if (!fwdBlock) {

				/* stop; we have used all available forwarding blocks */
				GIV(compEnd) = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
				return bytesToBeFreed;
			}
			newOop = oop - bytesToBeFreed;
			assert(oopisGreaterThanandLessThan(newOop, startOfMemory(), GIV(freeStart)));

			/* begin initForwardBlock:mapping:to:withBackPtr: */
			assert(fwdBlock != null);
			assert(!((hasForwardingBlock(oop))));
			originalHeader = longAt(oop);
			originalHeaderType = originalHeader & TypeMask;
			longAtput(fwdBlock, newOop);
			longAtput(fwdBlock + BytesPerWord, originalHeader);
			longAtput(oop, ((fwdBlock) >> 1) | (MarkBit | originalHeaderType));
		}

		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if (!(header & MarkBit)) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqInt = longAt(oop);
				sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlockUsqInt = ((header & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlockUsqInt));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlockUsqInt + BytesPerWord);
		if (realHeader & TypeMask) {
			sz = realHeader & SizeMask;
		}
		else {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
l1:	/* end objectAfterWhileForwarding: */;
	}
	GIV(compEnd) = GIV(freeStart);
	return bytesToBeFreed;
}


/*	Move all non-free objects between compStart and compEnd to their new 
	locations, restoring their headers in the process. Create a new free 
	block at the end of memory. Return the newly created free chunk. */
/*	Note: The free block used by the allocator always must be the last free 
	block in memory. It may take several compaction passes to make all 
	free space bubble up to the end of memory. */

	/* NewObjectMemory>>#incCompMove: */
static NoDbgRegParms usqInt
incCompMove(sqInt bytesFreed)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesToMove;
    usqInt firstWord;
    usqInt fwdBlock;
    usqInt fwdBlockUsqInt;
    sqInt header;
    sqInt header1;
    sqInt headerSqInt;
    sqInt headerSqIntSqInt;
    usqInt lastWord;
    usqInt newFreeChunk;
    sqInt newOop;
    sqInt next;
    sqInt oop;
    sqInt realHeader;
    usqInt sz;
    unsigned int sz1;
    unsigned int sz2;
    sqInt target;
    usqInt w;

	newOop = null;
	oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
	while (oopisLessThan(oop, GIV(compEnd))) {
		GIV(statCompMoveCount) += 1;

		/* begin objectAfterWhileForwarding: */
		header1 = longAt(oop);
		if (!(header1 & MarkBit)) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqIntSqInt = longAt(oop);
				sz1 = ((usqInt) ((headerSqIntSqInt & TypeMask
		? headerSqIntSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
			}
			next = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlockUsqInt = ((header1 & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlockUsqInt));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlockUsqInt + BytesPerWord);
		if (realHeader & TypeMask) {
			sz2 = realHeader & SizeMask;
		}
		else {
			sz2 = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		next = (oop + sz2) + (headerTypeBytes[(longAt(oop + sz2)) & TypeMask]);
l1:	/* end objectAfterWhileForwarding: */;
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {

			/* a moving object; unwind its forwarding block */
			fwdBlock = (((longAt(oop)) & AllButMarkBitAndTypeMask) << 1);
			assert(fwdBlockValid(fwdBlock));
			newOop = longAt(fwdBlock);
			header = longAt(fwdBlock + BytesPerWord);
			longAtput(oop, header);

			/* move the oop (including any extra header words) */
			bytesToMove = oop - newOop;

			/* begin sizeBitsOf: */
			headerSqInt = longAt(oop);
			sz = (headerSqInt & TypeMask
						? headerSqInt & SizeMask
						: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask);
			firstWord = oop - (headerTypeBytes[(longAt(oop)) & TypeMask]);
			lastWord = (oop + sz) - BaseHeaderSize;
			target = firstWord - bytesToMove;
			for (w = firstWord; w <= lastWord; w += BytesPerWord) {
				longAtput(target, longAt(w));
				target += BytesPerWord;
			}
		}
		oop = next;
	}
	if (newOop) {

		/* initialize the newly freed memory chunk */
		/* newOop is the last object moved; free chunk starts right after it */
		newFreeChunk = newOop + (sizeBitsOf(newOop));

		/* begin setSizeOfFree:to: */
		longAtput(newFreeChunk, (bytesFreed & AllButTypeMask) | HeaderTypeFree);
	}
	else {

		/* no objects moved */
		oop = GIV(compStart) + (headerTypeBytes[(longAt(GIV(compStart))) & TypeMask]);
		if ((((longAt(oop)) & TypeMask) == HeaderTypeFree)
		 && ((objectAfter(oop)) == (GIV(compEnd) + (headerTypeBytes[(longAt(GIV(compEnd))) & TypeMask])))) {
			newFreeChunk = oop;
		}
		else {
			newFreeChunk = GIV(freeStart);
		}
	}

	/* begin safeObjectAfter: */
	if (((longAt(newFreeChunk)) & TypeMask) == HeaderTypeFree) {
		sz1 = (longAt(newFreeChunk)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		headerSqInt = longAt(newFreeChunk);
		sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(newFreeChunk - (BytesPerWord * 2))) & LongSizeMask)));
	}
	next = ((((usqInt)(newFreeChunk + sz1))) >= GIV(freeStart)
				? ((sqInt)GIV(freeStart))
				: (newFreeChunk + sz1) + (headerTypeBytes[(longAt(newFreeChunk + sz1)) & TypeMask]));
	assert((next == GIV(freeStart))
	 || (next == (oopFromChunk(GIV(compEnd)))));
	if (next == GIV(freeStart)) {
		initializeMemoryFirstFree(newFreeChunk);
	}
	else {

		/* newFreeChunk is not at end of memory; re-install freeStart.
		   This will be the case when a compaction needs more than one pass. */
		initializeMemoryFirstFree(GIV(freeStart));
	}
	return newFreeChunk;
}


/*	Do a mark/sweep garbage collection of just the young object
	area of object memory (i.e., objects above youngStart), using
	the root table to identify objects containing pointers to
	young objects from the old object area. */

	/* NewObjectMemory>>#incrementalGC */
void
incrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt freeSizeNow;
    sqInt growth;
    sqInt i;
    sqInt limit;
    sqInt newMemoryLimit;
    sqInt survivorCount;
    sqInt weDidGrow;

	if (GIV(rootTableOverflowed)) {

		/* root table overflow; cannot do an incremental GC because some roots are missing.
		   (this should be very rare) */
		GIV(statRootTableOverflows) += 1;
		fullGC();
		return;
	}
	runLeakCheckerFor(GCModeNewSpace);

	/* begin preGCAction: */
	if (GIV(stackPage)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statSweepCount) = (GIV(statMarkCount) = (GIV(statMkFwdCount) = (GIV(statCompMoveCount) = 0)));

	/* begin initWeakTableForIncrementalGC: */
	GIV(weakRootCount) = 0;
	markPhase(0);
	assert(GIV(weakRootCount) <= WeakRootTableSize);
	for (i = 1; i <= GIV(weakRootCount); i += 1) {
		finalizeReference(GIV(weakRoots)[i]);
	}
	survivorCount = sweepPhase();
	runLeakCheckerFor(GCModeNewSpace);

	/* begin incrementalCompaction */
	if (GIV(compStart) == GIV(freeStart)) {

		/* Note: If compStart = freeStart then either the young
		   space is already compact  or there are enough forwarding table entries to do a
		   one-pass incr. compaction. */
		initializeMemoryFirstFree(GIV(freeStart));
	}
	else {
		incCompBody();
	}
	GIV(statIncrGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statIGCDeltaUsecs) = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statIncrGCUsecs) += GIV(statIGCDeltaUsecs);

	/* begin capturePendingFinalizationSignals */
	GIV(statPendingFinalizationSignals) = GIV(pendingFinalizationSignals);
	GIV(statRootTableCount) = GIV(rootTableCount);
	GIV(statSurvivorCount) = survivorCount;
	weDidGrow = 0;
	if (((survivorCount > GIV(tenuringThreshold))
	 || (GIV(rootTableCount) >= RootTableRedZone))
	 || (GIV(forceTenureFlag) == 1)) {

		/* move up the young space boundary if
		   * there are too many survivors:
		   this limits the number of objects that must be
		   processed on future incremental GC's
		   * we're about to overflow the roots table:
		   this limits the number of full GCs that may be caused
		   by root table overflows in the near future */
		GIV(forceTenureFlag) = 0;
		GIV(statTenures) += 1;
		clearRootsTable();
		if (((/* freeSize */
			(oopisLessThan(GIV(freeStart), GIV(reserveStart))
				? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
				: 0)) < GIV(growHeadroom))
		 && (GIV(gcBiasToGrow) > 0)) {
			/* begin biasToGrow */
			delta = ((GIV(growHeadroom) * 3) / 2) - (/* freeSize */
	(oopisLessThan(GIV(freeStart), GIV(reserveStart))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0));
			GIV(statGrowMemory) += 1;
			limit = sqGrowMemoryBy(GIV(memoryLimit), delta);
			if (!(limit == GIV(memoryLimit))) {
				newMemoryLimit = limit - 24;

				/* begin setMemoryLimit: */
				assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
				GIV(memoryLimit) = newMemoryLimit;
				initializeMemoryFirstFree(GIV(freeStart));
			}
			weDidGrow = 1;
		}
		GIV(youngStart) = GIV(freeStart);
	}

	/* begin attemptToShrink */
	freeSizeNow = /* freeSize */
			(oopisLessThan(GIV(freeStart), GIV(reserveStart))
				? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
				: 0);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {
		/* begin shrinkObjectMemory: */
		GIV(statShrinkMemory) += 1;
		limit = sqShrinkMemoryBy(GIV(memoryLimit), freeSizeNow - GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			newMemoryLimit = limit - 24;

			/* begin setMemoryLimit: */
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
	}

	/* begin postGCAction: */
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	postGCUpdateDisplayBits();
	runLeakCheckerFor(GCModeNewSpace);
	if (weDidGrow) {
		/* begin biasToGrowCheckGCLimit */
		growth = (GIV(youngStart) - (startOfMemory())) - GIV(gcBiasToGrowThreshold);
		if (growth < 0) {
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - GIV(memory);
		}
		if (growth > GIV(gcBiasToGrowGCLimit)) {
			fullGC();
			GIV(gcBiasToGrowThreshold) = GIV(youngStart) - GIV(memory);
		}
	}
}


/*	Initialize endOfMemory to the top of oop storage space, reserving some
	space for forwarding blocks, and set freeStart from which space is
	allocated. 
 */
/*	Note: The amount of space reserved for forwarding blocks should be chosen
	to ensure that incremental compactions can usually be done in a single
	pass. However, there should be enough forwarding blocks so a full
	compaction can be done
	in a reasonable number of passes, say ten. (A full compaction requires N
	object-moving passes, where N = number of non-garbage objects / number of
	forwarding blocks).
	
	di 11/18/2000 Re totalObjectCount: Provide a margin of one byte per object
	to be
	used for forwarding pointers at GC time. Since fwd blocks are 8 bytes,
	this means
	an absolute worst case of 8 passes to compact memory. In most cases it
	will be
	adequate to do compaction in a single pass. */
/*	reserve space for forwarding blocks and the interpreter. We can sacrifice
	forwarding block space at the cost of slower compactions but we cannot
	safely sacrifice interpreter allocation headroom. */

	/* NewObjectMemory>>#initializeMemoryFirstFree: */
static NoDbgRegParms void
initializeMemoryFirstFree(sqInt firstFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fwdBlockBytes;
    sqInt newEndOfMemory;
    sqInt totalReserve;

	fwdBlockBytes = GIV(totalObjectCount) & ((WordMask - BytesPerWord) + 1);
	totalReserve = fwdBlockBytes + (interpreterAllocationReserveBytes());
	if (oopisLessThan(GIV(memoryLimit) - totalReserve, firstFree + BaseHeaderSize)) {

		/* reserve enough space for a minimal free block of BaseHeaderSize bytes.
		   We are apparently in an emergency situation here because we have no space
		   for reserve and forwarding blocks.  But a full GC will occur immediately in
		   sufficientSpaceAfterGC: which will grow memory and restore the reserve. */
		fwdBlockBytes = GIV(memoryLimit) - (firstFree + BaseHeaderSize);
	}
	newEndOfMemory = GIV(memoryLimit) - fwdBlockBytes;

	/* begin setEndOfMemory: */
	assert((newEndOfMemory & (BytesPerWord - 1)) == 0);
	GIV(endOfMemory) = newEndOfMemory;
	if (!GIV(freeStart)) {
		GIV(freeStart) = newEndOfMemory;
	}
	GIV(reserveStart) = GIV(endOfMemory) - (interpreterAllocationReserveBytes());

	/* bytes available for oops */
	GIV(freeStart) = firstFree;
	GIV(scavengeThreshold) = (((GIV(freeStart) + GIV(edenBytes)) < GIV(reserveStart)) ? (GIV(freeStart) + GIV(edenBytes)) : GIV(reserveStart));
	assert(oopisLessThan(GIV(freeStart), GIV(reserveStart)));
	assert(oopisLessThan(GIV(endOfMemory), GIV(memoryLimit)));
}


/*	Initialize object memory variables at startup time. Assume endOfMemory is
	initially set (by the image-reading code) to the end of the last object in
	the image. Initialization redefines endOfMemory to be the end of the
	object allocation area based on the total available memory, but reserving
	some space for forwarding blocks.
 */
/*	Assume: image reader initializes the following variables:
	memory
	endOfMemory
	memoryLimit
	specialObjectsOop
	lastHash
	 */
/*	di 11/18/2000 fix slow full GC */
/*	set the start of the young object space */

	/* NewObjectMemory>>#initializeObjectMemory: */
static NoDbgRegParms void
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* image may be at a different address; adjust oops for new location */
	GIV(youngStart) = (GIV(freeStart) = GIV(endOfMemory));
	GIV(totalObjectCount) = adjustAllOopsBy(bytesToShift);
	initializeMemoryFirstFree(GIV(endOfMemory));

	/* heavily used special objects */
	GIV(specialObjectsOop) += bytesToShift;
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(NilObject) << (shiftForWord())))));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(FalseObject) << (shiftForWord())))));
	GIV(trueObj) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TrueObject) << (shiftForWord())))));
	GIV(rootTableCount) = 0;
	GIV(rootTableOverflowed) = 0;
	GIV(lowSpaceThreshold) = 0;
	GIV(signalLowSpace) = 0;
	GIV(compStart) = 0;
	GIV(compEnd) = 0;
	GIV(fwdTableNext) = 0;
	GIV(fwdTableLast) = 0;
	GIV(remapBufferCount) = 0;

	/* tenure all suriving objects if survivor count is over this threshold */
	GIV(tenuringThreshold) = 2000;

	/* four megabytes of headroom when growing */
	GIV(growHeadroom) = 0x400000;

	/* eight megabytes of free space before shrinking */
	/* garbage collection statistics */
	GIV(shrinkThreshold) = 0x800000;
	GIV(statFullGCs) = 0;
	GIV(statFullGCUsecs) = 0;
	GIV(statIncrGCs) = 0;
	GIV(statIncrGCUsecs) = 0;
	GIV(statTenures) = 0;
	GIV(statRootTableOverflows) = 0;
	GIV(statGrowMemory) = 0;
	GIV(statShrinkMemory) = 0;
	GIV(forceTenureFlag) = 0;
	GIV(gcBiasToGrow) = 0;
	GIV(gcBiasToGrowGCLimit) = 0;
	GIV(extraRootCount) = 0;
}


/*	c.f. {BlockContext. MethodContext. PseudoContext} collect: [:class| class
	-> class indexIfCompact]
 */

	/* NewObjectMemory>>#isContextHeader: */
static NoDbgRegParms int
isContextHeader(sqInt aHeader)
{
	return ((((usqInt)(aHeader)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex;
}


/*	Answer if obj is young. Assume obj is non-immediate. */

	/* NewObjectMemory>>#isYoungObject: */
int
isYoungObject(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(obj));
	return oopisGreaterThanOrEqualTo(obj, GIV(youngStart));
}


/*	Return the byte offset of the last pointer field of the given object. 
	Can be used even when the type bits are not correct.
	Works with CompiledMethods, as well as ordinary objects. */

	/* NewObjectMemory>>#lastPointerOf: */
static NoDbgRegParms sqInt
lastPointerOf(sqInt objOop)
{
    sqInt contextSize;
    usqInt fmt;
    sqInt header;
    usqInt numLiterals;
    sqInt sp;

	header = longAt(objOop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
			contextSize = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * BytesPerOop;
		}
		return (sizeBitsOfSafe(objOop)) - BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(objOop));
	header = longAt((objOop + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	numLiterals = ((((int) header)) < 0
				? ((header >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header)) >> 10) & 0xFF);
	return (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* NewObjectMemory>>#leakCheckFullGC */
int
leakCheckFullGC(void)
{
	return (checkForLeaks & GCModeFull) != 0;
}

	/* NewObjectMemory>>#leakCheckNewSpaceGC */
int
leakCheckNewSpaceGC(void)
{
	return (checkForLeaks & 2) != 0;
}

	/* NewObjectMemory>>#literalCountOfMethodHeader: */
usqInt
literalCountOfMethodHeader(sqInt methodHeader)
{
	assert((methodHeader & 1));
	return ((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF);
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed. It will return as its
	value the original array of roots, and the erstwhile segmentWordArray will
	have been truncated to a size of one word, i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to an unrecognizable and unusable jumble. But what more
	could you have done with it anyway?
 */

	/* NewObjectMemory>>#loadImageSegmentFrom:outPointers: */
static NoDbgRegParms sqInt
loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt data;
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    usqInt fmt;
    usqInt hdrTypeBits;
    sqInt header;
    sqInt headerSqInt;
    usqInt lastOut;
    usqInt lastPtr;
    sqInt mapOop;
    sqInt oop;
    usqInt outPtr;
    usqInt segOop;
    sqInt stopAddrSqInt;
    unsigned int sz;
    sqInt temp;
    sqInt wordAddr;

	hdrTypeBits = 0;
	lastOut = outPointerArray + (lastPointerOf(outPointerArray));

	/* Version check.  Byte order of the WordArray now */
	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BaseHeaderSize;
	data = longAt(segmentWordArray + BaseHeaderSize);
	if (!(/* readableFormat: */
			((data & 0xFFFF) == 6505 /* imageFormatVersion */)
		 || ((data & 0xFFFF) == 6504 /* imageFormatCompatibilityVersion */))) {

		/* low 2 bytes */
		/* Not readable -- try again with reversed bytes... */
		/* begin reverseBytesFrom:to: */
		addr = segmentWordArray + BaseHeaderSize;
		while (oopisLessThan(addr, endSeg + BytesPerWord)) {
			longAtput(addr, 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES((longAt(addr)))
#      else
				SQ_SWAP_8_BYTES((longAt(addr)))
#      endif
				);
			addr += BytesPerWord;
		}
		data = longAt(segmentWordArray + BaseHeaderSize);
		if (!(/* readableFormat: */
				((data & 0xFFFF) == 6505 /* imageFormatVersion */)
			 || ((data & 0xFFFF) == 6504 /* imageFormatCompatibilityVersion */))) {

			/* low 2 bytes */
			/* Still NG -- put things back and fail */
			/* begin reverseBytesFrom:to: */
			addr = segmentWordArray + BaseHeaderSize;
			while (oopisLessThan(addr, endSeg + BytesPerWord)) {
				longAtput(addr, 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES((longAt(addr)))
#        else
					SQ_SWAP_8_BYTES((longAt(addr)))
#        endif
					);
				addr += BytesPerWord;
			}
			return PrimErrBadArgument;
		}
	}
	if ((((usqInt)(data)) >> 16) == (((imageSegmentVersion())) >> 16)) {

		/* Need to swap floats if the segment is being loaded into a little-endian VM from a version
		   that keeps Floats in big-endian word order as was the case prior to the 6505 image format. */
		if (!((data & 0xFFFF) >= 6505)) {

			/* low 2 bytes */
			if ((/* vmEndianness */
				(VMBIGENDIAN
					? 1
					: 0)) != 1) {

				/* ~= 1 => little-endian */
				segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);

				/* begin wordSwapFloatsFrom:to: */
				oop = segOop;
				while (oopisLessThan(oop, endSeg + BytesPerWord)) {
					if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
						if ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()))
						 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex)) {
							temp = longAt(oop + BaseHeaderSize);
							longAtput(oop + BaseHeaderSize, longAt((oop + BaseHeaderSize) + 4));
							longAtput((oop + BaseHeaderSize) + 4, temp);
						}
					}

					/* begin objectAfter: */
					if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
						error("no objects after the end of memory");
					}
					if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
						sz = (longAt(oop)) & AllButTypeMask;
					}
					else {
						/* begin sizeBitsOf: */
						headerSqInt = longAt(oop);
						sz = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
					}
					oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
				}
			}
		}
	}
	else {

		/* Reverse the byte-type objects once */
		/* Oop of first embedded object */
		segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);

		/* begin byteSwapByteObjectsFrom:to:flipFloatsIf: */
		oop = segOop;
		while (oopisLessThan(oop, endSeg + BytesPerWord)) {
			if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
				fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
				if (fmt >= (firstByteFormat())) {

					/* oop contains bytes; unswap */
					wordAddr = oop + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat())) {

						/* compiled method; start after methodHeader and literals */
						wordAddr += ((literalCountOf(oop)) + LiteralStart) * BytesPerOop;
					}
					stopAddrSqInt = oop + (sizeBitsOf(oop));

					/* begin reverseBytesFrom:to: */
					addr = wordAddr;
					while (oopisLessThan(addr, stopAddrSqInt)) {
						longAtput(addr, 
#            if BytesPerWord == 4
							SQ_SWAP_4_BYTES((longAt(addr)))
#            else
							SQ_SWAP_8_BYTES((longAt(addr)))
#            endif
							);
						addr += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat())) {

					/* Bitmap, Float etc */
					if (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex) {
						if ((data & 0xFFFF) >= 6505) {
							temp = longAt(oop + BaseHeaderSize);
							longAtput(oop + BaseHeaderSize, longAt((oop + BaseHeaderSize) + 4));
							longAtput((oop + BaseHeaderSize) + 4, temp);
						}
					}
					else {
					}
				}
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqInt = longAt(oop);
				sz = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		}
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type = 0 or 1) -- start with that. */
			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */
			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */
		lastPtr = segOop + (lastPointerOf(segOop));
		if (lastPtr > endSeg) {
			return PrimErrBadIndex;
		}
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */
			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = (longAt(fieldPtr)) & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Integer -- nothing to do */
				fieldPtr += BytesPerWord;
			}
			else {
				if (fieldOop & 3) {
					return PrimErrBadIndex;
				}
				if (fieldOop & 0x80000000U) {

					/* External pointer -- look it up in outPointers */
					outPtr = outPointerArray + (fieldOop & 0x7FFFFFFF);
					if (outPtr > lastOut) {
						return PrimErrBadIndex;
					}
					mapOop = longAt(outPtr);
				}
				else {

					/* Internal pointer -- add segment offset */
					mapOop = fieldOop + segmentWordArray;
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += 8;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
				if (segOop < GIV(youngStart)) {
					possibleRootStoreIntovalue(segOop, mapOop);
				}
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(segOop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			headerSqInt = longAt(segOop);
			sz = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		segOop = ((sqInt) ((segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask])));
	}
	segOop = ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
	while (segOop <= endSeg) {
		if (!(oopHasAcceptableClass(segOop))) {
			return PrimErrInappropriate;
		}

		/* first field */
		fieldPtr = segOop + BaseHeaderSize;

		/* last field */
		/* Go through all oops, remapping them... */
		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */
			fieldOop = longAt(fieldPtr);
			if (!(oopHasAcceptableClass(fieldOop))) {
				return PrimErrInappropriate;
			}
			fieldPtr += BytesPerWord;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(segOop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			headerSqInt = longAt(segOop);
			sz = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		segOop = ((sqInt) ((segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask])));
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;
	if (extraSize == 8) {
		longAtput(segmentWordArray - extraSize, (BaseHeaderSize + BytesPerWord) + hdrTypeBits);
	}
	else {
		header = longAt(segmentWordArray);
		longAtput(segmentWordArray, ((header - (header & SizeMask)) + BaseHeaderSize) + BytesPerWord);
	}
	return ((segmentWordArray + BaseHeaderSize) + BytesPerWord) + (headerTypeBytes[(longAt((segmentWordArray + BaseHeaderSize) + BytesPerWord)) & TypeMask]);
}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* NewObjectMemory>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt headerSqInt;
    sqInt i;
    sqInt obj;
    sqInt oop;
    sqInt prntObj;
    unsigned int sz;
    unsigned int sz1;

	prntObj = 0;

	/* begin firstAccessibleObject */
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			oop = obj;
			goto l2;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l2:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
		 || (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
			if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
				i = (literalCountOf(oop)) + LiteralStart;
			}
			else {
				if (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(oop));
				}
				else {
					/* begin lengthOf: */
					header = longAt(oop);
					fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

					/* begin lengthOf:baseHeader:format: */
					if (header & TypeMask) {
						sz = header & SizeMask;
					}
					else {
						sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					}
					sz -= 0;
					if (fmt <= 4 /* lastPointerFormat */) {
						i = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
						goto l1;
					}
					i = (fmt < (firstByteFormat())
								? ((usqInt)((sz - BaseHeaderSize))) >> 2
								: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf: */;
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
					printHex(oop);

					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" @ ");
					fprintf(GIV(transcript),
							"%" PRIdSQINT "",
							((sqInt)i));
					cr();
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(oop);
			}
		}

		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz1 = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			headerSqInt = longAt(oop);
			sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l3;
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqInt = longAt(obj);
				sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
			}
			obj = (obj + sz1) + (headerTypeBytes[(longAt(obj + sz1)) & TypeMask]);
		}
		oop = null;
l3:	/* end accessibleObjectAfter: */;
	}
}


/*	Use the forwarding table to update the pointers of all non-free objects in
	the given range of memory.
	Also remap pointers in root objects which may contains pointers into the
	given memory range, and
	don't forget to flush the method cache based on the range. */

	/* NewObjectMemory>>#mapPointersInObjectsFrom:to: */
static NoDbgRegParms void
mapPointersInObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;
    sqInt probe;

	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(nilObj) & 1) == 0)
	 && (((longAt(GIV(nilObj))) & MarkBit) != 0)) {
		GIV(nilObj) = remapObj(GIV(nilObj));
	}
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(falseObj) & 1) == 0)
	 && (((longAt(GIV(falseObj))) & MarkBit) != 0)) {
		GIV(falseObj) = remapObj(GIV(falseObj));
	}
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(trueObj) & 1) == 0)
	 && (((longAt(GIV(trueObj))) & MarkBit) != 0)) {
		GIV(trueObj) = remapObj(GIV(trueObj));
	}
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(specialObjectsOop) & 1) == 0)
	 && (((longAt(GIV(specialObjectsOop))) & MarkBit) != 0)) {
		GIV(specialObjectsOop) = remapObj(GIV(specialObjectsOop));
	}
	mapInterpreterOops();

	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if (GIV(methodCache)[probe + MethodCacheSelector]) {
			if ((((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheSelector], memStart))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheSelector], memEnd)))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheClass], memStart))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheClass], memEnd))))
			 || ((oopisGreaterThanOrEqualTo(GIV(methodCache)[probe + MethodCacheMethod], memStart))
			 && (oopisLessThan(GIV(methodCache)[probe + MethodCacheMethod], memEnd)))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
	for (i = 1; i <= GIV(remapBufferCount); i += 1) {
		oop = GIV(remapBuffer)[i];
		if (/* shouldRemapOop: */
			((oop & 1) == 0)
		 && (/* isObjectForwarded: */
			((oop & 1) == 0)
		 && (((longAt(oop)) & MarkBit) != 0))) {
			GIV(remapBuffer)[i] = (remapObj(oop));
		}
	}
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!(((oop & 1))
			 || (((longAt(oop)) & TypeMask) == HeaderTypeFree))) {
			if (/* #shouldRemapObj: #isObjectForwarded: */
				((oop & 1) == 0)
			 && (((longAt(oop)) & MarkBit) != 0)) {
				(GIV(extraRoots)[i])[0] = (remapObj(oop));
			}
		}
	}
	updatePointersInRootObjectsFromto(memStart, memEnd);
	updatePointersInRangeFromto(memStart, memEnd);
}


/*	Mark phase of the mark and sweep garbage collector. Set 
	the mark bits of all reachable objects. Free chunks are 
	untouched by this process. */
/*	Assume: All non-free objects are initially unmarked. Root 
	objects were unmarked when they were made roots.
	(Make sure this stays true!!). */

	/* NewObjectMemory>>#markPhase: */
static NoDbgRegParms void
markPhase(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;
    sqInt statMarkCountPriorToStackPageFreeing;


	/* trace the interpreter's objects, including the active stacks
	   and special objects array */
	markAndTraceInterpreterOops(fullGCFlag);

	/* trace the roots */
	GIV(statSpecialMarkCount) = GIV(statMarkCount);
	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		markAndTrace(oop);
	}
	for (i = 1; i <= GIV(extraRootCount); i += 1) {
		oop = (GIV(extraRoots)[i])[0];
		if (!(((oop & 1))
			 || (((longAt(oop)) & TypeMask) == HeaderTypeFree))) {
			markAndTrace(oop);
		}
	}

	/* Only safe to free stack pages after all roots have been traced. */
	statMarkCountPriorToStackPageFreeing = GIV(statMarkCount);
	markAndTraceAndMaybeFreeStackPages(fullGCFlag);
	GIV(statSpecialMarkCount) += GIV(statMarkCount) - statMarkCountPriorToStackPageFreeing;
}


/*	Return the object or free chunk immediately following the 
	given object or free chunk in memory. Return endOfMemory 
	when enumeration is complete. */

	/* NewObjectMemory>>#objectAfter: */
sqInt
objectAfter(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    unsigned int sz;

	if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
		error("no objects after the end of memory");
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		sz = (longAt(oop)) & AllButTypeMask;
	}
	else {
		/* begin sizeBitsOf: */
		header = longAt(oop);
		sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
	}
	return (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* NewObjectMemory>>#okayOop: */
static NoDbgRegParms sqInt
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt fmt;
    sqInt header;
    usqInt oop;
    usqInt sz;
    usqInt type;
    sqInt unusedBit;

	/* address and size checks */
	oop = ((usqInt) signedOop);
	if ((oop & 1)) {
		return 1;
	}
	if (!((oop >= (startOfMemory()))
		 && (oop < GIV(freeStart)))) {
		error("oop is not a valid address");
		return 0;
	}
	if (oop % BytesPerWord) {
		error("oop is not a word-aligned address");
		return 0;
	}

	/* begin sizeBitsOf: */
	header = longAt(oop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask);
	if (!((oop + sz) <= GIV(freeStart))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	type = (longAt(oop)) & TypeMask;
	if (type == HeaderTypeFree) {
		error("oop is a free chunk, not an object");
		return 0;
	}
	if (type == HeaderTypeShort) {
		if (!((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)) {
			error("cannot have zero compact class field in a short header");
			return 0;
		}
	}
	if (type == HeaderTypeClass) {
		if (!((oop >= BytesPerWord)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	if (!type) {
		if (!((oop >= (BytesPerWord * 2))
			 && ((((longAt(oop - (BytesPerWord * 2))) & TypeMask) == type)
			 && (((longAt(oop - BytesPerWord)) & TypeMask) == type)))) {
			error("class header word has wrong type");
			return 0;
		}
	}
	fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	if ((fmt == 5) || (fmt == 7)) {
		error("oop has an unknown format type");
		return 0;
	}
	unusedBit = 0x20000000;
	if ((longAt(oop)) & unusedBit) {
		error("unused header bit 30 is set; should be zero");
		return 0;
	}
	if ((((longAt(oop)) & RootBit) != 0)
	 && (oop >= GIV(youngStart))) {
		error("root bit is set in a young object");
		return 0;
	}
	return 1;
}


/*	Similar to oopHasOkayClass:, except that it only returns true or false. */

	/* NewObjectMemory>>#oopHasAcceptableClass: */
static NoDbgRegParms sqInt
oopHasAcceptableClass(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    usqInt ccIndex;
    int formatMask;
    usqInt oop;
    usqInt oopClass;
    sqInt oopFormatBits;

	if ((signedOop & 1)) {
		return 1;
	}
	oop = ((usqInt) signedOop);
	if (!(/* addressCouldBeObj: */
			((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		return 0;
	}
	oopClass = ((usqInt) (/* fetchClassOfNonImm: */
	((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
		? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
		: (longAt(oop - BaseHeaderSize)) & AllButTypeMask)));
	if (!(/* addressCouldBeObj: */
			((oopClass & 3) == 0)
		 && (((((usqInt)oopClass)) >= (startOfMemory()))
		 && (((((usqInt)oopClass)) < GIV(freeStart))
		 && (((longAt(oopClass)) & TypeMask) != HeaderTypeGC))))) {
		return 0;
	}
	if (!((oopClass + (sizeBitsOf(oopClass))) <= GIV(freeStart))) {
		return 0;
	}
	if (!((((((usqInt)((longAt(oopClass)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
		 && ((lengthOf(oopClass)) >= 3))) {
		return 0;
	}
	formatMask = (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())
				? 0xC00
				: 0xF00);
	behaviorFormatBits = ((longAt((oopClass + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1) & formatMask;
	oopFormatBits = (longAt(oop)) & formatMask;
	if (!(behaviorFormatBits == oopFormatBits)) {
		return 0;
	}
	return 1;
}


/*	For forward-compatibility with Spur. Fail; ObjectMemory does not support
	pinning. 
 */

	/* NewObjectMemory>>#pinObject: */
sqInt
pinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
	return 0;
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* NewObjectMemory>>#printActivationsOf: */
void
printActivationsOf(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = firstAccessibleObject();
	while (!(oop == null)) {
		if ((((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
		 && (aMethodObj == (longAt((oop + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))))))) {
			printHex(oop);

			/* begin space */
			printChar(' ');
			printOopShortInner(oop);
			fflush(GIV(transcript));
			print(" pc ");
			printHex(longAt((oop + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord()))))));
			cr();
		}
		oop = accessibleObjectAfter(oop);
	}
}

	/* NewObjectMemory>>#printCantBeObject:on: */
static NoDbgRegParms void
printCantBeObjecton(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p%s\n",
			((void *)oop),
			(oop & (BytesPerWord - 1)
			? " is misaligned"
			: whereIs(oop)));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* NewObjectMemory>>#printContextReferencesTo: */
void
printContextReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int i;
    sqInt oop;

	i = 0;
	oop = firstAccessibleObject();
	while (!(oop == null)) {
		if (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
			i = CtxtTempFrameStart + (fetchStackPointerOf(oop));
		}
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((oop + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
				printHex(oop);
				print(" @ ");
				printNum(i);

				/* begin space */
				printChar(' ');
				printOopShortInner(oop);
				fflush(GIV(transcript));
				print(" pc ");
				printHex(longAt((oop + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord()))))));
				cr();
				i = 0;
			}
		}
		oop = accessibleObjectAfter(oop);
	}
}

	/* NewObjectMemory>>#printMemField:name:size: */
static NoDbgRegParms void
printMemFieldnamesize(usqInt memField, char *name, sqInt length)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"%s\t%p/%" PRIdSQINT " sz: %p",
			name,
			((void *)memField),
			memField,
			length);
	if (length) {
		fprintf(GIV(transcript),
				"/%" PRIuSQINT "",
				length);
	}
	cr();
}

	/* NewObjectMemory>>#printMemory */
void
printMemory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printMemFieldnamesize(startOfMemory(), "memory      ", GIV(youngStart) - (startOfMemory()));
	printMemFieldnamesize(GIV(youngStart), "youngStart  ", GIV(freeStart) - GIV(youngStart));
	if (GIV(freeStart) <= GIV(scavengeThreshold)) {
		printMemFieldnamesize(GIV(freeStart), "freeStart   ", GIV(reserveStart) - GIV(freeStart));
		printMemFieldnamesize(GIV(scavengeThreshold), "scavenge@   ", GIV(scavengeThreshold) - GIV(freeStart));
	}
	else {
		printMemFieldnamesize(GIV(scavengeThreshold), "scavenge@   ", GIV(scavengeThreshold) - GIV(freeStart));
		printMemFieldnamesize(GIV(freeStart), "freeStart   ", GIV(reserveStart) - GIV(freeStart));
	}
	printMemFieldnamesize(GIV(reserveStart), "reserveStart", GIV(endOfMemory) - GIV(reserveStart));
	printMemFieldnamesize(GIV(endOfMemory), "endOfMemory ", GIV(memoryLimit) - GIV(endOfMemory));
	printMemFieldnamesize(GIV(memoryLimit), "memoryLimit ", 0);
}


/*	useful for VM debugging */

	/* NewObjectMemory>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt oop;
    unsigned int sz;

	oop = startAddress;
	while (oopisLessThan(oop, endAddress)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			printOop(oop);
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */
/*	useful for VM debugging */

	/* NewObjectMemory>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt i;
    sqInt oop;
    unsigned int sz;

	oop = firstAccessibleObject();
	while (!(oop == null)) {
		if ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
		 || (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
			if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
				i = (literalCountOf(oop)) + LiteralStart;
			}
			else {
				if (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(oop));
				}
				else {
					/* begin lengthOf: */
					header = longAt(oop);
					fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

					/* begin lengthOf:baseHeader:format: */
					if (header & TypeMask) {
						sz = header & SizeMask;
					}
					else {
						sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
					}
					sz -= 0;
					if (fmt <= 4 /* lastPointerFormat */) {
						i = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
						goto l1;
					}
					i = (fmt < (firstByteFormat())
								? ((usqInt)((sz - BaseHeaderSize))) >> 2
								: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf: */;
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
					printHex(oop);
					print(" @ ");
					printNum(i);

					/* begin space */
					printChar(' ');
					printOopShortInner(oop);
					fflush(GIV(transcript));
					cr();
					i = 0;
				}
			}
		}
		oop = accessibleObjectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all contexts whose size is not
	either SmallContextSize or LargeContextSize
 */
/*	useful for VM debugging */

	/* NewObjectMemory>>#printWronglySizedContexts: */
void
printWronglySizedContexts(sqInt printContexts)
{
    sqInt oop;

	oop = firstAccessibleObject();
	while (!(oop == null)) {
		if ((((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
		 && (badContextSize(oop))) {
			printHex(oop);

			/* begin space */
			printChar(' ');
			printNum(numBytesOf(oop));
			cr();
			if (printContexts) {
				printContext(oop);
			}
		}
		oop = accessibleObjectAfter(oop);
	}
}


/*	Restore headers smashed by forwarding links */

	/* NewObjectMemory>>#restoreHeadersFrom:to:from:and:to:from: */
static NoDbgRegParms void
restoreHeadersFromtofromandtofrom(sqInt firstIn, sqInt lastIn, sqInt hdrBaseIn, sqInt firstOut, sqInt lastOut, sqInt hdrBaseOut)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt headerSqInt;
    sqInt oop;
    unsigned int sz;
    sqInt tablePtr;

	tablePtr = firstIn;
	while (oopisLessThanOrEqualTo(tablePtr, lastIn)) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseIn + (tablePtr - firstIn));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	tablePtr = firstOut;
	while (oopisLessThanOrEqualTo(tablePtr, lastOut)) {
		oop = longAt(tablePtr);
		header = longAt(hdrBaseOut + (tablePtr - firstOut));
		longAtput(oop, header);
		tablePtr += BytesPerWord;
	}
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(oop, GIV(freeStart))) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			longAtput(oop, (longAt(oop)) & AllButMarkBit);
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			headerSqInt = longAt(oop);
			sz = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}

	/* NewObjectMemory>>#runLeakCheckerFor: */
static NoDbgRegParms void
runLeakCheckerFor(sqInt gcModes)
{
	if (((gcModes & checkForLeaks) != 0)) {
		if (((gcModes & GCModeFull) != 0)) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrity());
		assert((checkInterpreterIntegrity()) == 0);
		assert(checkStackIntegrity());
		assert(checkCodeIntegrity(gcModes));
	}
}


/*	Version of printStringOf: that copes with forwarding during garbage
	collection. 
 */

	/* NewObjectMemory>>#safePrintStringOf: */
static NoDbgRegParms sqInt
safePrintStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    usqInt fmt;
    usqInt fwdBlock;
    sqInt header;
    sqInt i;

	if ((oop & 1)) {
		return null;
	}
	if (!(oopisGreaterThanOrEqualToandLessThan(oop, startOfMemory(), GIV(freeStart)))) {
		return null;
	}
	if (oop & (BytesPerWord - 1)) {
		return null;
	}

	/* begin headerWhileForwardingOf: */
	header = longAt(oop);
	if (header & MarkBit) {

		/* oop is forwarded; get its real header from its forwarding table entry */
		fwdBlock = ((header & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlock));
		header = longAt(fwdBlock + BytesPerWord);
	}
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	if (fmt < 8) {
		return null;
	}
	cnt = ((100 < (lengthOfbaseHeaderformat(oop, header, fmt))) ? 100 : (lengthOfbaseHeaderformat(oop, header, fmt)));
	i = 0;
	while (i < cnt) {
		printChar(byteAt((oop + BaseHeaderSize) + i));
		i += 1;
	}

	/* begin flush */
	fflush(GIV(transcript));
	return oop;
}


/*	Reduce the number of indexable fields in obj, a pointer object, to nSlots.
	Convert the
	unused residual to a free chunk. Word and byte indexable objects are not
	changed. Answer the number of bytes returned to free memory, which may be
	zero if no change
	was possible.
 */

	/* NewObjectMemory>>#shorten:toIndexableSize: */
sqInt
shortentoIndexableSize(sqInt obj, sqInt nSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt deltaBytes;
    sqInt desiredLength;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt indexableFields;
    unsigned int sz;
    sqInt totalLength;

	if (!(((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)) {
		return 0;
	}
	if (!(nSlots > 0)) {
		return 0;
	}
	hdr = longAt(obj);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(obj - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(obj)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(obj - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	indexableFields = totalLength - fixedFields;
	if (nSlots >= indexableFields) {
		return 0;
	}
	desiredLength = fixedFields + nSlots;
	deltaBytes = (totalLength - desiredLength) * BytesPerWord;
	if (((obj + BaseHeaderSize) + (totalLength * BytesPerWord)) == GIV(freeStart)) {

		/* Shortening the last object.  Need to reduce freeStart. */
		GIV(freeStart) = (obj + BaseHeaderSize) + (desiredLength * BytesPerWord);
	}
	else {

		/* Shortening some interior object.  Need to create a free block. */
		/* begin setSizeOfFree:to: */
		longAtput((obj + BaseHeaderSize) + (desiredLength * BytesPerWord), (deltaBytes & AllButTypeMask) | HeaderTypeFree);
	}
	switch ((longAt(obj)) & TypeMask) {
	case HeaderTypeSizeAndClass:
		longAtput(obj - (BaseHeaderSize * 2), (longAt(obj - (BytesPerWord * 2))) - deltaBytes);
		break;
	case HeaderTypeClass:
	case HeaderTypeShort:
		longAtput(obj, (((hdr | SizeMask) - SizeMask)) | ((hdr & SizeMask) - deltaBytes));
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return deltaBytes;
}


/*	Compute the size of the given object from the cc and size fields in its
	header. This works even if its type bits are not correct. */

	/* NewObjectMemory>>#sizeBitsOfSafe: */
static NoDbgRegParms usqInt
sizeBitsOfSafe(sqInt oop)
{
    sqInt header;
    sqInt type;

	header = longAt(oop);
	type = /* rightType: */
			(header & SizeMask
				? (header & CompactClassMask
						? HeaderTypeShort
						: HeaderTypeClass)
				: HeaderTypeSizeAndClass);
	return (type
			? header & SizeMask
			: (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask);
}


/*	Answer the number of bytes in the given object, including its base header,
	rounded up to an integral number of words.
 */
/*	Note: byte indexable objects need to have low bits subtracted from this
	size. 
 */

	/* NewObjectMemory>>#sizeBitsOf: */
static NoDbgRegParms usqInt
sizeBitsOf(sqInt oop)
{
    sqInt header;

	header = longAt(oop);
	return (header & TypeMask
			? header & SizeMask
			: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask);
}


/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

	/* NewObjectMemory>>#storeImageSegmentInto:outPointers:roots: */
static NoDbgRegParms sqInt
storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt doingClass;
    usqInt endSeg;
    sqInt extraSize;
    sqInt fieldOop;
    usqInt fieldPtr;
    usqInt firstIn;
    usqInt firstOut;
    usqInt hdrBaseIn;
    usqInt hdrBaseOut;
    usqInt hdrTypeBits;
    sqInt header;
    sqInt headerSqInt;
    sqInt i;
    sqInt in;
    sqInt iSqInt;
    sqInt lastAddr;
    sqInt lastAddrSqInt;
    usqInt lastIn;
    sqInt lastInSqInt;
    usqInt lastOut;
    usqInt lastPtr;
    usqInt lastSeg;
    unsigned int mapOop;
    sqInt out;
    usqInt savedYoungStart;
    usqInt segOop;
    unsigned int sz;
    sqInt versionOffset;

	hdrTypeBits = 0;
	if (!((((longAt(outPointerArray)) & TypeMask) == HeaderTypeSizeAndClass)
		 && (((longAt(segmentWordArray)) & TypeMask) == HeaderTypeSizeAndClass))) {

		/* Must be 3-word header */
		return PrimErrGenericFailure;
	}
	firstOut = outPointerArray + BaseHeaderSize;
	lastOut = firstOut - BytesPerWord;

	/* top half */
	hdrBaseOut = outPointerArray + (((lastPointerOf(outPointerArray)) / (BytesPerWord * 2)) * BytesPerWord);
	lastSeg = segmentWordArray;

	/* Write a version number for byte order and version check */
	endSeg = (segmentWordArray + (sizeBitsOf(segmentWordArray))) - BytesPerWord;
	versionOffset = BytesPerWord;
	lastSeg += versionOffset;
	if (lastSeg > endSeg) {
		return PrimErrGenericFailure;
	}
	longAtput(lastSeg, imageSegmentVersion());

	/* Take 1/8 of seg */
	firstIn = endSeg - (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 8)) * BytesPerWord);
	lastIn = firstIn - BytesPerWord;

	/* top half of that */
	/* First mark the rootArray and all root objects. */
	hdrBaseIn = firstIn + (((sizeBitsOf(segmentWordArray)) / (BytesPerWord * 16)) * BytesPerWord);
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) | MarkBit);
	lastPtr = arrayOfRoots + (lastPointerOf(arrayOfRoots));
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) | MarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	savedYoungStart = GIV(youngStart);

	/* process all of memory */
	GIV(youngStart) = startOfMemory();
	markAndTraceInterpreterOops(0);

	/* Finally unmark the rootArray and all root objects. */
	GIV(youngStart) = savedYoungStart;
	longAtput(arrayOfRoots, (longAt(arrayOfRoots)) & AllButMarkBit);
	fieldPtr = arrayOfRoots + BaseHeaderSize;
	while (fieldPtr <= lastPtr) {
		fieldOop = longAt(fieldPtr);
		if (!((fieldOop & 1))) {
			longAtput(fieldOop, (longAt(fieldOop)) & AllButMarkBit);
		}
		fieldPtr += BytesPerWord;
	}
	lastIn += BytesPerWord;
	if ((lastIn >= hdrBaseIn)
	 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(arrayOfRoots, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {
		lastIn -= BytesPerWord;
		restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);

		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
		i = outPointerArray + BaseHeaderSize;
		while (i <= lastAddr) {
			longAtput(i, GIV(nilObj));
			i += BytesPerWord;
		}
		return PrimErrGenericFailure;
	}
	segOop = ((segmentWordArray + versionOffset) + BaseHeaderSize) + (headerTypeBytes[(longAt((segmentWordArray + versionOffset) + BaseHeaderSize)) & TypeMask]);
	while (segOop <= lastSeg) {
		if (((longAt(segOop)) & TypeMask) <= 1) {

			/* This object has a class field (type=0 or 1) -- start with that. */
			fieldPtr = segOop - BytesPerWord;
			doingClass = 1;
		}
		else {

			/* No class field -- start with first data field */
			fieldPtr = segOop + BaseHeaderSize;
			doingClass = 0;
		}

		/* last field */
		/* Go through all oops, remapping them... */
		lastPtr = segOop + (lastPointerOf(segOop));
		while (!(fieldPtr > lastPtr)) {

			/* Examine each pointer field */
			fieldOop = longAt(fieldPtr);
			if (doingClass) {
				hdrTypeBits = fieldOop & TypeMask;
				fieldOop -= hdrTypeBits;
			}
			if ((fieldOop & 1)) {

				/* Just an integer -- nothing to do */
				fieldPtr += BytesPerWord;
			}
			else {
				header = longAt(fieldOop);
				if ((header & TypeMask) == HeaderTypeFree) {

					/* Has already been forwarded -- this is the link */
					mapOop = header & AllButTypeMask;
				}
				else {
					if ((longAt(fieldOop)) & MarkBit) {

						/* Points to a marked obj -- an external pointer.
						   Map it as a tagged index in outPointers, and forward its oop. */
						lastOut += BytesPerWord;
						if (lastOut >= hdrBaseOut) {

							/* Out of space in outPointerArray */
							lastOut -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);

							/* begin primitiveFailCodeAfterCleanup: */
							lastAddrSqInt = outPointerArray + (lastPointerOf(outPointerArray));
							iSqInt = outPointerArray + BaseHeaderSize;
							while (iSqInt <= lastAddrSqInt) {
								longAtput(iSqInt, GIV(nilObj));
								iSqInt += BytesPerWord;
							}
							return PrimErrGenericFailure;
						}
						mapOop = (lastOut - outPointerArray) | 0x80000000U;

						/* begin forward:to:savingOopAt:andHeaderAt: */
						longAtput(lastOut, fieldOop);
						longAtput(hdrBaseOut + (lastOut - firstOut), longAt(fieldOop));
						longAtput(fieldOop, mapOop + HeaderTypeFree);
					}
					else {

						/* Points to an unmarked obj -- an internal pointer.
						   Copy the object into the segment, and forward its oop. */
						lastIn += BytesPerWord;
						if ((lastIn >= hdrBaseIn)
						 || (0 == ((lastSeg = copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(fieldOop, segmentWordArray, lastSeg, firstIn, lastIn, hdrBaseIn + (lastIn - firstIn)))))) {

							/* Out of space in segment */
							lastIn -= BytesPerWord;
							restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);

							/* begin primitiveFailCodeAfterCleanup: */
							lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
							i = outPointerArray + BaseHeaderSize;
							while (i <= lastAddr) {
								longAtput(i, GIV(nilObj));
								i += BytesPerWord;
							}
							return PrimErrGenericFailure;
						}
						mapOop = (longAt(fieldOop)) & AllButTypeMask;
					}
				}
				if (doingClass) {
					longAtput(fieldPtr, mapOop + hdrTypeBits);
					fieldPtr += BytesPerWord * 2;
					doingClass = 0;
				}
				else {
					longAtput(fieldPtr, mapOop);
					fieldPtr += BytesPerWord;
				}
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(segOop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(segOop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(segOop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			headerSqInt = longAt(segOop);
			sz = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(segOop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		segOop = ((sqInt) ((segOop + sz) + (headerTypeBytes[(longAt(segOop + sz)) & TypeMask])));
	}
	restoreHeadersFromtofromandtofrom(firstIn, lastIn, hdrBaseIn, firstOut, lastOut, hdrBaseOut);
	if ((((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) < 12)
	 || ((endSeg - lastSeg) < 12)) {

		/* Not enough room to insert simple 3-word headers */
		/* begin primitiveFailCodeAfterCleanup: */
		lastAddr = outPointerArray + (lastPointerOf(outPointerArray));
		i = outPointerArray + BaseHeaderSize;
		while (i <= lastAddr) {
			longAtput(i, GIV(nilObj));
			i += BytesPerWord;
		}
		return PrimErrGenericFailure;
	}
	extraSize = headerTypeBytes[(longAt(segmentWordArray)) & TypeMask];

	/* Copy the 3-word wordArray header to establish a free chunk. */
	hdrTypeBits = (longAt(segmentWordArray)) & TypeMask;

	/* begin transfer:from:to: */
	in = (segmentWordArray - extraSize) - BytesPerWord;
	lastInSqInt = in + (3 * BytesPerWord);
	out = (lastOut + BytesPerWord) - BytesPerWord;
	while (oopisLessThan(in, lastInSqInt)) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	longAtput(lastOut + BytesPerWord, (((outPointerArray + (lastPointerOf(outPointerArray))) - lastOut) - extraSize) + hdrTypeBits);
	longAtput(outPointerArray - extraSize, ((lastOut - firstOut) + (BytesPerWord * 2)) + hdrTypeBits);
	beRootIfOld(outPointerArray);

	/* begin transfer:from:to: */
	in = (segmentWordArray - extraSize) - BytesPerWord;
	lastInSqInt = in + (3 * BytesPerWord);
	out = (lastSeg + BytesPerWord) - BytesPerWord;
	while (oopisLessThan(in, lastInSqInt)) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	longAtput(segmentWordArray - extraSize, ((lastSeg - segmentWordArray) + BaseHeaderSize) + hdrTypeBits);
	longAtput(lastSeg + BytesPerWord, ((endSeg - lastSeg) - extraSize) + hdrTypeBits);
	return PrimNoErr;
}


/*	Return true if there is enough free space after doing a garbage
	collection. If not, signal that space is low.
 */

	/* NewObjectMemory>>#sufficientSpaceAfterGC: */
static NoDbgRegParms sqInt
sufficientSpaceAfterGC(sqInt minFree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt limit;
    sqInt newMemoryLimit;
    usqInt oldLimit;

	oldLimit = 0;
	incrementalGC();
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		return 1;
	}
	if (GIV(signalLowSpace)) {
		return 0;
	}
	fullGC();
	if (oopisLessThan((GIV(freeStart) + minFree) + 15000, GIV(reserveStart))) {
		return 1;
	}
	while (1) {
		oldLimit = GIV(memoryLimit);

		/* begin growObjectMemory: */
		GIV(statGrowMemory) += 1;
		limit = sqGrowMemoryBy(GIV(memoryLimit), (minFree + 15000) + GIV(growHeadroom));
		if (!(limit == GIV(memoryLimit))) {
			newMemoryLimit = limit - 24;

			/* begin setMemoryLimit: */
			assert((newMemoryLimit & (BytesPerWord - 1)) == 0);
			GIV(memoryLimit) = newMemoryLimit;
			initializeMemoryFirstFree(GIV(freeStart));
		}
		if (oopisLessThan((GIV(freeStart) + minFree) + 15000, GIV(reserveStart))) break;

		/* If the memoryLimit doesn't change then presumably the platform can't grow anymore. */
		if (oldLimit == GIV(memoryLimit)) {
			return 0;
		}
	}
	return 1;
}


/*	Return true if there is enough space to allocate the given number of
	bytes, perhaps after doing a garbage collection.
 */

	/* NewObjectMemory>>#sufficientSpaceToAllocate: */
static NoDbgRegParms sqInt
sufficientSpaceToAllocate(sqInt bytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt minFree;

	/* check for low-space */
	minFree = ((((((GIV(lowSpaceThreshold) + bytes) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
	if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
		return 1;
	}
	return sufficientSpaceAfterGC(minFree);
}


/*	Sweep memory from youngStart through the end of memory. Free all 
	inaccessible objects and coalesce adjacent free chunks. Clear the mark 
	bits of accessible objects. Compute the starting point for the first pass
	of 
	incremental compaction (compStart). Return the number of surviving 
	objects. */
/*	Details: Each time a non-free object is encountered, decrement the 
	number of available forward table entries. If all entries are spoken for 
	(i.e., entriesAvailable reaches zero), set compStart to the last free 
	chunk before that object or, if there is no free chunk before the given 
	object, the first free chunk after it. Thus, at the end of the sweep 
	phase, compStart through compEnd spans the highest collection of 
	non-free objects that can be accomodated by the forwarding table. This 
	information is used by the first pass of incremental compaction to 
	ensure that space is initially freed at the end of memory. Note that 
	there should always be at least one free chunk--the one at the end of 
	the heap. */

	/* NewObjectMemory>>#sweepPhase */
static sqInt
sweepPhase(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt entriesAvailable;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    usqInt freeStartLocal;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    usqInt oopHeaderType;
    usqInt oopSize;
    sqInt survivors;

	freeChunkSize = 0;
	entriesAvailable = fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */
	firstFree = null;
	freeStartLocal = GIV(freeStart);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < freeStartLocal) {

		/* get oop's header, header type, size, and header size */
		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType) {

				/* free chunk */
				oopSize = oopHeader & LongSizeMask;
			}
			else {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
		}
		if (oopHeader & MarkBit) {

			/* object is marked; clear its mark bit and possibly adjust
			   the compaction start */
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
				finalizeReference(oop);
			}
			if (entriesAvailable > 0) {
				entriesAvailable -= 1;
			}
			else {

				/* start compaction at the last free chunk before this object */
				firstFree = freeChunk;
			}
			if (freeChunk) {

				/* record the size of the last free chunk */
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		else {

			/* object is not marked; free it */
			/* <-- Finalization support: We need to mark each oop chunk as free --> */
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk) {

				/* enlarge current free chunk to include this oop */
				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */
				/* chunk may start 4 or 8 bytes before oop */
				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */
				freeChunkSize = oopSize + (oop - freeChunk);
				if (!firstFree) {
					firstFree = freeChunk;
				}
			}
		}
		if (!oopSize) {
			error("zero sized object encountered in sweep");
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk) {

		/* record size of final free chunk */
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (!(oop == GIV(freeStart))) {
		error("sweep failed to find exact end of memory");
	}
	GIV(compStart) = (firstFree
				? firstFree
				: GIV(freeStart));
	return survivors;
}


/*	Sweep memory from youngStart through the end of memory. Free all
	inaccessible objects and coalesce adjacent free chunks. Clear the mark
	bits of accessible objects. Compute the starting point for the first pass
	of incremental compaction (compStart). Return the number of surviving
	objects. Unlike sweepPhase this always leaves compStart pointing at the
	first free chunk. */

	/* NewObjectMemory>>#sweepPhaseForFullGC */
static sqInt
sweepPhaseForFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt endOfMemoryLocal;
    sqInt firstFree;
    sqInt freeChunk;
    sqInt freeChunkSize;
    sqInt hdrBytes;
    usqInt oop;
    sqInt oopHeader;
    usqInt oopHeaderType;
    usqInt oopSize;
    sqInt survivors;

	freeChunkSize = 0;
	fwdTableInit(BytesPerWord * 2);
	survivors = 0;
	freeChunk = null;

	/* will be updated later */
	firstFree = null;
	endOfMemoryLocal = GIV(endOfMemory);
	oop = GIV(youngStart) + (headerTypeBytes[(longAt(GIV(youngStart))) & TypeMask]);
	while (oop < endOfMemoryLocal) {

		/* get oop's header, header type, size, and header size */
		GIV(statSweepCount) += 1;
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		hdrBytes = headerTypeBytes[oopHeaderType];
		if ((oopHeaderType & 1) == 1) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			if (oopHeaderType) {
				assert((oopHeader & MarkBit) == 0);
				oopSize = oopHeader & LongSizeMask;
			}
			else {
				oopSize = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
		}
		if (oopHeader & MarkBit) {

			/* object is marked; clear its mark bit and possibly adjust
			   the compaction start */
			longAtput(oop, oopHeader & AllButMarkBit);
			if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat())) {
				finalizeReference(oop);
			}
			if (freeChunk) {

				/* record the size of the last free chunk */
				longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
				freeChunk = null;
			}
			survivors += 1;
		}
		else {

			/* object is not marked; free it */
			/* <-- Finalization support: We need to mark each oop chunk as free --> */
			longAtput(oop - hdrBytes, HeaderTypeFree);
			if (freeChunk) {

				/* enlarge current free chunk to include this oop */
				freeChunkSize = (freeChunkSize + oopSize) + hdrBytes;
			}
			else {

				/* start a new free chunk */
				/* chunk may start 4 or 8 bytes before oop */
				freeChunk = oop - hdrBytes;

				/* adjust size for possible extra header bytes */
				freeChunkSize = oopSize + (oop - freeChunk);
				if (!firstFree) {
					firstFree = freeChunk;
				}
			}
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	if (freeChunk) {

		/* record size of final free chunk */
		longAtput(freeChunk, (freeChunkSize & LongSizeMask) | HeaderTypeFree);
	}
	if (oop == GIV(endOfMemory)) {
		GIV(freeStart) = GIV(endOfMemory);
	}
	else {
		error("sweep failed to find exact end of memory");
	}
	if (firstFree) {
		GIV(compStart) = firstFree;
	}
	else {
		error("expected to find at least one free object");
	}
	return survivors;
}


/*	For forward-compatibility with Spur. Fail; ObjectMemory does not support
	pinning. 
 */

	/* NewObjectMemory>>#unpinObject: */
void
unpinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
}


/*	Add the given variable location to the extra roots table */

	/* ObjectMemory>>#addGCRoot: */
sqInt
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}


/*	Answer if address appears to be that of either a SmallInteger or an
	object. For code disassembly and assertions. */

	/* ObjectMemory>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & 1))
	 || (/* addressCouldBeObj: */
		((address & 3) == 0)
	 && (((((usqInt)address)) >= (startOfMemory()))
	 && (((((usqInt)address)) < GIV(freeStart))
	 && (((longAt(address)) & TypeMask) != HeaderTypeGC))));
}


/*	Attempt to answer an array of all objects, excluding those that may
	be garbage collected as a side effect of allocating the result array.
	If no memory is available answer the number of objects as a SmallInteger.
	Since objects are at least 4 bytes big, and the largest SmallInteger
	covers 1/4 of the address space, the count can never overflow. */
/*	Count the currently accessible objects */

	/* ObjectMemory>>#allObjects */
static sqInt
allObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt header;
    sqInt newCount;
    sqInt obj;
    sqInt oop;
    sqInt resultArray;
    unsigned int sz;

	count = 0;

	/* begin allObjectsDo: */
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			count += 1;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}

	/* Store all objects in result array, excluding any reference to the result array itself,
	   as may happen if garbage collection occurred during allocation of the array. No store
	   check is necessary; the result array will be the last object in memory and hence new. */
	resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), count);
	newCount = 0;
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (obj < resultArray) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			newCount += 1;
			if (resultArray) {
				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((resultArray + BaseHeaderSize) + ((((usqInt)(newCount) << (shiftForWord())))), obj);
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	if (!resultArray) {
		return (((usqInt)count << 1) | 1);
	}
	if (newCount < count) {
		shortentoIndexableSize(resultArray, newCount);
	}
	return resultArray;
}

	/* ObjectMemory>>#badContextSize: */
static NoDbgRegParms sqInt
badContextSize(sqInt oop)
{
    sqInt header;
    int numSlots;
    unsigned int sz;

	/* begin numSlotsOf: */
	header = longAt(oop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask);
	numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	return (numSlots != SmallContextSlots)
	 && (numSlots != LargeContextSlots);
}

	/* ObjectMemory>>#become:with: */
sqInt
becomewith(sqInt array1, sqInt array2)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	If this object is old, mark it as a root (because a new object 
	may be stored into it) */

	/* ObjectMemory>>#beRootIfOld: */
void
beRootIfOld(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if ((oopisLessThan(oop, GIV(youngStart)))
	 && (!((oop & 1)))) {

		/* Yes, oop is an old object */
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if (!(header & RootBit)) {

			/* record oop as root only if not already recorded */
			if (GIV(rootTableCount) < RootTableSize) {

				/* record root if there is enough room in the roots table.
				   IMPORTANT: since clearRootsTable is the only thing that clears root bits
				   do *not* set the root bit unless an object is in the root table.  checking
				   routines will complain about the root bit being unset instead of the table
				   being full, but that's life */
				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
				if (GIV(rootTableCount) >= RootTableRedZone) {

					/* if we're now in the red zone force an IGC ASAP */
					/* begin scheduleIncrementalGC */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
			}
			else {

				/* note overflow; will need to do a fullGC instead of an incremental. */
				GIV(rootTableOverflowed) = 1;
			}
		}
	}
}


/*	Record that the given oop in the old object area points to an object in
	the young area when oop may be forwarded.
 */
/*	Warning: No young objects should be recorded as roots. Callers are
	responsible for ensuring this constraint is not violated.
 */
/*	for debugging... */
/*	If labelled, gcc duplicates the label when inlining
	updatePointersInRangeFrom:to: 
 */

	/* ObjectMemory>>#beRootWhileForwarding: */
static NoDbgRegParms void
beRootWhileForwarding(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt fwdBlock;
    sqInt header;
    usqInt headerLoc;
    sqInt headerSqInt;

	header = longAt(oop);
	if (header & MarkBit) {

		/* This oop is forwarded */
		fwdBlock = ((header & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlock));
		headerLoc = fwdBlock + BytesPerWord;
	}
	else {

		/* Normal -- no forwarding */
		headerLoc = oop;
	}

	/* begin noteAsRoot:headerLoc: */
	headerSqInt = longAt(headerLoc);
	if (!(headerSqInt & RootBit)) {

		/* record oop as root only if not already recorded */
		if (GIV(rootTableCount) < RootTableSize) {

			/* record root if there is enough room in the roots table.
			   IMPORTANT: since clearRootsTable is the only thing that clears root bits
			   do *not* set the root bit unless an object is in the root table.  checking
			   routines will complain about the root bit being unset instead of the table
			   being full, but that's life */
			GIV(rootTableCount) += 1;
			GIV(rootTable)[GIV(rootTableCount)] = oop;
			longAtput(headerLoc, headerSqInt | RootBit);
			if (GIV(rootTableCount) >= RootTableRedZone) {

				/* if we're now in the red zone force an IGC ASAP */
				/* begin scheduleIncrementalGC */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
		}
		else {

			/* note overflow; will need to do a fullGC instead of an incremental. */
			GIV(rootTableOverflowed) = 1;
		}
	}
}

	/* ObjectMemory>>#byteFormatMask */
static sqInt
byteFormatMask(void)
{
	return 12;
}

	/* ObjectMemory>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop)
{
	if ((oop & 1)) {
		return 0;
	}
	return numBytesOf(oop);
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* ObjectMemory>>#byteSwapped: */
sqInt
byteSwapped(sqInt w)
{
	return 
#  if BytesPerWord == 4
		SQ_SWAP_4_BYTES(w)
#  else
		SQ_SWAP_8_BYTES(w)
#  endif
		;
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#bytesPerElement: */
sqInt
bytesPerElement(sqInt oop)
{
	if ((oop & 1)) {
		return 0;
	}
	if (/* isWords: */
		((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()))) {
		return 4;
	}
	if (/* isBytes: */
		((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {
		return 1;
	}
	return BytesPerWord;
}


/*	Attempt to change the class of the receiver to the argument given that the
	format of the receiver matches the format of the argument. If successful,
	answer 0, otherwise answer an error code indicating the reason for
	failure. 
	Fail if the receiver is an instance of a compact class and the argument
	isn't, or if the format of the receiver is incompatible with the format of
	the argument,
	or if the argument is a fixed class and the receiver's size differs from
	the size
	that an instance of the argument should have. */
/*	Check what the format of the class says */

	/* ObjectMemory>>#changeClassOf:to: */
static NoDbgRegParms sqInt
changeClassOfto(sqInt rcvr, sqInt argClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt argClassInstByteSize;
    usqInt argFormat;
    usqInt ccIndex;
    usqInt classHdr;
    usqInt rcvrFormat;
    sqInt rcvrHdr;
    usqInt sizeHiBits;

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */
	classHdr = (longAt((argClass + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	sizeHiBits = ((classHdr & 0x60000)) >> 9;
	classHdr = classHdr & 0x1FFFF;

	/* size in bytes -- low 2 bits are 0 */
	/* Check the receiver's format against that of the class */
	argClassInstByteSize = (classHdr & SizeMask) + sizeHiBits;
	argFormat = ((classHdr) >> (instFormatFieldLSB())) & 15;
	rcvrHdr = longAt(rcvr);

	/* If the receiver is a byte object we need to clear the number of odd bytes from the format. */
	rcvrFormat = (((usqInt)(rcvrHdr)) >> (instFormatFieldLSB())) & 15;
	if (rcvrFormat > (firstByteFormat())) {
		rcvrFormat = rcvrFormat & 12;
	}
	if (!(argFormat == rcvrFormat)) {
		return PrimErrInappropriate;
	}
	if (argFormat < (arrayFormat())) {
		if ((argClassInstByteSize - BaseHeaderSize) != (numBytesOf(rcvr))) {
			return PrimErrBadReceiver;
		}
	}
	else {
		if (argFormat == (indexablePointersFormat())) {

			/* For indexable plus fixed fields the receiver must be at least big enough. */
			if ((argClassInstByteSize - BaseHeaderSize) > (numBytesOf(rcvr))) {
				return PrimErrBadReceiver;
			}
		}
	}
	if ((rcvrHdr & TypeMask) == HeaderTypeShort) {

		/* Compact classes. Check if the arg's class is compact and exchange ccIndex */
		ccIndex = classHdr & CompactClassMask;
		if (!ccIndex) {
			return PrimErrInappropriate;
		}
#    if IMMUTABILITY
		if (rcvrHdr & ImmutabilityBit) {
			return PrimErrNoModification;
		}
#    endif


		/* baseHeader:put: */
		longAtput(rcvr, (((rcvrHdr | CompactClassMask) - CompactClassMask)) | ccIndex);
	}
	else {

		/* Exchange the class pointer, which could make rcvr a root for argClass */
#    if IMMUTABILITY
		if (rcvrHdr & ImmutabilityBit) {
			return PrimErrNoModification;
		}
#    endif

		if ((((usqInt)(rcvrHdr)) >> (compactClassFieldLSB())) & 0x1F) {
			/* baseHeader:put: */
			longAtput(rcvr, ((rcvrHdr | CompactClassMask) - CompactClassMask));
		}
		longAtput(rcvr - BaseHeaderSize, argClass | (rcvrHdr & TypeMask));
		if (oopisLessThan(rcvr, GIV(youngStart))) {
			possibleRootStoreIntovalue(rcvr, argClass);
		}
	}
	return 0;
}

	/* ObjectMemory>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((characterCode >= 0) && (characterCode <= 0xFF))
			? fetchPointerofObject(characterCode, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CharacterTable) << (shiftForWord()))))))
			: GIV(nilObj));
}

	/* ObjectMemory>>#characterTable */
sqInt
characterTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CharacterTable) << (shiftForWord())))));
}


/*	Assumes zero-based array indexing. For testing in Smalltalk, this method
	should be overridden in a subclass.
 */

	/* ObjectMemory>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkAddress: */
	if (oopisLessThan(byteAddress, startOfMemory())) {
		error("bad address: negative");
	}
	if (oopisGreaterThanOrEqualTo(byteAddress, GIV(memoryLimit))) {
		error("bad address: past end of heap");
	}

	/* begin checkAddress: */
	if (oopisLessThan(byteAddress + 3, startOfMemory())) {
		error("bad address: negative");
	}
	if (oopisGreaterThanOrEqualTo(byteAddress + 3, GIV(memoryLimit))) {
		error("bad address: past end of heap");
	}
	return longAt(byteAddress);
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */
/*	useful for debugging */

	/* ObjectMemory>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt behaviorFormatBits;
    usqInt ccIndex;
    int formatMask;
    usqInt objClass;
    sqInt objFormatBits;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) (/* fetchClassOfNonImm: */
	((ccIndex = (((usqInt)((longAt(obj)))) >> (compactClassFieldLSB())) & 0x1F)
		? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
		: (longAt(obj - BaseHeaderSize)) & AllButTypeMask)));
	if ((objClass & 1)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" a SmallInteger is not a valid class or behavior");
		cr();
		return 0;
	}
	if (!(okayOop(objClass))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" class obj is not ok");
		cr();
		return 0;
	}
	if (!((((((usqInt)((longAt(objClass)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
		 && ((lengthOf(objClass)) >= 3))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" a class (behavior) must be a pointers object of size >= 3");
		cr();
		return 0;
	}
	formatMask = (/* isBytes: */
			((obj & 1) == 0)
		 && (((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))
				? 0xC00
				: 0xF00);
	behaviorFormatBits = ((longAt((objClass + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1) & formatMask;
	objFormatBits = (longAt(obj)) & formatMask;
	if (!(behaviorFormatBits == objFormatBits)) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"obj ");
		printHex(obj);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" and its class (behavior) formats differ");
		cr();
		return 0;
	}
	return 1;
}

	/* ObjectMemory>>#classAlien */
sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord())))));
}

	/* ObjectMemory>>#classArray */
sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord())))));
}

	/* ObjectMemory>>#classBitmap */
sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassBitmap) << (shiftForWord())))));
}

	/* ObjectMemory>>#classByteArray */
sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteArray) << (shiftForWord())))));
}

	/* ObjectMemory>>#classCharacter */
sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#classDoubleByteArray */
sqInt
classDoubleByteArray(void)
{
	return null;
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#classDoubleWordArray */
sqInt
classDoubleWordArray(void)
{
	return null;
}

	/* ObjectMemory>>#classExternalAddress */
sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassExternalAddress) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalData */
sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassExternalData) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalFunction */
sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassExternalFunction) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalLibrary */
sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassExternalLibrary) << (shiftForWord())))));
}

	/* ObjectMemory>>#classExternalStructure */
sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassExternalStructure) << (shiftForWord())))));
}

	/* ObjectMemory>>#classFloat */
sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#classFloat32Array */
sqInt
classFloat32Array(void)
{
	return null;
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#classFloat64Array */
sqInt
classFloat64Array(void)
{
	return null;
}

	/* ObjectMemory>>#classHeader: */
sqInt
classHeader(sqInt oop)
{
	return longAt(oop - BaseHeaderSize);
}

	/* ObjectMemory>>#classLargeNegativeInteger */
sqInt
classLargeNegativeInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
}

	/* ObjectMemory>>#classLargePositiveInteger */
sqInt
classLargePositiveInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
}

	/* ObjectMemory>>#classPoint */
sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord())))));
}

	/* ObjectMemory>>#classSemaphore */
sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord())))));
}

	/* ObjectMemory>>#classSmallInteger */
sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))));
}

	/* ObjectMemory>>#classString */
sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord())))));
}

	/* ObjectMemory>>#classUnsafeAlien */
sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassUnsafeAlien) << (shiftForWord())))));
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#classWordArray */
sqInt
classWordArray(void)
{
	return null;
}


/*	Clear the root bits of the current roots, then empty the roots table. */
/*	Caution: This should only be done when the young object space is empty. */
/*	reset the roots table (after this, all objects are old so there are no
	roots) 
 */

	/* ObjectMemory>>#clearRootsTable */
static void
clearRootsTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		longAtput(oop, (longAt(oop)) & AllButRootBit);
		GIV(rootTable)[i] = 0;
	}
	GIV(rootTableCount) = 0;
	GIV(rootTableOverflowed) = 0;
}


/*	Index must be between 1 and compactClassArray size. A zero compact class
	index in the base header indicates that the class is in the class header
	word.  */

	/* ObjectMemory>>#compactClassAt: */
sqInt
compactClassAt(sqInt ccIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))));
}

	/* ObjectMemory>>#compactClassIndexOfHeader: */
usqInt
compactClassIndexOfHeader(sqInt header)
{
	return (((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F;
}


/*	Copy this object into the segment beginning at lastSeg.
	Install a forwarding pointer, and save oop and header.
	Fail if out of space. Return the next segmentAddr if successful. */
/*	Copy the object... */

	/* ObjectMemory>>#copyObj:toSegment:addr:stopAt:saveOopAt:headerAt: */
static NoDbgRegParms sqInt
copyObjtoSegmentaddrstopAtsaveOopAtheaderAt(sqInt oop, sqInt segmentWordArray, sqInt lastSeg, sqInt stopAddr, sqInt oopPtr, sqInt hdrPtr)
{
    usqInt bodySize;
    sqInt extraSize;
    sqInt hdrAddr;
    sqInt header;
    sqInt in;
    sqInt lastIn;
    sqInt out;

	flag("Dan");
	extraSize = headerTypeBytes[(longAt(oop)) & TypeMask];

	/* begin sizeBitsOf: */
	header = longAt(oop);
	bodySize = (header & TypeMask
				? header & SizeMask
				: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask);
	if (oopisGreaterThanOrEqualTo((lastSeg + extraSize) + bodySize, stopAddr)) {
		return 0;
	}

	/* begin transfer:from:to: */
	in = (oop - extraSize) - BytesPerWord;
	lastIn = in + (((extraSize + bodySize) / BytesPerWord) * BytesPerWord);
	out = (lastSeg + BytesPerWord) - BytesPerWord;
	while (oopisLessThan(in, lastIn)) {
		longAtput((out += BytesPerWord), longAt((in += BytesPerWord)));
	}
	hdrAddr = (lastSeg + BytesPerWord) + extraSize;
	longAtput(hdrAddr, (longAt(hdrAddr)) & (AllButRootBit - MarkBit));

	/* begin forward:to:savingOopAt:andHeaderAt: */
	longAtput(oopPtr, oop);
	longAtput(hdrPtr, longAt(oop));
	longAtput(oop, (((lastSeg + BytesPerWord) + extraSize) - segmentWordArray) + HeaderTypeFree);
	return (lastSeg + extraSize) + bodySize;
}

	/* ObjectMemory>>#displayObject */
sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheDisplay) << (shiftForWord())))));
}

	/* ObjectMemory>>#falseObject */
sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* ObjectMemory>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt oop)
{
	return byteAt((oop + BaseHeaderSize) + byteIndex);
}

	/* ObjectMemory>>#fetchClassOf: */
sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;

	return ((oop & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* ObjectMemory>>#fetchLong32:ofObject: */
int
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << 2))));
}

	/* ObjectMemory>>#fetchLong64:ofObject: */
static NoDbgRegParms sqLong
fetchLong64ofObject(sqInt longIndex, sqInt oop)
{
	return 
#  if BytesPerWord == 8
		long64At((oop + BaseHeaderSize) + ((((usqInt)(longIndex) << 3))))
#  else
		
		#  if VMBIGENDIAN
				(((((unsigned long long)(long32At((oop + BaseHeaderSize) + ((((usqInt)(longIndex) << 3))))))) << 32)) + (((unsigned int) (long32At((oop + BaseHeaderSize) + (((((usqInt)(longIndex) << 3))) + 4)))))
		#  else // VMBIGENDIAN
				(((unsigned int) (long32At((oop + BaseHeaderSize) + ((((usqInt)(longIndex) << 3))))))) + (((((unsigned long long)(long32At((oop + BaseHeaderSize) + (((((usqInt)(longIndex) << 3))) + 4))))) << 32))
		#  endif // VMBIGENDIAN
				
#  endif // BytesPerWord == 8
		;
}


/*	index by word size, and return a pointer as long as the word size */

	/* ObjectMemory>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt oop)
{
	return longAt((oop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* ObjectMemory>>#firstFixedFieldOfMaybeImmediate: */
static NoDbgRegParms void *
firstFixedFieldOfMaybeImmediate(sqInt oop)
{
	return ((oop & 1)
			? ((void *)oop)
			: pointerForOop(oop + BaseHeaderSize));
}

	/* ObjectMemory>>#firstFixedField: */
void *
firstFixedField(sqInt oop)
{
	return pointerForOop(oop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes
 */

	/* ObjectMemory>>#firstIndexableField: */
void *
firstIndexableField(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    unsigned int sz;
    sqInt totalLength;

	hdr = longAt(oop);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {

		/* pointer; may need to delve into the class format word */
		/* begin lengthOf:baseHeader:format: */
		if (hdr & TypeMask) {
			sz = hdr & SizeMask;
		}
		else {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmt <= 4 /* lastPointerFormat */) {
			totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l1;
		}
		totalLength = (fmt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4 /* lastPointerFormat */)
		 || (fmt == (arrayFormat()))) {
			fixedFields = 0;
			goto l2;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l2;
		}
		class = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
		classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
		return pointerForOop((oop + BaseHeaderSize) + ((((usqInt)(fixedFields) << (shiftForWord())))));
	}
	return pointerForOop(oop + BaseHeaderSize);
}


/*	
	NOTE: This code supports the backward-compatible extension to 8 bits of
	instSize. When we revise the image format, it should become...
	^ (classFormat >> 2 bitAnd: 16rFF) - 
	 */

	/* ObjectMemory>>#fixedFieldsOf:format:length: */
static NoDbgRegParms sqInt
fixedFieldsOfformatlength(sqInt oop, sqInt fmt, sqInt wordLength)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;

	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		return 0;
	}
	if (fmt < 2) {
		return wordLength;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	return (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
}


/*	Spur compatibility; in V3 this is a synonym for fetchPointer:ofObject: */

	/* ObjectMemory>>#followField:ofObject: */
static NoDbgRegParms sqInt
followFieldofObject(sqInt fieldIndex, sqInt anObject)
{
	return longAt((anObject + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));
}


/*	**should be in-lined** */
/*	Note that, in Smalltalk, the instSpec will be equal to the inst spec
	part of the base header of an instance (without hdr type) shifted left 1.
	In this way, apart from the smallInt bit, the bits
	are just where you want them for the first header word. */
/*	Callers (must) expect low 2 bits (header type) to be zero! */

	/* ObjectMemory>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer)
{
	return (longAt((classPointer + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
}


/*	Answer if the given address is a valid forward table entry. */

	/* ObjectMemory>>#fwdBlockValid: */
static NoDbgRegParms sqInt
fwdBlockValid(sqInt addr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThan(addr, GIV(endOfMemory)))
	 && ((oopisLessThanOrEqualTo(addr, GIV(fwdTableNext)))
	 && ((addr & 3) == 0));
}

	/* ObjectMemory>>#goodContextSize: */
static NoDbgRegParms sqInt
goodContextSize(sqInt oop)
{
    sqInt header;
    int numSlots;
    unsigned int sz;

	/* begin numSlotsOf: */
	header = longAt(oop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask);
	numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	return (numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots);
}

	/* ObjectMemory>>#hasForwardingBlock: */
static NoDbgRegParms int
hasForwardingBlock(sqInt objOop)
{
	return ((longAt(objOop)) & MarkBit) != 0;
}


/*	The V3 64-bit memory manager has 64-bit oops, but its SmallIntegers only
	have 31 bits of precision. The Spur 64-bit memory manager has 61-bit
	immediates.  */

	/* ObjectMemory>>#hasSixtyFourBitImmediates */
static sqInt
hasSixtyFourBitImmediates(void)
{
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* ObjectMemory>>#headerIndicatesAlternateBytecodeSet: */
int
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((int) methodHeader)) < 0;
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* ObjectMemory>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj)
{
    usqInt byteSize;
    sqInt classHdr;
    usqInt sizeHiBits;

	assert(addressCouldBeObj(classObj));

	/* Low 2 bits are 0 */
	/* Compute the size of instances of the class (used for fixed field classes only) */
	classHdr = (longAt((classObj + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	sizeHiBits = (((usqInt)(classHdr)) >> 9) & 0x300;

	/* size in bytes -- low 2 bits are 0 */
	byteSize = (classHdr & SizeMask) + sizeHiBits;
	return (byteSize - BaseHeaderSize) / BytesPerWord;
}


/*	NOTE: This method supports the backward-compatible split instSize field of
	the 
	class format word. The sizeHiBits will go away and other shifts change by
	2 
	when the split fields get merged in an (incompatible) image change.
 */

	/* ObjectMemory>>#instantiateClass:indexableSize: */
sqInt
instantiateClassindexableSize(sqInt classPointer, sqInt size)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt binc;
    sqInt bm1;
    usqInt byteSize;
    sqInt byteSizeSqInt;
    usqInt cClass;
    sqInt classFormat;
    sqInt classOop;
    usqInt end;
    sqInt enoughSpace;
    sqInt fillWord;
    usqInt format;
    usqInt hash;
    int hdrSize;
    usqInt header1;
    usqInt header3;
    usqInt i;
    sqInt minFree;
    usqInt newChunk;
    usqInt newFreeStart;
    sqInt newObj;
    usqInt sizeHiBits;

	header3 = 0;
	assert(size >= 0);
	hash = (GIV(freeStart)) >> (shiftForWord());

	/* Low 2 bits are 0 */
	classFormat = (longAt((classPointer + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	header1 = (classFormat & 0x1FF00) | (((hash & HashMaskUnshifted) << HashBitsOffset));
	sizeHiBits = ((classFormat & 0x60000)) >> 9;

	/* compact class field from format word */
	cClass = header1 & CompactClassMask;

	/* size in bytes -- low 2 bits are 0 */
	/* Note this byteSize comes from the format word of the class which is pre-shifted
	   to 4 bytes per field.  Need another shift for 8 bytes per word... */
	byteSize = (classFormat & (SizeMask + Size4Bit)) + sizeHiBits;
	byteSize = (byteSize << ((shiftForWord()) - 2));
	format = (((usqInt)(classFormat)) >> (instFormatFieldLSB())) & 15;
	flag("sizeLowBits");
	if (format < (firstByteFormat())) {
		if (format == (firstLongFormat())) {

			/* long32 bitmaps */
			bm1 = BytesPerWord - 1;

			/* round up */
			byteSize = ((byteSize + (size * 4)) + bm1) & LongSizeMask;

			/* odd bytes */
			/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
			binc = bm1 - (((size * 4) + bm1) & bm1);
			header1 = header1 | (binc & 4);
		}
		else {

			/* Arrays and 64-bit bitmaps */
			byteSize += size * BytesPerWord;
		}
	}
	else {

		/* Strings and Methods */
		bm1 = BytesPerWord - 1;

		/* round up */
		byteSize = ((byteSize + size) + bm1) & LongSizeMask;

		/* odd bytes */
		/* low bits of byte size go in format field */
		binc = bm1 - ((size + bm1) & bm1);

		/* extra low bit (4) for 64-bit VM goes in 4-bit (betw hdr bits and sizeBits) */
		header1 = header1 | (((binc & 3) << (instFormatFieldLSB())));
		header1 = header1 | (binc & 4);
	}
	if (byteSize > 0xFF) {

		/* requires size header word/full header */
		header3 = byteSize;
		hdrSize = 3;
	}
	else {
		header1 = header1 | byteSize;
		hdrSize = (cClass
					? 1
					: 2);
	}

	/* begin allocate:headerSize:h1:h2:h3:doFill:format: */
	classOop = 0;
	newChunk = GIV(freeStart);
	newFreeStart = GIV(freeStart) + (byteSize + ((hdrSize - 1) * BytesPerWord));
	if (newFreeStart < GIV(scavengeThreshold)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}

	/* begin scheduleIncrementalGC */
	GIV(needGCFlag) = 1;
	forceInterruptCheck();
	if (GIV(freeStart) <= GIV(reserveStart)) {
		GIV(freeStart) = newFreeStart;
		newObj = oopForPointer(newChunk);
		goto l1;
	}
	newObj = 0;
l1:	/* end allocateChunk: */;
	if (newObj) {
		classOop = classPointer;
	}
	else {

		/* remap classOop because GC may move the classOop */
		if (hdrSize > 1) {
			/* begin pushRemappableOop: */
			assert(addressCouldBeOop(classPointer));
			GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = classPointer;
			if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
				error("remapBuffer overflow");
			}
		}
		byteSizeSqInt = byteSize + ((hdrSize - 1) * BytesPerWord);

		/* begin allocateChunkAfterGC: */
		/* begin sufficientSpaceToAllocate: */
		/* check for low-space */
		minFree = ((((((GIV(lowSpaceThreshold) + byteSizeSqInt) + BaseHeaderSize) + BytesPerWord) - 1) | (BytesPerWord - 1)) - (BytesPerWord - 1));
		if (oopisLessThanOrEqualTo(GIV(freeStart) + minFree, GIV(reserveStart))) {
			enoughSpace = 1;
			goto l2;
		}
		enoughSpace = sufficientSpaceAfterGC(minFree);
l2:	/* end sufficientSpaceToAllocate: */;
		if (!enoughSpace) {

			/* signal that space is running low, but proceed with allocation if possible */
			setSignalLowSpaceFlagAndSaveProcess();
		}
		if (oopisGreaterThan(GIV(freeStart) + byteSizeSqInt, GIV(reserveStart))) {
			newObj = null;
			goto l3;
		}
		newChunk = GIV(freeStart);
		GIV(freeStart) += byteSizeSqInt;
		newObj = oopForPointer(newChunk);
l3:	/* end allocateChunkAfterGC: */;
		if (hdrSize > 1) {
			/* begin popRemappableOop */
			classOop = GIV(remapBuffer)[GIV(remapBufferCount)];
			GIV(remapBufferCount) -= 1;
		}
		if (!newObj) {
			return newObj;
		}
	}
	if (hdrSize == 3) {
		longAtput(newObj, header3);
		longAtput(newObj + BytesPerWord, classOop);
		longAtput(newObj + (BytesPerWord * 2), header1);
		newObj += BytesPerWord * 2;
	}
	if (hdrSize == 2) {
		longAtput(newObj, classOop | HeaderTypeClass);
		longAtput(newObj + BytesPerWord, header1 | HeaderTypeClass);
		newObj += BytesPerWord;
	}
	if (hdrSize == 1) {
		longAtput(newObj, header1 | HeaderTypeShort);
	}
	fillWord = (format <= 4 /* lastPointerFormat */
				? GIV(nilObj)
				: 0);
	end = newObj + byteSize;

	/* skip header */
	i = newObj + BytesPerWord;
	while (i < end) {
		longAtput(i, fillWord);
		i += BytesPerWord;
	}
	assert(i == GIV(freeStart));
	return newObj;
}


/*	This field in a class's format inst var corresponds to the 4-bit format
	field stored in every object header
 */

	/* ObjectMemory>>#instSpecOfClass: */
static NoDbgRegParms usqInt
instSpecOfClass(sqInt classPointer)
{
	return (((usqInt)(((longAt((classPointer + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1))) >> (instFormatFieldLSB())) & 15;
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* ObjectMemory>>#integerObjectOf: */
sqInt
integerObjectOf(sqInt value)
{
	return ((((usqInt)(value) << 1))) + 1;
}


/*	Translator produces 'objectPointer >> 1' */

	/* ObjectMemory>>#integerValueOf: */
sqInt
integerValueOf(sqInt objectPointer)
{
	if (objectPointer & 0x80000000U) {

		/* negative */
		return ((((objectPointer & 0x7FFFFFFF)) >> 1) - 0x3FFFFFFF) - 1;
	}
	else {

		/* positive */
		return ((usqInt)(objectPointer)) >> 1;
	}
}

	/* ObjectMemory>>#invalidCompactClassError: */
static NoDbgRegParms void
invalidCompactClassError(const char *className)
{
	printf("\nClass %s does not have the required compact class index\n", className);
	exit(-1);
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* ObjectMemory>>#isArray: */
sqInt
isArray(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == 2);
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* ObjectMemory>>#isBytes: */
sqInt
isBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()));
}


/*	N.B. Because Slang always inlines is:instanceOf:compactClassIndex:
	(because is:instanceOf:compactClassIndex: has an inline: pragma) the
	phrase (self splObj: ClassCharacter) is expanded in-place
	and is _not_ evaluated if oop has a non-zero CompactClassIndex. */

	/* ObjectMemory>>#isCharacterObject: */
sqInt
isCharacterObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}

	/* ObjectMemory>>#isCharacterValue: */
int
isCharacterValue(sqInt anInteger)
{
	return ((anInteger >= 0) && (anInteger <= 0xFF));
}


/*	Answer whether the argument header has compiled method format */

	/* ObjectMemory>>#isCompiledMethodHeader: */
static NoDbgRegParms int
isCompiledMethodHeader(sqInt objHeader)
{
	return ((((usqInt)(objHeader)) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat());
}


/*	Answer whether the argument object is of compiled method format */

	/* ObjectMemory>>#isCompiledMethod: */
int
isCompiledMethod(sqInt oop)
{
	return ((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat());
}

	/* ObjectMemory>>#isContextNonImm: */
static NoDbgRegParms int
isContextNonImm(sqInt oop)
{
	return ((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex;
}

	/* ObjectMemory>>#isContext: */
static NoDbgRegParms sqInt
isContext(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex);
}


/*	N.B. Because Slang always inlines is:instanceOf:compactClassIndex:
	(because is:instanceOf:compactClassIndex: has an inline: pragma) the
	phrase (objectMemory splObj: ClassFloat) is expanded in-place and is
	_not_ evaluated if oop has a non-zero CompactClassIndex. */

	/* ObjectMemory>>#isFloatInstance: */
static NoDbgRegParms sqInt
isFloatInstance(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassFloatCompactIndex == ccIndex;
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}

	/* ObjectMemory>>#isImmediate: */
int
isImmediate(sqInt anOop)
{
	return (anOop & 1);
}

	/* ObjectMemory>>#isIndexable: */
int
isIndexable(sqInt oop)
{
	return ((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= 2;
}


/*	Return true if the given address is in ST object memory */

	/* ObjectMemory>>#isInMemory: */
sqInt
isInMemory(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThanOrEqualTo(address, startOfMemory()))
	 && (oopisLessThan(address, GIV(endOfMemory)));
}


/*	N.B. Because Slang always inlines is:instanceOf:compactClassIndex:
	(because is:instanceOf:compactClassIndex: has an inline: pragma) the
	phrase (objectMemory splObj: ClassLargeNegativeInteger) is expanded
	in-place and is _not_ evaluated if oop has a non-zero CompactClassIndex. */

	/* ObjectMemory>>#isInstanceOfClassLargeNegativeInteger: */
static NoDbgRegParms sqInt
isInstanceOfClassLargeNegativeInteger(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassLargeNegativeIntegerCompactIndex == ccIndex;
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}


/*	N.B. Because Slang always inlines is:instanceOf:compactClassIndex:
	(because is:instanceOf:compactClassIndex: has an inline: pragma) the
	phrase (objectMemory splObj: ClassLargePositiveInteger) is expanded
	in-place and is _not_ evaluated if oop has a non-zero CompactClassIndex. */

	/* ObjectMemory>>#isInstanceOfClassLargePositiveInteger: */
static NoDbgRegParms sqInt
isInstanceOfClassLargePositiveInteger(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassLargePositiveIntegerCompactIndex == ccIndex;
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}

	/* ObjectMemory>>#isIntegerObject: */
int
isIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) > 0;
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In C, use a shift and XOR to set the sign bit if and only if the top two
	bits of the given
	value are the same, then test the sign bit. Note that the top two bits are
	equal for
	exactly those integers in the range that can be represented in 31-bits or
	63-bits. 
 */

	/* ObjectMemory>>#isIntegerValue: */
int
isIntegerValue(sqInt intValue)
{
	return (((sqInt)((((usqInt)intValue)) ^ (((((usqInt)intValue)) << 1))))) >= 0;
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#isLong64s: */
sqInt
isLong64s(sqInt oop)
{
	return 0;
}


/*	Answer if oop's mark bit is set */

	/* ObjectMemory>>#isMarked: */
int
isMarked(sqInt oop)
{
	return ((longAt(oop)) & MarkBit) != 0;
}

	/* ObjectMemory>>#isNonImmediate: */
int
isNonImmediate(sqInt anOop)
{
	return (anOop & 1) == 0;
}

	/* ObjectMemory>>#isNonIntegerObject: */
int
isNonIntegerObject(sqInt objectPointer)
{
	return (objectPointer & 1) == 0;
}

	/* ObjectMemory>>#isObjImmutable: */
static NoDbgRegParms sqInt
isObjImmutable(sqInt anOop)
{
	return 
#  if IMMUTABILITY
		((longAt(anOop)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		;
}


/*	Answer whether the oop is an object of compiled method format */

	/* ObjectMemory>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()));
}


/*	Compatibility wth SpurMemoryManager. In ObjectMemory, no forwarding
	pointers are visible to the VM. */

	/* ObjectMemory>>#isOopForwarded: */
static NoDbgRegParms sqInt
isOopForwarded(sqInt oop)
{
	return 0;
}

	/* ObjectMemory>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt anOop)
{
	return ((anOop & 1))
	 || (
#  if IMMUTABILITY
		((longAt(anOop)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		);
}

	/* ObjectMemory>>#isOopMutable: */
sqInt
isOopMutable(sqInt anOop)
{
	return (!((anOop & 1)))
	 && (!(
#  if IMMUTABILITY
		((longAt(anOop)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		));
}


/*	For forward-compatibility with Spur. Answer false; ObjectMemory does not
	support pinning. */

	/* ObjectMemory>>#isPinned: */
sqInt
isPinned(sqInt objOop)
{
	return 0;
}


/*	Answer true if the argument has only fields that can hold oops. See
	comment in formatOf:
 */

	/* ObjectMemory>>#isPointers: */
sqInt
isPointers(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */);
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* ObjectMemory>>#isPureBitsNonImm: */
static NoDbgRegParms sqInt
isPureBitsNonImm(sqInt objOop)
{
    sqInt format;

	format = (((usqInt)((longAt(objOop)))) >> (instFormatFieldLSB())) & 15;

	/* begin isPureBitsFormat: */
	return (format >= (firstLongFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#isShorts: */
sqInt
isShorts(sqInt oop)
{
	return 0;
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWeakNonImm: */
static NoDbgRegParms int
isWeakNonImm(sqInt oop)
{
	return ((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat());
}


/*	Answer true if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWeak: */
sqInt
isWeak(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (weakArrayFormat()));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWordsNonImm: */
static NoDbgRegParms int
isWordsNonImm(sqInt oop)
{
	return ((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat());
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* ObjectMemory>>#isWordsOrBytesNonImm: */
static NoDbgRegParms sqInt
isWordsOrBytesNonImm(sqInt oop)
{
    usqInt fmt;

	fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	return (fmt == (firstLongFormat()))
	 || ((fmt >= (firstByteFormat()))
	 && (fmt < (firstCompiledMethodFormat())));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* ObjectMemory>>#isWordsOrBytes: */
sqInt
isWordsOrBytes(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (isWordsOrBytesNonImm(oop));
}


/*	forward compatibility with Spur */

	/* ObjectMemory>>#isWordsOrShorts: */
sqInt
isWordsOrShorts(sqInt oop)
{
	return /* isWords: */
		((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* ObjectMemory>>#isWords: */
sqInt
isWords(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) == (firstLongFormat()));
}

	/* ObjectMemory>>#isYoung: */
sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & 1) == 0)
	 && (oopisGreaterThanOrEqualTo(oop, GIV(youngStart)));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* ObjectMemory>>#is:instanceOf:compactClassIndex: */
static NoDbgRegParms sqInt
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;

	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	if (compactClassIndex) {
		return compactClassIndex == ccIndex;
	}
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}


/*	for the message send breakpoint; selectors can be immediates. */

	/* ObjectMemory>>#lengthOfMaybeImmediate: */
static NoDbgRegParms sqInt
lengthOfMaybeImmediate(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    unsigned int sz;

	if ((oop & 1)) {
		return 0;
	}

	/* begin lengthOf: */
	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
			? ((usqInt)((sz - BaseHeaderSize))) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Return the number of indexable bytes or words in the given object. Assume
	the argument is not an integer. For a CompiledMethod, the size of the
	method header (in bytes) should be subtracted from the result.
 */

	/* ObjectMemory>>#lengthOf: */
static NoDbgRegParms sqInt
lengthOf(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    unsigned int sz;

	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
			? ((usqInt)((sz - BaseHeaderSize))) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Return the number of fixed and indexable bytes, words, or object pointers
	in the
	given object. Assume the given oop is not an integer. For a
	CompiledMethod, the size
	of the method header (in bytes) should be subtracted from the result of
	this method.
 */

	/* ObjectMemory>>#lengthOf:baseHeader:format: */
static NoDbgRegParms sqInt
lengthOfbaseHeaderformat(sqInt oop, sqInt hdr, sqInt fmt)
{
    unsigned int sz;

	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
			? ((usqInt)((sz - BaseHeaderSize))) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
}

	/* ObjectMemory>>#literalCountOf: */
usqInt
literalCountOf(sqInt methodPointer)
{
    sqInt methodHeader;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	methodHeader = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1));
	return ((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF);
}


/*	If floatOrInt is an integer, then convert it to a C double float and
	return it.
	If it is a Float, then load its value and return it.
	Otherwise fail -- ie return with primErrorCode non-zero. */

	/* ObjectMemory>>#loadFloatOrIntFrom: */
static NoDbgRegParms double
loadFloatOrIntFrom(sqInt floatOrInt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double result;

	if ((floatOrInt & 1)) {
		return ((double) ((floatOrInt >> 1)) );
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((floatOrInt & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((floatOrInt & 1)));
	ccIndex = (((usqInt)((longAt(floatOrInt)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(floatOrInt - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(floatOrInt + BaseHeaderSize, result);
		return result;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* ObjectMemory>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt header;
    sqInt obj;
    sqInt oop;
    unsigned int sz;

	/* begin firstAccessibleObject */
	obj = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while (oopisLessThan(obj, GIV(freeStart))) {
		if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
			oop = obj;
			goto l1;
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
	}
	error("heap is empty");
	oop = null;
l1:	/* end firstAccessibleObject */;
	while (!(oop == null)) {
		if ((/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask)) == aClassOop) {
			longPrintOop(oop);
			cr();
		}

		/* begin accessibleObjectAfter: */
		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		obj = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		while (oopisLessThan(obj, GIV(freeStart))) {
			if (!(((longAt(obj)) & TypeMask) == HeaderTypeFree)) {
				oop = obj;
				goto l2;
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(obj, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(obj)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(obj);
				sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
			}
			obj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		}
		oop = null;
l2:	/* end accessibleObjectAfter: */;
	}
}


/*	Return the first free block after the given chunk in memory. */

	/* ObjectMemory>>#lowestFreeAfter: */
static NoDbgRegParms sqInt
lowestFreeAfter(sqInt chunk)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oopHeader;
    usqInt oopHeaderType;
    unsigned int oopSize;

	oop = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(oop, GIV(endOfMemory))) {
		oopHeader = longAt(oop);
		oopHeaderType = oopHeader & TypeMask;
		if (oopHeaderType == HeaderTypeFree) {
			return oop;
		}
		if (oopHeaderType) {
			oopSize = oopHeader & SizeMask;
		}
		else {
			oopSize = (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask;
		}
		oop = (oop + oopSize) + (headerTypeBytes[(longAt(oop + oopSize)) & TypeMask]);
	}
	error("expected to find at least one free object");
	return null;
}


/*	Mark all objects reachable from the given one.
	Trace from the given object even if it is old.
	Do not trace if it is already marked.
	Mark it only if it is a young object. */
/*	Tracer state variables:
	child		object being examined
	field		next field of child to examine
	parentField	field where child was stored in its referencing object */

	/* ObjectMemory>>#markAndTrace: */
sqInt
markAndTrace(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt action;
    usqInt ccIndex;
    sqInt child;
    sqInt childType;
    sqInt class;
    sqInt classFormat;
    sqInt contextSize;
    sqInt field;
    usqInt fmt;
    sqInt header;
    unsigned int header1;
    sqInt header1SqInt;
    sqInt header2;
    sqInt headerSqInt;
    sqInt lastFieldOffset;
    sqInt lastFieldOffsetSqInt;
    usqInt numLiterals;
    sqInt numOops;
    sqInt parentField;
    sqInt sp;
    sqInt statMarkCountLocal;
    usqInt sz;
    sqInt type;
    usqInt typeBits;
    sqInt typeSqInt;
    usqInt youngStartLocal;

	assert(addressCouldBeObjWhileForwarding(oop));
	header = longAt(oop);
	if (header & MarkBit) {
		return 0;
	}
	header = (header & AllButTypeMask) | HeaderTypeGC;
	if (oopisGreaterThanOrEqualTo(oop, GIV(youngStart))) {
		header = header | MarkBit;
	}
	longAtput(oop, header);
	parentField = GCTopMarker;
	child = oop;

	/* begin lastPointerOf:recordWeakRoot: */
	header2 = longAt(oop);
	fmt = (((usqInt)(header2)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {
		if (fmt >= (indexablePointersFormat())) {
			if (fmt == 4 /* lastPointerFormat */) {
				if (GIV(weakRootCount) >= 0) {

					/* And remember as weak root */
					if (!(((GIV(weakRootCount) += 1)) <= WeakRootTableSize)) {
						error("weakRoots table overflow");
					}
					GIV(weakRoots)[GIV(weakRootCount)] = oop;
				}

				/* begin nonWeakFieldsOf: */
				assert(isWeakNonImm(oop));
				class = /* fetchClassOfNonImm: */
						((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
				classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
				numOops = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
				lastFieldOffset = numOops * BytesPerWord;
				goto l4;
			}
			if (((((usqInt)(header2)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(oop);

				/* begin fetchStackPointerOf: */
				sp = longAt((oop + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l3;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(oop)));
				contextSize = (sp >> 1);
l3:	/* end fetchStackPointerOf: */;
				assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header2, fmt)));
				lastFieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l4;
			}
		}

		/* begin sizeBitsOfSafe: */
		headerSqInt = longAt(oop);
		type = /* rightType: */
				(headerSqInt & SizeMask
					? (headerSqInt & CompactClassMask
							? HeaderTypeShort
							: HeaderTypeClass)
					: HeaderTypeSizeAndClass);
		sz = (type
					? headerSqInt & SizeMask
					: (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask);
		lastFieldOffset = sz - BaseHeaderSize;
		goto l4;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		lastFieldOffset = 0;
		goto l4;
	}

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(oop));
	header2 = longAt((oop + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin lastPointerOfMethodHeader: */
	/* begin literalCountOfMethodHeader: */
	assert((header2 & 1));
	numLiterals = ((((int) header2)) < 0
				? ((header2 >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header2)) >> 10) & 0xFF);
	lastFieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l4:	/* end lastPointerOf:recordWeakRoot: */;
	field = oop + lastFieldOffset;
	action = StartField;
	youngStartLocal = GIV(youngStart);

	/* run the tracer state machine until all objects reachable from oop are marked */
	statMarkCountLocal = GIV(statMarkCount);
	do {
		if (action == StartField) {
			/* begin startField */
			while (1) {
				child = longAt(field);
				if (!((child & 1))) break;

				/* field contains a SmallInteger; skip it */
				/* Effectively ^ StartField */
				field -= BytesPerWord;
			}
			typeBits = child & TypeMask;
			if (!typeBits) {

				/* normal oop, go down */
				longAtput(field, parentField);
				parentField = field;
				action = StartObj;
				goto l1;
			}
			assert(typeBits == 2);
			if (child & CompactClassMask) {

				/* object's class is compact; we're done */
				/* restore the header type bits */
				child = child & AllButTypeMask;
				childType = /* rightType: */
						(child & SizeMask
							? (child & CompactClassMask
									? HeaderTypeShort
									: HeaderTypeClass)
							: HeaderTypeSizeAndClass);
				longAtput(field, child | childType);
				action = Upward;
				goto l1;
			}

			/* class word */
			child = longAt(field - BytesPerWord);

			/* clear type bits */
			child = child & AllButTypeMask;
			longAtput(field - BytesPerWord, parentField);

			/* point at class word; mark as working on the class. */
			parentField = (field - BytesPerWord) | 1;
			action = StartObj;
l1:	/* end startField */;
		}
		if (action == StartObj) {
			/* begin startObj */
			statMarkCountLocal += 1;
			if ((oopisLessThan(child, youngStartLocal))
			 || ((((header2 = longAt(child))) & MarkBit) != 0)) {

				/* already marked; skip it */
				field = child;
				action = Upward;
				goto l7;
			}

			/* begin lastPointerOf:recordWeakRoot: */
			header1SqInt = longAt(child);
			fmt = (((usqInt)(header1SqInt)) >> (instFormatFieldLSB())) & 15;
			if (fmt <= 4 /* lastPointerFormat */) {
				if (fmt >= (indexablePointersFormat())) {
					if (fmt == 4 /* lastPointerFormat */) {

						/* begin nonWeakFieldsOf: */
						assert(isWeakNonImm(child));
						class = /* fetchClassOfNonImm: */
								((ccIndex = (((usqInt)((longAt(child)))) >> (compactClassFieldLSB())) & 0x1F)
									? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
									: (longAt(child - BaseHeaderSize)) & AllButTypeMask);
						classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
						numOops = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
						lastFieldOffsetSqInt = numOops * BytesPerWord;
						goto l6;
					}
					if (((((usqInt)(header1SqInt)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
						setTraceFlagOnContextsFramesPageIfNeeded(child);

						/* begin fetchStackPointerOf: */
						sp = longAt((child + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
						if (!((sp & 1))) {
							contextSize = 0;
							goto l5;
						}
						assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(child)));
						contextSize = (sp >> 1);
l5:	/* end fetchStackPointerOf: */;
						assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(child, header1SqInt, fmt)));
						lastFieldOffsetSqInt = (CtxtTempFrameStart + contextSize) * BytesPerOop;
						goto l6;
					}
				}

				/* begin sizeBitsOfSafe: */
				headerSqInt = longAt(child);
				typeSqInt = /* rightType: */
						(headerSqInt & SizeMask
							? (headerSqInt & CompactClassMask
									? HeaderTypeShort
									: HeaderTypeClass)
							: HeaderTypeSizeAndClass);
				sz = (typeSqInt
							? headerSqInt & SizeMask
							: (longAt(child - (BytesPerWord * 2))) & AllButTypeMask);
				lastFieldOffsetSqInt = sz - BaseHeaderSize;
				goto l6;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				lastFieldOffsetSqInt = 0;
				goto l6;
			}

			/* begin methodHeaderOf: */
			assert(isCompiledMethod(child));
			header1SqInt = longAt((child + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

			/* begin lastPointerOfMethodHeader: */
			/* begin literalCountOfMethodHeader: */
			assert((header1SqInt & 1));
			numLiterals = ((((int) header1SqInt)) < 0
						? ((header1SqInt >> 1)) & AlternateHeaderNumLiteralsMask
						: (((usqInt)(header1SqInt)) >> 10) & 0xFF);
			lastFieldOffsetSqInt = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l6:	/* end lastPointerOf:recordWeakRoot: */;
			header2 = (header2 & AllButTypeMask) | (MarkBit | HeaderTypeGC);
			longAtput(child, header2);
			field = child + lastFieldOffsetSqInt;
			action = StartField;
l7:	/* end startObj */;
		}
		if (action == Upward) {
			/* begin upward */
			do {
				if (!(parentField & 1)) {

					/* normal */
					/* who we worked on below */
					child = field;

					/* where to put it */
					field = parentField;
					parentField = longAt(field);
					longAtput(field, child);

					/* point at header */
					field -= BytesPerWord;
					action = StartField;
					goto l2;
				}
				if (parentField == GCTopMarker) {

					/* top of the chain */
					header1 = (longAt(field)) & AllButTypeMask;
					type = /* rightType: */
							(header1 & SizeMask
								? (header1 & CompactClassMask
										? HeaderTypeShort
										: HeaderTypeClass)
								: HeaderTypeSizeAndClass);
					longAtput(field, header1 | type);
					action = Done;
					goto l2;
				}

				/* oop of class */
				child = field;

				/* class word, ** clear the low bit ** */
				field = parentField - 1;
				parentField = longAt(field);

				/* base header word */
				header1 = longAt(field + BytesPerWord);
				type = /* rightType: */
						(header1 & SizeMask
							? (header1 & CompactClassMask
									? HeaderTypeShort
									: HeaderTypeClass)
							: HeaderTypeSizeAndClass);
				longAtput(field, child | type);

				/* point at header */
				/* restore type bits */
				field += BytesPerWord;
				header1 = header1 & AllButTypeMask;
				longAtput(field, header1 | type);
			} while(1);
			action = null;
l2:	/* end upward */;
		}
	} while(!(action == Done));
	GIV(statMarkCount) = statMarkCountLocal;
	return 0;
}


/*	Answer the method header of a CompiledMethod object. */

	/* ObjectMemory>>#methodHeaderOf: */
static NoDbgRegParms sqInt
methodHeaderOf(sqInt methodObj)
{
	assert(isCompiledMethod(methodObj));
	return longAt((methodObj + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
}


/*	HeaderTypeFree free chunks require 1 word of header */

	/* ObjectMemory>>#minSlotsForShortening */
sqInt
minSlotsForShortening(void)
{
	return 1;
}


/*	For access from BitBlt module & Cogit */

	/* ObjectMemory>>#nilObject */
sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	Answer the C double precision floating point value of the argument,
	which *must* be something for which self isFloatInstance: answers true.
	Note: May be called by translated primitive code. */

	/* ObjectMemory>>#noFailFloatValueOf: */
double
noFailFloatValueOf(sqInt aFloatOop)
{
    double result;

	assert(isFloatInstance(aFloatOop));
	fetchFloatAtinto(aFloatOop + BaseHeaderSize, result);
	return result;
}

	/* ObjectMemory>>#noShiftCompactClassIndexOfHeader: */
sqInt
noShiftCompactClassIndexOfHeader(sqInt header)
{
	return header & (0x1FU << (compactClassFieldLSB()));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* ObjectMemory>>#numBytesOfBytes: */
static NoDbgRegParms sqInt
numBytesOfBytes(sqInt objOop)
{
    usqInt fmt;
    sqInt header;
    usqInt sz;

	header = longAt(objOop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(objOop - (BytesPerWord * 2))) & AllButTypeMask);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	assert(fmt >= (firstByteFormat()));
	return (sz - BaseHeaderSize) - (fmt & 3);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* ObjectMemory>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop)
{
    usqInt fmt;
    sqInt header;
    usqInt sz;

	header = longAt(objOop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(objOop - (BytesPerWord * 2))) & AllButTypeMask);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	return (fmt < (firstByteFormat())
			? sz - BaseHeaderSize
			: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Sput compatibility */

	/* ObjectMemory>>#numSlotsOfAny: */
static NoDbgRegParms int
numSlotsOfAny(sqInt obj)
{
    sqInt header;
    unsigned int sz;

	/* begin numSlotsOf: */
	header = longAt(obj);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(obj - (BytesPerWord * 2))) & AllButTypeMask);
	return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
}


/*	Answer the number of oop-sized elements in the given object.
	Unlike lengthOf: this does not adjust the length of a context
	by the stackPointer and so can be used e.g. by cloneContext: */

	/* ObjectMemory>>#numSlotsOf: */
int
numSlotsOf(sqInt obj)
{
    sqInt header;
    unsigned int sz;

	header = longAt(obj);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(obj - (BytesPerWord * 2))) & AllButTypeMask);
	return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
}


/*	Answer the object or start of free space immediately preceding the given
	address, object or free chunk in memory. If none, return 0. This is for
	debugging only. */

	/* ObjectMemory>>#objectBefore: */
sqInt
objectBefore(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    unsigned int sz;


	/* useful for debugging */
	chunk = (oopisGreaterThan(address, GIV(youngStart))
				? GIV(youngStart)
				: startOfMemory());

	/* begin oopFromChunk: */
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, address)) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if (oopisGreaterThanOrEqualTo(nextObj, address)) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	Answer the object or start of free space immediately preceding the given
	object or free chunk in memory. If none, return 0. This is for debugging
	only.  */

	/* ObjectMemory>>#objectExactlyBefore: */
sqInt
objectExactlyBefore(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt chunk;
    sqInt header;
    sqInt nextObj;
    sqInt obj;
    unsigned int sz;

	chunk = (oopisGreaterThan(oop, GIV(youngStart))
				? GIV(youngStart)
				: startOfMemory());

	/* begin oopFromChunk: */
	obj = chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
	while (oopisLessThan(obj, obj)) {
		if (((longAt(obj)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(obj)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(obj);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(obj - (BytesPerWord * 2))) & LongSizeMask)));
		}
		nextObj = (obj + sz) + (headerTypeBytes[(longAt(obj + sz)) & TypeMask]);
		if (nextObj == oop) {
			return obj;
		}
		obj = nextObj;
	}
	return 0;
}


/*	Compute the oop of this chunk by adding its extra header bytes. */

	/* ObjectMemory>>#oopFromChunk: */
static NoDbgRegParms sqInt
oopFromChunk(sqInt chunk)
{
	return chunk + (headerTypeBytes[(longAt(chunk)) & TypeMask]);
}


/*	Pop and return the possibly remapped object from the remap buffer. */

	/* ObjectMemory>>#popRemappableOop */
sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	oop is an old object. If valueObj is young, mark the object as a root. */

	/* ObjectMemory>>#possibleRootStoreInto:value: */
static NoDbgRegParms void
possibleRootStoreIntovalue(sqInt oop, sqInt valueObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;

	if ((oopisGreaterThanOrEqualTo(valueObj, GIV(youngStart)))
	 && (!((valueObj & 1)))) {

		/* Yes, valueObj is a young object */
		/* begin noteAsRoot:headerLoc: */
		header = longAt(oop);
		if (!(header & RootBit)) {

			/* record oop as root only if not already recorded */
			if (GIV(rootTableCount) < RootTableSize) {

				/* record root if there is enough room in the roots table.
				   IMPORTANT: since clearRootsTable is the only thing that clears root bits
				   do *not* set the root bit unless an object is in the root table.  checking
				   routines will complain about the root bit being unset instead of the table
				   being full, but that's life */
				GIV(rootTableCount) += 1;
				GIV(rootTable)[GIV(rootTableCount)] = oop;
				longAtput(oop, header | RootBit);
				if (GIV(rootTableCount) >= RootTableRedZone) {

					/* if we're now in the red zone force an IGC ASAP */
					/* begin scheduleIncrementalGC */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
			}
			else {

				/* note overflow; will need to do a fullGC instead of an incremental. */
				GIV(rootTableOverflowed) = 1;
			}
		}
	}
}

	/* ObjectMemory>>#primitiveErrorTable */
sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(PrimitiveErrorTableIndex) << (shiftForWord())))));
}

	/* ObjectMemory>>#printFreeObject:on: */
static NoDbgRegParms void
printFreeObjecton(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a free chunk of size %" PRIdSQINT "\n",
			((void *)oop),
			(longAt(oop)) & AllButTypeMask);
}

	/* ObjectMemory>>#printImmediateObject:on: */
static NoDbgRegParms void
printImmediateObjecton(sqInt oop, FILE *aStream)
{
	assert((oop & 1));
	fprintf(aStream,
			"%p=%" PRIdSQINT "\n",
			((void *)oop),
			((sqInt)((oop >> 1))));
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* ObjectMemory>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oop;

	oop = firstAccessibleObject();
	while (!(oop == null)) {
		if ((/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask)) == aClassOop) {
			printHex(oop);
			cr();
		}
		oop = accessibleObjectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all methods that implement
	anOop 
 */
/*	useful for VM debugging */

	/* ObjectMemory>>#printMethodImplementorsOf: */
void
printMethodImplementorsOf(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;

	obj = firstAccessibleObject();
	while (!(obj == null)) {
		if ((((((usqInt)((longAt(obj)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
		 && ((maybeSelectorOfMethod(obj)) == anOop)) {
			printHex(obj);

			/* begin space */
			printChar(' ');
			printOopShortInner(obj);
			fflush(GIV(transcript));
			cr();
		}
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */
/*	useful for VM debugging */

	/* ObjectMemory>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop)
{
    sqInt i;
    sqInt oop;

	oop = firstAccessibleObject();
	while (!(oop == null)) {
		if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
			i = ((literalCountOf(oop)) + LiteralStart) - 1;
			while (i >= 0) {
				if (anOop == (longAt((oop + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
					printHex(oop);
					print(" @ ");
					printNum(i);
					cr();
					i = 0;
				}
				i -= 1;
			}
		}
		oop = accessibleObjectAfter(oop);
	}
}

	/* ObjectMemory>>#printNonPointerDataOf:on: */
static NoDbgRegParms void
printNonPointerDataOfon(sqInt oop, FILE *aStream)
{
    sqInt elementsPerLine;
    usqInt format;
    sqInt index;
    sqInt lastIndex;
    unsigned int sz;

	format = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	assert(((format >= (sixtyFourBitIndexableFormat())) && (format <= ((firstCompiledMethodFormat()) - 1))));

	/* begin lengthOf:format: */
	/* begin lengthOf:baseHeader:format: */
	if ((longAt(oop)) & TypeMask) {
		sz = (longAt(oop)) & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (format <= 4 /* lastPointerFormat */) {
		lastIndex = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	lastIndex = (format < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (format & 3));
l1:	/* end lengthOf:format: */;
	if (!lastIndex) {
		return;
	}
	if (format == 7 /* sixtyFourBitIndexableFormat */) {
		lastIndex = ((32 < lastIndex) ? 32 : lastIndex);

		/* 0x/16r0123456789ABCDEF<space|cr> x 4 = 76/80 */
		elementsPerLine = 4;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%18" PRIXSQINT "%c",
					((usqLong) (fetchLong64ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
					? '\n'
					: ' '));
		}
		return;
	}
	if (format < (firstByteFormat())) {
		lastIndex = ((128 < lastIndex) ? 128 : lastIndex);

		/* 0x/16r12345678<space|cr> x 6 = 66/72 */
		elementsPerLine = 6;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%10p%c",
					long32At((oop + BaseHeaderSize) + ((((usqInt)((index - 1)) << 2)))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
					? '\n'
					: ' '));
		}
		return;
	}
	lastIndex = ((0x100 < lastIndex) ? 0x100 : lastIndex);

	/* 0x/16r12<space|cr> x 16 = 80/96 */
	elementsPerLine = 16;
	for (index = 1; index <= lastIndex; index += 1) {
		fprintf(aStream,
				"%4p%c",
				byteAt((oop + BaseHeaderSize) + (index - 1)),
				(((index % elementsPerLine) == 0)
		 || (index == lastIndex)
				? '\n'
				: ' '));
	}
}

	/* ObjectMemory>>#printStringDataOf:on: */
static NoDbgRegParms void
printStringDataOfon(sqInt oop, FILE *aStream)
{
    char *buffer;
    sqInt byte;
    sqInt i;
    sqInt limit;
    sqInt n;
    unsigned int *wideBuffer;
    int word;

	if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())) {
		buffer = ((char *) (alloca(0x400)));
		n = (i = 0);
		limit = (((numBytesOfBytes(oop)) < 0x100) ? (numBytesOfBytes(oop)) : 0x100);
		while (n < limit) {
			byte = byteAt((oop + BaseHeaderSize) + i);
			i += 1;
			if ((byte < 32)
			 && (byte != 9)) {
				buffer[n] = '<';
				n += 1;
				if ((byte == 10)
				 || (byte == 13)) {
					if (byte == 10) {
						buffer[n] = 'L';
						buffer[n + 1] = 'F';
					}
					else {
						buffer[n] = 'C';
						buffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (byte >= 10) {
						buffer[n] = ((byte / 10) + (((sqInt)'0')));
						n += 1;
					}
					buffer[n] = ((byte % 10) + (((sqInt)'0')));
					n += 1;
				}
				buffer[n] = '>';
				n += 1;
			}
			else {
				buffer[n] = byte;
				n += 1;
			}
		}
		fprintf(aStream,
				"%.*s%s\n",
				((int) n),
				buffer,
				((numBytesOfBytes(oop)) > limit
				? "..."
				: ""));
	}
	else {
		assert(isWordsNonImm(oop));
		wideBuffer = ((unsigned int *) (alloca(0x1000)));
		n = (i = 0);
		limit = (((lengthOf(oop)) < 0x100) ? (lengthOf(oop)) : 0x100);
		while (i < limit) {
			word = long32At((oop + BaseHeaderSize) + ((((usqInt)(i) << 2))));
			i += 1;
			if ((word < 32)
			 && (word != 9)) {
				wideBuffer[n] = '<';
				n += 1;
				if ((word == 10)
				 || (word == 13)) {
					if (word == 10) {
						wideBuffer[n] = 'L';
						wideBuffer[n + 1] = 'F';
					}
					else {
						wideBuffer[n] = 'C';
						wideBuffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (word >= 10) {
						wideBuffer[n] = ((word / 10) + (((sqInt)'0')));
						n += 1;
					}
					wideBuffer[n] = ((word % 10) + (((sqInt)'0')));
					n += 1;
				}
				wideBuffer[n] = '>';
				n += 1;
			}
			else {
				wideBuffer[n] = word;
				n += 1;
			}
		}
		fwprintf(aStream,
				L"%.*s%s\n",
				((int) n),
				wideBuffer,
				((lengthOf(oop)) > limit
				? "..."
				: ""));
	}
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that objects in temporary variables are properly
	remapped. 
 */

	/* ObjectMemory>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}


/*	Map the given oop to its new value during a compaction or become:
	operation. 
 */

	/* ObjectMemory>>#remapObj: */
static NoDbgRegParms sqInt
remapObj(sqInt obj)
{
    usqInt fwdBlock;
    sqInt targetObj;

	/* begin remappedObj: */
	fwdBlock = (((longAt(obj)) & AllButMarkBitAndTypeMask) << 1);
	assert(fwdBlockValid(fwdBlock));
	targetObj = longAt(fwdBlock);
	assert(addressCouldBeObjWhileForwarding(targetObj));
	return targetObj;
}


/*	Map the given oop to its new value during a compaction or 
	become: operation. If it has no forwarding table entry, 
	return the oop itself. */

	/* ObjectMemory>>#remap: */
sqInt
remap(sqInt oop)
{
    usqInt fwdBlock;
    sqInt targetObj;

	if (/* isObjectForwarded: */
		((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0)) {
		/* begin remappedObj: */
		fwdBlock = (((longAt(oop)) & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlock));
		targetObj = longAt(fwdBlock);
		assert(addressCouldBeObjWhileForwarding(targetObj));
		return targetObj;
	}
	return oop;
}


/*	Remove the given variable location to the extra roots table */

	/* ObjectMemory>>#removeGCRoot: */
sqInt
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Remove the given young root from the root table (for freeObject: for
	becomeForward:). 
 */

	/* ObjectMemory>>#removeYoungRoot: */
static NoDbgRegParms sqInt
removeYoungRoot(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int i;

	for (i = 1; i <= GIV(rootTableCount); i++) {
		if (obj == (GIV(rootTable)[i])) {

			/* swap obj with last entry */
			GIV(rootTable)[i] = (GIV(rootTable)[GIV(rootTableCount)]);
			GIV(rootTableCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Answer if the oop should be remapped */

	/* ObjectMemory>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt oop)
{
	return /* isObjectForwarded: */
		((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0);
}


/*	Answer if the oop should be remapped */

	/* ObjectMemory>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop)
{
	return ((oop & 1) == 0)
	 && (/* isObjectForwarded: */
		((oop & 1) == 0)
	 && (((longAt(oop)) & MarkBit) != 0));
}

	/* ObjectMemory>>#sixtyFourBitIndexableFormat */
static sqInt
sixtyFourBitIndexableFormat(void)
{
	return 7;
}


/*	Returns the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

	/* ObjectMemory>>#slotSizeOf: */
sqInt
slotSizeOf(sqInt oop)
{
    sqInt fmt;
    sqInt header;
    unsigned int sz;

	if ((oop & 1)) {
		return 0;
	}

	/* begin lengthOf: */
	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
			? ((usqInt)((sz - BaseHeaderSize))) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Return one of the objects in the SpecialObjectsArray */

	/* ObjectMemory>>#splObj: */
sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
}


/*	Part of InterpreterProxy's 1.14 API */

	/* ObjectMemory>>#statNumGCs */
sqInt
statNumGCs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(statIncrGCs) + GIV(statFullGCs);
}

	/* ObjectMemory>>#storeLong32:ofObject:withValue: */
int
storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valueWord)
{
	return long32Atput((oop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << 2))), valueWord);
}


/*	Like storePointer:ofObject:withValue:, but the caller guarantees that the
	object being stored into is a young object or is already marked as a root. */

	/* ObjectMemory>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{
	return longAtput((oop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

	/* ObjectMemory>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt oop, sqInt valuePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (oopisLessThan(oop, GIV(youngStart))) {
		possibleRootStoreIntovalue(oop, valuePointer);
	}
	return longAtput((oop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory.
	Caution: This may invoke the garbage collector. */

	/* ObjectMemory>>#stringForCString: */
sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord()))))), len);
	if (newString) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

	/* ObjectMemory>>#tenuringIncrementalGC */
void
tenuringIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(forceTenureFlag) = 1;
	incrementalGC();
}


/*	Returns the top of the remappable oop. Useful when writing loops. */

	/* ObjectMemory>>#topRemappableOop */
sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}

	/* ObjectMemory>>#trueObject */
sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}


/*	update pointers in the given memory range */

	/* ObjectMemory>>#updatePointersInRangeFrom:to: */
static NoDbgRegParms void
updatePointersInRangeFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    unsigned int classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    usqInt fmt;
    usqInt fwdBlock;
    usqInt fwdBlockUsqInt;
    sqInt header;
    sqInt header1;
    sqInt headerSqInt;
    usqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    usqInt numLiterals;
    sqInt oop;
    sqInt realHeader;
    usqInt size;
    sqInt sp;
    unsigned int sz;
    unsigned int sz1;

	oop = memStart + (headerTypeBytes[(longAt(memStart)) & TypeMask]);
	while (oopisLessThan(oop, memEnd)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			/* begin remapFieldsAndClassOf: */
			/* begin lastPointerWhileForwarding: */
			/* begin headerWhileForwardingOf: */
			header = longAt(oop);
			if (header & MarkBit) {

				/* oop is forwarded; get its real header from its forwarding table entry */
				fwdBlock = ((header & AllButMarkBitAndTypeMask) << 1);
				assert(fwdBlockValid(fwdBlock));
				header = longAt(fwdBlock + BytesPerWord);
			}
			fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
			if (fmt <= 4 /* lastPointerFormat */) {
				if ((fmt == (indexablePointersFormat()))
				 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l2;
					}
					contextSize = (sp >> 1);
l2:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
					goto l3;
				}
				size = (header & TypeMask
							? header & SizeMask
							: (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask);
				fieldOffset = size - BaseHeaderSize;
				goto l3;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				fieldOffset = 0;
				goto l3;
			}
			assert(isCompiledMethodHeader(header));
			header = longAt((oop + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

			/* begin lastPointerOfMethodHeader: */
			/* begin literalCountOfMethodHeader: */
			assert((header & 1));
			numLiterals = ((((int) header)) < 0
						? ((header >> 1)) & AlternateHeaderNumLiteralsMask
						: (((usqInt)(header)) >> 10) & 0xFF);
			fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l3:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (/* isObjectForwarded: */
					((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {

					/* update this oop from its forwarding block */
					/* begin remappedObj: */
					fwdBlock = (((longAt(fieldOop)) & AllButMarkBitAndTypeMask) << 1);
					assert(fwdBlockValid(fwdBlock));
					newOop = longAt(fwdBlock);
					assert(addressCouldBeObjWhileForwarding(newOop));
					longAtput(oop + fieldOffset, newOop);
					if ((oopisLessThan(oop, GIV(youngStart)))
					 && (oopisGreaterThanOrEqualTo(newOop, GIV(youngStart)))) {
						beRootWhileForwarding(oop);
					}
				}
				fieldOffset -= BytesPerWord;
			}

			/* begin remapClassOf: */
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l1;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (/* isObjectForwarded: */
				((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock = (((longAt(classOop)) & AllButMarkBitAndTypeMask) << 1);
				assert(fwdBlockValid(fwdBlock));
				newClassOop = longAt(fwdBlock);
				assert(addressCouldBeObjWhileForwarding(newClassOop));
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if ((oopisLessThan(oop, GIV(youngStart)))
				 && (oopisGreaterThanOrEqualTo(newClassOop, GIV(youngStart)))) {
					beRootWhileForwarding(oop);
				}
			}
l1:	/* end remapClassOf: */;
		}

		/* begin objectAfterWhileForwarding: */
		header1 = longAt(oop);
		if (!(header1 & MarkBit)) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqInt = longAt(oop);
				sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l4;
		}
		fwdBlockUsqInt = ((header1 & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlockUsqInt));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlockUsqInt + BytesPerWord);
		if (realHeader & TypeMask) {
			sz = realHeader & SizeMask;
		}
		else {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
l4:	/* end objectAfterWhileForwarding: */;
	}
}


/*	update pointers in root objects */

	/* ObjectMemory>>#updatePointersInRootObjectsFrom:to: */
static NoDbgRegParms void
updatePointersInRootObjectsFromto(sqInt memStart, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classHeader;
    unsigned int classOop;
    sqInt contextSize;
    sqInt fieldOffset;
    sqInt fieldOop;
    usqInt fmt;
    usqInt fwdBlock;
    sqInt header;
    sqInt i;
    usqInt newClassHeader;
    sqInt newClassOop;
    sqInt newOop;
    usqInt numLiterals;
    sqInt oop;
    usqInt size;
    sqInt sp;

	for (i = 1; i <= GIV(rootTableCount); i += 1) {
		oop = GIV(rootTable)[i];
		if ((oopisLessThan(oop, memStart))
		 || (oopisGreaterThanOrEqualTo(oop, memEnd))) {

			/* Note: must not remap the fields of any object twice! */
			/* remap this oop only if not in the memory range
			   covered below */
			/* begin remapFieldsAndClassOf: */
			/* begin lastPointerWhileForwarding: */
			/* begin headerWhileForwardingOf: */
			header = longAt(oop);
			if (header & MarkBit) {

				/* oop is forwarded; get its real header from its forwarding table entry */
				fwdBlock = ((header & AllButMarkBitAndTypeMask) << 1);
				assert(fwdBlockValid(fwdBlock));
				header = longAt(fwdBlock + BytesPerWord);
			}
			fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
			if (fmt <= 4 /* lastPointerFormat */) {
				if ((fmt == (indexablePointersFormat()))
				 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin nacFetchStackPointerOf: */
					sp = longAt((oop + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l2;
					}
					contextSize = (sp >> 1);
l2:	/* end nacFetchStackPointerOf: */;
					assert((ReceiverIndex + contextSize) < (lengthOfbaseHeaderformat(oop, header, fmt)));
					fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
					goto l3;
				}
				size = (header & TypeMask
							? header & SizeMask
							: (longAt(oop - (BytesPerWord * 2))) & AllButTypeMask);
				fieldOffset = size - BaseHeaderSize;
				goto l3;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				fieldOffset = 0;
				goto l3;
			}
			assert(isCompiledMethodHeader(header));
			header = longAt((oop + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

			/* begin lastPointerOfMethodHeader: */
			/* begin literalCountOfMethodHeader: */
			assert((header & 1));
			numLiterals = ((((int) header)) < 0
						? ((header >> 1)) & AlternateHeaderNumLiteralsMask
						: (((usqInt)(header)) >> 10) & 0xFF);
			fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
l3:	/* end lastPointerWhileForwarding: */;
			while (fieldOffset >= BaseHeaderSize) {
				fieldOop = longAt(oop + fieldOffset);
				if (/* isObjectForwarded: */
					((fieldOop & 1) == 0)
				 && (((longAt(fieldOop)) & MarkBit) != 0)) {

					/* update this oop from its forwarding block */
					/* begin remappedObj: */
					fwdBlock = (((longAt(fieldOop)) & AllButMarkBitAndTypeMask) << 1);
					assert(fwdBlockValid(fwdBlock));
					newOop = longAt(fwdBlock);
					assert(addressCouldBeObjWhileForwarding(newOop));
					longAtput(oop + fieldOffset, newOop);
					if ((oopisLessThan(oop, GIV(youngStart)))
					 && (oopisGreaterThanOrEqualTo(newOop, GIV(youngStart)))) {
						beRootWhileForwarding(oop);
					}
				}
				fieldOffset -= BytesPerWord;
			}

			/* begin remapClassOf: */
			if (((longAt(oop)) & TypeMask) == HeaderTypeShort) {
				goto l1;
			}
			classHeader = longAt(oop - BytesPerWord);
			classOop = classHeader & AllButTypeMask;
			if (/* isObjectForwarded: */
				((classOop & 1) == 0)
			 && (((longAt(classOop)) & MarkBit) != 0)) {
				/* begin remappedObj: */
				fwdBlock = (((longAt(classOop)) & AllButMarkBitAndTypeMask) << 1);
				assert(fwdBlockValid(fwdBlock));
				newClassOop = longAt(fwdBlock);
				assert(addressCouldBeObjWhileForwarding(newClassOop));
				newClassHeader = newClassOop | (classHeader & TypeMask);
				longAtput(oop - BytesPerWord, newClassHeader);
				if ((oopisLessThan(oop, GIV(youngStart)))
				 && (oopisGreaterThanOrEqualTo(newClassOop, GIV(youngStart)))) {
					beRootWhileForwarding(oop);
				}
			}
l1:	/* end remapClassOf: */;
		}
	}
}


/*	return 0 for little endian, 1 for big endian */
/*	?!*#$%! _Terrible_ name. Call it what it is.
	VMBIGENDIAN or VMLITTLEENDIAN. Dont leave us guessing!!!!
	Alas this has to remain for backward compatibility. */

	/* ObjectMemory>>#vmEndianness */
sqInt
vmEndianness(void)
{
	return (VMBIGENDIAN
			? 1
			: 0);
}


/*	Answer the current activeProcess. */
/*	useful for VM debugging */

	/* StackInterpreter>>#activeProcess */
sqInt
activeProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));

	/* begin fetchPointer:ofObject: */
	return longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
}


/*	The various poll/select calls in the VM should attempt to tally the
	ammount of time spent at idle here, so as to render the uptime value
	meaningful. 
 */

	/* StackInterpreter>>#addIdleUsecs: */
void
addIdleUsecs(sqInt idleUsecs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(statIdleUsecs) += idleUsecs;
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

	/* StackInterpreter>>#addLastLink:toList: */
static NoDbgRegParms void
addLastLinktoList(sqInt proc, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert(!((isForwarded(proc))));
	assert(!((isForwarded(aList))));
	assert((fetchPointerofObject(NextLinkIndex, proc)) == (nilObject()));
	if ((/* begin isEmptyList: */
		assert(!(isForwarded(aList))),
	(longAt((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aList, GIV(youngStart))) {
			possibleRootStoreIntovalue(aList, proc);
		}
		longAtput((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))), proc);
	}
	else {
		lastLink = longAt((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))));
		assert(lastLink != proc);

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(lastLink, GIV(youngStart))) {
			possibleRootStoreIntovalue(lastLink, proc);
		}
		longAtput((lastLink + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))), proc);
	}

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(aList, GIV(youngStart))) {
		possibleRootStoreIntovalue(aList, proc);
	}
	longAtput((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))), proc);

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(proc, GIV(youngStart))) {
		possibleRootStoreIntovalue(proc, aList);
	}
	longAtput((proc + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))), aList);
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */

	/* StackInterpreter>>#addNewMethodToCache: */
static NoDbgRegParms void
addNewMethodToCache(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt methodHeader;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    usqInt probe;

	/* shift drops low-order zeros from addresses */
	hash = GIV(messageSelector) ^ classObj;
	if (/* isOopCompiledMethod: */
		((GIV(newMethod) & 1) == 0)
	 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
		/* begin primitiveIndexOf: */
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin primitiveIndexOfMethod:header: */
		primBits = (methodHeader >> 1);
		primitiveIndex = (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);

		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
		? 0
		: primitiveTable[primitiveIndex])));
	}
	else {
		assert(!((isNonImmediate(GIV(newMethod)))
		 && (isForwarded(GIV(newMethod)))));
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt)(hash)) >> p) & MethodCacheMask;
		if (!(GIV(methodCache)[probe + MethodCacheSelector])) {

			/* Found an empty entry -- use it */
			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = classObj;
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));

			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */
	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = classObj;
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((sqIntptr_t) primitiveFunctionPointer));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */
	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt)(hash)) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static NoDbgRegParms sqInt
addressCouldBeClassObj(sqInt maybeClassObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (/* addressCouldBeObj: */
		((maybeClassObj & 3) == 0)
	 && (((((usqInt)maybeClassObj)) >= (startOfMemory()))
	 && (((((usqInt)maybeClassObj)) < GIV(freeStart))
	 && (((longAt(maybeClassObj)) & TypeMask) != HeaderTypeGC))))
	 && (objCouldBeClassObj(maybeClassObj));
}

	/* StackInterpreter>>#allOnesAsCharStar */
static char *
allOnesAsCharStar(void)
{
	return ((char *) (((usqInt) -1)));
}


/*	for Cogit */

	/* StackInterpreter>>#argumentCountOfClosure: */
sqInt
argumentCountOfClosure(sqInt closurePointer)
{
    sqInt oop;

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((closurePointer + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
	assert((oop & 1));
	return (oop >> 1);
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
usqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
usqInt
argumentCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin argumentCountOfMethodHeader: */
	return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#arrayValueOf: */
void *
arrayValueOf(sqInt arrayOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (/* isWordsOrBytes: */
		((arrayOop & 1) == 0)
	 && (isWordsOrBytesNonImm(arrayOop))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Returns an integer object */

	/* StackInterpreter>>#asciiOfCharacter: */
static NoDbgRegParms sqInt
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isCharacterObjectRV;

	/* begin isCharacterObject: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassCharacter) << (shiftForWord())))));
	if ((characterObj & 1)) {
		isCharacterObjectRV = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((characterObj & 1)));
	ccIndex = (((usqInt)((longAt(characterObj)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isCharacterObjectRV = ((longAt(characterObj - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isCharacterObjectRV = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isCharacterObject: */;
	if (isCharacterObjectRV) {
		return longAt((characterObj + BaseHeaderSize) + ((((usqInt)(CharacterValueIndex) << (shiftForWord())))));
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	return ConstZero;
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s: */
void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp)
{
	assertValidExecutionPointersimbarline(lip, lifp, lisp, 1 /* (isMachineCodeFrame: not) */, __LINE__);
}

	/* StackInterpreter>>#assertValidExecutionPointe:r:s:imbar:line: */
static NoDbgRegParms void
assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertl(inInterpreter, ln);
	assertl(GIV(stackPage) == (GIV(mostRecentlyUsedPage)), ln);

	/* begin assertValidStackLimits: */
	assertl((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (allOnesAsCharStar())), ln);
	assertl((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (allOnesAsCharStar())), ln);
	assertl(addressIsInPage(GIV(stackPage), lfp), ln);
	assertl(lsp < lfp, ln);
	assertl(lfp > lsp, ln);
	assertl(lsp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())), ln);
	assertl(((lfp - lsp) / BytesPerOop) < LargeContextSlots, ln);
	assertl(validInstructionPointerinFrame(lip, lfp), ln);
	assertl((frameIsBlockActivation(lfp))
	 || ((pushedReceiverOrClosureOfFrame(lfp)) == (frameReceiver(lfp))), ln);
	assertl(GIV(method) == (frameMethod(lfp)), ln);
}


/*	Support for primitiveSuspend.
	Assume suspendedContext is that of a process waiting on a condition
	variable. Backup the PC of suspendedContext to the send that entered the
	wait state.
	primitiveEnterCriticalSection pushes false for blocked waiters. false must
	be replaced by the condition variable. */

	/* StackInterpreter>>#backupContext:toBlockingSendTo: */
static NoDbgRegParms void
backupContexttoBlockingSendTo(sqInt suspendedContext, sqInt conditionVariable)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt pc;
    sqInt senderOop;
    sqInt sp;
    char *theFP;
    sqInt theIP;
    sqInt theMethod;
    sqInt theNewIP;
    StackPage *thePage;

	assert(isContext(suspendedContext));
	theMethod = longAt((suspendedContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!((longAt((suspendedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		pc = longAt((suspendedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
		sp = longAt((suspendedContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		assert(((pc & 1))
		 && (((pc >> 1)) > 0));
		assert(((sp & 1))
		 && (((sp >> 1)) > 0));
		theIP = ((theMethod + BaseHeaderSize) + ((pc >> 1))) - 1;
		theNewIP = pcPreviousToFunction(theIP, theMethod);
		assert((theNewIP < theIP)
		 && ((theIP - theNewIP) <= 3));
		pc = ((theNewIP - theMethod) - BaseHeaderSize) + 1;

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((suspendedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), (((usqInt)pc << 1) | 1));

		/* implicitly converts to 0 relative */
		sp = ((sp >> 1)) + ReceiverIndex;
		assert(((fetchPointerofObject(sp, suspendedContext)) == (falseObject()))
		 || ((fetchPointerofObject(sp, suspendedContext)) == conditionVariable));

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(suspendedContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(suspendedContext, conditionVariable);
		}
		longAtput((suspendedContext + BaseHeaderSize) + ((((usqInt)(sp) << (shiftForWord())))), conditionVariable);
		return;
	}
	assert(isMarriedOrWidowedContext(suspendedContext));
	assert(!((isWidowedContextNoConvert(suspendedContext))));

	/* begin frameOfMarriedContext: */
	senderOop = longAt((suspendedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	assert(!((thePage == GIV(stackPage))));
	assert(theFP == ((thePage->headFP)));

	/* fetchByte uses pre-increment; must + 1 to point at correct bytecode... */
	theIP = (longAt((thePage->headSP))) + 1;
	theNewIP = pcPreviousToFunction(theIP, theMethod);
	assert((theNewIP < theIP)
	 && ((theIP - theNewIP) <= 3));
	longAtput((thePage->headSP), theNewIP - 1);
	assert(((longAt(((thePage->headSP)) + BytesPerWord)) == (falseObject()))
	 || ((longAt(((thePage->headSP)) + BytesPerWord)) == conditionVariable));
	longAtput(((thePage->headSP)) + BytesPerWord, conditionVariable);
}


/*	convert true and false (Smalltalk) to true or false(C) */

	/* StackInterpreter>>#booleanValueOf: */
sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}

	/* begin success: */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Re-enter the interpreter to execute a (non-Alien) callback. */

	/* StackInterpreter>>#callbackEnter: */
sqInt
callbackEnter(sqInt *callbackID)
{
	warning("callbackEnter: is obsolete");
	return 0;
}


/*	Leave from a previous callback */

	/* StackInterpreter>>#callbackLeave: */
sqInt
callbackLeave(sqInt cbID)
{
	warning("callbackLeave: is obsolete");
	return 0;
}


/*	Context switch should not be allowed on every method activation. In
	particular the
	implementation of ensure: and ifCurtailed: depends on there being no
	suspension point
	on failing primitive 198 (primitiveMarkUnwindMethod,
	primitiveMarkUnwindMethod). slowPrimitiveResponse used to state
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod and
	PrimNumberNoContextSwitch.  */

	/* StackInterpreter>>#canContextSwitchIfActivating:header: */
sqInt
canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt primBits;
    sqInt primitiveIndex;

	/* begin primitiveIndexOfMethod:header: */
	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);
	return (primitiveIndex != PrimNumberUnwindMarker)
			 && (primitiveIndex != PrimNumberNoContextSwitchMarker);
}


/*	Above ObjectMemory, arg must lie in range 0-255! */

	/* StackInterpreter>>#characterForAscii: */
sqInt
characterForAscii(sqInt ascii)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CharacterTable) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ascii) << (shiftForWord())))));
}


/*	Ensure that all accessible objects in the heap are okay. */
/*	useful for VM debugging */

	/* StackInterpreter>>#checkAllAccessibleObjectsOkay */
sqInt
checkAllAccessibleObjectsOkay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt fwdBlock;
    sqInt header;
    sqInt headerSqInt;
    sqInt ok;
    sqInt oopSqInt;
    sqInt realHeader;
    unsigned int sz;
    unsigned int sz1;

	ok = 1;

	/* begin allObjectsDoSafely: */
	oopSqInt = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oopSqInt)) < GIV(freeStart)) {
		if (!(((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree)) {
			ok = ok && (checkOkayFields(oopSqInt));
		}

		/* begin objectAfterWhileForwarding: */
		header = longAt(oopSqInt);
		if (!(header & MarkBit)) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oopSqInt, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oopSqInt)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqInt = longAt(oopSqInt);
				sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oopSqInt - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oopSqInt = (oopSqInt + sz1) + (headerTypeBytes[(longAt(oopSqInt + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlock = ((header & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock + BytesPerWord);
		if (realHeader & TypeMask) {
			sz = realHeader & SizeMask;
		}
		else {
			sz = (longAt(oopSqInt - (BytesPerWord * 2))) & LongSizeMask;
		}
		oopSqInt = (oopSqInt + sz) + (headerTypeBytes[(longAt(oopSqInt + sz)) & TypeMask]);
l1:	/* end objectAfterWhileForwarding: */;
	}
	return ok;
}


/*	This is a no-op in the StackVM */

	/* StackInterpreter>>#checkCodeIntegrity: */
static NoDbgRegParms sqInt
checkCodeIntegrity(sqInt fullGCFlag)
{
	return 1;
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

	/* StackInterpreter>>#checkDeliveryOfLongRunningPrimitiveSignal */
#if LRPCheck
static NeverInline sqInt
checkDeliveryOfLongRunningPrimitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore))
	 && (GIV(longRunningPrimitiveSignalUndelivered)))) {

		/* but not yet delivered */
		GIV(longRunningPrimitiveSignalUndelivered) = 0;

		/* Signal the LRP check semaphore if it is present */
		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
			 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
					? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
					: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore));
	}
	return 0;
}
#endif /* LRPCheck */


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#checkedIntegerValueOf: */
sqInt
checkedIntegerValueOf(sqInt intOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

	/* StackInterpreter>>#checkForEventsMayContextSwitch: */
static NoDbgRegParms sqInt
checkForEventsMayContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt nowSqInt;
    sqInt oop;
    sqInt sema;
    sqInt switched;

	/* restore the stackLimit if it has been smashed. */
	GIV(statCheckForEvents) += 1;

	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	ioSynchronousCheckForEvents();
	if (GIV(needGCFlag)) {

		/* sufficientSpaceAfterGC: runs the incremental GC and
		   then, if not enough space is available, the fullGC. */
		if (!(sufficientSpaceAfterGC(0))) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
	}
	if (!mayContextSwitch) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
	 && ((ioHighResClock()) >= GIV(nextProfileTick)))) {
		/* begin zeroNextProfileTick */
		GIV(nextProfileTick) = 0;
		if (GIV(profileProcess) == GIV(nilObj)) {
			/* begin activeProcess */
			oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
			GIV(profileProcess) = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore)))) {
			switched = 1;
		}
	}
#  if LRPCheck
	if (checkDeliveryOfLongRunningPrimitiveSignal()) {
		switched = 1;
	}
#  endif

	if (GIV(signalLowSpace)) {
		/* signalLowSpace: */
		GIV(signalLowSpace) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheLowSpaceSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	nowSqInt = (now = ioUTCMicroseconds());

	/* begin checkInvokeIOProcessEvents: */
	if (nowSqInt >= GIV(nextPollUsecs)) {
		GIV(statIOProcessEvents) += 1;
		ioProcessEvents();

		/* msecs to wait before next call to ioProcessEvents.  Note that strictly
		   speaking we might need to update 'now' at this point since
		   ioProcessEvents could take a very long time on some platforms */
		GIV(nextPollUsecs) = nowSqInt + 20000;
	}
	if (GIV(interruptPending)) {
		/* reset interrupt flag */
		GIV(interruptPending) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheInterruptSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs)) {
		if (now >= GIV(nextWakeupUsecs)) {
			/* set timer interrupt to 0 for 'no timer' */
			GIV(nextWakeupUsecs) = 0;
			sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheTimerSemaphore) << (shiftForWord())))));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		GIV(pendingFinalizationSignals) = 0;
		sema = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheFinalizationSemaphore) << (shiftForWord())))));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (signalExternalSemaphores()) {
		switched = 1;
	}
	return switched;
}


/*	Support for embedded images. Check that the first few bytes of a potential
	header and answer if it
	looks like something the VM can load,
	The method checks the first three fields of the header (magic, header size
	& data size) & the total size.
	The magic number should be correct.
	The header size should be correct.
	The size of the data should be at least as long as the headerSize plus the
	data size in the header */
/*	Need at least headerSize bytes; no point going further if not... */

	/* StackInterpreter>>#checkImageHeaderFromBytes:AndSize: */
sqInt
checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize)
{
    sqInt dataSize;
    sqInt headerSize;
    int version;

	if (totalSize < (BytesPerWord * 16)) {
		return 0;
	}
	version = long32At(bytes);
	headerSize = long32At(bytes + 4);
	dataSize = longAt(bytes + 8);
	if (!(/* readableFormat: */
			(version == 6505 /* imageFormatVersion */)
		 || (version == 6504 /* imageFormatCompatibilityVersion */))) {
		if (!(/* readableFormat: */
				((SQ_SWAP_4_BYTES(version)) == 6505 /* imageFormatVersion */)
			 || ((SQ_SWAP_4_BYTES(version)) == 6504 /* imageFormatCompatibilityVersion */))) {
			return 0;
		}
		headerSize = 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(headerSize)
#      else
				SQ_SWAP_8_BYTES(headerSize)
#      endif
				;
		dataSize = 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES(dataSize)
#      else
				SQ_SWAP_8_BYTES(dataSize)
#      endif
				;
	}
	return (headerSize == (BytesPerWord * 16))
	 && (totalSize >= (headerSize + dataSize));
}


/*	Read and verify the image file version number and answer it.
	Assign through rawVersionPtr the unswapped version number. The caller can
	then infer if the given image file needs to be byte-swapped by seeing if
	the returned value
	equals tha assigned through rawVersionPtr.
	0 is answered if no valid version could be found. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt:assignRawVersion: */
static NoDbgRegParms sqInt
checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr)
{
    sqInt version;
    int w;

	rawVersionPtr[0] = 0;
	sqImageFileSeek(f, imageOffset);

	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	version = w;
	rawVersionPtr[0] = version;
	if (/* readableFormat: */
		(version == 6505 /* imageFormatVersion */)
	 || (version == 6504 /* imageFormatCompatibilityVersion */)) {
		return version;
	}
	sqImageFileSeek(f, imageOffset);

	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	version = SQ_SWAP_4_BYTES(w);
	if (!(/* isLikelyImageVersion: */
			(((rawVersionPtr[0]) / 100) == 65)
		 || (((rawVersionPtr[0]) / 1000) == 68))) {
		rawVersionPtr[0] = version;
	}
	if (/* readableFormat: */
		(version == 6505 /* imageFormatVersion */)
	 || (version == 6504 /* imageFormatCompatibilityVersion */)) {
		return version;
	}
	if (!imageOffset) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 0x200);

		/* begin getWord32FromFile:swap: */
		w = 0;
		sqImageFileRead((&w), sizeof(int), 1, f);
		version = w;
		if (!(/* isLikelyImageVersion: */
				(((rawVersionPtr[0]) / 100) == 65)
			 || (((rawVersionPtr[0]) / 1000) == 68))) {
			rawVersionPtr[0] = version;
		}
		if (/* readableFormat: */
			(version == 6505 /* imageFormatVersion */)
		 || (version == 6504 /* imageFormatCompatibilityVersion */)) {
			return version;
		}
		sqImageFileSeek(f, 0x200);

		/* begin getWord32FromFile:swap: */
		w = 0;
		sqImageFileRead((&w), sizeof(int), 1, f);
		version = SQ_SWAP_4_BYTES(w);
		if (!(/* isLikelyImageVersion: */
				(((rawVersionPtr[0]) / 100) == 65)
			 || (((rawVersionPtr[0]) / 1000) == 68))) {
			rawVersionPtr[0] = version;
		}
		if (/* readableFormat: */
			(version == 6505 /* imageFormatVersion */)
		 || (version == 6504 /* imageFormatCompatibilityVersion */)) {
			return version;
		}
	}
	if (!(/* isLikelyImageVersion: */
			(((rawVersionPtr[0]) / 100) == 65)
		 || (((rawVersionPtr[0]) / 1000) == 68))) {
		rawVersionPtr[0] = version;
	}
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer 0 if all checks pass. */

	/* StackInterpreter>>#checkInterpreterIntegrity */
static sqInt
checkInterpreterIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;

	flags = 0;
	if (!(checkOopIntegritynamed(GIV(specialObjectsOop), "specialObjectsOop"))) {
		flags = 1;
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod"))) {
		flags += 2;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess"))) {
		flags += 4;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod"))) {
		flags += 8;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore"))) {
		flags += 16;
	}
	if (GIV(tempOop)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop"))) {
			flags += 32;
		}
	}
	if (GIV(tempOop2)) {
		if (!(checkOopIntegritynamed(GIV(tempOop2), "tempOop2"))) {
			flags += 64;
		}
	}
	return flags;
}


/*	Another version of isWidowedContext: for debugging.
	This will not bereave a widowed context. */

	/* StackInterpreter>>#checkIsStillMarriedContext:currentFP: */
static NoDbgRegParms sqInt
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *limitFP;
    char *maybeFP;
    sqInt maybeFrameCtxt;
    sqInt senderOop;
    StackPage *thePage;

	if (!((/* isContext: */
			((aContext & 1) == 0)
		 && (((((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && (((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
		return 0;
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	maybeFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(maybeFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	limitFP = ((thePage == GIV(stackPage))
		 && (currentFP)
				? currentFP
				: (thePage->headFP));
	if (!((maybeFP >= limitFP)
		 && ((((((sqInt)(pointerForOop(longAt(maybeFP + FoxSavedFP))))) & 1) == 0)
		 && ((((/* begin withSmallIntegerTags: */
			assert(((oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) & (BytesPerWord - 1)) == 0),
		(oopForPointer(pointerForOop(longAt(maybeFP + FoxSavedFP)))) + 1 /* smallIntegerTag */)) == (longAt((aContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))))
		 && ((byteAt((maybeFP + FoxFrameFlags) + 2)) != 0))))) {
		return 0;
	}

	/* On Spur we need to follow the context to check for a match, but since the VM is
	   only speculating about maybeFrame being a frame, and only speculating about
	   maybeContext being a context, we need to be sure before we can safely follow. */
	maybeFrameCtxt = longAt(maybeFP + FoxThisContext);
	return maybeFrameCtxt == aContext;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

	/* StackInterpreter>>#checkOkayFields: */
static NoDbgRegParms sqInt
checkOkayFields(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;
    sqInt iSqInt;
    sqInt oopSqInt;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((oop & 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
		 || (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return 1;
	}
	oopSqInt = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);

	/* begin isYoung: */
	hasYoung = ((oopSqInt & 1) == 0)
		 && (oopisGreaterThanOrEqualTo(oopSqInt, GIV(youngStart)));
	if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		i = ((literalCountOf(oop)) + LiteralStart) - 1;
	}
	else {
		if (/* isContext: */
			((oop & 1) == 0)
		 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOf(oop)) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))));
		if (!((fieldOop & 1))) {
			hasYoung = hasYoung
				 || (/* isYoung: */
					((fieldOop & 1) == 0)
				 && (oopisGreaterThanOrEqualTo(fieldOop, GIV(youngStart))));
			if (!(checkOkayOop(fieldOop))) {
				return 0;
			}
			if (!(checkOopHasOkayClass(fieldOop))) {
				return 0;
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if (oopisGreaterThanOrEqualTo(oop, GIV(youngStart))) {
			return 1;
		}
		if (!((longAt(oop)) & RootBit)) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"root bit is not set in ");
			printHex(oop);
			cr();
			return 0;
		}
		for (iSqInt = 1; iSqInt <= GIV(rootTableCount); iSqInt += 1) {
			if (oop == (GIV(rootTable)[iSqInt])) {
				return 1;
			}
		}
		printHex(oop);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" has root bit set but is not in rootTable");
		cr();
		return 0;
	}
	return 1;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#checkOkayInterpreterObjects: */
sqInt
checkOkayInterpreterObjects(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int i;
    sqInt ok;
    sqInt oop;
    sqIntptr_t oopOrZero;

	ok = 1;
	ok = ok && (checkOkayFields(GIV(nilObj)));
	ok = ok && (checkOkayFields(GIV(falseObj)));
	ok = ok && (checkOkayFields(GIV(trueObj)));
	ok = ok && (checkOkayFields(GIV(specialObjectsOop)));
	ok = ok && (checkOkayFields(GIV(messageSelector)));
	ok = ok && (checkOkayFields(GIV(newMethod)));
	ok = ok && (checkOkayFields(GIV(lkupClass)));
	for (i = 0; i < MethodCacheEntries; i += MethodCacheEntrySize) {
		oopOrZero = GIV(methodCache)[i + MethodCacheSelector];
		if (oopOrZero) {
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheSelector]));
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheClass]));
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheMethod]));
		}
	}
	for (i = 1; i <= GIV(remapBufferCount); i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & 1))) {
			ok = ok && (checkOkayFields(oop));
		}
	}
	ok = ok && (checkOkayStackZone(writeBack));
	return ok;
}

	/* StackInterpreter>>#checkOkayStackPage: */
static NoDbgRegParms sqInt
checkOkayStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt ok;
    sqInt oop;
    char *theFP;
    char *theSP;

	callerFP = ((char *) 0);
	theSP = (thePage->headSP);
	theFP = (thePage->headFP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	ok = 1;
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				ok = ok && (checkOkayFields(oop));
			}
			theSP += BytesPerWord;
		}
		if (byteAt((theFP + FoxFrameFlags) + 2)) {
			assert(isContext(frameContext(theFP)));
			ok = ok && (checkOkayFields(longAt(theFP + FoxThisContext)));
		}
		ok = ok && (checkOkayFields(longAt(theFP + FoxMethod)));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			ok = ok && (checkOkayFields(oop));
		}
		theSP += BytesPerWord;
	}
	return ok;
}


/*	Check that all objects in the stack zone are okay */

	/* StackInterpreter>>#checkOkayStackZone: */
static NoDbgRegParms sqInt
checkOkayStackZone(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;
    StackPage *thePage;

	if (writeBack) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			ok = ok && (checkOkayStackPage(thePage));
		}
	}
	return ok;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

	/* StackInterpreter>>#checkProfileTick: */
static NoDbgRegParms void
checkProfileTick(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock()) >= GIV(nextProfileTick)) {
		/* begin activeProcess */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
		GIV(profileProcess) = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
		GIV(profileMethod) = (GIV(primFailCode)
					? GIV(nilObj)
					: aPrimitiveMethod);
		forceInterruptCheck();

		/* begin zeroNextProfileTick */
		GIV(nextProfileTick) = 0;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

	/* StackInterpreter>>#checkStackIntegrity */
static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt ok;
    sqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	callerFP = ((char *) 0);
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & 1) == 0)
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if (byteAt((theFP + FoxFrameFlags) + 2)) {
					oop = longAt(theFP + FoxThisContext);
					if (((oop & 1))
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!(/* isContext: */
							((oop & 1) == 0)
						 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((/* isContext: */
							((oop & 1) == 0)
						 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
						 && (((longAt((oop + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((/* isContext: */
							((oop & 1) == 0)
						 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
						 && ((((longAt((oop + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
						 && ((frameOfMarriedContext(oop)) == theFP)))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext);
						ok = 0;
					}
				}
				oop = longAt(theFP + FoxMethod);
				if (((oop & 1))
				 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame mthd", theFP, theFP + FoxMethod);
					ok = 0;
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 1) == 0)
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}


/*	Version of stackPointerForMaybeMarriedContext: with no side-effects (does
	not widow).
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the stackPointer of a Context. */

	/* StackInterpreter>>#checkStackPointerForMaybeMarriedContext: */
static NoDbgRegParms sqInt
checkStackPointerForMaybeMarriedContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodPointer;
    sqInt sp;
    sqInt spSqInt;

	if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
		sp = checkStackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
		return sp;
	}
	if (((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		methodPointer = longAt((aContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));

		/* begin argumentCountOf: */
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(methodPointer));
		header = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* begin argumentCountOfMethodHeader: */
		return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
	}
	spSqInt = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((spSqInt & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(aContext)));
	return (spSqInt >> 1);
}


/*	Version of stackPointerIndexForFrame: that does not depend on writing back
	head frame pointers.
	Used for assertion checking. Safe only in external primitives
	(framePointer valid).
	Answer the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#checkStackPointerIndexForFrame: */
static NoDbgRegParms sqInt
checkStackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (theFP == GIV(framePointer)) {
		return (((usqInt)(((theFP + FoxReceiver) - GIV(stackPointer)))) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
	}

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	startFrame = (thePage == GIV(stackPage)
				? GIV(framePointer)
				: (thePage->headFP));

	/* begin findSPOrNilOf:on:startingFrom: */
	prevFrame = ((char *) 0);
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
					? (thePage->headSP)
					: ((thePage->headSP)) + BytesPerWord);
		goto l1;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((prevFrame + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
			goto l1;
		}
	}
	theSP = null;
l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (!theSP) {
		return -1;
	}
	return (((usqInt)(((theFP + FoxReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	Check if aClass's name is className */

	/* StackInterpreter>>#classNameOf:Is: */
static NoDbgRegParms sqInt
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((numSlotsOf(aClass)) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + BaseHeaderSize) + ((((usqInt)(GIV(classNameIndex)) << (shiftForWord())))));
	if (!(/* isBytes: */
			((name & 1) == 0)
		 && (((((usqInt)((longAt(name)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		return 0;
	}
	length = numBytesOfBytes(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i < length; i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}


/*	For asserts. Check that theIP maps back correctly to the context's pc.
	The CallPrimitive bytecode presents a complication. */

	/* StackInterpreter>>#context:hasValidInversePCMappingOf:in: */
static NoDbgRegParms sqInt
contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP)
{
    sqInt encodedip;
    sqInt pc;

	pc = longAt((aContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));

	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP + 1, theFP));
	encodedip = (((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
	return pc == encodedip;
}


/*	for Cogit */

	/* StackInterpreter>>#copiedValueCountOfClosure: */
int
copiedValueCountOfClosure(sqInt closureObj)
{
	/* begin copiedValueCountOfVanillaClosure: */
	assert(isVanillaBlockClosure(closureObj));
	return (numSlotsOf(closureObj)) - ClosureFirstCopiedValueIndex;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

	/* StackInterpreter>>#copyBits */
sqInt
copyBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (!fn) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#copyBitsFrom:to:at: */
sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (!fn) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}

	/* StackInterpreter>>#couldBeProcess: */
static NoDbgRegParms NeverInline sqInt
couldBeProcess(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (/* addressCouldBeObj: */
		((oop & 3) == 0)
	 && (((((usqInt)oop)) >= (startOfMemory()))
	 && (((((usqInt)oop)) < GIV(freeStart))
	 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))
	 && ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
	 && ((!(/* isContext: */
		((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)))
	 && (((lengthOf(oop)) > MyListIndex)
	 && (isContext(longAt((oop + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord()))))))))));
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

	/* StackInterpreter>>#createActualMessageTo: */
static NoDbgRegParms void
createActualMessageTo(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    int i;
    sqInt message;
    char *sp;


	/* This is a useful break-point */
	assert((isImmediate(GIV(messageSelector)))
	 || (addressCouldBeObj(GIV(messageSelector))));

	/* begin mnuBreakpoint:receiver: */
	mnuBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), null);
	argumentArray = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), GIV(argumentCount));
	message = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassMessage) << (shiftForWord()))))), MessageLookupClassIndex + 1);
	for (i = ((GIV(argumentCount) - 1) * BytesPerOop); i >= 0; i += (-BytesPerOop)) {
		longAtput((argumentArray + BaseHeaderSize) + i, popStack());
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((message + BaseHeaderSize) + ((((usqInt)(MessageSelectorIndex) << (shiftForWord())))), GIV(messageSelector));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((message + BaseHeaderSize) + ((((usqInt)(MessageArgumentsIndex) << (shiftForWord())))), argumentArray);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((message + BaseHeaderSize) + ((((usqInt)(MessageLookupClassIndex) << (shiftForWord())))), lookupClass);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}


/*	Return the default number of stack pages allocate at startup.
	This V3 default suits Qwaq Forums (specifically general rendering).
	The Spur default reflects tuning for GC performance ast Cadence.
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

	/* StackInterpreter>>#defaultNumStackPages */
static sqInt
defaultNumStackPages(void)
{
	return 160;
}

	/* StackInterpreter>>#disableSendPrinting */
#if SEND_PRINTING
void
disableSendPrinting(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(printSends) = 0;
}
#endif /* SEND_PRINTING */


/*	Release the VM to other threads and answer the current thread's index.
	Currently valid flags for the non-threaded VM are:
	DisownVMForThreading	- allow the VM to thread-switch; this is ignored
	DisownVMForFFICall		- informs the VM that it is entering an FFI call
	
	This is the entry-point for plugins and primitives that wish to release
	the VM while
	performing some operation that may potentially block, and for callbacks
	returning back to some blocking operation. While this exists for the
	threaded FFI VM we use
	it to reset newMethod and the argumentCount after a callback. */

	/* StackInterpreter>>#disownVM: */
void *
disownVM(sqInt flags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;
    void *vmHandle;

	assert(GIV(primFailCode) == 0);
	assert(flags != 0);

	/* We are either in disowning after a callback (see thunkEntry) or before an FFI
	   callout. */
	vmHandle = ((void *) flags);
	assert((flags == DisownVMFromCallback)
	 || ((flags == (flags & (DisownVMForFFICall + DisownVMForThreading)))
	 && (((flags & DisownVMForFFICall) != 0))));
	if (((flags & DisownVMForFFICall) != 0)) {
		assert((isOopCompiledMethod(GIV(newMethod)))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
		return (GIV(ffiCalloutVMHandle) = vmHandle);
	}
	if (((flags & DisownVMFromCallback) != 0)) {
		GIV(argumentCount) = ((popStack()) >> 1);
		assert(((GIV(argumentCount) >= 0) && (GIV(argumentCount) <= (argumentCountOfMethodHeader(-1)))));

		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		assert((isOopCompiledMethod(GIV(newMethod)))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
		return null;
	}
	return vmHandle;
}

	/* StackInterpreter>>#divorceAllFrames */
static sqInt
divorceAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;

	if (GIV(stackPage)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}

	/* begin ensureFrameIsMarried:SP: */
	if (byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
l1:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			divorceFramesIn(aPage);
		}
	}

	/* begin nilStackPage */
	assert((!GIV(stackPage))
	 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
	GIV(stackPage) = null;
	return activeContext;
}

	/* StackInterpreter>>#divorceFramesIn: */
static NoDbgRegParms void
divorceFramesIn(StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    char *theSP;

	calleeFP = ((char *) 0);
	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);

	/* theSP points at hottest item on frame's stack */
	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		if (byteAt((theFP + FoxFrameFlags) + 2)) {
			assert(isContext(frameContext(theFP)));
			theContext = longAt(theFP + FoxThisContext);
			goto l1;
		}
		theContext = marryFrameSP(theFP, theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput(
			(theContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))),
			(/* begin contextInstructionPointer:frame: */
				assert(validInstructionPointerinFrame(theIP + 1, theFP)),
			(((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1)));
		assert((frameReceiver(theFP)) == (followFieldofObject(ReceiverIndex, theContext)));
		if (calleeContext) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(calleeContext, GIV(youngStart))) {
				possibleRootStoreIntovalue(calleeContext, theContext);
			}
			longAtput((calleeContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;

		/* theSP points at stacked hottest item on frame's stack */
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((calleeFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
	}

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(theContext, GIV(youngStart))) {
		possibleRootStoreIntovalue(theContext, longAt(calleeFP + FoxCallerContext));
	}
	longAtput((theContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), longAt(calleeFP + FoxCallerContext));
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

	/* StackInterpreter>>#doPrimitiveDiv:by: */
static NoDbgRegParms sqInt
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    int posArg;
    int posRcvr;
    sqInt result;

	integerArg = 0;
	integerRcvr = 0;
	if ((rcvr & arg) & 1) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);

		/* begin success: */
		if (!integerArg) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */
			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */
			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}

	/* begin success: */
	if (!((((sqInt)((((usqInt)result)) ^ (((((usqInt)result)) << 1))))) >= 0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return result;
}

	/* StackInterpreter>>#doPrimitiveMod:by: */
static NoDbgRegParms sqInt
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;

	integerArg = 0;
	integerRcvr = 0;
	if ((rcvr & arg) & 1) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);

		/* begin success: */
		if (!integerArg) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */
	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}

	/* begin success: */
	if (!((((sqInt)((((usqInt)integerResult)) ^ (((((usqInt)integerResult)) << 1))))) >= 0)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

	/* StackInterpreter>>#doSignalSemaphoreWithIndex: */
sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt sema;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	assert(isArray(xArray));

	/* Note: semaphore indices are 1-based */
	sema = longAt((xArray + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord())))));
	assert(!(isOopForwarded(sema)));
	return (/* isSemaphoreOop: */
		((sema & 1) == 0)
	 && ((/* fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(sema)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(sema - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord()))))))))
	 && (synchronousSignal(sema));
}


/*	Presumably this exists to squash C compiler warnings about unused
	variables... 
 */

	/* StackInterpreter>>#dummyReferToProxy */
struct VirtualMachine * *
dummyReferToProxy(void)
{
	return (&interpreterProxy);
}


/*	Dump the entire image out to the given file. Intended for debugging only.
	Doesn't work for Spur. */

	/* StackInterpreter>>#dumpImage: */
sqInt
dumpImage(sqInt fileName)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqImageFile f;
    sqInt result;

	f = sqImageFileOpen(pointerForOop(fileName), "wb");
	if (invalidSqImageFile(f)) {
		return -1;
	}
	else {
		result = sqImageFileWrite(pointerForOop(startOfMemory()), sizeof(unsigned char), GIV(endOfMemory) - (startOfMemory()), f);
		sqImageFileClose(f);
		return result;
	}
}


/*	The prim trace log is a circular buffer of entries. If there is
	an entry at primTraceLogIndex \\ PrimTraceLogSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* StackInterpreter>>#dumpPrimTraceLog */
void
dumpPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasParameter;
    sqInt i;
    sqInt remainder;

	if (!(GIV(primTraceLog)[/* safe:mod: */
				(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
					? remainder + PrimTraceLogSize
					: remainder)])) {
		return;
	}
	hasParameter = 0;
	if (GIV(primTraceLog)[GIV(primTraceLogIndex)]) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			hasParameter = printPrimLogEntryAthasParameter(i, hasParameter);
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		hasParameter = printPrimLogEntryAthasParameter(i, hasParameter);
	}
}


/*	Print the prim trace log on a specific output stream. */
/*	essential for writing crash.dmp; use export: not api, so it will be
	accessible on win32 and won't be written to cointerp.h
 */

	/* StackInterpreter>>#dumpPrimTraceLogOn: */
void
dumpPrimTraceLogOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;

	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream
				? aStdioStream
				: stdout);
	dumpPrimTraceLog();
	GIV(transcript) = savedTranscript;
}


/*	For marking the end of a leak check print message */

	/* StackInterpreter>>#eekcr */
NeverInline void
eekcr(void)
{
	printf("\n");
}

	/* StackInterpreter>>#enableSendPrinting */
#if SEND_PRINTING
void
enableSendPrinting(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(printSends) = 1;
}
#endif /* SEND_PRINTING */


/*	Answer the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

	/* StackInterpreter>>#ensureCallerContext: */
static NoDbgRegParms sqInt
ensureCallerContext(char *theFP)
{
    char *callerFP;

	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (!callerFP) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		return longAt(theFP + FoxCallerContext);
	}

	/* begin ensureFrameIsMarried:SP: */
	if (byteAt((callerFP + FoxFrameFlags) + 2)) {
		assert(isContext(frameContext(callerFP)));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(
		callerFP,
		(/* begin frameCallerStackPointer: */
			assert(!(isBaseFrame(theFP))),
		(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord));
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static NoDbgRegParms void
ensureImageFormatIsUpToDate(sqInt swapBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    usqInt fmt;
    sqInt header;
    sqInt methodHeader;
    sqInt oop;
    sqInt oopSqInt;
    sqInt startAddr;
    sqInt stopAddr;
    int swapFloatWords;
    unsigned int sz;
    sqInt temp;
    int tempInt;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		/* begin reverseBytesInMemory */
		startAddr = startOfMemory();
		addr = startAddr;
		while (oopisLessThan(addr, GIV(freeStart))) {
			longAtput(addr, 
#      if BytesPerWord == 4
				SQ_SWAP_4_BYTES((longAt(addr)))
#      else
				SQ_SWAP_8_BYTES((longAt(addr)))
#      endif
				);
			addr += BytesPerWord;
		}

		/* begin updateObjectsPostByteSwap */
		swapFloatWords = (/* vmEndianness */
				(VMBIGENDIAN
					? 1
					: 0)) != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);

		/* begin allObjectsDo: */
		oopSqInt = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
		while ((((usqInt)oopSqInt)) < GIV(freeStart)) {
			if (!(((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree)) {
				fmt = (((usqInt)((longAt(oopSqInt)))) >> (instFormatFieldLSB())) & 15;
				if (fmt >= (firstByteFormat())) {

					/* oop contains bytes */
					wordAddr = oopSqInt + BaseHeaderSize;
					if (fmt >= (firstCompiledMethodFormat())) {

						/* compiled method; start after methodHeader and literals */
						methodHeader = longAt(oopSqInt + BaseHeaderSize);
						wordAddr += (((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop;
					}
					stopAddr = oopSqInt + (sizeBitsOf(oopSqInt));

					/* begin reverseBytesFrom:to: */
					addr = wordAddr;
					while (oopisLessThan(addr, stopAddr)) {
						longAtput(addr, 
#            if BytesPerWord == 4
							SQ_SWAP_4_BYTES((longAt(addr)))
#            else
							SQ_SWAP_8_BYTES((longAt(addr)))
#            endif
							);
						addr += BytesPerWord;
					}
				}
				if (fmt == (firstLongFormat())) {

					/* Bitmap, Float etc */
					if (swapFloatWords
					 && (((((usqInt)((longAt(oopSqInt)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex)) {
						temp = longAt(oopSqInt + BaseHeaderSize);
						longAtput(oopSqInt + BaseHeaderSize, longAt((oopSqInt + BaseHeaderSize) + 4));
						longAtput((oopSqInt + BaseHeaderSize) + 4, temp);
					}
					else {
					}
				}
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oopSqInt, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oopSqInt)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(oopSqInt);
				sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oopSqInt - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oopSqInt = (oopSqInt + sz) + (headerTypeBytes[(longAt(oopSqInt + sz)) & TypeMask]);
		}
	}
	else {
		/* begin convertFloatsToPlatformOrder */
		if ((/* vmEndianness */
			(VMBIGENDIAN
				? 1
				: 0)) == GIV(imageFloatsBigEndian)) {
			goto l1;
		}
		assert(ClassFloatCompactIndex != 0);

		/* begin allObjectsDo: */
		oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
		while ((((usqInt)oop)) < GIV(freeStart)) {
			if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
				if (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassFloatCompactIndex) {
					tempInt = long32At(oop + BaseHeaderSize);
					long32Atput(oop + BaseHeaderSize, long32At((oop + BaseHeaderSize) + 4));
					long32Atput((oop + BaseHeaderSize) + 4, tempInt);
				}
			}

			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				header = longAt(oop);
				sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
		}
l1:	/* end convertFloatsToPlatformOrder */;
	}
}


/*	Main entry-point into the interpreter at each execution level, where an
	execution level is either the start of execution or reentry for a
	callback. This is the actual implementation, separated from
	enterSmalltalkExecutive so the
	simulator can wrap it in an exception handler and hence simulate the
	setjmp/longjmp.  */
/*	Setjmp for reentry into interpreter from elsewhere, e.g. FFI exception
	primitive failure.
 */

	/* StackInterpreter>>#enterSmalltalkExecutiveImplementation */
static sqInt
enterSmalltalkExecutiveImplementation(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	_setjmp(GIV(reenterInterpreter));
	interpret();
	return 0;
}


/*	Execute newMethod - either primitiveFunctionPointer must be set directly
	(i.e. from primitiveExecuteMethod et al), or it would have been set
	probing the method cache (i.e. primitivePerform et al). */

	/* StackInterpreter>>#executeNewMethod */
static sqInt
executeNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt i;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt rcvr;
    char *sp;

	if (primitiveFunctionPointer) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			return null;
		}
		if (slowPrimitiveResponse()) {
			return null;
		}
	}

	/* begin activateNewMethod */
	/* begin justActivateNewMethod: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
				: ((1 + ((numArgs << 8)))));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode)) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
	return 0;
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */
/*	stackPage needs to have current head pointers to avoid confusion. */

	/* StackInterpreter>>#externalDivorceFrame:andContext: */
static NoDbgRegParms void
externalDivorceFrameandContext(char *theFP, sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    StackPage *newPage;
    int onCurrent;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;

	assert((!GIV(stackPage))
	 || (GIV(stackPage) == (GIV(mostRecentlyUsedPage))));

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	theSP = findSPOfon(theFP, thePage);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP);

	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (!callerFP1) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		callerCtx = longAt(theFP + FoxCallerContext);
		goto l2;
	}

	/* begin ensureFrameIsMarried:SP: */
	if (byteAt((callerFP1 + FoxFrameFlags) + 2)) {
		assert(isContext(frameContext(callerFP1)));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l2;
	}
	callerCtx = marryFrameSP(
			callerFP1,
			(/* begin frameCallerStackPointer: */
				assert(!(isBaseFrame(theFP))),
			(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord));
l2:	/* end ensureCallerContext: */;
	if ((frameAbove = findFrameAboveinPage(theFP, thePage))) {

		/* othewise move all frames above to a new stack and then peel the frame off. */
		/* begin newStackPage */
		newPage = (GIV(mostRecentlyUsedPage)->nextPage);
		if (!((newPage->baseFP))) {
			goto l1;
		}
		divorceFramesIn(newPage);
l1:	/* end newStackPage */;
		theIP = oopForPointer(pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			assert(newPage);
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage);

			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (newPage->headSP);
			GIV(framePointer) = (newPage->headFP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage);
		}
		assert((frameCallerContext(frameAbove)) == ctxt);
	}
	else {

		/* If we're divorcing the top frame we can simply peel it off. */
		theIP = longAt((thePage->headSP));
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(
		(ctxt + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))),
		(/* begin contextInstructionPointer:frame: */
			assert(validInstructionPointerinFrame(theIP + 1, theFP)),
		(((usqInt)(((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1)));

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(ctxt, GIV(youngStart))) {
		possibleRootStoreIntovalue(ctxt, callerCtx);
	}
	longAtput((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), callerCtx);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP) {
		callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
		callerSP = ((/* begin frameCallerSP: */
	assert(!(isBaseFrame(theFP))),
(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord)) - BytesPerWord;
		longAtput(callerSP, callerIP);

		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
	else {

		/* theFP is a base frame; it is now alone; free the entire page */
		freeStackPage(thePage);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

	/* StackInterpreter>>#externalEnsureIsBaseFrame: */
static NoDbgRegParms char *
externalEnsureIsBaseFrame(char *aFramePtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int onCurrent;
    char *theFP;
    StackPage *thePage;

	if (!(longAt(aFramePtr + FoxSavedFP))) {
		return aFramePtr;
	}
	theFP = aFramePtr;

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));

	/* Storing the frame's sender with its caller's context
	   has the side effect of making theFP a base frame. */
	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP));
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);

		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	return theFP;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state. */

	/* StackInterpreter>>#externalInstVar:ofContext: */
static NoDbgRegParms sqInt
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isContext(aContext));
	assert(offset <= (ReceiverIndex + (checkStackPointerForMaybeMarriedContext(aContext))));
	if (offset <= StackPointerIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		if (/* isStillMarriedContext: */
			(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContext)))) {
			return fetchPointerofMarriedContext(offset, aContext);
		}
	}
	return longAt((aContext + BaseHeaderSize) + ((((usqInt)(offset) << (shiftForWord())))));
}

	/* StackInterpreter>>#externalInstVar:ofContext:put: */
static NoDbgRegParms sqInt
externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int onCurrentPage;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	assert(isContext(maybeMarriedContext));

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(!((isObjImmutable(maybeMarriedContext))));
	if (!(/* isStillMarriedContext: */
			(((longAt((maybeMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(maybeMarriedContext))))) {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(maybeMarriedContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))), anOop);
		return null;
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((maybeMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	onCurrentPage = thePage == GIV(stackPage);
	if (index) {
		externalDivorceFrameandContext(theFP, maybeMarriedContext);

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(maybeMarriedContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(maybeMarriedContext, anOop);
		}
		longAtput((maybeMarriedContext + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))), anOop);
	}
	else {
		storeSenderOfFramewithValue(theFP, anOop);
	}
	if (onCurrentPage) {
		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (GIV(stackPage)->headSP);
		GIV(framePointer) = (GIV(stackPage)->headFP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(pageListIsWellFormed());
	assert(validStackPageBaseFrames());
	return 0;
}


/*	Invoke a quick primitive.
	Called under the assumption that primFunctionPtr has been preloaded */

	/* StackInterpreter>>#externalQuickPrimitiveResponse */
static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 0xFF)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		oop = longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + ((((usqInt)((localPrimIndex - 264)) << (shiftForWord())))));

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 0x100) {
		return 1;
	}
	if (localPrimIndex == 0x101) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer)), GIV(nilObj));
		GIV(stackPointer) = sp;
		return 1;
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)(localPrimIndex - 261) << 1) | 1));
	GIV(stackPointer) = sp;
	return 1;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchArray:ofObject: */
void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));

	/* begin arrayValueOf: */
	if (/* isWordsOrBytes: */
		((arrayOop & 1) == 0)
	 && (isWordsOrBytesNonImm(arrayOop))) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchFloat:ofObject: */
double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt floatOop;
    sqInt isFloat;
    double result;

	floatOop = longAt((objectPointer + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((floatOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((floatOop & 1)));
	ccIndex = (((usqInt)((longAt(floatOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(floatOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(floatOop + BaseHeaderSize, result);
		return result;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#fetchInteger:ofObject: */
sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	intOop = longAt((objectPointer + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));

	/* begin checkedIntegerValueOf: */
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Fetch a slot from a married context. Compute the value
	of the relevant inst var from the spouse frame's state.
	
	This method assumes frame pointers have been written back. */

	/* StackInterpreter>>#fetchPointer:ofMarriedContext: */
static NoDbgRegParms sqInt
fetchPointerofMarriedContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    usqInt frameNumArgs;
    sqInt senderOop;
    char *spouseFP;

	assert(isContext(aContext));
	assert((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer)));
	assert(checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer)));
	if (offset <= ReceiverIndex) {
		if (!(offset <= StackPointerIndex)) {
			return longAt((aContext + BaseHeaderSize) + ((((usqInt)(offset) << (shiftForWord())))));
		}

		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
		if (!offset) {
			/* begin ensureCallerContext: */
			callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
			if (!callerFP) {

				/* base frame, context in saved ip slot (or base of stack in Cog) */
				return longAt(spouseFP + FoxCallerContext);
			}

			/* begin ensureFrameIsMarried:SP: */
			if (byteAt((callerFP + FoxFrameFlags) + 2)) {
				assert(isContext(frameContext(callerFP)));
				return longAt(callerFP + FoxThisContext);
			}
			return marryFrameSP(
				callerFP,
				(/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(spouseFP))),
				(spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((spouseFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord));
		}
		if (offset == StackPointerIndex) {
			return (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
		}
		if (offset == InstructionPointerIndex) {
			return instructionPointerForFramecurrentFPcurrentIP(spouseFP, GIV(framePointer), GIV(instructionPointer));
		}
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
	return ((((offset - ReceiverIndex) >= 1) && ((offset - ReceiverIndex) <= (stackPointerIndexForFrame(spouseFP))))
			? /* temporary:in: */
				((offset - (ReceiverIndex + 1)) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
					? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord))
					: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (offset - (ReceiverIndex + 1))) * BytesPerWord)))
			: GIV(nilObj));
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static NoDbgRegParms sqInt
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((sp & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
	return (sp >> 1);
}


/*	Answer if file times, including those from the FilePlugin and
	FileAttributesPlugin, should be answered in UTC seconds from the epoch
	rather than local seconds. */

	/* StackInterpreter>>#fileTimesInUTC */
int
fileTimesInUTC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(imageHeaderFlags) & 0x200) != 0);
}

	/* StackInterpreter>>#findClassContainingMethod:startingAt: */
static NoDbgRegParms sqInt
findClassContainingMethodstartingAt(sqInt meth, sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    int classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methodArray;
    unsigned int sz;

	currClass = classObj;
	do {
		assert(!(isForwarded(currClass)));
		if (!(addressCouldBeClassObj(currClass))) {
			return GIV(nilObj);
		}
		classDict = longAt((currClass + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		assert(!(isForwarded(classDict)));

		/* begin numSlotsOf: */
		header = longAt(classDict);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(classDict - (BytesPerWord * 2))) & AllButTypeMask);
		classDictSize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		if (classDictSize > MethodArrayIndex) {
			methodArray = longAt((classDict + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
			assert(!(isForwarded(methodArray)));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (meth == (longAt((methodArray + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
					return currClass;
				}
				i += 1;
			}
		}
		currClass = longAt((currClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}

	/* StackInterpreter>>#findClassOfMethod:forReceiver: */
sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt rclass;

	if (/* addressCouldBeOop: */
		((rcvr & 1))
	 || (/* addressCouldBeObj: */
		((rcvr & 3) == 0)
	 && (((((usqInt)rcvr)) >= (startOfMemory()))
	 && (((((usqInt)rcvr)) < GIV(freeStart))
	 && (((longAt(rcvr)) & TypeMask) != HeaderTypeGC))))) {
		rclass = findClassContainingMethodstartingAt(meth, /* fetchClassOf: */
				((rcvr & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask)));
		if (rclass != GIV(nilObj)) {
			return rclass;
		}
	}
	if (!((/* addressCouldBeObj: */
			((meth & 3) == 0)
		 && (((((usqInt)meth)) >= (startOfMemory()))
		 && (((((usqInt)meth)) < GIV(freeStart))
		 && (((longAt(meth)) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt)((longAt(meth)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return GIV(nilObj);
	}
	return findClassContainingMethodstartingAt(meth, safeMethodClassOf(meth));
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

	/* StackInterpreter>>#findFrameAbove:inPage: */
static NoDbgRegParms char *
findFrameAboveinPage(char *theFP, StackPage *thePage)
{
    char *callerFP;
    char *fp;

	callerFP = ((char *) 0);
	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

	/* StackInterpreter>>#findHomeForContext: */
static NoDbgRegParms sqInt
findHomeForContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt closureOrNil;

	if (!(/* isContext: */
			((aContext & 1) == 0)
		 && (((((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		return null;
	}
	closureOrNil = longAt((aContext + BaseHeaderSize) + ((((usqInt)(ClosureIndex) << (shiftForWord())))));
	assert((isPointers(closureOrNil))
	 && ((closureOrNil == (nilObject()))
	 || ((numSlotsOf(closureOrNil)) >= ClosureFirstCopiedValueIndex)));
	if (((closureOrNil & 1))
	 || (closureOrNil == GIV(nilObj))) {
		return aContext;
	}
	if ((/* fetchClassOf: */
		((closureOrNil & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(closureOrNil)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(closureOrNil - BaseHeaderSize)) & AllButTypeMask))) != (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassBlockClosure) << (shiftForWord()))))))) {
		if (!((/* fetchClassOf: */
				((closureOrNil & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(closureOrNil)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(closureOrNil - BaseHeaderSize)) & AllButTypeMask))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFullBlockClosure) << (shiftForWord())))))))) {
			return null;
		}
	}
	return findHomeForContext(longAt((closureOrNil + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord()))))));
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */
/*	Being mutually-recursive with findMethodWithPrimitive:FromFP:UpToContext:
	gives the author's type inference algorithm headaches. Wimp out by
	declaring the return type.
 */

	/* StackInterpreter>>#findMethodWithPrimitive:FromContext:UpToContext: */
static NoDbgRegParms sqInt
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderContextSqInt;
    sqInt senderOop;
    char *startFP;
    sqInt theContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    sqInt theMethodSqInt;
    char *theSP;

	assert((senderContext == (nilObject()))
	 || (isContext(senderContext)));
	assert((homeContext == (nilObject()))
	 || (isContext(homeContext)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((longAt((theContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((longAt((theContext + BaseHeaderSize) + ((((usqInt)(ClosureIndex) << (shiftForWord())))))) != GIV(nilObj)))) {
			theMethod = longAt((theContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
			if ((primitiveIndexOf(theMethod)) == primitive) {
				return theContext;
			}
		}
		theContext = longAt((theContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	if (isWidowedContext(theContext)) {
		return GIV(nilObj);
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((theContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	startFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin findMethodWithPrimitive:FromFP:UpToContext: */
	theFP = startFP;
	theFPAbove = startFP;
	do {
		if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!((primitive == 0)
			 || ((byteAt((theFP + FoxFrameFlags) + 3)) != 0))) {
			theMethodSqInt = longAt(theFP + FoxMethod);
			if ((primitiveIndexOf(theMethodSqInt)) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
				}

				/* begin ensureFrameIsMarried:SP: */
				if (byteAt((theFP + FoxFrameFlags) + 2)) {
					assert(isContext(frameContext(theFP)));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP);
			}
		}
		theFPAbove = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	senderContextSqInt = longAt(theFPAbove + FoxCallerContext);
	if (!(/* isContext: */
			((senderContextSqInt & 1) == 0)
		 && (((((usqInt)((longAt(senderContextSqInt)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContextSqInt, homeContext);
}


/*	Find the compiled method to be run when the current messageSelector is
	looked up in the
	class/classIndex classTagArg, setting the values of newMethod and
	primitiveFunctionPointer. 
 */

	/* StackInterpreter>>#findNewMethodInClassTag: */
static NoDbgRegParms sqInt
findNewMethodInClassTag(sqInt classTagArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;

	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTagArg))) {

		/* entry was not found in the cache; look it up the hard way */
		classTag = classTagArg;
		GIV(lkupClass) = classTag;
		lookupMethodInClass(GIV(lkupClass));
		addNewMethodToCache(GIV(lkupClass));
	}
	return 0;
}

	/* StackInterpreter>>#findSelectorOfMethod: */
sqInt
findSelectorOfMethod(sqInt aMethodOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    int classDictSize;
    sqInt classObj;
    sqInt header;
    sqInt homeMethod;
    sqInt i;
    sqInt methodArray;
    sqInt selector;
    unsigned int sz;

	if (!(/* addressCouldBeObj: */
			((aMethodOop & 3) == 0)
		 && (((((usqInt)aMethodOop)) >= (startOfMemory()))
		 && (((((usqInt)aMethodOop)) < GIV(freeStart))
		 && (((longAt(aMethodOop)) & TypeMask) != HeaderTypeGC))))) {
		return GIV(nilObj);
	}
	if (!(/* isOopCompiledMethod: */
			((aMethodOop & 1) == 0)
		 && (((((usqInt)((longAt(aMethodOop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return GIV(nilObj);
	}
	homeMethod = homeMethodOf(aMethodOop);
	selector = maybeSelectorOfMethod(homeMethod);
	if (selector) {
		return selector;
	}
	classObj = safeMethodClassOf(homeMethod);
	if (addressCouldBeClassObj(classObj)) {
		classDict = longAt((classObj + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));

		/* begin numSlotsOf: */
		header = longAt(classDict);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(classDict - (BytesPerWord * 2))) & AllButTypeMask);
		classDictSize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		if (classDictSize > MethodArrayIndex) {
			methodArray = longAt((classDict + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
			i = 0;
			while (i < (classDictSize - SelectorStart)) {
				if (homeMethod == (longAt((methodArray + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
					return longAt((classDict + BaseHeaderSize) + ((((usqInt)((i + SelectorStart)) << (shiftForWord())))));
				}
				i += 1;
			}
		}
	}
	return GIV(nilObj);
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

	/* StackInterpreter>>#findSPOf:on: */
static NoDbgRegParms char *
findSPOfon(char *theFP, StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *prevFrame;
    char *startFrame;
    char *theSP;

	assert(!((isFree(thePage))));
	startFrame = (thePage->headFP);

	/* begin findSPOrNilOf:on:startingFrom: */
	prevFrame = ((char *) 0);
	if (startFrame == theFP) {
		if (((thePage->headSP)) >= startFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */
			theSP = theFP + FoxReceiver;
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
					? (thePage->headSP)
					: ((thePage->headSP)) + BytesPerWord);
		goto l1;
	}
	aFrame = startFrame;
	while (1) {
		prevFrame = aFrame;
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(prevFrame)));
			theSP = (prevFrame + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((prevFrame + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
			goto l1;
		}
	}
	theSP = null;
l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (theSP) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}

	/* StackInterpreter>>#flush */
void
flush(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fflush(GIV(transcript));
}


/*	methodObj is a CompiledMethod. If it contains an external primitive,
	flush the function address and session ID of the CM. Answer the prim
	index for the benefit of subclass overrides. */

	/* StackInterpreter>>#flushExternalPrimitiveOf: */
static NoDbgRegParms sqInt
flushExternalPrimitiveOf(sqInt methodObj)
{
    sqInt header;
    sqInt lit;
    sqInt primBits;
    sqInt primIdx;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodObj));
	header = longAt((methodObj + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin primitiveIndexOfMethod:header: */
	primBits = (header >> 1);
	primIdx = (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);
	if ((primIdx == PrimNumberExternalCall)
	 && (((/* begin literalCountOfMethodHeader: */
		assert((header & 1)),
	((((int) header)) < 0
				? ((header >> 1)) & AlternateHeaderNumLiteralsMask
				: (((usqInt)(header)) >> 10) & 0xFF))) > 0)) {

		/* If not, something's broken */
		lit = longAt((methodObj + BaseHeaderSize) + (1U << (shiftForWord())));
		if ((/* isArray: */
			((lit & 1) == 0)
		 && (((((usqInt)((longAt(lit)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((numSlotsOf(lit)) == 4)) {

			/* If not, something's broken */
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((lit + BaseHeaderSize) + (2U << (shiftForWord())), ConstZero);

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((lit + BaseHeaderSize) + (3U << (shiftForWord())), ConstZero);
		}
	}
	return primIdx;
}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

	/* StackInterpreter>>#forceInterruptCheck */
sqInt
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;


	/* Do _not_ set stackLimit until the stack system has been initialized.
	   stackLimit is the initialization flag for the stack system. */
	if (!GIV(stackLimit)) {
		return null;
	}
	thePage = GIV(stackPage);
	if ((thePage)
	 && (thePage != 0)) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence();
	if (((iccFunc = interruptCheckChain))) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
	return 0;
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

	/* StackInterpreter>>#forceInterruptCheckFromHeartbeat */
void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
#    if LRPCheck
		if (!GIV(longRunningPrimitiveCheckSemaphore)) {
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			goto l1;
		}
		if (!GIV(longRunningPrimitiveStopUsecs)) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
#    endif // LRPCheck

l1:	/* end checkForLongRunningPrimitive */;
		forceInterruptCheck();
	}
}

	/* StackInterpreter>>#frameCallerContext: */
static NoDbgRegParms sqInt
frameCallerContext(char *theFP)
{
	return longAt(theFP + FoxCallerContext);
}


/*	Answer the SP of the caller provided theFP is not a base frame.
	This points to the hottest item on the caller frame's stack. */

	/* StackInterpreter>>#frameCallerSP: */
static NoDbgRegParms char *
frameCallerSP(char *theFP)
{
	assert(!(isBaseFrame(theFP)));
	return (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
}

	/* StackInterpreter>>#frameContext: */
static NoDbgRegParms sqInt
frameContext(char *theFP)
{
	return longAt(theFP + FoxThisContext);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameHasContext: */
static NoDbgRegParms int
frameHasContext(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 2)) != 0;
}


/*	<Integer> */

	/* StackInterpreter>>#frameIsBlockActivation: */
static NoDbgRegParms int
frameIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 3)) != 0;
}

	/* StackInterpreter>>#frameMethod: */
static NoDbgRegParms sqInt
frameMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	See encodeFrameFieldHasContext:numArgs: */

	/* StackInterpreter>>#frameNumArgs: */
static NoDbgRegParms usqInt
frameNumArgs(char *theFP)
{
	return byteAt((theFP + FoxFrameFlags) + 1);
}

	/* StackInterpreter>>#frameOfMarriedContext: */
static NoDbgRegParms char *
frameOfMarriedContext(sqInt aContext)
{
    sqInt senderOop;

	senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));

	/* begin withoutSmallIntegerTags: */
	assert((senderOop & 1));
	return pointerForOop(senderOop - 1 /* smallIntegerTag */);
}

	/* StackInterpreter>>#framePrintDescription: */
static NoDbgRegParms void
framePrintDescription(sqInt it)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (it) {
		if (it == GIV(nilObj)) {
			fprintf(GIV(transcript), "=nil");
		}
		else {
			fprintf(GIV(transcript),
					"=%" PRIdSQINT "",
					it);
		}
	}
}

	/* StackInterpreter>>#frameReceiver: */
static NoDbgRegParms sqInt
frameReceiver(char *theFP)
{
	return longAt(theFP + FoxReceiver);
}


/*	Free any untraced stack pages. */

	/* StackInterpreter>>#freeUntracedStackPages */
static void
freeUntracedStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((!(isFree(thePage)))
		 && (((thePage->trace)) == StackPageUnreached)) {
			assert(noMarkedContextsOnPage(thePage));
			freeStackPage(thePage);
		}
		assert(((thePage->trace = StackPageTraceInvalid)) != 0);
	}
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

	/* StackInterpreter>>#fullDisplayUpdate */
sqInt
fullDisplayUpdate(void)
{
	updateDisplayLeftTopRightBottom(0, 0, displayWidth, displayHeight);
	ioForceDisplayUpdate();
	return 0;
}


/*	Answer an array of flags indicating various optional features of the Cog
	VM. If the bit is set then...
	Bit 0: supports two bytecode sets (MULTIPLEBYTECODESETS)
	Bit 1: supports immutablity (IMMUTABILITY)
	Bit 2: suffers from a UNIX setitimer signal-based heartbeat
	Bit 3: the VM provides cross-platform bit-identical floating point
	Bit 4: the VM can catch exceptions in FFI calls and answer them as
	primitive failures
	Bit 5: the VM has suspend primitives 568 & 578 which back up a process to
	before the wait if it was waiting on a condition variable */

	/* StackInterpreter>>#getCogVMFeatureFlags */
static sqInt
getCogVMFeatureFlags(void)
{
	return (((usqInt)(((((0 + (
#if IMMUTABILITY
	(IMMUTABILITY
			? 2
			: 0)
#else
	0
#endif
	)) + (
#if ITIMER_HEARTBEAT
	4
#else
	0
#endif
	)) + (
#if BIT_IDENTICAL_FLOATING_POINT
	8
#else
	0
#endif
	)) + ((ioCanCatchFFIExceptions()
		? 16
		: 0))) + 32) << 1) | 1);
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. 
 */

	/* StackInterpreter>>#getCurrentBytecode */
sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return byteAt(GIV(instructionPointer));
}


/*	Answer the errorCode object to supply to a failing primitive method that
	accepts one.
	If there is a primitive error table and the primFailCode is a valid index
	there-in answer
	the corresponding entry in the table, otherwise simply answer the code as
	an integer.
 */

	/* StackInterpreter>>#getErrorObjectFromPrimFailCode */
static sqInt
getErrorObjectFromPrimFailCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt clone;
    sqInt errObj;
    sqInt header;
    sqInt i;
    int numSlots;
    unsigned int sz;
    sqInt table;
    sqInt valuePointer;

	if (GIV(primFailCode) > 0) {
		table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(PrimitiveErrorTableIndex) << (shiftForWord())))));
		if (GIV(primFailCode) <= (numSlotsOf(table))) {
			/* If there's a clonable object in the table at that index,
			   answer a clone of the error object with the second slot set to the value of secondaryErrorCode. */
			errObj = longAt((table + BaseHeaderSize) + ((((usqInt)((GIV(primFailCode) - 1)) << (shiftForWord())))));
			if (((((usqInt)((longAt(errObj)))) >> (instFormatFieldLSB())) & 15) == 1 /* nonIndexablePointerFormat */) {
				/* begin cloneErrorObj: */
				/* begin numSlotsOf: */
				header = longAt(errObj);
				sz = (header & TypeMask
							? header & SizeMask
							: (longAt(errObj - (BytesPerWord * 2))) & AllButTypeMask);
				numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
				clone = eeInstantiateSmallClassnumSlots(/* fetchClassOfNonImm: */
						((ccIndex = (((usqInt)((longAt(errObj)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(errObj - BaseHeaderSize)) & AllButTypeMask), numSlots);
				for (i = 0; i < numSlots; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((clone + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), longAt((errObj + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))));
				}
				if ((numSlots > 2)
				 && (GIV(primFailCode) == PrimErrFFIException)) {
					valuePointer = positive64BitIntegerFor(((usqLong) GIV(secondaryErrorCode)));

					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((clone + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
					valuePointer = positiveMachineIntegerFor(GIV(exceptionPC));

					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((clone + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer);
				}
				else {
					valuePointer = signed64BitIntegerFor(GIV(secondaryErrorCode));

					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((clone + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
				}
				errObj = clone;
			}
			return errObj;
		}
	}
	return (((usqInt)GIV(primFailCode) << 1) | 1);
}

	/* StackInterpreter>>#getFullScreenFlag */
sqInt
getFullScreenFlag(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(fullScreenFlag);
}


/*	Answer the flags that are contained in the 7th long of the image header. */

	/* StackInterpreter>>#getImageHeaderFlags */
static sqInt
getImageHeaderFlags(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((((((GIV(fullScreenFlag) + ((VMBIGENDIAN
		? 0
		: 2))) + ((GIV(preemptionYields)
		? 0
		: 16))) + ((GIV(newFinalization)
		? 64
		: 0))) + ((sendWheelEvents
		? 128
		: 0))) + ((primitiveDoMixedArithmetic
		? 0
		: 0x100))) + ((upscaleDisplayIfHighDPI
		? 0
		: 0x400))) + (((GIV(imageHeaderFlags) | (2003)) - (2003)));
}

	/* StackInterpreter>>#getInterruptKeycode */
sqInt
getInterruptKeycode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptKeycode);
}

	/* StackInterpreter>>#getInterruptPending */
sqInt
getInterruptPending(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptPending);
}

	/* StackInterpreter>>#getNextWakeupUsecs */
usqLong
getNextWakeupUsecs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nextWakeupUsecs);
}

	/* StackInterpreter>>#getSavedWindowSize */
sqInt
getSavedWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedWindowSize);
}


/*	Answer the screen size to write to the snapshot.
	If the actual screen size is zero then write the savedWindowSize instead. */

	/* StackInterpreter>>#getSnapshotScreenSize */
static sqInt
getSnapshotScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt screenSize;

	screenSize = ioScreenSize();
	if (((screenSize & 0xFFFF) == 0)
	 || ((((usqInt)(screenSize)) >> 16) == 0)) {
		screenSize = GIV(savedWindowSize);
	}
	return screenSize;
}


/*	For Alien FFI */

	/* StackInterpreter>>#getStackPointer */
sqInt *
getStackPointer(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((sqInt *) GIV(stackPointer));
}


/*	return the global session ID value */

	/* StackInterpreter>>#getThisSessionID */
sqInt
getThisSessionID(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(globalSessionID);
}

	/* StackInterpreter>>#getTranscript */
FILE *
getTranscript(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(transcript);
}


/*	Check for stack overflow, moving frames to another stack if so.
	This should *only* be sent from checkForStackOverflow. */

	/* StackInterpreter>>#handleStackOverflow */
static NeverInline void
handleStackOverflow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *callerFP1;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    char *theFP;

	callerFP = ((char *) 0);
	assert(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)));

	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	   e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	   back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	   more than one frame.  The idea is to record which page has overflowed, and the first
	   time it overflows move one frame, the second time two frames, and so on.  We move no
	   more frames than would leave the page half occupied. */
	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = (GIV(extraFramesToMoveOnOverflow) += 1);
		while ((((overflowCount -= 1)) >= 0)
		 && ((((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) < overflowLimitAddress)
		 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}

	/* begin ensureCallerContext: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (!callerFP1) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		/* frameCallerContext: */
		goto l2;
	}

	/* begin ensureFrameIsMarried:SP: */
	if (byteAt((callerFP1 + FoxFrameFlags) + 2)) {
		assert(isContext(frameContext(callerFP1)));

		/* frameContext: */
		goto l2;
	}
	marryFrameSP(
		callerFP1,
		(/* begin frameCallerStackPointer: */
			assert(!(isBaseFrame(theFP))),
		(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord));
l2:	/* end ensureCallerContext: */;

	/* begin newStackPage */
	newPage = (GIV(mostRecentlyUsedPage)->nextPage);
	if (!((newPage->baseFP))) {
		goto l1;
	}
	divorceFramesIn(newPage);
l1:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage);

	/* begin setStackPageAndLimit: */
	assert(newPage);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);

	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	assert(!(frameHasContext(GIV(framePointer))));
	assert(validInstructionPointerinMethodframePointer(GIV(instructionPointer) + 1, GIV(method), GIV(framePointer)));
}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for stackOverflow and interrupts anddeal with each
	appropriately. Answer if a context switch occurred. */

	/* StackInterpreter>>#handleStackOverflowOrEventAllowContextSwitch: */
static NoDbgRegParms sqInt
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkForStackOverflow */
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		return 0;
	}
	return checkForEventsMayContextSwitch(mayContextSwitch);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */
	shifted = anUnsignedValue;
	bitNo = 0;
#  if BytesPerWord > 4
	if (!(shifted < (1ULL << 32))) {
		shifted = (shifted) >> 32;
		bitNo += 32;
	}
#  endif

	if (!(shifted < (0x10000))) {
		shifted = (shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (0x100))) {
		shifted = (shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (16))) {
		shifted = (shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (4))) {
		shifted = (shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (2))) {
		shifted = (shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	With the full block implementation a CompiledBlock's method is found along
	the chain through the last literal. See CompiledBlock>>#method. Answer
	the home mehtod, or nilObj if it cannot be found. */

	/* StackInterpreter>>#homeMethodOf: */
sqInt
homeMethodOf(sqInt aMethodOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLiteral;
    sqInt methodChain;

	assert(isOopCompiledMethod(aMethodOop));
	methodChain = aMethodOop;
	while (1) {
		lastLiteral = ultimateLiteralOf(methodChain);
		if (!(/* isOopCompiledMethod: */
				((lastLiteral & 1) == 0)
			 && (((((usqInt)((longAt(lastLiteral)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
			return methodChain;
		}
		if (!(/* isOopCompiledMethod: */
				((lastLiteral & 1) == 0)
			 && (((((usqInt)((longAt(lastLiteral)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
			return GIV(nilObj);
		}
		methodChain = lastLiteral;
	}
	return 0;
}


/*	If thePage is the stackPage and the stackPointer and/or the framePointer
	are pointing within it,
	answer if thePage's heapSP and headFP are equal to the stackPointer and
	framePointer respectively.
 */

	/* StackInterpreter>>#ifCurrentStackPageHasValidHeadPointers: */
static NoDbgRegParms sqInt
ifCurrentStackPageHasValidHeadPointers(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (thePage == GIV(stackPage)) {
		if (/* addressIsInPage: */
			(((thePage->lastAddress)) < GIV(framePointer))
		 && (GIV(framePointer) < ((thePage->baseAddress)))) {
			if (((thePage->headFP)) != GIV(framePointer)) {
				return 0;
			}
		}
		if (/* addressIsInPage: */
			(((thePage->lastAddress)) < GIV(stackPointer))
		 && (GIV(stackPointer) < ((thePage->baseAddress)))) {
			if (((thePage->headSP)) != GIV(stackPointer)) {
				return 0;
			}
		}
	}
	return 1;
}

	/* StackInterpreter>>#iframeMethod: */
static NoDbgRegParms usqInt
iframeMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null.
	This is a noop in the stack VM since the C stack pointers are always
	elsewhere (e.g., in some C function running the interpreter). */

	/* StackInterpreter>>#ifValidWriteBackStack:Pointers:Save:To: */
void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		theClass = longAt((theClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return 0;
}


/*	Initialize the stack pages and then invoke continuation. Use alloca'ed
	memory so that
	when we have a JIT its stack pointer will be on the native stack since
	alloca allocates
	memory on the stack. Certain thread systems use the native stack pointer
	as the
	frame ID so putting the stack anywhere else can confuse the thread system.
	
	This path is for the threaded VM where we may want to allocate the stack
	zone on
	the stack of a thread other than the main VM thread. */

	/* StackInterpreter>>#initStackPagesAndContinueInto:with: */
void
initStackPagesAndContinueIntowith(void (*continuation)(void *), void *argument)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackPageBytes;
    sqInt stackZoneBytes;
    void *theStackMemory;

	/* begin ensureInitializeStackZone */
	if (!GIV(pages)) {
		stackPageBytes = stackPageByteSize();
		stackZoneBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackZoneBytes);
		memset(theStackMemory, 0, stackZoneBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackZoneBytes / BytesPerWord, stackPageBytes / BytesPerWord);
	}
	continuation(argument);
}


/*	Answer the bytecode pc object (i.e. SmallInteger) for an active frame. The
	bytecode pc is derived from the frame's pc. If the frame is the top frame
	on the current stack
	the frame pc is whatever the current instruction pointer is. If the frame
	is the top
	frame on some other stack the frame pc is the value on top of stack.
	Otherwise the
	frame pc is the saved pc of the frame above. Once the frame pc is found it
	must be
	mapped to a bytecode pc. */

	/* StackInterpreter>>#instructionPointerForFrame:currentFP:currentIP: */
static NoDbgRegParms sqInt
instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *fp;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;

	if (spouseFP == currentFP) {
		theIP = oopForPointer(instrPtr);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(spouseFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		callerFP = ((char *) 0);
		fp = (thePage->headFP);
		if (fp == spouseFP) {
			theFPAbove = 0;
			goto l1;
		}
		while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
			if (callerFP == spouseFP) {
				theFPAbove = fp;
				goto l1;
			}
			fp = callerFP;
		}
		error("did not find theFP in stack page");
		theFPAbove = 0;
l1:	/* end findFrameAbove:inPage: */;
		theIP = (theFPAbove
					? oopForPointer(pointerForOop(longAt(theFPAbove + FoxCallerSavedIP)))
					: longAt((thePage->headSP)));
	}

	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP + 1, spouseFP));
	return (((usqInt)(((theIP - (longAt(spouseFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

	/* StackInterpreter>>#interpreterAllocationReserveBytes */
static NeverInline sqInt
interpreterAllocationReserveBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int maxFramesPerPage;
    int maxUsedBytesPerPage;

	maxUsedBytesPerPage = (stackPageFrameBytes()) + (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord);
	maxFramesPerPage = (maxUsedBytesPerPage / BytesPerWord) / FrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

	/* StackInterpreter>>#ioFilename:fromString:ofLength:resolveAliases: */
void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

	/* StackInterpreter>>#isBaseFrame: */
static NoDbgRegParms int
isBaseFrame(char *theFP)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}

	/* StackInterpreter>>#isBooleanObject: */
sqInt
isBooleanObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oop == GIV(trueObj))
	 || (oop == GIV(falseObj));
}

	/* StackInterpreter>>#isEmptyList: */
static NoDbgRegParms int
isEmptyList(sqInt aLinkedList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isForwarded(aLinkedList)));
	return (longAt((aLinkedList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj);
}

	/* StackInterpreter>>#isFloatObject: */
sqInt
isFloatObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassFloatCompactIndex == ccIndex;
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}

	/* StackInterpreter>>#isFrame:onPage: */
static NoDbgRegParms sqInt
isFrameonPage(char *aFrame, StackPage *aPage)
{
    char *prevFP;
    char *theFP;

	assert(!((isFree(aPage))));
	theFP = (aPage->headFP);
	prevFP = theFP - BytesPerWord;
	while (1) {
		if (theFP == aFrame) {
			return 1;
		}
		if (!((theFP > prevFP)
		 && (theFP < ((aPage->baseFP))))) break;
		prevFP = theFP;
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	}
	return 0;
}


/*	Answer true if the oop is kind of Integer (Small or Large). */

	/* StackInterpreter>>#isKindOfInteger: */
sqInt
isKindOfInteger(sqInt oop)
{
	return ((oop & 1))
	 || (/* isLargeIntegerInstance: */
		(isInstanceOfClassLargePositiveInteger(oop))
	 || (isInstanceOfClassLargeNegativeInteger(oop)));
}

	/* StackInterpreter>>#isLargeIntegerObject: */
sqInt
isLargeIntegerObject(sqInt oop)
{
	return /* isLargeIntegerInstance: */
		(isInstanceOfClassLargePositiveInteger(oop))
	 || (isInstanceOfClassLargeNegativeInteger(oop));
}

	/* StackInterpreter>>#isLargeNegativeIntegerObject: */
sqInt
isLargeNegativeIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	/* begin isInstanceOfClassLargeNegativeInteger: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassLargeNegativeIntegerCompactIndex == ccIndex;
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}

	/* StackInterpreter>>#isLargePositiveIntegerObject: */
sqInt
isLargePositiveIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;

	/* begin isInstanceOfClassLargePositiveInteger: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));
	if ((oop & 1)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		return ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
	}
	return ClassLargePositiveIntegerCompactIndex == ccIndex;
	return classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
}


/*	Answer if the argument, which can be any object, is a live context. */

	/* StackInterpreter>>#isLiveContext: */
static NoDbgRegParms sqInt
isLiveContext(sqInt oop)
{
	assert(!((isOopForwarded(oop))));
	if (!(/* isContext: */
			((oop & 1) == 0)
		 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (!((longAt((oop + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		return ((longAt((oop + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1);
	}
	return !(isWidowedContext(oop));
}

	/* StackInterpreter>>#isMarriedOrWidowedContext: */
static NoDbgRegParms int
isMarriedOrWidowedContext(sqInt aContext)
{
	return ((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

	/* StackInterpreter>>#isPrimitiveFunctionPointerAnIndex */
static int
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
int
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 0x100) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
int
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}

	/* StackInterpreter>>#isSingleContext: */
static NoDbgRegParms int
isSingleContext(sqInt aContext)
{
	return ((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1) == 0;
}


/*	Answer if aContext is married or widowed and still married.
	If a context is widowed then turn it into a single dead context. */

	/* StackInterpreter>>#isStillMarriedContext: */
static NoDbgRegParms sqInt
isStillMarriedContext(sqInt aContext)
{
	return (((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContext)));
}


/*	Answer if aClosure is a vanilla BlockClosure as in the first Cog release,
	BlockClosure laid out as 
	'outerContext, startpc, numArgs. FullBlockClosure is laid out as
	outerContext, method, numArgs, receiver.
	So either answer true if we're not supporting FullBlockClosure, or test
	the startpc/method field. */

	/* StackInterpreter>>#isVanillaBlockClosure: */
static NoDbgRegParms sqInt
isVanillaBlockClosure(sqInt aClosure)
{
	assert((isPointers(aClosure))
	 && ((numSlotsOf(aClosure)) >= ClosureFirstCopiedValueIndex));
	return 1;
}


/*	See if the argument is married to a live frame or not. i.e. see if there
	is a matching
	frame whose frameContext field is aOnceMarriedContext, or a forwarder to
	it. If aOnceMarriedContext is not married to a live frame, turn it into a
	bereaved single context.
	This version is for use during scavenging when stack references may be
	forwarded. Following what appear to be references to forwarded objects on
	the stack is dangerous;
	an instruction ponter may be correctly aligned and may point to bytes that
	just happen
	to look like a forwarder. So it is only safe to follow fields that we know
	are frameContext
	fields; hence the stack page is walked to check that aOnceMarriedContext
	is pointing to
	a live frame. This only has to happen during scavenging because after a
	become: all
	frameContext fields have been followed and so there is no need to follow
	forwarders.  */

	/* StackInterpreter>>#isWidowedContextDuringGC: */
static NoDbgRegParms sqInt
isWidowedContextDuringGC(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    char *maybeFrame;
    sqInt maybeFrameCtxt;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    StackPage *thePage;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	maybeFrame = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(maybeFrame, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	if (!((isFree(thePage))
		 || (maybeFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));

		/* begin withoutSmallIntegerTags: */
		assert((anInteger & 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1 /* smallIntegerTag */);
		if (((pointerForOop(longAt(maybeFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((maybeFrame + FoxFrameFlags) + 2)) != 0)) {
			/* On Spur we need to follow the context to check for a match, but since the VM is
			   only speculating about maybeFrame being a frame, and only speculating about
			   maybeContext being a context, we need to be sure before we can safely follow. */
			maybeFrameCtxt = longAt(maybeFrame + FoxThisContext);
			if (maybeFrameCtxt == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}

	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	return 1;
}


/*	Answer if the argument is married to a live frame or not.
	This method is safe for use only when no frameContext fields may be
	forwarded (as maybe the case when scavenging). Post become: all
	frameContext fields are followed, and hence normally no following of
	frameContext fields is necessary. */
/*	i.e. inline into isWidowedContext: */

	/* StackInterpreter>>#isWidowedContextNoConvert: */
static NoDbgRegParms sqInt
isWidowedContextNoConvert(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFrame = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));

		/* begin withoutSmallIntegerTags: */
		assert((anInteger & 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1 /* smallIntegerTag */);
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((theFrame + FoxFrameFlags) + 2)) != 0)) {
			assert(!(((isFrameonPage(theFrame, thePage))
 && (isForwarded(frameContext(theFrame))))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {

				/* It is still married! */
				return 0;
			}
		}
	}
	return 1;
}


/*	Answer if the argument is married to a live frame or not.
	If it is not, turn it into a bereaved single context. This version is safe
	for use
	only when no frameContext fields may be forwarded (as maybe the case
	when scavenging). Post become: all frameContext fields are followed, and
	hence normally no following of frameContext fields is necessary. But
	during a scavenge one must use isWidowedContextDuringGC:. */

	/* StackInterpreter>>#isWidowedContext: */
static NoDbgRegParms sqInt
isWidowedContext(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anInteger;
    sqInt senderOop;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;
    sqInt widowed;

	/* begin isWidowedContextNoConvert: */
	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFrame = pointerForOop(senderOop - 1 /* smallIntegerTag */);

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */
		anInteger = longAt((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));

		/* begin withoutSmallIntegerTags: */
		assert((anInteger & 1));
		shouldBeFrameCallerField = pointerForOop(anInteger - 1 /* smallIntegerTag */);
		if (((pointerForOop(longAt(theFrame + FoxSavedFP))) == shouldBeFrameCallerField)
		 && ((byteAt((theFrame + FoxFrameFlags) + 2)) != 0)) {
			assert(!(((isFrameonPage(theFrame, thePage))
 && (isForwarded(frameContext(theFrame))))));
			if ((longAt(theFrame + FoxThisContext)) == aOnceMarriedContext) {

				/* It is still married! */
				widowed = 0;
				goto l1;
			}
		}
	}
	widowed = 1;
l1:	/* end isWidowedContextNoConvert: */;
	if (!widowed) {
		return 0;
	}

	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((aOnceMarriedContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	return 1;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
int
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oopClass;

	oopClass = /* fetchClassOf: */
			((oop & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return 0;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOf: */
sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oopClass;

	oopClass = /* fetchClassOf: */
			((oop & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		oopClass = longAt((oopClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return 0;
}


/*	Support for external primitives */

	/* StackInterpreter>>#is:MemberOf: */
sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oopClass;

	oopClass = /* fetchClassOf: */
			((oop & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
	return classNameOfIs(oopClass, className);
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static NoDbgRegParms sqInt
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    int numSlots;
    sqInt oop;
    unsigned int sz;

	/* begin numSlotsOf: */
	header = longAt(classOop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(classOop - (BytesPerWord * 2))) & AllButTypeMask);
	numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	oop = longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(classNameIndex)) << (shiftForWord())))));

	/* begin lengthOf: */
	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
			? ((usqInt)((sz - BaseHeaderSize))) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

	/* StackInterpreter>>#loadBitBltFrom: */
sqInt
loadBitBltFrom(sqInt bb)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (!fn) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

	/* StackInterpreter>>#loadInitialContext */
void
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    usqInt ccIndex;
    sqInt oop;

	runLeakCheckerFor(GCModeFull);

	/* begin getClassTagOfLinkedList */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	oop = longAt((oop + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	oop = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
	GIV(classLinkedListClassTag) = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));
	activeContext = longAt((activeProc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aClass;
    int byte;
    usqInt ccIndex;
    char *className;
    sqInt cls;
    sqInt column;
    sqInt fieldOop;
    usqInt fmt;
    sqInt fmtSqInt;
    sqInt header;
    sqInt i;
    sqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt length;
    sqInt n;
    sqInt oopClass;
    sqInt startIP;
    unsigned int sz;

	aClass = 0;
	length = 0;
	if ((oop & 1)) {
		/* begin printImmediateObject:on: */
		assert((oop & 1));
		fprintf(GIV(transcript),
				"%p=%" PRIdSQINT "\n",
				((void *)oop),
				((sqInt)((oop >> 1))));
		return;
	}
	if (!(/* addressCouldBeObj: */
			((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		/* begin printCantBeObject:on: */
		fprintf(GIV(transcript),
				"%p%s\n",
				((void *)oop),
				(oop & (BytesPerWord - 1)
				? " is misaligned"
				: whereIs(oop)));
		return;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((cls = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask))) {
		className = nameOfClasslengthInto(cls, (&length));
		fprintf(GIV(transcript),
				"%p: a(n) %.*s",
				((void *)oop),
				((int) length),
				className);
	}
	else {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
	}
	fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	fprintf(GIV(transcript),
			" format %" PRIxSQINT "",
			fmt);
	if (fmt > 4 /* lastPointerFormat */) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	else {
		if (/* isIndexableFormat: */
			(fmt >= (arrayFormat()))
		 && ((fmt <= (weakArrayFormat()))
		 || (fmt >= (firstLongFormat())))) {
			/* begin lengthOf: */
			header = longAt(oop);
			fmtSqInt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

			/* begin lengthOf:baseHeader:format: */
			if (header & TypeMask) {
				sz = header & SizeMask;
			}
			else {
				sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
			}
			sz -= 0;
			if (fmtSqInt <= 4 /* lastPointerFormat */) {
				len = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
				goto l1;
			}
			len = (fmtSqInt < (firstByteFormat())
						? ((usqInt)((sz - BaseHeaderSize))) >> 2
						: (sz - BaseHeaderSize) - (fmtSqInt & 3));
l1:	/* end lengthOf: */;
			fprintf(GIV(transcript),
					" size %" PRIdSQINT "",
					len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}

	/* begin printHeaderTypeOf:on: */
	switch ((longAt(oop)) & TypeMask) {
	case HeaderTypeFree:
		printf(GIV(transcript), " HeaderTypeFree (4 bytes)");
		break;
	case HeaderTypeShort:
		printf(GIV(transcript), " HeaderTypeShort (4 bytes)");
		break;
	case HeaderTypeClass:
		printf(GIV(transcript), " HeaderTypeClass (8 bytes)");
		break;
	case HeaderTypeSizeAndClass:
		printf(GIV(transcript), " HeaderTypeSizeAndClass (12 bytes)");
		break;
	default:
		error("Case not found and no otherwise clause");
	}

	/* begin print: */
	fprintf(GIV(transcript),
			"%s",
			" hash ");
	printHex((((usqInt)((longAt(oop)))) >> HashBitsOffset) & HashMaskUnshifted);
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		/* begin is:KindOfClass: */
		oopClass = /* fetchClassOf: */
				((oop & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
		while (!(oopClass == GIV(nilObj))) {
			if (oopClass == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord()))))))) {
				fprintf(GIV(transcript),
						" datasize %" PRIdSQINT " %s @ %p\n",
						longAt(oop + BaseHeaderSize),
						((longAt(oop + BaseHeaderSize)) < 0
						? "indirect"
						: (longAt(oop + BaseHeaderSize)
								? "direct"
								: "pointer")),
						startOfAlienData(oop));
				return;
			}
			oopClass = longAt((oopClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
		}

		/* #followObjField:ofObject: #fetchPointer:ofObject: */
		longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));

		/* begin is:KindOfClass: */
		oopClass = /* fetchClassOf: */
				((oop & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(oop - BaseHeaderSize)) & AllButTypeMask));
		while (!(oopClass == GIV(nilObj))) {
			if (oopClass == aClass) {
				printStringDataOfon(oop, GIV(transcript));
				return;
			}
			oopClass = longAt((oopClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	startIP = (fmt >= (firstCompiledMethodFormat())
				? (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) / BytesPerWord
				: numSlotsOf(oop));
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = longAt((oop + BaseHeaderSize) + ((((usqInt)((i - 1)) << (shiftForWord())))));

			/* begin space */
			printChar(' ');
			fprintf(GIV(transcript),
					"%" PRIdSQINT "",
					((sqInt)(i - 1)));
			printChar(' ');
			printHex(fieldOop);

			/* begin space */
			printChar(' ');
			if ((i == 1)
			 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
				/* begin printDecodeMethodHeaderOop: */
				/* begin printOopShort: */
				printOopShortInner(fieldOop);
				fflush(GIV(transcript));
				if (((fieldOop & V3PrimitiveBitsMask) != 0)) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" hasPrim");
				}
				if (fieldOop & LargeContextBit) {
					/* begin print: */
					fprintf(GIV(transcript),
							"%s",
							" largeFrame");
				}

				/* begin print: */
				fprintf(GIV(transcript),
						"%s",
						" nLits ");
				/* begin literalCountOfMethodHeader: */
				assert((fieldOop & 1));
				if ((((int) fieldOop)) < 0) {
					n = ((fieldOop >> 1)) & AlternateHeaderNumLiteralsMask;
				}
				else {
					n = (((usqInt)(fieldOop)) >> 10) & 0xFF;
				}

				/* begin printNum: */
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)n));
				fprintf(GIV(transcript),
						"%s",
						" nArgs ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)((((usqInt)(fieldOop)) >> MethodHeaderArgCountShift) & 15)));
				fprintf(GIV(transcript),
						"%s",
						" nTemps ");
				fprintf(GIV(transcript),
						"%" PRIdSQINT "",
						((sqInt)((((usqInt)(fieldOop)) >> MethodHeaderTempCountShift) & 0x3F)));
			}
			else {
				printOopShortInner(fieldOop);
			}
			cr();
		}
	}
	if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		startIP = (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) + 1;

		/* begin lengthOf: */
		header = longAt(oop);
		fmtSqInt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

		/* begin lengthOf:baseHeader:format: */
		if (header & TypeMask) {
			sz = header & SizeMask;
		}
		else {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmtSqInt <= 4 /* lastPointerFormat */) {
			lastIndex = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l2;
		}
		lastIndex = (fmtSqInt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmtSqInt & 3));
l2:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p ",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = ((int) (byteAt((oop + BaseHeaderSize) + (index - 1))));
			fprintf(GIV(transcript),
					"%02x/%-+3d%c",
					byte,
					byte,
					(column == 8
					? '\n'
					: ' '));
			if (((column += 1)) > 8) {
				column = 1;
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"...");
		}
		if (((column >= 2) && (column <= 7))) {
			cr();
		}
	}
	else {
		if (startIP > lastIndex) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"...");
			cr();
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return LongStoreBytecode;
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and classTag is found in the cache, set the values of
	'newMethod' and
	'primitiveFunctionPointer' and answer true. Otherwise, answer false. */

	/* StackInterpreter>>#lookupInMethodCacheSel:classTag: */
static NoDbgRegParms sqInt
lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    usqInt probe;

	/* begin inlineLookupInMethodCacheSel:classTag: */
	/* shift drops two low-order zeros from addresses */
	hash = selector ^ classTag;

	/* first probe */
	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */
	probe = (((usqInt)(hash)) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt)(hash)) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

	/* StackInterpreter>>#lookupMethodInClass: */
static NoDbgRegParms sqInt
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt header;
    sqInt index;
    int length;
    int mask;
    sqInt methodArray;
    sqInt nextSelector;
    unsigned int sz;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(class));

	/* begin lookupBreakFor: */
	if ((breakSelectorLength <= 0)
	 && (class == breakLookupClassTag)) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {

			/* MethodDict pointer is nil (hopefully due a swapped out stub)
			   -- raise exception #cannotInterpret:. */
			createActualMessageTo(class);
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorCannotInterpret) << (shiftForWord())))));

			/* begin sendBreakpoint:receiver: */
			sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), /* #fetchClassTagOf: #fetchClassOf: */
				((null & 1)
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
					: ((ccIndex = (((usqInt)((longAt(null)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(null - BaseHeaderSize)) & AllButTypeMask)));
			return lookupMethodInClass(longAt((currentClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord()))))));
		}

		/* begin lookupMethodInDictionary: */
		/* begin numSlotsOf: */
		header = longAt(dictionary);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask);
		length = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + ((((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (nextSelector == GIV(messageSelector)) {
					methodArray = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & 1)
		? (GIV(messageSelector) >> 1)
		: (((usqInt)((longAt(GIV(messageSelector))))) >> HashBitsOffset) & HashMaskUnshifted)));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))));
	sendBreakpointclassTag(GIV(messageSelector) + BaseHeaderSize, lengthOf(GIV(messageSelector)), class);
	return lookupMethodInClass(class);
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

	/* StackInterpreter>>#lookupOrdinaryNoMNUEtcInClass: */
static NoDbgRegParms sqInt
lookupOrdinaryNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt header;
    sqInt index;
    int length;
    int mask;
    sqInt methodArray;
    sqInt nextSelector;
    unsigned int sz;
    sqInt wrapAround;

	/* begin lookupBreakFor: */
	if ((breakSelectorLength <= 0)
	 && (class == breakLookupClassTag)) {
		warning("lookup class send break (heartbeat suppressed)");
	}
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {
			GIV(lkupClass) = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
			return SelectorCannotInterpret;
		}

		/* begin lookupMethodInDictionary: */
		/* begin numSlotsOf: */
		header = longAt(dictionary);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask);
		length = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */
		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + BaseHeaderSize) + ((((usqInt)((index + SelectorStart)) << (shiftForWord())))));
				if (nextSelector == GIV(messageSelector)) {
					methodArray = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
					GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((GIV(messageSelector) & 1)
		? (GIV(messageSelector) >> 1)
		: (((usqInt)((longAt(GIV(messageSelector))))) >> HashBitsOffset) & HashMaskUnshifted)));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				GIV(newMethod) = longAt((methodArray + BaseHeaderSize) + ((((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			addNewMethodToCache(class);
			return 0;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Lookup selector in class. Answer the method or nil. This is a debugging
	routine. It does /not/ side-effect lookupClass or newMethod. */

	/* StackInterpreter>>#lookupSelector:inClass: */
sqInt
lookupSelectorinClass(sqInt selector, sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt header;
    usqInt index;
    int length;
    int mask;
    sqInt meth;
    sqInt methodArray;
    sqInt nextSelector;
    unsigned int sz;
    sqInt wrapAround;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));
		if (dictionary == GIV(nilObj)) {
			return null;
		}

		/* begin lookupMethodFor:InDictionary: */
		/* begin numSlotsOf: */
		header = longAt(dictionary);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(dictionary - (BytesPerWord * 2))) & AllButTypeMask);
		length = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		mask = (length - SelectorStart) - 1;

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */
		index = SelectorStart + (mask & (((selector & 1)
		? (selector >> 1)
		: (((usqInt)((longAt(selector)))) >> HashBitsOffset) & HashMaskUnshifted)));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + BaseHeaderSize) + ((index << (shiftForWord()))));
			if (nextSelector == GIV(nilObj)) {
				meth = null;
				goto l1;
			}
			if (nextSelector == selector) {
				methodArray = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
				meth = longAt((methodArray + BaseHeaderSize) + ((((usqInt)((index - SelectorStart)) << (shiftForWord())))));
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					meth = null;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		meth = null;
l1:	/* end lookupMethodFor:InDictionary: */;
		if (meth) {
			return meth;
		}
		currentClass = longAt((currentClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	return null;
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. */

	/* StackInterpreter>>#makeBaseFrameFor: */
static NoDbgRegParms StackPage *
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    sqInt maybeClosure;
    usqInt numArgs;
    sqInt oop;
    StackPage *page;
    char *pointer;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;

	assert(isContext(aContext));
	assert(isSingleContext(aContext));
	assert(goodContextSize(aContext));

	/* begin newStackPage */
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	if (!((page->baseFP))) {
		goto l1;
	}
	divorceFramesIn(page);
l1:	/* end newStackPage */;
	pointer = (page->baseAddress);
	theIP = longAt((aContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	theMethod = longAt((aContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	if (!((theIP & 1))) {
		error("context is not resumable");
	}
	theIP = (theIP >> 1);

	/* If the frame is a closure activation then the closure should be on the stack in
	   the pushed receiver position (closures receive the value[:value:] messages).
	   Otherwise it should be the receiver proper. */
	rcvr = longAt((aContext + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord())))));
	maybeClosure = longAt((aContext + BaseHeaderSize) + ((((usqInt)(ClosureIndex) << (shiftForWord())))));
	if (maybeClosure != GIV(nilObj)) {

		/* begin argumentCountOfClosure: */
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))));
		assert((oop & 1));
		numArgs = (oop >> 1);
		longAtput(pointer, maybeClosure);
	}
	else {
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(theMethod));
		header = longAt((theMethod + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

		/* If this is a synthetic context its IP could be pointing at the CallPrimitive opcode.  If so, skip it. */
		numArgs = (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
		if ((((header & V3PrimitiveBitsMask) != 0))
		 && (theIP == (1 + ((((/* begin literalCountOfMethodHeader: */
	assert((header & 1)),
((((int) header)) < 0
			? ((header >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(header)) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop)))) {
			theIP += 0 /* sizeOfCallPrimitiveBytecode: */;
		}
		longAtput(pointer, rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((aContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), GIV(nilObj));
	}
	longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord()))))));
	longAtput((pointer -= BytesPerWord), 0);
	(page->baseFP = pointer);
	(page->headFP = pointer);
	longAtput((pointer -= BytesPerWord), theMethod);
	longAtput((pointer -= BytesPerWord), /* encodeFrameFieldHasContext:isBlock:numArgs: */
		(VMBIGENDIAN
			? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))) + (1U << ((BytesPerWord * 8) - 16))) + ((maybeClosure != GIV(nilObj)
		? 1U << ((BytesPerWord * 8) - 24)
		: 0))
			: ((1 + ((numArgs << 8))) + (0x10000)) + ((maybeClosure != GIV(nilObj)
		? 0x1000000
		: 0))));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput((pointer -= BytesPerWord), aContext);
	longAtput((pointer -= BytesPerWord), rcvr);

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
	assert((oop & 1));
	stackPtrIndex = (oop >> 1);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}

	/* begin iframeInstructionPointerForIndex:method: */
	assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod)))));
	theIP = ((theMethod + theIP) + BaseHeaderSize) - 2;
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP)));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(
		(aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))),
		(/* begin withSmallIntegerTags: */
			assert(((oopForPointer((page->baseFP))) & (BytesPerWord - 1)) == 0),
		(oopForPointer((page->baseFP))) + 1 /* smallIntegerTag */));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(
		(aContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))),
		(/* begin withSmallIntegerTags: */
			assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0),
		(oopForPointer(0)) + 1 /* smallIntegerTag */));
	assert(((fetchPointerofObject(SenderIndex, aContext)) & 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page));
	return page;
}


/*	Convert married contexts to widowed contexts, and in the CoInterpreter,
	map any machine code pcs to bytecode pcs, and then nil all slots beyond
	top of stack, so that the context can be resumed on any VM. */

	/* StackInterpreter>>#makeContextSnapshotSafe: */
static NoDbgRegParms void
makeContextSnapshotSafe(sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    int toDoLimit;
    sqInt toDoStart;

	assert(isContext(ctxt));
	if (((longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		/* begin markContextAsDead: */
		assert(isContext(ctxt));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((ctxt + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
	}
	toDoStart = (fetchStackPointerOf(ctxt)) + CtxtTempFrameStart;
	toDoLimit = (numSlotsOf(ctxt)) - 1;
	for (i = toDoStart; i <= toDoLimit; i += 1) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((ctxt + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed */

	/* StackInterpreter>>#makePointwithxValue:yValue: */
sqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt pointResult;

	pointResult = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassPoint) << (shiftForWord()))))), YIndex + 1);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + ((((usqInt)(XIndex) << (shiftForWord())))), (((usqInt)xValue << 1) | 1));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((pointResult + BaseHeaderSize) + ((((usqInt)(YIndex) << (shiftForWord())))), (((usqInt)yValue << 1) | 1));
	return pointResult;
}


/*	Map all oops in the interpreter's state to their new values 
	during garbage collection or a become: operation. */
/*	Assume: All traced variables contain valid oops. */

	/* StackInterpreter>>#mapInterpreterOops */
static void
mapInterpreterOops(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt oop;

	mapStackPages();

	/* begin mapTraceLogs */
	mapPrimTraceLog();
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(method) & 1) == 0)
	 && (((longAt(GIV(method))) & MarkBit) != 0)) {
		/* *rel to method */
		GIV(instructionPointer) -= GIV(method);
		GIV(method) = remapObj(GIV(method));
		GIV(instructionPointer) += GIV(method);
	}
	if (/* shouldRemapOop: */
		((GIV(newMethod) & 1) == 0)
	 && (/* isObjectForwarded: */
		((GIV(newMethod) & 1) == 0)
	 && (((longAt(GIV(newMethod))) & MarkBit) != 0))) {

		/* maybe oop due to object-as-method */
		GIV(newMethod) = remapObj(GIV(newMethod));
	}

	/* begin mapProfileState */
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(profileProcess) & 1) == 0)
	 && (((longAt(GIV(profileProcess))) & MarkBit) != 0)) {
		GIV(profileProcess) = remapObj(GIV(profileProcess));
	}
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(profileMethod) & 1) == 0)
	 && (((longAt(GIV(profileMethod))) & MarkBit) != 0)) {
		GIV(profileMethod) = remapObj(GIV(profileMethod));
	}
	if (/* #shouldRemapObj: #isObjectForwarded: */
		((GIV(profileSemaphore) & 1) == 0)
	 && (((longAt(GIV(profileSemaphore))) & MarkBit) != 0)) {
		GIV(profileSemaphore) = remapObj(GIV(profileSemaphore));
	}
#  if LRPCheck

	/* The longRunningPrimitiveCheckMethod (LRPCM) is sampled in an interrupt.  Be very careful with it.
	   If longRunningPrimitiveCheckSequenceNumber (LRPCSN) = statCheckForEvents then LRPCM has
	   been recenty sampled and could be mapped or not, but it must be newMethod and we can simply
	   copy newMethod.  If LRPCSN ~= statCheckForEvents then LRPCM must be some extant object and
	   needs to be remapped. */
	sqLowLevelMFence();
	if (GIV(longRunningPrimitiveCheckMethod)) {
		if (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)) {
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
		}
		else {
			if (/* #shouldRemapObj: #isObjectForwarded: */
				((GIV(longRunningPrimitiveCheckMethod) & 1) == 0)
			 && (((longAt(GIV(longRunningPrimitiveCheckMethod))) & MarkBit) != 0)) {
				GIV(longRunningPrimitiveCheckMethod) = remapObj(GIV(longRunningPrimitiveCheckMethod));
			}
		}
		sqLowLevelMFence();
	}
	if (GIV(longRunningPrimitiveCheckSemaphore)) {
		if (/* #shouldRemapObj: #isObjectForwarded: */
			((GIV(longRunningPrimitiveCheckSemaphore) & 1) == 0)
		 && (((longAt(GIV(longRunningPrimitiveCheckSemaphore))) & MarkBit) != 0)) {
			GIV(longRunningPrimitiveCheckSemaphore) = remapObj(GIV(longRunningPrimitiveCheckSemaphore));
		}
	}
#  endif // LRPCheck

	if ((GIV(tempOop) != 0)
	 && (/* shouldRemapOop: */
		((GIV(tempOop) & 1) == 0)
	 && (/* isObjectForwarded: */
		((GIV(tempOop) & 1) == 0)
	 && (((longAt(GIV(tempOop))) & MarkBit) != 0)))) {
		GIV(tempOop) = remapObj(GIV(tempOop));
	}
	if ((GIV(tempOop2) != 0)
	 && (/* shouldRemapOop: */
		((GIV(tempOop2) & 1) == 0)
	 && (/* isObjectForwarded: */
		((GIV(tempOop2) & 1) == 0)
	 && (((longAt(GIV(tempOop2))) & MarkBit) != 0)))) {
		GIV(tempOop2) = remapObj(GIV(tempOop2));
	}

	/* begin getClassTagOfLinkedList */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	oop = longAt((oop + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	oop = longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())));
	GIV(classLinkedListClassTag) = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
}


/*	The prim trace log is a circular buffer of objects. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* StackInterpreter>>#mapPrimTraceLog */
static void
mapPrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt entryOop;
    sqInt i;
    sqInt remainder;

	if (!(GIV(primTraceLog)[/* safe:mod: */
				(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
					? remainder + PrimTraceLogSize
					: remainder)])) {
		return;
	}
	if (GIV(primTraceLog)[GIV(primTraceLogIndex)]) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			entryOop = GIV(primTraceLog)[i];
			if ((entryOop != 0)
			 && (/* shouldRemapOop: */
				((entryOop & 1) == 0)
			 && (/* isObjectForwarded: */
				((entryOop & 1) == 0)
			 && (((longAt(entryOop)) & MarkBit) != 0)))) {
				GIV(primTraceLog)[i] = (remapObj(entryOop));
			}
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		entryOop = GIV(primTraceLog)[i];
		if ((entryOop != 0)
		 && (/* shouldRemapOop: */
			((entryOop & 1) == 0)
		 && (/* isObjectForwarded: */
			((entryOop & 1) == 0)
		 && (((longAt(entryOop)) & MarkBit) != 0)))) {
			GIV(primTraceLog)[i] = (remapObj(entryOop));
		}
	}
}

	/* StackInterpreter>>#mapStackPages */
static NeverInline void
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt numLivePages;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	callerFP = ((char *) 0);
	theIP = 0;
	numLivePages = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((thePage->baseFP)) {
			assert(ifCurrentStackPageHasValidHeadPointers(thePage));
			numLivePages += 1;
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = 0;
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (/* shouldRemapOop: */
						((oop & 1) == 0)
					 && (/* isObjectForwarded: */
						((oop & 1) == 0)
					 && (((longAt(oop)) & MarkBit) != 0))) {
						longAtput(theSP, remapObj(oop));
					}
					theSP += BytesPerWord;
				}
				if (byteAt((theFP + FoxFrameFlags) + 2)) {
					if (/* #shouldRemapObj: #isObjectForwarded: */
						(((longAt(theFP + FoxThisContext)) & 1) == 0)
					 && (((longAt(longAt(theFP + FoxThisContext))) & MarkBit) != 0)) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext)));
					}
				}
				if (/* #shouldRemapObj: #isObjectForwarded: */
					(((longAt(theFP + FoxMethod)) & 1) == 0)
				 && (((longAt(longAt(theFP + FoxMethod))) & MarkBit) != 0)) {
					if (theIPPtr) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP)));
						theIP = (longAt(theIPPtr)) - (longAt(theFP + FoxMethod));
					}
					longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod)));
					if (theIPPtr) {
						longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
					}
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerSavedIP */
			theSP = theFP + FoxCallerContext;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (/* shouldRemapOop: */
					((oop & 1) == 0)
				 && (/* isObjectForwarded: */
					((oop & 1) == 0)
				 && (((longAt(oop)) & MarkBit) != 0))) {
					longAtput(theSP, remapObj(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}

	/* begin recordLivePagesOnMapping: */
	GIV(statNumMaps) += 1;
	GIV(statPageCountWhenMappingSum) += numLivePages;
	GIV(statMaxPageCountWhenMapping) = ((GIV(statMaxPageCountWhenMapping) < numLivePages) ? numLivePages : GIV(statMaxPageCountWhenMapping));
}


/*	Read markAndTraceStackPages:'s comment. Finish tracing to-be-traced pages.
	Then free any untraced pages. */

	/* StackInterpreter>>#markAndTraceAndMaybeFreeStackPages: */
static NoDbgRegParms sqInt
markAndTraceAndMaybeFreeStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			assert(((thePage->trace = -1)) != 0);
		}
		return null;
	}
	markAndTraceUntracedReachableStackPages();
	freeUntracedStackPages();
	return 0;
}


/*	Mark and trace all oops in the interpreter's state. */
/*	Assume: All traced variables contain valid oops.
	N.B. Don't trace messageSelector and lkupClass; these are ephemeral, live
	only during message lookup and because createActualMessageTo will not
	cause a GC these cannot change during message lookup. */
/*	Must mark stack pages first to initialize the per-page trace
	flags for full garbage collect before any subsequent tracing. */

	/* StackInterpreter>>#markAndTraceInterpreterOops: */
static NoDbgRegParms void
markAndTraceInterpreterOops(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	markAndTraceStackPages(fullGCFlag);
	markAndTracePrimTraceLog();
	markAndTrace(GIV(specialObjectsOop));
	if (!((GIV(newMethod) & 1))) {
		markAndTrace(GIV(newMethod));
	}

	/* begin traceProfileState */
	markAndTrace(GIV(profileProcess));
	markAndTrace(GIV(profileMethod));
	markAndTrace(GIV(profileSemaphore));
#  if LRPCheck

	/* The longRunningPrimitiveCheckMethod (LRPCM) is sampled in an interrupt.  Be very careful with it.
	   If longRunningPrimitiveCheckSequenceNumber (LRPCSN) = statCheckForEvents then LRPCM has
	   been recenty sampled, but it must be newMethod and we don't need to trace it twice.  If LRPCSN
	   ~= statCheckForEvents then LRPCM must be some extant object and needs to be traced. */
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		markAndTrace(GIV(longRunningPrimitiveCheckMethod));
	}
	if (GIV(longRunningPrimitiveCheckSemaphore)) {
		markAndTrace(GIV(longRunningPrimitiveCheckSemaphore));
	}
#  endif // LRPCheck

	if (GIV(tempOop)) {
		markAndTrace(GIV(tempOop));
	}
	if (GIV(tempOop2)) {
		markAndTrace(GIV(tempOop2));
	}
	for (i = 1; i <= GIV(remapBufferCount); i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
	}
}


/*	The prim trace log is a circular buffer of objects. If there is
	an entry at primTraceLogIndex - 1 \\ PrimTraceBufferSize it has entries.
	If there is something at primTraceLogIndex it has wrapped. */

	/* StackInterpreter>>#markAndTracePrimTraceLog */
static void
markAndTracePrimTraceLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt entryOop;
    sqInt i;
    sqInt remainder;

	if (!(GIV(primTraceLog)[/* safe:mod: */
				(((remainder = (GIV(primTraceLogIndex) - 1) % PrimTraceLogSize)) < 0
					? remainder + PrimTraceLogSize
					: remainder)])) {
		return;
	}
	if (GIV(primTraceLog)[GIV(primTraceLogIndex)]) {
		for (i = GIV(primTraceLogIndex); i < PrimTraceLogSize; i += 1) {
			entryOop = GIV(primTraceLog)[i];
			if ((entryOop != 0)
			 && ((entryOop & 1) == 0)) {
				markAndTrace(entryOop);
			}
		}
	}
	for (i = 0; i < GIV(primTraceLogIndex); i += 1) {
		entryOop = GIV(primTraceLog)[i];
		if ((entryOop != 0)
		 && ((entryOop & 1) == 0)) {
			markAndTrace(entryOop);
		}
	}
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

	/* StackInterpreter>>#markAndTraceStackPages: */
static NoDbgRegParms sqInt
markAndTraceStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt iSqInt;
    void *pointer;
    sqInt senderOop;
    StackPage *thePage;
    StackPage *thePage1;

	/* begin initStackPageGC */
	if (GIV(stackPage)) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (iSqInt = 0; iSqInt < GIV(numStackPages); iSqInt += 1) {
		/* begin stackPageAt: */
		thePage1 = stackPageAtpages(iSqInt, GIV(pages));
		(thePage1->trace = StackPageUnreached);
	}
	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(thePage))) {
				markAndTraceStackPage(thePage);
			}
		}
		return null;
	}
	if (!GIV(stackPage)) {
		return null;
	}
	thePage = GIV(stackPage);
	do {
		markAndTraceStackPage(thePage);
		context = longAt(((thePage->baseFP)) + FoxCallerContext);
		if ((/* isContext: */
			((context & 1) == 0)
		 && (((((usqInt)((longAt(context)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && ((((longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (/* isStillMarriedContext: */
			(((longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(context)))))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			pointer = pointerForOop(senderOop - 1 /* smallIntegerTag */);

			/* begin stackPageFor: */
			thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
			assert(!(isFree(thePage)));
		}
	} while(((thePage->trace)) < StackPageTraced);
	return 0;
}

	/* StackInterpreter>>#markAndTraceStackPage: */
static NoDbgRegParms void
markAndTraceStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt oop;
    char *theFP;
    char *theSP;

	callerFP = ((char *) 0);
	assert(!(isFree(thePage)));
	assert(ifCurrentStackPageHasValidHeadPointers(thePage));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */
	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				markAndTrace(oop);
			}
			theSP += BytesPerWord;
		}
		if (byteAt((theFP + FoxFrameFlags) + 2)) {
			assert(isContext(frameContext(theFP)));
			markAndTrace(longAt(theFP + FoxThisContext));
		}
		markAndTrace(longAt(theFP + FoxMethod));
		if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */
	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			markAndTrace(oop);
		}
		theSP += BytesPerWord;
	}
}


/*	Trace any untraced pages */

	/* StackInterpreter>>#markAndTraceUntracedReachableStackPages */
static void
markAndTraceUntracedReachableStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	do {
		foundToBeTracedPage = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if ((!(isFree(thePage)))
			 && (((thePage->trace)) == StackPageReachedButUntraced)) {
				foundToBeTracedPage = 1;
				markAndTraceStackPage(thePage);
			}
		}
	} while(foundToBeTracedPage);
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the state .
 */

	/* StackInterpreter>>#marriedContext:pointsTo:stackDeltaForCurrentFrame: */
static NoDbgRegParms sqInt
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *rcvrOffset;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	/* begin frameOfMarriedContext: */
	senderOop = longAt((spouseContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		theSP = findSPOfon(theFP, thePage);
	}
	if ((anOop & 1)) {

		/* Check stack and instruction pointer fields. */
		if ((anOop == ((((usqInt)((((usqInt)(((theFP + FoxReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1))) << 1) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext)))) {
			return 1;
		}
	}
	else {

		/* Check method and sender fields, avoiding unnecessarily reifying sender context. */
		if (anOop == (longAt(theFP + FoxMethod))) {
			return 1;
		}
		if (longAt(theFP + FoxSavedFP)) {
			if (((byteAt(((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxFrameFlags) + 2)) != 0)
			 && (anOop == (longAt((pointerForOop(longAt(theFP + FoxSavedFP))) + FoxThisContext)))) {
				return 1;
			}
		}
		else {
			if (anOop == (longAt(theFP + FoxCallerContext))) {
				return 1;
			}
		}
	}
	rcvrOffset = theFP + FoxReceiver;
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Establish aContext at the base of a new stackPage, make the stackPage the
	active one and set-up the interreter registers. This is used to boot the
	system and bring it back after a snapshot. */

	/* StackInterpreter>>#marryContextInNewStackPageAndInitializeInterpreterRegisters: */
static NoDbgRegParms void
marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    StackPage *newPage;
    sqInt top;

	assert(!GIV(stackPage));
	newPage = makeBaseFrameFor(aContext);

	/* begin setStackPageAndLimit: */
	assert(newPage);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);

	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (newPage->headSP);
	GIV(framePointer) = (newPage->headFP);
	aMethodObj = longAt(((GIV(stackPage)->headFP)) + FoxMethod);

	/* begin setMethod: */
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;
}


/*	Marry an unmarried frame. This means creating a spouse context
	initialized with a subset of the frame's state (state through the last
	argument) that references the frame. */

	/* StackInterpreter>>#marryFrame:SP: */
static NoDbgRegParms sqInt
marryFrameSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    sqInt i;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numStack;
    sqInt theContext;

	assert(!(frameHasContext(theFP)));
	assert(addressCouldBeOop(longAt(theSP)));

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(longAt(theFP + FoxMethod)));

	/* Decide how much of the stack to preserve in widowed contexts.  Preserving too much
	   state will potentially hold onto garbage.  Holding onto too little may mean that a dead
	   context isn't informative enough in a debugging situation.  If copyTemps is false (as it
	   is in the default closure implementation) compromise, retaining only the arguments with
	   no temporaries.  Note that we still set the stack pointer to its current value, but stack
	   contents other than the arguments are nil. */
	methodHeader = longAt(((longAt(theFP + FoxMethod)) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	closureOrNil = (byteAt((theFP + FoxFrameFlags) + 3)
				? longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))))))
				: GIV(nilObj));
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;
	numStack = (((usqInt)(((theFP + FoxReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));

	/* Mark context as married by setting its sender to the frame pointer plus SmallInteger
	   tags and the InstructionPointer to the saved fp (which ensures correct alignment
	   w.r.t. the frame when we check for validity) */
	theContext = eeInstantiateMethodContextSlots((methodHeader & LargeContextBit
				? LargeContextSlots
				: SmallContextSlots));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(
		(theContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))),
		(/* begin withSmallIntegerTags: */
			assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0),
		(oopForPointer(theFP)) + 1 /* smallIntegerTag */));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput(
		(theContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))),
		(/* begin withSmallIntegerTags: */
			assert(((oopForPointer(pointerForOop(longAt(theFP + FoxSavedFP)))) & (BytesPerWord - 1)) == 0),
		(oopForPointer(pointerForOop(longAt(theFP + FoxSavedFP)))) + 1 /* smallIntegerTag */));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))), ((numStack << 1) | 1));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))), longAt(theFP + FoxMethod));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + ((((usqInt)(ClosureIndex) << (shiftForWord())))), closureOrNil);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord())))), longAt(theFP + FoxReceiver));
	for (i = 1; i <= numArgs; i += 1) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((theContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), longAt((theFP + FoxCallerSavedIP) + ((numArgs - (i - 1)) * BytesPerWord)));
	}
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((theContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), GIV(nilObj));
	}

	/* begin setFrameContext:to: */
	longAtput(theFP + FoxThisContext, theContext);
	byteAtput((theFP + FoxFrameFlags) + 2, 1);
	assert(frameHasContext(theFP));
	assert((frameOfMarriedContext(theContext)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext)));
	return theContext;
}


/*	Assert-only check for leaks after external prim calls if checkForLeaks
	includes the GCCheckPrimCall flag.
	This is ionly really useful from a low-level C debugger, hence no
	accessors for checkedPluginName.
 */

	/* StackInterpreter>>#maybeLeakCheckExternalPrimCall: */
static NoDbgRegParms sqInt
maybeLeakCheckExternalPrimCall(sqInt aMethodObj)
{
	if ((((checkForLeaks & GCCheckPrimCall) != 0))
	 && (((primitiveIndexOf(aMethodObj)) == PrimNumberExternalCall)
	 && (checkedPluginName == (fetchPointerofObject(0, longAt((aMethodObj + BaseHeaderSize) + (1U << (shiftForWord())))))))) {
		runLeakCheckerFor(GCCheckPrimCall);
	}
	return 1;
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence.
	With full blocks as of 9/2016 the last literal of a CompiledBlock is a
	back pointer
	to the enclosing block or compiled method. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
sqInt
maybeSelectorOfMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt maybeSelector;
    sqInt penultimateLiteral;
    sqInt ultimateLiteral;

	assert(isOopCompiledMethod(methodObj));
	ultimateLiteral = ultimateLiteralOf(methodObj);
	if (/* isOopCompiledMethod: */
		((ultimateLiteral & 1) == 0)
	 && (((((usqInt)((longAt(ultimateLiteral)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))) {
		return maybeSelectorOfMethod(ultimateLiteral);
	}
	penultimateLiteral = penultimateLiteralOf(methodObj);
	if (/* isWordsOrBytes: */
		((penultimateLiteral & 1) == 0)
	 && (isWordsOrBytesNonImm(penultimateLiteral))) {
		return ((/* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(penultimateLiteral)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(penultimateLiteral - BaseHeaderSize)) & AllButTypeMask)) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))))
				? penultimateLiteral
				: 0);
	}
	return ((/* isPointers: */
		((penultimateLiteral & 1) == 0)
	 && (((((usqInt)((longAt(penultimateLiteral)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
	 && (((numSlotsOf(penultimateLiteral)) >= 2)
	 && (((longAt((penultimateLiteral + BaseHeaderSize) + (0U << (shiftForWord())))) == methodObj)
	 && (((maybeSelector = longAt((penultimateLiteral + BaseHeaderSize) + (1U << (shiftForWord())))),
	(/* isWordsOrBytes: */
			((maybeSelector & 1) == 0)
		 && (isWordsOrBytesNonImm(maybeSelector)))
		 && ((/* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(maybeSelector)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(maybeSelector - BaseHeaderSize)) & AllButTypeMask)) == (fetchClassTagOfNonImm(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))))))))))
			? maybeSelector
			: 0);
}

	/* StackInterpreter>>#methodArgumentCount */
sqInt
methodArgumentCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(argumentCount);
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer)
{
    sqInt offset;

	offset = (literalCountOf(methodPointer)) - 1;

	/* begin literal:ofMethod: */
	return longAt((methodPointer + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	Answer the method class of a method which is the value of an Association
	in the last literal,
	or answer nil if there isn't one.
	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line. */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt offset;

	offset = (literalCountOf(methodPointer)) - 1;

	/* begin followLiteral:ofMethod: */
	literal = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	return ((literal != GIV(nilObj))
	 && (/* isPointers: */
		((literal & 1) == 0)
	 && (((((usqInt)((longAt(literal)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			? (assert((numSlotsOf(literal)) > ValueIndex),
			/* #followField:ofObject: #fetchPointer:ofObject: */
				longAt((literal + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord()))))))
			: GIV(nilObj));
}

	/* StackInterpreter>>#methodPrimitiveIndex */
sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt methodHeader;
    sqInt primBits;

	if (!((/* addressCouldBeObj: */
			((GIV(newMethod) & 3) == 0)
		 && (((((usqInt)GIV(newMethod))) >= (startOfMemory()))
		 && (((((usqInt)GIV(newMethod))) < GIV(freeStart))
		 && (((longAt(GIV(newMethod))) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		return -1;
	}

	/* begin primitiveIndexOf: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin primitiveIndexOfMethod:header: */
	primBits = (methodHeader >> 1);
	return (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnBool: */
sqInt
methodReturnBool(sqInt boolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), /* booleanObjectOf: */
		(boolean
			? GIV(trueObj)
			: GIV(falseObj)));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. */

	/* StackInterpreter>>#methodReturnFloat: */
sqInt
methodReturnFloat(double aFloat)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));

	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), floatObjectOf(aFloat));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnInteger: */
sqInt
methodReturnInteger(sqInt integer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 1) | 1));
	GIV(stackPointer) = sp;
	return 0;
}


/*	Sets the return value for a method */

	/* StackInterpreter>>#methodReturnReceiver */
sqInt
methodReturnReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!((failed())));

	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	return 0;
}


/*	Attempt to answer a ByteString for a given C string as the result of a
	primitive. 
 */

	/* StackInterpreter>>#methodReturnString: */
NeverInline sqInt
methodReturnString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt result;
    char *sp;

	assert(!((failed())));
	if (aCString) {
		result = stringForCString(aCString);
		if (result) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
			GIV(stackPointer) = sp;
		}
		else {
			GIV(primFailCode) = PrimErrNoMemory;
		}
	}
	else {
		GIV(primFailCode) = PrimErrOperationFailed;
	}
	return 0;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

	/* StackInterpreter>>#methodReturnValue: */
sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	assert(!((failed())));

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

	/* StackInterpreter>>#methodUsesAlternateBytecodeSet: */
int
methodUsesAlternateBytecodeSet(sqInt aMethodObj)
{
    sqInt methodHeader;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(aMethodObj));
	methodHeader = longAt((aMethodObj + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin headerIndicatesAlternateBytecodeSet: */
	return (((int) methodHeader)) < 0;
}


/*	Answer if aMethodObj contains a primitive and uses the primitive error
	code. 
 */

	/* StackInterpreter>>#methodUsesPrimitiveErrorCode: */
static NoDbgRegParms sqInt
methodUsesPrimitiveErrorCode(sqInt aMethodObj)
{
    sqInt methodHeader;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(aMethodObj));
	methodHeader = longAt((aMethodObj + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	return ((primitiveIndexOfMethodheader(aMethodObj, methodHeader)) > 0)
	 && ((LongStoreBytecode) == (fetchByteofObject(((((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF))) + LiteralStart) * BytesPerOop), aMethodObj)));
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

	/* StackInterpreter>>#moduleUnloaded: */
EXPORT(void)
moduleUnloaded(char *aModuleName)
{
	if (!(strcmp(aModuleName, "SurfacePlugin"))) {

		/* Surface plugin went away. Should never happen. But  then, who knows */
		showSurfaceFn = 0;
	}
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

	/* StackInterpreter>>#moveFramesIn:through:toPage: */
static NoDbgRegParms char *
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    sqInt callerIP;
    sqInt delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    char *offsetCallerFP;
    char *source;
    int stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;

	newSP = ((newPage->baseAddress)) + BytesPerWord;

	/* First move the data.  We will fix up frame pointers later. */
	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))));
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = ((newPage->baseAddress)) - stackedReceiverOffset;
	theFP1 = ((oldPage->headFP)) + delta;

	/* begin setHeadFP:andSP:inPage: */
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(!(isBaseFrame(theFP)));
	assert(frameHasContext(callerFP));
	callerIP = oopForPointer(pointerForOop(longAt(theFP + FoxCallerSavedIP)));
	longAtput(theFP + stackedReceiverOffset, callerIP);
	assert((callerFP < ((oldPage->baseAddress)))
	 && (callerFP > (((oldPage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerContext, longAt(callerFP + FoxThisContext));
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if (byteAt((fpInNewPage + FoxFrameFlags) + 2)) {
			theContext = longAt(fpInNewPage + FoxThisContext);

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput(
				(theContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))),
				(/* begin withSmallIntegerTags: */
					assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0),
				(oopForPointer(fpInNewPage)) + 1 /* smallIntegerTag */));

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput(
				(theContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))),
				(/* begin withSmallIntegerTags: */
					assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0),
				(oopForPointer(offsetCallerFP)) + 1 /* smallIntegerTag */));
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	return newFP;
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static NoDbgRegParms char *
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    int numSlots;
    unsigned int sz;

	/* begin numSlotsOf: */
	header = longAt(classOop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(classOop - (BytesPerWord * 2))) & AllButTypeMask);
	numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(thisClassIndex)) << (shiftForWord())))));
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClass(longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))));
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(classNameIndex)) << (shiftForWord())))))),
		/* isBytes: */
			((maybeNameOop & 1) == 0)
			 && (((((usqInt)((longAt(maybeNameOop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop);
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass:lengthInto: */
static NoDbgRegParms char *
nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    int numSlots;
    unsigned int sz;

	/* begin numSlotsOf: */
	header = longAt(classOop);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(classOop - (BytesPerWord * 2))) & AllButTypeMask);
	numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(thisClassIndex)) << (shiftForWord())))));
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClasslengthInto(longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))), lengthPtr);
		}
		lengthPtr[0] = 9;
		return "bad class";
	}
	if ((numSlots > GIV(classNameIndex))
	 && (((maybeNameOop = longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(classNameIndex)) << (shiftForWord())))))),
	/* isBytes: */
		((maybeNameOop & 1) == 0)
		 && (((((usqInt)((longAt(maybeNameOop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))))) {
		lengthPtr[0] = (numBytesOfBytes(maybeNameOop));
		return firstIndexableField(maybeNameOop);
	}
	lengthPtr[0] = 9;
	return "bad class";
}


/*	Answer a full 32 bit integer object for the given integer value which
	is known not to be a SmallInteger value. This serves to share the
	code for creating a four byte LargeInteger in one place. */

	/* StackInterpreter>>#noInlineSigned32BitIntegerGutsFor: */
static NoDbgRegParms NeverInline sqInt
noInlineSigned32BitIntegerGutsFor(sqInt integerValue)
{
    sqInt largeClass;
    unsigned int magnitude;
    sqInt newLargeInteger;

	assert(!((hasSixtyFourBitImmediates())));
	assert(!((isIntegerValue(integerValue))));
	if (integerValue < 0) {
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = (((usqInt)0)) - integerValue;
	}
	else {
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(largeClass, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude));
	return newLargeInteger;
}


/*	Answer true if there are no marked contexts on thePage. */

	/* StackInterpreter>>#noMarkedContextsOnPage: */
static NoDbgRegParms sqInt
noMarkedContextsOnPage(StackPage *thePage)
{
    char *theFP;

	assert(!(isFree(thePage)));
	theFP = (thePage->headFP);
	do {
		if (byteAt((theFP + FoxFrameFlags) + 2)) {
			assert(isContext(frameContext(theFP)));
			if ((longAt(longAt(theFP + FoxThisContext))) & MarkBit) {
				return 0;
			}
		}
	} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
	return 1;
}

	/* StackInterpreter>>#numStkPages */
static sqInt
numStkPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(numStackPages);
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
sqInt
objCouldBeClassObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldOop;

	return (((((usqInt)((longAt(objOop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
	 && (((numSlotsOfAny(objOop)) > InstanceSpecificationIndex)
	 && (((fieldOop = longAt((objOop + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))))),
	((/* addressCouldBeObj: */
			((fieldOop & 3) == 0)
		 && (((((usqInt)fieldOop)) >= (startOfMemory()))
		 && (((((usqInt)fieldOop)) < GIV(freeStart))
		 && (((longAt(fieldOop)) & TypeMask) != HeaderTypeGC))))
		 && (((((usqInt)((longAt(fieldOop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && (((fieldOop = longAt((objOop + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))))),
		((/* addressCouldBeObj: */
				((fieldOop & 3) == 0)
			 && (((((usqInt)fieldOop)) >= (startOfMemory()))
			 && (((((usqInt)fieldOop)) < GIV(freeStart))
			 && (((longAt(fieldOop)) & TypeMask) != HeaderTypeGC))))
			 && (((((usqInt)((longAt(fieldOop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
			 && (((longAt((objOop + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) & 1)))))));
}

	/* StackInterpreter>>#object:equalsString: */
static NoDbgRegParms sqInt
objectequalsString(sqInt anOop, char *aCString)
{
    sqInt len;

	len = strlen(aCString);
	return /* object:equalsString:ofSize: */
		(/* isBytes: */
		((anOop & 1) == 0)
	 && (((((usqInt)((longAt(anOop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
	 && ((!(((((usqInt)((longAt(anOop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && (((numBytesOfBytes(anOop)) == len)
	 && ((strncmp(aCString, firstIndexableField(anOop), len)) == 0)));
}


/*	This is the entry-point for plugins and primitives that wish to reacquire
	the VM after having
	released it via disownVM or callbacks that want to acquire it without
	knowing their ownership
	status. While this exists for the threaded FFI VM we use it to reset
	newMethod and the
	argumentCount after a callback.
	
	Answer 0 if the current thread is known to the VM (and on return owns the
	VM). Answer 1 if the current thread is unknown to the VM and takes
	ownership. Answer -1 if the current thread is unknown to the VM and fails
	to take ownership. */

	/* StackInterpreter>>#ownVM: */
sqInt
ownVM(void *vmHandle)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    char *sp;

	assert((isOopCompiledMethod(GIV(newMethod)))
	 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)));
	if (!vmHandle) {
		assert(GIV(primFailCode) == 0);

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)GIV(argumentCount) << 1) | 1));
		GIV(stackPointer) = sp;
		return 1;
	}
	flags = ((sqInt) vmHandle);
	if (((flags & DisownVMForFFICall) != 0)) {
		GIV(ffiCalloutVMHandle) = null;
	}
	return 0;
}

	/* StackInterpreter>>#pcPreviousTo:inSqueakV3PlusClosuresMethod: */
usqInt
pcPreviousToinSqueakV3PlusClosuresMethod(sqInt theIP, sqInt aMethod)
{
    sqInt byte;
    static unsigned char  extensionSizes[] = {
		2, 2, 2, 2, 3, 2, 2, 1, 1, 1, 2, 3, 3, 3, 3, 4
	};
    usqInt previousPC;
    usqInt thisIP;

	thisIP = ((((literalCountOf(aMethod)) + LiteralStart) * BytesPerOop) + aMethod) + BaseHeaderSize;
	assert(oopisLessThan(thisIP, theIP));
	while (oopisLessThan(thisIP, theIP)) {
		previousPC = thisIP;
		byte = byteAt(thisIP);
		thisIP += ((byte <= 125
						? 1
						: (byte >= 176
								? 1
								: (byte >= 160
										? 2
										: (byte >= 144
												? 1
												: (byte >= 128
														? extensionSizes[byte - 128]
														: (assertf("illegal bytecode in sizeOfSqueakV3Bytecode:"),
														1)))))));
	}
	return previousPC;
}

	/* StackInterpreter>>#penultimateLiteralOf: */
static NoDbgRegParms sqInt
penultimateLiteralOf(sqInt aMethodOop)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop));
	offset = (literalCountOf(aMethodOop)) - 2;

	/* begin literal:ofMethod: */
	return longAt((aMethodOop + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#popStack */
sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop: */
sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#pop:thenPush: */
void
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	integerValue is interpreted as POSITIVE, e.g. as the result of Bitmap>at:.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#positive32BitIntegerFor: */
sqInt
positive32BitIntegerFor(unsigned int integerValue)
{
    sqInt newLargeInteger;

	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
		return ((integerValue << 1) | 1);
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
	return newLargeInteger;
}


/*	Answer a Large Positive Integer object for the given integer value. N.B.
	will *not* cause a GC. */

	/* StackInterpreter>>#positive64BitIntegerFor: */
sqInt
positive64BitIntegerFor(usqLong integerValue)
{
    unsigned int highWord;
    sqInt newLargeInteger;
    sqInt newLargeIntegerSqInt;
    sqInt sz;

	if (!((highWord = (integerValue) >> 32))) {
		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) (((unsigned int) integerValue)))) <= (MaxSmallInteger)) {
			return (((((unsigned int) integerValue)) << 1) | 1);
		}
		newLargeIntegerSqInt = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeIntegerSqInt + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN((((unsigned int) integerValue))));
		return newLargeIntegerSqInt;
	}
	sz = 5;
	if ((highWord = (highWord) >> 8)) {
		sz += 1;
		if ((highWord = (highWord) >> 8)) {
			sz += 1;
			if ((highWord = (highWord) >> 8)) {
				sz += 1;
			}
		}
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + ((4 - sz) & 3), 8 / BytesPerOop);

	/* begin storeLong64:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_8_BYTES_IF_BIGENDIAN(integerValue));
	long32Atput(((newLargeInteger + BaseHeaderSize)) + 4, ((SQ_SWAP_8_BYTES_IF_BIGENDIAN(integerValue))) >> 32);
	SQ_SWAP_8_BYTES_IF_BIGENDIAN(integerValue);
	return newLargeInteger;
}

	/* StackInterpreter>>#positiveMachineIntegerFor: */
static NoDbgRegParms sqInt
positiveMachineIntegerFor(usqIntptr_t value)
{
    sqInt newLargeInteger;
    sqInt resultObj;

	/* begin positive32BitIntegerFor: */
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if ((((unsigned int) value)) <= (MaxSmallInteger)) {
		resultObj = ((value << 1) | 1);
		goto l1;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

	/* storeLong32:ofObject:withValue: */
	long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(value));
	resultObj = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;
	return resultObj;
}


/*	Update the displayBits after a GC may have moved it.
	Answer if the displayBits appear valid. The wrinkle here is that the
	displayBits could be a surface handle. */

	/* StackInterpreter>>#postGCUpdateDisplayBits */
static sqInt
postGCUpdateDisplayBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *bitsNow;
    sqInt bitsOop;
    sqInt displayObj;

	displayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheDisplay) << (shiftForWord())))));
	if (!((/* isPointers: */
			((displayObj & 1) == 0)
		 && (((((usqInt)((longAt(displayObj)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && ((lengthOf(displayObj)) >= 4))) {
		return 0;
	}
	bitsOop = longAt((displayObj + BaseHeaderSize) + (0U << (shiftForWord())));
	if ((bitsOop == GIV(nilObj))
	 || ((bitsOop & 1))) {

		/* It's a surface; our work here is done... */
		return 1;
	}
	assert((addressCouldBeObj(bitsOop))
	 && (isWordsOrBytes(bitsOop)));
	bitsNow = firstIndexableField(bitsOop);
	if (displayBits != bitsNow) {
		displayBits = bitsNow;
		ioNoteDisplayChangedwidthheightdepth(displayBits, displayWidth, displayHeight, displayDepth);
	}
	return 1;
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

	/* StackInterpreter>>#primitiveEventProcessingControl */
EXPORT(void)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int enabled;
    char *sp;

	enabled = inIOProcessEvents >= 0;
	if (!GIV(argumentCount)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer)), /* booleanObjectOf: */
			(enabled
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				/* primitiveFailFor: */
				GIV(primFailCode) = PrimErrBadArgument;
				return;
			}
		}

		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
			(enabled
				? GIV(trueObj)
				: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadNumArgs;
}

	/* StackInterpreter>>#primitiveFloatEqual:toArg: */
static NoDbgRegParms int
primitiveFloatEqualtoArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    double result;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	return rcvr == arg;
}

	/* StackInterpreter>>#primitiveFloatGreaterOrEqual:toArg: */
static NoDbgRegParms int
primitiveFloatGreaterOrEqualtoArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    double result;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	return rcvr >= arg;
}

	/* StackInterpreter>>#primitiveFloatGreater:thanArg: */
static NoDbgRegParms int
primitiveFloatGreaterthanArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    double result;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	return rcvr > arg;
}

	/* StackInterpreter>>#primitiveFloatLessOrEqual:toArg: */
static NoDbgRegParms int
primitiveFloatLessOrEqualtoArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    double result;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	return rcvr <= arg;
}

	/* StackInterpreter>>#primitiveFloatLess:thanArg: */
static NoDbgRegParms int
primitiveFloatLessthanArg(sqInt rcvrOop, sqInt argOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    double rcvr;
    double result;

	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l2;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((rcvrOop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((rcvrOop & 1)));
	ccIndex = (((usqInt)((longAt(rcvrOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(rcvrOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l2;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end loadFloatOrIntFrom: */;

	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l4;
	}

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((argOop & 1)) {
		isFloat = 0;
		goto l3;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((argOop & 1)));
	ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l3;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l3:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(argOop + BaseHeaderSize, result);
		arg = result;
		goto l4;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end loadFloatOrIntFrom: */;
	return rcvr < arg;
}


/*	Note: With the Squeak V3 format we now have 10 bits of primitive index,
	but they are
	in two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the
	Spur format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt primBits;

	primBits = (methodHeader >> 1);
	return (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt methodHeader;
    sqInt primBits;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	methodHeader = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin primitiveIndexOfMethod:header: */
	primBits = (methodHeader >> 1);
	return (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);
}

	/* StackInterpreter>>#printActivationNameForSelector:startClass: */
static NoDbgRegParms void
printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    int classDictSize;
    sqInt currClass;
    sqInt header;
    sqInt i;
    sqInt methClass;
    unsigned int sz;

	if (/* addressCouldBeObj: */
		((startClass & 3) == 0)
	 && (((((usqInt)startClass)) >= (startOfMemory()))
	 && (((((usqInt)startClass)) < GIV(freeStart))
	 && (((longAt(startClass)) & TypeMask) != HeaderTypeGC)))) {
		/* begin findClassForSelector:lookupClass:do: */
		currClass = startClass;
		do {
			classDict = longAt((currClass + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord())))));

			/* begin numSlotsOf: */
			header = longAt(classDict);
			sz = (header & TypeMask
						? header & SizeMask
						: (longAt(classDict - (BytesPerWord * 2))) & AllButTypeMask);
			classDictSize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			i = SelectorStart;
			while (i < classDictSize) {
				if (aSelector == (longAt((classDict + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))))) {
					methClass = currClass;
					goto l1;
				}
				i += 1;
			}
			currClass = longAt((currClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
		} while(!(currClass == GIV(nilObj)));
		methClass = null;
l1:	/* end findClassForSelector:lookupClass:do: */;
		if ((!methClass)
		 || (startClass == methClass)) {
			printNameOfClasscount(methClass, 5);
			printChar('>');
			if (!methClass) {
				printStringOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord()))))));
				print(" ");
			}
		}
		else {
			printNameOfClasscount(startClass, 5);
			printChar('(');
			printNameOfClasscount(methClass, 5);
			printChar(')');
			printChar('>');
		}
	}
	else {
		print("INVALID CLASS");
	}
	if (/* addressCouldBeOop: */
		((aSelector & 1))
	 || (/* addressCouldBeObj: */
		((aSelector & 3) == 0)
	 && (((((usqInt)aSelector)) >= (startOfMemory()))
	 && (((((usqInt)aSelector)) < GIV(freeStart))
	 && (((longAt(aSelector)) & TypeMask) != HeaderTypeGC))))) {
		if (/* isBytes: */
			((aSelector & 1) == 0)
		 && (((((usqInt)((longAt(aSelector)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()))) {
			printStringOf(aSelector);
		}
		else {
			/* begin printOopShort: */
			printOopShortInner(aSelector);
			fflush(GIV(transcript));
		}
	}
	else {
		print("INVALID SELECTOR");
	}
}

	/* StackInterpreter>>#printActivationNameFor:receiver:isBlock:firstTemporary: */
static NoDbgRegParms void
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classObj;
    sqInt homeMethod;
    sqInt methClass;
    sqInt methodSel;

	if (isBlock) {
		print("[] in ");
		homeMethod = homeMethodOf(aMethod);
	}
	else {
		homeMethod = aMethod;
	}
	methClass = findClassOfMethodforReceiver(homeMethod, anObject);
	methodSel = findSelectorOfMethod(homeMethod);
	if ((/* addressCouldBeOop: */
		((anObject & 1))
	 || (/* addressCouldBeObj: */
		((anObject & 3) == 0)
	 && (((((usqInt)anObject)) >= (startOfMemory()))
	 && (((((usqInt)anObject)) < GIV(freeStart))
	 && (((longAt(anObject)) & TypeMask) != HeaderTypeGC)))))
	 && (addressCouldBeClassObj((classObj = /* fetchClassOf: */
			((anObject & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(anObject)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(anObject - BaseHeaderSize)) & AllButTypeMask)))))) {
		printNameOfClasscount(classObj, 5);
		if (!((classObj == methClass)
			 || ((!methClass)
			 || (methClass == GIV(nilObj))))) {
			printChar('(');
			printNameOfClasscount(methClass, 5);
			printChar(')');
		}
	}
	else {
		print("INVALID RECEIVER");
	}
	printChar('>');
	if (/* addressCouldBeOop: */
		((methodSel & 1))
	 || (/* addressCouldBeObj: */
		((methodSel & 3) == 0)
	 && (((((usqInt)methodSel)) >= (startOfMemory()))
	 && (((((usqInt)methodSel)) < GIV(freeStart))
	 && (((longAt(methodSel)) & TypeMask) != HeaderTypeGC))))) {
		if (methodSel == GIV(nilObj)) {
			print("(nil)");
		}
		else {
			if ((methodSel & 1)) {
				printChar('(');
				printHex(methodSel);
				printChar(')');
			}
			else {
				printStringOf(methodSel);
			}
		}
	}
	else {
		print("INVALID SELECTOR = ");
		printHex(methodSel);
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorDoesNotUnderstand) << (shiftForWord())))))))
	 && ((/* addressCouldBeObj: */
		((maybeMessage & 3) == 0)
	 && (((((usqInt)maybeMessage)) >= (startOfMemory()))
	 && (((((usqInt)maybeMessage)) < GIV(freeStart))
	 && (((longAt(maybeMessage)) & TypeMask) != HeaderTypeGC))))
	 && ((/* fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(maybeMessage)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(maybeMessage - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassMessage) << (shiftForWord()))))))))) {

		/* print arg message selector */
		methodSel = longAt((maybeMessage + BaseHeaderSize) + ((((usqInt)(MessageSelectorIndex) << (shiftForWord())))));

		/* begin space */
		printChar(' ');
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */
/*	useful for VM debugging */

	/* StackInterpreter>>#printAllStacks */
void
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    usqInt fwdBlock;
    sqInt header;
    sqInt headerSqInt;
    sqInt linkedListClass;
    sqInt minProcessInstSize;
    sqInt myList;
    sqInt myListClass;
    sqInt oop;
    int p;
    int pri;
    sqInt proc;
    sqInt processClass;
    sqInt processList;
    sqInt realHeader;
    sqInt schedLists;
    unsigned int sz;
    unsigned int sz1;

	/* may not be an instance of process. may in exceptional circumstances be nilObject */
	proc = activeProcess();
	printNameOfClasscount(/* fetchClassOf: */
		((proc & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(proc)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(proc - BaseHeaderSize)) & AllButTypeMask)), 5);

	/* begin space */
	printChar(' ');
	printHex(proc);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, proc));
	cr();
	if (GIV(framePointer)) {
		printCallStack();
	}
	else {
		printProcessStack(proc);
	}
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));

	/* begin fetchPointer:ofObject: */
	schedLists = longAt((oop + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));

	/* then the runnable processes */
	linkedListClass = null;
	p = (GIV(highestRunnableProcessPriority)
				? GIV(highestRunnableProcessPriority)
				: numSlotsOf(schedLists));
	for (pri = (p - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + BaseHeaderSize) + ((((usqInt)(pri) << (shiftForWord())))));
		if (!(isEmptyList(processList))) {
			if (proc == GIV(nilObj)) {
				proc = longAt((processList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))));
			}
			cr();
			print("processes at priority ");
			printNum(pri + 1);
			printProcsOnList(processList);
		}
		if (!linkedListClass) {
			linkedListClass = /* fetchClassOfNonImm: */
					((ccIndex = (((usqInt)((longAt(processList)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(processList - BaseHeaderSize)) & AllButTypeMask);
		}
	}
	if (!linkedListClass) {
		/* #followObjField:ofObject: #fetchPointer:ofObject: */
		longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}
	if (proc == GIV(nilObj)) {
		cr();
		print("Cannot find a runnable process. Cannot therefore determine class Process. Cannot therefore print suspended processes");
		return;
	}
	cr();
	print("suspended processes");
	processClass = (!(proc == GIV(nilObj))
				? /* fetchClassOf: */
					((proc & 1)
						? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
						: ((ccIndex = (((usqInt)((longAt(proc)))) >> (compactClassFieldLSB())) & 0x1F)
								? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
								: (longAt(proc - BaseHeaderSize)) & AllButTypeMask))
				: 0);
	minProcessInstSize = MyListIndex + 1;
	while ((instanceSizeOf(longAt((processClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord()))))))) >= minProcessInstSize) {
		processClass = longAt((processClass + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
	}

	/* look for all subInstances of process that have a context as a suspendedContext and are on a list other than a LinkedList */
	minProcessInstSize = instanceSizeOf(processClass);

	/* begin allObjectsDoSafely: */
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
			 && (((numSlotsOf(oop)) >= minProcessInstSize)
			 && ((isContext(longAt((oop + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))))))
			 && (isKindOfClass(oop, processClass))))) {

				/* Is the process waiting on some delaying list?  This will be a subclass of LinkedList.
				   If so, assume it is blocked on the list. */
				myList = longAt((oop + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))));
				if ((myList != GIV(nilObj))
				 && ((((myListClass = /* fetchClassOfNonImm: */
						((ccIndex = (((usqInt)((longAt(myList)))) >> (compactClassFieldLSB())) & 0x1F)
							? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
							: (longAt(myList - BaseHeaderSize)) & AllButTypeMask))) != linkedListClass)
				 && (isKindOfClass(myList, linkedListClass)))) {
					printProcessStack(oop);
				}
			}
		}

		/* begin objectAfterWhileForwarding: */
		header = longAt(oop);
		if (!(header & MarkBit)) {
			/* begin objectAfter: */
			if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
				error("no objects after the end of memory");
			}
			if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
				sz1 = (longAt(oop)) & AllButTypeMask;
			}
			else {
				/* begin sizeBitsOf: */
				headerSqInt = longAt(oop);
				sz1 = ((usqInt) ((headerSqInt & TypeMask
		? headerSqInt & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
			}
			oop = (oop + sz1) + (headerTypeBytes[(longAt(oop + sz1)) & TypeMask]);
			goto l1;
		}
		fwdBlock = ((header & AllButMarkBitAndTypeMask) << 1);
		assert(fwdBlockValid(fwdBlock));

		/* following code is like sizeBitsOf: */
		realHeader = longAt(fwdBlock + BytesPerWord);
		if (realHeader & TypeMask) {
			sz = realHeader & SizeMask;
		}
		else {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
l1:	/* end objectAfterWhileForwarding: */;
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */
/*	useful for VM debugging */

	/* StackInterpreter>>#printAllStacksOn: */
void
printAllStacksOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;

	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream
				? aStdioStream
				: stdout);
	printAllStacks();
	GIV(transcript) = savedTranscript;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printCallStack */
void
printCallStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(framePointer)) {
		printCallStackFP(GIV(framePointer));
	}
	else {
		printCallStackOf(fetchPointerofObject(SuspendedContextIndex, activeProcess()));
	}
}

	/* StackInterpreter>>#printCallStackFP: */
static NoDbgRegParms sqInt
printCallStackFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP);
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printCallStackOf: */
sqInt
printCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	if (/* couldBeFramePointer: */
		(((((usqInt)aContextOrProcessOrFrame)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)aContextOrProcessOrFrame)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)aContextOrProcessOrFrame)) <= (((usqInt)GIV(pages))))))) {
		return printCallStackFP(((char *)aContextOrProcessOrFrame));
	}
	if (aContextOrProcessOrFrame == (activeProcess())) {
		return printCallStackOf(((sqInt)GIV(framePointer)));
	}
	if (couldBeProcess(aContextOrProcessOrFrame)) {
		return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord()))))));
	}
	context = aContextOrProcessOrFrame;
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
	return 0;
}

	/* StackInterpreter>>#printCallStackOf:currentFP: */
static NoDbgRegParms sqInt
printCallStackOfcurrentFP(sqInt aContext, char *currFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt senderOop;
    char *theFP;
    StackPage *thePage;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP)) {
				/* begin stackPageFor: */
				thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
				if (isFree(thePage)) {
					fprintf(GIV(transcript),
							"%p is on a free page?!\n",
							theFP);
					return null;
				}
				shortPrintFrameAndCallers(theFP);
				theFP = (thePage->baseFP);
				ctxt = longAt(theFP + FoxCallerContext);
			}
			else {
				fprintf(GIV(transcript),
						"widowed caller frame %p\n",
						theFP);
				return null;
			}
		}
		else {
			shortPrintContext(ctxt);
			ctxt = longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		}
	}
	return 0;
}


/*	Print the call stack on a specific output stream. */
/*	useful for VM debugging */

	/* StackInterpreter>>#printCallStackOn: */
void
printCallStackOn(FILE *aStdioStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    FILE *savedTranscript;

	/* begin withRedirectedOutputTo:do: */
	savedTranscript = GIV(transcript);
	GIV(transcript) = (aStdioStream
				? aStdioStream
				: stdout);
	printCallStack();
	GIV(transcript) = savedTranscript;
}


/*	Print the call stack of aContext until it links to a frame. */

	/* StackInterpreter>>#printContextCallStackOf: */
static NoDbgRegParms sqInt
printContextCallStackOf(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
	 || (((longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	}
	return ctxt;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printContext: */
void
printContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ip;
    sqInt sender;
    sqInt sp;
    sqInt theMethod;

	shortPrintContext(aContext);
	sender = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	ip = longAt((aContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))));
	if ((sender & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print("married (assuming framePointer valid)");
			cr();
		}
		else {
			print("widowed (assuming framePointer valid)");
			cr();
		}
		print("sender   ");
		printNum(sender);
		print(" (");
		printHexPtrnp(
			(/* begin withoutSmallIntegerTags: */
				assert((sender & 1)),
			pointerForOop(sender - 1 /* smallIntegerTag */)));
		printChar(')');
		cr();
		print("ip       ");
		printNum(ip);
		print(" (");
		printHexPtrnp(
			(/* begin withoutSmallIntegerTags: */
				assert((ip & 1)),
			pointerForOop(ip - 1 /* smallIntegerTag */)));
		printChar(')');
		cr();
	}
	else {
		print("sender   ");
		shortPrintOop(sender);
		print("ip       ");
		if (ip == GIV(nilObj)) {
			shortPrintOop(ip);
		}
		else {
			printNum(ip);
			print(" (");
			printNum((ip >> 1));

			/* begin space */
			printChar(' ');
			printHex((ip >> 1));
			printChar(')');
			cr();
		}
	}
	sp = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
	print("sp       ");
	printNum((sp >> 1));
	print(" (");
	printHex(sp);
	printChar(')');
	cr();
	print("method   ");

	/* begin printMethodFieldForPrintContext: */
	theMethod = longAt((aContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	fprintf(GIV(transcript),
			"%p: ",
			((void *)theMethod));
	shortPrintOop(theMethod);
	print("closure  ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + ((((usqInt)(ClosureIndex) << (shiftForWord()))))));
	print("receiver ");
	shortPrintOop(longAt((aContext + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord()))))));
	sp = (sp >> 1);
	sp = ((sp < ((lengthOf(aContext)) - ReceiverIndex)) ? sp : ((lengthOf(aContext)) - ReceiverIndex));
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);

		/* begin space */
		printChar(' ');
		shortPrintOop(longAt((aContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord()))))));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printExternalHeadFrame */
void
printExternalHeadFrame(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer));
}

	/* StackInterpreter>>#printFrameAndCallers:SP:short: */
static NoDbgRegParms sqInt
printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(/* couldBeFramePointer: */
			(((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	if (longAt(theFP + FoxSavedFP)) {
		printFrameAndCallersSPshort(pointerForOop(longAt(theFP + FoxSavedFP)), frameCallerSP(theFP), printShort);
	}
	if (printShort) {
		shortPrintFrame(theFP);
		return null;
	}
	cr();
	printFrameWithSP(theFP, theSP);
	return 0;
}

	/* StackInterpreter>>#printFrameFlagsForFP: */
static NoDbgRegParms void
printFrameFlagsForFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *address;
    sqInt it;

	address = theFP + FoxFrameFlags;
	it = longAt(address);

	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%10p:",
			((void *)address));
	fprintf(GIV(transcript),
			"       flags: %p",
			((void *)it));
	if (it) {
		fprintf(GIV(transcript),
				"=%d",
				((int) it));
	}
	fprintf(GIV(transcript),
			"  numArgs: %d %sContext %sBlock\n",
			((int) (byteAt((theFP + FoxFrameFlags) + 1))),
			(byteAt((theFP + FoxFrameFlags) + 2)
			? "is"
			: "no"),
			(byteAt((theFP + FoxFrameFlags) + 3)
			? "is"
			: "not"));
}

	/* StackInterpreter>>#printFrameOop:at: */
static NoDbgRegParms void
printFrameOopat(char *name, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);

	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%10p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %10p\t=" /* pst: */,
			name,
			((void *)it));
	printOopShortInner(it);
	cr();
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFramesInPage: */
void
printFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 0);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFramesOnStackPageListInUse */
void
printFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = GIV(mostRecentlyUsedPage);
	do {
		if (!(isFree(page))) {
			print("page ");
			printHexPtrnp(page);
			cr();
			printFramesInPage(page);
			cr();
		}
	} while(((page = (page->prevPage))) != (GIV(mostRecentlyUsedPage)));
}

	/* StackInterpreter>>#printFrameThing:andFrame:at: */
static NoDbgRegParms void
printFrameThingandFrameat(char *name, char *theFP, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);

	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%10p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %10p" /* pst: */,
			name,
			((void *)it));
	if (it) {
		if (it == GIV(nilObj)) {
			fprintf(GIV(transcript), "=nil");
		}
		else {
			fprintf(GIV(transcript),
					"=%" PRIdSQINT "",
					it);
		}
	}
	fprintf(GIV(transcript),
			" frame: %p\n",
			theFP);
}

	/* StackInterpreter>>#printFrameThing:at:extraString: */
static NoDbgRegParms void
printFrameThingatextraString(char *name, char *address, char *extraStringOrNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt it;

	it = longAt(address);

	/* begin printFrameAddress: */
	fprintf(GIV(transcript),
			"%10p:",
			((void *)address));
	fprintf(GIV(transcript),
			"%12s: %10p" /* pst: */,
			name,
			((void *)it));
	framePrintDescription(it);
	if (extraStringOrNil) {
		fprintf(GIV(transcript),
				"%s",
				extraStringOrNil);
	}
	cr();
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFrame: */
sqInt
printFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *frameAbove;
    char *prevFrame;
    char *startFrame;
    StackPage *thePage;
    char *theSP;

	if (!(/* couldBeFramePointer: */
			(((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		if ((/* addressCouldBeObj: */
			(((((sqInt)theFP)) & 3) == 0)
		 && (((((usqInt)(((sqInt)theFP)))) >= (startOfMemory()))
		 && (((((usqInt)(((sqInt)theFP)))) < GIV(freeStart))
		 && (((longAt(((sqInt)theFP))) & TypeMask) != HeaderTypeGC))))
		 && ((/* isInMemory: */
			(oopisGreaterThanOrEqualTo(((sqInt)theFP), startOfMemory()))
		 && (oopisLessThan(((sqInt)theFP), GIV(endOfMemory))))
		 && ((((((usqInt)((longAt(((sqInt)theFP))))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)
		 && (checkIsStillMarriedContextcurrentFP(((sqInt)theFP), GIV(framePointer)))))) {
			return printFrame(frameOfMarriedContext(((sqInt)theFP)));
		}
		fprintf(GIV(transcript),
				"%p is not in the stack zone?!\n",
				theFP);
		return null;
	}
	frameAbove = null;
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		if (isFree(thePage)) {
			fprintf(GIV(transcript),
					"%p is on a free page?!\n",
					theFP);
			return null;
		}
		if ((thePage != GIV(stackPage))
		 && (theFP == ((thePage->headFP)))) {
			theSP = (thePage->headSP);
		}
		else {
			startFrame = ((thePage == GIV(stackPage))
				 && (((GIV(framePointer) >= ((thePage->realStackLimit))) && (GIV(framePointer) <= ((thePage->baseAddress)))))
						? GIV(framePointer)
						: (thePage->headFP));

			/* begin safeFindFrameAbove:on:startingFrom: */
			prevFrame = ((char *) 0);
			assert(!(isFree(thePage)));
			if (startFrame == theFP) {
				frameAbove = null;
				goto l1;
			}
			aFrame = startFrame;
			while (1) {
				prevFrame = aFrame;
				aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
				if (!(aFrame != 0)) break;
				if (theFP == aFrame) {
					frameAbove = prevFrame;
					goto l1;
				}
			}
			frameAbove = null;
l1:	/* end safeFindFrameAbove:on:startingFrom: */;
			theSP = (frameAbove
						? frameCallerSP(frameAbove)
						: 0);
		}
	}
	if (!theSP) {
		fprintf(GIV(transcript), "could not find sp; using bogus value\n");
		theSP = theFP + FoxReceiver;
	}
	printFrameWithSP(theFP, theSP);
	if (frameAbove) {
		/* begin printFrameThing:at: */
		printFrameThingatextraString("frame pc", frameAbove + FoxCallerSavedIP, ((char *)null));
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printFrame:WithSP: */
sqInt
printFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *addr;
    usqInt i;
    usqInt numArgs;
    sqInt theMethod;
    sqInt topThing;

	if (!(/* couldBeFramePointer: */
			(((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		fprintf(GIV(transcript),
				"%p is not in the stack zone?!\n",
				theFP);
		return null;
	}
	theMethod = longAt(theFP + FoxMethod);
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	shortPrintFrame(theFP);
	theFP + ((FoxCallerSavedIP + BytesPerWord) + ((numArgs << (shiftForWord()))));
	/* empty frameRange:to: */
	printFrameOopat("rcvr/clsr", theFP + ((FoxCallerSavedIP + BytesPerWord) + ((numArgs << (shiftForWord())))));
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopat("arg", (theFP + FoxCallerSavedIP) + (i * BytesPerWord));
	}

	/* begin printFrameThing:at: */
	printFrameThingatextraString("cllr ip/ctxt", theFP + FoxCallerSavedIP, ((char *)null));
	printFrameThingatextraString("saved fp", theFP + FoxSavedFP, ((char *)null));
	printFrameOopat("method", theFP + FoxMethod);
	printFrameFlagsForFP(theFP);

	/* begin printFrameThing:at: */
	printFrameThingatextraString("context", theFP + FoxThisContext, ((char *)null));
	printFrameOopat("receiver", theFP + FoxReceiver);
	topThing = longAt(theSP);
	if ((topThing >= theMethod)
	 && (topThing <= (theMethod + (sizeBitsOfSafe(theMethod))))) {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}

		/* begin printFrameThing:at: */
		printFrameThingatextraString("frame ip", theSP, ((char *)null));
	}
	else {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
	}
	return 0;
}


/*	Print p in hex, unpadded, in the form 0x1234 (C)/16r1234 (here) */

	/* StackInterpreter>>#printHexPtrnp: */
static NoDbgRegParms sqInt
printHexPtrnp(void *p)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fprintf(GIV(transcript),
			"%p",
			p);
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles). In the simulator use 16r as the prefix, padding to 11 characters
	in 32-bits
	or 19 characters in 64-bits. */

	/* StackInterpreter>>#printHex: */
void
printHex(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"%10p" /* pst: */,
			((void *)n));
}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */
/*	useful for VM debugging */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt methodClassAssociation;
    sqInt oop;
    unsigned int sz;

	/* begin allObjectsDo: */
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			if ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))
			 && ((maybeSelectorOfMethod(oop)) == selector)) {

				/* try and print the key of the method class association (the name of the implementing class) */
				methodClassAssociation = methodClassAssociationOf(oop);

				/* printHexnp: */
				fprintf(GIV(transcript),
						"%p",
						((void *)oop));

				/* begin space */
				printChar(' ');
				printOopShortInner(((/* isPointers: */
					((methodClassAssociation & 1) == 0)
				 && (((((usqInt)((longAt(methodClassAssociation)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
				 && ((numSlotsOf(methodClassAssociation)) >= 2)
						? longAt((methodClassAssociation + BaseHeaderSize) + (0U << (shiftForWord())))
						: methodClassAssociation));
				cr();
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(void)
{
	printMethodCacheFor(-1);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    int i;
    sqIntptr_t m;
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;

	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || (m == thing)))))
		 && ((/* addressCouldBeOop: */
			((s & 1))
		 || (/* addressCouldBeObj: */
			((s & 3) == 0)
		 && (((((usqInt)s)) >= (startOfMemory()))
		 && (((((usqInt)s)) < GIV(freeStart))
		 && (((longAt(s)) & TypeMask) != HeaderTypeGC)))))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(c)))))) {
			n += 1;
			fprintf(GIV(transcript),
					"%d %x\n\t",
					i,
					i);
			if (((((usqInt)((longAt(s)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())) {
				fprintf(GIV(transcript),
						"%p %.*s\n",
						((void *)s),
						((int) (numBytesOfBytes(s))),
						((char *)(firstIndexableField(s))));
			}
			else {
				shortPrintOop(s);
			}

			/* begin tab */
			printChar('\t');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				printNum(c);

				/* begin space */
				printChar(' ');

				/* printHexnp: */
				fprintf(GIV(transcript),
						"%p",
						((void *)c));
				printChar(' ');
				shortPrintOop(c);
			}

			/* begin tab */
			printChar('\t');
			shortPrintOop(m);

			/* begin tab */
			printChar('\t');
			if (p > 0x400) {
				/* printHexnp: */
				fprintf(GIV(transcript),
						"%p",
						((void *)p));
			}
			else {
				printNum(p);
			}
			cr();
		}
	}
	if (n > 1) {
		printNum(n);
		cr();
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior)
{
	printMethodDictionary(longAt((behavior + BaseHeaderSize) + ((((usqInt)(MethodDictionaryIndex) << (shiftForWord()))))));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;
    int toDoLimit;

	methodArray = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(MethodArrayIndex) << (shiftForWord())))));
	toDoLimit = (numSlotsOf(dictionary)) - 1;
	for (index = SelectorStart; index <= toDoLimit; index += 1) {
		selector = longAt((dictionary + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + BaseHeaderSize) + ((((usqInt)((index - SelectorStart)) << (shiftForWord())))));

			/* begin printOopShort: */
			printOopShortInner(selector);
			fflush(GIV(transcript));
			print(" => ");

			/* begin printOopShort: */
			printOopShortInner(meth);
			fflush(GIV(transcript));
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			print(")\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static NoDbgRegParms void
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int numSlots;

	if (!GIV(classNameIndex)) {
		print("??nil cnidx??");
		return;
	}
	if ((!classOop)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class");
		return;
	}
	numSlots = numSlotsOf(classOop);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(thisClassIndex)) << (shiftForWord()))))), cnt - 1);
		print(" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class");
		}
		else {
			printStringOf(longAt((classOop + BaseHeaderSize) + ((((usqInt)(GIV(classNameIndex)) << (shiftForWord()))))));
		}
	}
}

	/* StackInterpreter>>#printNum: */
static NoDbgRegParms void
printNum(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"%" PRIdSQINT "",
			((sqInt)n));
}

	/* StackInterpreter>>#printOopShortInner: */
static NoDbgRegParms void
printOopShortInner(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classLookupKey;
    sqInt classOop;
    sqInt classOopSqInt;
    double f;
    sqInt isFloatInstanceRV;
    char *name;
    sqInt nameLen;
    sqInt oopSqInt;
    double result;

	if ((oop & 1)) {
		if ((oop & 1)) {
			fprintf(GIV(transcript),
					"%" PRIdSQINT "(0x%" PRIxSQINT ")",
					(oop >> 1),
					(oop >> 1));
			return;
		}
		fprintf(GIV(transcript),
				"unknown immediate %p",
				((void *)oop));
		return;
	}
	if (!(/* addressCouldBeObj: */
			((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		print((oop & (BytesPerWord - 1)
				? " is misaligned"
				: whereIs(oop)));
		return;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		print(" is a free chunk");
		return;
	}

	/* begin isFloatInstance: */
	classOopSqInt = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloatInstanceRV = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloatInstanceRV = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOopSqInt;
		goto l1;
	}
	isFloatInstanceRV = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloatInstanceRV = classOopSqInt == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloatInstanceRV) {
		/* begin noFailFloatValueOf: */
		assert(isFloatInstance(oop));
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		f = result;

		/* begin printFloat: */
		fprintf(GIV(transcript),
				"%g",
				f);
		return;
	}
	classOop = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
	if (!(/* addressCouldBeObj: */
			((classOop & 3) == 0)
		 && (((((usqInt)classOop)) >= (startOfMemory()))
		 && (((((usqInt)classOop)) < GIV(freeStart))
		 && (((longAt(classOop)) & TypeMask) != HeaderTypeGC))))) {
		print("a ??");
		return;
	}
	if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		return;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		return;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		return;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		return;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (!nameLen) {
		print("a ??");
		return;
	}
	name = nameOfClass(classOop);
	if ((/* isBytes: */
		((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
	 && (nameLen >= 6)) {
		if (!(strncmp((name + nameLen) - 6, "String", 6))) {

			/* strncmp is weird */
			printChar('\'');
			printStringOf(oop);
			printChar('\'');
			return;
		}
		if (!(strncmp((name + nameLen) - 6, "Symbol", 6))) {

			/* strncmp is weird */
			printChar('#');
			printStringOf(oop);
			return;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		printChar('$');
		printChar(((longAt((oop + BaseHeaderSize) + (0U << (shiftForWord())))) >> 1));
		return;
	}
	fprintf(GIV(transcript),
			"a(n) %.*s",
			((int) nameLen),
			name);
	if ((((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)
	 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
	 && (isBytes(longAt((oop + BaseHeaderSize) + ((((usqInt)(KeyIndex) << (shiftForWord()))))))))) {
		oopSqInt = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))));

		/* begin fetchClassOfNonImm: */
		classLookupKey = ((ccIndex = (((usqInt)((longAt(oopSqInt)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(oopSqInt - BaseHeaderSize)) & AllButTypeMask);
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				return;
			}
			if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
			classLookupKey = longAt((classLookupKey + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
		}
		if (includesBehaviorThatOf(classOop, classLookupKey)) {
			/* begin space */
			printChar(' ');
			printOopShortInner(longAt((oop + BaseHeaderSize) + ((((usqInt)(KeyIndex) << (shiftForWord()))))));
			print(" -> ");
			fprintf(GIV(transcript),
					"%p",
					((void *)(longAt((oop + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord()))))))));
		}
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printOop: */
void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    usqInt ccIndex;
    char *className;
    sqInt classOop;
    sqInt cls;
    sqInt column;
    usqInt fmt;
    sqInt fmtSqInt;
    sqInt header;
    sqInt index;
    sqInt isFloatInstanceRV;
    sqInt lastIndex;
    sqInt length;
    sqInt startIP;
    unsigned int sz;

	length = 0;
	if ((oop & 1)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(/* addressCouldBeObj: */
			((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if (!((cls = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(oop - BaseHeaderSize)) & AllButTypeMask)))) {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
		return;
	}
	className = nameOfClasslengthInto(cls, (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s",
			((void *)oop),
			((int) length),
			className);

	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloatInstanceRV = 0;
		goto l2;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloatInstanceRV = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l2;
	}
	isFloatInstanceRV = ClassFloatCompactIndex == ccIndex;
	goto l2;
	isFloatInstanceRV = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l2:	/* end isFloatInstance: */;
	if (isFloatInstanceRV) {
		fprintf(GIV(transcript),
				"\n%g\n",
				noFailFloatValueOf(oop));
		return;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	if (fmt > 4 /* lastPointerFormat */) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord()))))))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					((longAt(oop + BaseHeaderSize)) < 0
					? "indirect"
					: (longAt(oop + BaseHeaderSize)
							? "direct"
							: "pointer")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteString) << (shiftForWord())))))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	startIP = (fmt >= (firstCompiledMethodFormat())
				? (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) / BytesPerWord
				: numSlotsOf(oop));
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(longAt((oop + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord()))))));

			/* begin space */
			printChar(' ');
			if (!(index % 5 /* elementsPerPrintOopLine */)) {
				cr();
			}
		}
		if (lastIndex % 5 /* elementsPerPrintOopLine */) {
			cr();
		}
	}
	if (((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
		startIP = (((literalCountOf(oop)) + LiteralStart) * BytesPerOop) + 1;

		/* begin lengthOf: */
		header = longAt(oop);
		fmtSqInt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

		/* begin lengthOf:baseHeader:format: */
		if (header & TypeMask) {
			sz = header & SizeMask;
		}
		else {
			sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmtSqInt <= 4 /* lastPointerFormat */) {
			lastIndex = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l1;
		}
		lastIndex = (fmtSqInt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmtSqInt & 3));
l1:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = byteAt((oop + BaseHeaderSize) + (index - 1));
			fprintf(GIV(transcript),
					" %02x/%-+3d",
					((int) byte),
					((int) byte));
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				cr();
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			print("...");
		}
		if (!(column == 1)) {
			cr();
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			cr();
		}
	}
}


/*	print the entry and answer if it takes a parameter (as the following
	entry) 
 */

	/* StackInterpreter>>#printPrimLogEntryAt:hasParameter: */
static NoDbgRegParms sqInt
printPrimLogEntryAthasParameter(sqInt i, sqInt hasParameter)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *className;
    sqInt entryOop;
    sqInt length;
    sqInt methodClass;
    sqInt methodSel;

	length = 0;
	entryOop = GIV(primTraceLog)[i];
	if (hasParameter) {
		if (/* addressCouldBeObj: */
			((entryOop & 3) == 0)
		 && (((((usqInt)entryOop)) >= (startOfMemory()))
		 && (((((usqInt)entryOop)) < GIV(freeStart))
		 && (((longAt(entryOop)) & TypeMask) != HeaderTypeGC)))) {
			className = nameOfClasslengthInto(entryOop, (&length));
		}
		else {
			className = "bad class";
			length = 9;
		}
		fprintf(GIV(transcript),
				"%.*s\n",
				((int) length),
				className);
		return 0;
	}
	if ((entryOop & 1)) {
		if (entryOop == TraceIncrementalGC) {
			print("**IncrementalGC**\n");
			return 0;
		}
		if (entryOop == TraceFullGC) {
			print("**FullGC**\n");
			return 0;
		}
		if (entryOop == TraceCodeCompaction) {
			print("**CompactCode**\n");
			return 0;
		}
		if (entryOop == TraceStackOverflow) {
			print("**StackOverflow**\n");
			return 0;
		}
		if (entryOop == TracePrimitiveFailure) {
			print("**PrimitiveFailure** ");
			return 1;
		}
		if (entryOop == TracePrimitiveRetry) {
			print("**PrimitiveRetry**\n");
			return 0;
		}
		print("???\n");
	}
	else {
		if (/* addressCouldBeObj: */
			((entryOop & 3) == 0)
		 && (((((usqInt)entryOop)) >= (startOfMemory()))
		 && (((((usqInt)entryOop)) < GIV(freeStart))
		 && (((longAt(entryOop)) & TypeMask) != HeaderTypeGC)))) {
			if (((((usqInt)((longAt(entryOop)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {
				className = "???";
				length = 3;
				methodClass = safeMethodClassOf(entryOop);
				if (methodClass != GIV(nilObj)) {
					className = nameOfClasslengthInto(methodClass, (&length));
				}
				methodSel = findSelectorOfMethod(entryOop);
				if (methodSel == GIV(nilObj)) {
					fprintf(GIV(transcript),
							"%.*s>>(selector not found)\n",
							((int) length),
							className);
				}
				else {
					fprintf(GIV(transcript),
							"%.*s>>#%.*s\n",
							((int) length),
							className,
							((int) (numBytesOfBytes(methodSel))),
							((char *)(firstIndexableField(methodSel))));
				}
			}
			else {
				safePrintStringOf(entryOop);
				cr();
			}
		}
		else {
			fprintf(GIV(transcript),
					"%" PRIdSQINT "!!!\n",
					i);
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printProcessStack: */
void
printProcessStack(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt ctx;

	cr();
	printNameOfClasscount(/* fetchClassOf: */
		((aProcess & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(aProcess)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(aProcess - BaseHeaderSize)) & AllButTypeMask)), 5);

	/* begin space */
	printChar(' ');
	printHex(aProcess);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, aProcess));
	cr();
	ctx = longAt((aProcess + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printProcsOnList: */
sqInt
printProcsOnList(sqInt procList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstProc;
    sqInt proc;

	proc = (firstProc = longAt((procList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord()))))));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		proc = longAt((proc + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))));
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackCallStackOf: */
sqInt
printStackCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt senderOop;
    char *theFP;

	if (/* addressCouldBeObj: */
		((aContextOrProcessOrFrame & 3) == 0)
	 && (((((usqInt)aContextOrProcessOrFrame)) >= (startOfMemory()))
	 && (((((usqInt)aContextOrProcessOrFrame)) < GIV(freeStart))
	 && (((longAt(aContextOrProcessOrFrame)) & TypeMask) != HeaderTypeGC)))) {
		if ((/* isContext: */
			((aContextOrProcessOrFrame & 1) == 0)
		 && (((((usqInt)((longAt(aContextOrProcessOrFrame)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && (checkIsStillMarriedContextcurrentFP(aContextOrProcessOrFrame, null))) {
			return printStackCallStackOf(((sqInt)(frameOfMarriedContext(aContextOrProcessOrFrame))));
		}
		if (aContextOrProcessOrFrame == (activeProcess())) {
			return printStackCallStackOf(((sqInt)GIV(framePointer)));
		}
		if (couldBeProcess(aContextOrProcessOrFrame)) {
			return printCallStackOf(longAt((aContextOrProcessOrFrame + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord()))))));
		}
		return null;
	}
	theFP = ((void *)aContextOrProcessOrFrame);
	while (1) {
		context = shortReversePrintFrameAndCallers(theFP);
		if (!((((longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && ((/* begin frameOfMarriedContext: */
				(senderOop = longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))),
			assert((senderOop & 1)),
			(theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */)),
			checkIsStillMarriedContextcurrentFP(context, theFP))))) {
			return null;
		}
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPageList */
void
printStackPageList(void)
{
    StackPage *page;

	page = GIV(mostRecentlyUsedPage);
	do {
		/* begin printStackPage: */
		printStackPageuseCount(page, -1);
		cr();
	} while(((page = (page->prevPage))) != (GIV(mostRecentlyUsedPage)));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPageListInUse */
void
printStackPageListInUse(void)
{
    sqInt n;
    StackPage *page;

	page = GIV(mostRecentlyUsedPage);
	n = 0;
	do {
		if (!(isFree(page))) {
			printStackPageuseCount(page, (n += 1));
			cr();
		}
	} while(((page = (page->prevPage))) != (GIV(mostRecentlyUsedPage)));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPages */
void
printStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *page;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(i, GIV(pages));
		printStackPageuseCount(page, -1);
		cr();
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackPagesInUse */
void
printStackPagesInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt n;

	n = 0;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		if (!(isFree(stackPageAt(i)))) {
			printStackPageuseCount(stackPageAt(i), (n += 1));
			cr();
		}
	}
}

	/* StackInterpreter>>#printStackPage:useCount: */
static NoDbgRegParms void
printStackPageuseCount(StackPage *page, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	print("page ");
	printHexPtrnp(page);
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((page->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	if (n >= 0) {
		print(",");
		printNum(n);
	}
	print(")  (trace: ");
	printNum((page->trace));
	printChar(')');
	if (isFree(page)) {
		print(" (free)");
	}
	if (page == (GIV(mostRecentlyUsedPage))) {
		print(" (MRU)");
	}
	if (((page->prevPage)) == (GIV(mostRecentlyUsedPage))) {
		print(" (LRU)");
	}
	cr();

	/* begin tab */
	printChar('\t');
	print("ba: ");
	printHexPtrnp((page->baseAddress));
	print(" - sl: ");
	printHexPtrnp((page->realStackLimit));
	print(" - sl-so: ");
	printHexPtrnp(((page->realStackLimit)) - (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord));
	print(" - la:");
	printHexPtrnp((page->lastAddress));
	if (!(isFree(page))) {
		cr();

		/* begin tab */
		printChar('\t');
		print("baseFP ");
		printHexPtrnp((page->baseFP));

		/* begin tab */
		printChar('\t');
		print("headFP ");
		printHexPtrnp((page->headFP));

		/* begin tab */
		printChar('\t');
		print("headSP ");
		printHexPtrnp((page->headSP));
	}
	cr();

	/* begin tab */
	printChar('\t');
	print("prev ");
	printHexPtrnp(page->prevPage);
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((((page->prevPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	printChar(')');

	/* begin tab */
	printChar('\t');
	print("next ");
	printHexPtrnp(page->nextPage);
	print(" (");
	printNum(pageIndexForstackMemorybytesPerPage((((page->nextPage))->realStackLimit), GIV(stackMemory), GIV(bytesPerPage)));
	printChar(')');
	cr();
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printStackReferencesTo: */
void
printStackReferencesTo(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	callerFP = ((char *) 0);
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((thePage->baseFP)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */
			theFP = (thePage->headFP);
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					if (oop == (longAt(theSP))) {
						fprintf(GIV(transcript),
								"FP:%p @ %p\n",
								theFP,
								theSP);
					}
					theSP += BytesPerWord;
				}
				if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
				 && (oop == (longAt(theFP + FoxThisContext)))) {
					fprintf(GIV(transcript),
							"FP:%p CTXT\n",
							theFP);
				}
				if (oop == (longAt(theFP + FoxMethod))) {
					fprintf(GIV(transcript),
							"FP:%p MTHD\n",
							theFP);
				}
				if (!(((callerFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerContext */
			theSP = theFP + FoxCallerSavedIP;
			while (theSP <= ((thePage->baseAddress))) {
				if (oop == (longAt(theSP))) {
					fprintf(GIV(transcript),
							"FP:%p @ %p\n",
							theFP,
							theSP);
				}
				theSP += BytesPerWord;
			}
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static NoDbgRegParms void
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt code;
    usqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if ((oop & 1)) {
		return;
	}
	if (!(/* addressCouldBeObj: */
			((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		return;
	}
	fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
	if (fmt < (firstByteFormat())) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOf(oop)))) ? ((max = 128)) : ((len = lengthOf(oop))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteArray) << (shiftForWord()))))), GIV(classByteArrayCompactIndex)))
	 || (/* isLargeIntegerInstance: */
		(isInstanceOfClassLargePositiveInteger(oop))
	 || (isInstanceOfClassLargeNegativeInteger(oop)))) {
		while (i < cnt) {
			printHex(byteAt((oop + BaseHeaderSize) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			code = byteAt((oop + BaseHeaderSize) + i);
			switch (code) {
			case 10:
				print("<LF>");
				break;
			case 13:
				print("<CR>");
				break;
			default:
				printChar(code);
			}
			i += 1;
		}
	}
	if (len > max) {
		print("...");
	}

	/* begin flush */
	fflush(GIV(transcript));
}

	/* StackInterpreter>>#print: */
void
print(char *s)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(GIV(transcript),
			"%s",
			s);
}

	/* StackInterpreter>>#pushBool: */
void
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	object = /* booleanObjectOf: */
			(trueOrFalse
				? GIV(trueObj)
				: GIV(falseObj));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

	/* StackInterpreter>>#pushedReceiverOrClosureOfFrame: */
static NoDbgRegParms sqInt
pushedReceiverOrClosureOfFrame(char *theFP)
{
	return longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))))));
}

	/* StackInterpreter>>#pushFloat: */
void
pushFloat(double f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	object = floatObjectOf(f);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* StackInterpreter>>#pushInteger: */
sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)integerValue << 1) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#push: */
void
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Append aLong to aFile in this platform's 'natural' byte order. aLong is
	either 32 or 64 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putLong:toFile: */
static NoDbgRegParms void
putLongtoFile(sqInt aLong, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aLong), sizeof(sqInt), 1, aFile);

	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platform's 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putShort:toFile: */
static NoDbgRegParms void
putShorttoFile(short aShort, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aShort), sizeof(short), 1, aFile);

	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

	/* StackInterpreter>>#putToSleep:yieldingIf: */
static NoDbgRegParms void
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + ((((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	priority = (oop >> 1);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));

	/* begin fetchPointer:ofObject: */
	processLists = longAt((oop + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	processList = longAt((processLists + BaseHeaderSize) + ((((usqInt)((priority - 1)) << (shiftForWord())))));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList);
	}
	else {
		/* begin addFirstLink:toList: */
		assert(!(isForwarded(processList)));
		assert((fetchPointerofObject(NextLinkIndex, aProcess)) == (nilObject()));
		firstLink = longAt((processList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))));
		assert(firstLink != aProcess);

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(processList, GIV(youngStart))) {
			possibleRootStoreIntovalue(processList, aProcess);
		}
		longAtput((processList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))), aProcess);
		if (firstLink == GIV(nilObj)) {

			/* a.k.a. (self isEmptyList: aList) */
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(processList, GIV(youngStart))) {
				possibleRootStoreIntovalue(processList, aProcess);
			}
			longAtput((processList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(aProcess, GIV(youngStart))) {
				possibleRootStoreIntovalue(aProcess, firstLink);
			}
			longAtput((aProcess + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))), firstLink);
		}

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aProcess, GIV(youngStart))) {
			possibleRootStoreIntovalue(aProcess, processList);
		}
		longAtput((aProcess + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))), processList);
	}
}


/*	Append aWord32 to aFile in this platform's 'natural' byte order. aWord32
	is 32 bits,
	depending on ObjectMemory. (Bytes will be swapped, if necessary, when the
	image is read
	on a different platform.) Set successFlag to false if the write fails. */

	/* StackInterpreter>>#putWord32:toFile: */
static NoDbgRegParms void
putWord32toFile(int aWord32, sqImageFile aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite((&aWord32), 4, 1, aFile);

	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Return the integer value of the field without verifying that it is an
	integer value! For use in time-critical places where the integer-ness of
	the field can be guaranteed.
 */

	/* StackInterpreter>>#quickFetchInteger:ofObject: */
static NoDbgRegParms sqInt
quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt oop;

	oop = longAt((objectPointer + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));
	assert((oop & 1));
	return (oop >> 1);
}


/*	Anwer if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == 6505 /* imageFormatVersion */)
	 || (imageVersion == 6504 /* imageFormatCompatibilityVersion */);
}

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt aValue;
    sqInt bytesRead;
    sqInt bytesToShift;
    usqInt ccIndex;
    sqInt cct;
    sqInt classArrayClass;
    sqInt classArrayObj;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt hdrEdenBytes;
    usqInt hdrMaxExtSemTabSize;
    usqInt hdrNumStackPages;
    sqInt header;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    usqInt heapSize;
    sqInt i;
    sqInt index;
    usqInt mem;
    sqInt memEnd;
    sqInt memLimit;
    usqInt minimumMemory;
    sqInt oop;
    sqInt rawVersion;
    int swapBytes;
    unsigned int sz;
    int toDoLimit;
    int toDoLimit1;
    sqInt version;
    int w;
    unsigned short w1;
    sqInt wSqInt;

	rawVersion = 0;
	GIV(transcript) = stdout;
	GIV(metaclassNumSlots) = 6;
	GIV(classNameIndex) = 6;
	version = checkImageVersionFromstartingAtassignRawVersion(f, imageOffset, (&rawVersion));
	if (!version) {
		/* begin bailOutOfImageLoad: */
		fprintf(stderr,
				"This ver %d vm cannot read ver %" PRIdSQINT " image file %s\n",
				6505 /* imageFormatVersion */,
				rawVersion,
				getImageName());
	}
	swapBytes = rawVersion != version;
	GIV(multipleBytecodeSetsActive) = ((version & MultipleBytecodeSetsBitmask) != 0);
	headerStart = (sqImageFilePosition(f)) - 4;

	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	headerSize = (swapBytes
				? SQ_SWAP_4_BYTES(w)
				: w);

	/* begin getLongFromFile:swap: */
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	dataSize = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);

	/* begin getLongFromFile:swap: */
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	GIV(oldImageBaseAddress) = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);

	/* begin getLongFromFile:swap: */
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	anObject = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);

	/* begin specialObjectsOop: */
	GIV(specialObjectsOop) = anObject;
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	aValue = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);

	/* begin lastHash: */
	GIV(lastHash) = aValue;
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	GIV(savedWindowSize) = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);

	/* begin getLongFromFile:swap: */
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	headerFlags = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);

	/* begin setImageHeaderFlagsFrom: */
	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;

	/* processHasThreadAffinity := headerFlags anyMask: 4. specific to CoInterpreterMT */
	/* flagInterpretedMethods := headerFlags anyMask: 8. specific to CoInterpreter */
	GIV(imageFloatsBigEndian) = ((!(headerFlags & 2))
				? 1
				: 0);

	/* noThreadingOfGUIThread := headerFlags anyMask: 32. specific to CoInterpreterMT */
	GIV(preemptionYields) = (!(headerFlags & 16));
	GIV(newFinalization) = ((headerFlags & 64) != 0);
	sendWheelEvents = ((headerFlags & 128) != 0);
	if (primitiveDoMixedArithmetic < 0) {

		/* i.e. has it not been set on the command line? */
		primitiveDoMixedArithmetic = (!(headerFlags & 0x100));
	}
	if (upscaleDisplayIfHighDPI < 0) {

		/* i.e. has it not been set on the command line? */
		upscaleDisplayIfHighDPI = (!(headerFlags & 0x400));
	}

	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	extraVMMemory = (swapBytes
				? SQ_SWAP_4_BYTES(w)
				: w);

	/* begin getShortFromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(unsigned short), 1, f);
	hdrNumStackPages = (swapBytes
				? ((((usqInt)(w1)) >> 8) & 0xFF) | (((w1 & 0xFF) << 8))
				: w1);
	GIV(numStackPages) = (desiredNumStackPages
				? desiredNumStackPages
				: (hdrNumStackPages
						? hdrNumStackPages
						: defaultNumStackPages()));
	desiredNumStackPages = hdrNumStackPages;

	/* begin getShortFromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(unsigned short), 1, f);
	GIV(theUnknownShort) = (swapBytes
				? ((((usqInt)(w1)) >> 8) & 0xFF) | (((w1 & 0xFF) << 8))
				: w1);

	/* begin getWord32FromFile:swap: */
	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, f);
	hdrEdenBytes = (swapBytes
				? SQ_SWAP_4_BYTES(w)
				: w);
	aValue = (desiredEdenBytes
				? desiredEdenBytes
				: (hdrEdenBytes
						? hdrEdenBytes
						: defaultEdenBytes()));

	/* begin edenBytes: */
	GIV(edenBytes) = aValue;
	desiredEdenBytes = hdrEdenBytes;

	/* begin getShortFromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(unsigned short), 1, f);
	hdrMaxExtSemTabSize = (swapBytes
				? ((((usqInt)(w1)) >> 8) & 0xFF) | (((w1 & 0xFF) << 8))
				: w1);
	if (hdrMaxExtSemTabSize) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}

	/* begin getShortFromFile:swap: */
	w1 = 0;
	sqImageFileRead((&w1), sizeof(unsigned short), 1, f);
	GIV(the2ndUnknownShort) = (swapBytes
				? ((((usqInt)(w1)) >> 8) & 0xFF) | (((w1 & 0xFF) << 8))
				: w1);

	/* begin getLongFromFile:swap: */
	wSqInt = 0;
	sqImageFileRead((&wSqInt), sizeof(wSqInt), 1, f);
	firstSegSize = (swapBytes
				? 
#        if BytesPerWord == 4
					SQ_SWAP_4_BYTES(wSqInt)
#        else
					SQ_SWAP_8_BYTES(wSqInt)
#        endif
					
				: wSqInt);
	allocationReserve = interpreterAllocationReserveBytes();
	minimumMemory = (dataSize + GIV(edenBytes)) + allocationReserve;
	heapSize = (desiredHeapSize + GIV(edenBytes)) + (((desiredHeapSize - dataSize) > allocationReserve
		? 0
		: allocationReserve));
	if (heapSize < minimumMemory) {
		insufficientMemorySpecifiedError();
	}
	mem = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	if (mem) {
		memLimit = mem + heapSize;
		memEnd = mem + dataSize;

		/* begin setHeapBase:memoryLimit:endOfMemory: */
		GIV(memory) = mem;
		assert((memLimit & (BytesPerWord - 1)) == 0);
		GIV(memoryLimit) = memLimit;

		/* begin setEndOfMemory: */
		assert((memEnd & (BytesPerWord - 1)) == 0);
		GIV(endOfMemory) = memEnd;
		if (!GIV(freeStart)) {
			GIV(freeStart) = memEnd;
		}
		GIV(oldSpaceStart) = mem;
	}
	else {
		insufficientMemoryAvailableError();
	}
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = 
#    if PharoVM
			sqImageFileReadEntireImage(pointerForOop(GIV(memory)), sizeof(char), dataSize, f)
#    else
			sqImageFileRead(pointerForOop(GIV(memory)), sizeof(char), dataSize, f)
#    endif
			;
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(memory) - GIV(oldImageBaseAddress);

	/* begin initializeInterpreter: */
	interpreterProxy = sqGetInterpreterProxy();
	(&interpreterProxy);
	initializeObjectMemory(bytesToShift);

	/* begin checkAssumedCompactClasses */
	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord())))))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (2U << (shiftForWord()))))) {
		invalidCompactClassError("Array");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargeNegativeInteger) << (shiftForWord())))))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (3U << (shiftForWord()))))) {
		invalidCompactClassError("LargeNegativeInteger");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (4U << (shiftForWord()))))) {
		invalidCompactClassError("LargePositiveInteger");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (5U << (shiftForWord()))))) {
		invalidCompactClassError("Float");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassMethodContext) << (shiftForWord())))))) != (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + (13U << (shiftForWord()))))) {
		invalidCompactClassError("MethodContext");
	}

	/* begin compactIndexOfClass: */
	cct = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))));
	for (index = ((lengthOf(cct)) - 1); index >= 0; index += -2) {
		if ((longAt((cct + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))))) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassByteArray) << (shiftForWord()))))))) {
			GIV(classByteArrayCompactIndex) = index + 1;
			goto l1;
		}
	}
	GIV(classByteArrayCompactIndex) = 0;
l1:	/* end compactIndexOfClass: */;

	/* begin initializeExtraClassInstVarIndices */
	classArrayObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord())))));
	classArrayClass = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(classArrayObj)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(classArrayObj - BaseHeaderSize)) & AllButTypeMask);

	/* begin numSlotsOf: */
	header = longAt(classArrayClass);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(classArrayClass - (BytesPerWord * 2))) & AllButTypeMask);
	GIV(metaclassNumSlots) = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());

	/* default */
	GIV(thisClassIndex) = 5;
	toDoLimit = numSlotsOf(classArrayClass);
	for (i = (InstanceSpecificationIndex + 1); i <= toDoLimit; i += 1) {
		if ((longAt((classArrayClass + BaseHeaderSize) + ((((usqInt)((i - 1)) << (shiftForWord())))))) == classArrayObj) {
			GIV(thisClassIndex) = i - 1;
		}
	}

	/* default */
	GIV(classNameIndex) = 6;
	toDoLimit1 = numSlotsOf(classArrayObj);
	for (i = (InstanceSpecificationIndex + 1); i <= toDoLimit1; i += 1) {
		oop = longAt((classArrayObj + BaseHeaderSize) + ((((usqInt)((i - 1)) << (shiftForWord())))));
		if (objectequalsString(oop, "Array")) {
			GIV(classNameIndex) = i - 1;
		}
	}
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;

	/* begin initialCleanup */
	/* begin flushMethodCache */
	memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
	memset(externalPrimitiveTable, 0, MaxExternalPrimitiveTableSize * (sizeof(externalPrimitiveTable[0])));
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));

	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = ((time(NULL)) + (ioMSecs())) & 0x7FFFFFFF;
	}
	GIV(metaAccessorDepth) = -2;
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin");
	return dataSize;
}


/*	Assuming the primFailCode is non-zero, check if the method consumes the
	error code
	and if so, assign it through theSP. Then zero the primFailCode. This is
	infrequent code,
	so keep it out of the common path. */

	/* StackInterpreter>>#reapAndResetErrorCodeTo:header: */
static NoDbgRegParms NeverInline void
reapAndResetErrorCodeToheader(char *theSP, sqInt methodHeader)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt initialPC;

	assert(GIV(primFailCode) != 0);
	initialPC = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize);
	if ((byteAt(initialPC)) == LongStoreBytecode) {
		longAtPointerput(theSP, getErrorObjectFromPrimFailCode());
	}
	GIV(primFailCode) = 0;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

	/* StackInterpreter>>#reestablishContextPriorToCallback: */
sqInt
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt senderOop;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;

	flag("obsolete");
	if (!(isLiveContext(callbackContext))) {
		return 0;
	}
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext);
	if (!(isLiveContext(calloutContext))) {
		return 0;
	}

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((longAt((callbackContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
		if (GIV(framePointer) == theFP) {

			/* common case */
			if (longAt(theFP + FoxSavedFP)) {

				/* calloutContext is immediately below on the same page.  Make it current. */
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(GIV(framePointer) + FoxCallerSavedIP))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((GIV(framePointer) + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				return 1;
			}
			else {
				freeStackPage(GIV(stackPage));
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext);

			/* begin markContextAsDead: */
			assert(isContext(callbackContext));

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((callbackContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((callbackContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
		}
	}
	else {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((callbackContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((callbackContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	}
	if (/* isStillMarriedContext: */
		(((longAt((calloutContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(calloutContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((calloutContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		thePage = makeBaseFrameFor(calloutContext);

		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;

	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	return 1;
}


/*	Remove the first process from the given linked list. */

	/* StackInterpreter>>#removeFirstLinkOfList: */
static NoDbgRegParms sqInt
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;

	assert(!((isForwarded(aList))));
	first = longAt((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	last = longAt((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))));
	assert(!((isForwarded(first))));
	assert(!((isForwarded(last))));
	if (first == last) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))), GIV(nilObj));
	}
	else {
		next = longAt((first + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))));

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aList, GIV(youngStart))) {
			possibleRootStoreIntovalue(aList, next);
		}
		longAtput((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))), next);
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((first + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))), GIV(nilObj));
	return first;
}


/*	Attempt to remove a process from a linked list. Answer if the attempt
	succeeded. 
 */

	/* StackInterpreter>>#removeProcess:fromList: */
static NoDbgRegParms sqInt
removeProcessfromList(sqInt aProcess, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt lastLink;
    sqInt nextLink;
    sqInt tempLink;

	nextLink = 0;
	assert(!((isForwarded(aProcess))));
	assert(!((isForwarded(aList))));
	firstLink = longAt((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))));
	lastLink = longAt((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))));
	if (aProcess == firstLink) {
		nextLink = longAt((aProcess + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))));

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(aList, GIV(youngStart))) {
			possibleRootStoreIntovalue(aList, nextLink);
		}
		longAtput((aList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))), nextLink);
		if (aProcess == lastLink) {
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))), GIV(nilObj));
		}
	}
	else {
		tempLink = firstLink;
		while (1) {
			if (!((/* isPointers: */
					((tempLink & 1) == 0)
				 && (((((usqInt)((longAt(tempLink)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
				 && ((numSlotsOf(tempLink)) > MyListIndex))) {
				return 0;
			}
			nextLink = longAt((tempLink + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))));
			if (nextLink == aProcess) break;
			tempLink = nextLink;
		}
		nextLink = longAt((aProcess + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))));

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(tempLink, GIV(youngStart))) {
			possibleRootStoreIntovalue(tempLink, nextLink);
		}
		longAtput((tempLink + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))), nextLink);
		if (aProcess == lastLink) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(aList, GIV(youngStart))) {
				possibleRootStoreIntovalue(aList, tempLink);
			}
			longAtput((aList + BaseHeaderSize) + ((((usqInt)(LastLinkIndex) << (shiftForWord())))), tempLink);
		}
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((aProcess + BaseHeaderSize) + ((((usqInt)(NextLinkIndex) << (shiftForWord())))), GIV(nilObj));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((aProcess + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))), GIV(nilObj));
	return 1;
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yiled to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect. */

	/* StackInterpreter>>#resume:preemptedYieldingIf: */
static NoDbgRegParms sqInt
resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt oop;

	/* begin activeProcess */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + BaseHeaderSize) + ((((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	activePriority = (oop >> 1);

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + BaseHeaderSize) + ((((usqInt)(PriorityIndex) << (shiftForWord())))));
	assert((oop & 1));
	newPriority = (oop >> 1);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly);
	transferTo(aProcess);
	return 1;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

	/* StackInterpreter>>#returnAs:ThroughCallback:Context: */
sqInt
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutMethodContext;
    sqInt senderOop;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;

	assert(GIV(primFailCode) == 0);
	assert((returnTypeOop & 1));
	assert(!(isImmediate(((sqInt)vmCallbackContext))));
	assert((addressCouldBeObj(callbackMethodContext))
	 && (isContext(callbackMethodContext)));
	assert(((debugCallbackPath = 0)) == 0);
	if (!(((returnTypeOop & 1))
		 && (isLiveContext(callbackMethodContext)))) {
		assert(((debugCallbackPath = 1)) == 1);
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext);
	if (!(isLiveContext(calloutMethodContext))) {
		assert(((debugCallbackPath = 2)) == 2);
		return 0;
	}
	assert(((debugCallbackReturns += 1)) > 0);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((longAt((callbackMethodContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1) {
		assert(((debugCallbackPath = debugCallbackPath | 8)) > 0);

		/* begin frameOfMarriedContext: */
		senderOop = longAt((callbackMethodContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
		assert((frameReceiver(theFP)) == (splObj(ClassAlien)));
		if (GIV(framePointer) == theFP) {

			/* common case */
			assert(((debugCallbackPath = debugCallbackPath | 16)) > 0);
			if (longAt(theFP + FoxSavedFP)) {

				/* calloutMethodContext is immediately below on the same page.  Make it current. */
				assert(((debugCallbackPath = debugCallbackPath | 32)) > 0);
				GIV(instructionPointer) = ((usqInt)(pointerForOop(longAt(theFP + FoxCallerSavedIP))));
				GIV(stackPointer) = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
				GIV(framePointer) = pointerForOop(longAt(theFP + FoxSavedFP));

				/* begin setMethod: */
				GIV(method) = longAt(GIV(framePointer) + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));

				/* begin restoreCStackStateForCallbackContext: */
				memcpy(GIV(reenterInterpreter), ((void *)((vmCallbackContext->savedReenterInterpreter))), sizeof(jmp_buf));
				assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1 /* (isMachineCodeFrame: not) */, __LINE__);
				_longjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
				return 1;
			}
			freeStackPage(GIV(stackPage));
		}
		else {
			assert(((debugCallbackPath = debugCallbackPath | 64)) > 0);
			externalDivorceFrameandContext(theFP, callbackMethodContext);

			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext));

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((callbackMethodContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((callbackMethodContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
		}
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 4)) > 0);

		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((callbackMethodContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((callbackMethodContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
	}
	if (/* isStillMarriedContext: */
		(((longAt((calloutMethodContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(calloutMethodContext)))) {
		assert(((debugCallbackPath = debugCallbackPath | 128)) > 0);

		/* begin frameOfMarriedContext: */
		senderOop = longAt((calloutMethodContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (((thePage->headFP)) == theFP
					? (thePage->headSP)
					: (findSPOfon(theFP, thePage)) - BytesPerWord);
		GIV(framePointer) = theFP;
		assert(GIV(stackPointer) < GIV(framePointer));
	}
	else {
		assert(((debugCallbackPath = debugCallbackPath | 0x100)) > 0);
		thePage = makeBaseFrameFor(calloutMethodContext);

		/* begin setStackPointersFromPage: */
		GIV(stackPointer) = (thePage->headSP);
		GIV(framePointer) = (thePage->headFP);
	}

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;

	/* begin setMethod: */
	GIV(method) = longAt((calloutMethodContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord())))));
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));

	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);

	/* begin restoreCStackStateForCallbackContext: */
	memcpy(GIV(reenterInterpreter), ((void *)((vmCallbackContext->savedReenterInterpreter))), sizeof(jmp_buf));
	_longjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
	return 1;
}


/*	Reverse the given range of Display pixels, rounded to whole word boundary.
	Used to give feedback during VM activities such as garbage collection when
	debugging. It is assumed that the given word range falls entirely within
	the first line of the Display. */

	/* StackInterpreter>>#reverseDisplayFrom:to: */
static NoDbgRegParms void
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt primFailCodeValue;
    sqInt ptr;
    unsigned int reversed;
    sqInt toDoLimit;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	if (!(postGCUpdateDisplayBits())) {
		return;
	}
	if ((displayBits == 0)
	 || ((((((sqInt)displayBits)) & 1))
	 || (displayDepth <= 0))) {
		return;
	}
	wordStartIndex = ((((startIndex < 0) ? 0 : startIndex)) * displayDepth) / 32;
	wordEndIndex = ((((endIndex < displayWidth) ? endIndex : displayWidth)) * displayDepth) / 32;
	toDoLimit = (((sqInt)displayBits)) + (wordEndIndex * 4);
	for (ptr = ((((sqInt)displayBits)) + (wordStartIndex * 4)); ptr <= toDoLimit; ptr += 4) {
		reversed = (long32At(ptr)) ^ 0xFFFFFFFFU;
		long32Atput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	updateDisplayLeftTopRightBottom(0, 0, displayWidth, 1);
	ioForceDisplayUpdate();
	GIV(primFailCode) = primFailCodeValue;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims. */

	/* StackInterpreter>>#rewriteMethodCacheEntryForExternalPrimitiveToFunction: */
static NoDbgRegParms void
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)())
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((sqIntptr_t) localPrimAddress));
	}
}


/*	Safe version of methodClassOf: that deals with malformed compiled methods,
	etc, and does not fixup forwarding pointers.. */

	/* StackInterpreter>>#safeMethodClassOf: */
static NoDbgRegParms sqInt
safeMethodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt maybeClass;
    sqInt offset;

	offset = (literalCountOf(methodPointer)) - 1;

	/* begin literal:ofMethod: */
	literal = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
	if (!((/* isPointers: */
			((literal & 1) == 0)
		 && (((((usqInt)((longAt(literal)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && ((numSlotsOf(literal)) > ValueIndex))) {
		return GIV(nilObj);
	}
	maybeClass = longAt((literal + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	return maybeClass;
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the 1 arg
	invokeCallbackContext: or the 4 arg invokeCallback:stack:registers:jmpbuf:
	message, depending on what selector is installed in the
	specialObjectsArray. Note that if invoking the
	legacy invokeCallback:stack:registers:jmpbuf: we pass the
	vmCallbackContext as the jmpbuf
	argument (see reestablishContextPriorToCallback:). The arguments are raw C
	addresses and
	are converted to integer objects on the way. sendInvokeCallbackContext: &
	returnAs:ThroughCallback:Context: along with ownVM: and disownVM: conspire
	to save and
	restore newMethod, argumentCount and primitiveFunctionPointer around a
	callback. The VM depends on argumentCount being correct to cut-back the
	correct number of
	arguments on primitive return. Since this is an implicit send we need to
	log it explicitly.
	The return side is done via a primitive so that gets logged normally. */

	/* StackInterpreter>>#sendInvokeCallbackContext: */
sqInt
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classTag;
    usqInt i;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt oop;
    sqInt rcvr;
    char *sp;

	oop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord())))));

	/* begin fetchClassTagOfNonImm: */
	classTag = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SelectorInvokeCallback) << (shiftForWord())))));
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if (lookupOrdinaryNoMNUEtcInClass(classTag)) {
			return 0;
		}
	}
	assert(((debugCallbackInvokes += 1)) > 0);

	/* begin saveCStackStateForCallbackContext: */
	memcpy(((void *)((vmCallbackContext->savedReenterInterpreter))), GIV(reenterInterpreter), sizeof(jmp_buf));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassAlien) << (shiftForWord()))))));
	GIV(stackPointer) = sp;
	if ((argumentCountOf(GIV(newMethod))) == 4) {
		object = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->thunkp))));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		object = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->stackp))));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		object = positiveMachineIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	object = positiveMachineIntegerFor(((usqInt)vmCallbackContext));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin justActivateNewMethod: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
				: ((1 + ((numArgs << 8)))));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode)) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}

	/* begin checkForStackOverflow */
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (GIV(stackPointer) < ((GIV(stackPage)->realStackLimit))) {
		handleStackOverflow();
	}
	assert((frameReceiver(GIV(framePointer))) == (splObj(ClassAlien)));

	/* begin enterSmalltalkExecutiveFromCallback */
	enterSmalltalkExecutive();
	return 1;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#setBreakMNUSelector: */
void
setBreakMNUSelector(char *aString)
{
	if ((breakSelector = aString)) {
		breakSelectorLength = -(strlen(aString));
	}
	else {
		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#setBreakSelector: */
void
setBreakSelector(char *aString)
{
	if ((breakSelector = aString)) {
		breakSelectorLength = strlen(aString);
	}
	else {
		/* nil's effective length is zero */
		breakSelectorLength = MinSmallInteger;
	}
}

	/* StackInterpreter>>#setFullScreenFlag: */
void
setFullScreenFlag(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(fullScreenFlag) = value;
}

	/* StackInterpreter>>#setInterruptCheckChain: */
void *
setInterruptCheckChain(void (*aFunction)())
{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

	/* StackInterpreter>>#setInterruptKeycode: */
void
setInterruptKeycode(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptKeycode) = value;
}

	/* StackInterpreter>>#setInterruptPending: */
void
setInterruptPending(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	forceInterruptCheck();
	GIV(interruptPending) = value;
}

	/* StackInterpreter>>#setNextWakeupUsecs: */
void
setNextWakeupUsecs(usqLong value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(nextWakeupUsecs) = value;
}

	/* StackInterpreter>>#setSavedWindowSize: */
void
setSavedWindowSize(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

	/* StackInterpreter>>#setSignalLowSpaceFlagAndSaveProcess */
static void
setSignalLowSpaceFlagAndSaveProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;
    sqInt oop;

	/* signalLowSpace: */
	GIV(signalLowSpace) = 1;

	/* lowSpaceThreshold: */
	GIV(lowSpaceThreshold) = 0;
	lastSavedProcess = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ProcessSignalingLowSpace) << (shiftForWord())))));
	if (lastSavedProcess == GIV(nilObj)) {
		/* begin activeProcess */
		oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
		activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));

		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
			possibleRootStoreIntovalue(GIV(specialObjectsOop), activeProc);
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ProcessSignalingLowSpace) << (shiftForWord())))), activeProc);
	}
	forceInterruptCheck();
}

	/* StackInterpreter>>#setTraceFlagOnContextsFramesPageIfNeeded: */
static NoDbgRegParms void
setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *pointer;
    sqInt senderOop;
    StackPage *thePage;

	if (/* isStillMarriedContextDuringGC: */
		(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContextDuringGC(aContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		pointer = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		assert(((((thePage->trace)) >= StackPageUnreached) && (((thePage->trace)) <= StackPageTraced)));
		if (!((thePage->trace))) {
			(thePage->trace = StackPageReachedButUntraced);
		}
	}
}

	/* StackInterpreter>>#shortPrintContext: */
static NoDbgRegParms sqInt
shortPrintContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt home;
    sqInt rcvr;
    sqInt senderOop;
    char *theFP;

	if (!(/* isContext: */
			((aContext & 1) == 0)
		 && (((((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
		printHex(aContext);

		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" is not a context");
		cr();
		return null;
	}
	printHex(aContext);
	if (((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" I (");
			printHex(((usqIntptr_t)theFP));

			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					") ");
		}
		else {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					" w ");
		}
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" s ");
	}
	home = findHomeForContext(aContext);
	if (home) {
		rcvr = longAt((home + BaseHeaderSize) + ((((usqInt)(ReceiverIndex) << (shiftForWord())))));
		printActivationNameForreceiverisBlockfirstTemporary(longAt((aContext + BaseHeaderSize) + ((((usqInt)(MethodIndex) << (shiftForWord()))))), rcvr, home != aContext, longAt((home + BaseHeaderSize) + ((((usqInt)((0 + CtxtTempFrameStart)) << (shiftForWord()))))));

		/* begin space */
		printChar(' ');
		shortPrintOop(rcvr);
	}
	else {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				" BOGUS CONTEXT (can't determine home)");
		cr();
	}
	return 0;
}

	/* StackInterpreter>>#shortPrintFrameAndCallers: */
static NoDbgRegParms sqInt
shortPrintFrameAndCallers(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(/* couldBeFramePointer: */
			(((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	shortPrintFrame(theFP);
	if (longAt(theFP + FoxSavedFP)) {
		shortPrintFrameAndCallers(pointerForOop(longAt(theFP + FoxSavedFP)));
	}
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#shortPrintFramesInPage: */
void
shortPrintFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 1);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#shortPrintFramesOnStackPageListInUse */
void
shortPrintFramesOnStackPageListInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *page;

	page = GIV(mostRecentlyUsedPage);
	do {
		if (!(isFree(page))) {
			/* begin print: */
			fprintf(GIV(transcript),
					"%s",
					"page ");
			printHexPtrnp(page);
			cr();
			shortPrintFramesInPage(page);
			cr();
		}
	} while(((page = (page->prevPage))) != (GIV(mostRecentlyUsedPage)));
}

	/* StackInterpreter>>#shortPrintFrame: */
static NoDbgRegParms sqInt
shortPrintFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt frameNumArgs;
    sqInt rcvr;

	if (!(/* couldBeFramePointer: */
			(((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		/* begin print: */
		fprintf(GIV(transcript),
				"%s",
				"invalid frame pointer");
		cr();
		return null;
	}
	rcvr = longAt(theFP + FoxReceiver);
	printHexPtrnp(theFP);

	/* begin space */
	printChar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(longAt(theFP + FoxMethod), rcvr, (byteAt((theFP + FoxFrameFlags) + 3)) != 0, /* temporary:in: */
		(0 < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
			? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
			: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord))));

	/* begin space */
	printChar(' ');
	shortPrintOop(rcvr);
	return 0;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#shortPrintFrame:AndNCallers: */
void
shortPrintFrameAndNCallers(char *theFP, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((n != 0)
	 && (/* couldBeFramePointer: */
		(((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		shortPrintFrame(theFP);
		shortPrintFrameAndNCallers(pointerForOop(longAt(theFP + FoxSavedFP)), n - 1);
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static NoDbgRegParms void
shortPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    char *className;
    sqInt length;

	length = 0;
	if ((oop & 1)) {
		/* begin printImmediateObject:on: */
		assert((oop & 1));
		fprintf(GIV(transcript),
				"%p=%" PRIdSQINT "\n",
				((void *)oop),
				((sqInt)((oop >> 1))));
		return;
	}
	if (!(/* addressCouldBeObj: */
			((oop & 3) == 0)
		 && (((((usqInt)oop)) >= (startOfMemory()))
		 && (((((usqInt)oop)) < GIV(freeStart))
		 && (((longAt(oop)) & TypeMask) != HeaderTypeGC))))) {
		/* begin printCantBeObject:on: */
		fprintf(GIV(transcript),
				"%p%s\n",
				((void *)oop),
				(oop & (BytesPerWord - 1)
				? " is misaligned"
				: whereIs(oop)));
		return;
	}
	if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	className = nameOfClasslengthInto(/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask), (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s\n",
			((void *)oop),
			((int) length),
			className);
}

	/* StackInterpreter>>#shortReversePrintFrameAndCallers: */
static NoDbgRegParms sqInt
shortReversePrintFrameAndCallers(char *aFramePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt caller;
    char *callerFP;
    char *theFP;

	callerFP = ((char *) 0);
	if (!aFramePointer) {
		return GIV(nilObj);
	}
	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP);
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	caller = longAt(theFP + FoxCallerContext);
	return caller;
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

	/* StackInterpreter>>#showDisplayBits:Left:Top:Right:Bottom: */
sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (deferDisplayUpdates
	 || (aForm != (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheDisplay) << (shiftForWord())))))))) {
		return null;
	}
	updateDisplayLeftTopRightBottom(l, t, r, b);
	return 0;
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

	/* StackInterpreter>>#signalExternalSemaphores */
static sqInt
signalExternalSemaphores(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ExternalObjectsArray) << (shiftForWord())))));
	return doSignalExternalSemaphores(numSlotsOf(xArray));
}


/*	Answer a full 32 bit integer object for the given integer value.
	N.B. Returning in each arm separately enables Slang inlining.
	/Don't/ return the ifTrue:ifFalse: unless Slang inlining of conditionals
	is fixed. */

	/* StackInterpreter>>#signed32BitIntegerFor: */
sqInt
signed32BitIntegerFor(sqInt integerValue)
{
	if ((((sqInt)((((usqInt)integerValue)) ^ (((((usqInt)integerValue)) << 1))))) >= 0) {
		return (((usqInt)integerValue << 1) | 1);
	}
	return noInlineSigned32BitIntegerGutsFor(integerValue);
}


/*	Answer a Large Integer object for the given integer value. N.B. will *not*
	cause a GC. */

	/* StackInterpreter>>#signed64BitIntegerFor: */
sqInt
signed64BitIntegerFor(sqLong integerValue)
{
    usqInt highWord;
    sqInt largeClass;
    usqLong magnitude;
    sqInt newLargeInteger;
    sqInt sz;

	if (integerValue < 0) {
		if (integerValue >= (MinSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 1) | 1);
		}
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		magnitude = 0 - (((usqLong) integerValue));
	}
	else {
		if (integerValue <= (MaxSmallInteger)) {
			return (((usqInt)(((sqInt)integerValue)) << 1) | 1);
		}
		largeClass = ClassLargePositiveIntegerCompactIndex;
		magnitude = integerValue;
	}
	if ((highWord = (magnitude) >> 32)) {
		sz = 5;
		if ((highWord = (highWord) >> 8)) {
			sz += 1;
			if ((highWord = (highWord) >> 8)) {
				sz += 1;
				if ((highWord = (highWord) >> 8)) {
					sz += 1;
				}
			}
		}
	}
	else {
		sz = 4;
	}
	newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(largeClass, (firstByteFormat()) + ((4 - sz) & 3), (sz + 3) / BytesPerOop);
	if (sz > 4) {
		/* begin storeLong64:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude));
		long32Atput(((newLargeInteger + BaseHeaderSize)) + 4, ((SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude))) >> 32);
		SQ_SWAP_8_BYTES_IF_BIGENDIAN(magnitude);
	}
	else {
		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(magnitude));
	}
	return newLargeInteger;
}


/*	Answer the size of the CallPrimitive bytecode that may be used to store a
	method's primitive.
 */
/*	NewsqueakV4:	249	11111001	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */
/*	SistaV1:		248	11111000 iiiiiiii	mssjjjjj	Call Primitive #iiiiiiii + (
	jjjjj * 256) */
/*	V3+Closures:	139	11101111	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 0;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

	/* StackInterpreter>>#sizeOfSTArrayFromCPrimitive: */
sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt header;
    sqInt oop;
    unsigned int sz;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(/* isWordsOrBytes: */
			((oop & 1) == 0)
		 && (isWordsOrBytesNonImm(oop)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}

	/* begin lengthOf: */
	header = longAt(oop);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (header & TypeMask) {
		sz = header & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		return ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	}
	return (fmt < (firstByteFormat())
			? ((usqInt)((sz - BaseHeaderSize))) >> 2
			: (sz - BaseHeaderSize) - (fmt & 3));
}


/*	Invoke a normal (non-quick) primitive.
	Called under the assumption that primFunctionPointer has been preloaded. */

	/* StackInterpreter>>#slowPrimitiveResponse */
static int
slowPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
	assert((GIV(remapBufferCount)) == 0);

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	if (LOGPRIMITIVES) {
		/* begin fastLogPrim: */
		GIV(primTraceLog)[GIV(primTraceLogIndex)] = GIV(newMethod);
		primTraceLogIndex(GIV(primTraceLogIndex) + 1);
	}
	dispatchFunctionPointer(primitiveFunctionPointer);
	assert(maybeLeakCheckExternalPrimCall(GIV(newMethod)));

	/* begin maybeRetryPrimitiveOnFailure */
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	return !GIV(primFailCode);
}


/*	update state of active context */

	/* StackInterpreter>>#snapshot: */
static NoDbgRegParms sqInt
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    usqInt i;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt oop;
    sqInt rcvr;
    sqInt rcvrSqInt;
    void *setMacType;
    char *sp;
    sqInt stackIndex;


	/* For now the stack munging below doesn't deal with more than one argument.
	   It can, and should. */
	rcvr = 0;
	if (GIV(argumentCount)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* update state of active process */
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(1);

	/* begin activeProcess */
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	activeProc = longAt((oop + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(activeProc, GIV(youngStart))) {
		possibleRootStoreIntovalue(activeProc, activeContext);
	}
	longAtput((activeProc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);
	GIV(tempOop) = activeContext;

	/* begin garbageCollectForSnapshot */
	incrementalGC();
	fullGC();
	clearRootsTable();
	activeContext = GIV(tempOop);
	GIV(tempOop) = 0;
	if (!GIV(primFailCode)) {

		/* Without contexts or stacks simulate
		   rcvr := self popStack. ''pop rcvr''
		   self push: trueObj.
		   to arrange that the snapshot resumes with true.  N.B. stackIndex is one-relative. */
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		assert((oop & 1));
		stackIndex = (oop >> 1);
		rcvr = longAt((activeContext + BaseHeaderSize) + ((((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())))));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((activeContext + BaseHeaderSize) + ((((usqInt)(((stackIndex + CtxtTempFrameStart) - 1)) << (shiftForWord())))), GIV(trueObj));
		writeImageFileIO();
		if ((!GIV(primFailCode))
		 && (!embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */
			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (setMacType) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((activeContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)(stackIndex - 1) << 1) | 1));
	}
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
	if (GIV(primFailCode)) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp;

		/* begin justActivateNewMethod: */
		/* begin methodHeaderOf: */
		assert(isCompiledMethod(GIV(newMethod)));
		methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
		numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
		numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

		/* could new rcvr be set at point of send? */
		rcvrSqInt = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		assert(!(isOopForwarded(rcvrSqInt)));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp;
		GIV(framePointer) = GIV(stackPointer);

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp;

		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method)));
		assert((methodHeaderOf(GIV(method))) == methodHeader);
		assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
		object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
				(VMBIGENDIAN
					? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
					: ((1 + ((numArgs << 8)))));

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvrSqInt);
		GIV(stackPointer) = sp;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
		if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
			GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
			if (GIV(primFailCode)) {
				reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
			}
		}
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp;
	}
	return 0;
}

	/* StackInterpreter>>#specialSelector: */
sqInt
specialSelector(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin fetchPointer:ofObject: */
	return longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((index * 2)) << (shiftForWord())))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackFloatValue: */
double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt classOop;
    sqInt isFloat;
    sqInt oop;
    double result;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));

	/* begin floatValueOf: */
	/* begin isFloatInstance: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassFloat) << (shiftForWord())))));
	if ((oop & 1)) {
		isFloat = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((oop & 1)));
	ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isFloat = ((longAt(oop - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;
	isFloat = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isFloatInstance: */;
	if (isFloat) {
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackIntegerValue: */
sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));

	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Answer the actual stackLimit offset in a page. Since stackPageByteSize may
	have chosen to shrink a page
	this may be less than stackPageFrameBytes, but it should be no more than
	stackPageFrameBytes. 
 */

	/* StackInterpreter>>#stackLimitBytes */
static sqInt
stackLimitBytes(void)
{
	return (((stackPageFrameBytes()) < (((stackPageByteSize()) - (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord)))) ? (stackPageFrameBytes()) : (((stackPageByteSize()) - (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord))));
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	method header fields
	context (uninitialized)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

	/* StackInterpreter>>#stackLimitOffset */
static int
stackLimitOffset(void)
{
	return ((FrameSlots + LargeContextSlots) + 1) * BytesPerWord;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackObjectValue: */
sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer a page size that is a power-of-two and contains a useful number of
	frames. Room for 256 slots for frames gives around 40 frames a page which
	is a
	good compromise between overflow rate and latency in divorcing a page. */

	/* StackInterpreter>>#stackPageByteSize */
static sqInt
stackPageByteSize(void)
{
    sqInt largeSize;
    int pageBytes;
    sqInt smallSize;

	pageBytes = ((stackPageFrameBytes()) + (((FrameSlots + LargeContextSlots) + 1) * BytesPerWord));
	if (!(pageBytes & (pageBytes - 1))) {

		/* = 0 => a power of two */
		return pageBytes;
	}
	largeSize = 1U << (highBit(pageBytes));
	smallSize = 1U << ((highBit(pageBytes)) - 1);
	assert((largeSize > pageBytes)
	 && (pageBytes > smallSize));
	return ((pageBytes - smallSize) <= (smallSize / 8)
			? smallSize
			: largeSize);
}


/*	Return a minimum amount of headroom for each stack page (in bytes).
	In a JIT the stack has to have room for interrupt handlers which will run
	on the
	stack. In the interpreter we don't actually need any headroom. */

	/* StackInterpreter>>#stackPageHeadroom */
static sqInt
stackPageHeadroom(void)
{
	return 0;
}


/*	Return the stackPointer of a Context or BlockContext. */

	/* StackInterpreter>>#stackPointerForMaybeMarriedContext: */
static NoDbgRegParms sqInt
stackPointerForMaybeMarriedContext(sqInt aContext)
{
    usqInt sp;
    sqInt spSqInt;

	if (/* isStillMarriedContext: */
		(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContext)))) {
		sp = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
		assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
		return sp;
	}

	/* begin fetchStackPointerOf: */
	spSqInt = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((spSqInt & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(aContext)));
	return (spSqInt >> 1);
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPointerIndexForFrame: */
static NoDbgRegParms usqInt
stackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *thePage;
    char *theSP;

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	theSP = findSPOfon(theFP, thePage);
	return (((usqInt)(((theFP + FoxReceiver) - theSP))) >> (shiftForWord())) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackPositiveMachineIntegerValue: */
usqIntptr_t
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    sqInt integerPointer;
    int ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));

	/* begin positiveMachineIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((integerPointer & 1)));
	ccIndex = (((usqInt)((longAt(integerPointer)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(integerPointer - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	bs = numBytesOfBytes(integerPointer);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		return SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, integerPointer)));
	}
	return ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((integerPointer + BaseHeaderSize))))));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackSignedMachineIntegerValue: */
sqIntptr_t
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	return signedMachineIntegerValueOf(integerPointer);
}

	/* StackInterpreter>>#stackTop */
sqInt
stackTop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

	/* StackInterpreter>>#stackValue: */
sqInt
stackValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
usqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return ((literalCountOf(aCompiledMethod)) + LiteralStart) * BytesPerOop;
}


/*	Return what ST would return for <obj> at: index. */

	/* StackInterpreter>>#stObject:at: */
sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    unsigned int integerValue;
    sqInt newLargeInteger;
    usqInt sp;
    sqInt spSqInt;
    sqInt stSize;
    unsigned int sz;
    sqInt totalLength;

	hdr = longAt(array);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(array)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(array - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((array + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			stSize = sp;
			goto l3;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((array + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l3;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(array)));
		stSize = (spSqInt >> 1);
l3:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (/* isStillMarriedContext: */
			(((longAt((array + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))))) {
			return temporaryin(index - 1, frameOfMarriedContext(array));
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
		(fmt >= (firstCompiledMethodFormat())
			? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			return longAt((array + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
		}
		if (fmt >= (firstByteFormat())) {
			return (((usqInt)(byteAt((array + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
		}
		integerValue = long32At((array + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			return ((integerValue << 1) | 1);
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		return newLargeInteger;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = (fmt <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
	return 0;
}


/*	Do what ST would return for <obj> at: index put: value. */

	/* StackInterpreter>>#stObject:at:put: */
sqInt
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt signedValueToStore;
    usqInt sp;
    sqInt spSqInt;
    sqInt stSize;
    unsigned int sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;

	hdr = longAt(array);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(array - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(array)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(array - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((array + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			stSize = sp;
			goto l4;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((array + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l4;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(array)));
		stSize = (spSqInt >> 1);
l4:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && (/* isStillMarriedContext: */
			(((longAt((array + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(array)))))) {
			return temporaryinput(index - 1, frameOfMarriedContext(array), value);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
		(fmt >= (firstCompiledMethodFormat())
			? (((literalCountOf(array)) + LiteralStart) * BytesPerOop) + 1
			: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(array, GIV(youngStart))) {
				possibleRootStoreIntovalue(array, value);
			}
			longAtput((array + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l2;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}
			signedValueToStore = (value >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}

			/* storeByte:ofObject:withValue: */
			byteAtput((array + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l2;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* storeLong32:ofObject:withValue: */
			long32Atput((array + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
l2:	/* end subscript:with:storing:format: */;
	}
	else {
		/* primitiveFailFor: */
		GIV(primFailCode) = (fmt <= 1
					? PrimErrBadReceiver
					: PrimErrBadIndex);
	}
	return value;
}


/*	Note: May be called by translated primitive code. */

	/* StackInterpreter>>#storeInteger:ofObject:withValue: */
sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((sqInt)((((usqInt)integerValue)) ^ (((((usqInt)integerValue)) << 1))))) >= 0) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((objectPointer + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), (((usqInt)integerValue << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

	/* StackInterpreter>>#storeSenderOfFrame:withValue: */
static NoDbgRegParms char *
storeSenderOfFramewithValue(char *theFP, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    StackPage *newPage;
    int onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;

	if (!(longAt(theFP + FoxSavedFP))) {
		/* begin frameCallerContext:put: */
		assert((anOop == (nilObject()))
		 || (isContext(anOop)));
		longAtput(theFP + FoxCallerContext, anOop);
		return theFP;
	}

	/* begin ensureCallerContext: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (!callerFP) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */
		/* frameCallerContext: */
		goto l2;
	}

	/* begin ensureFrameIsMarried:SP: */
	if (byteAt((callerFP + FoxFrameFlags) + 2)) {
		assert(isContext(frameContext(callerFP)));

		/* frameContext: */
		goto l2;
	}
	marryFrameSP(
		callerFP,
		(/* begin frameCallerStackPointer: */
			assert(!(isBaseFrame(theFP))),
		(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord));
l2:	/* end ensureCallerContext: */;

	/* begin stackPageFor: */
	thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	onCurrentPage = thePage == GIV(stackPage);
	if (!onCurrentPage) {

		/* Make sure the frame's page isn't divorced when a new page is allocated. */
		markStackPageNextMostRecentlyUsed(thePage);
	}

	/* begin newStackPage */
	newPage = (GIV(mostRecentlyUsedPage)->nextPage);
	if (!((newPage->baseFP))) {
		goto l1;
	}
	divorceFramesIn(newPage);
l1:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		assert(newPage);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
	}
	else {
		markStackPageMostRecentlyUsed(newPage);
	}
	assert(isBaseFrame(theMovedFP));

	/* begin frameCallerContext:put: */
	assert((anOop == (nilObject()))
	 || (isContext(anOop)));
	longAtput(theMovedFP + FoxCallerContext, anOop);
	return theMovedFP;
}


/*	Answer the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not an immediate! */

	/* StackInterpreter>>#stSizeOf: */
sqInt
stSizeOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    unsigned int sz;
    sqInt totalLength;

	hdr = longAt(oop);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(oop - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;
	if (/* isPureBitsFormat: */
		(fmt >= (firstLongFormat()))
	 && (fmt < (firstCompiledMethodFormat()))) {
		return totalLength;
	}

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(oop - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (fmt == (indexablePointersFormat())) {
		assert(!(isContextHeader(hdr)));
	}
	return totalLength - fixedFields;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
sqInt
superclassOf(sqInt classPointer)
{
	return longAt((classPointer + BaseHeaderSize) + ((((usqInt)(SuperclassIndex) << (shiftForWord())))));
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted. */

	/* StackInterpreter>>#synchronousSignal: */
static NoDbgRegParms sqInt
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt excessSignals;

	if ((/* begin isEmptyList: */
		assert(!(isForwarded(aSemaphore))),
	(longAt((aSemaphore + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj))) {

		/* no process is waiting on this semaphore */
		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);

		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)((((usqInt)(excessSignals + 1))) ^ (((((usqInt)(excessSignals + 1))) << 1))))) >= 0) {
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((aSemaphore + BaseHeaderSize) + ((((usqInt)(ExcessSignalsIndex) << (shiftForWord())))), (((usqInt)(excessSignals + 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		return 0;
	}
	return resumepreemptedYieldingIf(removeFirstLinkOfList(aSemaphore), GIV(preemptionYields));
}

	/* StackInterpreter>>#tempCountOf: */
usqInt
tempCountOf(sqInt methodPointer)
{
    sqInt header;

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodPointer));
	header = longAt((methodPointer + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin temporaryCountOfMethodHeader: */
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
usqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}


/*	See StackInterpreter class>>initializeFrameIndices */

	/* StackInterpreter>>#temporary:in: */
static NoDbgRegParms sqInt
temporaryin(sqInt offset, char *theFP)
{
    usqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
			? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord))
			: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord)));
}


/*	See StackInterpreter class>>initializeFrameIndices */

	/* StackInterpreter>>#temporary:in:put: */
static NoDbgRegParms sqInt
temporaryinput(sqInt offset, char *theFP, sqInt valueOop)
{
    usqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
			? longAtput((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord), valueOop)
			: longAtput(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord), valueOop));
}


/*	Record a process to be awoken on the next interpreter cycle. */

	/* StackInterpreter>>#transferTo: */
static NoDbgRegParms sqInt
transferTo(sqInt newProc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *lastUsedPage;
    sqInt newContext;
    StackPage *newPage;
    sqInt oldProc;
    sqInt sched;
    sqInt senderOop;
    char *sp;
    char *theFrame;
    StackPage *thePage;
    sqInt top;

	GIV(statProcessSwitch) += 1;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());

	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer) + 1, GIV(framePointer), GIV(stackPointer), 1 /* (isMachineCodeFrame: not) */, __LINE__);
	sched = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));
	oldProc = longAt((sched + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))));

	/* begin ensureFrameIsMarried:SP: */
	if (byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer) + BytesPerWord);
l1:	/* end ensureFrameIsMarried:SP: */;

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(oldProc, GIV(youngStart))) {
		possibleRootStoreIntovalue(oldProc, activeContext);
	}
	longAtput((oldProc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))), activeContext);

	/* begin storePointer:ofObject:withValue: */
	if (oopisLessThan(sched, GIV(youngStart))) {
		possibleRootStoreIntovalue(sched, newProc);
	}
	longAtput((sched + BaseHeaderSize) + ((((usqInt)(ActiveProcessIndex) << (shiftForWord())))), newProc);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((newProc + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))), GIV(nilObj));

	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	newContext = longAt((newProc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	assert(isContext(newContext));
	if (((longAt((newContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer)));
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((newProc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))), GIV(nilObj));
	if (/* isStillMarriedContext: */
		(((longAt((newContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(newContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((newContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFrame = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		if (theFrame != ((thePage->headFP))) {

			/* explicit assignment of suspendedContext can cause switch to interior frame. */
			/* begin newStackPage */
			newPage = (GIV(mostRecentlyUsedPage)->nextPage);
			if (!((newPage->baseFP))) {
				goto l3;
			}
			divorceFramesIn(newPage);
l3:	/* end newStackPage */;
			moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFrame, thePage), newPage);

			/* begin markStackPageLeastMostRecentlyUsed: */
			assert(newPage == ((GIV(mostRecentlyUsedPage)->nextPage)));
			lastUsedPage = (newPage->nextPage);
			while (((lastUsedPage->baseFP)) == 0) {
				lastUsedPage = (lastUsedPage->nextPage);
			}
			if (((lastUsedPage->nextPage)) == newPage) {
				goto l2;
			}
			(((newPage->prevPage))->nextPage = (newPage->nextPage));
			(((newPage->nextPage))->prevPage = (newPage->prevPage));
			(((lastUsedPage->prevPage))->nextPage = newPage);
			(newPage->prevPage = (lastUsedPage->prevPage));
			(newPage->nextPage = lastUsedPage);
			(lastUsedPage->prevPage = newPage);
			assert(pageListIsWellFormed());
l2:	/* end markStackPageLeastMostRecentlyUsed: */;
		}
		assert(((thePage->headFP)) == theFrame);
	}
	else {
		thePage = makeBaseFrameFor(newContext);
		theFrame = (thePage->baseFP);
	}

	/* begin setStackPageAndLimit: */
	assert(thePage);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);

	/* begin setStackPointersFromPage: */
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);

	/* begin setMethod: */
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert(!((methodUsesAlternateBytecodeSet(GIV(method)))));

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = top;

	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), 1 /* (isMachineCodeFrame: not) */, __LINE__);
	return 0;
}

	/* StackInterpreter>>#ultimateLiteralOf: */
sqInt
ultimateLiteralOf(sqInt aMethodOop)
{
    sqInt offset;

	assert(isOopCompiledMethod(aMethodOop));
	offset = (literalCountOf(aMethodOop)) - 1;

	/* begin literal:ofMethod: */
	return longAt((aMethodOop + BaseHeaderSize) + ((((usqInt)((offset + LiteralStart)) << (shiftForWord())))));
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object. */

	/* StackInterpreter>>#updateDisplayLeft:Top:Right:Bottom: */
static NoDbgRegParms sqInt
updateDisplayLeftTopRightBottom(sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt left;
    sqInt right;
    sqInt surfaceHandle;
    sqInt top;

	left = ((l < 0) ? 0 : l);
	right = ((r < displayWidth) ? r : displayWidth);
	top = ((t < 0) ? 0 : t);
	bottom = ((b < displayHeight) ? b : displayHeight);
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (((((sqInt)displayBits)) & 1)) {
		surfaceHandle = ((((sqInt)displayBits)) >> 1);
		if (!showSurfaceFn) {
			showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
			if (!showSurfaceFn) {
				return (GIV(primFailCode) = PrimErrNotFound);
			}
		}
		showSurfaceFn(surfaceHandle, left, top, right - left, bottom - top);
	}
	else {
		assert(isNonImmediate(((sqInt)displayBits)));
		ioShowDisplay(((sqInt)displayBits), displayWidth, displayHeight, displayDepth, left, right, top, bottom);
	}
	return 0;
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

	/* StackInterpreter>>#updateStateOfSpouseContextForFrame:WithSP: */
static NoDbgRegParms void
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *pointer;
    usqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP));
	theContext = longAt(theFP + FoxThisContext);
	assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));

	/* update the arguments. this would appear not to be strictly necessary, but is for two reasons.
	   First, the fact that arguments are read-only is only as convention in the Smalltalk compiler;
	   other languages may choose to modify arguments.
	   Second, the Squeak runUntilErrorOrReturnFrom: nightmare pops the stack top, which may, in
	   certain circumstances, be the last argument, and hence the last argument may not have been
	   stored into the context. */
	tempIndex = byteAt((theFP + FoxFrameFlags) + 1);
	pointer = theFP + ((FoxCallerSavedIP + BytesPerWord) + ((tempIndex << (shiftForWord()))));
	for (i = 1; i <= tempIndex; i += 1) {
		pointer -= BytesPerWord;
		assert(addressCouldBeOop(longAt(pointer)));

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(theContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(theContext, longAt(pointer));
		}
		longAtput((theContext + BaseHeaderSize) + ((((usqInt)((ReceiverIndex + i)) << (shiftForWord())))), longAt(pointer));
	}
	pointer = (theFP + FoxReceiver) - BytesPerWord;
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer)));
		tempIndex += 1;

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(theContext, GIV(youngStart))) {
			possibleRootStoreIntovalue(theContext, longAt(pointer));
		}
		longAtput((theContext + BaseHeaderSize) + (((ReceiverIndex + tempIndex) << (shiftForWord()))), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext)));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((theContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))), ((tempIndex << 1) | 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */

	/* StackInterpreter>>#validInstructionPointer:inFrame: */
static NoDbgRegParms sqInt
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp)
{
	return /* validInstructionPointer:inMethod:framePointer: */
		(anInstrPointer >= ((((longAt(fp + FoxMethod)) + (lastPointerOf(longAt(fp + FoxMethod)))) + BytesPerOop) - 1))
	 && (anInstrPointer < ((((longAt(fp + FoxMethod)) + (numBytesOfBytes(longAt(fp + FoxMethod)))) + BaseHeaderSize) - 1));
}


/*	Note that we accept anInstrPointer pointing to a callPrimitiveBytecode
	at the start of a method that contains a primitive. This because methods
	like Context(Part)>>reset have to be updated to skip the callPrimtiive
	bytecode otherwise. */
/*	-1 for pre-increment in fetchNextBytecode */

	/* StackInterpreter>>#validInstructionPointer:inMethod:framePointer: */
sqInt
validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp)
{
	return (theInstrPointer >= (((aMethod + (lastPointerOf(aMethod))) + BytesPerOop) - 1))
	 && (theInstrPointer < (((aMethod + (numBytesOfBytes(aMethod))) + BaseHeaderSize) - 1));
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

	/* StackInterpreter>>#validStackPageBaseFrames */
static sqInt
validStackPageBaseFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			if (!(validStackPageBaseFrame(aPage))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Check that the base frame in the stack page has a valid sender context. */

	/* StackInterpreter>>#validStackPageBaseFrame: */
static NoDbgRegParms sqInt
validStackPageBaseFrame(StackPage *aPage)
{
    sqInt senderContextOrNil;

	if (!(asserta(isBaseFrame((aPage->baseFP))))) {
		return 0;
	}
	senderContextOrNil = longAt(((aPage->baseFP)) + FoxCallerContext);
	if (!(asserta(addressCouldBeObj(senderContextOrNil)))) {
		return 0;
	}
	if (!(asserta((senderContextOrNil == (nilObject()))
		 || (isContext(senderContextOrNil))))) {
		return 0;
	}
	return 1;
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

	/* StackInterpreter>>#voidLongRunningPrimitive: */
#if LRPCheck
static NoDbgRegParms NeverInline void
voidLongRunningPrimitive(char *reason)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence();
}
#endif /* LRPCheck */


/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */

	/* StackInterpreter>>#voidVMStateForSnapshotFlushingExternalPrimitivesIf: */
static NoDbgRegParms sqInt
voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    usqInt fmt;
    sqInt header;
    sqInt oop;
    unsigned int sz;

	activeContext = divorceAllFrames();

	/* begin bereaveAllMarriedContextsForSnapshotFlushingExternalPrimitivesIf: */
	/* begin allObjectsDo: */
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			fmt = (((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15;
			if ((fmt == (indexablePointersFormat()))
			 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
				makeContextSnapshotSafe(oop);
			}
			if (flushExtPrims
			 && (fmt >= (firstCompiledMethodFormat()))) {
				flushExternalPrimitiveOf(oop);
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
	return activeContext;
}


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

	/* StackInterpreter>>#wakeHighestPriority */
static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt oop;
    sqInt p;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	oop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SchedulerAssociation) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)(ValueIndex) << (shiftForWord())))));

	/* begin fetchPointer:ofObject: */
	schedLists = longAt((oop + BaseHeaderSize) + ((((usqInt)(ProcessListsIndex) << (shiftForWord())))));
	p = (GIV(highestRunnableProcessPriority)
				? GIV(highestRunnableProcessPriority)
				: numSlotsOf(schedLists));
	while (((p -= 1)) >= 0) {
		processList = longAt((schedLists + BaseHeaderSize) + ((((usqInt)(p) << (shiftForWord())))));
		while (1) {
			/* begin isEmptyList: */
			assert(!(isForwarded(processList)));
			if ((longAt((processList + BaseHeaderSize) + ((((usqInt)(FirstLinkIndex) << (shiftForWord())))))) == GIV(nilObj)) break;

			/* Only answer processes with a runnable suspendedContext.
			   Discard those that aren't; the VM would crash otherwise. */
			proc = removeFirstLinkOfList(processList);
			ctxt = longAt((proc + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
			if (isLiveContext(ctxt)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			warning("evicted zombie process from run queue");
		}
	}
	error("scheduler could not find a runnable process");
	return null;
}


/*	useful for VM debugging */

	/* StackInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *where;

	/* begin whereIsMaybeHeapThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, startOfMemory(), GIV(endOfMemory))) {
		if (oopisLessThan(anOop, GIV(freeStart))) {
			where = " is in old space";
			goto l1;
		}
		if (oopisLessThan(anOop, GIV(reserveStart))) {
			where = " is in new space";
			goto l1;
		}
		where = " is above reserve start";
		goto l1;
	}
	where = null;
l1:	/* end whereIsMaybeHeapThing: */;
	if (where) {
		return where;
	}

	/* begin whereIsMaybeStackThing: */
	if (oopisGreaterThanOrEqualToandLessThan(anOop, GIV(stackMemory), GIV(pages))) {
		where = " is in the stack zone";
		goto l2;
	}
	where = null;
l2:	/* end whereIsMaybeStackThing: */;
	if (where) {
		return where;
	}
	return " is no where obvious";
}


/*	Write the image header and heap contents to imageFile for snapshot. c.f.
	writeImageFileIOSimulation. The game below is to maintain 64-bit alignment
	for all putLong:toFile: occurrences. */

	/* StackInterpreter>>#writeImageFileIO */
static NeverInline sqInt
writeImageFileIO(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt imageBytes;
    extern char imageName[];
    sqInt okToWrite;
    void *sCWIfn;

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!okToWrite) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	headerStart = 0;

	/* 64 or 128; header size in bytes; do not change! */
	headerSize = BytesPerWord * 16;
	f = sqImageFileOpen(imageName, "wb");
	if (invalidSqImageFile(f)) {

		/* could not open the image file for writing */
		return (GIV(primFailCode) = PrimErrOperationFailed);
	}
	imageBytes = GIV(freeStart) - (startOfMemory());
	headerStart = sqImageFileStartLocation(f, imageName, headerSize + imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putWord32toFile(/* imageFormatVersionForSnapshot */
		(GIV(multipleBytecodeSetsActive)
			? 7017 /* (imageFormatVersion bitOr: MultipleBytecodeSetsBitmask) */
			: 6505 /* imageFormatVersion */), f);
	putWord32toFile(headerSize, f);
	putLongtoFile(imageBytes, f);
	putLongtoFile(startOfMemory(), f);
	putLongtoFile(GIV(specialObjectsOop), f);
	putLongtoFile((GIV(freeStart)) >> (shiftForWord()), f);
	putLongtoFile(getSnapshotScreenSize(), f);
	putLongtoFile(getImageHeaderFlags(), f);
	putWord32toFile(extraVMMemory, f);
	putShorttoFile(desiredNumStackPages, f);
	putShorttoFile(GIV(theUnknownShort), f);
	putWord32toFile(desiredEdenBytes, f);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
			? ioGetMaxExtSemTableSize()
			: 0), f);
	putShorttoFile(GIV(the2ndUnknownShort), f);
		putLongtoFile(0, f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);
	putLongtoFile(0, f);
	assert((headerStart + headerSize) == (sqImageFilePosition(f)));
	sqImageFileSeek(f, headerStart + headerSize);
	if (GIV(primFailCode)) {

		/* file write or seek failure */
		sqImageFileClose(f);
		return null;
	}
	bytesWritten = sqImageFileWrite(pointerForOop(startOfMemory()), sizeof(char), imageBytes, f);

	/* begin success: */
	if (!(bytesWritten == imageBytes)) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f);
	return 0;
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#fieldOrSenderFP:ofContext: */
static NoDbgRegParms sqInt
fieldOrSenderFPofContext(sqInt index, sqInt contextObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt senderOop;
    char *spouseFP;
    sqInt tempIndex;

	tempIndex = index - CtxtTempFrameStart;
	if (!(/* isStillMarriedContext: */
			(((longAt((contextObj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(contextObj))))) {
		if (tempIndex >= (fetchStackPointerOf(contextObj))) {
			return GIV(nilObj);
		}
		else {
			return longAt((contextObj + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
		}
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((contextObj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
	if (tempIndex >= (stackPointerIndexForFrame(spouseFP))) {
		return GIV(nilObj);
	}
	return fieldofFrame(index, spouseFP);
}


/*	Arrange to answer naked frame pointers for unmarried
	senders to avoid reifying contexts in the search. */

	/* StackInterpreterPrimitives>>#field:ofFrame: */
static NoDbgRegParms sqInt
fieldofFrame(sqInt index, char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    usqInt frameNumArgs;

	switch (index) {
	case SenderIndex:
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		return (callerFP
				? (byteAt((callerFP + FoxFrameFlags) + 2)
						? (assert(checkIsStillMarriedContextcurrentFP(frameContext(callerFP), null)),
						/* frameContext: */
							longAt(callerFP + FoxThisContext))
						: ((sqInt)callerFP))
				: longAt(theFP + FoxCallerContext));

	case StackPointerIndex:
	case InstructionPointerIndex:
		return ConstZero;

	case MethodIndex:
		return longAt(theFP + FoxMethod);

	case ClosureIndex:
		return (byteAt((theFP + FoxFrameFlags) + 3)
				? longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))))))
				: GIV(nilObj));

	case ReceiverIndex:
		return longAt(theFP + FoxReceiver);

	default:
		assert((((index - CtxtTempFrameStart) >= 0) && ((index - CtxtTempFrameStart) <= (stackPointerIndexForFrame(theFP)))));
		return /* temporary:in: */
			((index - CtxtTempFrameStart) < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
				? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord))
				: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - CtxtTempFrameStart)) * BytesPerWord)));
	}
	return 0;
}

	/* StackInterpreterPrimitives>>#isAppropriateForCopyObject: */
static NoDbgRegParms sqInt
isAppropriateForCopyObject(sqInt oop)
{
	if (!(((((usqInt)((longAt(oop)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */)) {
		return 0;
	}
	if (/* isContext: */
		((oop & 1) == 0)
	 && (((((usqInt)((longAt(oop)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		return !(/* isStillMarriedContext: */
			(((longAt((oop + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(oop))));
	}
	return 1;
}


/*	The function has not been loaded yet. Fetch module and function name. */

	/* StackInterpreterPrimitives>>#linkExternalCall:errInto: */
static NoDbgRegParms void
(*linkExternalCallerrInto(sqInt externalCallLiteral, sqInt *failPtr))()
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    void *functionAddress;
    sqInt functionLength;
    sqInt functionName;
    sqInt i;
    sqInt index;
    sqInt moduleLength;
    sqInt moduleName;

	moduleName = longAt((externalCallLiteral + BaseHeaderSize) + ((((usqInt)(ExternalCallLiteralModuleNameIndex) << (shiftForWord())))));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(/* isBytes: */
				((moduleName & 1) == 0)
			 && (((((usqInt)((longAt(moduleName)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
			if (failPtr) {
				failPtr[0] = PrimErrBadMethod;
			}
			return 0;
		}
		moduleLength = numBytesOfBytes(moduleName);
	}
	functionName = longAt((externalCallLiteral + BaseHeaderSize) + ((((usqInt)(ExternalCallLiteralFunctionNameIndex) << (shiftForWord())))));
	if (!(/* isBytes: */
			((functionName & 1) == 0)
		 && (((((usqInt)((longAt(functionName)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		if (failPtr) {
			failPtr[0] = PrimErrBadMethod;
		}
		return 0;
	}

	/* Spur needs metadata for the primitive, which is stored in the third slot of the literal. */
	functionLength = numBytesOfBytes(functionName);
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr) {

		/* add the function to the external primitive table */
		functionAddress = ((void *) addr);

		/* begin addToExternalPrimitiveTable: */
		for (i = GIV(externalPrimitiveTableFirstFreeIndex); i < MaxExternalPrimitiveTableSize; i += 1) {
			if (!(externalPrimitiveTable[i])) {
				externalPrimitiveTable[i] = functionAddress;
				index = (GIV(externalPrimitiveTableFirstFreeIndex) = i + 1);
				goto l1;
			}
		}
		index = 0;
l1:	/* end addToExternalPrimitiveTable: */;
	}
	else {
		index = -1;
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((externalCallLiteral + BaseHeaderSize) + ((((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))), (((usqInt)index << 1) | 1));
	rewriteMethodCacheEntryForExternalPrimitiveToFunction((index >= 0
			? addr
			: 0));
	return addr;
}


/*	Return a shallow copy of the receiver.
	Special-case non-single contexts (because of context-to-stack mapping).
	Can't fail for contexts cuz of image context instantiation code (sigh). */
/*	because of cloneContext: below */

	/* StackInterpreterPrimitives>>#primitiveClone */
static void
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt frameNumArgs;
    sqInt header;
    sqInt i;
    sqInt newCopy;
    sqInt rcvr;
    sqInt senderOop;
    char *sp;
    char *spouseFP;
    sqInt spSqInt;
    int sz;
    unsigned int sz1;
    sqInt valuePointer;

	newCopy = 0;
	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & 1)) {
		newCopy = rcvr;
	}
	else {
		if (((((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
			/* begin externalWriteBackHeadFramePointers */
			assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
			assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
			assert(!((isFree(GIV(stackPage)))));

			/* begin setHeadFP:andSP:inPage: */
			assert(GIV(stackPointer) < GIV(framePointer));
			assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
			 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
			assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
			 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
			(GIV(stackPage)->headFP = GIV(framePointer));
			(GIV(stackPage)->headSP = GIV(stackPointer));
			assert(pageListIsWellFormed());

			/* begin cloneContext: */
			/* begin numSlotsOf: */
			header = longAt(rcvr);
			sz1 = (header & TypeMask
						? header & SizeMask
						: (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask);
			sz = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
			newCopy = eeInstantiateMethodContextSlots(sz);
			assert(!((newCopy == 0)));
			for (i = 0; i <= StackPointerIndex; i += 1) {
				valuePointer = externalInstVarofContext(i, rcvr);

				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newCopy + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), valuePointer);
			}
			for (i = MethodIndex; i <= ReceiverIndex; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				longAtput((newCopy + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), longAt((rcvr + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))));
			}
			if (/* isStillMarriedContext: */
				(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(rcvr)))) {
				/* begin frameOfMarriedContext: */
				senderOop = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
				assert((senderOop & 1));
				spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
				spSqInt = (stackPointerIndexForFrame(spouseFP)) - 1;
				for (i = 0; i <= spSqInt; i += 1) {
					valuePointer = /* temporary:in: */
							(i < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
								? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - i) * BytesPerWord))
								: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - i) * BytesPerWord)));

					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((newCopy + BaseHeaderSize) + ((((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))), valuePointer);
				}
			}
			else {
				spSqInt = (fetchStackPointerOf(rcvr)) - 1;
				for (i = 0; i <= spSqInt; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					longAtput((newCopy + BaseHeaderSize) + ((((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord())))), longAt((rcvr + BaseHeaderSize) + ((((usqInt)((i + CtxtTempFrameStart)) << (shiftForWord()))))));
				}
			}
		}
		else {
			newCopy = cloneObject(rcvr);
		}
		if (!newCopy) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveClosureCopyWithCopiedValues */
static void
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    sqInt integerPointer;
    sqInt newClosure;
    sqInt numArgs;
    int numCopied;
    char *sp;
    unsigned int sz;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((integerPointer & 1)) {
		numArgs = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		numArgs = 0;
	}
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin closureIn:numArgs:instructionPointer:copiedValues: */
	/* begin numSlotsOf: */
	header = longAt(longAt(GIV(stackPointer)));
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt((longAt(GIV(stackPointer))) - (BytesPerWord * 2))) & AllButTypeMask);
	numCopied = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	newClosure = eeInstantiateSmallClassnumSlots(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassBlockClosure) << (shiftForWord()))))), ClosureFirstCopiedValueIndex + numCopied);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure + BaseHeaderSize) + ((((usqInt)(ClosureOuterContextIndex) << (shiftForWord())))), longAt(GIV(stackPointer) + (2 * BytesPerWord)));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure + BaseHeaderSize) + ((((usqInt)(ClosureStartPCIndex) << (shiftForWord())))), (((usqInt)((GIV(instructionPointer) + 2) - (GIV(method) + BaseHeaderSize)) << 1) | 1));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((newClosure + BaseHeaderSize) + ((((usqInt)(ClosureNumArgsIndex) << (shiftForWord())))), (((usqInt)numArgs << 1) | 1));
	for (i = 0; i < numCopied; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((newClosure + BaseHeaderSize) + ((((usqInt)((i + ClosureFirstCopiedValueIndex)) << (shiftForWord())))), longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))));
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (2 * BytesPerWord)), newClosure);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveAt for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAt */
static void
primitiveContextAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fixedFieldsSqInt;
    usqInt fmt;
    usqInt fmtUsqInt;
    usqInt frameNumArgs;
    sqInt hdr;
    sqInt hdrSqInt;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt senderOop;
    char *sp;
    char *spouseFP;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt stSize;
    sqInt stSizeSqInt;
    unsigned int sz;
    sqInt totalLength;
    sqInt totalLengthSqInt;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 1);

	/* Duplicating much of stObject:at:put: here allows stObject:at:put: to omit tests for contexts. */
	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	hdr = longAt(aContext);
	if (!(((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at: */
		hdrSqInt = longAt(aContext);
		fmtUsqInt = (((usqInt)(hdrSqInt)) >> (instFormatFieldLSB())) & 15;

		/* begin lengthOf:baseHeader:format: */
		if (hdrSqInt & TypeMask) {
			sz = hdrSqInt & SizeMask;
		}
		else {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmtUsqInt <= 4 /* lastPointerFormat */) {
			totalLengthSqInt = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l6;
		}
		totalLengthSqInt = (fmtUsqInt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmtUsqInt & 3));
l6:	/* end lengthOf:baseHeader:format: */;

		/* begin fixedFieldsOf:format:length: */
		if ((fmtUsqInt > 4 /* lastPointerFormat */)
		 || (fmtUsqInt == (arrayFormat()))) {
			fixedFieldsSqInt = 0;
			goto l7;
		}
		if (fmtUsqInt < 2) {
			fixedFieldsSqInt = totalLengthSqInt;
			goto l7;
		}
		class = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(aContext - BaseHeaderSize)) & AllButTypeMask);
		classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFieldsSqInt = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l7:	/* end fixedFieldsOf:format:length: */;
		if ((fmtUsqInt == (indexablePointersFormat()))
		 && (((((usqInt)(hdrSqInt)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if (/* isStillMarriedContext: */
				(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))) {
				spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(aContext)));
				stSizeSqInt = spUsqInt;
				goto l5;
			}

			/* begin fetchStackPointerOf: */
			spSqInt = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((spSqInt & 1))) {
				stSizeSqInt = 0;
				goto l5;
			}
			assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(aContext)));
			stSizeSqInt = (spSqInt >> 1);
l5:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSizeSqInt))
			 && (/* isStillMarriedContext: */
				(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))))) {
				value = temporaryin(index - 1, frameOfMarriedContext(aContext));
				goto l8;
			}
		}
		else {
			stSizeSqInt = totalLengthSqInt - fixedFieldsSqInt;
		}
		if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
			(fmtUsqInt >= (firstCompiledMethodFormat())
				? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
				: 1)))
		 && (oopisLessThanOrEqualTo(index, stSizeSqInt))) {
			/* begin subscript:with:format: */
			if (fmtUsqInt <= 4 /* lastPointerFormat */) {
				value = longAt((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFieldsSqInt) - 1)) << (shiftForWord())))));
				goto l8;
			}
			if (fmtUsqInt >= (firstByteFormat())) {
				value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFieldsSqInt) - 1))) << 1) | 1);
				goto l8;
			}
			integerValue = long32At((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFieldsSqInt) - 1)) << 2))));

			/* begin positive32BitIntegerFor: */
			/* begin maybeInlinePositive32BitIntegerFor: */
			assert(!((hasSixtyFourBitImmediates())));
			if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
				value = ((integerValue << 1) | 1);
				goto l8;
			}
			newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

			/* storeLong32:ofObject:withValue: */
			long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
			value = newLargeInteger;
			goto l8;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = (fmtUsqInt <= 1
					? PrimErrBadReceiver
					: PrimErrBadIndex);
		value = 0;
l8:	/* end stObject:at: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(/* isStillMarriedContext: */
			(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

		/* begin lengthOf:baseHeader:format: */
		if (hdr & TypeMask) {
			sz = hdr & SizeMask;
		}
		else {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmt <= 4 /* lastPointerFormat */) {
			totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l1;
		}
		totalLength = (fmt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4 /* lastPointerFormat */)
		 || (fmt == (arrayFormat()))) {
			fixedFields = 0;
			goto l3;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l3;
		}
		class = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(aContext - BaseHeaderSize)) & AllButTypeMask);
		classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(aContext)));
		stSize = (spSqInt >> 1);
l2:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}

		/* begin subscript:with:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			value = longAt((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))));
			goto l4;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((usqInt)(byteAt((aContext + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l4;
		}
		integerValue = long32At((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			value = ((integerValue << 1) | 1);
			goto l4;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		value = newLargeInteger;
l4:	/* end subscript:with:format: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
		return;
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	value = /* temporary:in: */
			((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
				? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord))
				: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)));

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveAtPut for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextAtPut */
static void
primitiveContextAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    sqInt fixedFieldsSqInt;
    usqInt fmt;
    usqInt fmtUsqInt;
    usqInt frameNumArgs;
    sqInt hdr;
    sqInt hdrSqInt;
    sqInt index;
    sqInt senderOop;
    sqInt signedValueToStore;
    char *sp;
    char *spouseFP;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt stSize;
    sqInt stSizeSqInt;
    unsigned int sz;
    sqInt totalLength;
    sqInt totalLengthSqInt;
    unsigned int unsignedValueToStore;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	hdr = longAt(aContext);
	index = (index >> 1);
	if (!(((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */
		/* begin stObject:at:put: */
		hdrSqInt = longAt(aContext);
		fmtUsqInt = (((usqInt)(hdrSqInt)) >> (instFormatFieldLSB())) & 15;

		/* begin lengthOf:baseHeader:format: */
		if (hdrSqInt & TypeMask) {
			sz = hdrSqInt & SizeMask;
		}
		else {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmtUsqInt <= 4 /* lastPointerFormat */) {
			totalLengthSqInt = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l6;
		}
		totalLengthSqInt = (fmtUsqInt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmtUsqInt & 3));
l6:	/* end lengthOf:baseHeader:format: */;

		/* begin fixedFieldsOf:format:length: */
		if ((fmtUsqInt > 4 /* lastPointerFormat */)
		 || (fmtUsqInt == (arrayFormat()))) {
			fixedFieldsSqInt = 0;
			goto l5;
		}
		if (fmtUsqInt < 2) {
			fixedFieldsSqInt = totalLengthSqInt;
			goto l5;
		}
		class = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(aContext - BaseHeaderSize)) & AllButTypeMask);
		classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFieldsSqInt = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l5:	/* end fixedFieldsOf:format:length: */;
		if ((fmtUsqInt == (indexablePointersFormat()))
		 && (((((usqInt)(hdrSqInt)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if (/* isStillMarriedContext: */
				(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))) {
				spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(aContext)));
				stSizeSqInt = spUsqInt;
				goto l7;
			}

			/* begin fetchStackPointerOf: */
			spSqInt = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
			if (!((spSqInt & 1))) {
				stSizeSqInt = 0;
				goto l7;
			}
			assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(aContext)));
			stSizeSqInt = (spSqInt >> 1);
l7:	/* end stackPointerForMaybeMarriedContext: */;
			if ((oopisGreaterThanOrEqualTo(index, 1))
			 && ((oopisLessThanOrEqualTo(index, stSizeSqInt))
			 && (/* isStillMarriedContext: */
				(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
			 && (!(isWidowedContext(aContext)))))) {
				temporaryinput(index - 1, frameOfMarriedContext(aContext), value);
				goto l9;
			}
		}
		else {
			stSizeSqInt = totalLengthSqInt - fixedFieldsSqInt;
		}
		if ((oopisGreaterThanOrEqualTo(index, /* firstValidIndexOfIndexableObject:withFormat: */
			(fmtUsqInt >= (firstCompiledMethodFormat())
				? (((literalCountOf(aContext)) + LiteralStart) * BytesPerOop) + 1
				: 1)))
		 && (oopisLessThanOrEqualTo(index, stSizeSqInt))) {
			/* begin subscript:with:storing:format: */
			if (fmtUsqInt <= 4 /* lastPointerFormat */) {
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(aContext, GIV(youngStart))) {
					possibleRootStoreIntovalue(aContext, value);
				}
				longAtput((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFieldsSqInt) - 1)) << (shiftForWord())))), value);
				goto l8;
			}
			if (fmtUsqInt >= (firstByteFormat())) {
				if (!((value & 1))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l8;
				}
				signedValueToStore = (value >> 1);
				if (!((signedValueToStore >= 0)
					 && (signedValueToStore <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
					goto l8;
				}

				/* storeByte:ofObject:withValue: */
				byteAtput((aContext + BaseHeaderSize) + ((index + fixedFieldsSqInt) - 1), signedValueToStore);
				goto l8;
			}
			unsignedValueToStore = positive32BitValueOf(value);
			if (!GIV(primFailCode)) {
				/* storeLong32:ofObject:withValue: */
				long32Atput((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFieldsSqInt) - 1)) << 2))), unsignedValueToStore);
			}
l8:	/* end subscript:with:storing:format: */;
		}
		else {
			/* primitiveFailFor: */
			GIV(primFailCode) = (fmtUsqInt <= 1
						? PrimErrBadReceiver
						: PrimErrBadIndex);
		}
l9:	/* end stObject:at:put: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
		}
		return;
	}

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(/* isStillMarriedContext: */
			(((longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

		/* begin lengthOf:baseHeader:format: */
		if (hdr & TypeMask) {
			sz = hdr & SizeMask;
		}
		else {
			sz = (longAt(aContext - (BytesPerWord * 2))) & LongSizeMask;
		}
		sz -= 0;
		if (fmt <= 4 /* lastPointerFormat */) {
			totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
			goto l1;
		}
		totalLength = (fmt < (firstByteFormat())
					? ((usqInt)((sz - BaseHeaderSize))) >> 2
					: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 4 /* lastPointerFormat */)
		 || (fmt == (arrayFormat()))) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l4;
		}
		class = /* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(aContext)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(aContext - BaseHeaderSize)) & AllButTypeMask);
		classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
		fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l4:	/* end fixedFieldsOf:format:length: */;

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((aContext + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(aContext)));
		stSize = (spSqInt >> 1);
l2:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadIndex;
			return;
		}

		/* begin subscript:with:storing:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(aContext, GIV(youngStart))) {
				possibleRootStoreIntovalue(aContext, value);
			}
			longAtput((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << (shiftForWord())))), value);
			goto l3;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((value & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}
			signedValueToStore = (value >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l3;
			}

			/* storeByte:ofObject:withValue: */
			byteAtput((aContext + BaseHeaderSize) + ((index + fixedFields) - 1), signedValueToStore);
			goto l3;
		}
		unsignedValueToStore = positive32BitValueOf(value);
		if (!GIV(primFailCode)) {
			/* storeLong32:ofObject:withValue: */
			long32Atput((aContext + BaseHeaderSize) + ((((usqInt)(((index + fixedFields) - 1)) << 2))), unsignedValueToStore);
		}
l3:	/* end subscript:with:storing:format: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
		return;
	}

	/* begin frameOfMarriedContext: */
	senderOop = longAt((aContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	assert((senderOop & 1));
	spouseFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* temporary:in:put: */
	if ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))) {
		longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	else {
		longAtput(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}


/*	Special version of primitiveSize for accessing contexts.
	Written to be varargs for use from mirror primitives. */

	/* StackInterpreterPrimitives>>#primitiveContextSize */
static void
primitiveContextSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt rcvr;
    char *sp;
    sqInt spSqInt;
    usqInt spUsqInt;
    sqInt sz;
    unsigned int sz1;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz1 = hdr & SizeMask;
	}
	else {
		sz1 = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz1 -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz1 - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz1 - BaseHeaderSize))) >> 2
				: (sz1 - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
		assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
		assert(!((isFree(GIV(stackPage)))));

		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());

		/* begin stackPointerForMaybeMarriedContext: */
		if (/* isStillMarriedContext: */
			(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			spUsqInt = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((spUsqInt >> 1))) < (lengthOf(rcvr)));
			sz = spUsqInt;
			goto l3;
		}

		/* begin fetchStackPointerOf: */
		spSqInt = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
		if (!((spSqInt & 1))) {
			sz = 0;
			goto l3;
		}
		assert((ReceiverIndex + ((spSqInt >> 1))) < (lengthOf(rcvr)));
		sz = (spSqInt >> 1);
l3:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}

	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)sz << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

	/* StackInterpreterPrimitives>>#primitiveContextXray */
static void
primitiveContextXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    char *sp;

	context = longAt(GIV(stackPointer));
	if (((longAt((context + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer))) {
			flags = 3;
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)flags << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

	/* StackInterpreterPrimitives>>#primitiveDeferDisplayUpdates */
static void
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	if (cannotDeferDisplayUpdates) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

	/* StackInterpreterPrimitives>>#primitiveDoNamedPrimitiveWithArgs */
static void
primitiveDoNamedPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    int arraySize;
    usqInt ccIndex;
    sqInt classOop;
    sqInt functionLength;
    sqInt functionName;
    sqInt header;
    sqInt index;
    sqInt isArray;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt primRcvr;
    char *sp;
    sqInt spec;
    sqInt successBoolean;
    unsigned int sz;
    sqInt top;
    sqInt valuePointer;

	argumentArray = longAt(GIV(stackPointer));
	methodArg = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((/* isArray: */
			((argumentArray & 1) == 0)
		 && (((((usqInt)((longAt(argumentArray)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && (/* isOopCompiledMethod: */
			((methodArg & 1) == 0)
		 && (((((usqInt)((longAt(methodArg)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -2;
		return;
	}

	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask);
	arraySize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -2;
		return;
	}

	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodArg));
	methodHeader = longAt((methodArg + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	if (!(((/* begin literalCountOfMethodHeader: */
			assert((methodHeader & 1)),
		((((int) methodHeader)) < 0
					? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
					: (((usqInt)(methodHeader)) >> 10) & 0xFF))) > 2)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -3;
		return;
	}

	/* first literal */
	spec = longAt((methodArg + BaseHeaderSize) + (1U << (shiftForWord())));

	/* begin isInstanceOfClassArray: */
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord())))));
	if ((spec & 1)) {
		isArray = 0;
		goto l1;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((spec & 1)));
	ccIndex = (((usqInt)((longAt(spec)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		isArray = ((longAt(spec - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	isArray = ClassArrayCompactIndex == ccIndex;
	goto l1;
	isArray = classOop == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord()))))));
l1:	/* end isInstanceOfClassArray: */;
	if (!(isArray
		 && (((numSlotsOf(spec)) == 4)
		 && ((primitiveIndexOfMethodheader(methodArg, methodHeader)) == PrimNumberExternalCall)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -3;
		return;
	}
	if (!(((((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15) == arraySize)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -2;
		return;
	}
	moduleName = longAt((spec + BaseHeaderSize) + (0U << (shiftForWord())));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		successBoolean = /* isBytes: */
				((moduleName & 1) == 0)
			 && (((((usqInt)((longAt(moduleName)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()));

		/* begin success: */
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		moduleLength = numBytesOfBytes(moduleName);
	}
	functionName = longAt((spec + BaseHeaderSize) + (1U << (shiftForWord())));
	successBoolean = /* isBytes: */
			((functionName & 1) == 0)
		 && (((((usqInt)((longAt(functionName)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat()));

	/* begin success: */
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	functionLength = numBytesOfBytes(functionName);
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -3;
		return;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (!addr) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -1;
		return;
	}
	GIV(tempOop) = eeInstantiateClassIndexformatnumSlots(ClassArrayCompactIndex, arrayFormat(), 4);

	/* begin popStack */
	valuePointer = (argumentArray = longAt(GIV(stackPointer)));
	GIV(stackPointer) += BytesPerWord;
	valuePointer = (argumentArray);

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
	valuePointer = (primRcvr = longAt(GIV(stackPointer)));
	GIV(stackPointer) += BytesPerWord;
	valuePointer = (primRcvr);

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer = top;

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer);
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	valuePointer = top;

	/* begin storePointerUnchecked:ofObject:withValue: */
	longAtput((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord())), valuePointer);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), primRcvr);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}

	/* begin callExternalPrimitive: */
	dispatchFunctionPointer(addr);
	if (GIV(primFailCode)) {

		/* If primitive failed, then restore state for failure code */
		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (3U << (shiftForWord()))));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (2U << (shiftForWord()))));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (1U << (shiftForWord()))));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(tempOop) + BaseHeaderSize) + (0U << (shiftForWord()))));
		GIV(stackPointer) = sp;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(argumentCount) = 3;
		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}


/*	Implement either ProtoObject>>tryPrimitive: primIndex withArgs: argArray
	or Context>>receiver: anObject tryPrimitive: primIndex withArgs: argArray.
	If this primitive fails, arrange that its error code is a negative
	integer, to
	distinguish between this failing and the primitive it invokes failing. */

	/* StackInterpreterPrimitives>>#primitiveDoPrimitiveWithArgs */
static void
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    int arraySize;
    sqInt header;
    sqInt index;
    sqInt primIdx;
    sqInt rcvr;
    sqInt savedNumArgs;
    char *sp;
    unsigned int sz;

	if (!(((GIV(argumentCount) >= 2) && (GIV(argumentCount) <= 3)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -PrimErrUnsupported;
		return;
	}
	argumentArray = longAt(GIV(stackPointer));
	primIdx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((/* isArray: */
			((argumentArray & 1) == 0)
		 && (((((usqInt)((longAt(argumentArray)))) >> (instFormatFieldLSB())) & 15) == 2))
		 && ((primIdx & 1)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -PrimErrBadArgument;
		return;
	}

	/* begin numSlotsOf: */
	header = longAt(argumentArray);
	sz = (header & TypeMask
				? header & SizeMask
				: (longAt(argumentArray - (BytesPerWord * 2))) & AllButTypeMask);
	arraySize = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
	if (!(arraySize <= (LargeContextSlots - CtxtTempFrameStart))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = -PrimErrLimitExceeded;
		return;
	}
	primIdx = (primIdx >> 1);

	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx])));
	if (!primitiveFunctionPointer) {
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;

		/* primitiveFailFor: */
		GIV(primFailCode) = -PrimErrBadIndex;
		return;
	}
	if (((savedNumArgs = GIV(argumentCount))) == 3) {

		/* ...and receiver if the three arg form */
		/* actual receiver */
		GIV(tempOop2) = longAt(GIV(stackPointer) + (4 * BytesPerWord));

		/* receiver for primitive */
		rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));

		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
	}
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= arraySize) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		GIV(tempOop2) = 0;
		return;
	}

	/* prim might alloc/gc */
	/* Run the primitive (sets primFailCode) */
	GIV(tempOop) = argumentArray;
	if (!(slowPrimitiveResponse())) {

		/* If primitive failed, then restore state for failure code */
		if (!GIV(tempOop)) {

			/* the primitive failed in a recursive invocation.  can't fix things with no value... */
			return;
		}

		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		if (savedNumArgs == 3) {
			rcvr = longAt(GIV(stackPointer));

			/* stackTopPut: */
			longAtPointerput(GIV(stackPointer), GIV(tempOop2));

			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
			GIV(stackPointer) = sp;
		}

		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), (((usqInt)primIdx << 1) | 1));
		GIV(stackPointer) = sp;

		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(tempOop));
		GIV(stackPointer) = sp;
		primitiveFunctionPointer = primitiveDoPrimitiveWithArgs;
		GIV(argumentCount) = savedNumArgs;
	}
	GIV(tempOop) = (GIV(tempOop2) = 0);
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethod */
static void
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *sp;
    sqInt top;

	methodArgument = longAt(GIV(stackPointer));
	if (!(/* isOopCompiledMethod: */
			((methodArgument & 1) == 0)
		 && (((((usqInt)((longAt(methodArgument)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (!((GIV(argumentCount) - 1) == (argumentCountOf(methodArgument)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = top;

	/* begin primitiveIndexOf: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin primitiveIndexOfMethod:header: */
	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);

	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
		? 0
		: primitiveTable[primitiveIndex])));
	GIV(argumentCount) -= 1;

	/* begin executeNewMethod */
	if (primitiveFunctionPointer) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}

	/* begin activateNewMethod */
	/* begin justActivateNewMethod: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
				: ((1 + ((numArgs << 8)))));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode)) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

	/* StackInterpreterPrimitives>>#primitiveExecuteMethodArgsArray */
static void
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt argCnt;
    sqInt argumentArray;
    sqInt header;
    sqInt i;
    usqInt iUsqInt;
    sqInt methodArgument;
    sqInt methodHeader;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    sqInt rcvrSqInt;
    char *sp;

	methodArgument = longAt(GIV(stackPointer));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((/* isOopCompiledMethod: */
			((methodArgument & 1) == 0)
		 && (((((usqInt)((longAt(methodArgument)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
		 && (/* isArray: */
			((argumentArray & 1) == 0)
		 && (((((usqInt)((longAt(argumentArray)))) >> (instFormatFieldLSB())) & 15) == 2)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}

	/* begin argumentCountOf: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(methodArgument));
	header = longAt((methodArgument + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	argCnt = (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
	if (!(argCnt == (numSlotsOf(argumentArray)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	if (GIV(argumentCount) > 2) {

		/* CompiledMethod class>>receiver:withArguments:executeMethod:
		   SqueakObjectPrimitives class>>receiver:withArguments:apply:
		   VMMirror>>ifFail:object:with:executeMethod: et al */
		rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
		if (GIV(argumentCount) > 4) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return;
		}

		/* stackValue:put: */
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	}

	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	for (i = 0; i < argCnt; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord()))))));
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;

	/* begin primitiveIndexOf: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));

	/* begin primitiveIndexOfMethod:header: */
	primBits = (methodHeader >> 1);
	primitiveIndex = (primBits & 0x1FF) + ((((usqInt)(primBits)) >> 19) & 0x200);

	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
		? 0
		: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = argCnt;

	/* begin executeNewMethod */
	if (primitiveFunctionPointer) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}

	/* begin activateNewMethod */
	/* begin justActivateNewMethod: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvrSqInt = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvrSqInt)));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
				: ((1 + ((numArgs << 8)))));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvrSqInt);
	GIV(stackPointer) = sp;
	for (iUsqInt = (numArgs + 1); iUsqInt <= numTemps; iUsqInt += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode)) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol)
	* The function name (String | Symbol)
	* The session ID (SmallInteger) [OBSOLETE], or in Spur, the metadata
	(accessorDepth and flags; Integer))
	* The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:.
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */
/*	because the primitive accesses newMethod's first literal, which is checked
	for explicitly in checkForAndFollowForwardedPrimitiveState
 */
/*	since call may invoke a callback */
/*	since external primitive linkage is in first literal... */

	/* StackInterpreterPrimitives>>#primitiveExternalCall */
static void
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt index;
    sqInt lit;
    sqInt reasonCode;


	/* Check for it being a method for primitiveDoPrimitiveWithArgs.
	   Fetch the first literal of the method; check its an Array of length 4.
	   Look at the function index in case it has been loaded before */
	if (!((/* isOopCompiledMethod: */
			((GIV(newMethod) & 1) == 0)
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
		 && (((literalCountOf(GIV(newMethod))) > 0)
		 && (((lit = longAt((GIV(newMethod) + BaseHeaderSize) + (1U << (shiftForWord())))),
		(/* isArray: */
				((lit & 1) == 0)
			 && (((((usqInt)((longAt(lit)))) >> (instFormatFieldLSB())) & 15) == 2))
			 && (((numSlotsOf(lit)) == 4)
			 && (((index = longAt((lit + BaseHeaderSize) + ((((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))))),
			(index & 1))))))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadMethod;
		return;
	}

	/* Check if we have already looked up the function and failed. */
	index = (index >> 1);
	if (index < 0) {

		/* Function address was not found in this session,
		   Void the primitive function. */
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNotFound;
		return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = externalPrimitiveTable[index - 1];
		if (addr) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);

			/* begin callExternalPrimitive: */
			dispatchFunctionPointer(addr);

			/* begin maybeRetryPrimitiveOnFailure */
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNamedInternal;
		return;
	}

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((lit + BaseHeaderSize) + ((((usqInt)(ExternalCallLiteralFlagsIndex) << (shiftForWord())))), ConstZero);

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((lit + BaseHeaderSize) + ((((usqInt)(ExternalCallLiteralTargetFunctionIndex) << (shiftForWord())))), ConstZero);
	addr = linkExternalCallerrInto(lit, (&GIV(primFailCode)));
	if (!addr) {
		assert((fetchPointerofObject(ExternalCallLiteralFlagsIndex, lit)) == ConstZero);
		reasonCode = (GIV(primFailCode)
					? GIV(primFailCode)
					: PrimErrNotFound);
		GIV(primFailCode) = reasonCode;
		return;
	}

	/* begin callExternalPrimitive: */
	dispatchFunctionPointer(addr);

	/* begin maybeRetryPrimitiveOnFailure */
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

	/* StackInterpreterPrimitives>>#primitiveFindHandlerContext */
static void
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberHandlerMarker, longAt(GIV(stackPointer)), GIV(nilObj));
	if (!handlerOrNilOrZero) {
		handlerOrNilOrZero = GIV(nilObj);
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

	/* StackInterpreterPrimitives>>#primitiveFindNextUnwindContext */
static void
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt handlerOrNilOrZero;
    sqInt senderContext;
    sqInt senderOop;
    char *sp;
    sqInt startContext;
    char *startFP;
    sqInt stopContext;
    char *theFP;
    char *theFP1;
    char *theFPAbove;
    sqInt theMethod;
    char *theSP;

	stopContext = longAt(GIV(stackPointer));
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (/* isContext: */
			((stopContext & 1) == 0)
		 && (((((usqInt)((longAt(stopContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	assert(stopContext != calleeContext);

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (/* isStillMarriedContext: */
		(((longAt((calleeContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(calleeContext)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((calleeContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
		if (longAt(theFP + FoxSavedFP)) {
			startFP = pointerForOop(longAt(theFP + FoxSavedFP));

			/* begin findMethodWithPrimitive:FromFP:UpToContext: */
			theFP1 = startFP;
			theFPAbove = startFP;
			do {
				if (((byteAt((theFP1 + FoxFrameFlags) + 2)) != 0)
				 && (stopContext == (longAt(theFP1 + FoxThisContext)))) {
					handlerOrNilOrZero = 0;
					goto l1;
				}
				if (!(byteAt((theFP1 + FoxFrameFlags) + 3))) {
					theMethod = longAt(theFP1 + FoxMethod);
					if ((primitiveIndexOf(theMethod)) == PrimNumberUnwindMarker) {
						if (theFP1 == theFPAbove) {
							theSP = findSPOfon(theFP1, stackPageFor(theFP1));
						}
						else {
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(theFPAbove)));
							theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
						}

						/* begin ensureFrameIsMarried:SP: */
						if (byteAt((theFP1 + FoxFrameFlags) + 2)) {
							assert(isContext(frameContext(theFP1)));
							handlerOrNilOrZero = longAt(theFP1 + FoxThisContext);
							goto l1;
						}
						handlerOrNilOrZero = marryFrameSP(theFP1, theSP);
						goto l1;
					}
				}
				theFPAbove = theFP1;
				theFP1 = pointerForOop(longAt(theFP1 + FoxSavedFP));
			} while(theFP1 != 0);
			senderContext = longAt(theFPAbove + FoxCallerContext);
			if (!(/* isContext: */
					((senderContext & 1) == 0)
				 && (((((usqInt)((longAt(senderContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))) {
				handlerOrNilOrZero = GIV(nilObj);
				goto l1;
			}
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, senderContext, stopContext);
l1:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
		}
		else {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, longAt(theFP + FoxCallerContext), stopContext);
		}
	}
	else {
		startContext = longAt((calleeContext + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		if (/* isContext: */
			((startContext & 1) == 0)
		 && (((((usqInt)((longAt(startContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(PrimNumberUnwindMarker, startContext, stopContext);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (!handlerOrNilOrZero) {
		handlerOrNilOrZero = GIV(nilObj);
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheByMethod */
static void
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt probe;

	/* begin flushMethodCacheForMethod: */
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == (longAt(GIV(stackPointer)))) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	flushExternalPrimitiveOf(longAt(GIV(stackPointer)));

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined.  */

	/* StackInterpreterPrimitives>>#primitiveFlushCacheBySelector */
static void
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt probe;
    sqInt selector;

	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (32U << (shiftForWord())))))
	 || (selector == (longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(SpecialSelectors) << (shiftForWord())))))) + BaseHeaderSize) + (34U << (shiftForWord())))))) {
		/* begin flushAtCache */
		memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
	}
}


/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */
/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */

	/* StackInterpreterPrimitives>>#primitiveFullGC */
static void
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	incrementalGC();
	fullGC();
	integer = (/* freeSize */
	(oopisLessThan(GIV(freeStart), GIV(reserveStart))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0)) + (sqMemoryExtraBytesLeft(1));

	/* begin methodReturnInteger: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 1) | 1));
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveGetSetFFIExceptionHandling */
static void
primitiveGetSetFFIExceptionHandling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt integer;
    char *sp;

	if (!GIV(argumentCount)) {
		integer = (ioCanCatchFFIExceptions()
					? ffiExceptionResponse
					: -1);

		/* begin methodReturnInteger: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)integer << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (!(ioCanCatchFFIExceptions())) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrUnsupported;
		return;
	}
	if (!(GIV(argumentCount) == 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	arg = longAt(GIV(stackPointer));
	if (!(((arg & 1))
		 && (((((arg = (arg >> 1))) >= -1) && (arg <= 1))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	ffiExceptionResponse = arg;

	/* begin methodReturnReceiver */
	assert(!((failed())));
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */
/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

	/* StackInterpreterPrimitives>>#primitiveIncrementalGC */
static void
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	incrementalGC();
	integerVal = (/* freeSize */
	(oopisLessThan(GIV(freeStart), GIV(reserveStart))
		? (((usqInt) GIV(reserveStart))) - (((usqInt) GIV(freeStart)))
		: 0)) + (sqMemoryExtraBytesLeft(0));

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer)), (((usqInt)integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	because of externalInstVar:ofContext: below */

	/* StackInterpreterPrimitives>>#primitiveInstVarAt */
static void
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt rcvr;
    char *sp;
    unsigned int sz;
    sqInt totalLength;
    sqInt value;

	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(index & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
		return;
	}
	index = (index >> 1);
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l2:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			value = longAt((rcvr + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord())))));
			goto l3;
		}
		if (fmt >= (firstByteFormat())) {
			value = (((usqInt)(byteAt((rcvr + BaseHeaderSize) + (index - 1))) << 1) | 1);
			goto l3;
		}
		integerValue = long32At((rcvr + BaseHeaderSize) + ((((usqInt)((index - 1)) << 2))));

		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
			value = ((integerValue << 1) | 1);
			goto l3;
		}
		newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

		/* storeLong32:ofObject:withValue: */
		long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
		value = newLargeInteger;
l3:	/* end subscript:with:format: */;
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitiveInstVarAtPut */
static void
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt class;
    sqInt classFormat;
    sqInt fixedFields;
    usqInt fmt;
    sqInt hdr;
    sqInt index;
    sqInt newValue;
    sqInt rcvr;
    sqInt signedValueToStore;
    char *sp;
    unsigned int sz;
    sqInt totalLength;
    unsigned int unsignedValueToStore;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(index & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	index = (index >> 1);
	hdr = longAt(rcvr);
	fmt = (((usqInt)(hdr)) >> (instFormatFieldLSB())) & 15;

	/* begin lengthOf:baseHeader:format: */
	if (hdr & TypeMask) {
		sz = hdr & SizeMask;
	}
	else {
		sz = (longAt(rcvr - (BytesPerWord * 2))) & LongSizeMask;
	}
	sz -= 0;
	if (fmt <= 4 /* lastPointerFormat */) {
		totalLength = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		goto l1;
	}
	totalLength = (fmt < (firstByteFormat())
				? ((usqInt)((sz - BaseHeaderSize))) >> 2
				: (sz - BaseHeaderSize) - (fmt & 3));
l1:	/* end lengthOf:baseHeader:format: */;

	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 4 /* lastPointerFormat */)
	 || (fmt == (arrayFormat()))) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = /* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(rcvr - BaseHeaderSize)) & AllButTypeMask);
	classFormat = (longAt((class + BaseHeaderSize) + ((((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))))) - 1;
	fixedFields = (((((usqInt)(classFormat)) >> 11) & 192) + ((((usqInt)(classFormat)) >> 2) & 0x3F)) - 1;
l3:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && (((((usqInt)(hdr)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
		externalInstVarofContextput(index - 1, rcvr, newValue);
	}
	else {
		/* begin subscript:with:storing:format: */
		if (fmt <= 4 /* lastPointerFormat */) {
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(rcvr, GIV(youngStart))) {
				possibleRootStoreIntovalue(rcvr, newValue);
			}
			longAtput((rcvr + BaseHeaderSize) + ((((usqInt)((index - 1)) << (shiftForWord())))), newValue);
			goto l2;
		}
		if (fmt >= (firstByteFormat())) {
			if (!((newValue & 1))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}
			signedValueToStore = (newValue >> 1);
			if (!((signedValueToStore >= 0)
				 && (signedValueToStore <= 0xFF))) {
				GIV(primFailCode) = PrimErrBadArgument;
				goto l2;
			}

			/* storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + (index - 1), signedValueToStore);
			goto l2;
		}
		unsignedValueToStore = positive32BitValueOf(newValue);
		if (!GIV(primFailCode)) {
			/* storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)((index - 1)) << 2))), unsignedValueToStore);
		}
l2:	/* end subscript:with:storing:format: */;
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitive */
#if LRPCheck
EXPORT(void)
primitiveLongRunningPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong gcms;
    sqInt lrpcm;
    sqLong primms;
    sqInt result;
    char *sp;

	lrpcm = 0;
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))))
	 && ((/* addressCouldBeObj: */
		((lrpcm & 3) == 0)
	 && (((((usqInt)lrpcm)) >= (startOfMemory()))
	 && (((((usqInt)lrpcm)) < GIV(freeStart))
	 && (((longAt(lrpcm)) & TypeMask) != HeaderTypeGC))))
	 && (((((usqInt)((longAt(lrpcm)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat()))))) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), 3);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;

		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(result, GIV(youngStart))) {
			possibleRootStoreIntovalue(result, lrpcm);
		}
		longAtput((result + BaseHeaderSize) + (0U << (shiftForWord())), lrpcm);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (1U << (shiftForWord())), (((usqInt)primms << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((result + BaseHeaderSize) + (2U << (shiftForWord())), ((gcms << 1) | 1));
	}
	else {
		result = GIV(nilObj);
	}
	voidLongRunningPrimitive("get");

	/* begin methodReturnValue: */
	assert(!((failed())));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}
#endif /* LRPCheck */


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

	/* StackInterpreterPrimitives>>#primitiveLongRunningPrimitiveSemaphore */
#if LRPCheck
EXPORT(sqInt)
primitiveLongRunningPrimitiveSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt sema;

	sema = longAt(GIV(stackPointer));
	if (sema == GIV(nilObj)) {
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		if (!(/* isSemaphoreOop: */
				((sema & 1) == 0)
			 && ((/* fetchClassOfNonImm: */
				((ccIndex = (((usqInt)((longAt(sema)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(sema - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord()))))))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	voidLongRunningPrimitive("install");

	/* begin methodReturnReceiver */
	assert(!((failed())));
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	return 0;
}
#endif /* LRPCheck */


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Works correctly for cogged methods too. */

	/* StackInterpreterPrimitives>>#primitiveObjectPointsTo */
static void
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt fmt;
    sqInt header;
    sqInt headerSqInt;
    sqInt i;
    sqInt methodHeader;
    usqInt numSlots;
    sqInt rcvr;
    char *sp;
    unsigned int sz;
    sqInt thang;
    sqInt trueOrFalse;

	thang = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	header = longAt(rcvr);
	fmt = (((usqInt)(header)) >> (instFormatFieldLSB())) & 15;
	if (fmt <= 4 /* lastPointerFormat */) {
		if ((fmt == (indexablePointersFormat()))
		 && (((((usqInt)(header)) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)) {
			if (((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
				assert(!((isFree(GIV(stackPage)))));

				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				if (/* isStillMarriedContext: */
					(((longAt((rcvr + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
				 && (!(isWidowedContext(rcvr)))) {
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2);

					/* begin pop:thenPushBool: */
					longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), /* booleanObjectOf: */
						(trueOrFalse
							? GIV(trueObj)
							: GIV(falseObj)));
					GIV(stackPointer) = sp;
					return;
				}
			}
			numSlots = CtxtTempFrameStart + (fetchStackPointerOf(rcvr));
		}
		else {
			/* begin numSlotsOf: */
			headerSqInt = longAt(rcvr);
			sz = (headerSqInt & TypeMask
						? headerSqInt & SizeMask
						: (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask);
			numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		}
	}
	else {
		if (fmt < (firstCompiledMethodFormat())) {

			/* no pointers */
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp;
			return;
		}

		/* begin methodHeaderOf: */
		assert(isCompiledMethod(rcvr));
		methodHeader = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp;
			return;
		}
		numSlots = ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF))) + LiteralStart;
	}
	assert((((numSlots - 1) * BytesPerOop) + BaseHeaderSize) == (lastPointerOf(rcvr)));
	for (i = BaseHeaderSize; i <= (((numSlots - 1) * BytesPerOop) + BaseHeaderSize); i += BytesPerOop) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp;
			return;
		}
	}

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (1 * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp;
}

	/* StackInterpreterPrimitives>>#primitivePerform */
static void
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt i;
    usqInt iUsqInt;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt newReceiver;
    usqInt numArgs;
    usqInt numTemps;
    sqInt object;
    usqInt performMethod;
    sqInt rcvr;
    char *sp;

	performMethod = GIV(newMethod);
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));

	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,
	   so we must adjust argumentCount and slide args now, so that will work. */
	/* Slide arguments down over selector */
	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	lookupClassTag = /* #fetchClassTagOf: #fetchClassOf: */
			((newReceiver & 1)
				? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
				: ((ccIndex = (((usqInt)((longAt(newReceiver)))) >> (compactClassFieldLSB())) & 0x1F)
						? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
						: (longAt(newReceiver - BaseHeaderSize)) & AllButTypeMask));

	/* begin sendBreakpoint:receiver: */
	sendBreakpointclassTag(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), /* #fetchClassTagOf: #fetchClassOf: */
		((newReceiver & 1)
			? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSmallInteger) << (shiftForWord())))))
			: ((ccIndex = (((usqInt)((longAt(newReceiver)))) >> (compactClassFieldLSB())) & 0x1F)
					? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
					: (longAt(newReceiver - BaseHeaderSize)) & AllButTypeMask)));
	if (
#  if SEND_PRINTING
		GIV(printSends)
#  else
		0
#  endif
		) {
		printActivationNameForSelectorstartClass(GIV(messageSelector), lookupClassTag);
		cr();
	}
	findNewMethodInClassTag(lookupClassTag);
	if (!((/* isOopCompiledMethod: */
			((GIV(newMethod) & 1) == 0)
		 && (((((usqInt)((longAt(GIV(newMethod))))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
		 && ((argumentCountOf(GIV(newMethod))) == GIV(argumentCount)))) {

		/* Slide the args back up (sigh) and re-insert the selector. */
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;

		/* Must reset primitiveFunctionPointer for checkForAndFollowForwardedPrimitiveState */
		GIV(newMethod) = performMethod;

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}

	/* begin executeNewMethod */
	if (primitiveFunctionPointer) {
		if ((((usqIntptr_t) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		if (slowPrimitiveResponse()) {
			goto l1;
		}
	}

	/* begin activateNewMethod */
	/* begin justActivateNewMethod: */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + ((((usqInt)(HeaderIndex) << (shiftForWord())))));
	numTemps = (((usqInt)(methodHeader)) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt)(methodHeader)) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */
	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp;
	GIV(framePointer) = GIV(stackPointer);

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;

	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader);
	assert(!((headerIndicatesAlternateBytecodeSet(methodHeader))));
	object = /* encodeFrameFieldHasContext:isBlock:numArgs: */
			(VMBIGENDIAN
				? ((1 + ((numArgs << ((BytesPerWord * 8) - 8)))))
				: ((1 + ((numArgs << 8)))));

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp;
	for (iUsqInt = (numArgs + 1); iUsqInt <= numTemps; iUsqInt += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + ((/* begin literalCountOfMethodHeader: */
	assert((methodHeader & 1)),
((((int) methodHeader)) < 0
			? ((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask
			: (((usqInt)(methodHeader)) >> 10) & 0xFF)))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (((methodHeader & V3PrimitiveBitsMask) != 0)) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */
		GIV(instructionPointer) += 0 /* sizeOfCallPrimitiveBytecode: */;
		if (GIV(primFailCode)) {
			reapAndResetErrorCodeToheader(GIV(stackPointer), methodHeader);
		}
	}
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Pin or unpin the receiver, i.e. make it immobile or mobile, based on the
	argument. Answer whether the object was already pinned. N.B. pinning does
	*not* prevent
	an object from being garbage collected. */

	/* StackInterpreterPrimitives>>#primitivePin */
static void
primitivePin(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt boolean;
    sqInt obj;
    char *sp;
    sqInt wasPinned;

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrUnsupported;
	return;
	obj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((obj & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	boolean = longAt(GIV(stackPointer));
	if (!((boolean == GIV(falseObj))
		 || (boolean == GIV(trueObj)))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	wasPinned = GIV(falseObj);
	if (boolean == GIV(trueObj)) {
		if ((/* isContext: */
			((obj & 1) == 0)
		 && (((((usqInt)((longAt(obj)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && (/* isStillMarriedContext: */
			(((longAt((obj + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(obj))))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadReceiver;
			return;
		}
		if (!(pinObject(obj))) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrNoMemory;
			return;
		}
	}

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), wasPinned);
	GIV(stackPointer) = sp;
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

	/* StackInterpreterPrimitives>>#primitiveSetGCSemaphore */
EXPORT(void)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
	}
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;

		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtMilliseconds */
static void
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqLong deltaMsecs;
    sqLong limit;
    sqLong msecs;
    sqInt msecsObj;
    sqInt sema;

	msecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj);
	if (!GIV(primFailCode)) {
		if (/* isSemaphoreOop: */
			((sema & 1) == 0)
		 && ((/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(sema)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(sema - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord())))))))) {
			/* begin splObj:put: */
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
				possibleRootStoreIntovalue(GIV(specialObjectsOop), sema);
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheTimerSemaphore) << (shiftForWord())))), sema);
			deltaMsecs = msecs - ((ioMSecs()) & MillisecondClockMask);

			/* Handle a roll-over that could happen in between image invocation of ioMSecs and this invocation.
			   This will limit the maximum relative duration to MillisecondClockMask/2, about 3 days currently.
			   Every delay longer than that limit may lead to undefined behavior (shorten delay, or no delay at all) */
			limit = ((usqInt)(MillisecondClockMask)) >> 1;
			if (deltaMsecs > limit) {
				deltaMsecs -= MillisecondClockMask;
			}
			GIV(nextWakeupUsecs) = (deltaMsecs > 0
						? (ioUTCMicroseconds()) + (deltaMsecs * 1000)
						: ioUTCMicroseconds());

			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheTimerSemaphore) << (shiftForWord())))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;

			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

	/* StackInterpreterPrimitives>>#primitiveSignalAtUTCMicroseconds */
static void
primitiveSignalAtUTCMicroseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	usecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj);
	if (!GIV(primFailCode)) {
		if (/* isSemaphoreOop: */
			((sema & 1) == 0)
		 && ((/* fetchClassOfNonImm: */
			((ccIndex = (((usqInt)((longAt(sema)))) >> (compactClassFieldLSB())) & 0x1F)
				? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
				: (longAt(sema - BaseHeaderSize)) & AllButTypeMask)) == (longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassSemaphore) << (shiftForWord())))))))) {
			/* begin splObj:put: */
			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(GIV(specialObjectsOop), GIV(youngStart))) {
				possibleRootStoreIntovalue(GIV(specialObjectsOop), sema);
			}
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheTimerSemaphore) << (shiftForWord())))), sema);
			GIV(nextWakeupUsecs) = usecs;

			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
		if (sema == GIV(nilObj)) {
			/* storePointerUnchecked:ofObject:withValue: */
			longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(TheTimerSemaphore) << (shiftForWord())))), GIV(nilObj));
			GIV(nextWakeupUsecs) = 0;

			/* begin pop: */
			GIV(stackPointer) += 2 * BytesPerWord;
			return;
		}
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
}


/*	Answer a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive answers the raw integral value
	at each slot. 
	e.g. for Strings it answers the character code, not the Character object
	at each slot. */
/*	because of externalInstVar:ofContext: below */

	/* StackInterpreterPrimitives>>#primitiveSlotAt */
static void
primitiveSlotAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt fmt;
    sqInt header;
    sqInt index;
    unsigned int integerValue;
    sqInt newLargeInteger;
    sqInt numLiveSlots;
    sqInt numSlots;
    sqInt oop;
    sqInt rcvr;
    char *sp;
    unsigned int sz;
    sqInt value;

	index = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15;
	index = ((index >> 1)) - 1;
	if (fmt <= 4 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask);
		numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		if ((((usqInt)index)) < numSlots) {
			if (((((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
				assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
				assert(!((isFree(GIV(stackPage)))));

				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				numLiveSlots = (stackPointerForMaybeMarriedContext(rcvr)) + CtxtTempFrameStart;
				value = ((((usqInt)index)) < numLiveSlots
							? externalInstVarofContext(index, rcvr)
							: GIV(nilObj));
			}
			else {
				value = longAt((rcvr + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))));
			}

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return;
		}
		numSlots = numBytesOfBytes(rcvr);
		if ((((usqInt)index)) < numSlots) {
			/* begin pop:thenPushInteger: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((usqInt)(byteAt((rcvr + BaseHeaderSize) + index)) << 1) | 1));
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt == 7 /* sixtyFourBitIndexableFormat */) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 3;
		if ((((usqInt)index)) < numSlots) {
			oop = positive64BitIntegerFor(fetchLong64ofObject(index, rcvr));

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			integerValue = long32At((rcvr + BaseHeaderSize) + ((((usqInt)(index) << 2))));

			/* begin positive32BitIntegerFor: */
			/* begin maybeInlinePositive32BitIntegerFor: */
			assert(!((hasSixtyFourBitImmediates())));
			if ((((unsigned int) integerValue)) <= (MaxSmallInteger)) {
				oop = ((integerValue << 1) | 1);
				goto l1;
			}
			newLargeInteger = eeInstantiateSmallClassIndexformatnumSlots(ClassLargePositiveIntegerCompactIndex, (firstByteFormat()) + (0), 1);

			/* storeLong32:ofObject:withValue: */
			long32Atput((newLargeInteger + BaseHeaderSize), SQ_SWAP_4_BYTES_IF_BIGENDIAN(integerValue));
			oop = newLargeInteger;
l1:	/* end positive32BitIntegerFor: */;

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	return;
}


/*	Assign a slot in an object. This numbers all slots from 1, ignoring the
	distinction between
	named and indexed inst vars. In objects with both named and indexed inst
	vars, the named
	inst vars precede the indexed ones. In non-object indexed objects (objects
	that contain
	bits, not object references) this primitive assigns a raw integral value
	at each slot. */

	/* StackInterpreterPrimitives>>#primitiveSlotAtPut */
static void
primitiveSlotAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    usqInt fmt;
    sqInt header;
    sqInt index;
    sqInt newValue;
    sqInt numSlots;
    int ok;
    sqInt rcvr;
    char *sp;
    unsigned int sz;
    usqIntptr_t value;
    sqInt valueSqInt;

	newValue = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if ((rcvr & 1)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	if (
#  if IMMUTABILITY
		((longAt(rcvr)) & (hex(ImmutabilityBit))) != 0
#  else
		0
#  endif
		) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrNoModification;
		return;
	}
	fmt = (((usqInt)((longAt(rcvr)))) >> (instFormatFieldLSB())) & 15;
	index = ((index >> 1)) - 1;
	if (fmt <= 4 /* lastPointerFormat */) {
		/* begin numSlotsOf: */
		header = longAt(rcvr);
		sz = (header & TypeMask
					? header & SizeMask
					: (longAt(rcvr - (BytesPerWord * 2))) & AllButTypeMask);
		numSlots = ((usqInt)((sz - BaseHeaderSize))) >> (shiftForWord());
		if ((((usqInt)index)) < numSlots) {
			if (((((usqInt)((longAt(rcvr)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex) {
				externalInstVarofContextput(index, rcvr, newValue);
			}
			else {
				/* begin storePointer:ofObject:withValue: */
				if (oopisLessThan(rcvr, GIV(youngStart))) {
					possibleRootStoreIntovalue(rcvr, newValue);
				}
				longAtput((rcvr + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))), newValue);
			}

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* begin positiveMachineIntegerValueOf: */
	if ((newValue & 1)) {
		valueSqInt = (newValue >> 1);
		if (valueSqInt < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = null;
			goto l2;
		}
		value = valueSqInt;
		goto l2;
	}
	classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!((newValue & 1)));
	ccIndex = (((usqInt)((longAt(newValue)))) >> (compactClassFieldLSB())) & 0x1F;
	if (!ccIndex) {
		ok = ((longAt(newValue - BaseHeaderSize)) & AllButTypeMask) == classOop;
		goto l1;
	}
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l2;
	}
	bs = numBytesOfBytes(newValue);
	if (bs > (sizeof(usqIntptr_t))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l2;
	}
	if (((sizeof(usqIntptr_t)) == 8)
	 && (bs > 4)) {
		value = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, newValue)))));
		goto l2;
	}
	value = ((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((newValue + BaseHeaderSize))))));
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrUnsupported;
			return;
		}
		if ((((usqInt)value)) > 0xFF) {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
		numSlots = numBytesOfBytes(rcvr);
		if ((((usqInt)index)) < numSlots) {
			/* storeByte:ofObject:withValue: */
			byteAtput((rcvr + BaseHeaderSize) + index, value);

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (fmt >= (firstLongFormat())) {
		numSlots = ((usqInt)((numBytesOf(rcvr)))) >> 2;
		if ((((usqInt)index)) < numSlots) {
			/* storeLong32:ofObject:withValue: */
			long32Atput((rcvr + BaseHeaderSize) + ((((usqInt)(index) << 2))), value);

			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
			GIV(stackPointer) = sp;
			return;
		}

		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadReceiver;
	return;
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

	/* StackInterpreterPrimitives>>#primitiveStoreStackp */
static void
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt integerPointer;
    sqInt newStackp;
    int onCurrentPage;
    sqInt senderOop;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;

	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer));
	if ((integerPointer & 1)) {
		newStackp = (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
	}
	if (!((!GIV(primFailCode))
		 && (((newStackp >= 0) && (newStackp <= ((numSlotsOf(ctxt)) - CtxtTempFrameStart)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (/* isStillMarriedContext: */
		(((longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(ctxt)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((ctxt + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin stackPageFor: */
		thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt);
		if (onCurrentPage) {
			/* begin setStackPointersFromPage: */
			GIV(stackPointer) = (GIV(stackPage)->headSP);
			GIV(framePointer) = (GIV(stackPage)->headFP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer))));
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
	}

	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))));
	if (!((sp & 1))) {
		stackp = 0;
		goto l1;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(ctxt)));
	stackp = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((ctxt + BaseHeaderSize) + ((((usqInt)(((i + CtxtTempFrameStart) - 1)) << (shiftForWord())))), GIV(nilObj));
	}

	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt)));

	/* storePointerUnchecked:ofObject:withValue: */
	longAtput((ctxt + BaseHeaderSize) + ((((usqInt)(StackPointerIndex) << (shiftForWord())))), (((usqInt)newStackp << 1) | 1));
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive #88. Suspend the receiver, aProcess, such that it can be
	executed again
	by sending #resume. If the given process is not the active process, take
	it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
	c.f. primitiveSuspendBackingUpV1,#568 & primitiveSuspendBackingUpV2,#578 */

	/* StackInterpreterPrimitives>>#primitiveSuspend */
static void
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt myContext;
    sqInt myList;
    sqInt ok;
    sqInt process;

	process = longAt(GIV(stackPointer));
	if (process == (activeProcess())) {
		/* stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
		transferTo(wakeHighestPriority());
		return;
	}
	myList = longAt((process + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))));
	myContext = longAt((process + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!((/* isPointers: */
			((myList & 1) == 0)
		 && (((((usqInt)((longAt(myList)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && (((numSlotsOf(myList)) > LastLinkIndex)
		 && ((/* isContext: */
			((myContext & 1) == 0)
		 && (((((usqInt)((longAt(myContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && ((/* begin isResumableContext: */
			assert(isContext(myContext)),
		((longAt((myContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	ok = removeProcessfromList(process, myList);
	if (!ok) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}

	/* stackTopPut: */
	longAtPointerput(GIV(stackPointer), myList);
}


/*	Primitive #568. Suspend the receiver, aProcess, such that it can be
	executed again
	by sending #resume. If the given process is not the active process, take
	it off
	its corresponding list. If the list was not its run queue assume it was on
	some condition variable (Semaphore, Mutex) and back up its pc to the send
	that invoked the wait state the process entered. Hence when the process
	resumes it will reenter the wait state. Answer the list the receiver was
	previously on,
	unless it was the activeProcess, in which case answer nil.
	c.f. primitiveSuspend,#88 & primitiveSuspendBackingUpV2,#578 */

	/* StackInterpreterPrimitives>>#primitiveSuspendBackingUpV1 */
static void
primitiveSuspendBackingUpV1(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt myContext;
    sqInt myList;
    sqInt ok;
    sqInt process;

	process = longAt(GIV(stackPointer));
	if (process == (activeProcess())) {
		/* stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
		transferTo(wakeHighestPriority());
		return;
	}
	myList = longAt((process + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))));
	myContext = longAt((process + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!((/* isPointers: */
			((myList & 1) == 0)
		 && (((((usqInt)((longAt(myList)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && (((numSlotsOf(myList)) > LastLinkIndex)
		 && ((/* isContext: */
			((myContext & 1) == 0)
		 && (((((usqInt)((longAt(myContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && ((/* begin isResumableContext: */
			assert(isContext(myContext)),
		((longAt((myContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	ok = removeProcessfromList(process, myList);
	if (!ok) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}
	if ((/* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(myList)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(myList - BaseHeaderSize)) & AllButTypeMask)) != GIV(classLinkedListClassTag)) {
		backupContexttoBlockingSendTo(myContext, myList);
	}

	/* stackTopPut: */
	longAtPointerput(GIV(stackPointer), myList);
}


/*	Primitive #578. Suspend the receiver, aProcess, such that it can be
	executed again
	by sending #resume. If the given process is not the active process, take
	it off
	its corresponding list. If the list was not its run queue assume it was on
	some condition variable (Semaphore, Mutex) and back up its pc to the send
	that invoked the wait state the process entered. Hence when the process
	resumes it will reenter the wait state. Answer the list the receiver was
	previously on iff
	it was not active and not blocked, otherwise answer nil.
	c.f. primitiveSuspend,#88 & primitiveSuspendBackingUpV1,#568,
	which always answer the list the process was on, even if blocked. */

	/* StackInterpreterPrimitives>>#primitiveSuspendBackingUpV2 */
EXPORT(void)
primitiveSuspendBackingUpV2(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt ccIndex;
    sqInt myContext;
    sqInt myList;
    sqInt ok;
    sqInt process;

	process = longAt(GIV(stackPointer));
	if (process == (activeProcess())) {
		/* stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
		transferTo(wakeHighestPriority());
		return;
	}
	myList = longAt((process + BaseHeaderSize) + ((((usqInt)(MyListIndex) << (shiftForWord())))));
	myContext = longAt((process + BaseHeaderSize) + ((((usqInt)(SuspendedContextIndex) << (shiftForWord())))));
	if (!((/* isPointers: */
			((myList & 1) == 0)
		 && (((((usqInt)((longAt(myList)))) >> (instFormatFieldLSB())) & 15) <= 4 /* lastPointerFormat */))
		 && (((numSlotsOf(myList)) > LastLinkIndex)
		 && ((/* isContext: */
			((myContext & 1) == 0)
		 && (((((usqInt)((longAt(myContext)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex))
		 && ((/* begin isResumableContext: */
			assert(isContext(myContext)),
		((longAt((myContext + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))))) & 1))))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadReceiver;
		return;
	}
	ok = removeProcessfromList(process, myList);
	if (!ok) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrOperationFailed;
		return;
	}
	if ((/* #fetchClassTagOfNonImm: #fetchClassOfNonImm: */
		((ccIndex = (((usqInt)((longAt(myList)))) >> (compactClassFieldLSB())) & 0x1F)
			? longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(CompactClasses) << (shiftForWord())))))) + BaseHeaderSize) + ((((usqInt)((ccIndex - 1)) << (shiftForWord())))))
			: (longAt(myList - BaseHeaderSize)) & AllButTypeMask)) != GIV(classLinkedListClassTag)) {
		backupContexttoBlockingSendTo(myContext, myList);

		/* stackTopPut: */
		longAtPointerput(GIV(stackPointer), GIV(nilObj));
	}
	else {
		/* stackTopPut: */
		longAtPointerput(GIV(stackPointer), myList);
	}
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
 */

	/* StackInterpreterPrimitives>>#primitiveTerminateTo */
static void
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    char *callerFP;
    char *callerFP1;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *frameAbove;
    sqInt handlerOrNilOrZero;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    StackPage *pageToStopOn;
    sqInt senderOop;
    sqInt senderOopSqInt;
    char *source;
    int stackedReceiverOffset;
    char *theFP;
    StackPage *thePage;
    sqInt thisCtx;

	contextsFP = ((char *) 0);
	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (/* isContext: */
			((aContextOrNil & 1) == 0)
		 && (((((usqInt)((longAt(aContextOrNil)))) >> (compactClassFieldLSB())) & 0x1F) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
	assert(!((isFree(GIV(stackPage)))));

	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((aContextOrNil != GIV(nilObj))
	 && (/* isStillMarriedContext: */
		(((longAt((aContextOrNil + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(aContextOrNil))))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((aContextOrNil + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		contextsFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin stackPageFor: */
		pageToStopOn = stackPageAtpages(pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
	}
	else {
		pageToStopOn = 0;
	}
	if (/* isStillMarriedContext: */
		(((longAt((thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
	 && (!(isWidowedContext(thisCtx)))) {
		/* begin frameOfMarriedContext: */
		senderOop = longAt((thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);
		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			if ((pointerForOop(longAt(theFP + FoxSavedFP))) != contextsFP) {
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFP + FoxFrameFlags) + 1))) << (shiftForWord()))));

				/* begin findFrameAbove:inPage: */
				callerFP = ((char *) 0);
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l1;
				}
				while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l1;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
l1:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(pointerForOop(longAt(frameAbove + FoxCallerSavedIP))));

				/* begin frameCallerSP: */
				assert(!(isBaseFrame(frameAbove)));
				newSP = (frameAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;
				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx));

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput(
					(thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))),
					(/* begin withSmallIntegerTags: */
						assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0),
					(oopForPointer(newFP)) + 1 /* smallIntegerTag */));

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput(
					(thisCtx + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))),
					(/* begin withSmallIntegerTags: */
						assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0),
					(oopForPointer(contextsFP)) + 1 /* smallIntegerTag */));
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}

			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
			return;
		}

		/* May cause a GC!! */
		theFP = externalEnsureIsBaseFrame(theFP);

		/* May also reclaim aContextOrNil's page, hence... */
		currentCtx = longAt(theFP + FoxCallerContext);
		if ((aContextOrNil != GIV(nilObj))
		 && (/* isStillMarriedContext: */
			(((longAt((aContextOrNil + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
		 && (!(isWidowedContext(aContextOrNil))))) {
			/* begin frameOfMarriedContext: */
			senderOop = longAt((aContextOrNil + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
			assert((senderOop & 1));
			contextsFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

			/* begin stackPageFor: */
			pageToStopOn = stackPageAtpages(pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		currentCtx = longAt((thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
	}

	/* begin context:hasSender: */
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCtx, aContextOrNil);
	if (!handlerOrNilOrZero) {

		/* Need to walk the stack freeing stack pages and nilling contexts. */
		while (!((currentCtx == aContextOrNil)
		 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx));
			if (((longAt((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
				/* begin frameOfMarriedContext: */
				senderOop = longAt((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
				assert((senderOop & 1));
				theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

				/* begin stackPageFor: */
				thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					callerFP = ((char *) 0);
					fp = (thePage->headFP);
					if (fp == theFP) {
						frameAbove = 0;
						goto l2;
					}
					while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
						if (callerFP == theFP) {
							frameAbove = fp;
							goto l2;
						}
						fp = callerFP;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
l2:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);

					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */
					frameAbove = externalEnsureIsBaseFrame(frameAbove);
					if ((aContextOrNil != GIV(nilObj))
					 && (/* isStillMarriedContext: */
						(((longAt((aContextOrNil + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1))
					 && (!(isWidowedContext(aContextOrNil))))) {
						/* begin frameOfMarriedContext: */
						senderOopSqInt = longAt((aContextOrNil + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
						assert((senderOopSqInt & 1));
						contextsFP = pointerForOop(senderOopSqInt - 1 /* smallIntegerTag */);

						/* begin stackPageFor: */
						pageToStopOn = stackPageAtpages(pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {

						/* We're here.  Cut back the stack to aContextOrNil's frame,
						   push its instructionPointer if it's not already a head frame,
						   and we're done. */
						/* begin findFrameAbove:inPage: */
						callerFP1 = ((char *) 0);
						fp1 = (thePage->headFP);
						if (fp1 == contextsFP) {
							frameAbove = 0;
							goto l3;
						}
						while (((callerFP1 = pointerForOop(longAt(fp1 + FoxSavedFP)))) != 0) {
							if (callerFP1 == contextsFP) {
								frameAbove = fp1;
								goto l3;
							}
							fp1 = callerFP1;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
l3:	/* end findFrameAbove:inPage: */;
						if (frameAbove) {
							contextsSP = ((/* begin frameCallerSP: */
	assert(!(isBaseFrame(frameAbove))),
(frameAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((frameAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord)) - BytesPerWord;
							longAtput(contextsSP, pointerForOop(longAt(frameAbove + FoxCallerSavedIP)));

							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {

						/* We can free the entire page without further ado. */
						/* for a short time invariant is violated; assert follows */
						currentCtx = longAt(((thePage->baseFP)) + FoxCallerContext);
						freeStackPageNoAssert(thePage);
					}
				}
			}
			else {
				nextCntx = longAt((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));

				/* begin markContextAsDead: */
				assert(isContext(currentCtx));

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((currentCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), GIV(nilObj));

				/* storePointerUnchecked:ofObject:withValue: */
				longAtput((currentCtx + BaseHeaderSize) + ((((usqInt)(InstructionPointerIndex) << (shiftForWord())))), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed());
	if (((longAt((thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer)));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx)));

		/* begin frameOfMarriedContext: */
		senderOop = longAt((thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))));
		assert((senderOop & 1));
		theFP = pointerForOop(senderOop - 1 /* smallIntegerTag */);

		/* begin frameCallerContext:put: */
		assert((aContextOrNil == (nilObject()))
		 || (isContext(aContextOrNil)));
		longAtput(theFP + FoxCallerContext, aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		if (oopisLessThan(thisCtx, GIV(youngStart))) {
			possibleRootStoreIntovalue(thisCtx, aContextOrNil);
		}
		longAtput((thisCtx + BaseHeaderSize) + ((((usqInt)(SenderIndex) << (shiftForWord())))), aContextOrNil);
	}

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	assert(GIV(stackPage) == (GIV(mostRecentlyUsedPage)));
}


/*	Primitive. Unload the module with the given name.
	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is forced by invalidating all external
	primitive methods and activations in flushExternalPrimitives.
	N.B. since this is most likely a development time activity we don't care
	about performance. */

	/* StackInterpreterPrimitives>>#primitiveUnloadModule */
static void
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt moduleLength;
    sqInt moduleName;
    sqInt oopSqInt;
    unsigned int sz;

	moduleName = longAt(GIV(stackPointer));
	if (!(/* isBytes: */
			((moduleName & 1) == 0)
		 && (((((usqInt)((longAt(moduleName)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleLength = numBytesOfBytes(moduleName);
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), moduleLength))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (/* object:equalsString:ofSize: */
		(/* isBytes: */
		((moduleName & 1) == 0)
	 && (((((usqInt)((longAt(moduleName)))) >> (instFormatFieldLSB())) & 15) >= (firstByteFormat())))
	 && ((!(((((usqInt)((longAt(moduleName)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())))
	 && (((numBytesOfBytes(moduleName)) == moduleLength)
	 && ((strncmp("SqueakFFIPrims", firstIndexableField(moduleName), moduleLength)) == 0)))) {
		primitiveCalloutPointer = ((void *) -1);
	}
	forceInterruptCheck();

	/* begin flushExternalPrimitives */
	/* begin allObjectsDo: */
	oopSqInt = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oopSqInt)) < GIV(freeStart)) {
		if (!(((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree)) {
			if (((((usqInt)((longAt(oopSqInt)))) >> (instFormatFieldLSB())) & 15) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */
				flushExternalPrimitiveOf(oopSqInt);
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oopSqInt, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oopSqInt)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oopSqInt)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oopSqInt);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oopSqInt - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oopSqInt = (oopSqInt + sz) + (headerTypeBytes[(longAt(oopSqInt + sz)) & TypeMask]);
	}

	/* begin flushMethodCache */
	memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
	memset(externalPrimitiveTable, 0, MaxExternalPrimitiveTableSize * (sizeof(externalPrimitiveTable[0])));
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end (v3)/size(Spur) of old-space (0-based, read-only)
	2	end (v3)/size(Spur) of young/new-space (read-only)
	3	end (v3)/size(Spur) of heap (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs (SqueakV3) or scavenges (Spur) since startup (read-only)
	10	total milliseconds in incremental GCs (SqueakV3) or scavenges (Spur)
	since startup (read-only)
	11	tenures of surving objects since startup or reset (read-write)
	12-20 were specific to ikp's JITTER VM, now 12 16 open for use
	13	if started, the start time in utc microseconds of the high-priority
	ticker 14	if started, the number of checkHighPriorityTickees calls
	15	if started, the number of tickee calls from checkHighPriorityTickees
	16	total microseconds at idle since start-up (if non-zero)
	17	fraction of the code zone to use (Sista only; used to control code zone
	use to preserve sendAndBranchData on counter tripped callback)
	18	total milliseconds in compaction phase of full GC since start-up (Spur
	only) 19	scavenge threshold, the effective size of eden. When eden fills
	to the threshold a scavenge is scheduled. Newer Spur VMs only.
	20	utc microseconds at VM start-up (actually at time initialization, which
	precedes image load).
	21	root/remembered table size (occupancy) (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc (stored
	in image file header).
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	Spur: bytes allocated in total since start-up or reset (read-write)
	(Used to be number of allocations done before current IGC/FGC (read-only))
	35	number of survivor objects after current IGC/FGC (read-only)
	36	millisecond clock when current IGC/FGC completed (read-only)
	37	number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38	milliseconds taken by current IGC (read-only)
	39	Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40	BytesPerOop for this image
	41	imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (stored in image file header; Cog only;
	otherwise nil)
	48	various header flags. See getImageHeaderFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	
		50	max literal count for JIT compile (stored in image file header; Cog
	only; otherwise nil)
	51 nil; reserved for VM parameters that persist in the image (such as eden
	above) 52	root/remembered table capacity
	53	number of segments (Spur only; otherwise nil)
	54	total size of free old space (Spur only, otherwise nil)
	55	ratio of growth and image size at or above which a GC will be performed
	post scavenge
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	65	various VM feature flags; see getCogVMFeatureFlags
	66	the byte size of a stack page
	67	the max allowed size of old space (Spur only; nil otherwise; 0 implies
	no limit except that of the underlying platform)
	68	the average number of live stack pages when scanned by GC (at
	scavenge/gc/become et al) (read-write)
	69	the maximum number of live stack pages when scanned by GC (at
	scavenge/gc/become et al) (read-write)
	70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
	71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
	72 total milliseconds in full GCs Mark phase since startup (read-only)
	73 total milliseconds in full GCs Sweep phase since startup (read-only,
	can be 0 depending on compactors)
	74 maximum pause time due to segment allocation
	75 whether the arithmetic primitives perform conversion in case of mixed
	SmallInteger/Float (true) or fail (false)
	76 the minimum unused headroom in all stack pages; Cog VMs only
	
	Note: Thanks to Ian Piumarta for this primitive. */

	/* StackInterpreterPrimitives>>#primitiveVMParameter */
static void
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t arg;
    sqInt argOop;
    sqInt bs;
    usqInt ccIndex;
    sqInt classOop;
    sqInt index;
    int mustFlush;
    int ok;
    sqInt oldPrimitiveDoMixedArithmetic;
    sqInt oop;
    sqInt paramsArraySize;
    sqInt result;
    sqInt resultSqInt;
    char *sp;
    sqInt value;
    sqInt valuePointer;

	paramsArraySize = 76;
	if (!GIV(argumentCount)) {
		/* begin primitiveAllVMParameters: */
		resultSqInt = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassArray) << (shiftForWord()))))), paramsArraySize);
		valuePointer = positiveMachineIntegerFor(GIV(youngStart) - (startOfMemory()));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (0U << (shiftForWord())), valuePointer);
		valuePointer = (((usqInt)(GIV(freeStart) - (startOfMemory())) << 1) | 1);

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (1U << (shiftForWord())), valuePointer);
		valuePointer = positiveMachineIntegerFor(GIV(endOfMemory) - (startOfMemory()));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (2U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (5U << (shiftForWord())), (((usqInt)GIV(tenuringThreshold) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (6U << (shiftForWord())), (((usqInt)GIV(statFullGCs) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (7U << (shiftForWord())), ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (8U << (shiftForWord())), (((usqInt)GIV(statIncrGCs) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (9U << (shiftForWord())), ((((GIV(statIncrGCUsecs) + 500) / 1000) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (10U << (shiftForWord())), (((usqInt)GIV(statTenures) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (11U << (shiftForWord())), (((usqInt)eventTraceMask << 1) | 1));
		valuePointer = 
#      if VM_TICKER
				positive64BitIntegerFor(ioVMTickerStartUSecs())
#      else
				ConstZero
#      endif
				;

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (12U << (shiftForWord())), valuePointer);
		valuePointer = 
#      if VM_TICKER
				positiveMachineIntegerFor(ioVMTickerCount())
#      else
				ConstZero
#      endif
				;

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (13U << (shiftForWord())), valuePointer);
		valuePointer = 
#      if VM_TICKER
				positiveMachineIntegerFor(ioVMTickeeCallCount())
#      else
				ConstZero
#      endif
				;

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (14U << (shiftForWord())), valuePointer);
		valuePointer = positive64BitIntegerFor(GIV(statIdleUsecs));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (15U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (16U << (shiftForWord())), ConstZero);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (17U << (shiftForWord())), ConstZero);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (18U << (shiftForWord())), ConstZero);
		valuePointer = positive64BitIntegerFor(ioUTCStartMicroseconds());

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (19U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (20U << (shiftForWord())), (((usqInt)GIV(rootTableCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (21U << (shiftForWord())), (((usqInt)GIV(statRootTableOverflows) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (22U << (shiftForWord())), (((usqInt)extraVMMemory << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (23U << (shiftForWord())), (((usqInt)GIV(shrinkThreshold) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (24U << (shiftForWord())), (((usqInt)GIV(growHeadroom) << 1) | 1));
		valuePointer = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (25U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (26U << (shiftForWord())), (((usqInt)GIV(statMarkCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (27U << (shiftForWord())), (((usqInt)GIV(statSweepCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (28U << (shiftForWord())), (((usqInt)GIV(statMkFwdCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (29U << (shiftForWord())), (((usqInt)GIV(statCompMoveCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (30U << (shiftForWord())), (((usqInt)GIV(statGrowMemory) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (0x1FU << (shiftForWord())), (((usqInt)GIV(statShrinkMemory) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (32U << (shiftForWord())), (((usqInt)GIV(statRootTableCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (34U << (shiftForWord())), (((usqInt)GIV(statSurvivorCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (35U << (shiftForWord())), ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (36U << (shiftForWord())), (((usqInt)GIV(statSpecialMarkCount) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (37U << (shiftForWord())), ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (38U << (shiftForWord())), (((usqInt)GIV(statPendingFinalizationSignals) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (39U << (shiftForWord())), (((usqInt)BytesPerWord << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (40U << (shiftForWord())), (((usqInt)6505 /* imageFormatVersion */ << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (41U << (shiftForWord())), (((usqInt)GIV(numStackPages) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (42U << (shiftForWord())), (((usqInt)desiredNumStackPages << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (43U << (shiftForWord())), (((usqInt)GIV(edenBytes) << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (44U << (shiftForWord())), (((usqInt)desiredEdenBytes << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (45U << (shiftForWord())), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (46U << (shiftForWord())), GIV(nilObj));
		valuePointer = (((usqInt)(((usqInt)((getImageHeaderFlags()))) >> 2) << 1) | 1);

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (47U << (shiftForWord())), valuePointer);
		valuePointer = (((usqInt)(ioGetMaxExtSemTableSize()) << 1) | 1);

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (48U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (49U << (shiftForWord())), GIV(nilObj));
		valuePointer = (((usqInt)(((GIV(oldImageBaseAddress) != (startOfMemory())
		? 1
		: 0)) + ((sqImageFileIsEmbedded()
		? 2
		: 0))) << 1) | 1);

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (50U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (51U << (shiftForWord())), (((usqInt)RootTableSize << 1) | 1));
		valuePointer = positive64BitIntegerFor(GIV(statProcessSwitch));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (55U << (shiftForWord())), valuePointer);
		valuePointer = positive64BitIntegerFor(GIV(statIOProcessEvents));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (56U << (shiftForWord())), valuePointer);
		valuePointer = positive64BitIntegerFor(GIV(statForceInterruptCheck));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (57U << (shiftForWord())), valuePointer);
		valuePointer = positive64BitIntegerFor(GIV(statCheckForEvents));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (58U << (shiftForWord())), valuePointer);
		valuePointer = positive64BitIntegerFor(GIV(statStackOverflow));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (59U << (shiftForWord())), valuePointer);
		valuePointer = positive64BitIntegerFor(GIV(statStackPageDivorce));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (60U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (61U << (shiftForWord())), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (0x3EU << (shiftForWord())), GIV(nilObj));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (0x3FU << (shiftForWord())), ConstZero);
		valuePointer = getCogVMFeatureFlags();

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (64U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (65U << (shiftForWord())), (((usqInt)GIV(bytesPerPage) << 1) | 1));
		valuePointer = floatObjectOf(statAverageLivePagesWhenMapping());

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (67U << (shiftForWord())), valuePointer);
		valuePointer = (((usqInt)(GIV(statMaxPageCountWhenMapping)) << 1) | 1);

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (68U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (69U << (shiftForWord())), (((usqInt)VM_PROXY_MAJOR /* vmProxyMajorVersion */ << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (70U << (shiftForWord())), (((usqInt)VM_PROXY_MINOR /* vmProxyMinorVersion */ << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (71U << (shiftForWord())), (((usqInt)0 /* ((statMarkUsecs + 500) // 1000) */ << 1) | 1));

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (72U << (shiftForWord())), (((usqInt)0 /* ((statSweepUsecs + 500) // 1000) */ << 1) | 1));
		valuePointer = /* booleanObjectOf: */
				(primitiveDoMixedArithmetic
					? GIV(trueObj)
					: GIV(falseObj));

		/* begin storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (74U << (shiftForWord())), valuePointer);

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((resultSqInt + BaseHeaderSize) + (75U << (shiftForWord())), (((usqInt)-1 /* minimumUnusedHeadroom */ << 1) | 1));
		beRootIfOld(resultSqInt);

		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultSqInt);
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) > 2) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadNumArgs;
		return;
	}
	index = longAt(GIV(stackPointer) + (((GIV(argumentCount) == 1
		? 0
		: 1)) * BytesPerWord));
	if (!((index & 1))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	index = (index >> 1);
	if ((index < 1)
	 || (index > paramsArraySize)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadIndex;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* read VM parameter; written this way to avoid branch limits in V3 bytecode set */
		/* written thus to enable Slang inlining of primitiveGetVMParameter: */
		/* begin primitiveGetVMParameter: */
		switch (index) {
		case 1:
			result = positiveMachineIntegerFor(GIV(youngStart) - (startOfMemory()));
			goto l1;
			break;
		case 2:
			result = (((usqInt)(GIV(freeStart) - (startOfMemory())) << 1) | 1);
			goto l1;
			break;
		case 3:
			result = positiveMachineIntegerFor(GIV(endOfMemory) - (startOfMemory()));
			goto l1;
			break;
		case 6:
			result = (((usqInt)GIV(tenuringThreshold) << 1) | 1);
			goto l1;
			break;
		case 7:
			result = (((usqInt)GIV(statFullGCs) << 1) | 1);
			goto l1;
			break;
		case 8:
			result = ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1);
			goto l1;
			break;
		case 9:
			result = (((usqInt)GIV(statIncrGCs) << 1) | 1);
			goto l1;
			break;
		case 10:
			result = ((((GIV(statIncrGCUsecs) + 500) / 1000) << 1) | 1);
			goto l1;
			break;
		case 11:
			result = (((usqInt)GIV(statTenures) << 1) | 1);
			goto l1;
			break;
		case 12:
			result = (((usqInt)eventTraceMask << 1) | 1);
			goto l1;
			break;
		case 13:
			result = 
#        if VM_TICKER
					positive64BitIntegerFor(ioVMTickerStartUSecs())
#        else
					ConstZero
#        endif
					;
			goto l1;
			break;
		case 14:
			result = 
#        if VM_TICKER
					positiveMachineIntegerFor(ioVMTickerCount())
#        else
					ConstZero
#        endif
					;
			goto l1;
			break;
		case 15:
			result = 
#        if VM_TICKER
					positiveMachineIntegerFor(ioVMTickeeCallCount())
#        else
					ConstZero
#        endif
					;
			goto l1;
			break;
		case 16:
			result = positive64BitIntegerFor(GIV(statIdleUsecs));
			goto l1;
			break;
		case 17:
			result = ConstZero;
			goto l1;
			break;
		case 18:
			result = ConstZero;
			goto l1;
			break;
		case 19:
			result = ConstZero;
			goto l1;
			break;
		case 20:
			result = positive64BitIntegerFor(ioUTCStartMicroseconds());
			goto l1;
			break;
		case 21:
			result = (((usqInt)GIV(rootTableCount) << 1) | 1);
			goto l1;
			break;
		case 22:
			result = (((usqInt)GIV(statRootTableOverflows) << 1) | 1);
			goto l1;
			break;
		case 23:
			result = (((usqInt)extraVMMemory << 1) | 1);
			goto l1;
			break;
		case 24:
			result = (((usqInt)GIV(shrinkThreshold) << 1) | 1);
			goto l1;
			break;
		case 25:
			result = (((usqInt)GIV(growHeadroom) << 1) | 1);
			goto l1;
			break;
		case 26:
			result = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);
			goto l1;
			break;
		case 27:
			result = (((usqInt)GIV(statMarkCount) << 1) | 1);
			goto l1;
			break;
		case 28:
			result = (((usqInt)GIV(statSweepCount) << 1) | 1);
			goto l1;
			break;
		case 29:
			result = (((usqInt)GIV(statMkFwdCount) << 1) | 1);
			goto l1;
			break;
		case 30:
			result = (((usqInt)GIV(statCompMoveCount) << 1) | 1);
			goto l1;
			break;
		case 0x1F:
			result = (((usqInt)GIV(statGrowMemory) << 1) | 1);
			goto l1;
			break;
		case 32:
			result = (((usqInt)GIV(statShrinkMemory) << 1) | 1);
			goto l1;
			break;
		case 33:
			result = (((usqInt)GIV(statRootTableCount) << 1) | 1);
			goto l1;
			break;
		case 34:
			result = null;
			goto l1;
			break;
		case 35:
			result = (((usqInt)GIV(statSurvivorCount) << 1) | 1);
			goto l1;
			break;
		case 36:
			result = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1);
			goto l1;
			break;
		case 37:
			result = (((usqInt)GIV(statSpecialMarkCount) << 1) | 1);
			goto l1;
			break;
		case 38:
			result = ((((GIV(statIGCDeltaUsecs) + 500) / 1000) << 1) | 1);
			goto l1;
			break;
		case 39:
			result = (((usqInt)GIV(statPendingFinalizationSignals) << 1) | 1);
			goto l1;
			break;
		case 40:
			result = (((usqInt)BytesPerWord << 1) | 1);
			goto l1;
			break;
		case 41:
			result = (((usqInt)6505 /* imageFormatVersion */ << 1) | 1);
			goto l1;
			break;
		case 42:
			result = (((usqInt)GIV(numStackPages) << 1) | 1);
			goto l1;
			break;
		case 43:
			result = (((usqInt)desiredNumStackPages << 1) | 1);
			goto l1;
			break;
		case 44:
			result = (((usqInt)GIV(edenBytes) << 1) | 1);
			goto l1;
			break;
		case 45:
			result = (((usqInt)desiredEdenBytes << 1) | 1);
			goto l1;
			break;
		case 46:
			result = GIV(nilObj);
			goto l1;
			break;
		case 47:
			result = GIV(nilObj);
			goto l1;
			break;
		case 48:
			result = (((usqInt)(((usqInt)((getImageHeaderFlags()))) >> 2) << 1) | 1);
			goto l1;
			break;
		case 49:
			result = (((usqInt)(ioGetMaxExtSemTableSize()) << 1) | 1);
			goto l1;
			break;
		case 50:
			result = GIV(nilObj);
			goto l1;
			break;
		case 51:
			result = (((usqInt)(((GIV(oldImageBaseAddress) != (startOfMemory())
		? 1
		: 0)) + ((sqImageFileIsEmbedded()
		? 2
		: 0))) << 1) | 1);
			goto l1;
			break;
		case 52:
			result = (((usqInt)RootTableSize << 1) | 1);
			goto l1;
			break;
		case 53:
			result = null;
			goto l1;
			break;
		case 54:
			result = null;
			goto l1;
			break;
		case 55:
			result = null;
			goto l1;
			break;
		case 56:
			result = positive64BitIntegerFor(GIV(statProcessSwitch));
			goto l1;
			break;
		case 57:
			result = positive64BitIntegerFor(GIV(statIOProcessEvents));
			goto l1;
			break;
		case 58:
			result = positive64BitIntegerFor(GIV(statForceInterruptCheck));
			goto l1;
			break;
		case 59:
			result = positive64BitIntegerFor(GIV(statCheckForEvents));
			goto l1;
			break;
		case 60:
			result = positive64BitIntegerFor(GIV(statStackOverflow));
			goto l1;
			break;
		case 61:
			result = positive64BitIntegerFor(GIV(statStackPageDivorce));
			goto l1;
			break;
		case 0x3E:
			result = GIV(nilObj);
			goto l1;
			break;
		case 0x3F:
			result = GIV(nilObj);
			goto l1;
			break;
		case 64:
			result = ConstZero;
			goto l1;
			break;
		case 65:
			result = getCogVMFeatureFlags();
			goto l1;
			break;
		case 66:
			result = (((usqInt)GIV(bytesPerPage) << 1) | 1);
			goto l1;
			break;
		case 67:
			result = null;
			goto l1;
			break;
		case 68:
			result = floatObjectOf(statAverageLivePagesWhenMapping());
			goto l1;
			break;
		case 69:
			result = (((usqInt)(GIV(statMaxPageCountWhenMapping)) << 1) | 1);
			goto l1;
			break;
		case 70:
			result = (((usqInt)VM_PROXY_MAJOR /* vmProxyMajorVersion */ << 1) | 1);
			goto l1;
			break;
		case 71:
			result = (((usqInt)VM_PROXY_MINOR /* vmProxyMinorVersion */ << 1) | 1);
			goto l1;
			break;
		case 72:
			result = (((usqInt)0 /* ((statMarkUsecs + 500) // 1000) */ << 1) | 1);
			goto l1;
			break;
		case 73:
			result = (((usqInt)0 /* ((statSweepUsecs + 500) // 1000) */ << 1) | 1);
			goto l1;
			break;
		case 74:
			result = null;
			goto l1;
			break;
		case 75:
			result = /* booleanObjectOf: */
					(primitiveDoMixedArithmetic
						? GIV(trueObj)
						: GIV(falseObj));
			goto l1;
			break;
		case 76:
			result = (((usqInt)-1 /* minimumUnusedHeadroom */ << 1) | 1);
			goto l1;
			break;
		default:
			result = null;
			goto l1;
		}
l1:	/* end primitiveGetVMParameter: */;
		oop = (!(result)
				? GIV(nilObj)
				: result);

		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return;
	}
	argOop = longAt(GIV(stackPointer));

	/* begin primitiveSetVMParameter:arg: */
	switch (index) {
	case 17:
	case 55:
	case 68:
		if (!((isFloatInstance(argOop))
			 || ((argOop & 1)))) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		break;
	case 67:
		/* begin positiveMachineIntegerValueOf: */
		if ((argOop & 1)) {
			value = (argOop >> 1);
			if (value < 0) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg = ((usqIntptr_t) null);
				goto l4;
			}
			arg = ((usqIntptr_t) value);
			goto l4;
		}
		classOop = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + ((((usqInt)(ClassLargePositiveInteger) << (shiftForWord())))));

		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!((argOop & 1)));
		ccIndex = (((usqInt)((longAt(argOop)))) >> (compactClassFieldLSB())) & 0x1F;
		if (!ccIndex) {
			ok = ((longAt(argOop - BaseHeaderSize)) & AllButTypeMask) == classOop;
			goto l3;
		}
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l3;
l3:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			arg = 0;
			goto l4;
		}
		bs = numBytesOfBytes(argOop);
		if (bs > (sizeof(usqIntptr_t))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			arg = 0;
			goto l4;
		}
		if (((sizeof(usqIntptr_t)) == 8)
		 && (bs > 4)) {
			arg = ((usqIntptr_t) (SQ_SWAP_8_BYTES_IF_BIGENDIAN((fetchLong64ofObject(0, argOop)))));
			goto l4;
		}
		arg = ((usqIntptr_t) (((unsigned int) (SQ_SWAP_4_BYTES_IF_BIGENDIAN((long32At((argOop + BaseHeaderSize))))))));
l4:	/* end positiveMachineIntegerValueOf: */;
		break;
	case 75:
		/* begin booleanValueOf: */
		if (argOop == GIV(trueObj)) {
			arg = 1;
			goto l2;
		}
		if (argOop == GIV(falseObj)) {
			arg = 0;
			goto l2;
		}

		/* begin success: */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
l2:	/* end booleanValueOf: */;
		break;
	default:
		arg = (argOop >> 1);
	}
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		goto l6;
	}

	/* primitiveFailFor: */
	GIV(primFailCode) = PrimErrBadArgument;
	switch (index) {
	case 5:
		resultSqInt = GIV(nilObj);

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		break;
	case 6:
		resultSqInt = (((usqInt)GIV(tenuringThreshold) << 1) | 1);

		/* begin tenuringThreshold: */
		GIV(tenuringThreshold) = arg;
		GIV(primFailCode) = 0;
		break;
	case 12:
		resultSqInt = (((usqInt)eventTraceMask << 1) | 1);
		eventTraceMask = arg;

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		break;
	case 11:
		if (arg >= 0) {
			resultSqInt = (((usqInt)GIV(statTenures) << 1) | 1);

			/* begin statTenures: */
			GIV(statTenures) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 17:
		break;
	case 23:
		resultSqInt = (((usqInt)extraVMMemory << 1) | 1);
		extraVMMemory = arg;

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		break;
	case 24:
		if (arg > 0) {
			resultSqInt = (((usqInt)GIV(shrinkThreshold) << 1) | 1);

			/* shrinkThreshold: */
			GIV(shrinkThreshold) = arg;

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 25:
		if (arg > 0) {
			resultSqInt = (((usqInt)GIV(growHeadroom) << 1) | 1);

			/* growHeadroom: */
			GIV(growHeadroom) = arg;

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 26:
		if (arg >= 0) {

			/* 0 turns off the heartbeat */
			resultSqInt = (((usqInt)(ioHeartbeatMilliseconds()) << 1) | 1);
			ioSetHeartbeatMilliseconds(arg);

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 34:
		break;
	case 43:
		if (((arg >= 0) && (arg <= 0xFFFF))) {
			resultSqInt = (((usqInt)desiredNumStackPages << 1) | 1);
			desiredNumStackPages = arg;

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 45:
		if (arg >= 0) {
			resultSqInt = (((usqInt)desiredEdenBytes << 1) | 1);
			desiredEdenBytes = arg;

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
		break;
	case 47:
		break;
	case 48:
		if (arg >= 0) {
			oldPrimitiveDoMixedArithmetic = primitiveDoMixedArithmetic;
			resultSqInt = (((usqInt)(((usqInt)((getImageHeaderFlags()))) >> 2) << 1) | 1);

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			if ((((usqInt)arg)) > 0x1FF) {
				/* primitiveFailFor: */
				GIV(primFailCode) = PrimErrUnsupported;
				goto l5;
			}

			/* flagInterpretedMethods := flags anyMask: 2. specific to CoInterpreter */
			GIV(imageHeaderFlags) = (((arg & 1) != 0)
						? GIV(imageHeaderFlags) | 4
						: ((GIV(imageHeaderFlags) | 4) - 4));
			GIV(imageHeaderFlags) = (((arg & 2) != 0)
						? GIV(imageHeaderFlags) | 8
						: ((GIV(imageHeaderFlags) | 8) - 8));

			/* noThreadingOfGUIThread := flags anyMask: 8.. specific to CoInterpreterMT */
			GIV(preemptionYields) = (!(arg & 4));
			GIV(imageHeaderFlags) = (((arg & 8) != 0)
						? GIV(imageHeaderFlags) | 32
						: ((GIV(imageHeaderFlags) | 32) - 32));
			GIV(newFinalization) = ((arg & 16) != 0);
			sendWheelEvents = ((arg & 32) != 0);
			primitiveDoMixedArithmetic = (!(arg & 64));
			GIV(imageHeaderFlags) = (((arg & 128) != 0)
						? GIV(imageHeaderFlags) | 0x200
						: ((GIV(imageHeaderFlags) | 0x200) - 0x200));
			upscaleDisplayIfHighDPI = (!(arg & 0x100));
l5:	/* end setImageHeaderFlags: */;
			if ((GIV(primFailCode) == 0)
			 && (oldPrimitiveDoMixedArithmetic != primitiveDoMixedArithmetic)) {
				/* begin flushMethodCache */
				memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

				/* this for primitiveExternalMethod */
				GIV(lastMethodCacheProbeWrite) = 0;

				/* begin flushAtCache */
				memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
				goto l6;
			}
		}
		break;
	case 49:
		if (((arg >= 0) && (arg <= 0xFFFF))) {
			resultSqInt = (((usqInt)(ioGetMaxExtSemTableSize()) << 1) | 1);

			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
		break;
	case 50:
		break;
	case 55:
		break;
	case 67:
		break;
	case 68:
		resultSqInt = floatObjectOf(statAverageLivePagesWhenMapping());

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		if ((loadFloatOrIntFrom(argOop)) == 0.0) {
			GIV(statPageCountWhenMappingSum) = (GIV(statNumMaps) = 0);
		}
		else {
			/* primitiveFailFor: */
			GIV(primFailCode) = PrimErrBadArgument;
		}
		break;
	case 69:
		if (arg >= 0) {
			resultSqInt = (((usqInt)(GIV(statMaxPageCountWhenMapping)) << 1) | 1);

			/* begin statMaxPageCountWhenMapping: */
			GIV(statMaxPageCountWhenMapping) = arg;
			GIV(primFailCode) = 0;
		}
		break;
	case 74:
		break;
	case 75:
		resultSqInt = /* booleanObjectOf: */
				(primitiveDoMixedArithmetic
					? GIV(trueObj)
					: GIV(falseObj));

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		mustFlush = primitiveDoMixedArithmetic != arg;
		primitiveDoMixedArithmetic = arg;
		if (mustFlush) {
			/* begin flushMethodCache */
			memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

			/* this for primitiveExternalMethod */
			GIV(lastMethodCacheProbeWrite) = 0;

			/* begin flushAtCache */
			memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
			goto l6;
		}
		break;
	default:
;
	}
	if (GIV(primFailCode)) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrInappropriate;
	}
	else {
		/* begin methodReturnValue: */
		assert(!((failed())));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), resultSqInt);
		GIV(stackPointer) = sp;
	}
l6:	/* end primitiveSetVMParameter:arg: */;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

	/* StackInterpreterPrimitives>>#primitiveVoidReceiver */
EXPORT(void)
primitiveVoidReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtPointerput(GIV(framePointer) + FoxReceiver, 0);
}


/*	Void all internal VM state in the stack and machine code zones */

	/* StackInterpreterPrimitives>>#primitiveVoidVMState */
static void
primitiveVoidVMState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0);

	/* begin flushMethodCache */
	memset(GIV(methodCache), 0, MethodCacheSize * (sizeof(GIV(methodCache)[0])));

	/* this for primitiveExternalMethod */
	GIV(lastMethodCacheProbeWrite) = 0;

	/* begin flushAtCache */
	memset(GIV(atCache), 0, AtCacheTotalSize * (sizeof(GIV(atCache)[0])));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}


/*	Prune the stack to contain only the path, removing stacked indices
	and mapping frame pointers to contexts The issue here is that a
	GC can occur during ensureFrameIsMarried:SP:, but frame pointers
	are not valid objects. So first prune back to objects and framePointers
	as integers, and then replace frame pointers as integers by contexts. */

	/* StackInterpreterPrimitives>>#pruneStack:stackp: */
static NoDbgRegParms void
pruneStackstackp(sqInt stack, sqInt stackp)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt finger;
    char *fp;
    sqInt i;
    sqInt objOrFP;
    sqInt oop;
    char *theFP;
    char *theFPAbove;
    StackPage *thePage;
    char *theSP;
    sqInt theStack;
    sqInt toDoLimit;

	finger = 1;
	for (i = 2; i < stackp; i += 2) {
		objOrFP = longAt((stack + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))));
		if (/* couldBeFramePointer: */
			(((((usqInt)(((char *) objOrFP)))) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)(((char *) objOrFP)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) objOrFP)))) <= (((usqInt)GIV(pages))))))) {
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(objOrFP)) & (BytesPerWord - 1)) == 0);
			objOrFP = (oopForPointer(objOrFP)) + 1 /* smallIntegerTag */;
		}

		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((stack + BaseHeaderSize) + ((((usqInt)(finger) << (shiftForWord())))), objOrFP);
		finger += 1;
	}
	toDoLimit = (lengthOf(stack)) - 1;
	for (i = finger; i <= toDoLimit; i += 1) {
		/* storePointerUnchecked:ofObject:withValue: */
		longAtput((stack + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))), GIV(nilObj));
	}
	oop = (theStack = stack);

	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	for (i = 1; i < finger; i += 1) {
		objOrFP = longAt((theStack + BaseHeaderSize) + ((((usqInt)(i) << (shiftForWord())))));
		if ((objOrFP & 1)) {
			/* begin withoutSmallIntegerTags: */
			assert((objOrFP & 1));
			theFP = pointerForOop(objOrFP - 1 /* smallIntegerTag */);

			/* begin stackPageFor: */
			thePage = stackPageAtpages(pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage)), GIV(pages));
			callerFP = ((char *) 0);
			fp = (thePage->headFP);
			if (fp == theFP) {
				theFPAbove = 0;
				goto l1;
			}
			while (((callerFP = pointerForOop(longAt(fp + FoxSavedFP)))) != 0) {
				if (callerFP == theFP) {
					theFPAbove = fp;
					goto l1;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
l1:	/* end findFrameAbove:inPage: */;

			/* begin frameCallerSP: */
			assert(!(isBaseFrame(theFPAbove)));
			theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((((usqInt)((byteAt((theFPAbove + FoxFrameFlags) + 1))) << (shiftForWord())))))) + BytesPerWord;

			/* begin ensureFrameIsMarried:SP: */
			if (byteAt((theFP + FoxFrameFlags) + 2)) {
				assert(isContext(frameContext(theFP)));
				objOrFP = longAt(theFP + FoxThisContext);
				goto l2;
			}
			objOrFP = marryFrameSP(theFP, theSP);
l2:	/* end ensureFrameIsMarried:SP: */;
			theStack = GIV(remapBuffer)[GIV(remapBufferCount)];

			/* begin storePointer:ofObject:withValue: */
			if (oopisLessThan(theStack, GIV(youngStart))) {
				possibleRootStoreIntovalue(theStack, objOrFP);
			}
			longAtput((theStack + BaseHeaderSize) + ((((usqInt)(finger) << (shiftForWord())))), objOrFP);
		}
	}

	/* begin popRemappableOop */
	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
}

	/* StackInterpreterPrimitives>>#unmarkAfterPathTo */
static void
unmarkAfterPathTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hdr;
    sqInt header;
    sqInt oop;
    unsigned int sz;

	unmarkAllFrames();

	/* begin unmarkAllObjects */
	oop = (startOfMemory()) + (headerTypeBytes[(longAt(startOfMemory())) & TypeMask]);
	while ((((usqInt)oop)) < GIV(freeStart)) {
		if (!(((longAt(oop)) & TypeMask) == HeaderTypeFree)) {
			hdr = longAt(oop);
			if (hdr & MarkBit) {
				/* baseHeader:put: */
				longAtput(oop, hdr & AllButMarkBit);
			}
		}

		/* begin objectAfter: */
		if (!(asserta(oopisLessThan(oop, GIV(freeStart))))) {
			error("no objects after the end of memory");
		}
		if (((longAt(oop)) & TypeMask) == HeaderTypeFree) {
			sz = (longAt(oop)) & AllButTypeMask;
		}
		else {
			/* begin sizeBitsOf: */
			header = longAt(oop);
			sz = ((usqInt) ((header & TypeMask
		? header & SizeMask
		: (longAt(oop - (BytesPerWord * 2))) & LongSizeMask)));
		}
		oop = (oop + sz) + (headerTypeBytes[(longAt(oop + sz)) & TypeMask]);
	}
}

	/* StackInterpreterPrimitives>>#unmarkAllFrames */
static void
unmarkAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flags;
    sqInt i;
    char *theFP;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			theFP = (thePage->headFP);
			do {
				flags = longAt(theFP + FoxFrameFlags);
				if (flags & 2) {
					longAtput(theFP + FoxFrameFlags, flags - 2);
				}
			} while(((theFP = pointerForOop(longAt(theFP + FoxSavedFP)))) != 0);
		}
	}
}

/*** Exports ***/

static char _m[] = "";
void* vm_exports[][3] = {
	{(void*)_m, "moduleUnloaded", (void*)moduleUnloaded},
	{(void*)_m, "primitiveAddLargeIntegers", (void*)primitiveAddLargeIntegers},
	{(void*)_m, "primitiveAllInstances", (void*)primitiveAllInstances},
	{(void*)_m, "primitiveAllObjects", (void*)primitiveAllObjects},
	{(void*)_m, "primitiveBitAndLargeIntegers", (void*)primitiveBitAndLargeIntegers},
	{(void*)_m, "primitiveBitOrLargeIntegers", (void*)primitiveBitOrLargeIntegers},
	{(void*)_m, "primitiveBitShiftLargeIntegers", (void*)primitiveBitShiftLargeIntegers},
	{(void*)_m, "primitiveBitXorLargeIntegers", (void*)primitiveBitXorLargeIntegers},
	{(void*)_m, "primitiveBytecodeSetsAvailable", (void*)primitiveBytecodeSetsAvailable},
	{(void*)_m, "primitiveClockLogAddresses", (void*)primitiveClockLogAddresses},
	{(void*)_m, "primitiveCompareBytes", (void*)primitiveCompareBytes},
	{(void*)_m, "primitiveCompareWith", (void*)primitiveCompareWith},
	{(void*)_m, "primitiveCrashVM", (void*)primitiveCrashVM},
	{(void*)_m, "primitiveDisablePowerManager", (void*)primitiveDisablePowerManager},
	{(void*)_m, "primitiveDivideLargeIntegers", (void*)primitiveDivideLargeIntegers},
	{(void*)_m, "primitiveDivLargeIntegers", (void*)primitiveDivLargeIntegers},
	{(void*)_m, "primitiveEqualLargeIntegers", (void*)primitiveEqualLargeIntegers},
	{(void*)_m, "primitiveEventProcessingControl", (void*)primitiveEventProcessingControl},
	{(void*)_m, "primitiveForceTenure", (void*)primitiveForceTenure},
	{(void*)_m, "primitiveGetenv", (void*)primitiveGetenv},
	{(void*)_m, "primitiveGetLogDirectory", (void*)primitiveGetLogDirectory},
	{(void*)_m, "primitiveGetWindowLabel", (void*)primitiveGetWindowLabel},
	{(void*)_m, "primitiveGetWindowSize", (void*)primitiveGetWindowSize},
	{(void*)_m, "primitiveGreaterOrEqualLargeIntegers", (void*)primitiveGreaterOrEqualLargeIntegers},
	{(void*)_m, "primitiveGreaterThanLargeIntegers", (void*)primitiveGreaterThanLargeIntegers},
	{(void*)_m, "primitiveHeartbeatFrequency", (void*)primitiveHeartbeatFrequency},
	{(void*)_m, "primitiveHighResClock", (void*)primitiveHighResClock},
	{(void*)_m, "primitiveImageFormatVersion", (void*)primitiveImageFormatVersion},
	{(void*)_m, "primitiveInterruptChecksPerMSec", (void*)primitiveInterruptChecksPerMSec},
	{(void*)_m, "primitiveIsBigEnder", (void*)primitiveIsBigEnder},
	{(void*)_m, "primitiveIsRoot", (void*)primitiveIsRoot},
	{(void*)_m, "primitiveIsWindowObscured", (void*)primitiveIsWindowObscured},
	{(void*)_m, "primitiveIsYoung", (void*)primitiveIsYoung},
	{(void*)_m, "primitiveLessOrEqualLargeIntegers", (void*)primitiveLessOrEqualLargeIntegers},
	{(void*)_m, "primitiveLessThanLargeIntegers", (void*)primitiveLessThanLargeIntegers},
#if LRPCheck
	{(void*)_m, "primitiveLongRunningPrimitive", (void*)primitiveLongRunningPrimitive},
#endif /* LRPCheck */
#if LRPCheck
	{(void*)_m, "primitiveLongRunningPrimitiveSemaphore", (void*)primitiveLongRunningPrimitiveSemaphore},
#endif /* LRPCheck */
	{(void*)_m, "primitiveMillisecondClockMask", (void*)primitiveMillisecondClockMask},
	{(void*)_m, "primitiveModLargeIntegers", (void*)primitiveModLargeIntegers},
	{(void*)_m, "primitiveMultipleBytecodeSetsActive", (void*)primitiveMultipleBytecodeSetsActive},
	{(void*)_m, "primitiveMultiplyLargeIntegers", (void*)primitiveMultiplyLargeIntegers},
	{(void*)_m, "primitiveNotEqualLargeIntegers", (void*)primitiveNotEqualLargeIntegers},
	{(void*)_m, "primitivePathToUsing", (void*)primitivePathToUsing},
	{(void*)_m, "primitiveProfilePrimitive", (void*)primitiveProfilePrimitive},
	{(void*)_m, "primitiveProfileSample", (void*)primitiveProfileSample},
	{(void*)_m, "primitiveProfileSemaphore", (void*)primitiveProfileSemaphore},
	{(void*)_m, "primitiveProfileStart", (void*)primitiveProfileStart},
	{(void*)_m, "primitiveQuoLargeIntegers", (void*)primitiveQuoLargeIntegers},
	{(void*)_m, "primitiveRemLargeIntegers", (void*)primitiveRemLargeIntegers},
	{(void*)_m, "primitiveRootTableAt", (void*)primitiveRootTableAt},
	{(void*)_m, "primitiveScreenDepth", (void*)primitiveScreenDepth},
	{(void*)_m, "primitiveScreenScaleFactor", (void*)primitiveScreenScaleFactor},
	{(void*)_m, "primitiveSetGCBiasToGrow", (void*)primitiveSetGCBiasToGrow},
	{(void*)_m, "primitiveSetGCBiasToGrowGCLimit", (void*)primitiveSetGCBiasToGrowGCLimit},
	{(void*)_m, "primitiveSetGCSemaphore", (void*)primitiveSetGCSemaphore},
	{(void*)_m, "primitiveSetLogDirectory", (void*)primitiveSetLogDirectory},
	{(void*)_m, "primitiveSetWindowLabel", (void*)primitiveSetWindowLabel},
	{(void*)_m, "primitiveSetWindowSize", (void*)primitiveSetWindowSize},
	{(void*)_m, "primitiveSubtractLargeIntegers", (void*)primitiveSubtractLargeIntegers},
	{(void*)_m, "primitiveSuspendBackingUpV2", (void*)primitiveSuspendBackingUpV2},
#if TestingPrimitives
	{(void*)_m, "primitiveTestShortenIndexableSize", (void*)primitiveTestShortenIndexableSize},
#endif /* TestingPrimitives */
	{(void*)_m, "primitiveUtcWithOffset", (void*)primitiveUtcWithOffset},
	{(void*)_m, "primitiveVoidReceiver", (void*)primitiveVoidReceiver},
	{NULL, NULL, NULL}
};
