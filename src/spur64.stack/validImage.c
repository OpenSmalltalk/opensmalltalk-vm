/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
   from
	ImageLeakChecker VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3
 */
static char __buildInfo[] = "ImageLeakChecker VMMaker.oscog-eem.3456 uuid: e316760f-1758-4b6b-aa08-f84bc7c44ef3 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include "sq.h"
#define INCLUDE_SIF_CODE 1
#include <stdio.h> /* for printf */
#include <stdlib.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "sqImageFileAccess.h"
#include "sqSetjmpShim.h"
#include "dispdbg.h"


/* ImageLeakChecker class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline(off)
sqInt warnpid, erroronwarn;
EXPORT(void)
warning(const char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
EXPORT(void)
warningat(const char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set multiple breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
EXPORT(void)
warninginat(const char *s, const char *f, int l) { /* ditto with function name & line number. */
	/* use alloca to call warning so one does not have to remember to set multiple breakpoints... */
	char *sl = alloca(strlen(s) + strlen(f) + 17);
	sprintf(sl, "%s %s %d", s, f, l);
	warning(sl);
}
#pragma auto_inline(on)

#if !defined(PharoVM)
# define PharoVM 0
#endif


void error(const char *msg) {
  warning(msg);
  abort();
}


/* end ImageLeakChecker class>>preambleCCode */


/*** Constants ***/
#define AlternateHeaderHasPrimFlag 0x80000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 245
#define AtCacheTotalSize 64
#define BecameActiveClassFlag 8
#define BecameCompiledMethodFlag 2
#define BecamePointerObjectFlag 1
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassCharacter 19
#define ClassDoubleByteArray 31
#define ClassDoubleWordArray 33
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClassWordArray 32
#define CtxtTempFrameStart 6
#define ExtraRootsSize 64
#define FalseObject 1
#define GCCheckFreeSpace 32
#define GCModeFull 1
#define GCModeNewSpace 2
#define HeaderIndex 0
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x100000
#define LiteralStart 1
#define LongStoreBytecode 129
#define MarkStackRootIndex 0x1000
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntrySize 4
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 27
#define MethodHeaderTempCountShift 21
#define MethodIndex 3
#define MournQueueRootIndex 4098
#define MultipleBytecodeSetsBitmask 0x200
#define NilObject 0
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define PrimitiveErrorTableIndex 51
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetRootIndex 4099
#define ScavengeInProgress 1
#define SchedulerAssociation 3
#define SelectorDoesNotUnderstand 20
#define SelectorStart 2
#define StackPointerIndex 2
#define SuperclassIndex 0
#define TheDisplay 14
#define TrueObject 2
#define ValidatedClassDoubleByteArrayFlag 1
#define ValidatedClassDoubleWordArrayFlag 4
#define ValidatedClassWordArrayFlag 2
#define ValueIndex 1
#define WeaklingStackRootIndex 0x1001

typedef struct {
	usqInt	sEdenBytes;
	usqInt	sPastBytes;
	usqInt	sRememberedSetSize;
	usqInt	sRememberedSetRedZone;
	usqInt	sRememberedSetLimit;
	usqInt	sStatTenures;
	usqInt	tTenureCriterion;
	usqInt	tTenureThreshold;
	usqInt	tRefCountToShrinkRT;
	usqInt	eSurvivorBytes;
	usqInt	eRememberedSetSize;
	usqInt	eStatTenures;
 } SpurScavengeLogRecord;


typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
	usqInt	savedSegSize;
	usqInt	lastFreeObject;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	int	padToWord;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

static NoDbgRegParms sqInt growOldSpaceByAtLeast(sqInt minAmmount);
static NoDbgRegParms void initializeInterpreter(sqInt bytesToShift);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern int main(int argc, char *argv[]);
extern int plugInNotifyUser(char *msg);
extern void printHex(usqInt n);
static NoDbgRegParms void printNum(sqInt n);
extern void print(char *s);
static NoDbgRegParms sqInt runLeakCheckerForResult(sqInt gcModes);
static NoDbgRegParms char * whereIsMaybeStackThing(sqInt thing);
extern sqInt failed(void);
static NoDbgRegParms int isDirectAlien(sqInt oop);
static NoDbgRegParms int isIndirectAlien(sqInt oop);
static NoDbgRegParms int isPointerAlien(sqInt oop);
static NoDbgRegParms sqInt isPositiveMachineIntegerObject(sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
static NoDbgRegParms usqInt addressAfter(sqInt objOop);
static NoDbgRegParms sqInt allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
static NoDbgRegParms sqInt allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
extern sqInt byteSwapped(sqInt w);
static NoDbgRegParms usqInt bytesInBody(sqInt objOop);
static int defaultEdenBytes(void);
extern sqInt fetchClassTagOf(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
static NoDbgRegParms void hackSlimBridgeToat(sqInt objOop, sqInt startAddress);
extern int headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
static NoDbgRegParms sqInt initFreeChunkWithBytesat(usqLong numBytes, sqInt address);
static NoDbgRegParms void initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address);
static NoDbgRegParms sqInt integerObjectOf(sqInt value);
static NoDbgRegParms int isFloatInstance(sqInt oop);
static NoDbgRegParms int isImmediateFloat(sqInt oop);
static NoDbgRegParms int isIntegerObject(sqInt oop);
extern int isIntegerValue(sqInt intValue);
static NoDbgRegParms int isLilliputianSize(sqInt chunkBytes);
extern int isMarked(sqInt objOop);
static NoDbgRegParms int isSmallFloatValueBits(usqLong rawFloatBits);
static NoDbgRegParms int isSmallFloatValue(double aFloat);
static NoDbgRegParms int isWordsNonImm(sqInt objOop);
static NoDbgRegParms usqInt largeObjectBytesForSlots(sqInt numSlots);
static sqInt logBytesPerOop(void);
static sqInt maxSlotsForAlloc(void);
extern double noFailFloatValueOf(sqInt aFloatOop);
static NoDbgRegParms sqInt normalisedFormatForindexableSize(sqInt objOop, sqInt indexableSize);
static sqInt numFreeLists(void);
static NoDbgRegParms sqInt objectAfterMaybeSlimBridgelimit(sqInt objOop, sqInt limit);
static NoDbgRegParms usqInt objectBytesForSlots(sqInt numSlots);
static NoDbgRegParms usqInt rotateLeft(sqInt anInteger);
static NoDbgRegParms usqInt rotateRight(sqInt anInteger);
static NoDbgRegParms void setClassIndexOfto(sqInt objOop, sqInt classIndex);
static NoDbgRegParms void setFormatOfto(sqInt objOop, sqInt format);
static NoDbgRegParms void setIsImmutableOfto(sqInt objOop, sqInt aBoolean);
static NoDbgRegParms void setIsMarkedOfto(sqInt objOop, sqInt aBoolean);
static NoDbgRegParms void setIsPinnedOfto(sqInt objOop, sqInt aBoolean);
static NoDbgRegParms void setIsRememberedOfto(sqInt objOop, sqInt aBoolean);
static NoDbgRegParms usqLong smallFloatBitsOf(sqInt oop);
static NoDbgRegParms double smallFloatValueOf(sqInt oop);
extern usqInt smallObjectBytesForSlots(sqInt numSlots);
static NoDbgRegParms void updateFormatOfShortenedObjectto(sqInt objOop, sqInt indexableSize);
static sqInt wordIndexableFormat(void);
static sqInt wordSizeClassIndexPun(void);
static NoDbgRegParms void forgetObject(sqInt objOop);
static void growRememberedSet(void);
static sqInt initFutureSpaceStart(void);
static void initializeRememberedSet(void);
static NoDbgRegParms sqInt isInRememberedSet(sqInt objOop);
static NoDbgRegParms void newSpaceStartnewSpaceBytessurvivorBytes(sqInt startAddress, sqInt totalBytes, sqInt requestedSurvivorBytes);
extern void openScavengeLog(void);
extern void printRememberedSet(void);
extern sqInt remember(sqInt objOop);
static NoDbgRegParms void noteValidHeapExtent(sqInt bytesToShift);
static NoDbgRegParms sqInt swizzleObjin(sqInt objOop, sqInt containerOopOrNil);
static NoDbgRegParms NeverInline sqInt activeAndDeferredScan(sqInt anEphemeron);
static NoDbgRegParms void addFreeSubTree(sqInt freeTree);
extern sqInt addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeObj(sqInt address);
static NoDbgRegParms sqInt addressCouldBeOldObj(sqInt address);
extern sqInt addressCouldBeOop(sqInt address);
static NoDbgRegParms sqInt addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes);
static NoDbgRegParms sqInt addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes);
static NoDbgRegParms void adjustAllOopsBy(sqInt bytesToShift);
static NoDbgRegParms sqInt allocateOldSpaceChunkOfBytes(usqInt chunkBytes);
extern sqInt allocatePinnedSlots(sqInt nSlots);
static sqInt allocationUnit(void);
static NoDbgRegParms NeverInline sqInt assertInnerValidFreeObject(sqInt objOop);
static NoDbgRegParms sqInt becomeEffectFlagsFor(sqInt objOop);
extern void beRootIfOld(sqInt oop);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(void);
static sqInt bridgeSize(void);
static NoDbgRegParms sqInt byteFormatForNumBytes(sqInt numBytes);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern unsigned char bytesPerElement(sqInt oop);
extern sqInt characterObjectOf(sqInt characterCode);
extern usqInt characterValueOf(sqInt oop);
extern sqInt checkedLongAt(sqInt byteAddress);
static NoDbgRegParms void checkFreeSpace(sqInt gcModes);
static NoDbgRegParms void checkFreeSpaceignoring(sqInt gcModes, sqInt anOopToIgnore);
static NoDbgRegParms sqInt checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid);
extern sqInt checkOkayOop(usqInt oop);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classAtIndex(sqInt classIndex);
static sqInt classBitmap(void);
static sqInt classByteArray(void);
static sqInt classCharacter(void);
static sqInt classDoubleByteArray(void);
static sqInt classDoubleWordArray(void);
static sqInt classExternalAddress(void);
static sqInt classExternalData(void);
static sqInt classExternalFunction(void);
static sqInt classExternalLibrary(void);
static sqInt classExternalStructure(void);
static sqInt classFloat(void);
static sqInt classFloat32Array(void);
static sqInt classFloat64Array(void);
static NoDbgRegParms sqInt classForClassTag(sqInt classIndex);
static sqInt classIndexFieldWidth(void);
extern sqInt classIndexOf(sqInt objOop);
static sqInt classLargeNegativeInteger(void);
static sqInt classLargePositiveInteger(void);
extern sqInt classOrNilAtIndex(sqInt classIndex);
static sqInt classPoint(void);
static sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
static sqInt classString(void);
extern sqInt classTableMinorIndexMask(void);
extern sqInt classTablePageSize(void);
extern sqInt classTableRootObj(void);
static sqInt classTableRootSlots(void);
extern sqInt classTagForClass(sqInt classObj);
static sqInt classUnsafeAlien(void);
static sqInt classWordArray(void);
static void clearLeakMapAndMapAccessibleObjects(void);
static NoDbgRegParms sqInt cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning);
static NoDbgRegParms sqInt cloneObject(sqInt objOop);
static NoDbgRegParms sqInt compactIndexOfClass(sqInt objOop);
static void computeFreeSpacePostSwizzle(void);
extern void countMarkedAndUnmarkdObjects(sqInt printFlags);
static NoDbgRegParms void countNumClassPagesPreSwizzle(sqInt bytesToShift);
static sqInt displayObject(void);
static NoDbgRegParms sqInt doShortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern usqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots);
static NoDbgRegParms void enableObjectEnumerationFrom(sqInt initialObject);
static NoDbgRegParms sqInt ensureRoomOnObjStackAt(sqInt objStackRootIndex);
static NoDbgRegParms sqInt enterIntoClassTable(sqInt aBehavior);
static sqInt ephemeronFormat(void);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop);
static NoDbgRegParms NeverInline sqInt fetchClassOfNonImm(sqInt objOop);
static NoDbgRegParms sqInt fetchClassOf(sqInt oop);
static NoDbgRegParms sqInt fetchClassTagOfNonImm(sqInt obj);
extern int fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static NoDbgRegParms sqLong fetchLong64ofObject(sqInt longIndex, sqInt objOop);
static NoDbgRegParms sqInt fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop);
static NoDbgRegParms sqInt fetchPointerofMaybeForwardedObject(sqInt fieldIndex, sqInt objOop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop);
static NoDbgRegParms sqInt fetchShort16ofObject(sqInt shortIndex, sqInt objOop);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
static NoDbgRegParms void * firstFixedField(sqInt objOop);
static NoDbgRegParms void * firstIndexableField(sqInt objOop);
extern sqInt fixedFieldsOfClassFormatMask(void);
extern sqInt fixedFieldsOfClassFormat(sqInt classFormat);
static NoDbgRegParms sqInt fixedFieldsOfClass(sqInt objOop);
static NoDbgRegParms sqInt fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength);
static NoDbgRegParms NeverInline sqInt fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue);
static NoDbgRegParms sqInt followFieldofObject(sqInt fieldIndex, sqInt anObject);
static NoDbgRegParms sqInt followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth);
extern sqInt followForwarded(sqInt objOop);
static NoDbgRegParms sqInt followMaybeForwarded(sqInt objOop);
static NoDbgRegParms sqInt followObjFieldofObject(sqInt fieldIndex, sqInt anObject);
static void followSpecialObjectsOop(void);
extern sqInt formatOfClass(sqInt classPointer);
static NoDbgRegParms sqInt formatOf(sqInt objOop);
static sqInt forwardedFormat(void);
static NoDbgRegParms void forwardto(sqInt obj1, sqInt obj2);
static sqInt freeChunkLargerIndex(void);
static sqInt freeChunkNextIndex(void);
static sqInt freeChunkParentIndex(void);
static sqInt freeChunkPrevIndex(void);
static sqInt freeChunkSmallerIndex(void);
static NoDbgRegParms sqInt freeChunkWithBytesat(sqInt bytes, sqInt address);
extern sqInt freeObject(sqInt objOop);
static NoDbgRegParms int hasOverflowHeader(sqInt objOop);
static NoDbgRegParms sqInt hasPointerFieldsNonImm(sqInt oop);
extern usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static sqInt hiddenRootSlots(void);
static sqInt identityHashFieldWidth(void);
#if IMMUTABILITY
extern sqInt immutableBitMask(void);
#endif /* IMMUTABILITY */
static NoDbgRegParms void inFreeTreeReplacewith(sqInt treeNode, sqInt newNode);
static NoDbgRegParms void initFreeTreeChunkbytes(sqInt freeChunk, sqInt chunkBytes);
static NoDbgRegParms void initializeFreeSpacePostLoad(sqInt freeListObj);
static NeverInline void initializeNewSpaceVariables(void);
static NoDbgRegParms void initializeObjectMemory(sqInt bytesToShift);
static NoDbgRegParms void initializeOldSpaceFirstFree(usqInt startOfFreeOldSpace);
extern void inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList);
extern sqInt instanceSizeOf(sqInt classObj);
extern sqInt instSpecOfClassFormat(sqInt classFormat);
static NoDbgRegParms sqInt instSpecOfClass(sqInt classPointer);
static NoDbgRegParms void invalidCompactClassError(const char *className);
static NoDbgRegParms int isArrayNonImm(sqInt oop);
static NoDbgRegParms sqInt isArray(sqInt oop);
static NoDbgRegParms int isBytesNonImm(sqInt objOop);
static NoDbgRegParms sqInt isBytes(sqInt oop);
extern int isCharacterObject(sqInt oop);
extern int isCharacterValue(sqInt anInteger);
extern int isCompiledMethod(sqInt objOop);
static NoDbgRegParms sqInt isEmptyObjStack(sqInt objStack);
static NoDbgRegParms int isEphemeron(sqInt objOop);
extern sqInt isFixedSizePointerFormat(sqInt format);
extern int isForwarded(sqInt objOop);
static NoDbgRegParms int isFreeObject(sqInt objOop);
static NoDbgRegParms sqInt isFreeOop(sqInt oop);
static NoDbgRegParms int isGrey(sqInt objOop);
static NoDbgRegParms int isHiddenObj(sqInt objOop);
extern int isImmediate(sqInt oop);
static NoDbgRegParms int isImmutable(sqInt objOop);
static NoDbgRegParms sqInt isIndexableFormat(sqInt format);
static NoDbgRegParms sqInt isIndexable(sqInt objOop);
static NoDbgRegParms sqInt isInEden(sqInt objOop);
static NoDbgRegParms sqInt isInFutureSpace(sqInt address);
static NoDbgRegParms sqInt isInHeapBounds(sqInt address);
static NoDbgRegParms sqInt isInMemory(sqInt address);
static NoDbgRegParms sqInt isInNewSpace(sqInt objOop);
extern sqInt isInOldSpace(sqInt address);
static NoDbgRegParms sqInt isInPastSpace(sqInt address);
static NoDbgRegParms int isInRangeCharacterCode(sqInt characterCode);
static NoDbgRegParms sqInt isInstanceOfClassLargeNegativeInteger(sqInt oop);
static NoDbgRegParms sqInt isInstanceOfClassLargePositiveInteger(sqInt oop);
static NoDbgRegParms int isLargeFreeObject(sqInt objOop);
static NoDbgRegParms sqInt isLargeIntegerInstance(sqInt oop);
static NoDbgRegParms int isLong64sNonImm(sqInt objOop);
extern sqInt isLong64s(sqInt oop);
extern int isNonImmediate(sqInt oop);
static NoDbgRegParms int isObjEphemeron(sqInt objOop);
static NoDbgRegParms int isOldObject(sqInt objOop);
extern sqInt isOopCompiledMethod(sqInt oop);
extern sqInt isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt oop);
extern sqInt isOopMutable(sqInt oop);
extern int isPinned(sqInt objOop);
static NoDbgRegParms int isPointersFormat(sqInt format);
static NoDbgRegParms int isPointersNonImm(sqInt objOop);
static NoDbgRegParms sqInt isPointers(sqInt oop);
static NoDbgRegParms sqInt isPureBitsFormat(sqInt format);
extern int isReallyYoungObject(sqInt obj);
static NoDbgRegParms sqInt isReallyYoung(sqInt oop);
static NoDbgRegParms int isRemembered(sqInt objOop);
static NoDbgRegParms int isSegmentBridge(sqInt objOop);
static NoDbgRegParms int isShortsNonImm(sqInt objOop);
extern sqInt isShorts(sqInt oop);
static NoDbgRegParms int isUnambiguouslyForwarder(sqInt objOop);
extern int isUnmarked(sqInt objOop);
extern sqInt isValidClassTag(sqInt classIndex);
static NoDbgRegParms sqInt isValidObjStackAt(sqInt objStackRootIndex);
static NoDbgRegParms sqInt isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx);
static NoDbgRegParms sqInt isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage);
static NoDbgRegParms sqInt isValidObjStack(sqInt objStack);
static NoDbgRegParms int isWeakNonImm(sqInt objOop);
static NoDbgRegParms sqInt isWeak(sqInt oop);
static NoDbgRegParms sqInt isWordsOrBytesNonImm(sqInt objOop);
static NoDbgRegParms sqInt isWordsOrBytes(sqInt oop);
static NoDbgRegParms int isWordsOrShortsNonImm(sqInt objOop);
extern sqInt isWordsOrShorts(sqInt oop);
static NoDbgRegParms sqInt isWords(sqInt oop);
extern int isYoungObject(sqInt objOop);
extern sqInt isYoung(sqInt oop);
static NoDbgRegParms sqInt isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static NoDbgRegParms sqInt keyOfEphemeron(sqInt objOop);
static NoDbgRegParms sqInt knownClassAtIndex(sqInt classIndex);
static sqInt lastPointerFormat(void);
static NoDbgRegParms sqInt lastPointerOfWhileSwizzling(sqInt objOop);
extern int leakCheckFullGC(void);
extern int leakCheckNewSpaceGC(void);
static NoDbgRegParms sqInt lengthOf(sqInt objOop);
extern usqInt literalCountOfMethodHeader(sqInt header);
extern usqInt literalCountOf(sqInt methodPointer);
extern void longPrintInstancesOf(sqInt aClassOop);
extern void longPrintInstancesWithClassIndex(sqInt classIndex);
extern void longPrintReferencesTo(sqInt anOop);
static NoDbgRegParms void markAndTraceClassOf(sqInt objOop);
extern NeverInline void markAndTrace(sqInt objOop);
extern sqInt maxSlotsForNewSpaceAlloc(void);
static NoDbgRegParms sqInt methodHeaderOf(sqInt methodObj);
extern sqInt minSlotsForShortening(void);
static sqInt newSpaceIsEmpty(void);
static sqInt newSpaceRefCountMask(void);
extern sqInt nilObject(void);
static NoDbgRegParms sqInt noCheckClassAtIndex(sqInt classIndex);
static NoDbgRegParms sqInt noCheckPushonObjStack(sqInt objOop, sqInt objStack);
extern sqInt nonIndexablePointerFormat(void);
static NoDbgRegParms sqInt numBytesOfBitsformat(sqInt objOop, sqInt format);
static NoDbgRegParms sqInt numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
static NoDbgRegParms usqInt numPointerSlotsOf(sqInt objOop);
static NoDbgRegParms sqInt numSlotsForBytes(sqInt numBytes);
static NoDbgRegParms usqInt numSlotsOfAny(sqInt objOop);
extern usqInt numSlotsOf(sqInt objOop);
static NoDbgRegParms sqInt numStrongSlotsOfInephemeral(sqInt objOop);
extern sqInt objectAfter(sqInt objOop);
extern sqInt objectBefore(sqInt objOop);
static NoDbgRegParms sqInt objectInPastSpaceBefore(sqInt objOop);
static NoDbgRegParms sqInt objectStartingAt(sqInt address);
static NoDbgRegParms sqInt okayOop(sqInt signedOop);
extern sqInt oldSpaceObjectAfter(sqInt objOop);
extern sqInt pinObject(sqInt objOop);
static NoDbgRegParms sqInt popObjStack(sqInt objStack);
extern sqInt popRemappableOop(void);
static NoDbgRegParms void postBecomeScanClassTable(sqInt effectsFlags);
extern sqInt primitiveErrorTable(void);
extern void printActivationsOf(sqInt aMethodObj);
extern void printBogons(void);
static NoDbgRegParms void printBridgeon(sqInt oop, FILE *aStream);
static NoDbgRegParms void printCantBeObjecton(sqInt oop, FILE *aStream);
extern void printContextReferencesTo(sqInt anOop);
extern void printEntity(sqInt oop);
extern void printForwarders(void);
static NoDbgRegParms void printForwarderon(sqInt oop, FILE *aStream);
extern void printFreeChunks(void);
extern void printFreeChunk(sqInt freeChunk);
static NoDbgRegParms void printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode);
extern void printFreeListHeads(void);
extern sqInt printFreeList(sqInt chunkOrIndex);
static NoDbgRegParms void printFreeObjecton(sqInt oop, FILE *aStream);
extern void printFreeTree(void);
static NoDbgRegParms void printFreeTreeChunk(sqInt chunkOrZero);
extern void printHeaderOf(sqInt objOop);
static NoDbgRegParms void printImmediateObjecton(sqInt oop, FILE *aStream);
extern void printInstancesOf(sqInt aClassOop);
extern void printInstancesWithClassIndex(sqInt classIndex);
extern void printInvalidClassTableEntries(void);
#if LLDB
extern void printMarkedOops(void);
#endif /* LLDB */
extern void printMethodImplementorsOf(sqInt anOop);
extern void printMethodReferencesTo(sqInt anOop);
static NoDbgRegParms void printNonPointerDataOfon(sqInt oop, FILE *aStream);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printObjectsWithHash(sqInt hash);
extern void printObjStackAndContents(sqInt objStack);
static NoDbgRegParms void printObjStackPagemyIndexpageTypeprintContents(sqInt objStackPage, sqInt myx, sqInt pageType, sqInt printContents);
static NoDbgRegParms void printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType);
extern void printObjStack(sqInt objStack);
extern NeverInline void printOopsExcept(sqInt (*function)(sqInt));
extern void printOopsFromto(sqInt startAddress, sqInt endAddress);
extern NeverInline void printOopsSuchThat(sqInt (*function)(sqInt));
extern void printReferencesTo(sqInt anOop);
static NoDbgRegParms void printStringDataOfon(sqInt oop, FILE *aStream);
#if LLDB
extern void printUnmarkedOops(void);
#endif /* LLDB */
static NoDbgRegParms sqInt pushOnUnscannedEphemeronsStack(sqInt anEphemeron);
extern void pushRemappableOop(sqInt oop);
extern sqInt rawHashBitsOf(sqInt objOop);
static NoDbgRegParms void rememberedSetObj(sqInt anObj);
extern sqInt removeGCRoot(sqInt *varLoc);
static NoDbgRegParms void reverseBytesFromto(sqInt startAddr, sqInt stopAddr);
static void reverseBytesInMemory(void);
static NoDbgRegParms usqInt roundUpHeapSize(usqInt heapSize);
static int scavengeInProgress(void);
static sqInt scavengerDenominator(void);
static NoDbgRegParms void setHashBitsOfto(sqInt objOop, sqInt hash);
static NoDbgRegParms NeverInline sqInt setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd);
static NoDbgRegParms void setHiddenRootsObj(sqInt anOop);
static NoDbgRegParms void setNextFreeChunkOfwithValuechunkBytes(sqInt freeChunk, sqInt nextFreeChunk, sqInt chunkBytes);
extern sqInt shortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress);
extern sqInt shouldRemapOop(sqInt oop);
static NoDbgRegParms usqInt sizeBitsOf(sqInt objOop);
static NoDbgRegParms sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
static NoDbgRegParms usqInt startOfObject(sqInt objOop);
extern sqInt statNumGCs(void);
extern usqInt storeCheckBoundary(void);
extern int storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt obj, sqInt valueWord);
static NoDbgRegParms sqInt storePointerNoAssertofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
static NoDbgRegParms sqInt storePointerofForwarderwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
static NoDbgRegParms sqInt storePointerofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
static NoDbgRegParms sqInt swizzleObjStackAt(sqInt objStackRootIndex);
static NoDbgRegParms sqInt topOfObjStack(sqInt objStack);
extern sqInt topRemappableOop(void);
static sqInt totalFreeListBytes(void);
static sqInt traceImmediatelySlotLimit(void);
extern sqInt trueObject(void);
static NoDbgRegParms sqInt unlinkFreeChunkatIndexchunkBytes(sqInt chunk, sqInt index, sqInt chunkBytes);
static NoDbgRegParms sqInt unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes);
static NoDbgRegParms NeverInline sqInt unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index);
static NoDbgRegParms void unlinkSolitaryFreeTreeNode(sqInt freeTreeNode);
extern sqInt unpinObject(sqInt objOop);
static void updateFreeLists(void);
static NoDbgRegParms void updateListStartingAt(sqInt freeNode);
static NoDbgRegParms sqInt updateRootOfObjStackAtwith(sqInt objStackRootIndex, sqInt newRootPage);
static sqInt validClassTableRootPages(void);
extern int validFreeTree(void);
static NoDbgRegParms const char * validFreeTreeChunkparent(sqInt chunk, sqInt parent);
static sqInt validObjStacks(void);
extern sqInt vmEndianness(void);
static NoDbgRegParms char * whereIsMaybeHeapThing(sqInt anOop);
extern sqInt shouldRemapObj(sqInt objOop);
static NoDbgRegParms usqInt segLimit(SpurSegmentInfo *self_in_SpurSegmentInfo);
static NoDbgRegParms void adjustSegmentSwizzlesBy(sqInt firstSegmentShift);
static void allocateOrExtendSegmentInfos(void);
static NoDbgRegParms sqInt bridgeAt(sqInt segIndex);
static NoDbgRegParms sqInt bridgeFor(SpurSegmentInfo *aSegment);
static void checkSegments(void);
static void collapseSegmentsPostSwizzle(void);
static void computeTotalHeapSizeIncludingBridges(void);
static NoDbgRegParms sqInt isInSegments(usqInt address);
static NoDbgRegParms sqInt isValidSegmentBridge(sqInt objOop);
static SpurSegmentInfo lastSegment(void);
static NoDbgRegParms sqInt readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes);
extern SpurSegmentInfo * segmentContainingObj(sqInt objOop);
static sqInt someSegmentContainsPinned(void);
static NoDbgRegParms sqInt swizzleObj(sqInt objOop);
static usqInt totalBytesInSegments(void);
static sqInt totalOldSpaceCapacity(void);
static NoDbgRegParms sqInt addressCouldBeClassObj(sqInt maybeClassObj);
extern usqInt argumentCountOfMethodHeader(sqInt header);
extern usqInt argumentCountOf(sqInt methodPointer);
static NoDbgRegParms sqInt bailOutOfImageLoad(sqInt rawVersion);
static void checkAssumedCompactClasses(void);
extern sqInt checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize);
static NoDbgRegParms sqInt checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr);
static sqInt convertFloatsToPlatformOrder(void);
extern NeverInline void eekcr(void);
static sqInt elementsPerPrintOopLine(void);
static NoDbgRegParms void ensureImageFormatIsUpToDate(sqInt swapBytes);
static NoDbgRegParms sqInt fetchStackPointerOf(sqInt aContext);
static NoDbgRegParms usqInt firstBytecodeOfAlternateHeadermethod(sqInt methodHeader, sqInt theMethod);
extern void flush(void);
static NoDbgRegParms sqInt followLiteralofMethod(sqInt offset, sqInt methodPointer);
static NoDbgRegParms sqInt getLongFromFileswap(sqImageFile aFile, sqInt swapFlag);
static NoDbgRegParms usqInt getShortFromFileswap(sqImageFile aFile, sqInt swapFlag);
static NoDbgRegParms sqInt getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
extern sqInt highBit(usqInt anUnsignedValue);
extern sqInt homeMethodOf(sqInt aMethodOop);
static NoDbgRegParms sqInt imageFormatVersionFromSnapshot(sqInt imageVersion);
static NoDbgRegParms sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static void initializeExtraClassInstVarIndices(void);
static NoDbgRegParms sqInt isBooleanObject(sqInt oop);
extern int isFloatObject(sqInt oop);
extern sqInt isKindOfInteger(sqInt oop);
extern sqInt isLargeIntegerObject(sqInt oop);
extern sqInt isLargeNegativeIntegerObject(sqInt oop);
extern sqInt isLargePositiveIntegerObject(sqInt oop);
extern int isQuickPrimitiveIndex(sqInt anInteger);
extern int isReadMediatedContextInstVarIndex(sqInt index);
extern int isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
static NoDbgRegParms sqInt lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
extern sqInt maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
static NoDbgRegParms int methodHeaderHasPrimitive(sqInt methodHeader);
static NoDbgRegParms char * nameOfClass(sqInt classOop);
static NoDbgRegParms char * nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr);
extern sqInt objCouldBeClassObj(sqInt objOop);
static NoDbgRegParms sqInt objectbeginsWithStringofSize(sqInt anOop, char *aCString, sqInt aCStringStrlen);
static NoDbgRegParms sqInt objectequalsString(sqInt anOop, char *aCString);
static NoDbgRegParms sqInt objectequalsStringofSize(sqInt anOop, char *aCString, sqInt aCStringStrlen);
static NoDbgRegParms sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static NoDbgRegParms void printDecodeMethodHeaderOop(sqInt methodHeaderOop);
static NoDbgRegParms sqInt printHexnpnp(usqInt n);
static NoDbgRegParms sqInt printHexnp(usqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static NoDbgRegParms void printNameOfClasscount(sqInt classOop, sqInt cnt);
static NoDbgRegParms void printOopShortInner(sqInt oop);
extern void printOop(sqInt oop);
static NoDbgRegParms void printStringOf(sqInt oop);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
static void reverseBytesInImage(void);
static NoDbgRegParms void setImageHeaderFlagsFrom(sqInt headerFlags);
static NoDbgRegParms void shortPrintOop(sqInt oop);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern usqInt startPCOfMethod(sqInt aCompiledMethod);
static NoDbgRegParms sqInt superclassOf(sqInt classPointer);
extern usqInt tempCountOf(sqInt methodPointer);
extern usqInt temporaryCountOfMethodHeader(sqInt header);
extern sqInt ultimateLiteralOf(sqInt aMethodOop);
static void updateObjectsPostByteSwap(void);
extern char * whereIs(sqInt anOop);
static NoDbgRegParms char * stretchcat(char *s1, char *s2);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss usqInt freeStart;
_iss usqInt pastSpaceStart;
_iss usqInt endOfMemory;
_iss sqInt nilObj;
_iss usqInt oldSpaceStart;
_iss FILE * transcript;
_iss sqInt specialObjectsOop;
_iss sqInt * freeLists;
_iss usqInt freeListsMask;
_iss sqInt markStack;
_iss sqInt numClassTablePages;
_iss sqInt hiddenRootsObj;
_iss sqInt numSegments;
_iss SpurSegmentInfo * segments;
_iss usqInt totalFreeOldSpace;
_iss sqInt rememberedSetSize;
_iss sqInt classTableIndex;
_iss sqInt weaklingStack;
_iss char * objStackInvalidBecause;
_iss sqInt invalidObjStackPage;
_iss sqInt classNameIndex;
_iss sqInt * rememberedSet;
_iss sqInt primFailCode;
_iss sqInt validatedIntegerClassFlags;
_iss sqInt extraRootCount;
_iss sqInt remapBufferCount;
_iss sqInt thisClassIndex;
_iss sqInt metaclassNumSlots;
_iss usqInt newSpaceStart;
_iss sqInt numSegInfos;
_iss sqInt mournQueue;
_iss sqInt verbose;
_iss sqInt classTableFirstPage;
_iss sqInt falseObj;
_iss sqInt rememberedSetLimit;
_iss usqInt scavengeThreshold;
_iss sqInt trueObj;
_iss usqInt freeOldSpaceStart;
_iss sqInt futureSurvivorStart;
_iss sqInt needGCFlag;
_iss sqInt edenBytes;
_iss sqInt firstSegmentSize;
_iss usqInt totalHeapSizeIncludingBridges;
_iss sqInt becomeEffectsFlags;
_iss sqInt canSwizzle;
_iss sqInt imageFloatsBigEndian;
_iss sqInt marking;
_iss sqInt rememberedSetRedZone;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt detectedInvalidOop;
_iss sqInt gcPhaseInProgress;
_iss sqInt globalSessionID;
_iss sqInt growHeadroom;
_iss char * imageFilename;
_iss sqInt oldHeapBase;
_iss sqInt oldHeapLimit;
_iss char * stackLimit;
_iss sqInt subsequentReport;
_iss sqInt biasForGC;
_iss sqInt fullScreenFlag;
_iss sqInt newFinalization;
_iss sqInt statFullGCs;
_iss sqInt statIncrGCs;
_iss sqInt statScavenges;
_iss sqInt theUnknownShort;
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt argumentCount;
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss usqLong byteCount;
_iss sqInt bytecodeSetSelector;
_iss sqInt classLinkedListClassTag;
_iss usqLong compactionStartUsecs;
_iss sqInt currentBytecode;
_iss sqInt ephemeronList;
_iss usqInt exceptionPC;
_iss sqInt extA;
_iss sqInt extB;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt extraFramesToMoveOnOverflow;
_iss void * ffiCalloutVMHandle;
_iss sqInt firstFieldOfRememberedSet;
_iss usqInt firstFreeObject;
_iss usqInt firstMobileObject;
_iss char * framePointer;
_iss sqInt freeSpaceCheckOopToIgnore;
_iss usqLong gcMarkEndUsecs;
_iss sqInt gcSemaphoreIndex;
_iss usqLong gcStartUsecs;
_iss usqLong gcSweepEndUsecs;
_iss usqInt heapSizeAtPreviousGC;
_iss sqInt highestRunnableProcessPriority;
_iss sqInt imageHeaderFlags;
_iss usqInt instructionPointer;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqInt lastHash;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt lkupClass;
_iss sqInt lkupClassTag;
_iss char * localFP;
_iss char * localIP;
_iss sqInt localReturnValue;
_iss char * localSP;
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckMethod;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSemaphore;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
#endif
#if LRPCheck
_iss usqLong longRunningPrimitiveGCUsecs;
#endif
#if LRPCheck
_iss sqInt longRunningPrimitiveSignalUndelivered;
#endif
#if LRPCheck
_iss usqLong longRunningPrimitiveStartUsecs;
#endif
#if LRPCheck
_iss usqLong longRunningPrimitiveStopUsecs;
#endif
_iss usqInt lowSpaceThreshold;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt messageSelector;
_iss sqInt metaAccessorDepth;
_iss usqInt method;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt multipleBytecodeSetsActive;
_iss usqInt newMethod;
_iss usqLong nextPollUsecs;
_iss sqLong nextProfileTick;
_iss usqLong nextWakeupUsecs;
_iss sqInt numExtB;
_iss sqInt numRememberedEphemerons;
_iss sqInt numStackPages;
_iss usqInt objectAfterLastMobileObject;
_iss sqLong oldSpaceUsePriorToScavenge;
_iss StackPage * overflowedPage;
_iss sqInt pendingFinalizationSignals;
_iss sqInt performWithArgumentsRecursionGuard;
_iss sqInt preemptionYields;
_iss sqInt previousRememberedSetSize;
_iss sqInt primTraceLog[256];
_iss sqInt printSends;
_iss sqInt profileMethod;
_iss sqInt profileProcess;
_iss sqInt profileSemaphore;
_iss sqInt refCountToShrinkRT;
_iss sqInt savedFirstFieldsSpaceNotInOldSpace;
_iss sqInt savedWindowSize;
_iss FILE * scavengeLog;
_iss sqLong secondaryErrorCode;
_iss sqInt shrinkThreshold;
_iss sqInt signalLowSpace;
_iss StackPage * stackPage;
_iss char * stackPointer;
_iss usqLong statAllocatedBytes;
_iss usqLong statCheckForEvents;
_iss sqInt statCompactPassCount;
_iss usqLong statCompactionUsecs;
_iss usqLong statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss usqLong statGCEndUsecs;
_iss sqInt statGrowMemory;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIOProcessEvents;
_iss usqLong statIdleUsecs;
_iss sqInt statMarkCount;
_iss usqLong statMarkUsecs;
_iss sqInt statMaxAllocSegmentTime;
_iss sqInt statPendingFinalizationSignals;
_iss usqLong statProcessSwitch;
_iss sqInt statRootTableCount;
_iss sqInt statRootTableOverflows;
_iss usqLong statSGCDeltaUsecs;
_iss usqLong statScavengeGCUsecs;
_iss sqInt statShrinkMemory;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt statSurvivorCount;
_iss usqLong statSweepUsecs;
_iss sqInt statTenures;
_iss sqInt tempOop;
_iss sqInt tempOop2;
_iss sqInt tenureCriterion;
_iss sqInt tenureThreshold;
_iss sqInt tenuringClassIndex;
_iss sqInt the2ndUnknownShort;
_iss sqInt weakList;
_iss unsigned char primTraceLogIndex;
_iss SpurNewSpaceSpace eden;
_iss SpurNewSpaceSpace futureSpace;
_iss SpurNewSpaceSpace pastSpace;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss float heapGrowthToSizeGCRatio;
_iss jmp_buf reenterInterpreter;
_iss SpurContiguousObjStack savedFirstFieldsSpace;
_iss SpurScavengeLogRecord scavengeLogRecord;
_iss double tenuringProportion;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
# if SQ_USE_GLOBAL_STRUCT_REG
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# else
#	define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
#	define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
# endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
# if SQ_USE_GLOBAL_STRUCT_REG
#	define fooxstr(s) foostr(s)
#	define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
# else
static struct foo * foo = &fum;
# endif
#endif
static void *primitiveCalloutPointer = (void *)-1;
static void (*interruptCheckChain)(void) = 0;
static void (*primitiveFunctionPointer)();
static int (*sHEAFn)() = 0;
sqInt checkForLeaks;
sqInt primitiveDoMixedArithmetic = -1;
sqInt upscaleDisplayIfHighDPI = -1;
sqInt sendWheelEvents;
sqInt breakLookupClassTag;
char * breakSelector;
sqInt breakSelectorLength = MinSmallInteger;
sqInt cannotDeferDisplayUpdates;
sqInt checkedPluginName;
sqInt debugCallbackInvokes;
sqInt debugCallbackPath;
sqInt debugCallbackReturns;
sqInt deferDisplayUpdates;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
void * displayBits;
sqInt eventTraceMask;
sqInt extraVMMemory;
sqInt ffiExceptionResponse;
sqInt inIOProcessEvents;
struct VirtualMachine* interpreterProxy;
const char *interpreterVersion = "Open Smalltalk ImageChecker VM [ImageLeakChecker VMMaker.oscog-eem.3456]";
usqInt maxOldSpaceSize;
sqInt suppressHeartbeatFlag;
int displayDepth;
int displayHeight;
int displayWidth;
char expensiveAsserts = 0;
volatile int sendTrace;
int (*showSurfaceFn)(sqIntptr_t, int, int, int, int);


/*** Macros ***/
#define cr() fputc('\n',transcript)
#define numTagBits() 3
#define shiftForWord() 3
#define smallFloatExponentBits() 8
#define smallFloatExponentOffset() 896
#define smallFloatMantissaBits() 52
#define smallFloatTag() 4
#define tagMask() 0x7
#define wordSize() 8
#define arrayClassIndexPun() 16
#define arrayFormat() 2
#define characterTag() 2
#define classIndexMask() 0x3FFFFF
#define classIsItselfClassIndexPun() 31
#define classTableMajorIndexShift() 10
#define extraAlignedBitShift() 24
#define firstByteFormat() 16
#define firstClassIndexPun() 16
#define firstCompiledMethodFormat() 24
#define firstLongFormat() 10
#define firstShortFormat() 12
#define fixedFieldsFieldWidth() 16
#define formatFieldWidthShift() 5
#define formatMask() 0x1F
#define formatShift() 24
#define greyBitShift() 31
#define identityHashFullWordShift() 32
#define identityHashHalfWordMask() 0x3FFFFF
#define immutableBitShift() 23
#define indexablePointersFormat() 3
#define isForwardedObjectClassIndexPun() 8
#define isFreeObjectClassIndexPun() 0
#define lastClassIndexPun() 31
#define markedBitFullShift() 55
#define markedBitHalfShift() 23
#define numSlotsFullShift() 56
#define numSlotsHalfShift() 24
#define numSlotsMask() 0xFF
#define pinnedBitShift() 30
#define rememberedBitShift() 29
#define rootTableCapacity() GIV(rememberedSetLimit)
#define rootTableCount() GIV(rememberedSetSize)
#define segmentBridgePun() 3
#define sixtyFourBitIndexableFormat() 9
#define sixtyFourBitLongsClassIndexPun() 19
#define smallIntegerTag() 1
#define startOfMemory() GIV(memory)
#define thirtyTwoBitLongsClassIndexPun() 18
#define weakArrayClassIndexPun() 17
#define weakArrayFormat() 4
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define printChar(aCharacter) fputc(aCharacter,transcript)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


/*** Methods ***/

	/* ImageLeakChecker>>#growOldSpaceByAtLeast: */
static NoDbgRegParms sqInt
growOldSpaceByAtLeast(sqInt minAmmount)
{
	error("growOldSpaceByAtLeast: was invoked; should not happen!");
	return 0;
}


/*	Initialize Interpreter state before starting execution of a new image.
	N.B. do *NOT* initialize variables that can be initialized via command
	line arguments since command line arguments are proicessed before the
	image is loaded and this initialization takes place after the image is
	loaded. Anything that us not initialized to either 0 or false (the C
	default value)
	should be initialized in StackInterpeeter class>>declareCVarsIn: */

	/* ImageLeakChecker>>#initializeInterpreter: */
static NoDbgRegParms void
initializeInterpreter(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	noteValidHeapExtent(bytesToShift);

	/* begin sqGetInterpreterProxy */
	interpreterProxy = null;
	initializeObjectMemory(bytesToShift);
	checkAssumedCompactClasses();
	initializeExtraClassInstVarIndices();
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	GIV(methodDictLinearSearchLimit) = 8;
	GIV(profileSemaphore) = (GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj)));

	/* cmd-. as used for Mac but no other OS */
	GIV(interruptKeycode) = 2094;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = ((time(NULL)) + 1 /* ioMSecs */) & 0x7FFFFFFF;
	}
	GIV(metaAccessorDepth) = -2;
	sHEAFn = ioLoadFunctionFrom("secHasEnvironmentAccess", "SecurityPlugin");
}

	/* ImageLeakChecker>>#ioLoadFunction:From: */
void *
ioLoadFunctionFrom(char *functionName, char *moduleName)
{
	return null;
}

	/* ImageLeakChecker>>#main:_: */
int
main(int argc, char *argv[])
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argi;
    sqInt forVersion;
    FILE *ifh;
    sqInt ok;
    int okSwizzle;

	argi = 1;
	forVersion = 0;
	while ((argi < argc)
	 && (((argv[argi])[0]) == '-')) {
		if (!(strcmp(/* asCommandLineArgument: */
				(PharoVM
					? "--" "version"
					: "-" "version"), argv[argi]))) {
			printf("%s\n", interpreterVersion);
			forVersion = 1;
		}
		if (!(strcmp(/* asCommandLineArgument: */
				(PharoVM
					? "--" "verbose"
					: "-" "verbose"), argv[argi]))) {
			GIV(verbose) = 1;
		}
		argi += 1;
	}
	if ((argc == argi)
	 && (forVersion)) {
		return 0;
	}
	if ((argc != (argi + 1))
	 || (((ifh = sqImageFileOpen((GIV(imageFilename) = argv[argi]), "rb"))) == 0)) {
		printf("Usage: %s [%s] [%s] imageFileName\n",
				argv[0],
				/* asCommandLineArgument: */
			(PharoVM
				? "--" "verbose"
				: "-" "verbose"),
				/* asCommandLineArgument: */
			(PharoVM
				? "--" "version"
				: "-" "version"));
		return 1;
	}
	readImageFromFileHeapSizeStartingAt(ifh, 0, 0);
	sqImageFileClose(ifh);
	okSwizzle = !GIV(detectedInvalidOop);
	ok = runLeakCheckerForResult(GCModeFull);
	if (GIV(verbose)
	 && (okSwizzle
	 && (ok))) {
		printf("Image %s is free of leaks\n", argv[argi]);
	}
	return (ok
			? 0
			: 2);
}


/*	This is used in macros in some sqPlatformSpecific.h, sigh... */

	/* ImageLeakChecker>>#plugInNotifyUser: */
int
plugInNotifyUser(char *msg)
{
	error(msg);
	return 0;
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles). In the simulator use 16r as the prefix, padding to 11 characters
	in 32-bits
	or 19 characters in 64-bits. */

	/* ImageLeakChecker>>#printHex: */
void
printHex(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(verbose)) {
		fprintf(GIV(transcript),
				"%16p" /* pst: */,
				((void *)n));
	}
}

	/* ImageLeakChecker>>#printNum: */
static NoDbgRegParms void
printNum(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(verbose)) {
		fprintf(GIV(transcript),
				"%" PRIdSQINT "",
				((sqInt)n));
	}
}

	/* ImageLeakChecker>>#print: */
void
print(char *s)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(verbose)) {
		fprintf(GIV(transcript),
				"%s",
				s);
	}
}

	/* ImageLeakChecker>>#runLeakCheckerForResult: */
static NoDbgRegParms sqInt
runLeakCheckerForResult(sqInt gcModes)
{
	clearLeakMapAndMapAccessibleObjects();
	return checkHeapIntegrityclassIndicesShouldBeValid(0, 1);
}

	/* ImageLeakChecker>>#whereIsMaybeStackThing: */
static NoDbgRegParms char *
whereIsMaybeStackThing(sqInt thing)
{
	return null;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#isDirectAlien: */
static NoDbgRegParms int
isDirectAlien(sqInt oop)
{
	return (longAt(oop + BaseHeaderSize)) > 0;
}

	/* InterpreterPrimitives>>#isIndirectAlien: */
static NoDbgRegParms int
isIndirectAlien(sqInt oop)
{
	return (longAt(oop + BaseHeaderSize)) < 0;
}

	/* InterpreterPrimitives>>#isPointerAlien: */
static NoDbgRegParms int
isPointerAlien(sqInt oop)
{
	return (longAt(oop + BaseHeaderSize)) == 0;
}


/*	Answer if oop is a value of an integer in address range, i.e up to the
	size of a machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

	/* InterpreterPrimitives>>#isPositiveMachineIntegerObject: */
static NoDbgRegParms sqInt
isPositiveMachineIntegerObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt classOop;
    int ok;

	if ((((oop) & 7) == 1)) {
		return ((oop >> 3)) >= 0;
	}
	if (isImmediate(oop)) {
		return 0;
	}
	classOop = fetchPointerofObject(ClassLargePositiveInteger, GIV(specialObjectsOop));

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = classIndexOf(oop);
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	return ok
	 && ((numBytesOfBytes(oop)) <= (sizeof(usqIntptr_t)));
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#sizeOfAlienData: */
usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return SQABS((longAt(oop + BaseHeaderSize)));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

	/* InterpreterPrimitives>>#startOfAlienData: */
void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop))))) {
		/* primitiveFailFor: */
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) ((isDirectAlien(oop)
		? (oop + BaseHeaderSize) + BytesPerOop
		: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Answer the address immediately following an object. */

	/* Spur64BitMemoryManager>>#addressAfter: */
static NoDbgRegParms usqInt
addressAfter(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	if (!numSlots) {
		return (objOop + (allocationUnit())) + BaseHeaderSize;
	}
	if (numSlots == (numSlotsMask())) {
		numSlots = ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8;
	}
	return (objOop + BaseHeaderSize) + (((numSlots << (shiftForWord()))));
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. Try
	and allocate in a segment that already includes pinned objects. The header
	of the
	result will have been filled-in but not the contents. */

	/* Spur64BitMemoryManager>>#allocateSlotsForPinningInOldSpace:bytes:format:classIndex: */
static NoDbgRegParms sqInt
allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt acceptedChunk;
    sqInt acceptedNode;
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt nextFreeChunk;
    sqInt nextSqInt;
    sqInt node;
    sqInt prev;

	/* begin allocateOldSpaceChunkOfBytes:suchThat: */
	next = 0;
	prev = 0;

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= totalBytes;
	initialIndex = totalBytes / (allocationUnit());
	if ((initialIndex < (numFreeLists()))
	 && ((1ULL << initialIndex) <= GIV(freeListsMask))) {
		if (((GIV(freeListsMask) & (1ULL << initialIndex)) != 0)) {
			if ((node = GIV(freeLists)[initialIndex])) {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node)));

					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node));
					next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
					if (((segmentContainingObj(node))->containsPinned)) {
						if (prev) {
							setNextFreeChunkOfwithValuechunkBytes(prev, next, totalBytes);
						}
						else {
							unlinkFreeChunkatIndexchunkBytes(node, initialIndex, totalBytes);
						}
						chunk = node;
						goto l1;
					}
					prev = node;
					node = next;
				}
			}
			else {
				GIV(freeListsMask) -= 1ULL << initialIndex;
			}
		}
		index = initialIndex;
		while ((((index += initialIndex)) < (numFreeLists()))
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if ((node = GIV(freeLists)[index])) {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));

						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node));
						next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev) {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, next);
								if (next) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, prev);
								}
							}
							else {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInBody(node)) == (index * (allocationUnit())))
								 && ((index > 1)
								 && ((startOfObject(node)) == node)));
								GIV(freeLists)[index] = ((nextSqInt = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node)));
								if (nextSqInt) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextSqInt, 0);
								}
							}
							freeChunkWithBytesat((index * (allocationUnit())) - totalBytes, (startOfObject(node)) + totalBytes);
							chunk = node;
							goto l1;
						}
						prev = node;
						node = next;
					}
				}
				else {
					GIV(freeListsMask) -= 1ULL << index;
				}
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < (numFreeLists()))
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if ((node = GIV(freeLists)[index])) {
					prev = 0;
					while (node != 0) {
						assert(node == (startOfObject(node)));

						/* begin assertValidFreeObject: */
						assert(assertInnerValidFreeObject(node));
						next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
						if (((segmentContainingObj(node))->containsPinned)) {
							if (prev) {
								/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
								storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, next);
								if (next) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, prev);
								}
							}
							else {
								/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
								assert(((bytesInBody(node)) == (index * (allocationUnit())))
								 && ((index > 1)
								 && ((startOfObject(node)) == node)));
								GIV(freeLists)[index] = ((nextSqInt = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node)));
								if (nextSqInt) {
									storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextSqInt, 0);
								}
							}
							freeChunkWithBytesat((index * (allocationUnit())) - totalBytes, (startOfObject(node)) + totalBytes);
							chunk = node;
							goto l1;
						}
						prev = node;
						node = next;
					}
				}
				else {
					GIV(freeListsMask) -= 1ULL << index;
				}
			}
		}
	}
	child = GIV(freeLists)[0];
	node = (acceptedChunk = (acceptedNode = 0));
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child));
		childBytes = bytesInBody(child);
		if (childBytes == totalBytes) {

			/* size match; try to remove from list at node. */
			node = child;
			while (1) {
				prev = node;
				node = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
				if (!(node != 0)) break;
				if (((segmentContainingObj(node))->containsPinned)) {
					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(node));
					nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);

					/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
					storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, nextFreeChunk);
					if (nextFreeChunk) {
						storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, prev);
					}
					chunk = startOfObject(node);
					goto l1;
				}
			}
			if (((segmentContainingObj(child))->containsPinned)) {
				next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, child);
				if (next) {

					/* list; replace node with it */
					inFreeTreeReplacewith(child, next);
				}
				else {

					/* no list; remove the interior node */
					unlinkSolitaryFreeTreeNode(child);
				}
				chunk = startOfObject(child);
				goto l1;
			}
		}
		if (child) {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (totalBytes + (allocationUnit()))) {

				/* node too small; walk down the larger size of the tree */
				child = fetchPointerofFreeChunk(freeChunkLargerIndex(), child);
			}
			else {
				flag("we can do better here; preferentially choosing the lowest node. That would be a form of best-fit since we are trying to compact down");
				node = child;
				child = fetchPointerofFreeChunk(freeChunkSmallerIndex(), node);
				if (!acceptedNode) {
					/* first search the list. */
					acceptedChunk = node;
					do {
						acceptedChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedChunk);
						if ((acceptedChunk != 0)
						 && (((segmentContainingObj(acceptedChunk))->containsPinned))) {
							acceptedNode = node;
						}
					} while((acceptedChunk != 0)
						 && (acceptedNode == 0));
					if ((acceptedNode == 0)
					 && (((segmentContainingObj(node))->containsPinned))) {
						acceptedNode = node;

						/* break out of loop now we have an acceptedNode */
						child = 0;
					}
				}
			}
		}
	}
	if (acceptedNode) {
		if (acceptedChunk) {
			assert((bytesInBody(acceptedChunk)) >= (totalBytes + (allocationUnit())));
			while (1) {
				next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedNode);
				if (!(next != acceptedChunk)) break;
				acceptedNode = next;
			}
			nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedChunk);

			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, acceptedNode, nextFreeChunk);
			if (nextFreeChunk) {
				storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, acceptedNode);
			}
			freeChunkWithBytesat((bytesInBody(acceptedChunk)) - totalBytes, (startOfObject(acceptedChunk)) + totalBytes);
			chunk = startOfObject(acceptedChunk);
			goto l1;
		}
		next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, acceptedNode);
		if (next) {

			/* list; replace node with it */
			inFreeTreeReplacewith(acceptedNode, next);
		}
		else {

			/* no list; remove the interior node */
			unlinkSolitaryFreeTreeNode(acceptedNode);
		}
		assert((bytesInBody(acceptedNode)) >= (totalBytes + (allocationUnit())));
		freeChunkWithBytesat((bytesInBody(acceptedNode)) - totalBytes, (startOfObject(acceptedNode)) + totalBytes);
		chunk = startOfObject(acceptedNode);
		goto l1;
	}

	/* optimism was unfounded */
	GIV(totalFreeOldSpace) += totalBytes;
	chunk = null;
l1:	/* end allocateOldSpaceChunkOfBytes:suchThat: */;
	if (!chunk) {
		chunk = allocateOldSpaceChunkOfBytes(totalBytes);
		if (!chunk) {
			return null;
		}
		((segmentContainingObj(chunk))->containsPinned = 1);
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))));
		longAtput(chunk + BaseHeaderSize, (((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + classIndex) | (1U << (pinnedBitShift())));
		checkFreeSpace(GCModeNewSpace);
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, (((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + classIndex) | (1U << (pinnedBitShift())));
	checkFreeSpace(GCModeNewSpace);
	return chunk;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. The
	header will have been filled-in but not the contents. If no memory is
	available answer nil. */

	/* Spur64BitMemoryManager>>#allocateSlotsInOldSpace:bytes:format:classIndex: */
static NoDbgRegParms sqInt
allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex)
{
    sqInt chunk;

	chunk = allocateOldSpaceChunkOfBytes(totalBytes);
	if (!chunk) {
		return null;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		longAtput(chunk, numSlots + ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))));
		longAtput(chunk + BaseHeaderSize, ((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + classIndex);
		checkFreeSpaceignoring(GCModeNewSpace, chunk + BaseHeaderSize);
		return chunk + BaseHeaderSize;
	}
	longAtput(chunk, ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + classIndex);
	checkFreeSpaceignoring(GCModeNewSpace, chunk);
	return chunk;
}


/*	Answer the given integer with its bytes in the reverse order. */

	/* Spur64BitMemoryManager>>#byteSwapped: */
sqInt
byteSwapped(sqInt w)
{
	return SQ_SWAP_8_BYTES(w);
}


/*	Answer the total number of bytes in an object including header and
	possible overflow size header.
 */

	/* Spur64BitMemoryManager>>#bytesInBody: */
static NoDbgRegParms usqInt
bytesInBody(sqInt objOop)
{
    usqLong header;
    usqLong headerNumSlots;
    usqLong numSlots;

	flag("endianness");
	header = longAt(objOop);
	headerNumSlots = (header) >> (numSlotsFullShift());
	numSlots = (headerNumSlots == (numSlotsMask())
				? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
				: (headerNumSlots
						? headerNumSlots
						: 1));
	return ((numSlots << (shiftForWord()))) + ((headerNumSlots == (numSlotsMask())
		? BaseHeaderSize + BaseHeaderSize
		: BaseHeaderSize));
}


/*	Answer the default amount of memory to allocate for the eden space.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file.
	The shootout tests seem to plateau at 5 or 6Mb.
	
	Originally, both the 32-bit and 64-bit versions used the same 4Mb default.
	Measuring the simulator on image start-up, the 64-bit system's eden at the
	same point in start-up
	(the first copyBits) is only 8% larger in bytes because it allocates 26%
	fewer objects.
	Some 21% of the objects in the 32-bit version's eden are large integers
	and floats that
	are representable as 64-bit immediates.
	
	But when running benchmarks such as the computer language shootout's
	binary trees,
	using the same amount of memory for the 64-bit system causes a significant
	slow-down and a lot of compactions. So we now use 4Mb for 32-bits and 7Mb
	for 64-bits. */

	/* Spur64BitMemoryManager>>#defaultEdenBytes */
static int
defaultEdenBytes(void)
{
	return 0x700000;
}


/*	Answer the tag used in lookup caches for a receiver. This is the
	receiver's classIndex. */

	/* Spur64BitMemoryManager>>#fetchClassTagOf: */
sqInt
fetchClassTagOf(sqInt oop)
{
    sqInt tagBits;

	return ((tagBits = oop & (tagMask()))
			? tagBits
			: classIndexOf(oop));
}

	/* Spur64BitMemoryManager>>#floatObjectOf: */
sqInt
floatObjectOf(double aFloat)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newFloatObj;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    usqLong rawFloat;
    usqLong rot;

	if (isSmallFloatValue(aFloat)) {
		/* begin smallFloatObjectOf: */
		assert(isSmallFloatValue(aFloat));
		memcpy((&rawFloat), (&aFloat), sizeof(rawFloat));

		/* begin smallFloatObjectOfBits: */
		assert(isSmallFloatValueBits(rawFloat));
		rot = rotateLeft(rawFloat);
		if (rot > 1) {

			/* a.k.a. ~= +/-0.0 */
			rot -= (((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
			assert(rot > 0);
		}
		return ((rot << (numTagBits()))) + (smallFloatTag());
	}
	numSlots = (sizeof(double)) / BytesPerOop;

	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	assert((numSlots >= 0)
	 && ((knownClassAtIndex(ClassFloatCompactIndex)) != GIV(nilObj)));
	assert((firstLongFormat()) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex))));

	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = smallObjectBytesForSlots(numSlots);
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if ((GIV(freeStart) + numBytes) > (((GIV(eden)).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newFloatObj = 0;
			goto l1;
		}
	}
	long64Atput(newObj, ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)((firstLongFormat())) << (formatShift()))))) + ClassFloatCompactIndex);
	GIV(freeStart) += numBytes;
	newFloatObj = newObj;
l1:	/* end eeInstantiateSmallClassIndex:format:numSlots: */;
	storeFloatAtfrom(newFloatObj + BaseHeaderSize, aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

	/* Spur64BitMemoryManager>>#floatValueOf: */
double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double result;
    sqInt tagBits;

	if ((tagBits = oop & (tagMask()))) {
		if (tagBits == (smallFloatTag())) {
			return smallFloatValueOf(oop);
		}
	}
	else {
		if ((classIndexOf(oop)) == ClassFloatCompactIndex) {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
			return result;
		}
	}

	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	This is a horrible hack for getting to the first object in eden if
	pastSpace is almost full.
	If there is only one (64-bit) word at the end of pastSpace there is no
	room for a full
	bridge, but there is room for this hack. */

	/* Spur64BitMemoryManager>>#hackSlimBridgeTo:at: */
static NoDbgRegParms void
hackSlimBridgeToat(sqInt objOop, sqInt startAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(oopisLessThan(startAddress, objOop));
	assert(oopisLessThanOrEqualTo(objOop, GIV(oldSpaceStart)));
	assert(((startAddress + (allocationUnit())) == objOop)
	 || (((startAddress + (allocationUnit())) + (allocationUnit())) == objOop));
	longAtput(startAddress, ((startAddress + (allocationUnit())) == objOop
			? ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift())))
			: ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + 1));
}


/*	A negative header selects the alternate bytecode set. */

	/* Spur64BitMemoryManager>>#headerIndicatesAlternateBytecodeSet: */
int
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((sqLong) methodHeader)) < 0;
}


/*	must have room for a header (single or double) plus the next free pointer */

	/* Spur64BitMemoryManager>>#initFreeChunkWithBytes:at: */
static NoDbgRegParms sqInt
initFreeChunkWithBytesat(usqLong numBytes, sqInt address)
{
    sqLong numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BytesPerOop)));
	if (numBytes >= (((((usqInt)((numSlotsMask())) << (shiftForWord())))) + BaseHeaderSize)) {
		numSlots = ((usqLong)(((numBytes - BaseHeaderSize) - BaseHeaderSize))) >> (shiftForWord());
		longAtput(address, ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(address + 8, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsFullShift()))));
		return address + 8;
	}
	numSlots = ((usqLong)((numBytes - BaseHeaderSize))) >> (shiftForWord());
	assert(numSlots < (numSlotsMask()));
	longAtput(address, ((sqLong)((usqLong)(numSlots) << (numSlotsFullShift()))));
	return address;
}


/*	Must have room for a double header or a short object with the forwarding
	slot (16 bytes either way).
 */

	/* Spur64BitMemoryManager>>#initSegmentBridgeWithBytes:at: */
static NoDbgRegParms void
initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address)
{
    sqLong numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= (BaseHeaderSize + BaseHeaderSize)));
	numSlots = ((usqLong)(((numBytes - BaseHeaderSize) - BaseHeaderSize))) >> (shiftForWord());
	if (numSlots) {

		/* long bridge */
		longAtput(address, ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(address + BaseHeaderSize, (((((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + (1U << (pinnedBitShift()))) + (1ULL << (markedBitFullShift()))) + ((((usqInt)((wordIndexableFormat())) << (formatShift()))))) + (segmentBridgePun()));
	}
	else {

		/* short bridge for adjacent segments */
		longAtput(address, (((1U << (pinnedBitShift())) + (1ULL << (markedBitFullShift()))) + ((((usqInt)((wordIndexableFormat())) << (formatShift()))))) + (segmentBridgePun()));
	}
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

	/* Spur64BitMemoryManager>>#integerObjectOf: */
static NoDbgRegParms sqInt
integerObjectOf(sqInt value)
{
	return (((((usqInt)value)) << (numTagBits()))) + 1;
}

	/* Spur64BitMemoryManager>>#isFloatInstance: */
static NoDbgRegParms int
isFloatInstance(sqInt oop)
{
    sqInt tagBits;

	return ((tagBits = oop & (tagMask()))
			? tagBits == (smallFloatTag())
			: (classIndexOf(oop)) == ClassFloatCompactIndex);
}

	/* Spur64BitMemoryManager>>#isImmediateFloat: */
static NoDbgRegParms int
isImmediateFloat(sqInt oop)
{
	return ((oop & (smallFloatTag())) != 0);
}

	/* Spur64BitMemoryManager>>#isIntegerObject: */
static NoDbgRegParms int
isIntegerObject(sqInt oop)
{
	return ((oop & (smallIntegerTag())) != 0);
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In 64-bits we use a 3 bit tag which leaves 61 bits for 2's complement
	signed integers. In C, use a shift add and mask to test if the top 4 bits
	are all the same.
	Since 16rFFFFFFFFFFFFFFFF >> 60 = 16rF the computation intValue >> 60 + 1
	bitAnd: 16rF
	maps in-range -ve values to 0 and in-range +ve values to 1. */

	/* Spur64BitMemoryManager>>#isIntegerValue: */
int
isIntegerValue(sqInt intValue)
{
	return (((((usqInt)(intValue)) >> 60) + 1) & 15) <= 1;
}


/*	To have a prev pointer, which follows the next pointer, we need at least
	two slots.
 */

	/* Spur64BitMemoryManager>>#isLilliputianSize: */
static NoDbgRegParms int
isLilliputianSize(sqInt chunkBytes)
{
	assert(chunkBytes >= (BaseHeaderSize + (allocationUnit())));
	return chunkBytes == (BaseHeaderSize + (allocationUnit()));
}

	/* Spur64BitMemoryManager>>#isMarked: */
int
isMarked(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (markedBitFullShift())) & 1) != 0;
}

	/* Spur64BitMemoryManager>>#isSmallFloatValueBits: */
static NoDbgRegParms int
isSmallFloatValueBits(usqLong rawFloatBits)
{
    usqInt exponent;

	exponent = ((rawFloatBits) >> (smallFloatMantissaBits())) & 0x7FF;
	return (exponent > (smallFloatExponentOffset())
			? exponent <= (0xFF + (smallFloatExponentOffset()))
			: (rawFloatBits & ((1ULL << (smallFloatMantissaBits())) - 1)
					? exponent == (smallFloatExponentOffset())
					: exponent == 0));
}

	/* Spur64BitMemoryManager>>#isSmallFloatValue: */
static NoDbgRegParms int
isSmallFloatValue(double aFloat)
{
    usqInt exponent;
    usqLong rawFloat;

	memcpy((&rawFloat), (&aFloat), sizeof(rawFloat));
	exponent = ((rawFloat) >> (smallFloatMantissaBits())) & 0x7FF;
	return (exponent > (smallFloatExponentOffset())
			? exponent <= (0xFF + (smallFloatExponentOffset()))
			: (rawFloat & ((1ULL << (smallFloatMantissaBits())) - 1)
					? exponent == (smallFloatExponentOffset())
					: exponent == 0));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* Spur64BitMemoryManager>>#isWordsNonImm: */
static NoDbgRegParms int
isWordsNonImm(sqInt objOop)
{
	return (((formatOf(objOop)) >= (firstLongFormat())) && ((formatOf(objOop)) <= ((firstShortFormat()) - 1)));
}


/*	Answer the total number of bytes in an object with an overflow header,
	including header bytes.
 */

	/* Spur64BitMemoryManager>>#largeObjectBytesForSlots: */
static NoDbgRegParms usqInt
largeObjectBytesForSlots(sqInt numSlots)
{
	return (BaseHeaderSize + BaseHeaderSize) + (numSlots * BytesPerOop);
}

	/* Spur64BitMemoryManager>>#logBytesPerOop */
static sqInt
logBytesPerOop(void)
{
	return 3;
}


/*	Answer the maximum number of slots we are willing to attempt to allocate
	in an object.
	Must fit in 56-bits; c.f. bytesInObject: */

	/* Spur64BitMemoryManager>>#maxSlotsForAlloc */
static sqInt
maxSlotsForAlloc(void)
{
	return 0x10000000000LL;
}


/*	Answer the C double precision floating point value of the argument,
	which *must* be something for which self isFloatInstance: answers true.
	Note: May be called by translated primitive code. */

	/* Spur64BitMemoryManager>>#noFailFloatValueOf: */
double
noFailFloatValueOf(sqInt aFloatOop)
{
    double result;

	assert(isFloatInstance(aFloatOop));
	if (aFloatOop & (tagMask())) {
		result = smallFloatValueOf(aFloatOop);
	}
	else {
		fetchFloatAtinto(aFloatOop + BaseHeaderSize, result);
	}
	return result;
}


/*	Answer the format for an objOop clone with indexableSize. Needs to work
	for longFormat and arrayFormat only. */

	/* Spur64BitMemoryManager>>#normalisedFormatFor:indexableSize: */
static NoDbgRegParms sqInt
normalisedFormatForindexableSize(sqInt objOop, sqInt indexableSize)
{
    sqInt format;
    sqInt instFormat;

	instFormat = formatOf(objOop);

	/* begin classFormatFromInstFormat: */
	if (instFormat >= (firstByteFormat())) {

		/* this is likely the common case */
		format = instFormat & -8;
		goto l1;
	}
	if (instFormat <= (sixtyFourBitIndexableFormat())) {
		format = instFormat;
		goto l1;
	}
	if (instFormat < (firstShortFormat())) {
		format = instFormat & -2;
		goto l1;
	}
	format = instFormat & -4;
l1:	/* end classFormatFromInstFormat: */;
	return ((format == (firstLongFormat()))
	 && (((indexableSize & 1) != 0))
			? format + 1
			: format);
}


/*	Answer the number of free lists. We use freeListsMask, a bitmap, to avoid
	reading empty list heads. This should fit in a machine word to end up in a
	register during free chunk allocation. */

	/* Spur64BitMemoryManager>>#numFreeLists */
static sqInt
numFreeLists(void)
{
	return 64;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceding word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word.
	
	This variation on objectAfter:limit: allows for a single (64-bit) word
	bridge which may be needed
	to bridge from an almost full pastSpace to eden. It is only used in the
	flat enumerators that use
	startAddressForBridgedHeapEnumeration and enumerate over pastSpace, eden
	and oldSpace
	in that order. Note that the order for allObjects, and allInstances
	enumerates over oldSpace first.
	
	This hack is cheap. It increases the size of the objectAfter code, but
	saves two extra copies of
	the inner loop, since the inner loop now enumerates over all of pastSpace,
	eden and oldSpace.
	The test for a slim bridge is only performed if applied to an overflow
	header, and typically only
	1 in 400 objects have overflow headers in 32-bits, 1 in 500 in 64-bits.
	The complication is that
	image segment loading evaporates the word array by setting the overflow
	slots to 1, and this
	is ambiguous with a slimbridge. The resolution is that if the segmentArray
	has an overflow header,
	and is in new space, then its slot size can be zeroed and its overflow
	header changed to a slimbridge.
	
	At some point we should allow slimbridges (slivers?) throughout object
	memory, and use them to
	provide object alignment by slimbridges (slivers?) padding up to the
	following (aligned) object.
 */

	/* Spur64BitMemoryManager>>#objectAfterMaybeSlimBridge:limit: */
static NoDbgRegParms sqInt
objectAfterMaybeSlimBridgelimit(sqInt objOop, sqInt limit)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, limit)) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
			 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
					? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
					: followingWordAddress + BaseHeaderSize)
			: followingWordAddress);
}


/*	Answer the total number of bytes in an object with the given
	number of slots, including header and possible overflow size header. */

	/* Spur64BitMemoryManager>>#objectBytesForSlots: */
static NoDbgRegParms usqInt
objectBytesForSlots(sqInt numSlots)
{
	return (numSlots
			? ((((usqInt)(numSlots) << (shiftForWord())))) + ((numSlots >= (numSlotsMask())
		? BaseHeaderSize + BaseHeaderSize
		: BaseHeaderSize))
			: (allocationUnit()) + BaseHeaderSize);
}

	/* Spur64BitMemoryManager>>#rotateLeft: */
static NoDbgRegParms usqInt
rotateLeft(sqInt anInteger)
{
	return ((((usqInt)(anInteger)) >> 0x3F) & 1) + ((((usqInt)(anInteger) << 1)));
}

	/* Spur64BitMemoryManager>>#rotateRight: */
static NoDbgRegParms usqInt
rotateRight(sqInt anInteger)
{
	return ((((usqInt)(anInteger) << 0x3F))) + (((((usqInt)anInteger))) >> 1);
}

	/* Spur64BitMemoryManager>>#setClassIndexOf:to: */
static NoDbgRegParms void
setClassIndexOfto(sqInt objOop, sqInt classIndex)
{
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(classIndexMask()))) + classIndex);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable
	12 - 15 16-bit indexable
	16 - 23 byte indexable
	24 - 31 compiled method */

	/* Spur64BitMemoryManager>>#setFormatOf:to: */
static NoDbgRegParms void
setFormatOfto(sqInt objOop, sqInt format)
{
	assert(((format >= 0) && (format <= (formatMask()))));
	longAtput(objOop, ((longAt(objOop)) & (~(usqIntptr_t)(((sqInt)((usqInt)((formatMask())) << (formatShift())))))) + ((((usqInt)(format) << (formatShift())))));
}

	/* Spur64BitMemoryManager>>#setIsImmutableOf:to: */
static NoDbgRegParms void
setIsImmutableOfto(sqInt objOop, sqInt aBoolean)
{
	longAtput(objOop, (aBoolean
			? (longAt(objOop)) | (1U << (immutableBitShift()))
			: (longAt(objOop)) & (~(usqIntptr_t)(1U << (immutableBitShift())))));
}

	/* Spur64BitMemoryManager>>#setIsMarkedOf:to: */
static NoDbgRegParms void
setIsMarkedOfto(sqInt objOop, sqInt aBoolean)
{
	assert(!(isFreeObject(objOop)));
	longAtput(objOop, (aBoolean
			? (longAt(objOop)) | (1ULL << (markedBitFullShift()))
			: (longAt(objOop)) & (~(usqIntptr_t)(1ULL << (markedBitFullShift())))));
}

	/* Spur64BitMemoryManager>>#setIsPinnedOf:to: */
static NoDbgRegParms void
setIsPinnedOfto(sqInt objOop, sqInt aBoolean)
{
	longAtput(objOop, (aBoolean
			? (longAt(objOop)) | (1U << (pinnedBitShift()))
			: (longAt(objOop)) & (~(usqIntptr_t)(1U << (pinnedBitShift())))));
}

	/* Spur64BitMemoryManager>>#setIsRememberedOf:to: */
static NoDbgRegParms void
setIsRememberedOfto(sqInt objOop, sqInt aBoolean)
{
	longAtput(objOop, (aBoolean
			? (longAt(objOop)) | (1U << (rememberedBitShift()))
			: (longAt(objOop)) & (~(usqIntptr_t)(1U << (rememberedBitShift())))));
}


/*	Answer the ieee 754 double precision floating point bits of the argument,
	a SmallFloat.
	See section 61-bit Immediate Floats in the SpurMemoryManager class
	comment. msb lsb 
	Decode:				[8expsubset][52mantissa][1s][3tags] 
	shift away tags:		[ 000 ][8expsubset][52mantissa][1s] 
	add exponent offset:	[ 11 exponent ][52mantissa][1s] 
	rot sign:				[1s][ 11 exponent ][52mantissa] */

	/* Spur64BitMemoryManager>>#smallFloatBitsOf: */
static NoDbgRegParms usqLong
smallFloatBitsOf(sqInt oop)
{
    usqLong rot;

	assert(isImmediateFloat(oop));
	rot = ((((usqInt)oop))) >> (numTagBits());
	if (rot > 1) {

		/* a.k.a. ~= +/-0.0 */
		rot += (((usqInt)((smallFloatExponentOffset())) << ((smallFloatMantissaBits()) + 1)));
	}
	rot = rotateRight(rot);
	return rot;
}


/*	Answer the C double precision floating point value of the argument, a
	SmallFloat. See section 61-bit Immediate Floats in the SpurMemoryManager
	class comment.
	msb lsb 
	Decode:				[8expsubset][52mantissa][1s][3tags] 
	shift away tags:		[ 000 ][8expsubset][52mantissa][1s] 
	add exponent offset:	[ 11 exponent ][52mantissa][1s] 
	rot sign:				[1s][ 11 exponent ][52mantissa] */

	/* Spur64BitMemoryManager>>#smallFloatValueOf: */
static NoDbgRegParms double
smallFloatValueOf(sqInt oop)
{
    usqLong bits;
    double value;

	bits = smallFloatBitsOf(oop);
	memcpy((&value), (&bits), sizeof(value));
	return value;
}


/*	Answer the total number of bytes in an object without an overflow header,
	including header bytes.
 */

	/* Spur64BitMemoryManager>>#smallObjectBytesForSlots: */
usqInt
smallObjectBytesForSlots(sqInt numSlots)
{
	return BaseHeaderSize + ((numSlots < 1
		? allocationUnit()
		: numSlots * BytesPerOop));
}


/*	Update the odd bits of a word object, if required. It will need to be
	extended if
	shortening of 16-bit or 8-bit pure bits objects is ever supported. */

	/* Spur64BitMemoryManager>>#updateFormatOfShortenedObject:to: */
static NoDbgRegParms void
updateFormatOfShortenedObjectto(sqInt objOop, sqInt indexableSize)
{
	if ((((formatOf(objOop)) >= (firstLongFormat())) && ((formatOf(objOop)) <= ((firstLongFormat()) + 1)))) {
		setFormatOfto(objOop, (firstLongFormat()) + (indexableSize & 1));
	}
}

	/* Spur64BitMemoryManager>>#wordIndexableFormat */
static sqInt
wordIndexableFormat(void)
{
	return sixtyFourBitIndexableFormat();
}

	/* Spur64BitMemoryManager>>#wordSizeClassIndexPun */
static sqInt
wordSizeClassIndexPun(void)
{
	return sixtyFourBitLongsClassIndexPun();
}


/*	Forget the argument. */

	/* SpurGenerationScavenger>>#forgetObject: */
static NoDbgRegParms void
forgetObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	assert(GIV(rememberedSetSize) > 0);
	assert(isRemembered(objOop));
	setIsRememberedOfto(objOop, 0);
	if (!(objOop == (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]))) {
		index = 0;
		while (index < GIV(rememberedSetSize)) {
			if (objOop == (GIV(rememberedSet)[index])) {
				GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
				index = GIV(rememberedSetSize);
			}
			else {
				index += 1;
			}
		}
	}
	GIV(rememberedSetSize) -= 1;
	assert(GIV(rememberedSetSize) >= 0);
}

	/* SpurGenerationScavenger>>#growRememberedSet */
static void
growRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt *base;
    sqInt fudge;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    sqInt obj;


	/* Don't ruin locality in remember: */
	obj = fetchPointerofObject(RememberedSetRootIndex, GIV(hiddenRootsObj));
	numSlots = numSlotsOf(obj);
	assert(numSlots >= 0x400);
	newObj = allocatePinnedSlots(numSlots * 2);
	if (!newObj) {
		newObj = allocatePinnedSlots(numSlots + 0x400);
		if (!newObj) {
			if (!(growOldSpaceByAtLeast((numSlots + 0x400) * BytesPerOop))) {
				error("could not grow remembered set");
			}

			/* cannot fail */
			newObj = allocatePinnedSlots(numSlots + 0x400);
		}
	}
	rememberedSetObj(newObj);
	base = firstIndexableField(newObj);
	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		base[i] = (GIV(rememberedSet)[i]);
	}
	if (isMarked(obj)) {
		setIsMarkedOfto(newObj, 1);
		setIsMarkedOfto(obj, 0);
	}
	freeObject(obj);
	GIV(rememberedSet) = base;
	GIV(rememberedSetLimit) = numSlotsOf(newObj);

	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 0x400;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#initFutureSpaceStart */
static sqInt
initFutureSpaceStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oldStart;

	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	return oldStart;
}

	/* SpurGenerationScavenger>>#initializeRememberedSet */
static void
initializeRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fudge;
    sqInt obj;

	obj = fetchPointerofObject(RememberedSetRootIndex, GIV(hiddenRootsObj));
	if (obj == GIV(nilObj)) {
		obj = allocatePinnedSlots(0x400);
		rememberedSetObj(obj);
	}
	else {

		/* The Spur32to64BitBootstrap failed to set the type of rememberedSetObj to 64-bit indexability.
		   This is unimportant except for simulation; rememberedSet is declared as sqInt *, but to have
		   firstIndexableField: below answer a suitable type the format must be wordIndexableFormat. */
		setFormatOfto(obj, wordIndexableFormat());
	}
	assert((formatOf(obj)) == (wordIndexableFormat()));
	assert(isPinned(obj));
	GIV(rememberedSet) = firstIndexableField(obj);
	GIV(rememberedSetSize) = 0;
	GIV(rememberedSetLimit) = numSlotsOf(obj);

	/* begin setRememberedSetRedZone */
	fudge = ((((GIV(eden).limit)) - ((GIV(eden).start))) / BytesPerWord) / 0x400;
	GIV(rememberedSetRedZone) = ((((GIV(rememberedSetLimit) * 3) / 4) < fudge) ? fudge : ((GIV(rememberedSetLimit) * 3) / 4));
}

	/* SpurGenerationScavenger>>#isInRememberedSet: */
static NoDbgRegParms sqInt
isInRememberedSet(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		if ((GIV(rememberedSet)[i]) == objOop) {
			return 1;
		}
	}
	return 0;
}

	/* SpurGenerationScavenger>>#newSpaceStart:newSpaceBytes:survivorBytes: */
static NoDbgRegParms void
newSpaceStartnewSpaceBytessurvivorBytes(sqInt startAddress, sqInt totalBytes, sqInt requestedSurvivorBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualEdenBytes;
    sqInt survivorBytes;

	survivorBytes = (requestedSurvivorBytes & ~7);
	actualEdenBytes = (((totalBytes - survivorBytes) - survivorBytes) & ~7);
	assert((((totalBytes - actualEdenBytes) - survivorBytes) - survivorBytes) < (allocationUnit()));
	(GIV(pastSpace).start = startAddress);
	(GIV(pastSpace).limit = startAddress + survivorBytes);
	(GIV(futureSpace).start = (GIV(pastSpace).limit));
	(GIV(futureSpace).limit = ((GIV(pastSpace).limit)) + survivorBytes);
	(GIV(eden).start = (GIV(futureSpace).limit));
	(GIV(eden).limit = startAddress + totalBytes);
	assert((((GIV(futureSpace)).limit)) <= (startAddress + totalBytes));
	assert((((((GIV(eden)).start)) % (allocationUnit())) + ((((GIV(eden)).limit)) % (allocationUnit()))) == 0);
	assert((((((GIV(pastSpace)).start)) % (allocationUnit())) + ((((GIV(pastSpace)).limit)) % (allocationUnit()))) == 0);
	assert((((((GIV(futureSpace)).start)) % (allocationUnit())) + ((((GIV(futureSpace)).limit)) % (allocationUnit()))) == 0);
	initFutureSpaceStart();
	GIV(tenuringProportion) = 0.9;
}

	/* SpurGenerationScavenger>>#openScavengeLog */
void
openScavengeLog(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(scavengeLog) = fopen("scavenge.log", "a+");
}


/*	Print the objects in the remembered set. */
/*	useful for debugging */

	/* SpurGenerationScavenger>>#printRememberedSet */
void
printRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		printNum(i);

		/* begin space */
		printChar(' ');
		shortPrintOop(GIV(rememberedSet)[i]);
	}
}


/*	Add the argument to the remembered set and set its isRemembered bit to
	true. Answer the argument for the benefit of the Cogit. */

	/* SpurGenerationScavenger>>#remember: */
sqInt
remember(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	assert(!((isYoungObject(objOop))));
	assert(!((isRemembered(objOop))));
	assert(!((isInRememberedSet(objOop))));
	setIsRememberedOfto(objOop, 1);
	if (GIV(rememberedSetSize) >= GIV(rememberedSetLimit)) {
		growRememberedSet();
	}
	GIV(rememberedSet)[GIV(rememberedSetSize)] = objOop;
	if (((GIV(rememberedSetSize) += 1)) >= GIV(rememberedSetRedZone)) {
	}
	return objOop;
}

	/* SpurLeakCheckingSegmentManager>>#noteValidHeapExtent: */
static NoDbgRegParms void
noteValidHeapExtent(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(oldHeapBase) = GIV(oldSpaceStart) - bytesToShift;
	GIV(oldHeapLimit) = ((((lastSegment()).segStart)) + (((lastSegment()).segSize))) - (((lastSegment()).swizzle));
}


/*	Override to check that objOop is in bounds. */

	/* SpurLeakCheckingSegmentManager>>#swizzleObj:in: */
static NoDbgRegParms sqInt
swizzleObjin(sqInt objOop, sqInt containerOopOrNil)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	if (!(oopisGreaterThanOrEqualToandLessThan(objOop, GIV(oldHeapBase), GIV(oldHeapLimit)))) {
		if (GIV(verbose)) {
			if (!GIV(subsequentReport)) {
				printf("Swizzling:\n");
				GIV(subsequentReport) = 1;
			}
			if (containerOopOrNil) {
				printf("Oop %p is out of bounds at/in %p\n", objOop, containerOopOrNil - GIV(nilObj));
			}
			else {
				printf("Oop %p is out of bounds\n", objOop);
			}
		}
		GIV(detectedInvalidOop) = 1;
	}
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}


/*	Answer whether an ephemeron is active (has an unmarked
	key) and was pushed on the unscanned ephemerons stack. */

	/* SpurMemoryManager>>#activeAndDeferredScan: */
static NoDbgRegParms NeverInline sqInt
activeAndDeferredScan(sqInt anEphemeron)
{
    sqInt key;

	key = 0;
	assert(isEphemeron(anEphemeron));
	if ((isImmediate((key = keyOfEphemeron(anEphemeron))))
	 || (isMarked(key))) {
		return 0;
	}
	return pushOnUnscannedEphemeronsStack(anEphemeron);
}


/*	Add a freeChunk sub tree back into the large free chunk tree.
	This is for allocateOldSpaceChunkOf[Exactly]Bytes:[suchThat:]. */
/*	N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */

	/* SpurMemoryManager>>#addFreeSubTree: */
static NoDbgRegParms void
addFreeSubTree(sqInt freeTree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesInArg;
    usqInt bytesInNode;
    sqInt subNode;
    sqInt treeNode;

	assert(isFreeObject(freeTree));
	bytesInArg = bytesInBody(freeTree);
	assert(bytesInArg >= ((numFreeLists()) * (allocationUnit())));
	treeNode = GIV(freeLists)[0];
	assert(treeNode != 0);
	while (1) {
		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		bytesInNode = bytesInBody(treeNode);
		assert((oopisLessThanOrEqualTo((freeTree + bytesInArg) - BaseHeaderSize, treeNode))
		 || (oopisGreaterThanOrEqualTo(freeTree, (treeNode + bytesInNode) - BaseHeaderSize)));
		assert(bytesInNode >= ((numFreeLists()) * (allocationUnit())));
		assert(bytesInArg != bytesInNode);
		if (bytesInNode > bytesInArg) {
			subNode = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode);
			if (!subNode) {
				storePointerofFreeChunkwithValue(freeChunkSmallerIndex(), treeNode, freeTree);
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeTree, treeNode);
				return;
			}
		}
		else {
			subNode = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode);
			if (!subNode) {
				storePointerofFreeChunkwithValue(freeChunkLargerIndex(), treeNode, freeTree);
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeTree, treeNode);
				return;
			}
		}
		treeNode = subNode;
	}
}


/*	Add the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#addGCRoot: */
sqInt
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootsSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}

	/* SpurMemoryManager>>#addressCouldBeObj: */
sqInt
addressCouldBeObj(sqInt address)
{
	return ((address & (BaseHeaderSize - 1)) == 0)
	 && ((isInOldSpace(address))
	 || ((isInEden(address))
	 || ((isInPastSpace(address))
	 || ((scavengeInProgress())
	 && (isInFutureSpace(address))))));
}

	/* SpurMemoryManager>>#addressCouldBeOldObj: */
static NoDbgRegParms sqInt
addressCouldBeOldObj(sqInt address)
{
	return ((address & (BaseHeaderSize - 1)) == 0)
	 && (isInOldSpace(address));
}


/*	Answer if address appears to be that of either an immediate or an object.
	For code disassembly and assertions. */

	/* SpurMemoryManager>>#addressCouldBeOop: */
sqInt
addressCouldBeOop(sqInt address)
{
	return (isImmediate(address))
	 || (addressCouldBeObj(address));
}


/*	Add freeChunk to the relevant freeList.
	For the benefit of sortedFreeObject:, if freeChunk is large, answer the
	treeNode it
	is added to, if it is added to the next list of a freeTreeNode, otherwise
	answer 0. */
/*	coInterpreter transcript ensureCr. coInterpreter print: 'freeing '. self
	printFreeChunk: freeChunk.
 */

	/* SpurMemoryManager>>#addToFreeList:bytes: */
static NoDbgRegParms sqInt
addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInBody(freeChunk)));
	index = chunkBytes / (allocationUnit());
	if (index < (numFreeLists())) {
		setNextFreeChunkOfwithValuechunkBytes(freeChunk, GIV(freeLists)[index], chunkBytes);
		if (!(isLilliputianSize(chunkBytes))) {
			storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, freeChunk, 0);
		}
		GIV(freeLists)[index] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | (1ULL << index);
		return 0;
	}
	return addToFreeTreebytes(freeChunk, chunkBytes);
}


/*	Add freeChunk to the large free chunk tree.
	For the benefit of sortedFreeObject:, answer the treeNode it is added
	to, if it is added to the next list of a freeTreeNode, otherwise answer 0. */

	/* SpurMemoryManager>>#addToFreeTree:bytes: */
static NoDbgRegParms sqInt
addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt nextFreeChunk;
    sqInt parent;

	initFreeTreeChunkbytes(freeChunk, chunkBytes);
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		/* check for overlap; could write this as self oop: (self objectAfter: freeChunk) isLessThanOrEqualTo: child...
		   but that relies on headers being correct, etc.  So keep it clumsy... */
		childBytes = bytesInBody(child);
		assert((oopisLessThanOrEqualTo((freeChunk + chunkBytes) - BaseHeaderSize, child))
		 || (oopisGreaterThanOrEqualTo(freeChunk, (child + childBytes) - BaseHeaderSize)));
		if (childBytes == chunkBytes) {

			/* size match; add to list at node. */
			nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, child);

			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, freeChunk, nextFreeChunk);
			if (nextFreeChunk) {
				storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, freeChunk);
			}

			/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
			storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, child, freeChunk);
			if (freeChunk) {
				storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, freeChunk, child);
			}
			return child;
		}
		parent = child;
		child = fetchPointerofFreeChunk((childBytes > chunkBytes
					? freeChunkSmallerIndex()
					: freeChunkLargerIndex()), child);
	}
	if (!parent) {
		assert((GIV(freeLists)[0]) == 0);
		GIV(freeLists)[0] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | 1;
		return 0;
	}
	assert(((GIV(freeListsMask) & 1) != 0));
	storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeChunk, parent);
	storePointerofFreeChunkwithValue((childBytes > chunkBytes
			? freeChunkSmallerIndex()
			: freeChunkLargerIndex()), parent, freeChunk);
	return 0;
}


/*	Adjust all oop references by the given number of bytes. This is
	done just after reading in an image when the new base address
	of the object heap is different from the base address in the image,
	or when loading multiple segments that have been coalesced. Also
	set bits in the classTableBitmap corresponding to used classes. */

	/* SpurMemoryManager>>#adjustAllOopsBy: */
static NoDbgRegParms void
adjustAllOopsBy(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt chunkBytes;
    sqInt classIndex;
    sqInt field;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt index;
    sqInt obj;

	assert(newSpaceIsEmpty());
	countNumClassPagesPreSwizzle(bytesToShift);
	if ((bytesToShift != 0)
	 || (GIV(numSegments) > 1)) {
		obj = objectStartingAt(GIV(oldSpaceStart));
		while (oopisLessThan(obj, GIV(freeOldSpaceStart))) {
			classIndex = classIndexOf(obj);
			if (classIndex >= (isForwardedObjectClassIndexPun())) {
				/* begin swizzleFieldsOfObject: */
				fieldAddr = obj + (lastPointerOfWhileSwizzling(obj));
				while (oopisGreaterThanOrEqualTo(fieldAddr, obj + BaseHeaderSize)) {
					fieldOop = longAt(fieldAddr);
					if (isNonImmediate(fieldOop)) {
						longAtput(fieldAddr, swizzleObjin(fieldOop, obj));
					}
					fieldAddr -= BytesPerOop;
				}
			}
			else {
				if (classIndex == (isFreeObjectClassIndexPun())) {
					/* begin swizzleFieldsOfFreeChunk: */
					field = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, obj);
					if (field) {
						storePointerNoAssertofFreeChunkwithValue(0 /* freeChunkNextIndex */, obj, swizzleObjin(field, obj));
					}
					chunkBytes = bytesInBody(obj);
					if (chunkBytes >= ((numFreeLists()) * (allocationUnit()))) {
						for (index = 2 /* freeChunkParentIndex */; index <= (freeChunkLargerIndex()); index += 1) {
							field = fetchPointerofFreeChunk(index, obj);
							if (field) {
								storePointerNoAssertofFreeChunkwithValue(index, obj, swizzleObjin(field, obj));
							}
						}
					}
				}
			}

			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(obj);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
				obj = GIV(endOfMemory);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
						? followingWordAddress + BaseHeaderSize
						: followingWordAddress);
l1:	/* end objectAfter:limit: */;
		}
	}
}


/*	Answer a chunk of oldSpace from the free lists, if available,
	otherwise answer nil. Break up a larger chunk if one of the
	exact size does not exist. N.B. the chunk is simply a pointer, it
	has no valid header. The caller *must* fill in the header correctly. */
/*	for debugging: */
/*	totalFreeOldSpace := self totalFreeListBytes */

	/* SpurMemoryManager>>#allocateOldSpaceChunkOfBytes: */
static NoDbgRegParms sqInt
allocateOldSpaceChunkOfBytes(usqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqInt childBytes;
    sqInt chunk;
    usqInt index;
    usqInt initialIndex;
    sqInt next;
    sqInt nextFreeChunk;
    usqInt nodeBytes;
    sqInt parent;

	nodeBytes = 0;

	/* be optimistic (& don't wait for the write) */
	GIV(totalFreeOldSpace) -= chunkBytes;
	initialIndex = chunkBytes / (allocationUnit());
	if ((initialIndex < (numFreeLists()))
	 && ((1ULL << initialIndex) <= GIV(freeListsMask))) {
		if (((GIV(freeListsMask) & (1ULL << initialIndex)) != 0)) {
			if ((chunk = GIV(freeLists)[initialIndex])) {
				assert(chunk == (startOfObject(chunk)));

				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk));
				unlinkFreeChunkatIndexchunkBytes(chunk, initialIndex, chunkBytes);
				return chunk;
			}
			GIV(freeListsMask) -= 1ULL << initialIndex;
		}
		index = initialIndex;
		while ((((index += index)) < (numFreeLists()))
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if ((chunk = GIV(freeLists)[index])) {
					assert(chunk == (startOfObject(chunk)));

					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk));
					assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = ((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk)));
					if (next) {
						storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, 0);
					}
					assert((bytesInBody(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * (allocationUnit())) - chunkBytes, (startOfObject(chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1ULL << index;
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < (numFreeLists()))
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if (((GIV(freeListsMask) & (1ULL << index)) != 0)) {
				if ((chunk = GIV(freeLists)[index])) {
					assert(chunk == (startOfObject(chunk)));

					/* begin assertValidFreeObject: */
					assert(assertInnerValidFreeObject(chunk));
					assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk)) == chunk)));
					GIV(freeLists)[index] = ((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk)));
					if (next) {
						storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, 0);
					}
					assert((bytesInBody(chunk)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * (allocationUnit())) - chunkBytes, (startOfObject(chunk)) + chunkBytes);
					return chunk;
				}
				GIV(freeListsMask) -= 1ULL << index;
			}
		}
	}
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(child));
		childBytes = bytesInBody(child);
		if (childBytes == chunkBytes) {

			/* size match; try to remove from list at node. */
			chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, child);
			if (chunk) {
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(chunk));
				nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk);

				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, child, nextFreeChunk);
				if (nextFreeChunk) {
					storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, child);
				}
				return startOfObject(chunk);
			}
			nodeBytes = childBytes;
			parent = child;

			/* break out of loop to remove interior node */
			child = 0;
		}
		else {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */
			if (childBytes <= (chunkBytes + (allocationUnit()))) {

				/* node too small; walk down the larger size of the tree */
				child = fetchPointerofFreeChunk(freeChunkLargerIndex(), child);
			}
			else {
				/* parent will be smallest node >= chunkBytes + allocationUnit */
				parent = child;
				nodeBytes = childBytes;
				child = fetchPointerofFreeChunk(freeChunkSmallerIndex(), child);
			}
		}
	}
	if (!parent) {
		/* optimism was unfounded */
		GIV(totalFreeOldSpace) += chunkBytes;
		return null;
	}
	assert((nodeBytes == chunkBytes)
	 || (nodeBytes >= (chunkBytes + (2 * (allocationUnit())))));
	assert((bytesInBody(parent)) == nodeBytes);
	chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, parent);
	if (chunk) {
		assert((chunkBytes == nodeBytes)
		 || ((chunkBytes + (allocationUnit())) < nodeBytes));
		nextFreeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk);

		/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
		storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, parent, nextFreeChunk);
		if (nextFreeChunk) {
			storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, parent);
		}
		if (chunkBytes != nodeBytes) {
			freeChunkWithBytesat(nodeBytes - chunkBytes, (startOfObject(chunk)) + chunkBytes);
		}
		return startOfObject(chunk);
	}
	chunk = parent;
	unlinkSolitaryFreeTreeNode(chunk);
	if (chunkBytes != nodeBytes) {
		freeChunkWithBytesat(nodeBytes - chunkBytes, (startOfObject(chunk)) + chunkBytes);
	}
	return startOfObject(chunk);
}

	/* SpurMemoryManager>>#allocatePinnedSlots: */
sqInt
allocatePinnedSlots(sqInt nSlots)
{
    sqInt obj;
    usqInt p;
    usqInt toDoLimit;

	obj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(nSlots, objectBytesForSlots(nSlots), wordIndexableFormat(), wordSizeClassIndexPun());
	if (obj) {
		assert(isPinned(obj));

		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1, addressAfter(obj)));
		toDoLimit = ((usqInt)(((obj + BaseHeaderSize) + (nSlots * BytesPerOop)) - 1));
		for (p = (((usqInt)(obj + BaseHeaderSize))); p <= toDoLimit; p += (allocationUnit())) {
			longAtput(p, 0);
		}
	}
	return obj;
}


/*	All objects are a multiple of 8 bytes in length */

	/* SpurMemoryManager>>#allocationUnit */
static sqInt
allocationUnit(void)
{
	return 8;
}


/*	we don't want to inline so we can nest that in an assertion with the
	return true so the production VM does not generate any code here, while in
	simulation, the code breaks on the assertion we want to.
 */

	/* SpurMemoryManager>>#assertInnerValidFreeObject: */
static NoDbgRegParms NeverInline sqInt
assertInnerValidFreeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    sqInt chunk;
    usqInt index;
    sqInt largeChild;
    sqInt smallChild;
    sqInt treeNode;

	assert(oopisLessThanOrEqualTo(addressAfter(objOop), GIV(endOfMemory)));
	chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, objOop);
	assert((chunk == 0)
	 || (isFreeOop(chunk)));
	if (!(isLilliputianSize(bytesInBody(objOop)))) {

		/* double linkedlist assertions */
		chunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, objOop);
		if (chunk) {
			assert(isFreeOop(chunk));
			assert(objOop == (fetchPointerofFreeChunk(freeChunkPrevIndex(), chunk)));
		}
		chunk = fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, objOop);
		index = (bytesInBody(objOop)) / (allocationUnit());
		if ((index < (numFreeLists()))
		 && ((1ULL << index) <= GIV(freeListsMask))) {
			if ((GIV(freeLists)[index]) == objOop) {
				assert(chunk == 0);
			}
		}
		else {
			/* begin freeTreeNodesDo: */
			treeNode = GIV(freeLists)[0];
			if (!treeNode) {
				goto l1;
			}
			cameFrom = -1;
			do {
				assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
				smallChild = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode);
				largeChild = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode);
				assert((smallChild == 0)
				 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
				assert((largeChild == 0)
				 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
				if (((smallChild == 0)
				 && (largeChild == 0))
				 || ((largeChild
						? cameFrom == largeChild
						: cameFrom == smallChild))) {
					if (treeNode == objOop) {
						assert(chunk == 0);
					}
					cameFrom = treeNode;
					treeNode = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, treeNode);
				}
				else {
					if ((smallChild != 0)
					 && (cameFrom != smallChild)) {
						treeNode = smallChild;
					}
					else {
						assert(largeChild != 0);
						treeNode = largeChild;
					}
					cameFrom = -1;
				}
			} while(treeNode != 0);
l1:	/* end freeTreeNodesDo: */;
		}
		if (chunk) {
			assert(isFreeOop(chunk));
			assert(objOop == (fetchPointerofFreeChunk(freeChunkNextIndex(), chunk)));
		}
	}
	if (isLargeFreeObject(objOop)) {

		/* Tree assertions */
		chunk = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, objOop);
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
		chunk = fetchPointerofFreeChunk(freeChunkSmallerIndex(), objOop);
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
		chunk = fetchPointerofFreeChunk(freeChunkLargerIndex(), objOop);
		assert((chunk == 0)
		 || ((isFreeOop(chunk))
		 && (isLargeFreeObject(chunk))));
	}
	return 1;
}


/*	Answer the appropriate become effect flags for objOop, or 0 if none.
	The effect flags determine how much work is done after the become
	in following forwarding pointers, voiding method caches, etc. */

	/* SpurMemoryManager>>#becomeEffectFlagsFor: */
static NoDbgRegParms sqInt
becomeEffectFlagsFor(sqInt objOop)
{
    sqInt hash;

	hash = 0;
	if (isPointersNonImm(objOop)) {
		if ((((hash = rawHashBitsOf(objOop))) != 0)
		 && ((classAtIndex(hash)) == objOop)) {
			return BecamePointerObjectFlag + BecameActiveClassFlag;
		}
		else {
			return BecamePointerObjectFlag;
		}
	}
	else {
		return (isCompiledMethod(objOop)
				? BecameCompiledMethodFlag
				: 0);
	}
}


/*	If this object is old, mark it as a root (because a new object
	may be stored into it). */

	/* SpurMemoryManager>>#beRootIfOld: */
void
beRootIfOld(sqInt oop)
{
	if (isOldObject(oop)) {

		/* No, oop is an old object */
		/* begin possibleRootStoreInto: */
		if (!(isRemembered(oop))) {
			remember(oop);
		}
	}
}

	/* SpurMemoryManager>>#bitsSetInFreeSpaceMaskForAllFreeLists */
static sqInt
bitsSetInFreeSpaceMaskForAllFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < (numFreeLists()); i += 1) {
		if (((GIV(freeLists)[i]) != 0)
		 && ((!((1ULL << i) & GIV(freeListsMask))))) {
			return 0;
		}
	}
	return 1;
}

	/* SpurMemoryManager>>#bridgeSize */
static sqInt
bridgeSize(void)
{
	return 2 * BaseHeaderSize;
}

	/* SpurMemoryManager>>#byteFormatForNumBytes: */
static NoDbgRegParms sqInt
byteFormatForNumBytes(sqInt numBytes)
{
	return (firstByteFormat()) + ((8 - numBytes) & (BytesPerWord - 1));
}

	/* SpurMemoryManager>>#byteFormatMask */
static sqInt
byteFormatMask(void)
{
	return 24;
}

	/* SpurMemoryManager>>#byteSizeOf: */
sqInt
byteSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numBytes;

	if (isImmediate(oop)) {
		return 0;
	}

	/* begin numBytesOf: */
	fmt = formatOf(oop);
	numBytes = numSlotsOf(oop);
	numBytes = (numBytes << (shiftForWord()));
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((fmt & 3) << 1));
	}
	return numBytes - (((fmt & 1) << 2));
}


/*	Answer the basic element size for the receiver. Answer 0 for immediates
	and CompiledCode
	(element size could be wordSize for literals or 1 for bytes, so its
	indeterminable). Answer
	wordSize for pointer objects. Otherwise answer the actual element size of
	a bits container. */

	/* SpurMemoryManager>>#bytesPerElement: */
unsigned char
bytesPerElement(sqInt oop)
{
    unsigned char byteSizes[16] =
								   {	wordSize(),  wordSize(),  wordSize(),  wordSize(),
									wordSize(),  wordSize(),  wordSize(),  0, /* forwarder */ wordSize(),
									8,
									4, 4,
									2, 2, 2, 2 };
    sqInt fmt;

	if (isImmediate(oop)) {
		return 0;
	}
	fmt = formatOf(oop);
	if (fmt >= (firstByteFormat())) {
		if (fmt >= (firstCompiledMethodFormat())) {
			return 0;
		}
		return 1;
	}
	return byteSizes[fmt];
}

	/* SpurMemoryManager>>#characterObjectOf: */
sqInt
characterObjectOf(sqInt characterCode)
{
	return ((((usqInt)(characterCode) << (numTagBits())))) + (characterTag());
}


/*	Immediate characters are unsigned */

	/* SpurMemoryManager>>#characterValueOf: */
usqInt
characterValueOf(sqInt oop)
{
	return ((((usqInt)oop))) >> (numTagBits());
}


/*	Assumes zero-based array indexing. */

	/* SpurMemoryManager>>#checkedLongAt: */
sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isInMemory(byteAddress))) {
		warning("checkedLongAt bad address");

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return longAt(byteAddress);
}

	/* SpurMemoryManager>>#checkFreeSpace: */
static NoDbgRegParms void
checkFreeSpace(sqInt gcModes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if ((gcModes > 0)
	 && (((checkForLeaks & (GCCheckFreeSpace | gcModes)) == (GCCheckFreeSpace | gcModes)))) {
	}
}

	/* SpurMemoryManager>>#checkFreeSpace:ignoring: */
static NoDbgRegParms void
checkFreeSpaceignoring(sqInt gcModes, sqInt anOopToIgnore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if ((gcModes > 0)
	 && (((checkForLeaks & (GCCheckFreeSpace | gcModes)) == (GCCheckFreeSpace | gcModes)))) {
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each (non-free)
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rememberedSet, remapBuffer and
	extraRootTable checking
	that every entry is a pointer to a header. Check that the number of roots
	is correct and that all
	rememberedSet entries have their isRemembered: flag set. Answer if all
	checks pass. */

	/* SpurMemoryManager>>#checkHeapIntegrity:classIndicesShouldBeValid: */
static NoDbgRegParms sqInt
checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedObjs, sqInt classIndicesShouldBeValid)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classOop;
    sqInt containsYoung;
    sqInt fi;
    sqInt fieldOop;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt freeListOop;
    sqInt i;
    sqInt iSqInt;
    sqInt numOnThisPage;
    sqInt numRememberedObjectsInHeap;
    sqInt obj;
    sqInt objOop;
    sqInt objStackPage;
    sqInt ok;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt ri;
    usqInt start;
    sqInt toDoLimit;
    sqInt toDoLimit1;

	ok = 1;
	numRememberedObjectsInHeap = 0;
	for (i = 0; i < (numFreeLists()); i += 1) {
		if ((freeListOop = GIV(freeLists)[i])) {
			if (isInOldSpace(freeListOop)) {
				if (heapMapAtWord(pointerForOop(freeListOop))) {
					print("leak in free list ");
					printNum(i);
					print(" to non-free ");
					printHex(freeListOop);
					eekcr();
					ok = 0;
				}
			}
			else {
				print("leak in free list ");
				printNum(i);
				print(" to out-of-bounds ");
				printHex(freeListOop);
				eekcr();
				ok = 0;
			}
		}
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l3;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (isFreeObject(objOop)) {
			print("young object ");
			printHex(objOop);
			print(" is free");
			eekcr();
			ok = 0;
		}
		else {
			if (!((!(isMarked(objOop)))
				 && (excludeUnmarkedObjs))) {
				if (isRemembered(objOop)) {
					print("young object ");
					printHex(objOop);
					print(" is remembered");
					eekcr();
					ok = 0;
				}
			}
			if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				fieldOop = fetchPointerofMaybeForwardedObject(0, objOop);
				if (isInHeapBounds(fieldOop)) {
					if (!(heapMapAtWord(pointerForOop(fieldOop)))) {
						print("object leak in forwarder ");
						printHex(objOop);
						print(" to unmapped ");
						printHex(fieldOop);
						eekcr();
						ok = 0;
					}
				}
				else {
					print("object leak in forwarder ");
					printHex(objOop);
					print(" to out-of-bounds ");
					printHex(fieldOop);
					eekcr();
					ok = 0;
				}
			}
			else {
				classOop = classOrNilAtIndex((classIndex = classIndexOf(objOop)));
				if (classIndicesShouldBeValid
				 && ((classOop == GIV(nilObj))
				 && (!(isHiddenObj(objOop))))) {
					print("object leak in ");
					printHex(objOop);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop
							? "nilObj"
							: "nil"));
					eekcr();
					ok = 0;
				}
				toDoLimit = (numPointerSlotsOf(objOop)) - 1;
				for (fi = 0; fi <= toDoLimit; fi += 1) {
					fieldOop = fetchPointerofObject(fi, objOop);
					if (isNonImmediate(fieldOop)) {
						if (isInHeapBounds(fieldOop)) {
							if (!(heapMapAtWord(pointerForOop(fieldOop)))) {
								print("object leak in ");
								printHex(objOop);
								print(" @ ");
								printNum(fi);
								print(" = ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
						}
						else {
							print("object leak in ");
							printHex(objOop);
							print(" to out-of-bounds ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l2;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l2:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l3:	/* end allNewSpaceEntitiesDo: */;

	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (isFreeObject(objOop)) {
			if (heapMapAtWord(pointerForOop(objOop))) {
				print("leak in free chunk ");
				printHex(objOop);
				print(" is mapped?! ");
				eekcr();
				ok = 0;
			}
			fieldOop = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, objOop);
			if ((fieldOop != 0)
			 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
				print("leak in free chunk ");
				printHex(objOop);
				print(" @ 0 = ");
				printHex(fieldOop);
				print(" is mapped");
				eekcr();
				ok = 0;
			}
			if (!(isLilliputianSize(bytesInBody(objOop)))) {
				fieldOop = fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, objOop);
				if ((fieldOop != 0)
				 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
					print("leak in free chunk ");
					printHex(objOop);
					print(" @ 1 = ");
					printHex(fieldOop);
					print(" is mapped");
					eekcr();
					ok = 0;
				}
			}
			if (isLargeFreeObject(objOop)) {
				for (fi = 2 /* freeChunkParentIndex */; fi <= (freeChunkLargerIndex()); fi += 1) {
					fieldOop = fetchPointerofFreeChunk(fi, objOop);
					if ((fieldOop != 0)
					 && ((heapMapAtWord(pointerForOop(fieldOop))) != 0)) {
						print("leak in free chunk ");
						printHex(objOop);
						print(" @ ");
						printNum(fi);
						print(" = ");
						printHex(fieldOop);
						print(" is mapped");
						eekcr();
						ok = 0;
					}
				}
			}
		}
		else {
			if (!(excludeUnmarkedObjs
				 && (!(isMarked(objOop))))) {
				containsYoung = 0;
				if (isRemembered(objOop)) {
					numRememberedObjectsInHeap += 1;
					if (!(isInRememberedSet(objOop))) {
						print("remembered object ");
						printHex(objOop);
						print(" is not in remembered table");
						eekcr();
						ok = 0;
					}
				}
				if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					fieldOop = fetchPointerofMaybeForwardedObject(0, objOop);
					if (isInHeapBounds(fieldOop)) {
						if (!(heapMapAtWord(pointerForOop(fieldOop)))) {
							print("object leak in forwarder ");
							printHex(objOop);
							print(" to unmapped ");
							printHex(fieldOop);
							eekcr();
							ok = 0;
						}
					}
					else {
						print("object leak in forwarder ");
						printHex(objOop);
						print(" to out-of-bounds ");
						printHex(fieldOop);
						eekcr();
						ok = 0;
					}
					if (isReallyYoung(fieldOop)) {
						containsYoung = 1;
					}
				}
				else {
					classOop = classOrNilAtIndex((classIndex = classIndexOf(objOop)));
					if (classIndicesShouldBeValid
					 && ((classOop == GIV(nilObj))
					 && (classIndex > (lastClassIndexPun())))) {
						print("object leak in ");
						printHex(objOop);
						print(" invalid class index ");
						printHex(classIndex);
						print(" -> ");
						print((classOop
								? "nilObj"
								: "nil"));
						eekcr();
						ok = 0;
					}
					toDoLimit1 = (numPointerSlotsOf(objOop)) - 1;
					for (fi = 0; fi <= toDoLimit1; fi += 1) {
						fieldOop = fetchPointerofObject(fi, objOop);
						if (isNonImmediate(fieldOop)) {
							if (isInHeapBounds(fieldOop)) {
								if (!(heapMapAtWord(pointerForOop(fieldOop)))) {
									print("object leak in ");
									printHex(objOop);
									print(" @ ");
									printNum(fi);
									print(" = ");
									printHex(fieldOop);
									eekcr();
									ok = 0;
								}
							}
							else {
								print("object leak in ");
								printHex(objOop);
								print(" to out-of-bounds ");
								printHex(fieldOop);
								eekcr();
								ok = 0;
							}
							if (isReallyYoung(fieldOop)) {
								containsYoung = 1;
							}
						}
					}
				}
				if (containsYoung) {
					if (!(isRemembered(objOop))) {
						print("unremembered object ");
						printHex(objOop);
						print(" contains young oop(s)");
						eekcr();
						ok = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l4;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l4:	/* end objectAfter:limit: */;
	}
	if (numRememberedObjectsInHeap != GIV(rememberedSetSize)) {
		print("root count mismatch. #heap roots ");
		printNum(numRememberedObjectsInHeap);
		print("; #roots ");
		printNum(GIV(rememberedSetSize));
		eekcr();
		flag("no support for remembered set overflow yet");
	}

	/* begin rememberedSetWithIndexDo: */
	for (iSqInt = 0; iSqInt < GIV(rememberedSetSize); iSqInt += 1) {
		obj = GIV(rememberedSet)[iSqInt];
		if (obj & (BytesPerWord - 1)) {
			print("misaligned oop in remembered set @ ");
			printNum(iSqInt);
			print(" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if (heapMapAtWord(pointerForOop(obj))) {
				if (isYoung(obj)) {
					print("non-root in remembered set @ ");
					printNum(iSqInt);
					print(" = ");
					printHex(obj);
					eekcr();
					ok = 0;
				}
			}
			else {
				print("object leak in remembered set @ ");
				printNum(iSqInt);
				print(" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}

	/* begin objStack:do: */
	if (GIV(mournQueue) == GIV(nilObj)) {
		goto l1;
	}
	eassert(isValidObjStack(GIV(mournQueue)));
	objStackPage = GIV(mournQueue);
	while (objStackPage != 0) {
		numOnThisPage = fetchPointerofObject(ObjStackTopx, objStackPage);
		for (iSqInt = ((numOnThisPage + ObjStackFixedSlots) - 1); iSqInt >= ObjStackFixedSlots; iSqInt += -1) {
			obj = fetchPointerofObject(iSqInt, objStackPage);
			if (obj & (BytesPerWord - 1)) {
				print("misaligned oop in mournQueue @ ");
				printNum(iSqInt);
				print(" in ");
				printHex(objStackPage);
				print(" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
			else {
				if (!(excludeUnmarkedObjs
					 && (!(isMarked(obj))))) {
					if (!(heapMapAtWord(pointerForOop(obj)))) {
						print("object leak in mournQueue @ ");
						printNum(iSqInt);
						print(" in ");
						printHex(objStackPage);
						print(" = ");
						printHex(obj);
						eekcr();
						ok = 0;
					}
				}
			}
		}
		objStackPage = fetchPointerofObject(ObjStackNextx, objStackPage);
	}
l1:	/* end objStack:do: */;
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if (obj & (BytesPerWord - 1)) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if (!(heapMapAtWord(pointerForOop(obj)))) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if (obj & (BytesPerWord - 1)) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			eekcr();
			ok = 0;
		}
		else {
			if (!(heapMapAtWord(pointerForOop(obj)))) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				eekcr();
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */
/*	useful for debugging */

	/* SpurMemoryManager>>#checkOkayOop: */
sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */
	if (isImmediate(oop)) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		print("oop ");
		printHex(oop);
		print(" is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		print("oop ");
		printHex(oop);
		print(" size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = classIndexOf(oop))) >= (firstClassIndexPun()))) {
		print("oop ");
		printHex(oop);
		print(" is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		print("oop ");
		printHex(oop);
		print(" header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = formatOf(oop);
	if ((fmt == 6) || (fmt == 8)) {
		print("oop ");
		printHex(oop);
		print(" has an unknown format type");
		return 0;
	}
	if ((fmt == (forwardedFormat())) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		print("oop ");
		printHex(oop);
		print(" has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1U << (classIndexFieldWidth())) | (1ULL << ((identityHashFieldWidth()) + 32));
	if ((long64At(oop)) & unusedBits) {
		print("oop ");
		printHex(oop);
		print(" has some unused header bits set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = newSpaceRefCountMask();
	if ((longAt(oop)) & unusedBitsInYoungObjects) {
		print("oop ");
		printHex(oop);
		print(" has some header bits unused in young objects set; should be zero");
		return 0;
	}
	return 1;
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */
/*	useful for debugging */

	/* SpurMemoryManager>>#checkOopHasOkayClass: */
sqInt
checkOopHasOkayClass(usqInt obj)
{
    usqInt objClass;
    sqInt objFormat;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) (fetchClassOfNonImm(obj)));
	if (isImmediate(objClass)) {
		print("obj ");
		printHex(obj);
		print(" an immediate is not a valid class or behavior");
		cr();
		return 0;
	}
	if (!(okayOop(objClass))) {
		print("obj ");
		printHex(obj);
		print(" class obj is not ok");
		cr();
		return 0;
	}
	if (!((isPointersNonImm(objClass))
		 && ((numSlotsOf(objClass)) >= 3))) {
		print("obj ");
		printHex(obj);
		print(" a class (behavior) must be a pointers object of size >= 3");
		cr();
		return 0;
	}
	objFormat = (isBytes(obj)
				? (((formatOf(obj)) | 7) - 7)
				: formatOf(obj));
	if ((instSpecOfClass(objClass)) != objFormat) {
		print("obj ");
		printHex(obj);
		print(" and its class (behavior) formats differ");
		cr();
		return 0;
	}
	return 1;
}

	/* SpurMemoryManager>>#classAlien */
static sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassAlien, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classArray */
sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassArray, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classAtIndex: */
sqInt
classAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask()))
	 || ((classIndex >= (arrayClassIndexPun()))
	 && (classIndex <= (classIndexMask())))));
	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}

	/* SpurMemoryManager>>#classBitmap */
static sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassBitmap, GIV(specialObjectsOop));
}


/*	a.k.a. self fetchPointer: ClassByteArrayCompactIndex ofObject:
	classTableFirstPage 
 */

	/* SpurMemoryManager>>#classByteArray */
static sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassByteArray, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classCharacter */
static sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassCharacter, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classDoubleByteArray */
static sqInt
classDoubleByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;

	/* begin accessIntegerClass:withValidationFlag: */
	hash = 0;
	classOop = fetchPointerofObject(ClassDoubleByteArray, GIV(specialObjectsOop));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassDoubleByteArrayFlag) != 0)) {
		return classOop;
	}
	if ((isImmediate(classOop))
	 || ((((hash = rawHashBitsOf(classOop))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassDoubleByteArrayFlag;
	return classOop;
}

	/* SpurMemoryManager>>#classDoubleWordArray */
static sqInt
classDoubleWordArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;

	/* begin accessIntegerClass:withValidationFlag: */
	hash = 0;
	classOop = fetchPointerofObject(ClassDoubleWordArray, GIV(specialObjectsOop));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassDoubleWordArrayFlag) != 0)) {
		return classOop;
	}
	if ((isImmediate(classOop))
	 || ((((hash = rawHashBitsOf(classOop))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassDoubleWordArrayFlag;
	return classOop;
}

	/* SpurMemoryManager>>#classExternalAddress */
static sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalAddress, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalData */
static sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalData, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalFunction */
static sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalFunction, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalLibrary */
static sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalLibrary, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classExternalStructure */
static sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassExternalStructure, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classFloat */
static sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassFloat, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classFloat32Array */
static sqInt
classFloat32Array(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}

	/* SpurMemoryManager>>#classFloat64Array */
static sqInt
classFloat64Array(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	No need to check this; classAtIndex: has a stricter assert:
	self assert: classIndex ~= self isForwardedObjectClassIndexPun. */

	/* SpurMemoryManager>>#classForClassTag: */
static NoDbgRegParms sqInt
classForClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	/* begin classAtIndex: */
	assert((classIndex >= 0)
	 && ((classIndex <= (tagMask()))
	 || ((classIndex >= (arrayClassIndexPun()))
	 && (classIndex <= (classIndexMask())))));
	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}


/*	22-bit class mask => ~ 4M classes */

	/* SpurMemoryManager>>#classIndexFieldWidth */
static sqInt
classIndexFieldWidth(void)
{
	return 22;
}


/*	Answer objOop's classIndex from the object header.
	A note on performance:
	This routine uses longAt:, which does a 32-bit load on the 32-bit system,
	and a 64-bit load
	on the 64-bit system. Since the only 64-bit implementation(s) is/are
	little-endian, and
	since all of isGrey,isPinned,isRemembered,format,isUmmutable and
	classIndex fit within
	the least significant 32-bits we could use long32At: to access these, in
	the hope that the
	32-bit access will be quicker on 64-bits by virtue of fetching half the
	bits. But experiments
	show that doing this does not produce any increase; at least any signal is
	lost in the noise. */

	/* SpurMemoryManager>>#classIndexOf: */
sqInt
classIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & (classIndexMask());
}

	/* SpurMemoryManager>>#classLargeNegativeInteger */
static sqInt
classLargeNegativeInteger(void)
{
	return knownClassAtIndex(ClassLargeNegativeIntegerCompactIndex);
}

	/* SpurMemoryManager>>#classLargePositiveInteger */
static sqInt
classLargePositiveInteger(void)
{
	return knownClassAtIndex(ClassLargePositiveIntegerCompactIndex);
}

	/* SpurMemoryManager>>#classOrNilAtIndex: */
sqInt
classOrNilAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return GIV(nilObj);
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}

	/* SpurMemoryManager>>#classPoint */
static sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassPoint, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classSemaphore */
static sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassSemaphore, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classSmallInteger */
sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassSmallInteger, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classString */
static sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassByteString, GIV(specialObjectsOop));
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTableMinorIndexMask */

	/* SpurMemoryManager>>#classTableMinorIndexMask */
sqInt
classTableMinorIndexMask(void)
{
	return (1U << (classTableMajorIndexShift())) - 1;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTablePageSize */

	/* SpurMemoryManager>>#classTablePageSize */
sqInt
classTablePageSize(void)
{
	return 1U << (classTableMajorIndexShift());
}


/*	For Cogit & bootstrap */

	/* SpurMemoryManager>>#classTableRootObj */
sqInt
classTableRootObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	Answer the number of slots for class table pages in the hidden root
	object. 
 */

	/* SpurMemoryManager>>#classTableRootSlots */
static sqInt
classTableRootSlots(void)
{
	return 1U << ((classIndexFieldWidth()) - (classTableMajorIndexShift()));
}


/*	Answer the classObj's identityHash to use as a tag in the first-level
	method lookup cache.
 */

	/* SpurMemoryManager>>#classTagForClass: */
sqInt
classTagForClass(sqInt classObj)
{
    sqInt err;
    sqInt hash;

	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	flag("todo");
	return ((hash = rawHashBitsOf(classObj))
			? hash
			: (objCouldBeClassObj(classObj)
					? ((err = enterIntoClassTable(classObj))
							? -err
							: rawHashBitsOf(classObj))
					: -PrimErrBadReceiver));
}

	/* SpurMemoryManager>>#classUnsafeAlien */
static sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(ClassUnsafeAlien, GIV(specialObjectsOop));
}

	/* SpurMemoryManager>>#classWordArray */
static sqInt
classWordArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOop;
    sqInt hash;

	/* begin accessIntegerClass:withValidationFlag: */
	hash = 0;
	classOop = fetchPointerofObject(ClassWordArray, GIV(specialObjectsOop));
	if (((GIV(validatedIntegerClassFlags) & ValidatedClassWordArrayFlag) != 0)) {
		return classOop;
	}
	if ((isImmediate(classOop))
	 || ((((hash = rawHashBitsOf(classOop))) == 0)
	 || ((classAtIndex(hash)) != classOop))) {
		return GIV(nilObj);
	}
	GIV(validatedIntegerClassFlags) = GIV(validatedIntegerClassFlags) | ValidatedClassWordArrayFlag;
	return classOop;
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

	/* SpurMemoryManager>>#clearLeakMapAndMapAccessibleObjects */
static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	clearHeapMap();

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(obj);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(obj)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			heapMapAtWordPut(pointerForOop(obj), 1);
		}
		prevPrevObj = prevObj;
		prevObj = obj;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(obj, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
}

	/* SpurMemoryManager>>#cloneInOldSpace:forPinning: */
static NoDbgRegParms sqInt
cloneInOldSpaceforPinning(sqInt objOop, sqInt forPinning)
{
    sqInt fmt;
    sqInt hash;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt numSlots;
    sqInt oop;

	numSlots = numSlotsOf(objOop);
	fmt = formatOf(objOop);
	if (forPinning) {
		newObj = allocateSlotsForPinningInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), fmt, classIndexOf(objOop));
	}
	else {
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), fmt, classIndexOf(objOop));
	}
	if (!newObj) {
		return 0;
	}
	if (isPointersFormat(fmt)) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = fetchPointerofObject(i, objOop);
			if ((isNonImmediate(oop))
			 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
				oop = followForwarded(oop);
			}
			if ((isNonImmediate(oop))
			 && (isYoungObject(oop))) {
				hasYoung = 1;
			}
			storePointerUncheckedofObjectwithValue(i, newObj, oop);
		}
		if (hasYoung) {
			remember(newObj);
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			storePointerUncheckedofObjectwithValue(i, newObj, fetchPointerofObject(i, objOop));
		}
		if (fmt >= (firstCompiledMethodFormat())) {
			if ((isYoungObject(objOop))
			 || (isRemembered(objOop))) {
				remember(newObj);
			}
		}
	}
	if ((hash = rawHashBitsOf(objOop))) {
		setHashBitsOfto(newObj, hash);
	}
	if (
#  if IMMUTABILITY
		isImmutable(objOop)
#  else
		0
#  endif
		) {
		setIsImmutableOfto(newObj, 1);
	}
	return newObj;
}

	/* SpurMemoryManager>>#cloneObject: */
static NoDbgRegParms sqInt
cloneObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    usqInt newObjUsqInt;
    usqInt numBytes;
    usqInt numSlots;
    sqInt oop;

	numSlots = numSlotsOf(objOop);
	fmt = formatOf(objOop);
	if (numSlots > (maxSlotsForNewSpaceAlloc())) {
		classIndex = classIndexOf(objOop);

		/* begin allocateSlotsInOldSpace:format:classIndex: */
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), fmt, classIndex);
	}
	else {
		classIndex = classIndexOf(objOop);

		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if (((numSlots) >> 56) > 0) {
				newObj = null;
				goto l1;
			}
			newObjUsqInt = GIV(freeStart) + BaseHeaderSize;
			numBytes = largeObjectBytesForSlots(numSlots);
		}
		else {
			newObjUsqInt = GIV(freeStart);
			numBytes = smallObjectBytesForSlots(numSlots);
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, fmt, classIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
			longAtput(newObjUsqInt, ((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift()))) + ((((usqInt)(fmt) << (formatShift()))))) + classIndex);
		}
		else {
			longAtput(newObjUsqInt, ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(fmt) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObjUsqInt % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObjUsqInt;
l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (newObj) {
		if (isPointersFormat(fmt)) {
			hasYoung = 0;
			for (i = 0; i < numSlots; i += 1) {
				oop = fetchPointerofObject(i, objOop);
				if (isNonImmediate(oop)) {
					if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
						oop = followForwarded(oop);
					}
					if ((isNonImmediate(oop))
					 && (isYoungObject(oop))) {
						hasYoung = 1;
					}
				}
				storePointerUncheckedofObjectwithValue(i, newObj, oop);
			}
			if (hasYoung
			 && (!(isYoungObject(newObj)))) {
				remember(newObj);
			}
		}
		else {
			for (i = 0; i < numSlots; i += 1) {
				storePointerUncheckedofObjectwithValue(i, newObj, fetchPointerofObject(i, objOop));
			}
			if (fmt >= (firstCompiledMethodFormat())) {
				if ((isOldObject(newObj))
				 && ((isYoungObject(objOop))
				 || (isRemembered(objOop)))) {
					remember(newObj);
				}
			}
		}
	}
	return newObj;
}

	/* SpurMemoryManager>>#compactIndexOfClass: */
static NoDbgRegParms sqInt
compactIndexOfClass(sqInt objOop)
{
	assert((rawHashBitsOf(objOop)) != 0);
	return rawHashBitsOf(objOop);
}

	/* SpurMemoryManager>>#computeFreeSpacePostSwizzle */
static void
computeFreeSpacePostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(totalFreeOldSpace) = totalFreeListBytes();
	checkFreeSpace(0);
}


/*	print the count of marked and unmarked objects.
	In addition if 1 is set in printFlags, short-print marked objects,
	and/or if 2 is set, short-print unmarked obejcts. */
/*	useful for debugging */

	/* SpurMemoryManager>>#countMarkedAndUnmarkdObjects: */
void
countMarkedAndUnmarkdObjects(sqInt printFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt nm;
    sqInt nu;
    sqInt obj;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	nm = (nu = 0);

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(obj);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(obj)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if (isMarked(obj)) {
				nm += 1;
				if (((printFlags & 1) != 0)) {
					shortPrintOop(obj);
				}
			}
			else {
				nu += 1;
				if (((printFlags & 2) != 0)) {
					shortPrintOop(obj);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(obj, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
	print("n marked: ");
	printNum(nm);
	cr();
	print("n unmarked: ");
	printNum(nu);
	cr();
}


/*	Compute the used size of the class table before swizzling. Needed to
	initialize the classTableBitmap which is populated during adjustAllOopsBy: */

	/* SpurMemoryManager>>#countNumClassPagesPreSwizzle: */
static NoDbgRegParms void
countNumClassPagesPreSwizzle(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTableRoot;
    sqInt firstObj;
    sqInt i;
    sqInt nilObjPreSwizzle;

	/* a.k.a. nilObj */
	/* first five objects are nilObj, falseObj, trueObj, freeListsObj, hiddenRootsObj */
	firstObj = objectStartingAt(GIV(oldSpaceStart));
	classTableRoot = oldSpaceObjectAfter(oldSpaceObjectAfter(oldSpaceObjectAfter(oldSpaceObjectAfter(firstObj))));
	nilObjPreSwizzle = GIV(oldSpaceStart) - bytesToShift;
	GIV(numClassTablePages) = numSlotsOf(classTableRoot);
	assert(GIV(numClassTablePages) == ((classTableRootSlots()) + (hiddenRootSlots())));
	for (i = 2; i < GIV(numClassTablePages); i += 1) {
		if ((fetchPointerofObject(i, classTableRoot)) == nilObjPreSwizzle) {
			GIV(numClassTablePages) = i;
			return;
		}
	}
}

	/* SpurMemoryManager>>#displayObject */
static sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(TheDisplay, GIV(specialObjectsOop));
}


/*	Reduce the number of indexable fields in objOop, a pointer object, to
	nSlots. Convert the
	unused residual to a free chunk. Without changes to
	numSlotsForShortening:toIndexableSize: this only works for arrayFormat and
	longFormat objects.
	Answer the number of bytes returned to free memory, which may be zero if
	no change
	was possible. */

	/* SpurMemoryManager>>#doShorten:toIndexableSize: */
static NoDbgRegParms sqInt
doShortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytesBefore;
    sqInt classIndex;
    sqInt copy;
    sqInt delta;
    usqInt followingAddress;
    sqInt format;
    sqInt freeChunk;
    sqInt i;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;

	/* for assert checking */
	followingAddress = addressAfter(objOop);
	assert(oopisLessThanOrEqualTo(followingAddress, GIV(endOfMemory)));

	/* numSlotsForShortening:toIndexableSize: */
	switch (formatOf(objOop)) {
	case arrayFormat():
		numSlots = indexableSize;
		break;
	case firstLongFormat():
	case (firstLongFormat()) + 1:
		numSlots = numSlotsForBytes(indexableSize * 4);
		break;
	default:
		assertf("invalid format for shortening");
		numSlots = 0;
	}
	bytesBefore = bytesInBody(objOop);

	/* Since the system rounds objects up to 64-bits, losing a 32-bit
	   slot may not actually change the bytes occupied by the object. */
	delta = bytesBefore - (objectBytesForSlots(numSlots));
	if (!delta) {
		if (hasOverflowHeader(objOop)) {
			/* begin rawOverflowSlotsOf:put: */
			longAtput(objOop - BaseHeaderSize, ((((usqInt)((numSlotsMask())) << 56))) + numSlots);
		}
		else {
			/* rawNumSlotsOf:put: */
			byteAtput(objOop + 7, numSlots);
		}
		updateFormatOfShortenedObjectto(objOop, indexableSize);
		return 0;
	}
	if ((delta <= (allocationUnit()))
	 && (isOldObject(objOop))) {
		format = normalisedFormatForindexableSize(objOop, indexableSize);
		classIndex = classIndexOf(objOop);

		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			if ((((usqInt)(numSlots)) >> 56) > 0) {
				copy = null;
				goto l1;
			}
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes = largeObjectBytesForSlots(numSlots);
		}
		else {
			newObj = GIV(freeStart);
			numBytes = smallObjectBytesForSlots(numSlots);
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			copy = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, format, classIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */
			flag("endianness");
			longAtput(GIV(freeStart), ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
			longAtput(newObj, ((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift()))) + ((((usqInt)(format) << (formatShift()))))) + classIndex);
		}
		else {
			longAtput(newObj, ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(format) << (formatShift()))))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		copy = newObj;
l1:	/* end allocateSlots:format:classIndex: */;
		if (!copy) {
			error("shorten:toIndexableSize: attempted to shorten by allocationUnit and failed to allocate space for copy!");
		}
		if (isPureBitsFormat(format)) {
			memcpy(firstIndexableField(copy), firstIndexableField(objOop), numBytesOfBitsformat(copy, format));
		}
		else {
			for (i = 0; i < numSlots; i += 1) {
				storePointerUncheckedofObjectwithValue(i, copy, fetchPointerofObject(i, objOop));
			}
		}
		if (isRemembered(objOop)) {
			remember(copy);
		}
		forwardto(objOop, copy);
		return 0;
	}
	if (hasOverflowHeader(objOop)) {
		/* begin rawOverflowSlotsOf:put: */
		longAtput(objOop - BaseHeaderSize, ((((usqInt)((numSlotsMask())) << 56))) + numSlots);
		if (numSlots <= 1) {
			if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
				/* rawNumSlotsOf:put: */
				byteAtput(objOop + 7, numSlots);
				hackSlimBridgeToat(objOop, objOop - (allocationUnit()));
			}
		}
	}
	else {
		assert(numSlots < (numSlotsMask()));

		/* rawNumSlotsOf:put: */
		byteAtput(objOop + 7, numSlots);
	}
	delta = followingAddress - (addressAfter(objOop));
	assert((delta >= (allocationUnit()))
	 && ((delta % (allocationUnit())) == 0));
	if (delta == (allocationUnit())) {
		assert(!((isOldObject(objOop))));
		delta = 0;
		if (followingAddress == GIV(freeStart)) {
			GIV(freeStart) = addressAfter(objOop);
		}
		else {
			hackSlimBridgeToat(followingAddress, addressAfter(objOop));
		}
	}
	else {
		freeChunk = initFreeChunkWithBytesat(delta, addressAfter(objOop));
		assert((objectAfter(objOop)) == freeChunk);
		assert((addressAfter(freeChunk)) == followingAddress);
		if (isInOldSpace(objOop)) {
			GIV(totalFreeOldSpace) += delta;
			addToFreeListbytes(freeChunk, delta);
		}
		else {
			delta = 0;
			setClassIndexOfto(freeChunk, wordSizeClassIndexPun());
			setFormatOfto(freeChunk, firstLongFormat());
		}
	}
	setFormatOfto(objOop, normalisedFormatForindexableSize(objOop, indexableSize));
	return delta;
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

	/* SpurMemoryManager>>#eeInstantiateClassIndex:format:numSlots: */
usqInt
eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt newObj;
    usqInt numBytes;

	assert((numSlots >= 0)
	 && ((knownClassIndex != 0)
	 && ((knownClassAtIndex(knownClassIndex)) != GIV(nilObj))));
	assert(((objFormat < (firstByteFormat())
			? objFormat
			: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));

	/* begin allocateNewSpaceSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		if (numSlots > 0xFFFFFFFFU) {
			return null;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = largeObjectBytesForSlots(numSlots);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = smallObjectBytesForSlots(numSlots);
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if ((GIV(freeStart) + numBytes) > (((GIV(eden)).limit))) {
			error("no room in eden for allocateNewSpaceSlots:format:classIndex:");
			return 0;
		}
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, ((sqInt)((usqInt)((numSlotsMask())) << (numSlotsHalfShift()))));
		long64Atput(newObj, ((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift()))) + ((((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
	}
	else {
		long64Atput(newObj, ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(objFormat) << (formatShift()))))) + knownClassIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}


/*	We use bridges to stitch segments together to make it appear that the heap
	is one contiguous space.
	Bridges at the end of oldSpace segments are maintained. Bridges at the end
	of pastSpace and eden
	are temporary, and are established here, depending on the current sizes of
	pastSpace end eden.
	
	N.B. this introduces complications. Either or both pastSpace and eden may
	be empty, so the 
	bridge from pastSpace may skip eden. pastSpace may be full, so there may
	be no bridge at
	the end of pastSpace. Most difficult, pastSpace could be one 64-bit word
	short of full, but normal
	bridges are two word objects. To make this work we introduce a hack,
	objectAfterMaybeSlimBridge:limit:, which uses a fake overflow slot count
	to get to the start of the next object, which is either one or two
	words away, depending on whether the first object in eden has a normal or
	an overflow header. */

	/* SpurMemoryManager>>#enableObjectEnumerationFrom: */
static NoDbgRegParms void
enableObjectEnumerationFrom(sqInt initialObject)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (oopisLessThan(initialObject, GIV(oldSpaceStart))) {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			/* begin bridgeEdenAndOldSpace */
			initSegmentBridgeWithBytesat(GIV(oldSpaceStart) - GIV(freeStart), GIV(freeStart));
			if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

				/* past space can be entirely full (!!) */
				if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

					/* No room for a full bridge (!!); use the slim bridge hack */
					hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
					assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
				}
				else {

					/* Room for a regular bridge; this is straight-forward */
					initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
				}
			}
		}
		else {

			/* If eden is empty (e.g. at snapshot time), skip it entirely */
			/* begin bridgePastSpaceAndOldSpace */
			initSegmentBridgeWithBytesat(GIV(oldSpaceStart) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such as
	the markStack or the ephemeronQueue. It is a linked list of segments,
	with the hot end at the head of the list. It is a word object. The stack
	pointer is in ObjStackTopx and 0 means empty. The list goes through
	ObjStackNextx. We don't want to shrink objStacks, since they're used
	in GC and its good to keep their memory around. So unused pages
	created by popping emptying pages are kept on the ObjStackFreex list. */

	/* SpurMemoryManager>>#ensureRoomOnObjStackAt: */
static NoDbgRegParms sqInt
ensureRoomOnObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt formatField;
    sqInt freeOrNewPage;
    sqInt stackOrNil;

	stackOrNil = fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj));
	if ((stackOrNil == GIV(nilObj))
	 || ((fetchPointerofObject(ObjStackTopx, stackOrNil)) >= ObjStackLimit)) {
		freeOrNewPage = (stackOrNil == GIV(nilObj)
					? 0
					: fetchPointerofObject(ObjStackFreex, stackOrNil));
		if (freeOrNewPage) {

			/* the free page list is always on the new page. */
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
			longAtput((stackOrNil + BaseHeaderSize) + ((((usqInt)(ObjStackFreex) << (shiftForWord())))), 0);
			assert((!GIV(marking))
			 || (isMarked(freeOrNewPage)));
		}
		else {
			formatField = wordIndexableFormat();
			classIndex = wordSizeClassIndexPun();

			/* begin allocateSlotsInOldSpace:format:classIndex: */
			freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, objectBytesForSlots(ObjStackPageSlots), formatField, classIndex);
			if (!freeOrNewPage) {

				/* Allocate a new segment an retry. This is very uncommon. But it happened to me (Clement). */
				growOldSpaceByAtLeast(ObjStackPageSlots * BytesPerOop);
				formatField = wordIndexableFormat();
				classIndex = wordSizeClassIndexPun();

				/* begin allocateSlotsInOldSpace:format:classIndex: */
				freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, objectBytesForSlots(ObjStackPageSlots), formatField, classIndex);
				if (!freeOrNewPage) {
					error("no memory to allocate or extend obj stack");
				}
			}

			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
			longAtput((freeOrNewPage + BaseHeaderSize) + ((((usqInt)(ObjStackFreex) << (shiftForWord())))), 0);
			if (GIV(marking)) {
				setIsMarkedOfto(freeOrNewPage, 1);
			}
		}

		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + ((((usqInt)(ObjStackMyx) << (shiftForWord())))), objStackRootIndex);

		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + ((((usqInt)(ObjStackNextx) << (shiftForWord())))), (stackOrNil == GIV(nilObj)
				? 0
				: stackOrNil));

		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		longAtput((freeOrNewPage + BaseHeaderSize) + ((((usqInt)(ObjStackTopx) << (shiftForWord())))), 0);
		storePointerofObjectwithValue(objStackRootIndex, GIV(hiddenRootsObj), freeOrNewPage);
		assert(isValidObjStackAt(objStackRootIndex));
		stackOrNil = updateRootOfObjStackAtwith(objStackRootIndex, freeOrNewPage);
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return stackOrNil;
}


/*	Enter aBehavior into the class table and answer 0. Otherwise answer a
	primitive failure code. */

	/* SpurMemoryManager>>#enterIntoClassTable: */
static NoDbgRegParms sqInt
enterIntoClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt initialMajorIndex;
    sqInt majorIndex;
    sqInt minorIndex;
    sqInt numSlots;
    sqInt numSlotsSqInt;
    usqInt p;
    sqInt page;
    sqInt toDoLimit;
    usqInt toDoLimitUsqInt;

	majorIndex = ((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift());

	/* classTableIndex should never index the first page; it's reserved for known classes */
	initialMajorIndex = majorIndex;
	assert(initialMajorIndex > 0);
	minorIndex = GIV(classTableIndex) & (classTableMinorIndexMask());
	while (1) {
		page = fetchPointerofObject(majorIndex, GIV(hiddenRootsObj));
		if (page == GIV(nilObj)) {
			numSlots = classTablePageSize();

			/* begin allocateSlotsInOldSpace:format:classIndex: */
			page = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, objectBytesForSlots(numSlots), arrayFormat(), arrayClassIndexPun());
			if (!page) {
				return PrimErrNoMemory;
			}
			numSlotsSqInt = classTablePageSize();

			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((page + BaseHeaderSize) + (numSlotsSqInt * BytesPerOop)) - 1, addressAfter(page)));
			toDoLimitUsqInt = ((usqInt)(((page + BaseHeaderSize) + (numSlotsSqInt * BytesPerOop)) - 1));
			for (p = (((usqInt)(page + BaseHeaderSize))); p <= toDoLimitUsqInt; p += (allocationUnit())) {
				longAtput(p, GIV(nilObj));
			}
			storePointerofObjectwithValue(majorIndex, GIV(hiddenRootsObj), page);
			GIV(numClassTablePages) += 1;
			minorIndex = 0;
		}
		toDoLimit = (classTablePageSize()) - 1;
		for (i = minorIndex; i <= toDoLimit; i += 1) {
			if ((fetchPointerofObject(i, page)) == GIV(nilObj)) {
				/* classTableIndex must never index the first page, which is reserved for classes known to the VM. */
				GIV(classTableIndex) = ((((usqInt)(majorIndex) << (classTableMajorIndexShift())))) + i;
				assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
				storePointerofObjectwithValue(i, page, aBehavior);
				setHashBitsOfto(aBehavior, GIV(classTableIndex));
				assert((classAtIndex(rawHashBitsOf(aBehavior))) == aBehavior);
				return 0;
			}
		}
		majorIndex = ((((majorIndex + 1) & (classIndexMask())) < 1) ? 1 : ((majorIndex + 1) & (classIndexMask())));
		if (majorIndex == initialMajorIndex) {

			/* wrapped; table full */
			return PrimErrLimitExceeded;
		}
	}
	return 0;
}

	/* SpurMemoryManager>>#ephemeronFormat */
static sqInt
ephemeronFormat(void)
{
	return 5;
}

	/* SpurMemoryManager>>#falseObject */
sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}

	/* SpurMemoryManager>>#fetchByte:ofObject: */
sqInt
fetchByteofObject(sqInt byteIndex, sqInt objOop)
{
	return byteAt((objOop + BaseHeaderSize) + byteIndex);
}

	/* SpurMemoryManager>>#fetchClassOfNonImm: */
static NoDbgRegParms NeverInline sqInt
fetchClassOfNonImm(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = classIndexOf(objOop);
	if (classIndex <= (classIsItselfClassIndexPun())) {
		if (classIndex == (classIsItselfClassIndexPun())) {
			return objOop;
		}
		if (classIndex == (isForwardedObjectClassIndexPun())) {
			return GIV(nilObj);
		}
	}
	assert(classIndex >= (arrayClassIndexPun()));
	return classOrNilAtIndex(classIndex);
}

	/* SpurMemoryManager>>#fetchClassOf: */
static NoDbgRegParms sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt tagBits;

	return ((tagBits = oop & (tagMask()))
			? fetchPointerofObject(tagBits, GIV(classTableFirstPage))
			: fetchClassOfNonImm(oop));
}


/*	In Spur an object's classIndex is the tag in all method caches. */

	/* SpurMemoryManager>>#fetchClassTagOfNonImm: */
static NoDbgRegParms sqInt
fetchClassTagOfNonImm(sqInt obj)
{
	return classIndexOf(obj);
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

	/* SpurMemoryManager>>#fetchLong32:ofObject: */
int
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << 2))));
}

	/* SpurMemoryManager>>#fetchLong64:ofObject: */
static NoDbgRegParms sqLong
fetchLong64ofObject(sqInt longIndex, sqInt objOop)
{
	return long64At((objOop + BaseHeaderSize) + ((((usqInt)(longIndex) << 3))));
}

	/* SpurMemoryManager>>#fetchPointer:ofFreeChunk: */
static NoDbgRegParms sqInt
fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchPointer:ofMaybeForwardedObject: */
static NoDbgRegParms sqInt
fetchPointerofMaybeForwardedObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchPointer:ofObject: */
sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))));
}

	/* SpurMemoryManager>>#fetchShort16:ofObject: */
static NoDbgRegParms sqInt
fetchShort16ofObject(sqInt shortIndex, sqInt objOop)
{
	return shortAt((objOop + BaseHeaderSize) + ((((usqInt)(shortIndex) << 1))));
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */
/*	useful for debugging */

	/* SpurMemoryManager>>#findStringBeginningWith: */
void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	aCStringStrlen = strlen(aCString);

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if (objectbeginsWithStringofSize(objSqInt, aCString, aCStringStrlen)) {
				printHex(objSqInt);

				/* begin space */
				printChar(' ');
				printNum(lengthOf(objSqInt));

				/* begin space */
				printChar(' ');
				printOopShortInner(objSqInt);
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

	/* SpurMemoryManager>>#findString: */
void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aCStringStrlen;
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	aCStringStrlen = strlen(aCString);

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if (objectequalsStringofSize(objSqInt, aCString, aCStringStrlen)) {
				printHex(objSqInt);

				/* begin space */
				printChar(' ');
				printOopShortInner(objSqInt);
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}

	/* SpurMemoryManager>>#firstFixedField: */
static NoDbgRegParms void *
firstFixedField(sqInt objOop)
{
	return pointerForOop(objOop + BaseHeaderSize);
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes.
	There are only two important cases, both for objects with named inst vars,
	i.e. formats 2,3 & 5.
	The first indexable field for formats 2 & 5 is the slot count (by
	convention, even though that's off the end
	of the object). For 3 we must go to the class. */

	/* SpurMemoryManager>>#firstIndexableField: */
static NoDbgRegParms void *
firstIndexableField(sqInt objOop)
{
    sqInt classFormat;
    sqInt classPointer;
    sqInt fmt;

	fmt = formatOf(objOop);
	if (fmt <= (weakArrayFormat())) {
		if (fmt == (arrayFormat())) {

			/* array starts at 0. */
			return pointerForOop(objOop + BaseHeaderSize);
		}
		if (fmt >= (indexablePointersFormat())) {

			/* indexable with inst vars; need to delve into the class format word */
			classPointer = fetchClassOfNonImm(objOop);

			/* begin formatOfClass: */
			classFormat = ((fetchPointerofObject(InstanceSpecificationIndex, classPointer)) >> 3);
			return pointerForOop((objOop + BaseHeaderSize) + ((((usqInt)((fixedFieldsOfClassFormat(classFormat))) << (shiftForWord())))));
		}
		return 0;
	}
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 && (fmt < (firstCompiledMethodFormat()))) {
		return pointerForOop(objOop + BaseHeaderSize);
	}
	return 0;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormatMask */
sqInt
fixedFieldsOfClassFormatMask(void)
{
	return (1U << (fixedFieldsFieldWidth())) - 1;
}

	/* SpurMemoryManager>>#fixedFieldsOfClassFormat: */
sqInt
fixedFieldsOfClassFormat(sqInt classFormat)
{
	return classFormat & (fixedFieldsOfClassFormatMask());
}

	/* SpurMemoryManager>>#fixedFieldsOfClass: */
static NoDbgRegParms sqInt
fixedFieldsOfClass(sqInt objOop)
{
	return fixedFieldsOfClassFormat(((fetchPointerofObject(InstanceSpecificationIndex, objOop)) >> 3));
}

	/* SpurMemoryManager>>#fixedFieldsOf:format:length: */
static NoDbgRegParms sqInt
fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength)
{
    sqInt class;


	/* N.B. written to fall through to fetchClassOfNonImm: et al for forwarders
	   so as to trigger an assert fail. */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == (arrayFormat()))) {
		return 0;
	}
	if (fmt < (arrayFormat())) {
		return wordLength;
	}
	class = fetchClassOfNonImm(objOop);
	return fixedFieldsOfClassFormat(((fetchPointerofObject(InstanceSpecificationIndex, class)) >> 3));
}


/*	Private helper for followField:ofObject: to avoid code duplication for
	rare case.
 */

	/* SpurMemoryManager>>#fixFollowedField:ofObject:withInitialValue: */
static NoDbgRegParms NeverInline sqInt
fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue)
{
    sqInt objOop;

	assert(isOopForwarded(initialValue));
	objOop = initialValue;
	do {
		objOop = fetchPointerofMaybeForwardedObject(0, objOop);
	} while(isOopForwarded(objOop));
	storePointerofObjectwithValue(fieldIndex, anObject, objOop);
	return objOop;
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

	/* SpurMemoryManager>>#followField:ofObject: */
static NoDbgRegParms sqInt
followFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = fetchPointerofObject(fieldIndex, anObject);
	if (isOopForwarded(objOop)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}


/*	Follow pointers in the object to depth.
	Answer if any forwarders were found.
	How to avoid cyclic structures?? A temporary mark bit? eem 6/22/2020 no
	need since depth is always finite. */

	/* SpurMemoryManager>>#followForwardedObjectFields:toDepth: */
static NoDbgRegParms sqInt
followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt found;
    sqInt header;
    sqInt i;
    usqInt numLiterals;
    usqInt numSlots;
    sqInt oop;
    sqInt sp;

	found = 0;
	assert((isPointers(objOop))
	 || (isOopCompiledMethod(objOop)));

	/* begin numPointerSlotsOf: */
	fmt = formatOf(objOop);
	if (fmt <= (lastPointerFormat())) {
		if ((fmt == (indexablePointersFormat()))
		 && ((classIndexOf(objOop)) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = fetchPointerofObject(StackPointerIndex, objOop);
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
l1:	/* end fetchStackPointerOf: */;
			numSlots = CtxtTempFrameStart + contextSize;
			goto l2;
		}
		numSlots = numSlotsOf(objOop);
		goto l2;
	}
	if (fmt == (forwardedFormat())) {
		numSlots = 1;
		goto l2;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		numSlots = 0;
		goto l2;
	}
	header = methodHeaderOf(objOop);

	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	numSlots = numLiterals + LiteralStart;
l2:	/* end numPointerSlotsOf: */;
	for (i = 0; i < numSlots; i += 1) {
		oop = fetchPointerofObject(i, objOop);
		if (isNonImmediate(oop)) {
			if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
				found = 1;
				oop = followForwarded(oop);
				storePointerofObjectwithValue(i, objOop, oop);
			}
			if ((depth > 0)
			 && ((/* hasPointerFields: */
				(isNonImmediate(oop))
			 && (hasPointerFieldsNonImm(oop)))
			 && (followForwardedObjectFieldstoDepth(oop, depth - 1)))) {
				found = 1;
			}
		}
	}
	return found;
}


/*	Follow a forwarding pointer. This must be a loop because we cannot prevent
	forwarders to
	forwarders being created by lazy become. Consider the following example by
	Igor Stasenko:
	array := { a. b. c }.
	- array at: 1 points to &a. array at: 2 points to &b. array at: 3 points
	to &c
	a becomeForward: b
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	b becomeForward: c.
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	- when accessing array first one has to follow a forwarding chain:
	&a -> &b -> c */

	/* SpurMemoryManager>>#followForwarded: */
sqInt
followForwarded(sqInt objOop)
{
    sqInt referent;

	assert(isUnambiguouslyForwarder(objOop));
	referent = fetchPointerofMaybeForwardedObject(0, objOop);
	while (isOopForwarded(referent)) {
		referent = fetchPointerofMaybeForwardedObject(0, referent);
	}
	return referent;
}

	/* SpurMemoryManager>>#followMaybeForwarded: */
static NoDbgRegParms sqInt
followMaybeForwarded(sqInt objOop)
{
	return (isOopForwarded(objOop)
			? followForwarded(objOop)
			: objOop);
}


/*	Make sure the obj at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) obj at
	fieldIndex.  */

	/* SpurMemoryManager>>#followObjField:ofObject: */
static NoDbgRegParms sqInt
followObjFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = fetchPointerofObject(fieldIndex, anObject);
	assert(isNonImmediate(objOop));
	if ((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}

	/* SpurMemoryManager>>#followSpecialObjectsOop */
static void
followSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((!((longAt(GIV(specialObjectsOop))) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		GIV(validatedIntegerClassFlags) = 0;
		GIV(specialObjectsOop) = followForwarded(GIV(specialObjectsOop));
	}
	followForwardedObjectFieldstoDepth(GIV(specialObjectsOop), 0);
}

	/* SpurMemoryManager>>#formatOfClass: */
sqInt
formatOfClass(sqInt classPointer)
{
	return ((fetchPointerofObject(InstanceSpecificationIndex, classPointer)) >> 3);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 64-bit indexable
	10 - 11 32-bit indexable	(11 unused in 32 bits)
	12 - 15 16-bit indexable	(14 & 15 unused in 32-bits)
	16 - 23 byte indexable		(20-23 unused in 32-bits)
	24 - 31 compiled method	(28-31 unused in 32-bits) */
/*	A note on performance. Since the format field is, by design, aligned on a
	byte boundary
	in the fourth byte of the header we could access it via
	^(self byteAt: objOop + 3) bitAnd: self formatMask
	but al least on e.g. Core i7 x86-64 using the clang 6 compiler, this makes
	no difference,
	or at least any change is in the noise. */

	/* SpurMemoryManager>>#formatOf: */
static NoDbgRegParms sqInt
formatOf(sqInt objOop)
{
	return (((usqInt)((longAt(objOop)))) >> (formatShift())) & (formatMask());
}


/*	A special format used by the GC to follow only the first pointer. */

	/* SpurMemoryManager>>#forwardedFormat */
static sqInt
forwardedFormat(void)
{
	return 7;
}

	/* SpurMemoryManager>>#forward:to: */
static NoDbgRegParms void
forwardto(sqInt obj1, sqInt obj2)
{
    sqInt format;

	format = forwardedFormat();

	/* begin set:classIndexTo:formatTo: */
	assert((((isForwardedObjectClassIndexPun()) >= 0) && ((isForwardedObjectClassIndexPun()) <= (classIndexMask()))));
	assert(((format >= 0) && (format <= (formatMask()))));
	longAtput(obj1, ((longAt(obj1)) & (~(usqIntptr_t)(((((usqInt)((formatMask())) << (formatShift())))) + (classIndexMask())))) + ((isForwardedObjectClassIndexPun()) + ((((usqInt)(format) << (formatShift()))))));
#  if IMMUTABILITY
	setIsImmutableOfto(obj1, 0);
#  endif

	storePointerofForwarderwithValue(0, obj1, obj2);
	if (!(byteAt(obj1 + 7))) {
		/* rawNumSlotsOf:put: */
		byteAtput(obj1 + 7, 1);
	}
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkLargerIndex */
static sqInt
freeChunkLargerIndex(void)
{
	return 4;
}


/*	for linking objecs on each free list, or, during pigCompact, doubly-
	linking the free objects in address order using the xor link hack. */

	/* SpurMemoryManager>>#freeChunkNextIndex */
static sqInt
freeChunkNextIndex(void)
{
	return 0;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkParentIndex */
static sqInt
freeChunkParentIndex(void)
{
	return 2;
}


/*	For linking objecs on each free list, doubly-linking the free objects.
	Free chunks of size 1 do not have a prev index. */

	/* SpurMemoryManager>>#freeChunkPrevIndex */
static sqInt
freeChunkPrevIndex(void)
{
	return 1;
}


/*	for organizing the tree of large free chunks. */

	/* SpurMemoryManager>>#freeChunkSmallerIndex */
static sqInt
freeChunkSmallerIndex(void)
{
	return 3;
}

	/* SpurMemoryManager>>#freeChunkWithBytes:at: */
static NoDbgRegParms sqInt
freeChunkWithBytesat(sqInt bytes, sqInt address)
{
    sqInt freeChunk;

	assert(isInOldSpace(address));
	assert((segmentContainingObj(address)) == (segmentContainingObj(address + bytes)));
	freeChunk = initFreeChunkWithBytesat(bytes, address);
	addToFreeListbytes(freeChunk, bytes);
	assert(freeChunk == (objectStartingAt(address)));
	return freeChunk;
}


/*	Free an object in oldSpace. Coalesce if possible to reduce fragmentation. */

	/* SpurMemoryManager>>#freeObject: */
sqInt
freeObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt bytes;
    usqInt chunkBytes;
    sqInt next;
    usqInt start;

	assert(isInOldSpace(objOop));
	if (isRemembered(objOop)) {
		forgetObject(objOop);
	}
	bytes = bytesInBody(objOop);
	start = startOfObject(objOop);
	next = objectStartingAt(start + bytes);
	if (isFreeObject(next)) {
		/* begin detachFreeObject: */
		chunkBytes = bytesInBody(next);
		GIV(totalFreeOldSpace) -= chunkBytes;
		unlinkFreeChunkchunkBytes(next, chunkBytes);
		bytes += bytesInBody(next);
	}
	GIV(totalFreeOldSpace) += bytes;
	return freeChunkWithBytesat(bytes, start);
}

	/* SpurMemoryManager>>#hasOverflowHeader: */
static NoDbgRegParms int
hasOverflowHeader(sqInt objOop)
{
	return (byteAt(objOop + 7)) == (numSlotsMask());
}

	/* SpurMemoryManager>>#hasPointerFieldsNonImm: */
static NoDbgRegParms sqInt
hasPointerFieldsNonImm(sqInt oop)
{
    sqInt format;

	format = formatOf(oop);

	/* begin isAnyPointerFormat: */
	return (format <= (lastPointerFormat()))
	 || (format >= (firstCompiledMethodFormat()));
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,isExtraAligned})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#headerForSlots:format:classIndex: */
usqLong
headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{
	return ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + classIndex;
}


/*	Answer the number of extra root slots in the root of the hidden root
	object. 
 */

	/* SpurMemoryManager>>#hiddenRootSlots */
static sqInt
hiddenRootSlots(void)
{
	return 8;
}

	/* SpurMemoryManager>>#identityHashFieldWidth */
static sqInt
identityHashFieldWidth(void)
{
	return 22;
}


/*	mask the immutable bit in the base header word */

	/* SpurMemoryManager>>#immutableBitMask */
#if IMMUTABILITY
sqInt
immutableBitMask(void)
{
	return 1U << (immutableBitShift());
}
#endif /* IMMUTABILITY */


/*	Part of reorderReversedTreeList:. Switch treeNode with newNode in
	the tree, but do nothing to the list linked through freeChunkNextIndex. */

	/* SpurMemoryManager>>#inFreeTreeReplace:with: */
static NoDbgRegParms void
inFreeTreeReplacewith(sqInt treeNode, sqInt newNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt relative;

	storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, newNode, 0);
	for (i = 2 /* freeChunkParentIndex */; i <= (freeChunkLargerIndex()); i += 1) {
		relative = fetchPointerofFreeChunk(i, treeNode);
		if (i == 2 /* freeChunkParentIndex */) {
			if (relative) {

				/* replace link from parent to treeNode with link to newNode. */
				storePointerofFreeChunkwithValue((treeNode == (fetchPointerofFreeChunk(freeChunkSmallerIndex(), relative))
						? freeChunkSmallerIndex()
						: freeChunkLargerIndex()), relative, newNode);
			}
			else {

				/* update root to point to newNode */
				assert((GIV(freeLists)[0]) == treeNode);
				GIV(freeLists)[0] = newNode;
			}
		}
		else {
			if (relative) {
				assert((fetchPointerofFreeChunk(freeChunkParentIndex(), relative)) == treeNode);
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, relative, newNode);
			}
		}
		storePointerofFreeChunkwithValue(i, newNode, relative);
		storePointerofFreeChunkwithValue(i, treeNode, 0);
	}
}

	/* SpurMemoryManager>>#initFreeTreeChunk:bytes: */
static NoDbgRegParms void
initFreeTreeChunkbytes(sqInt freeChunk, sqInt chunkBytes)
{
	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInBody(freeChunk)));
	assert(chunkBytes >= ((numFreeLists()) * (allocationUnit())));
	storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, freeChunk, 0);
	storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, freeChunk, 0);
	storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, freeChunk, 0);
	storePointerofFreeChunkwithValue(freeChunkSmallerIndex(), freeChunk, 0);
	storePointerofFreeChunkwithValue(freeChunkLargerIndex(), freeChunk, 0);
}


/*	Reinitialize the free list info. The freeLists object needs to be swizzled
	because its neither a free, nor a pointer object. Free objects have
	already been swizzled in adjustAllOopsBy: */

	/* SpurMemoryManager>>#initializeFreeSpacePostLoad: */
static NoDbgRegParms void
initializeFreeSpacePostLoad(sqInt freeListObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert((numSlotsOf(freeListObj)) == (numFreeLists()));
	assert((formatOf(freeListObj)) == (wordIndexableFormat()));
	GIV(freeLists) = firstIndexableField(freeListObj);
	GIV(freeListsMask) = 0;
	for (i = 0; i < (numFreeLists()); i += 1) {
		if (GIV(freeLists)[i]) {
			GIV(freeListsMask) = GIV(freeListsMask) | (1ULL << i);
			GIV(freeLists)[i] = (swizzleObjin(GIV(freeLists)[i], freeListObj));
		}
	}
}

	/* SpurMemoryManager>>#initializeNewSpaceVariables */
static NeverInline void
initializeNewSpaceVariables(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(freeStart) = ((GIV(eden)).start);
	GIV(pastSpaceStart) = ((GIV(pastSpace)).start);
	GIV(scavengeThreshold) = ((((GIV(eden)).limit)) - ((((GIV(eden).limit)) - ((GIV(eden).start))) / 64));
	GIV(newSpaceStart) = (((((GIV(pastSpace)).start)) < (((GIV(futureSpace)).start))) ? (((GIV(pastSpace)).start)) : (((GIV(futureSpace)).start)));
	assert(GIV(newSpaceStart) < (((GIV(eden)).start)));
}


/*	Initialize object memory variables at startup time. Assume endOfMemory at
	al are
	initialised by the image-reading code via
	setHeapBase:memoryLimit:endOfMemory:. endOfMemory is assumed to point to
	the end of the last object in the image.
	Assume: image reader also initializes the following variables:
	specialObjectsOop
	lastHash */
/*	Catch mis-initializations leading to bad translations to C */

	/* SpurMemoryManager>>#initializeObjectMemory: */
static NoDbgRegParms void
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeListObj;

	assert(BaseHeaderSize == BaseHeaderSize);
	assert((((sqInt)((maxSlotsForAlloc()) * BytesPerWord))) > 0);
	initSegmentBridgeWithBytesat(bridgeSize(), GIV(endOfMemory) - (bridgeSize()));
	adjustSegmentSwizzlesBy(bytesToShift);
	adjustAllOopsBy(bytesToShift);

	/* heavily used special objects */
	GIV(specialObjectsOop) = swizzleObj(GIV(specialObjectsOop));
	GIV(nilObj) = fetchPointerofObject(NilObject, GIV(specialObjectsOop));
	GIV(falseObj) = fetchPointerofObject(FalseObject, GIV(specialObjectsOop));

	/* In Cog we insist that nil, true & false are next to each other (Cogit generates tighter
	   conditional branch code as a result).  In addition, Spur places the free lists and
	   class table root page immediately following them. */
	GIV(trueObj) = fetchPointerofObject(TrueObject, GIV(specialObjectsOop));
	assert(GIV(nilObj) == GIV(oldSpaceStart));
	assert(GIV(falseObj) == (oldSpaceObjectAfter(GIV(nilObj))));
	assert(GIV(trueObj) == (oldSpaceObjectAfter(GIV(falseObj))));
	freeListObj = oldSpaceObjectAfter(GIV(trueObj));
	setHiddenRootsObj(oldSpaceObjectAfter(freeListObj));
	GIV(markStack) = swizzleObjStackAt(MarkStackRootIndex);
	GIV(weaklingStack) = swizzleObjStackAt(WeaklingStackRootIndex);
	GIV(mournQueue) = swizzleObjStackAt(MournQueueRootIndex);
	assert(validObjStacks());
	assert(isEmptyObjStack(GIV(markStack)));
	assert(isEmptyObjStack(GIV(weaklingStack)));
	initializeFreeSpacePostLoad(freeListObj);
	collapseSegmentsPostSwizzle();
	updateFreeLists();
	computeFreeSpacePostSwizzle();
	initializeOldSpaceFirstFree(GIV(freeOldSpaceStart));
	initializeNewSpaceVariables();
	initializeRememberedSet();
	checkSegments();

	/* begin biasForGC */
	GIV(biasForGC) = 1;

	/* headroom when growing */
	GIV(growHeadroom) = 0x1000000;

	/* free space before shrinking */
	GIV(shrinkThreshold) = 0x2000000;
	GIV(heapSizeAtPreviousGC) = (totalOldSpaceCapacity()) - GIV(totalFreeOldSpace);
	GIV(oldSpaceUsePriorToScavenge) = (totalOldSpaceCapacity()) - GIV(totalFreeOldSpace);

	/* By default GC after scavenge if heap has grown by a third since the last GC */
	GIV(heapGrowthToSizeGCRatio) = 0.333333;
}

	/* SpurMemoryManager>>#initializeOldSpaceFirstFree: */
static NoDbgRegParms void
initializeOldSpaceFirstFree(usqInt startOfFreeOldSpace)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;
    usqInt freeOldStart;
    usqInt limit;

	limit = GIV(endOfMemory) - (bridgeSize());
	if (limit > startOfFreeOldSpace) {
		GIV(totalFreeOldSpace) += limit - startOfFreeOldSpace;
		freeOldStart = startOfFreeOldSpace;
		while ((limit - freeOldStart) >= (0x100000000LL)) {
			freeChunk = freeChunkWithBytesat(0x100000000LL, freeOldStart);
			freeOldStart += 0x100000000LL;
			assert(freeOldStart == (addressAfter(freeChunk)));
		}
		if (freeOldStart < limit) {
			freeChunk = freeChunkWithBytesat(limit - freeOldStart, freeOldStart);
			assert((addressAfter(freeChunk)) == limit);
		}
	}
	GIV(endOfMemory) -= bridgeSize();
	GIV(freeOldSpaceStart) = GIV(endOfMemory);
	checkFreeSpace(GCCheckFreeSpace);
}


/*	print free chunks in freeTree in order. */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#inOrderPrintFreeTree:printList: */
void
inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList)
{
    sqInt next;

	if ((next = fetchPointerofFreeChunk(freeChunkSmallerIndex(), freeChunk))) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
	printFreeChunkprintAsTreeNode(freeChunk, 1);
	if (printNextList) {
		next = freeChunk;
		while (((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, next))) != 0) {
			/* begin tab */
			printChar('\t');
			printFreeChunkprintAsTreeNode(next, 0);
		}
	}
	if ((next = fetchPointerofFreeChunk(freeChunkLargerIndex(), freeChunk))) {
		inOrderPrintFreeTreeprintList(next, printNextList);
	}
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

	/* SpurMemoryManager>>#instanceSizeOf: */
sqInt
instanceSizeOf(sqInt classObj)
{
	assert(addressCouldBeClassObj(classObj));
	return (((fetchPointerofObject(InstanceSpecificationIndex, classObj)) >> 3)) & (fixedFieldsOfClassFormatMask());
}

	/* SpurMemoryManager>>#instSpecOfClassFormat: */
sqInt
instSpecOfClassFormat(sqInt classFormat)
{
	return (((usqInt)(classFormat)) >> (fixedFieldsFieldWidth())) & (formatMask());
}


/*	This field in a class's format inst var corresponds to the 5-bit format
	field stored in every object header
 */

	/* SpurMemoryManager>>#instSpecOfClass: */
static NoDbgRegParms sqInt
instSpecOfClass(sqInt classPointer)
{
	return instSpecOfClassFormat(((fetchPointerofObject(InstanceSpecificationIndex, classPointer)) >> 3));
}

	/* SpurMemoryManager>>#invalidCompactClassError: */
static NoDbgRegParms void
invalidCompactClassError(const char *className)
{
	printf("\nClass %s does not have the required class index\n", className);
	exit(-1);
}


/*	Answer if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArrayNonImm: */
static NoDbgRegParms int
isArrayNonImm(sqInt oop)
{
	return (formatOf(oop)) == (arrayFormat());
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

	/* SpurMemoryManager>>#isArray: */
static NoDbgRegParms sqInt
isArray(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isArrayNonImm(oop));
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isBytesNonImm: */
static NoDbgRegParms int
isBytesNonImm(sqInt objOop)
{
	return (formatOf(objOop)) >= (firstByteFormat());
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

	/* SpurMemoryManager>>#isBytes: */
static NoDbgRegParms sqInt
isBytes(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isBytesNonImm(oop));
}

	/* SpurMemoryManager>>#isCharacterObject: */
int
isCharacterObject(sqInt oop)
{
	return ((oop & (characterTag())) != 0);
}

	/* SpurMemoryManager>>#isCharacterValue: */
int
isCharacterValue(sqInt anInteger)
{
	return isInRangeCharacterCode(anInteger);
}


/*	Answer whether the argument object is of compiled method format */

	/* SpurMemoryManager>>#isCompiledMethod: */
int
isCompiledMethod(sqInt objOop)
{
	return (formatOf(objOop)) >= (firstCompiledMethodFormat());
}

	/* SpurMemoryManager>>#isEmptyObjStack: */
static NoDbgRegParms sqInt
isEmptyObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		return 1;
	}
	eassert(isValidObjStack(objStack));
	return (0 == (fetchPointerofObject(ObjStackTopx, objStack)))
	 && (0 == (fetchPointerofObject(ObjStackNextx, objStack)));
}

	/* SpurMemoryManager>>#isEphemeron: */
static NoDbgRegParms int
isEphemeron(sqInt objOop)
{
    sqInt format;

	assert(isNonImmediate(objOop));
	format = formatOf(objOop);

	/* begin isEphemeronFormat: */
	return format == (ephemeronFormat());
}

	/* SpurMemoryManager>>#isFixedSizePointerFormat: */
sqInt
isFixedSizePointerFormat(sqInt format)
{
	return (format <= 1 /* nonIndexablePointerFormat */)
	 || (format == (ephemeronFormat()));
}


/*	Answer if objOop is that if a forwarder. Take advantage of
	isForwardedObjectClassIndexPun being a power of two to generate a more
	efficient test than the straight-forward
	(self classIndexOf: objOop) = self isForwardedObjectClassIndexPun
	at the cost of this being ambiguous with free chunks. So either never
	apply this to free chunks
	or guard with (self isFreeObject: foo) not. So far the idiom has been to
	guard with isFreeObject: */
/*	self assert: (self isFreeObject: objOop) not. */

	/* SpurMemoryManager>>#isForwarded: */
int
isForwarded(sqInt objOop)
{
	return (!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))));
}

	/* SpurMemoryManager>>#isFreeObject: */
static NoDbgRegParms int
isFreeObject(sqInt objOop)
{
	return (classIndexOf(objOop)) == (isFreeObjectClassIndexPun());
}

	/* SpurMemoryManager>>#isFreeOop: */
static NoDbgRegParms sqInt
isFreeOop(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isFreeObject(oop));
}

	/* SpurMemoryManager>>#isGrey: */
static NoDbgRegParms int
isGrey(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (greyBitShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isHiddenObj: */
static NoDbgRegParms int
isHiddenObj(sqInt objOop)
{
	return (classIndexOf(objOop)) <= (lastClassIndexPun());
}

	/* SpurMemoryManager>>#isImmediate: */
int
isImmediate(sqInt oop)
{
	return ((oop & (tagMask())) != 0);
}

	/* SpurMemoryManager>>#isImmutable: */
static NoDbgRegParms int
isImmutable(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (immutableBitShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isIndexableFormat: */
static NoDbgRegParms sqInt
isIndexableFormat(sqInt format)
{
	return (format >= (arrayFormat()))
	 && ((format <= (weakArrayFormat()))
	 || (format >= (sixtyFourBitIndexableFormat())));
}

	/* SpurMemoryManager>>#isIndexable: */
static NoDbgRegParms sqInt
isIndexable(sqInt objOop)
{
    sqInt fmt;

	fmt = formatOf(objOop);
	return isIndexableFormat(fmt);
}

	/* SpurMemoryManager>>#isInEden: */
static NoDbgRegParms sqInt
isInEden(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(objOop, ((GIV(eden)).start), GIV(freeStart));
}

	/* SpurMemoryManager>>#isInFutureSpace: */
static NoDbgRegParms sqInt
isInFutureSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, ((GIV(futureSpace)).start), GIV(futureSurvivorStart));
}


/*	Answer if the given address is within the entire range ST object memory.
	For quick checking during leak checking only! */

	/* SpurMemoryManager>>#isInHeapBounds: */
static NoDbgRegParms sqInt
isInHeapBounds(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisGreaterThanOrEqualTo(address, GIV(newSpaceStart)))
	 && (oopisLessThan(address, GIV(endOfMemory)));
}


/*	Answer if the given address is in ST object memory. */

	/* SpurMemoryManager>>#isInMemory: */
static NoDbgRegParms sqInt
isInMemory(sqInt address)
{
	if (isInNewSpace(address)) {
		return (isInEden(address))
		 || ((isInPastSpace(address))
		 || ((scavengeInProgress())
		 && (isInFutureSpace(address))));
	}
	return isInSegments(address);
}

	/* SpurMemoryManager>>#isInNewSpace: */
static NoDbgRegParms sqInt
isInNewSpace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oopisLessThan(objOop, GIV(oldSpaceStart)))
	 && (oopisGreaterThanOrEqualTo(objOop, GIV(newSpaceStart)));
}

	/* SpurMemoryManager>>#isInOldSpace: */
sqInt
isInOldSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, GIV(oldSpaceStart), GIV(endOfMemory));
}

	/* SpurMemoryManager>>#isInPastSpace: */
static NoDbgRegParms sqInt
isInPastSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return oopisGreaterThanOrEqualToandLessThan(address, ((GIV(pastSpace)).start), GIV(pastSpaceStart));
}

	/* SpurMemoryManager>>#isInRangeCharacterCode: */
static NoDbgRegParms int
isInRangeCharacterCode(sqInt characterCode)
{
	return ((characterCode >= 0) && (characterCode <= (0x3FFFFFFF)));
}


/*	Answer if the oop is a large negative integer instance. */

	/* SpurMemoryManager>>#isInstanceOfClassLargeNegativeInteger: */
static NoDbgRegParms sqInt
isInstanceOfClassLargeNegativeInteger(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassLargeNegativeIntegerCompactIndex);
}


/*	Answer if the oop is a large positive integer instance. */

	/* SpurMemoryManager>>#isInstanceOfClassLargePositiveInteger: */
static NoDbgRegParms sqInt
isInstanceOfClassLargePositiveInteger(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((classIndexOf(oop)) == ClassLargePositiveIntegerCompactIndex);
}

	/* SpurMemoryManager>>#isLargeFreeObject: */
static NoDbgRegParms int
isLargeFreeObject(sqInt objOop)
{
	return (bytesInBody(objOop)) >= ((numFreeLists()) * (allocationUnit()));
}


/*	Answer if the oop is a large positive or negative integer instance. */

	/* SpurMemoryManager>>#isLargeIntegerInstance: */
static NoDbgRegParms sqInt
isLargeIntegerInstance(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((((usqInt)((classIndexOf(oop)) - ClassLargeNegativeIntegerCompactIndex))) <= 1);
}


/*	Answer if the argument contains only indexable 64-bit double words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isLong64sNonImm: */
static NoDbgRegParms int
isLong64sNonImm(sqInt objOop)
{
	return (formatOf(objOop)) == (sixtyFourBitIndexableFormat());
}


/*	Answer if the argument contains only indexable 64-bit double words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isLong64s: */
sqInt
isLong64s(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isLong64sNonImm(oop));
}

	/* SpurMemoryManager>>#isNonImmediate: */
int
isNonImmediate(sqInt oop)
{
	return (!(oop & (tagMask())));
}

	/* SpurMemoryManager>>#isObjEphemeron: */
static NoDbgRegParms int
isObjEphemeron(sqInt objOop)
{
    sqInt format;

	format = formatOf(objOop);

	/* begin isEphemeronFormat: */
	return format == (ephemeronFormat());
}


/*	Answer if obj is old. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isOldObject: */
static NoDbgRegParms int
isOldObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisGreaterThanOrEqualTo(objOop, GIV(oldSpaceStart));
}


/*	Answer whether the oop is an object of compiled method format */

	/* SpurMemoryManager>>#isOopCompiledMethod: */
sqInt
isOopCompiledMethod(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((formatOf(oop)) >= (firstCompiledMethodFormat()));
}

	/* SpurMemoryManager>>#isOopForwarded: */
sqInt
isOopForwarded(sqInt oop)
{
	return (isNonImmediate(oop))
	 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))));
}

	/* SpurMemoryManager>>#isOopImmutable: */
sqInt
isOopImmutable(sqInt oop)
{
	return (isImmediate(oop))
	 || (isImmutable(oop));
}

	/* SpurMemoryManager>>#isOopMutable: */
sqInt
isOopMutable(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (!(isImmutable(oop)));
}

	/* SpurMemoryManager>>#isPinned: */
int
isPinned(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (pinnedBitShift())) & 1) != 0;
}

	/* SpurMemoryManager>>#isPointersFormat: */
static NoDbgRegParms int
isPointersFormat(sqInt format)
{
	return format <= (lastPointerFormat());
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointersNonImm: */
static NoDbgRegParms int
isPointersNonImm(sqInt objOop)
{
	return (formatOf(objOop)) <= (lastPointerFormat());
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

	/* SpurMemoryManager>>#isPointers: */
static NoDbgRegParms sqInt
isPointers(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isPointersNonImm(oop));
}


/*	the inverse of isAnyPointerFormat: */

	/* SpurMemoryManager>>#isPureBitsFormat: */
static NoDbgRegParms sqInt
isPureBitsFormat(sqInt format)
{
	return (format >= (sixtyFourBitIndexableFormat()))
	 && (format < (firstCompiledMethodFormat()));
}


/*	Answer if obj is young. This for compatibility with SqueakV3 where
	the GC makes all objects young during full GC. Spur doesn't do so. */

	/* SpurMemoryManager>>#isReallyYoungObject: */
int
isReallyYoungObject(sqInt obj)
{
	return isYoungObject(obj);
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isReallyYoung: */
static NoDbgRegParms sqInt
isReallyYoung(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isReallyYoungObject(oop));
}

	/* SpurMemoryManager>>#isRemembered: */
static NoDbgRegParms int
isRemembered(sqInt objOop)
{
	return ((((usqInt)((longAt(objOop)))) >> (rememberedBitShift())) & 1) != 0;
}


/*	Maybe this should be in SpurSegmentManager only */

	/* SpurMemoryManager>>#isSegmentBridge: */
static NoDbgRegParms int
isSegmentBridge(sqInt objOop)
{
	return (classIndexOf(objOop)) == (segmentBridgePun());
}


/*	Answer if the argument contains only indexable 16-bit half words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isShortsNonImm: */
static NoDbgRegParms int
isShortsNonImm(sqInt objOop)
{
	return (((formatOf(objOop)) >= (firstShortFormat())) && ((formatOf(objOop)) <= ((firstByteFormat()) - 1)));
}


/*	Answer if the argument contains only indexable 16-bit half words (no
	oops). See comment in formatOf:
 */

	/* SpurMemoryManager>>#isShorts: */
sqInt
isShorts(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isShortsNonImm(oop));
}


/*	This version is private to SpurMemoryManager (for asserts, etc). It does
	not take advantage of the power-of-two optimization in isForwarded:. */

	/* SpurMemoryManager>>#isUnambiguouslyForwarder: */
static NoDbgRegParms int
isUnambiguouslyForwarder(sqInt objOop)
{
	return (classIndexOf(objOop)) == (isForwardedObjectClassIndexPun());
}


/*	For debugging using printOopsSuchThat: */

	/* SpurMemoryManager>>#isUnmarked: */
int
isUnmarked(sqInt objOop)
{
	return !(isMarked(objOop));
}

	/* SpurMemoryManager>>#isValidClassTag: */
sqInt
isValidClassTag(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;

	assert(((classIndex >= 0) && (classIndex <= ((1U << (classIndexFieldWidth())) - 1))));
	classOrNil = classOrNilAtIndex(classIndex);
	return (classOrNil != GIV(nilObj))
	 && ((rawHashBitsOf(classOrNil)) == classIndex);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackAt: */
static NoDbgRegParms sqInt
isValidObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackOrNil;

	stackOrNil = fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj));
	return (stackOrNil == GIV(nilObj))
	 || (isValidObjStackPagemyIndexfirstPage(stackOrNil, objStackRootIndex, 1));
}


/*	Just check the page itself. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex: */
static NoDbgRegParms sqInt
isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((classIndexOf(objStackPage)) == (wordSizeClassIndexPun()))) {
		GIV(objStackInvalidBecause) = "wrong class index";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((formatOf(objStackPage)) == (wordIndexableFormat()))) {
		GIV(objStackInvalidBecause) = "wrong format";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((numSlotsOfAny(objStackPage)) == ObjStackPageSlots)) {
		GIV(objStackInvalidBecause) = "wrong num slots";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(myx == (fetchPointerofObject(ObjStackMyx, objStackPage)))) {
		GIV(objStackInvalidBecause) = "wrong myx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (GIV(marking)
	 && (!(isMarked(objStackPage)))) {
		GIV(objStackInvalidBecause) = "marking but page is unmarked";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return 1;
}


/*	Answer if the obj stack at stackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStackPage:myIndex:firstPage: */
static NoDbgRegParms sqInt
isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    sqInt page;

	if (!(isValidObjStackPagemyIndex(objStackPage, myx))) {
		return 0;
	}
	freeOrNextPage = fetchPointerofObject(ObjStackFreex, objStackPage);
	while (freeOrNextPage != 0) {
		if (!isFirstPage) {
			GIV(objStackInvalidBecause) = "free page on other than first page";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (freeOrNextPage == (fetchPointerofObject(ObjStackNextx, objStackPage))) {
			GIV(objStackInvalidBecause) = "free page = next page";
			GIV(invalidObjStackPage) = freeOrNextPage;
			return 0;
		}
		if (!(isValidObjStackPagemyIndex(freeOrNextPage, myx))) {
			GIV(objStackInvalidBecause) = stretchcat(GIV(objStackInvalidBecause), ", on next page");
			return 0;
		}
		page = fetchPointerofObject(ObjStackFreex, freeOrNextPage);
		if ((page == freeOrNextPage)
		 || (page == objStackPage)) {
			GIV(objStackInvalidBecause) = "circularity in free page list";
			GIV(invalidObjStackPage) = page;
			return 0;
		}
		freeOrNextPage = page;
	}
	if (isFirstPage) {
		if (!(((myx >= (classTableRootSlots())) && (myx <= (((classTableRootSlots()) + (hiddenRootSlots())) - 1))))) {
			GIV(objStackInvalidBecause) = "myx out of range";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (!((fetchPointerofObject(myx, GIV(hiddenRootsObj))) == objStackPage)) {
			GIV(objStackInvalidBecause) = "firstPage is not root";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
	}
	index = fetchPointerofObject(ObjStackTopx, objStackPage);
	if (!(((index >= 0) && (index <= ObjStackLimit)))) {
		GIV(objStackInvalidBecause) = "bad topx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	freeOrNextPage = fetchPointerofObject(ObjStackNextx, objStackPage);
	if (!freeOrNextPage) {
		return 1;
	}
	if (freeOrNextPage == objStackPage) {
		GIV(objStackInvalidBecause) = "circularity in objStack page list";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(freeOrNextPage, myx, 0);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

	/* SpurMemoryManager>>#isValidObjStack: */
static NoDbgRegParms sqInt
isValidObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((addressCouldBeObj(objStack))
		 && ((numSlotsOfAny(objStack)) == ObjStackPageSlots))) {
		GIV(objStackInvalidBecause) = "first page not obj or wrong size";
		GIV(invalidObjStackPage) = objStack;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), 1);
}

	/* SpurMemoryManager>>#isWeakNonImm: */
static NoDbgRegParms int
isWeakNonImm(sqInt objOop)
{
    sqInt format;

	format = formatOf(objOop);

	/* begin isWeakFormat: */
	return format == (weakArrayFormat());
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWeak: */
static NoDbgRegParms sqInt
isWeak(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWeakNonImm(oop));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytesNonImm: */
static NoDbgRegParms sqInt
isWordsOrBytesNonImm(sqInt objOop)
{
	return isPureBitsFormat(formatOf(objOop));
}


/*	Answer if the contains only indexable words or bytes (no oops). See
	comment in formatOf:
 */
/*	Note: Excludes CompiledMethods. */

	/* SpurMemoryManager>>#isWordsOrBytes: */
static NoDbgRegParms sqInt
isWordsOrBytes(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWordsOrBytesNonImm(oop));
}


/*	Answer if the argument contains only indexable 16-bit half words or 32-bit
	words (no oops).
	See comment in formatOf: */

	/* SpurMemoryManager>>#isWordsOrShortsNonImm: */
static NoDbgRegParms int
isWordsOrShortsNonImm(sqInt objOop)
{
	return (((formatOf(objOop)) >= (firstLongFormat())) && ((formatOf(objOop)) <= ((firstByteFormat()) - 1)));
}


/*	Answer if the argument contains only indexable 16-bit half words or 32-bit
	indexable words (no oops).
	See comment in formatOf: */

	/* SpurMemoryManager>>#isWordsOrShorts: */
sqInt
isWordsOrShorts(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWordsOrShortsNonImm(oop));
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

	/* SpurMemoryManager>>#isWords: */
static NoDbgRegParms sqInt
isWords(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (isWordsNonImm(oop));
}


/*	Answer if obj is young. Require that obj is non-immediate. */

	/* SpurMemoryManager>>#isYoungObject: */
int
isYoungObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return oopisLessThan(objOop, GIV(oldSpaceStart));
}


/*	Answer if oop is young. */

	/* SpurMemoryManager>>#isYoung: */
sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (isNonImmediate(oop))
	 && (oopisLessThan(oop, GIV(oldSpaceStart)));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

	/* SpurMemoryManager>>#is:instanceOf:compactClassIndex: */
static NoDbgRegParms sqInt
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if (isImmediate(oop)) {
		return 0;
	}

	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = classIndexOf(oop);
	if (compactClassIndex) {
		return compactClassIndex == ccIndex;
	}
	else {
		return classOop == (classAtIndex(ccIndex));
	}
}


/*	Answer the object the ephemeron guards. This is its first element. */

	/* SpurMemoryManager>>#keyOfEphemeron: */
static NoDbgRegParms sqInt
keyOfEphemeron(sqInt objOop)
{
	assert((isNonImmediate(objOop))
	 && (isObjEphemeron(objOop)));
	return fetchPointerofObject(0, objOop);
}

	/* SpurMemoryManager>>#knownClassAtIndex: */
static NoDbgRegParms sqInt
knownClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(((classIndex >= 1) && (classIndex <= (classTablePageSize()))));
	return fetchPointerofObject(classIndex, GIV(classTableFirstPage));
}

	/* SpurMemoryManager>>#lastPointerFormat */
static sqInt
lastPointerFormat(void)
{
	return 5;
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects.
	Does not examine the stack pointer of contexts to be sure to swizzle
	the nils that fill contexts on snapshot.
	It is invariant that on image load no object contains a forwarding
	pointer, and the image contains no forwarders (see class comment). */

	/* SpurMemoryManager>>#lastPointerOfWhileSwizzling: */
static NoDbgRegParms sqInt
lastPointerOfWhileSwizzling(sqInt objOop)
{
    sqInt fmt;
    sqInt header;

	fmt = formatOf(objOop);
	assert(fmt != (forwardedFormat()));
	if (fmt <= (lastPointerFormat())) {
		return (((numSlotsOf(objOop)) - 1) * BytesPerOop) + BaseHeaderSize;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	header = methodHeaderOf(objOop);
	return (((((/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1)),
/* literalCountOfAlternateHeader: */
	((header >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) - 1) * BytesPerOop) + BaseHeaderSize;
}

	/* SpurMemoryManager>>#leakCheckFullGC */
int
leakCheckFullGC(void)
{
	return ((checkForLeaks & GCModeFull) != 0);
}

	/* SpurMemoryManager>>#leakCheckNewSpaceGC */
int
leakCheckNewSpaceGC(void)
{
	return ((checkForLeaks & GCModeNewSpace) != 0);
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes) should
	be subtracted from the result. */

	/* SpurMemoryManager>>#lengthOf: */
static NoDbgRegParms sqInt
lengthOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numSlots;

	fmt = formatOf(objOop);

	/* begin lengthOf:format: */
	/* don't let forwarders freak us out... */
	numSlots = numSlotsOfAny(objOop);
	if (fmt <= (ephemeronFormat())) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return ((numSlots << (shiftForWord()))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return ((numSlots << ((shiftForWord()) - 1))) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return ((numSlots << ((shiftForWord()) - 2))) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}

	/* SpurMemoryManager>>#literalCountOfMethodHeader: */
usqInt
literalCountOfMethodHeader(sqInt header)
{
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}

	/* SpurMemoryManager>>#literalCountOf: */
usqInt
literalCountOf(sqInt methodPointer)
{
    sqInt header;

	header = methodHeaderOf(methodPointer);

	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	return ((header >> 3)) & AlternateHeaderNumLiteralsMask;
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintInstancesOf: */
void
longPrintInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = rawHashBitsOf(aClassOop);
	if (classIndex != (isFreeObjectClassIndexPun())) {
		longPrintInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing any and all objects whose classIndex equals the
	argument. 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintInstancesWithClassIndex: */
void
longPrintInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((classIndexOf(objOop)) == classIndex) {
			longPrintOop(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if ((classIndexOf(objOop)) == classIndex) {
			longPrintOop(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;
}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#longPrintReferencesTo: */
void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt prntObj;
    sqInt startObject;

	prntObj = 0;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if ((isPointersNonImm(objSqInt))
			 || (isCompiledMethod(objSqInt))) {
				if (isCompiledMethod(objSqInt)) {
					i = (literalCountOf(objSqInt)) + LiteralStart;
				}
				else {
					if ((classIndexOf(objSqInt)) == ClassMethodContextCompactIndex) {
						i = CtxtTempFrameStart + (fetchStackPointerOf(objSqInt));
					}
					else {
						i = numSlotsOf(objSqInt);
					}
				}
				while (((i -= 1)) >= 0) {
					if (anOop == (fetchPointerofObject(i, objSqInt))) {
						printHex(objSqInt);
						print(" @ ");
						printNum(i);
						cr();
						prntObj = 1;
						i = 0;
					}
				}
				if (prntObj) {
					prntObj = 0;
					longPrintOop(objSqInt);
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}


/*	Ensure the class of the argument is marked, pushing it on the markStack if
	not already marked.
	And for one-way become, which can create duplicate entries in the class
	table, make sure
	objOop's classIndex refers to the classObj's actual classIndex.
	Note that this is recursive, but the metaclass chain should terminate
	quickly. 
 */

	/* SpurMemoryManager>>#markAndTraceClassOf: */
static NoDbgRegParms void
markAndTraceClassOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classObj;
    sqInt objStack;
    sqInt realClassIndex;

	classIndex = classIndexOf(objOop);
	classObj = classOrNilAtIndex(classIndex);
	assert(objCouldBeClassObj(classObj));
	realClassIndex = rawHashBitsOf(classObj);
	if ((classIndex != realClassIndex)
	 && (classIndex > (lastClassIndexPun()))) {
		setClassIndexOfto(objOop, realClassIndex);
	}
	if (!(isMarked(classObj))) {
		setIsMarkedOfto(classObj, 1);
		markAndTraceClassOf(classObj);
		objStack = GIV(markStack);

		/* begin push:onObjStack: */
		assert(addressCouldBeOop(classObj));
		if (isImmediate(classObj)) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
					? fetchPointerofObject(ObjStackNextx, objStack)
					: objStack))));
		}
		else {

			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(classObj))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(classObj)));
		}
		noCheckPushonObjStack(classObj, objStack);
	}
}


/*	Mark the argument, and all objects reachable from it, and any remaining
	objects on the mark stack. Follow forwarding pointers in the scan. */
/*	if markAndTrace: is to follow and eliminate forwarding pointers
	in its scan it cannot be handed an r-value which is forwarded.
	The assert for this is in markAndShouldScan: */

	/* SpurMemoryManager>>#markAndTrace: */
NeverInline void
markAndTrace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt format;
    sqInt formatSqInt;
    sqInt header;
    sqInt index;
    usqInt numLiterals;
    usqInt numSlots;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objOopSqInt;
    sqInt objStack;
    sqInt objStack1;
    sqInt objStackSqInt;
    sqInt objToScan;
    sqInt scanLargeObject;
    sqInt sp;

	/* begin markAndShouldScan: */
	if (isImmediate(objOop)) {
		return;
	}
	assert(!(isForwarded(objOop)));
	if (isMarked(objOop)) {
		return;
	}
	setIsMarkedOfto(objOop, 1);
	format = formatOf(objOop);
	if (isPureBitsFormat(format)) {

		/* avoid pushing non-pointer objects on the markStack. */
		/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
		if ((classIndexOf(objOop)) > (lastClassIndexPun())) {
			markAndTraceClassOf(objOop);
		}
		return;
	}
	if (format == (weakArrayFormat())) {

		/* push weaklings on the weakling stack to scan later */
		objStack = GIV(weaklingStack);

		/* begin push:onObjStack: */
		assert(addressCouldBeOop(objOop));
		if (isImmediate(objOop)) {
			assert(objStack == GIV(markStack));
			assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
					? fetchPointerofObject(ObjStackNextx, objStack)
					: objStack))));
		}
		else {

			/* There should be no weaklings on the mark stack. */
			assert(!((objStack == GIV(markStack))
			 && (isWeakNonImm(objOop))));
			assert((objStack != GIV(weaklingStack))
			 || (isWeakNonImm(objOop)));
		}
		noCheckPushonObjStack(objOop, objStack);
		return;
	}
	if ((format == (ephemeronFormat()))
	 && (activeAndDeferredScan(objOop))) {
		return;
	}

	/* begin markLoopFrom: */
	numStrongSlots = 0;

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */
	objToScan = objOop;
	do {
		if (isImmediate(objToScan)) {
			scanLargeObject = 1;
		}
		else {
			/* begin numStrongSlotsOfInephemeral: */
			fmt = formatOf(objToScan);
			assert((fmt != (ephemeronFormat()))
			 || (isMarked(keyOfEphemeron(objToScan))));
			if (fmt <= (lastPointerFormat())) {
				numSlots = numSlotsOf(objToScan);
				if (fmt <= (arrayFormat())) {
					numStrongSlots = numSlots;
					goto l4;
				}
				if (fmt == (indexablePointersFormat())) {
					if ((classIndexOf(objToScan)) == ClassMethodContextCompactIndex) {
						/* begin fetchStackPointerOf: */
						sp = fetchPointerofObject(StackPointerIndex, objToScan);
						if (!((((sp) & 7) == 1))) {
							contextSize = 0;
							goto l3;
						}
						assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objToScan)));
						contextSize = (sp >> 3);
l3:	/* end fetchStackPointerOf: */;
						numStrongSlots = CtxtTempFrameStart + contextSize;
						goto l4;
					}
					numStrongSlots = numSlots;
					goto l4;
				}
				if (fmt == (weakArrayFormat())) {
					numStrongSlots = fixedFieldsOfClass(fetchClassOfNonImm(objToScan));
					goto l4;
				}
			}
			if (fmt == (forwardedFormat())) {
				numStrongSlots = 1;
				goto l4;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				numStrongSlots = 0;
				goto l4;
			}
			header = methodHeaderOf(objToScan);

			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			numStrongSlots = numLiterals + LiteralStart;
l4:	/* end numStrongSlotsOfInephemeral: */;
			scanLargeObject = numStrongSlots > (traceImmediatelySlotLimit());
		}
		if (scanLargeObject) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */
			if (isImmediate(objToScan)) {
				index = (objToScan >> 3);
				objToScan = topOfObjStack(GIV(markStack));
			}
			else {
				index = numStrongSlots;
				markAndTraceClassOf(objToScan);
			}
			while (index > 0) {
				index -= 1;
				field = fetchPointerofObject(index, objToScan);
				if (isNonImmediate(field)) {
					if ((!((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}

					/* begin markAndShouldScan: */
					if (isImmediate(field)) {
						goto l1;
					}
					assert(!(isForwarded(field)));
					if (isMarked(field)) {
						goto l1;
					}
					setIsMarkedOfto(field, 1);
					format = formatOf(field);
					if (isPureBitsFormat(format)) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if ((classIndexOf(field)) > (lastClassIndexPun())) {
							markAndTraceClassOf(field);
						}
						goto l1;
					}
					if (format == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						objStack1 = GIV(weaklingStack);

						/* begin push:onObjStack: */
						assert(addressCouldBeOop(field));
						if (isImmediate(field)) {
							assert(objStack1 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
									? fetchPointerofObject(ObjStackNextx, objStack1)
									: objStack1))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack1 == GIV(markStack))
							 && (isWeakNonImm(field))));
							assert((objStack1 != GIV(weaklingStack))
							 || (isWeakNonImm(field)));
						}
						noCheckPushonObjStack(field, objStack1);
						goto l1;
					}
					if ((format == (ephemeronFormat()))
					 && (activeAndDeferredScan(field))) {
						goto l1;
					}
					if (index > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan) {
							objStack = GIV(markStack);

							/* begin push:onObjStack: */
							assert(addressCouldBeOop(objToScan));
							if (isImmediate(objToScan)) {
								assert(objStack == GIV(markStack));
								assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
										? fetchPointerofObject(ObjStackNextx, objStack)
										: objStack))));
							}
							else {

								/* There should be no weaklings on the mark stack. */
								assert(!((objStack == GIV(markStack))
								 && (isWeakNonImm(objToScan))));
								assert((objStack != GIV(weaklingStack))
								 || (isWeakNonImm(objToScan)));
							}
							noCheckPushonObjStack(objToScan, objStack);
						}
						objOopSqInt = (((usqInt)index << 3) | 1);
						objStackSqInt = GIV(markStack);

						/* begin push:onObjStack: */
						assert(addressCouldBeOop(objOopSqInt));
						if (isImmediate(objOopSqInt)) {
							assert(objStackSqInt == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStackSqInt))
									? fetchPointerofObject(ObjStackNextx, objStackSqInt)
									: objStackSqInt))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStackSqInt == GIV(markStack))
							 && (isWeakNonImm(objOopSqInt))));
							assert((objStackSqInt != GIV(weaklingStack))
							 || (isWeakNonImm(objOopSqInt)));
						}
						noCheckPushonObjStack(objOopSqInt, objStackSqInt);
					}
					objToScan = field;
					index = -1;
l1:;
				}
			}
			if (index >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */
				objToScan = popObjStack(GIV(markStack));
				if (objToScan == objOop) {
					objToScan = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */
			index = numStrongSlots;
			markAndTraceClassOf(objToScan);
			while (index > 0) {
				index -= 1;
				field = fetchPointerofObject(index, objToScan);
				if (isNonImmediate(field)) {
					if ((!((longAt(field)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {

						/* fixFollowedField: is /not/ inlined */
						field = fixFollowedFieldofObjectwithInitialValue(index, objToScan, field);
					}

					/* begin markAndShouldScan: */
					if (isImmediate(field)) {
						goto l2;
					}
					assert(!(isForwarded(field)));
					if (isMarked(field)) {
						goto l2;
					}
					setIsMarkedOfto(field, 1);
					formatSqInt = formatOf(field);
					if (isPureBitsFormat(formatSqInt)) {

						/* avoid pushing non-pointer objects on the markStack. */
						/* Avoid tracing classes of non-objects on the heap, e.g. IRC caches, Sista counters. */
						if ((classIndexOf(field)) > (lastClassIndexPun())) {
							markAndTraceClassOf(field);
						}
						goto l2;
					}
					if (formatSqInt == (weakArrayFormat())) {

						/* push weaklings on the weakling stack to scan later */
						objStack1 = GIV(weaklingStack);

						/* begin push:onObjStack: */
						assert(addressCouldBeOop(field));
						if (isImmediate(field)) {
							assert(objStack1 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
									? fetchPointerofObject(ObjStackNextx, objStack1)
									: objStack1))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack1 == GIV(markStack))
							 && (isWeakNonImm(field))));
							assert((objStack1 != GIV(weaklingStack))
							 || (isWeakNonImm(field)));
						}
						noCheckPushonObjStack(field, objStack1);
						goto l2;
					}
					if ((formatSqInt == (ephemeronFormat()))
					 && (activeAndDeferredScan(field))) {
						goto l2;
					}
					objStack1 = GIV(markStack);

					/* begin push:onObjStack: */
					assert(addressCouldBeOop(field));
					if (isImmediate(field)) {
						assert(objStack1 == GIV(markStack));
						assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
								? fetchPointerofObject(ObjStackNextx, objStack1)
								: objStack1))));
					}
					else {

						/* There should be no weaklings on the mark stack. */
						assert(!((objStack1 == GIV(markStack))
						 && (isWeakNonImm(field))));
						assert((objStack1 != GIV(weaklingStack))
						 || (isWeakNonImm(field)));
					}
					noCheckPushonObjStack(field, objStack1);
					if (((byteAt(field + 7)) > (traceImmediatelySlotLimit()))
					 && (((numStrongSlots = numStrongSlotsOfInephemeral(field))) > (traceImmediatelySlotLimit()))) {
						objOop1 = (((usqInt)numStrongSlots << 3) | 1);
						objStack1 = GIV(markStack);

						/* begin push:onObjStack: */
						assert(addressCouldBeOop(objOop1));
						if (isImmediate(objOop1)) {
							assert(objStack1 == GIV(markStack));
							assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack1))
									? fetchPointerofObject(ObjStackNextx, objStack1)
									: objStack1))));
						}
						else {

							/* There should be no weaklings on the mark stack. */
							assert(!((objStack1 == GIV(markStack))
							 && (isWeakNonImm(objOop1))));
							assert((objStack1 != GIV(weaklingStack))
							 || (isWeakNonImm(objOop1)));
						}
						noCheckPushonObjStack(objOop1, objStack1);
					}
l2:;
				}
			}
			objToScan = popObjStack(GIV(markStack));
		}
	} while(objToScan);
}


/*	Almost entirely arbitrary, but we dont want 1Mb bitmaps allocated in eden.
	But this choice means no check for numSlots > maxSlotsForNewSpaceAlloc
	for non-variable allocations. */

	/* SpurMemoryManager>>#maxSlotsForNewSpaceAlloc */
sqInt
maxSlotsForNewSpaceAlloc(void)
{
	return fixedFieldsOfClassFormatMask();
}


/*	Answer the method header of a CompiledMethod object. */

	/* SpurMemoryManager>>#methodHeaderOf: */
static NoDbgRegParms sqInt
methodHeaderOf(sqInt methodObj)
{
	assert(isCompiledMethod(methodObj));
	return fetchPointerofObject(HeaderIndex, methodObj);
}


/*	Answer the minimum number of additional slots to allocate in an object to
	always be able to shorten it.
	This is enough slots to allocate a minimum-sized object. */

	/* SpurMemoryManager>>#minSlotsForShortening */
sqInt
minSlotsForShortening(void)
{
	return ((allocationUnit()) * 2) / BytesPerOop;
}

	/* SpurMemoryManager>>#newSpaceIsEmpty */
static sqInt
newSpaceIsEmpty(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(freeStart) == (((GIV(eden)).start)))
	 && (GIV(pastSpaceStart) == (((GIV(pastSpace)).start)));
}


/*	The three bit field { isGrey, isPinned, isRemembered } is for bits
	that are never set in young objects. This allows the remembered
	table to be pruned when full by using these bits as a reference
	count of newSpace objects from the remembered table. Objects
	with a high count should be tenured to prune the remembered table. */

	/* SpurMemoryManager>>#newSpaceRefCountMask */
static sqInt
newSpaceRefCountMask(void)
{
	return (1U << (greyBitShift())) | ((1U << (pinnedBitShift())) | (1U << (rememberedBitShift())));
}

	/* SpurMemoryManager>>#nilObject */
sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}

	/* SpurMemoryManager>>#noCheckClassAtIndex: */
static NoDbgRegParms sqInt
noCheckClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	classTablePage = fetchPointerofObject(((usqInt)(classIndex)) >> (classTableMajorIndexShift()), GIV(hiddenRootsObj));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return fetchPointerofObject(classIndex & (classTableMinorIndexMask()), classTablePage);
}


/*	Push an element on an objStack. Split from push:onObjStack: for testing. */

	/* SpurMemoryManager>>#noCheckPush:onObjStack: */
static NoDbgRegParms sqInt
noCheckPushonObjStack(sqInt objOop, sqInt objStack)
{
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = fetchPointerofObject(ObjStackTopx, objStack);
	if (topx >= ObjStackLimit) {
		noCheckPushonObjStack(objOop, ensureRoomOnObjStackAt(fetchPointerofObject(ObjStackMyx, objStack)));
	}
	else {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + ((((usqInt)((ObjStackFixedSlots + topx)) << (shiftForWord())))), objOop);

		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + ((((usqInt)(ObjStackTopx) << (shiftForWord())))), topx + 1);
	}
	return objOop;
}

	/* SpurMemoryManager>>#nonIndexablePointerFormat */
sqInt
nonIndexablePointerFormat(void)
{
	return 1;
}


/*	Answer the number of indexable bytes in the given non-immediate pure bits
	object with format.
 */

	/* SpurMemoryManager>>#numBytesOfBits:format: */
static NoDbgRegParms sqInt
numBytesOfBitsformat(sqInt objOop, sqInt format)
{
    usqInt numBytes;

	assert((isPureBitsFormat(format))
	 && ((formatOf(objOop)) == format));
	numBytes = numSlotsOf(objOop);
	numBytes = (numBytes << (shiftForWord()));
	if (format < (firstShortFormat())) {
		return (format <= (sixtyFourBitIndexableFormat())
				? numBytes
				: numBytes - (((format & 1) << 2)));
	}
	return (format < (firstByteFormat())
			? numBytes - (((format & 3) << 1))
			: numBytes - (format & 7));
}


/*	Answer the number of indexable bytes in the given non-immediate
	byte-indexable object.
 */

	/* SpurMemoryManager>>#numBytesOfBytes: */
static NoDbgRegParms sqInt
numBytesOfBytes(sqInt objOop)
{
    sqInt fmt;

	fmt = formatOf(objOop);
	assert(fmt >= (firstByteFormat()));
	return (((numSlotsOf(objOop)) << (shiftForWord()))) - (fmt & 7);
}


/*	Answer the number of indexable bytes in the given non-immediate object.
	Does not adjust the size of contexts by stackPointer. */

	/* SpurMemoryManager>>#numBytesOf: */
sqInt
numBytesOf(sqInt objOop)
{
    sqInt fmt;
    usqInt numBytes;

	fmt = formatOf(objOop);
	numBytes = numSlotsOf(objOop);
	numBytes = (numBytes << (shiftForWord()));
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */
		return numBytes - (fmt & 7);
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		return numBytes;
	}
	if (fmt >= (firstShortFormat())) {
		return numBytes - (((fmt & 3) << 1));
	}
	return numBytes - (((fmt & 1) << 2));
}


/*	Answer the number of pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numPointerSlotsOf: */
static NoDbgRegParms usqInt
numPointerSlotsOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    usqInt numLiterals;
    sqInt sp;

	fmt = formatOf(objOop);

	/* begin numPointerSlotsOf:format: */
	if (fmt <= (lastPointerFormat())) {
		if ((fmt == (indexablePointersFormat()))
		 && ((classIndexOf(objOop)) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */
			/* begin fetchStackPointerOf: */
			sp = fetchPointerofObject(StackPointerIndex, objOop);
			if (!((((sp) & 7) == 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
			contextSize = (sp >> 3);
l1:	/* end fetchStackPointerOf: */;
			return CtxtTempFrameStart + contextSize;
		}
		return numSlotsOf(objOop);
	}
	if (fmt == (forwardedFormat())) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	header = methodHeaderOf(objOop);

	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}

	/* SpurMemoryManager>>#numSlotsForBytes: */
static NoDbgRegParms sqInt
numSlotsForBytes(sqInt numBytes)
{
	return (numBytes + (BytesPerWord - 1)) / BytesPerWord;
}


/*	A private internal version of numSlotsOf: that is happy to be applied to
	free or forwarded objects.
 */

	/* SpurMemoryManager>>#numSlotsOfAny: */
static NoDbgRegParms usqInt
numSlotsOfAny(sqInt objOop)
{
    usqInt numSlots;

	numSlots = byteAt(objOop + 7);
	return (numSlots == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
}


/*	numSlotsOf: should not be applied to free or forwarded objects. */

	/* SpurMemoryManager>>#numSlotsOf: */
usqInt
numSlotsOf(sqInt objOop)
{
    usqInt numSlots;

	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	return (((numSlots = byteAt(objOop + 7))) == (numSlotsMask())
			? ((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8
			: numSlots);
}


/*	Answer the number of strong pointer fields in the given object,
	which is .expected not to be an active ephemeron.
	Works with CompiledMethods, as well as ordinary objects. */

	/* SpurMemoryManager>>#numStrongSlotsOfInephemeral: */
static NoDbgRegParms sqInt
numStrongSlotsOfInephemeral(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt header;
    usqInt numLiterals;
    usqInt numSlots;
    sqInt sp;

	fmt = formatOf(objOop);
	assert((fmt != (ephemeronFormat()))
	 || (isMarked(keyOfEphemeron(objOop))));
	if (fmt <= (lastPointerFormat())) {
		numSlots = numSlotsOf(objOop);
		if (fmt <= (arrayFormat())) {
			return numSlots;
		}
		if (fmt == (indexablePointersFormat())) {
			if ((classIndexOf(objOop)) == ClassMethodContextCompactIndex) {
				/* begin fetchStackPointerOf: */
				sp = fetchPointerofObject(StackPointerIndex, objOop);
				if (!((((sp) & 7) == 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objOop)));
				contextSize = (sp >> 3);
l1:	/* end fetchStackPointerOf: */;
				return CtxtTempFrameStart + contextSize;
			}
			return numSlots;
		}
		if (fmt == (weakArrayFormat())) {
			return fixedFieldsOfClass(fetchClassOfNonImm(objOop));
		}
	}
	if (fmt == (forwardedFormat())) {
		return 1;
	}
	if (fmt < (firstCompiledMethodFormat())) {
		return 0;
	}
	header = methodHeaderOf(objOop);

	/* begin literalCountOfMethodHeader: */
	assert((((header) & 7) == 1));
	numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
	return numLiterals + LiteralStart;
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#objectAfter: */
sqInt
objectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
		if (isInEden(objOop)) {
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				return GIV(freeStart);
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
		}
		if (isInPastSpace(objOop)) {
			/* begin objectAfter:limit: */
			followingWordAddress = addressAfter(objOop);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
				return GIV(pastSpaceStart);
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
		}

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(futureSurvivorStart))) {
			return GIV(futureSurvivorStart);
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
				? followingWordAddress + BaseHeaderSize
				: followingWordAddress);
	}

	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
}


/*	useful for debugging */

	/* SpurMemoryManager>>#objectBefore: */
sqInt
objectBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOopSqInt;
    sqInt prev;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	prev = null;
	if (oopisLessThan(objOop, GIV(oldSpaceStart))) {
		/* begin allNewSpaceEntitiesDo: */
		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
		prevPrevObj = (prevObj = null);
		assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

		/* begin startAddressForBridgedHeapEnumeration */
		if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
			start = ((GIV(pastSpace)).start);
		}
		else {
			if (GIV(freeStart) > (((GIV(eden)).start))) {
				start = ((GIV(eden)).start);
			}
			else {
				start = GIV(oldSpaceStart);
			}
		}
		if (start > GIV(freeStart)) {
			goto l2;
		}

		/* begin bridgePastSpaceAndEden */
		if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

			/* past space can be entirely full (!!) */
			if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

				/* No room for a full bridge (!!); use the slim bridge hack */
				hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
				assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
			}
			else {

				/* Room for a regular bridge; this is straight-forward */
				initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
			}
		}
		objOopSqInt = objectStartingAt(start);
		while (oopisLessThan(objOopSqInt, GIV(freeStart))) {
			if (oopisGreaterThanOrEqualTo(objOopSqInt, objOop)) {
				return prev;
			}
			prev = objOopSqInt;
			prevPrevObj = prevObj;
			prevObj = objOopSqInt;

			/* begin objectAfterMaybeSlimBridge:limit: */
			followingWordAddress = addressAfter(objOopSqInt);
			if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
				objOopSqInt = GIV(freeStart);
				goto l1;
			}
			flag("endianness");
			followingWord = longAt(followingWordAddress);
			objOopSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
						? ((oopisLessThan(objOopSqInt, GIV(oldSpaceStart)))
						 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
								? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
								: followingWordAddress + BaseHeaderSize)
						: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		}
l2:	/* end allNewSpaceEntitiesDo: */;
		return prev;
	}

	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOopSqInt = GIV(nilObj);
	while (1) {
		assert((objOopSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOopSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objOopSqInt)) != 0);
		if (oopisGreaterThanOrEqualTo(objOopSqInt, objOop)) {
			return prev;
		}
		prev = objOopSqInt;
		prevPrevObj = prevObj;
		prevObj = objOopSqInt;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOopSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOopSqInt = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOopSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For assertions only... This ends the recursion in setting up the bridged
	enumerations of new space that need objectBefore: for assertion checking. */

	/* SpurMemoryManager>>#objectInPastSpaceBefore: */
static NoDbgRegParms sqInt
objectInPastSpaceBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt obj;
    sqInt prev;

	if (GIV(pastSpaceStart) <= (((GIV(pastSpace)).start))) {
		return null;
	}
	prev = null;
	obj = objectStartingAt(((GIV(pastSpace)).start));
	while (oopisLessThan(obj, GIV(pastSpaceStart))) {
		if (oopisGreaterThanOrEqualTo(obj, objOop)) {
			return prev;
		}
		prev = obj;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(pastSpaceStart))) {
			obj = GIV(pastSpaceStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l1:	/* end objectAfter:limit: */;
	}
	return prev;
}


/*	For enumerating objects find the header of the first object in a space.
	If the object starts with an overflow size field it will start at the next
	allocationUnit. c.f. numSlotsOf: */

	/* SpurMemoryManager>>#objectStartingAt: */
static NoDbgRegParms sqInt
objectStartingAt(sqInt address)
{
    usqInt numSlots;

	numSlots = byteAt(address + 7);
	return (numSlots == (numSlotsMask())
			? address + BaseHeaderSize
			: address);
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

	/* SpurMemoryManager>>#okayOop: */
static NoDbgRegParms sqInt
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqInt oop;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;

	/* address and size checks */
	oop = ((usqInt) signedOop);
	if (isImmediate(oop)) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = classIndexOf(oop))) >= (firstClassIndexPun()))) {
		error("oop is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((byteAt(oop + 7)) == (numSlotsMask()))
	 && ((byteAt((oop - BaseHeaderSize) + 7)) != (numSlotsMask()))) {
		error("oop header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = formatOf(oop);
	if ((fmt == 6) || (fmt == 8)) {
		error("oop has an unknown format type");
		return 0;
	}
	if ((fmt == (forwardedFormat())) != (classIndex == (isForwardedObjectClassIndexPun()))) {
		error("oop has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1U << (classIndexFieldWidth())) | (1ULL << ((identityHashFieldWidth()) + 32));
	if ((long64At(oop)) & unusedBits) {
		error("some unused header bits are set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1U << (greyBitShift())) | (1U << (pinnedBitShift()))) | (1U << (rememberedBitShift()));
	if ((longAt(oop)) & unusedBitsInYoungObjects) {
		error("some header bits unused in young objects are set; should be zero");
		return 0;
	}
	return 1;
}


/*	useful for debugging */
/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

	/* SpurMemoryManager>>#oldSpaceObjectAfter: */
sqInt
oldSpaceObjectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;

	/* begin objectAfter:limit: */
	followingWordAddress = addressAfter(objOop);
	if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
		return GIV(endOfMemory);
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress);
	return ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
			? followingWordAddress + BaseHeaderSize
			: followingWordAddress);
}


/*	Attempt to pin objOop, which must not be immediate.
	If the attempt succeeds answer objOop's (possibly moved) oop.
	If the attempt fails, which can only occur if there is no memory, answer
	0.  */

	/* SpurMemoryManager>>#pinObject: */
sqInt
pinObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oldClone;
    SpurSegmentInfo *seg;

	assert(isNonImmediate(objOop));
	assert(!((isForwarded(objOop))));
	flag("policy decision here. if already old, do we clone in a segment containing pinned objects or merely pin?");
	if (isOldObject(objOop)) {
		if ((numBytesOf(objOop)) > (0x100000)) {
			setIsPinnedOfto(objOop, 1);
			return objOop;
		}
		seg = segmentContainingObj(objOop);
		if ((seg->containsPinned)) {
			setIsPinnedOfto(objOop, 1);
			return objOop;
		}
		if (!(someSegmentContainsPinned())) {
			setIsPinnedOfto(objOop, 1);
			(seg->containsPinned = 1);
			return objOop;
		}
	}
	oldClone = cloneInOldSpaceforPinning(objOop, 1);
	if (oldClone) {
		GIV(becomeEffectsFlags) = becomeEffectFlagsFor(objOop);
		setIsPinnedOfto(oldClone, 1);
		forwardto(objOop, oldClone);
		followSpecialObjectsOop();
		postBecomeScanClassTable(GIV(becomeEffectsFlags));
		GIV(becomeEffectsFlags) = 0;
	}
	return oldClone;
}

	/* SpurMemoryManager>>#popObjStack: */
static NoDbgRegParms sqInt
popObjStack(sqInt objStack)
{
    sqInt myx;
    sqInt nextPage;
    sqInt top;
    sqInt topx;

	eassert(isValidObjStack(objStack));
	topx = fetchPointerofObject(ObjStackTopx, objStack);
	if (!topx) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	topx -= 1;
	top = fetchPointerofObject(topx + ObjStackFixedSlots, objStack);

	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(objStack)) == (wordIndexableFormat()));
	longAtput((objStack + BaseHeaderSize) + ((((usqInt)(ObjStackTopx) << (shiftForWord())))), topx);
	if ((topx == 0)
	 && (((nextPage = fetchPointerofObject(ObjStackNextx, objStack))) != 0)) {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		longAtput((nextPage + BaseHeaderSize) + ((((usqInt)(ObjStackFreex) << (shiftForWord())))), objStack);

		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		longAtput((objStack + BaseHeaderSize) + ((((usqInt)(ObjStackNextx) << (shiftForWord())))), 0);
		myx = fetchPointerofObject(ObjStackMyx, objStack);
		updateRootOfObjStackAtwith(myx, nextPage);
		eassert(isValidObjStack(nextPage));
	}
	else {
		eassert(isValidObjStack(objStack));
	}
	return top;
}


/*	Pop and return the possibly remapped object from the remap buffer.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#popRemappableOop */
sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	Scan the class table post-become (iff an active class object was becommed)
	to ensure no
	forwarding pointers, and no unhashed classes exist in the class table.
	
	Note that one-way become can cause duplications in the class table.
	So if pointer objects have been becommed, scan all pages in the class
	table and eliminate ay entries that have a zero hash.
	doBecome:and:copyHash: has
	already ensured that any becomed class has been stored at the right index. */

	/* SpurMemoryManager>>#postBecomeScanClassTable: */
static NoDbgRegParms void
postBecomeScanClassTable(sqInt effectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt i;
    sqInt j;
    sqInt page;
    sqInt toDoLimit;

	assert(validClassTableRootPages());
	if (!(((effectsFlags & BecamePointerObjectFlag) != 0))) {
		return;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = fetchPointerofObject(i, GIV(hiddenRootsObj));
		assert(!(isForwarded(page)));
		toDoLimit = (numSlotsOf(page)) - 1;
		for (j = 0; j <= toDoLimit; j += 1) {
			classOrNil = fetchPointerofObject(j, page);
			if (classOrNil != GIV(nilObj)) {
				if ((!((longAt(classOrNil)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
					classOrNil = followForwarded(classOrNil);
					storePointerofObjectwithValue(j, page, classOrNil);
				}
				if (!(rawHashBitsOf(classOrNil))) {
					storePointerUncheckedofObjectwithValue(j, page, GIV(nilObj));
					if ((((((usqInt)(i) << (classTableMajorIndexShift())))) + j) < GIV(classTableIndex)) {
						GIV(classTableIndex) = ((((usqInt)(i) << (classTableMajorIndexShift())))) + j;
					}
				}
			}
		}
	}
	assert(GIV(classTableIndex) >= (1U << (classTableMajorIndexShift())));
}

	/* SpurMemoryManager>>#primitiveErrorTable */
sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(PrimitiveErrorTableIndex, GIV(specialObjectsOop));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printActivationsOf: */
void
printActivationsOf(sqInt aMethodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if (((classIndexOf(objSqInt)) == ClassMethodContextCompactIndex)
			 && (aMethodObj == (fetchPointerofObject(MethodIndex, objSqInt)))) {
				printHex(objSqInt);

				/* begin space */
				printChar(' ');
				printOopShortInner(objSqInt);
				fflush(GIV(transcript));
				print(" pc ");
				printHex(fetchPointerofObject(InstructionPointerIndex, objSqInt));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printBogons */
void
printBogons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anomaly;
    sqInt bogon;

	/* begin printTheBogons: */
	print("bogon ");
	printHexnp(bogon);
	cr();
	print("anomaly ");
	printHexnp(anomaly);
	cr();
}

	/* SpurMemoryManager>>#printBridge:on: */
static NoDbgRegParms void
printBridgeon(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a bridge hdr%d slot size %" PRIuSQINT "\n",
			((void *)oop),
			(hasOverflowHeader(oop)
			? 16
			: 8),
			numSlotsOfAny(oop));
}

	/* SpurMemoryManager>>#printCantBeObject:on: */
static NoDbgRegParms void
printCantBeObjecton(sqInt oop, FILE *aStream)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(oop & ((allocationUnit()) - 1))) {
		if ((isInNewSpace(oop))
		 && ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))) {
			printForwarderon(oop, aStream);
			return;
		}
		if (oop == (bridgeAt(GIV(numSegments) - 1))) {
			printBridgeon(oop, aStream);
			return;
		}
	}
	fprintf(aStream,
			"%p%s\n",
			((void *)oop),
			(oop & ((allocationUnit()) - 1)
			? " is misaligned"
			: whereIs(oop)));
}


/*	Scan the heap printing the oops of any and all contexts that refer to
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printContextReferencesTo: */
void
printContextReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if ((classIndexOf(objSqInt)) == ClassMethodContextCompactIndex) {
				i = CtxtTempFrameStart + (fetchStackPointerOf(objSqInt));
				while (((i -= 1)) >= 0) {
					if (anOop == (fetchPointerofObject(i, objSqInt))) {
						printHex(objSqInt);
						print(" @ ");
						printNum(i);

						/* begin space */
						printChar(' ');
						printOopShortInner(objSqInt);
						fflush(GIV(transcript));
						print(" pc ");
						printHex(fetchPointerofObject(InstructionPointerIndex, objSqInt));
						cr();
						i = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printEntity: */
void
printEntity(sqInt oop)
{
    sqInt printFlags;

	printFlags = 0;
	printHex(oop);

	/* begin space */
	printChar(' ');
	if (!(addressCouldBeObj(oop))) {
		print((isImmediate(oop)
				? "immediate"
				: "unknown"));
		return;
	}
	print((isFreeObject(oop)
			? "free"
			: (isSegmentBridge(oop)
					? "bridge"
					: ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))
							? "forwarder"
							: ((classIndexOf(oop)) <= (lastClassIndexPun())
									? ((printFlags = 1),
									"pun/obj stack")
									: ((printFlags = 1),
									"object"))))));

	/* begin space */
	printChar(' ');
	printHexnpnp(byteAt(oop + 7));
	print("/");
	printHexnpnp(bytesInBody(oop));
	print("/");
	printNum(bytesInBody(oop));
	if (printFlags) {
		/* begin space */
		printChar(' ');
		print(((formatOf(oop)) <= 15
				? "f:0"
				: "f:"));
		printHexnpnp(formatOf(oop));
		print((isGrey(oop)
				? " g"
				: " ."));
		print((isImmutable(oop)
				? "i"
				: "."));
		print((isMarked(oop)
				? "m"
				: "."));
		print((isPinned(oop)
				? "p"
				: "."));
		print((isRemembered(oop)
				? "r"
				: "."));
	}
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printForwarders */
void
printForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOopSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOopSqInt = GIV(nilObj);
	while (1) {
		assert((objOopSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOopSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objOopSqInt)) != 0);
		if (isUnambiguouslyForwarder(objOopSqInt)) {
			printHex(objOopSqInt);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOopSqInt;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOopSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOopSqInt = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOopSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOopSqInt = objectStartingAt(start);
	while (oopisLessThan(objOopSqInt, GIV(freeStart))) {
		if (isUnambiguouslyForwarder(objOopSqInt)) {
			printHex(objOopSqInt);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOopSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOopSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOopSqInt = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOopSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOopSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;
}

	/* SpurMemoryManager>>#printForwarder:on: */
static NoDbgRegParms void
printForwarderon(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a forwarded hdr%d slot size %" PRIuSQINT " object to %p\n",
			((void *)oop),
			(hasOverflowHeader(oop)
			? 16
			: 8),
			numSlotsOfAny(oop),
			((void *)(followForwarded(oop))));
}


/*	This version goes through memory, printing all free chunks.
	Other versions go through the free lists. This one will show
	all free chunks even if the free lists are corrupt. */
/*	useful for debugging */

	/* SpurMemoryManager>>#printFreeChunks */
void
printFreeChunks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt seenNewFreeChunk;
    usqInt start;

	seenNewFreeChunk = 0;

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (isFreeObject(objOop)) {
			if (!seenNewFreeChunk) {
				print("NewSpace CONTAINS FREE OBJECT(S)!!");
				cr();
				seenNewFreeChunk = 1;
			}
			printFreeChunk(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;

	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (isFreeObject(objOop)) {
			printFreeChunk(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeChunk: */
void
printFreeChunk(sqInt freeChunk)
{
	printFreeChunkprintAsTreeNode(freeChunk, 1);
}

	/* SpurMemoryManager>>#printFreeChunk:printAsTreeNode: */
static NoDbgRegParms void
printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numBytes;

	numBytes = bytesInBody(freeChunk);
	print("freeChunk ");
	printHexnp(freeChunk);
	if (printAsTreeNode) {
		print((freeChunk == (GIV(freeLists)[0])
				? " + "
				: " - "));
		printHexnp(addressAfter(freeChunk));
	}
	print(" bytes ");
	printNum(numBytes);
	print(" next ");
	printHexnp(fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk));
	if (!(isLilliputianSize(numBytes))) {
		print(" prev ");
		printHexnp(fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, freeChunk));
	}
	if ((numBytes >= ((numFreeLists()) * (allocationUnit())))
	 && (printAsTreeNode)) {
		print(" ^ ");
		printHexnp(fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, freeChunk));
		print(" < ");
		printHexnp(fetchPointerofFreeChunk(freeChunkSmallerIndex(), freeChunk));
		print(" > ");
		printHexnp(fetchPointerofFreeChunk(freeChunkLargerIndex(), freeChunk));
	}
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeListHeads */
void
printFreeListHeads(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt expectedMask;
    sqInt i;

	expectedMask = 0;
	for (i = 0; i < (numFreeLists()); i += 1) {
		printHex(GIV(freeLists)[i]);
		if (GIV(freeLists)[i]) {
			expectedMask += 1ULL << i;
		}
		if ((i + 1) % (((usqInt)(32)) >> (logBytesPerOop()))) {
			print("  ");
		}
		else {
			cr();
		}
	}
	cr();
	print("mask: ");
	printHexnp(GIV(freeListsMask));
	print(" expected: ");
	printHexnp(expectedMask);
	cr();
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeList: */
sqInt
printFreeList(sqInt chunkOrIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;

	if ((chunkOrIndex >= 0)
	 && (chunkOrIndex < (numFreeLists()))) {
		return printFreeList(GIV(freeLists)[chunkOrIndex]);
	}
	freeChunk = chunkOrIndex;
	while (freeChunk != 0) {
		printFreeChunk(freeChunk);
		freeChunk = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk);
	}
	return 0;
}

	/* SpurMemoryManager>>#printFreeObject:on: */
static NoDbgRegParms void
printFreeObjecton(sqInt oop, FILE *aStream)
{
	fprintf(aStream,
			"%p is a free chunk of size %" PRIdSQINT " 0th field:%p\n",
			((void *)oop),
			bytesInBody(oop),
			((void *)(fetchPointerofFreeChunk(0, oop))));
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printFreeTree */
void
printFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFreeTreeChunk(GIV(freeLists)[0]);
}


/*	Slang is blind-sided by the inlining of printFreeTreeChunk: into
	printFreeTree. 
 */

	/* SpurMemoryManager>>#printFreeTreeChunk: */
static NoDbgRegParms void
printFreeTreeChunk(sqInt chunkOrZero)
{
	if (chunkOrZero > 0) {
		printFreeTreeChunk(fetchPointerofFreeChunk(freeChunkSmallerIndex(), chunkOrZero));
		printFreeChunk(chunkOrZero);
		printFreeTreeChunk(fetchPointerofFreeChunk(freeChunkLargerIndex(), chunkOrZero));
	}
}


/*	useful for VM debugging */
/*	N.B. No safety bounds checks!! We need to look e.g. at corpses. */

	/* SpurMemoryManager>>#printHeaderOf: */
void
printHeaderOf(sqInt objOop)
{
	printHexnp(objOop);
	if (hasOverflowHeader(objOop)) {
		print(" hdr16 slotf ");
		printHexnp(byteAt(objOop + 7));
		print(" slotc ");
		printHexnp(((((usqInt)(((sqInt)((usqInt)((longAt(objOop - BaseHeaderSize))) << 8)))))) >> 8);

		/* begin space */
		printChar(' ');
	}
	else {
		print(" hdr8 slots ");
		printHexnp(numSlotsOfAny(objOop));
	}

	/* begin space */
	printChar(' ');
	printChar((isMarked(objOop)
			? 'M'
			: 'm'));
	printChar((isGrey(objOop)
			? 'G'
			: 'g'));
	printChar((isPinned(objOop)
			? 'P'
			: 'p'));
	printChar((isRemembered(objOop)
			? 'R'
			: 'r'));
	printChar((isImmutable(objOop)
			? 'I'
			: 'i'));
	print(" hash ");
	printHexnp(rawHashBitsOf(objOop));
	print(" fmt ");
	printHexnp(formatOf(objOop));
	print(" cidx ");
	printHexnp(classIndexOf(objOop));
	cr();
}

	/* SpurMemoryManager>>#printImmediateObject:on: */
static NoDbgRegParms void
printImmediateObjecton(sqInt oop, FILE *aStream)
{
	assert(isImmediate(oop));
	if ((((oop) & 7) == 1)) {
		fprintf(aStream,
				"%p=%" PRIdSQINT "\n",
				((void *)oop),
				((sqInt)((oop >> 3))));
	}
	if (((oop & (characterTag())) != 0)) {
		fprintf(aStream,
				"%p=$%" PRIdSQINT " ($%lc)\n",
				((void *)oop),
				((long)(characterValueOf(oop))),
				((wint_t) (characterValueOf(oop))));
	}
	if (((oop & (smallFloatTag())) != 0)) {
		fprintf(aStream,
				"%p=%g\n",
				((void *)oop),
				floatValueOf(oop));
	}
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printInstancesOf: */
void
printInstancesOf(sqInt aClassOop)
{
    sqInt classIndex;

	classIndex = rawHashBitsOf(aClassOop);
	if (classIndex != (isFreeObjectClassIndexPun())) {
		printInstancesWithClassIndex(classIndex);
	}
}


/*	Scan the heap printing the oops of any and all objects whose classIndex
	equals the argument.
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printInstancesWithClassIndex: */
void
printInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((classIndexOf(objOop)) == classIndex) {
			printHex(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if ((classIndexOf(objOop)) == classIndex) {
			printHex(objOop);
			cr();
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;
}


/*	Print the objects in the classTable that have bad hashes. */
/*	useful for debugging */

	/* SpurMemoryManager>>#printInvalidClassTableEntries */
void
printInvalidClassTableEntries(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNilSqInt;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt j;
    sqInt page;
    sqInt toDoLimit;

	hash = 0;
	if (!(validClassTableRootPages())) {
		print("class table invalid; cannot print");
		cr();
		return;
	}

	/* begin classTableEntriesDo: */
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = fetchPointerofObject(i, GIV(hiddenRootsObj));
		toDoLimit = (classTablePageSize()) - 1;
		for (j = 0; j <= toDoLimit; j += 1) {
			classOrNilSqInt = fetchPointerofObject(j, page);
			if (classOrNilSqInt != GIV(nilObj)) {
				index = ((((usqInt)(i) << (classTableMajorIndexShift())))) + j;
				if (((!((longAt(classOrNilSqInt)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
				 || ((((hash = rawHashBitsOf(classOrNilSqInt))) == 0)
				 || ((noCheckClassAtIndex(hash)) != classOrNilSqInt))) {
					print("entry ");
					printHex(index);
					print(" oop ");
					printHex(classOrNilSqInt);
					print(" hash ");
					printHex(hash);
					print(" => ");
					printHex(classAtIndex(hash));
					cr();
				}
			}
		}
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMarkedOops */
#if LLDB
void
printMarkedOops(void)
{
	printOopsSuchThat(isMarked);
}
#endif /* LLDB */


/*	Scan the heap printing the oops of any and all methods that implement
	anOop 
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMethodImplementorsOf: */
void
printMethodImplementorsOf(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if ((isCompiledMethod(objSqInt))
			 && ((maybeSelectorOfMethod(objSqInt)) == anOop)) {
				printHex(objSqInt);

				/* begin space */
				printChar(' ');
				printOopShortInner(objSqInt);
				fflush(GIV(transcript));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}


/*	Scan the heap printing the oops of any and all methods that refer to anOop */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printMethodReferencesTo: */
void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt i;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if (isCompiledMethod(objSqInt)) {
				i = ((literalCountOf(objSqInt)) + LiteralStart) - 1;
				while (((i -= 1)) >= 0) {
					if (anOop == (fetchPointerofObject(i, objSqInt))) {
						printHex(objSqInt);
						print(" @ ");
						printNum(i);

						/* begin space */
						printChar(' ');
						printOopShortInner(objSqInt);
						fflush(GIV(transcript));
						cr();
						i = 0;
					}
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}

	/* SpurMemoryManager>>#printNonPointerDataOf:on: */
static NoDbgRegParms void
printNonPointerDataOfon(sqInt oop, FILE *aStream)
{
    sqInt elementsPerLine;
    sqInt format;
    sqInt index;
    sqInt lastIndex;
    usqInt numSlots;

	format = formatOf(oop);
	assert(((format >= (sixtyFourBitIndexableFormat())) && (format <= ((firstCompiledMethodFormat()) - 1))));

	/* begin lengthOf:format: */
	/* don't let forwarders freak us out... */
	numSlots = numSlotsOfAny(oop);
	if (format <= (ephemeronFormat())) {
		lastIndex = numSlots;
		goto l1;
	}
	if (format >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		lastIndex = ((numSlots << (shiftForWord()))) - (format & 7);
		goto l1;
	}
	if (format >= (firstShortFormat())) {
		lastIndex = ((numSlots << ((shiftForWord()) - 1))) - (format & 3);
		goto l1;
	}
	if (format >= (firstLongFormat())) {
		lastIndex = ((numSlots << ((shiftForWord()) - 2))) - (format & 1);
		goto l1;
	}
	if (format == (sixtyFourBitIndexableFormat())) {
		lastIndex = numSlots;
		goto l1;
	}
	lastIndex = 0;
l1:	/* end lengthOf:format: */;
	if (!lastIndex) {
		return;
	}
	if (format == (sixtyFourBitIndexableFormat())) {
		lastIndex = ((32 < lastIndex) ? 32 : lastIndex);

		/* 0x/16r0123456789ABCDEF<space|cr> x 4 = 76/80 */
		elementsPerLine = 4;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%18" PRIXSQINT "%c",
					((usqLong) (fetchLong64ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
					? '\n'
					: ' '));
		}
		return;
	}
	if (format < (firstShortFormat())) {
		lastIndex = ((64 < lastIndex) ? 64 : lastIndex);

		/* 0x/16r12345678<space|cr> x 8 = 80/88 */
		elementsPerLine = 8;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%10p%c",
					((void *)(fetchLong32ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
					? '\n'
					: ' '));
		}
		return;
	}
	if (format < (firstByteFormat())) {
		lastIndex = ((128 < lastIndex) ? 128 : lastIndex);

		/* 0x/16r1234<space|cr> x 10 = 70/80 */
		elementsPerLine = 10;
		for (index = 1; index <= lastIndex; index += 1) {
			fprintf(aStream,
					"%6p%c",
					((void *)(fetchShort16ofObject(index - 1, oop))),
					(((index % elementsPerLine) == 0)
			 || (index == lastIndex)
					? '\n'
					: ' '));
		}
		return;
	}
	lastIndex = ((0x100 < lastIndex) ? 0x100 : lastIndex);

	/* 0x/16r12<space|cr> x 16 = 80/96 */
	elementsPerLine = 16;
	for (index = 1; index <= lastIndex; index += 1) {
		fprintf(aStream,
				"%4p%c",
				((void *)(fetchByteofObject(index - 1, oop))),
				(((index % elementsPerLine) == 0)
		 || (index == lastIndex)
				? '\n'
				: ' '));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printObjectsFrom:to: */
void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop
				? ((objectAfter(oop)) == startAddress
						? startAddress
						: oop)
				: startAddress);
	while (oopisLessThan(oop, endAddress)) {
		if (!((isFreeObject(oop))
			 || (isSegmentBridge(oop)))) {
			printOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Scan the heap printing the oops of any and all objects whose hash equals
	the argument.
 */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printObjectsWithHash: */
void
printObjectsWithHash(sqInt hash)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	/* begin allHeapEntitiesDo: */
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if ((rawHashBitsOf(objOop)) == hash) {
			shortPrintOop(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if ((rawHashBitsOf(objOop)) == hash) {
			shortPrintOop(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;
}

	/* SpurMemoryManager>>#printObjStackAndContents: */
void
printObjStackAndContents(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printObjStack:printContents: */
	if (objStack == GIV(nilObj)) {
		print("nil");
		cr();
	}
	else {
		printObjStackPagemyIndexpageTypeprintContents(objStack, fetchPointerofObject(ObjStackMyx, objStack), ObjStackMyx, 1);
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:pageType:printContents: */
static NoDbgRegParms void
printObjStackPagemyIndexpageTypeprintContents(sqInt objStackPage, sqInt myx, sqInt pageType, sqInt printContents)
{
    sqInt freeOrNextPage;
    sqInt index;
    int isFirstPage;
    int isFreePage;
    int isNextPage;
    sqInt page;

	isFirstPage = pageType == ObjStackMyx;
	isNextPage = pageType == ObjStackNextx;
	isFreePage = pageType == ObjStackFreex;
	printObjStackPagemyIndextag(objStackPage, myx, (isFirstPage
			? "head"
			: (isFreePage
					? "free"
					: "next")));
	if (isFirstPage
	 || (isNextPage)) {
		/* begin tab */
		printChar('\t');
		print("topx: ");
		printNum(fetchPointerofObject(ObjStackTopx, objStackPage));
		print(" next: ");
		printHex(fetchPointerofObject(ObjStackNextx, objStackPage));
		if (isFirstPage) {
			print(" free: ");
			printHex(fetchPointerofObject(ObjStackFreex, objStackPage));
		}
		cr();
	}
	if (isFirstPage) {
		freeOrNextPage = fetchPointerofObject(ObjStackFreex, objStackPage);
		while (freeOrNextPage != 0) {
			printObjStackPagemyIndexpageTypeprintContents(freeOrNextPage, myx, ObjStackFreex, 0);
			page = fetchPointerofObject(ObjStackFreex, freeOrNextPage);
			if ((page == freeOrNextPage)
			 || (page == objStackPage)) {
				print("circularity in free page list!!");
				cr();
				page = 0;
			}
			freeOrNextPage = page;
		}
	}
	freeOrNextPage = fetchPointerofObject(ObjStackNextx, objStackPage);
	if (freeOrNextPage) {
		printObjStackPagemyIndexpageTypeprintContents(freeOrNextPage, myx, ObjStackNextx, printContents);
	}
	if (printContents) {
		index = (fetchPointerofObject(ObjStackTopx, objStackPage)) + ObjStackNextx;
		while (index >= ObjStackFixedSlots) {
			/* begin space */
			printChar(' ');
			printHex(fetchPointerofObject(index, objStackPage));
			index -= 1;
		}
		if (((fetchPointerofObject(ObjStackTopx, objStackPage)) + ObjStackNextx) >= ObjStackFixedSlots) {
			cr();
		}
	}
}

	/* SpurMemoryManager>>#printObjStackPage:myIndex:tag: */
static NoDbgRegParms void
printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType)
{
	print(pageType);

	/* begin space */
	printChar(' ');
	printHex(objStackPage);

	/* begin space */
	printChar(' ');
	print("cx ");
	printNum(classIndexOf(objStackPage));
	print(" (");
	printNum(wordSizeClassIndexPun());
	print(") fmt ");
	printNum(formatOf(objStackPage));
	print(" (");
	printNum(wordIndexableFormat());
	print(") sz ");
	printNum(numSlotsOfAny(objStackPage));
	print(" (");
	printNum(ObjStackPageSlots);
	print(") myx: ");
	printNum(fetchPointerofObject(ObjStackMyx, objStackPage));
	print(" (");
	printNum(myx);
	print((isMarked(objStackPage)
			? ") mkd"
			: ") unmkd"));
	cr();
}


/*	useful for debugging */

	/* SpurMemoryManager>>#printObjStack: */
void
printObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printObjStack:printContents: */
	if (objStack == GIV(nilObj)) {
		print("nil");
		cr();
	}
	else {
		printObjStackPagemyIndexpageTypeprintContents(objStack, fetchPointerofObject(ObjStackMyx, objStack), ObjStackMyx, 0);
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsExcept: */
NeverInline void
printOopsExcept(sqInt (*function)(sqInt))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt n;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	n = 0;

	/* begin allHeapEntitiesDo: */
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (!(function(objOop))) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (!(function(objOop))) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;
	if (n > 4) {

		/* rabbits */
		printNum(n);
		print(" objects");
		cr();
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsFrom:to: */
void
printOopsFromto(sqInt startAddress, sqInt endAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstNonEntity;
    sqInt inEmptySpace;
    sqInt lastNonEntity;
    sqInt limit;
    sqInt oop;

	firstNonEntity = 0;
	oop = objectBefore(startAddress);
	limit = (((((usqIntptr_t)endAddress)) < GIV(endOfMemory)) ? (((usqIntptr_t)endAddress)) : GIV(endOfMemory));
	oop = (oop
				? ((objectAfter(oop)) == startAddress
						? startAddress
						: oop)
				: startAddress);
	inEmptySpace = 0;
	while (oopisLessThan(oop, limit)) {
		printEntity(oop);
		while (1) {
			oop = objectAfter(oop);
			if (!((long64At(oop)) == 0)) break;
			if (!inEmptySpace) {
				inEmptySpace = 1;
				firstNonEntity = oop;
			}
			lastNonEntity = oop;
		}
		if (inEmptySpace) {
			inEmptySpace = 0;
			print("skipped empty space from ");
			printHexnp(firstNonEntity);
			print(" to ");
			printHexnp(lastNonEntity);
			cr();
			oop = objectStartingAt(oop);
		}
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printOopsSuchThat: */
NeverInline void
printOopsSuchThat(sqInt (*function)(sqInt))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt n;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt start;

	n = 0;

	/* begin allHeapEntitiesDo: */
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop, GIV(endOfMemory)))) break;
		assert((long64At(objOop)) != 0);
		if (function(objOop)) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfter:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objOop = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? followingWordAddress + BaseHeaderSize
					: followingWordAddress);
l3:	/* end objectAfter:limit: */;
	}

	/* begin allNewSpaceEntitiesDo: */
	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */
	prevPrevObj = (prevObj = null);
	assert((((GIV(pastSpace)).start)) < (((GIV(eden)).start)));

	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		start = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			start = ((GIV(eden)).start);
		}
		else {
			start = GIV(oldSpaceStart);
		}
	}
	if (start > GIV(freeStart)) {
		goto l2;
	}

	/* begin bridgePastSpaceAndEden */
	if (GIV(pastSpaceStart) < (((GIV(eden)).start))) {

		/* past space can be entirely full (!!) */
		if ((GIV(pastSpaceStart) + BaseHeaderSize) == (((GIV(eden)).start))) {

			/* No room for a full bridge (!!); use the slim bridge hack */
			hackSlimBridgeToat(objectStartingAt(((GIV(eden)).start)), GIV(pastSpaceStart));
			assert((objectAfterMaybeSlimBridgelimit(objectInPastSpaceBefore(GIV(pastSpaceStart)), GIV(nilObj))) == (objectStartingAt(((GIV(eden)).start))));
		}
		else {

			/* Room for a regular bridge; this is straight-forward */
			initSegmentBridgeWithBytesat((((GIV(eden)).start)) - GIV(pastSpaceStart), GIV(pastSpaceStart));
		}
	}
	objOop = objectStartingAt(start);
	while (oopisLessThan(objOop, GIV(freeStart))) {
		if (function(objOop)) {
			n += 1;
			printEntity(objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objOop);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(freeStart))) {
			objOop = GIV(freeStart);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objOop = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objOop, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
	}
l2:	/* end allNewSpaceEntitiesDo: */;
	if (n > 4) {

		/* rabbits */
		printNum(n);
		print(" objects");
		cr();
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */
/*	useful for VM debugging */

	/* SpurMemoryManager>>#printReferencesTo: */
void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt contextSize;
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt header;
    sqInt i;
    usqInt numLiterals;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt sp;
    sqInt startObject;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			/* begin numPointerSlotsOf: */
			fmt = formatOf(objSqInt);
			if (fmt <= (lastPointerFormat())) {
				if ((fmt == (indexablePointersFormat()))
				 && ((classIndexOf(objSqInt)) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */
					/* begin fetchStackPointerOf: */
					sp = fetchPointerofObject(StackPointerIndex, objSqInt);
					if (!((((sp) & 7) == 1))) {
						contextSize = 0;
						goto l1;
					}
					assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(objSqInt)));
					contextSize = (sp >> 3);
l1:	/* end fetchStackPointerOf: */;
					i = ((usqInt) (CtxtTempFrameStart + contextSize));
					goto l2;
				}
				i = numSlotsOf(objSqInt);
				goto l2;
			}
			if (fmt == (forwardedFormat())) {
				i = 1;
				goto l2;
			}
			if (fmt < (firstCompiledMethodFormat())) {
				i = 0;
				goto l2;
			}
			header = methodHeaderOf(objSqInt);

			/* begin literalCountOfMethodHeader: */
			assert((((header) & 7) == 1));
			numLiterals = ((header >> 3)) & AlternateHeaderNumLiteralsMask;
			i = numLiterals + LiteralStart;
l2:	/* end numPointerSlotsOf: */;
			while (((i -= 1)) >= 0) {
				if (anOop == (fetchPointerofMaybeForwardedObject(i, objSqInt))) {
					printHex(objSqInt);
					print(" @ ");
					printNum(i);

					/* begin space */
					printChar(' ');
					printOopShortInner(objSqInt);
					fflush(GIV(transcript));
					cr();
					i = 0;
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l3;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l3:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}

	/* SpurMemoryManager>>#printStringDataOf:on: */
static NoDbgRegParms void
printStringDataOfon(sqInt oop, FILE *aStream)
{
    char *buffer;
    sqInt byte;
    sqInt i;
    sqInt limit;
    sqInt n;
    unsigned int *wideBuffer;
    int word;

	if (isBytesNonImm(oop)) {
		buffer = ((char *) (alloca(0x400)));
		n = (i = 0);
		limit = (((numBytesOfBytes(oop)) < 0x100) ? (numBytesOfBytes(oop)) : 0x100);
		while (n < limit) {
			byte = fetchByteofObject(i, oop);
			i += 1;
			if ((byte < 32)
			 && (byte != 9)) {
				buffer[n] = '<';
				n += 1;
				if ((byte == 10)
				 || (byte == 13)) {
					if (byte == 10) {
						buffer[n] = 'L';
						buffer[n + 1] = 'F';
					}
					else {
						buffer[n] = 'C';
						buffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (byte >= 10) {
						buffer[n] = ((byte / 10) + (((sqInt)'0')));
						n += 1;
					}
					buffer[n] = ((byte % 10) + (((sqInt)'0')));
					n += 1;
				}
				buffer[n] = '>';
				n += 1;
			}
			else {
				buffer[n] = byte;
				n += 1;
			}
		}
		fprintf(aStream,
				"%.*s%s\n",
				((int) n),
				buffer,
				((numBytesOfBytes(oop)) > limit
				? "..."
				: ""));
	}
	else {
		assert(isWordsNonImm(oop));
		wideBuffer = ((unsigned int *) (alloca(0x1000)));
		n = (i = 0);
		limit = (((lengthOf(oop)) < 0x100) ? (lengthOf(oop)) : 0x100);
		while (i < limit) {
			word = fetchLong32ofObject(i, oop);
			i += 1;
			if ((word < 32)
			 && (word != 9)) {
				wideBuffer[n] = '<';
				n += 1;
				if ((word == 10)
				 || (word == 13)) {
					if (word == 10) {
						wideBuffer[n] = 'L';
						wideBuffer[n + 1] = 'F';
					}
					else {
						wideBuffer[n] = 'C';
						wideBuffer[n + 1] = 'R';
					}
					n += 2;
				}
				else {
					if (word >= 10) {
						wideBuffer[n] = ((word / 10) + (((sqInt)'0')));
						n += 1;
					}
					wideBuffer[n] = ((word % 10) + (((sqInt)'0')));
					n += 1;
				}
				wideBuffer[n] = '>';
				n += 1;
			}
			else {
				wideBuffer[n] = word;
				n += 1;
			}
		}
		fwprintf(aStream,
				L"%.*ls%s\n",
				((int) n),
				wideBuffer,
				((lengthOf(oop)) > limit
				? "..."
				: ""));
	}
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#printUnmarkedOops */
#if LLDB
void
printUnmarkedOops(void)
{
	printOopsExcept(isMarked);
}
#endif /* LLDB */


/*	Attempt to push anEphemeron on the unscanned ephemerons stack
	and answer if the attempt succeeded. Note that the ephemeron
	stack overflowing isn't a disaster; it simply means treating the
	ephemeron as strong in this GC cycle. */

	/* SpurMemoryManager>>#pushOnUnscannedEphemeronsStack: */
static NoDbgRegParms sqInt
pushOnUnscannedEphemeronsStack(sqInt anEphemeron)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isEphemeron(anEphemeron));
	if (((GIV(unscannedEphemerons).top)) >= ((GIV(unscannedEphemerons).limit))) {
		return 0;
	}
	longAtput((GIV(unscannedEphemerons).top), anEphemeron);
	(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) + BytesPerOop);
	return 1;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that
	objects in temporary variables are properly remapped.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#pushRemappableOop: */
void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}

	/* SpurMemoryManager>>#rawHashBitsOf: */
sqInt
rawHashBitsOf(sqInt objOop)
{
	flag("endianness");
	return (long32At(objOop + 4)) & (identityHashHalfWordMask());
}

	/* SpurMemoryManager>>#rememberedSetObj: */
static NoDbgRegParms void
rememberedSetObj(sqInt anObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isOldObject(anObj));
	storePointerUncheckedofObjectwithValue(RememberedSetRootIndex, GIV(hiddenRootsObj), anObj);
}


/*	Remove the given variable location to the extra roots table. */

	/* SpurMemoryManager>>#removeGCRoot: */
sqInt
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */
			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Byte-swap the given range of memory (not inclusive of stopAddr!). */

	/* SpurMemoryManager>>#reverseBytesFrom:to: */
static NoDbgRegParms void
reverseBytesFromto(sqInt startAddr, sqInt stopAddr)
{
    sqInt addr;

	addr = startAddr;
	while (oopisLessThan(addr, stopAddr)) {
		longAtput(addr, byteSwapped(longAt(addr)));
		addr += BytesPerWord;
	}
}

	/* SpurMemoryManager>>#reverseBytesInMemory */
static void
reverseBytesInMemory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	reverseBytesFromto(GIV(oldSpaceStart), GIV(endOfMemory));
}

	/* SpurMemoryManager>>#roundUpHeapSize: */
static NoDbgRegParms usqInt
roundUpHeapSize(usqInt heapSize)
{
    sqInt bit;

	bit = (((highBit(heapSize)) - 1) * 3) / 4;
	return (((heapSize & ((1ULL << bit) - 1)) != 0)
			? (((heapSize | ((1ULL << bit) - 1)) - ((1ULL << bit) - 1))) + (1ULL << bit)
			: heapSize);
}

	/* SpurMemoryManager>>#scavengeInProgress */
static int
scavengeInProgress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(gcPhaseInProgress) == ScavengeInProgress;
}


/*	David's paper uses 140Kb eden + 2 x 28kb survivor spaces,
	which is 5 7ths for eden and 1 7th each for the survivor spaces.
	So express scavenger sizes in 7ths */

	/* SpurMemoryManager>>#scavengerDenominator */
static sqInt
scavengerDenominator(void)
{
	return 7;
}

	/* SpurMemoryManager>>#setHashBitsOf:to: */
static NoDbgRegParms void
setHashBitsOfto(sqInt objOop, sqInt hash)
{
	flag("endianness");
	assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
	long32Atput(objOop + 4, ((((long32At(objOop + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
}


/*	Set the dimensions of the heap, answering the start of oldSpace. edenBytes
	holds the desired ``size of eden''
	which is actually the total size of new space minus the reserve. edenBytes
	is then divided up between eden
	and the two survivor spaces, where each survivor space is a
	scavengerDenominator (one seventh) of the total. */
/*	Transcript
	cr; nextPutAll: 'heapBase: '; print: baseOfHeap; nextPut: $/; nextPutAll:
	baseOfHeap hex;
	nextPutAll: ' memLimit '; print: memLimit; nextPut: $/; nextPutAll:
	memLimit hex;
	nextPutAll: ' memEnd '; print: memEnd; nextPut: $/; nextPutAll: memEnd
	hex; cr; flush. */
/*	This is more than a little counter-intuitive. Eden must include
	interpreterAllocationReserveBytes. 
 */

	/* SpurMemoryManager>>#setHeapBase:memoryLimit:endOfMemory: */
static NoDbgRegParms NeverInline sqInt
setHeapBasememoryLimitendOfMemory(sqInt baseOfHeap, sqInt memLimit, sqInt memEnd)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt reserve;

	reserve = 0 /* interpreterAllocationReserveBytes */;
	GIV(newSpaceStart) = baseOfHeap;
	GIV(oldSpaceStart) = (baseOfHeap + GIV(edenBytes)) + reserve;
	newSpaceStartnewSpaceBytessurvivorBytes(GIV(newSpaceStart), GIV(oldSpaceStart) - GIV(newSpaceStart), ((GIV(oldSpaceStart) - GIV(newSpaceStart)) - reserve) / (scavengerDenominator()));
	GIV(freeStart) = ((GIV(eden)).start);
	GIV(pastSpaceStart) = ((GIV(pastSpace)).start);
	GIV(freeOldSpaceStart) = memEnd;
	GIV(endOfMemory) = memLimit;
	return baseOfHeap;
}

	/* SpurMemoryManager>>#setHiddenRootsObj: */
static NoDbgRegParms void
setHiddenRootsObj(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt j;
    sqInt page;

	GIV(hiddenRootsObj) = anOop;
	assert(validClassTableRootPages());
	GIV(classTableFirstPage) = fetchPointerofObject(0, GIV(hiddenRootsObj));
	assert(((numSlotsOf(GIV(classTableFirstPage))) - 1) == (classTableMinorIndexMask()));
	flag("remove at some stage");
	if ((classIndexOf(GIV(classTableFirstPage))) != (arrayClassIndexPun())) {
		setClassIndexOfto(GIV(classTableFirstPage), arrayClassIndexPun());
	}
	GIV(numClassTablePages) = classTableRootSlots();
	GIV(classTableIndex) = ((sqInt)((usqInt)(GIV(numClassTablePages)) << (classTableMajorIndexShift())));
	for (i = 1; i < GIV(numClassTablePages); i += 1) {
		if (((page = fetchPointerofObject(i, GIV(hiddenRootsObj)))) == GIV(nilObj)) {
			if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) > i) {
				GIV(classTableIndex) = ((sqInt)((usqInt)(((((i - 1) < 1) ? 1 : (i - 1)))) << (classTableMajorIndexShift())));
			}
			GIV(numClassTablePages) = i;
			assert((classOrNilAtIndex(GIV(classTableIndex))) == GIV(nilObj));
			return;
		}
		else {
			if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) > i) {
				j = 0;
				while (j < (classTablePageSize())) {
					if ((fetchPointerofObject(j, page)) == GIV(nilObj)) {
						GIV(classTableIndex) = ((((usqInt)(i) << (classTableMajorIndexShift())))) + j;
						j = classTablePageSize();
					}
					j += 1;
				}
			}
		}
	}
	if ((((usqInt)(GIV(classTableIndex))) >> (classTableMajorIndexShift())) >= GIV(numClassTablePages)) {
		GIV(classTableIndex) = 1U << (classTableMajorIndexShift());
	}
	assert((classOrNilAtIndex(GIV(classTableIndex))) == GIV(nilObj));
}

	/* SpurMemoryManager>>#setNextFreeChunkOf:withValue:chunkBytes: */
static NoDbgRegParms void
setNextFreeChunkOfwithValuechunkBytes(sqInt freeChunk, sqInt nextFreeChunk, sqInt chunkBytes)
{
    sqInt lilliputian;

	lilliputian = isLilliputianSize(chunkBytes);

	/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
	storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, freeChunk, nextFreeChunk);
	if ((nextFreeChunk != 0)
	 && (!lilliputian)) {
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextFreeChunk, freeChunk);
	}
}


/*	Reduce the number of indexable fields in objOop, an arrayFormat or
	longFormat object, to nSlots.
	Convert the unused residual to a free chunk (if in oldSpace).
	Answer the number of bytes returned to free memory, which may be zero. */

	/* SpurMemoryManager>>#shorten:toIndexableSize: */
sqInt
shortentoIndexableSize(sqInt objOop, sqInt indexableSize)
{
    sqInt delta;

	assert((indexableSize >= 0)
	 && (indexableSize < (lengthOf(objOop))));
	delta = doShortentoIndexableSize(objOop, indexableSize);
	assert((lengthOf(followMaybeForwarded(objOop))) == indexableSize);
	return delta;
}


/*	useful for VM debugging */

	/* SpurMemoryManager>>#shortPrintObjectsFrom:to: */
void
shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop
				? ((objectAfter(oop)) == startAddress
						? startAddress
						: oop)
				: startAddress);
	while (oopisLessThan(oop, endAddress)) {
		if (!(isFreeObject(oop))) {
			shortPrintOop(oop);
		}
		oop = objectAfter(oop);
	}
}


/*	Answer if the oop should be scavenged.. The method is called
	shouldRemapOop: for compatibility with ObjectMemory. */

	/* SpurMemoryManager>>#shouldRemapOop: */
sqInt
shouldRemapOop(sqInt oop)
{
	return (isNonImmediate(oop))
	 && (shouldRemapObj(oop));
}


/*	Answer the number of bytes in the given object, including its base header,
	rounded up to an integral number of words.
	Hence, were it not for the fact that zero-sized objects have at least room
	for a forwarding pointer,
	objOop + (self sizeBitsOf: objOop) is the address immediately following
	objOop. 
 */
/*	Note: byte indexable objects need to have low bits subtracted from this
	size to find the address beyond the last byte.
 */

	/* SpurMemoryManager>>#sizeBitsOf: */
static NoDbgRegParms usqInt
sizeBitsOf(sqInt objOop)
{
	return (((numSlotsOf(objOop)) << (shiftForWord()))) + BaseHeaderSize;
}


/*	*DO NOT CONFUSE THIS WITH numSlotsOf:.
	This is an ObjectMemory compatibility method with questionable semantics.
	Answers the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	If the receiver is a short object, return the number of shorts.
	If the receiver is a word object, return the number of words.
	If the receiver is a double word object, return the number of double
	words. Otherwise return the number of pointers. */

	/* SpurMemoryManager>>#slotSizeOf: */
static NoDbgRegParms sqInt
slotSizeOf(sqInt oop)
{
    sqInt fmt;
    usqInt numSlots;

	if (isImmediate(oop)) {
		return 0;
	}

	/* begin lengthOf: */
	fmt = formatOf(oop);
	numSlots = numSlotsOfAny(oop);
	if (fmt <= (ephemeronFormat())) {
		return numSlots;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return ((numSlots << (shiftForWord()))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return ((numSlots << ((shiftForWord()) - 1))) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return ((numSlots << ((shiftForWord()) - 2))) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlots;
	}
	return 0;
}


/*	Return one of the objects in the specialObjectsArray */

	/* SpurMemoryManager>>#splObj: */
sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fetchPointerofObject(index, GIV(specialObjectsOop));
}


/*	Answer the start of objOop, which is either the address of the overflow
	size word, or objOop itself, depending on the size of the object. This may
	be applied to any kind of object, normal, forwarders or free chunks. */

	/* SpurMemoryManager>>#startOfObject: */
static NoDbgRegParms usqInt
startOfObject(sqInt objOop)
{
	return (hasOverflowHeader(objOop)
			? objOop - BaseHeaderSize
			: objOop);
}


/*	Part of InterpreterProxy's 1.14 API */

	/* SpurMemoryManager>>#statNumGCs */
sqInt
statNumGCs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(statScavenges) + GIV(statIncrGCs)) + GIV(statFullGCs);
}


/*	A renaming for the Cogit, which can't make sense of GIV(oldSpaceStart) */

	/* SpurMemoryManager>>#storeCheckBoundary */
usqInt
storeCheckBoundary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(oldSpaceStart);
}

	/* SpurMemoryManager>>#storeLong32:ofObject:withValue: */
int
storeLong32ofObjectwithValue(sqInt fieldIndex, sqInt obj, sqInt valueWord)
{
	return long32Atput((obj + BaseHeaderSize) + ((((usqInt)(fieldIndex) << 2))), valueWord);
}

	/* SpurMemoryManager>>#storePointerNoAssert:ofFreeChunk:withValue: */
static NoDbgRegParms sqInt
storePointerNoAssertofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	return longAtput((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointerUnchecked:ofObject:withValue: */
sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isOopForwarded(objOop)));
	return longAtput((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointer:ofForwarder:withValue: */
static NoDbgRegParms sqInt
storePointerofForwarderwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(isForwarded(objOop));
	assert(!(isOopForwarded(valuePointer)));
	if (isOldObject(objOop)) {

		/* most stores into young objects */
		if (isYoung(valuePointer)) {
			/* begin possibleRootStoreInto: */
			if (!(isRemembered(objOop))) {
				remember(objOop);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}

	/* SpurMemoryManager>>#storePointer:ofFreeChunk:withValue: */
static NoDbgRegParms sqInt
storePointerofFreeChunkwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(isFreeObject(objOop));
	assert((valuePointer == 0)
	 || (isFreeObject(valuePointer)));
	return longAtput((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */
/*	See SistaCogit */

	/* SpurMemoryManager>>#storePointer:ofObject:withValue: */
sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isForwarded(objOop)));
	if (isOldObject(objOop)) {

		/* most stores into young objects */
		if (isYoung(valuePointer)) {
			/* begin possibleRootStoreInto: */
			if (!(isRemembered(objOop))) {
				remember(objOop);
			}
		}
	}
	return longAtput((objOop + BaseHeaderSize) + ((((usqInt)(fieldIndex) << (shiftForWord())))), valuePointer);
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory. */

	/* SpurMemoryManager>>#stringForCString: */
sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt len;
    usqInt newObj;
    sqInt newString;
    usqInt numBytes;
    sqInt numSlots;

	len = strlen(aCString);
	numSlots = numSlotsForBytes(len);
	formatField = byteFormatForNumBytes(len);

	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		if ((((usqInt)(numSlots)) >> 56) > 0) {
			newString = null;
			goto l1;
		}
		newObj = GIV(freeStart) + BaseHeaderSize;
		numBytes = largeObjectBytesForSlots(numSlots);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = smallObjectBytesForSlots(numSlots);
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		newString = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */
		flag("endianness");
		longAtput(GIV(freeStart), ((((usqInt)((numSlotsMask())) << (numSlotsFullShift())))) + numSlots);
		longAtput(newObj, ((((((usqLong) (numSlotsMask()))) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + ClassByteStringCompactIndex);
	}
	else {
		longAtput(newObj, ((((((usqLong) numSlots)) << (numSlotsFullShift()))) + ((((usqInt)(formatField) << (formatShift()))))) + ClassByteStringCompactIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newString = newObj;
l1:	/* end allocateSlots:format:classIndex: */;
	if (newString) {
		strncpy(((char *) (newString + BaseHeaderSize)), aCString, len);
	}
	return newString;
}


/*	On load, swizzle the pointers in an obj stack. Answer the obj stack's oop. */

	/* SpurMemoryManager>>#swizzleObjStackAt: */
static NoDbgRegParms sqInt
swizzleObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt page;
    sqInt stackOrNil;

	firstPage = (stackOrNil = fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj)));
	if (stackOrNil == GIV(nilObj)) {
		return stackOrNil;
	}
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);

		/* swizzle fields including ObjStackNextx, excluding ObjStackFreex and leave field containing the next link. */
		index = (fetchPointerofObject(ObjStackTopx, stackOrNil)) + ObjStackNextx;
		do {
			field = fetchPointerofObject(index, stackOrNil);
			if (!((field == 0)
				 || (isImmediate(field)))) {
				field = swizzleObjin(field, stackOrNil);

				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
				longAtput((stackOrNil + BaseHeaderSize) + ((((usqInt)(index) << (shiftForWord())))), field);
			}
		} while(((index -= 1)) >= ObjStackNextx);
	} while(((stackOrNil = field)) != 0);
	if ((stackOrNil = fetchPointerofObject(ObjStackFreex, firstPage))) {
		page = firstPage;
		do {
			stackOrNil = swizzleObjin(stackOrNil, firstPage);

			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(page)) == (wordIndexableFormat()));
			longAtput((page + BaseHeaderSize) + ((((usqInt)(ObjStackFreex) << (shiftForWord())))), stackOrNil);
			page = stackOrNil;
		} while(((stackOrNil = fetchPointerofObject(ObjStackFreex, page))) != 0);
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return fetchPointerofObject(objStackRootIndex, GIV(hiddenRootsObj));
}


/*	This assert is tricky. push:onObjStack: may call topOfObjStack: just after
	pushing an
	empty page on the stack, and will ask if the second page is valid. */

	/* SpurMemoryManager>>#topOfObjStack: */
static NoDbgRegParms sqInt
topOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt topx;

	eassert(isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), objStack == (fetchPointerofObject(fetchPointerofObject(ObjStackMyx, objStack), GIV(hiddenRootsObj)))));
	topx = fetchPointerofObject(ObjStackTopx, objStack);
	if (!topx) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	return fetchPointerofObject((topx + ObjStackFixedSlots) - 1, objStack);
}


/*	Answers the top of the remappable oop stack. Useful when writing loops.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

	/* SpurMemoryManager>>#topRemappableOop */
sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}


/*	This method both computes the actual number of free bytes by traversing
	all free objects
	on the free lists/tree, and checks that the tree is valid. It is used
	mainly by checkFreeSpace. */

	/* SpurMemoryManager>>#totalFreeListBytes */
static sqInt
totalFreeListBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesInChunk;
    sqInt cameFrom;
    sqInt i;
    sqInt largeChild;
    sqInt listNode;
    sqInt nextNode;
    sqInt smallChild;
    sqInt totalFreeBytes;
    sqInt treeNodeSqInt;

	totalFreeBytes = 0;
	for (i = 1; i < (numFreeLists()); i += 1) {
		bytesInChunk = i * (allocationUnit());
		listNode = GIV(freeLists)[i];
		while (listNode != 0) {
			totalFreeBytes += bytesInChunk;

			/* begin assertValidFreeObject: */
			assert(assertInnerValidFreeObject(listNode));
			assert(bytesInChunk == (bytesInBody(listNode)));
			nextNode = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, listNode);
			assert(nextNode != listNode);
			listNode = nextNode;
		}
	}

	/* begin freeTreeNodesDo: */
	treeNodeSqInt = GIV(freeLists)[0];
	if (!treeNodeSqInt) {
		goto l1;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNodeSqInt)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNodeSqInt);
		largeChild = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNodeSqInt);
		assert((smallChild == 0)
		 || (treeNodeSqInt == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNodeSqInt == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild
				? cameFrom == largeChild
				: cameFrom == smallChild))) {
			bytesInChunk = bytesInBody(treeNodeSqInt);
			assert((bytesInChunk / (allocationUnit())) >= (numFreeLists()));
			listNode = treeNodeSqInt;
			while (listNode != 0) {

				/* self printFreeChunk: listNode */
				/* begin assertValidFreeObject: */
				assert(assertInnerValidFreeObject(listNode));
				assert((listNode == treeNodeSqInt)
				 || ((fetchPointerofFreeChunk(freeChunkParentIndex(), listNode)) == 0));
				totalFreeBytes += bytesInChunk;
				assert(bytesInChunk == (bytesInBody(listNode)));
				nextNode = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, listNode);
				assert(nextNode != listNode);
				listNode = nextNode;
			}
			cameFrom = treeNodeSqInt;
			treeNodeSqInt = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, treeNodeSqInt);
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNodeSqInt = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNodeSqInt = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNodeSqInt != 0);
l1:	/* end freeTreeNodesDo: */;
	return totalFreeBytes;
}


/*	Arbitrary level at which to defer tracing large objects until later.
	The average slot size of Smalltalk objects is typically near 8.
	We do require traceImmediatelySlotLimit to be < numSlotsMask. */

	/* SpurMemoryManager>>#traceImmediatelySlotLimit */
static sqInt
traceImmediatelySlotLimit(void)
{
	return 64;
}

	/* SpurMemoryManager>>#trueObject */
sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}

	/* SpurMemoryManager>>#unlinkFreeChunk:atIndex:chunkBytes: */
static NoDbgRegParms sqInt
unlinkFreeChunkatIndexchunkBytes(sqInt chunk, sqInt index, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lilliputian;
    sqInt next;

	lilliputian = isLilliputianSize(chunkBytes);

	/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
	assert(((bytesInBody(chunk)) == (index * (allocationUnit())))
	 && ((index > 1)
	 && ((startOfObject(chunk)) == chunk)));
	GIV(freeLists)[index] = ((next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, chunk)));
	if ((!lilliputian)
	 && (next != 0)) {
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, next, 0);
	}
	return chunk;
}


/*	Unlink a free object from the free lists. Do not alter totalFreeOldSpace.
	Used for coalescing.
 */

	/* SpurMemoryManager>>#unlinkFreeChunk:chunkBytes: */
static NoDbgRegParms sqInt
unlinkFreeChunkchunkBytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt next;
    sqInt nextSqInt;
    sqInt prev;

	/* Pathological 64 bits case - size 1 - single linked list */
	index = chunkBytes / (allocationUnit());
	if (isLilliputianSize(chunkBytes)) {
		return unlinkLilliputianChunkindex(freeChunk, index);
	}

	/* Has prev element: update double linked list */
	prev = fetchPointerofFreeChunk(1 /* freeChunkPrevIndex */, freeChunk);
	if (prev) {
		setNextFreeChunkOfwithValuechunkBytes(prev, fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk), chunkBytes);
		return freeChunk;
	}
	if ((index < (numFreeLists()))
	 && ((1ULL << index) <= GIV(freeListsMask))) {
		/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
		assert(((bytesInBody(freeChunk)) == (index * (allocationUnit())))
		 && ((index > 1)
		 && ((startOfObject(freeChunk)) == freeChunk)));
		GIV(freeLists)[index] = ((nextSqInt = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk)));
		if (nextSqInt) {
			storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, nextSqInt, 0);
		}
		return freeChunk;
	}
	next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk);
	if (next) {

		/* list; replace node with it */
		inFreeTreeReplacewith(freeChunk, next);
	}
	else {

		/* no list; remove the interior node */
		unlinkSolitaryFreeTreeNode(freeChunk);
	}
	return freeChunk;
}

	/* SpurMemoryManager>>#unlinkLilliputianChunk:index: */
static NoDbgRegParms NeverInline sqInt
unlinkLilliputianChunkindex(sqInt freeChunk, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt next;
    sqInt nextSqInt;
    sqInt node;
    sqInt prev;


	/* for profiling */
	node = GIV(freeLists)[index];
	prev = 0;
	while (node != 0) {
		assert(node == (startOfObject(node)));

		/* begin assertValidFreeObject: */
		assert(assertInnerValidFreeObject(node));
		next = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, node);
		if (node == freeChunk) {
			if (prev) {
				/* begin setNextFreeChunkOf:withValue:isLilliputianSize: */
				storePointerofFreeChunkwithValue(0 /* freeChunkNextIndex */, prev, next);
			}
			else {
				/* begin unlinkFreeChunk:atIndex:isLilliputianSize: */
				assert(((bytesInBody(freeChunk)) == (index * (allocationUnit())))
				 && ((index > 1)
				 && ((startOfObject(freeChunk)) == freeChunk)));
				GIV(freeLists)[index] = ((nextSqInt = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, freeChunk)));
			}
			return freeChunk;
		}
		prev = node;
		node = next;
	}
	error("freeChunk not found in lilliputian chunk free list");
	return 0;
}


/*	Unlink a freeTreeNode. Assumes the node has no list (null next link). */

	/* SpurMemoryManager>>#unlinkSolitaryFreeTreeNode: */
static NoDbgRegParms void
unlinkSolitaryFreeTreeNode(sqInt freeTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt larger;
    sqInt parent;
    sqInt smaller;

	assert((fetchPointerofFreeChunk(freeChunkNextIndex(), freeTreeNode)) == 0);
	smaller = fetchPointerofFreeChunk(freeChunkSmallerIndex(), freeTreeNode);
	larger = fetchPointerofFreeChunk(freeChunkLargerIndex(), freeTreeNode);
	parent = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, freeTreeNode);
	if (parent) {

		/* parent; stitch back into appropriate side of parent. */
		if (smaller) {
			storePointerofFreeChunkwithValue((freeTreeNode == (fetchPointerofFreeChunk(freeChunkSmallerIndex(), parent))
					? freeChunkSmallerIndex()
					: freeChunkLargerIndex()), parent, smaller);
			storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, smaller, parent);
			if (larger) {
				addFreeSubTree(larger);
			}
		}
		else {
			storePointerofFreeChunkwithValue((freeTreeNode == (fetchPointerofFreeChunk(freeChunkSmallerIndex(), parent))
					? freeChunkSmallerIndex()
					: freeChunkLargerIndex()), parent, larger);
			if (larger) {
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, larger, parent);
			}
		}
	}
	else {

		/* no parent; stitch the subnodes back into the root */
		if (smaller) {
			storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, smaller, 0);
			GIV(freeLists)[0] = smaller;
			if (larger) {
				addFreeSubTree(larger);
			}
		}
		else {
			if (larger) {
				storePointerofFreeChunkwithValue(2 /* freeChunkParentIndex */, larger, 0);
			}
			GIV(freeLists)[0] = larger;
		}
	}
}

	/* SpurMemoryManager>>#unpinObject: */
sqInt
unpinObject(sqInt objOop)
{
	assert(isNonImmediate(objOop));
	setIsPinnedOfto(objOop, 0);
	return 0;
}


/*	Snapshot did not guarantee the state of the freelist prevLink, so we need
	to update it.
	Effectively transforms the freechunk single linked list in double linked
	list. 
 */
/*	Small chunks */
/*	Skip in 64 bits size 1 which is single linked list - pathological case */

	/* SpurMemoryManager>>#updateFreeLists */
static void
updateFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cameFrom;
    sqInt i;
    sqInt largeChild;
    sqInt min;
    sqInt smallChild;
    sqInt treeNode;

	min = 3;
	for (i = min; i < (numFreeLists()); i += 1) {
		updateListStartingAt(GIV(freeLists)[i]);
	}

	/* begin freeTreeNodesDo: */
	treeNode = GIV(freeLists)[0];
	if (!treeNode) {
		goto l1;
	}
	cameFrom = -1;
	do {
		assert((bytesInBody(treeNode)) >= ((numFreeLists()) * (allocationUnit())));
		smallChild = fetchPointerofFreeChunk(freeChunkSmallerIndex(), treeNode);
		largeChild = fetchPointerofFreeChunk(freeChunkLargerIndex(), treeNode);
		assert((smallChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
		 && (largeChild == 0))
		 || ((largeChild
				? cameFrom == largeChild
				: cameFrom == smallChild))) {
			updateListStartingAt(treeNode);
			cameFrom = treeNode;
			treeNode = fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, treeNode);
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode != 0);
l1:	/* end freeTreeNodesDo: */;
}

	/* SpurMemoryManager>>#updateListStartingAt: */
static NoDbgRegParms void
updateListStartingAt(sqInt freeNode)
{
    sqInt obj;
    sqInt prev;

	obj = 0;
	if (!freeNode) {
		return;
	}
	assert(!((isLilliputianSize(bytesInBody(freeNode)))));
	prev = freeNode;
	storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, prev, 0);
	while (1) {
		obj = fetchPointerofFreeChunk(0 /* freeChunkNextIndex */, prev);
		if (!(obj != 0)) break;
		storePointerofFreeChunkwithValue(1 /* freeChunkPrevIndex */, obj, prev);
		prev = obj;
	}
}

	/* SpurMemoryManager>>#updateRootOfObjStackAt:with: */
static NoDbgRegParms sqInt
updateRootOfObjStackAtwith(sqInt objStackRootIndex, sqInt newRootPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	storePointerofObjectwithValue(objStackRootIndex, GIV(hiddenRootsObj), newRootPage);
	switch (objStackRootIndex) {
	case MarkStackRootIndex:
		GIV(markStack) = newRootPage;
		break;
	case WeaklingStackRootIndex:
		GIV(weaklingStack) = newRootPage;
		break;
	case MournQueueRootIndex:
		GIV(mournQueue) = newRootPage;
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return newRootPage;
}


/*	Answer if hiddenRootsObj is of the right size with the
	expected contents, and if numClassTablePages is correct. */

	/* SpurMemoryManager>>#validClassTableRootPages */
static sqInt
validClassTableRootPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt obj;
    sqInt toDoLimit;

	if (!((numSlotsOf(GIV(hiddenRootsObj))) == ((classTableRootSlots()) + (hiddenRootSlots())))) {
		return 0;
	}
	if (!((GIV(numClassTablePages) > 1)
		 && (GIV(numClassTablePages) <= (classTableRootSlots())))) {
		return 0;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		obj = fetchPointerofObject(i, GIV(hiddenRootsObj));
		if (!((addressCouldBeObj(obj))
			 && ((numSlotsOf(obj)) == (classTablePageSize())))) {
			return 0;
		}
	}
	toDoLimit = (classTableRootSlots()) - 1;
	for (i = GIV(numClassTablePages); i <= toDoLimit; i += 1) {
		if ((fetchPointerofObject(i, GIV(hiddenRootsObj))) != GIV(nilObj)) {
			return 0;
		}
	}
	return 1;
}


/*	useful for debugging */

	/* SpurMemoryManager>>#validFreeTree */
int
validFreeTree(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return !(validFreeTreeChunkparent(GIV(freeLists)[0], 0));
}

	/* SpurMemoryManager>>#validFreeTreeChunk:parent: */
static NoDbgRegParms const char *
validFreeTreeChunkparent(sqInt chunk, sqInt parent)
{
    const char *reason;

	if (!chunk) {
		return null;
	}
	if (!(addressCouldBeOldObj(chunk))) {
		return "not in old space";
	}
	if (((bytesInBody(chunk)) / (allocationUnit())) < (numFreeLists())) {
		return "too small";
	}
	if (parent != (fetchPointerofFreeChunk(2 /* freeChunkParentIndex */, chunk))) {
		return "bad parent";
	}
	if ((segmentContainingObj(chunk)) != (segmentContainingObj(addressAfter(chunk)))) {
		return "not in one segment";
	}
	reason = validFreeTreeChunkparent(fetchPointerofFreeChunk(freeChunkSmallerIndex(), chunk), chunk);
	if (reason) {
		return reason;
	}
	reason = validFreeTreeChunkparent(fetchPointerofFreeChunk(freeChunkLargerIndex(), chunk), chunk);
	if (reason) {
		return reason;
	}
	return null;
}

	/* SpurMemoryManager>>#validObjStacks */
static sqInt
validObjStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(markStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(markStack))))
	 && (((GIV(weaklingStack) == GIV(nilObj))
	 || (isValidObjStack(GIV(weaklingStack))))
	 && ((GIV(mournQueue) == GIV(nilObj))
	 || (isValidObjStack(GIV(mournQueue)))));
}


/*	1 = big, 0 = little */

	/* SpurMemoryManager>>#vmEndianness */
sqInt
vmEndianness(void)
{
	return VMBIGENDIAN;
}

	/* SpurMemoryManager>>#whereIsMaybeHeapThing: */
static NoDbgRegParms char *
whereIsMaybeHeapThing(sqInt anOop)
{
	if (isInNewSpace(anOop)) {
		if (isInEden(anOop)) {
			return " is in eden";
		}
		if (isInFutureSpace(anOop)) {
			return " is in future space";
		}
		if (isInPastSpace(anOop)) {
			return " is in past space";
		}
		return " is in new space";
	}
	if (isInOldSpace(anOop)) {
		if (segmentContainingObj(anOop)) {
			return " is in old space";
		}
		return " is between old space segments";
	}
	return null;
}


/*	Answer if the obj should be scavenged, or simply followed. Sent via the
	compactor from shouldRemapObj:. We test for being already scavenged
	because mapStackPages
	via mapInterpreterOops may be applied twice in the context of a global GC
	where a
	scavenge, followed by a scan-mark-free, and final compaction passes may
	result in
	scavenged fields being visited twice. */

	/* SpurPlanningCompactor>>#shouldRemapObj: */
sqInt
shouldRemapObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt lastMobileObject = null;
    sqInt mobileStart;

	return /* slidingCompactionShouldRemapObj: */
		((!((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun())))))
	 || ((GIV(gcPhaseInProgress) > 0)
	 && ((scavengeInProgress()
			? (isReallyYoungObject(objOop))
			 && (!(isInFutureSpace(objOop)))
			: /* isMobile: */
				(oopisGreaterThanOrEqualToandLessThanOrEqualTo(objOop, mobileStart, lastMobileObject))
			 && (!(isPinned(objOop))))));
}

	/* SpurSegmentInfo>>#segLimit */
static NoDbgRegParms usqInt
segLimit(SpurSegmentInfo *self_in_SpurSegmentInfo)
{
	return ((self_in_SpurSegmentInfo->segSize)) + ((self_in_SpurSegmentInfo->segStart));
}


/*	Adjust swizzles by firstSegmentShift. Also computes segStarts as
	they were in the image when it was written, so that oops' segments
	can be determined and hence oops correctly swizzled. */

	/* SpurSegmentManager>>#adjustSegmentSwizzlesBy: */
static NoDbgRegParms void
adjustSegmentSwizzlesBy(sqInt firstSegmentShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oldBaseAddr;
    SpurSegmentInfo *segInfo;

	oldBaseAddr = GIV(oldSpaceStart) - firstSegmentShift;
	for (i = 0; i < GIV(numSegments); i += 1) {
		segInfo = (&(GIV(segments)[i]));
		(segInfo->segStart = ((segInfo->segStart)) + oldBaseAddr);
		(segInfo->swizzle = ((segInfo->swizzle)) - oldBaseAddr);
	}
	GIV(canSwizzle) = 1;
}


/*	Increase the number of allocated segInfos by 16. */

	/* SpurSegmentManager>>#allocateOrExtendSegmentInfos */
static void
allocateOrExtendSegmentInfos(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newNumSegs;

	if (!GIV(numSegInfos)) {
		GIV(numSegInfos) = 16;
		GIV(segments) = calloc(GIV(numSegInfos), sizeof(SpurSegmentInfo));
		return;
	}
	newNumSegs = GIV(numSegInfos) + 16;
	GIV(segments) = realloc(GIV(segments), newNumSegs * (sizeof(SpurSegmentInfo)));
	if (!GIV(segments)) {
		error("out of memory; cannot allocate more segments");
	}
	memset(GIV(segments) + GIV(numSegInfos), 0, (newNumSegs - GIV(numSegInfos)) * (sizeof(SpurSegmentInfo)));
	GIV(numSegInfos) = newNumSegs;
}

	/* SpurSegmentManager>>#bridgeAt: */
static NoDbgRegParms sqInt
bridgeAt(sqInt segIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return bridgeFor((&(GIV(segments)[segIndex])));
}

	/* SpurSegmentManager>>#bridgeFor: */
static NoDbgRegParms sqInt
bridgeFor(SpurSegmentInfo *aSegment)
{
	return objectStartingAt((segLimit(aSegment)) - (bridgeSize()));
}

	/* SpurSegmentManager>>#checkSegments */
static void
checkSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(numSegments) >= 1);
	for (i = 0; i < GIV(numSegments); i += 1) {
		assert(addressCouldBeObj(((GIV(segments)[i]).segStart)));
		assert(isValidSegmentBridge(bridgeAt(i)));
	}
	assert(((segLimit(&GIV(segments)[GIV(numSegments) - 1])) - (bridgeSize())) == (GIV(endOfMemory)));
}


/*	The image has been loaded, old segments reconstructed, and the heap
	swizzled into a single contiguous segment. Collapse the segments into one. */

	/* SpurSegmentManager>>#collapseSegmentsPostSwizzle */
static void
collapseSegmentsPostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo *cascade0;

	GIV(canSwizzle) = 0;
	GIV(numSegments) = 1;
	computeTotalHeapSizeIncludingBridges();
	cascade0 = (&(GIV(segments)[0]));
	(cascade0->segStart = GIV(oldSpaceStart));
	(cascade0->segSize = GIV(totalHeapSizeIncludingBridges));
	assert(isSegmentBridge(bridgeAt(0)));
	assert((numSlotsOfAny(bridgeAt(0))) == 0);
}

	/* SpurSegmentManager>>#computeTotalHeapSizeIncludingBridges */
static void
computeTotalHeapSizeIncludingBridges(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(totalHeapSizeIncludingBridges) = GIV(endOfMemory) - GIV(oldSpaceStart);
}

	/* SpurSegmentManager>>#isInSegments: */
static NoDbgRegParms sqInt
isInSegments(usqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < (segLimit(&GIV(segments)[i]))) {
			return 1;
		}
	}
	return 0;
}


/*	bridges bridge the gaps between segments. They are the last object in each
	segment. 
 */

	/* SpurSegmentManager>>#isValidSegmentBridge: */
static NoDbgRegParms sqInt
isValidSegmentBridge(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((addressCouldBeObj(objOop))
	 || (objOop == GIV(endOfMemory)))
	 && ((isSegmentBridge(objOop))
	 && ((hasOverflowHeader(objOop))
	 || ((numSlotsOfAny(objOop)) == 0)));
}

	/* SpurSegmentManager>>#lastSegment */
static SpurSegmentInfo
lastSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(segments)[GIV(numSegments) - 1];
}


/*	Read numBytes of image data from f into memory at memoryBaseForImageRead.
	Answer the number of bytes written. In addition, read each segment, build
	up the
	segment info for swizzling, while eliminating the bridge objects at the
	end of each
	segment that specify the distance to and the size of the subsequent
	segment.  */

	/* SpurSegmentManager>>#readHeapFromImageFile:dataBytes: */
static NoDbgRegParms sqInt
readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bridge;
    sqInt bridgehead;
    usqLong bridgeSpan;
    sqInt bytesRead;
    usqInt newBase;
    usqInt nextSegmentSize;
    sqInt oldBase;
    SpurSegmentInfo *segInfo;
    sqInt totalBytesRead;

	allocateOrExtendSegmentInfos();
	GIV(numSegments) = (totalBytesRead = 0);

	/* N.B. still must be adjusted by oldBaseAddr. */
	oldBase = 0;
	newBase = GIV(oldSpaceStart);
	nextSegmentSize = GIV(firstSegmentSize);
	bridgehead = (GIV(firstSegmentSize) + GIV(oldSpaceStart)) - (bridgeSize());
	while (1) {
		segInfo = (&(GIV(segments)[GIV(numSegments)]));
		(segInfo->segStart = oldBase);
		(segInfo->segSize = nextSegmentSize);
		(segInfo->swizzle = newBase - oldBase);
		bytesRead = sqImageFileRead(pointerForOop(newBase), sizeof(char), nextSegmentSize, f);
		if (bytesRead > 0) {
			totalBytesRead += bytesRead;
		}
		if (bytesRead != nextSegmentSize) {
			return totalBytesRead;
		}
		if (((GIV(numSegments) += 1)) >= GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		bridge = bridgehead + BaseHeaderSize;
		bridgeSpan = (byteAt(bridgehead + 7)
					? BytesPerOop * (((((usqInt)(((sqInt)((usqInt)((longAt(bridge - BaseHeaderSize))) << 8)))))) >> 8)
					: 0);
		oldBase = (oldBase + nextSegmentSize) + bridgeSpan;
		newBase = (newBase + nextSegmentSize) - (bridgeSize());
		nextSegmentSize = ((usqInt)(long64At(bridge)));
		if (!(nextSegmentSize != 0)) break;
		bridgehead = (bridgehead - (bridgeSize())) + nextSegmentSize;
	}
	assert((newBase - (GIV(oldSpaceStart))) == (totalBytesRead - (GIV(numSegments) * (bridgeSize()))));

	/* begin setFreeOldSpaceStart: */
	GIV(freeOldSpaceStart) = newBase;
	GIV(firstSegmentSize) = null;
	return totalBytesRead;
}


/*	Answer the segment containing an object. This is mostly for assert
	checking, but
	variations on the incremental GC may use it in anger. Binary search is (of
	course) marginally slower than linear search for a single segment (e.g. in
	a 720k object heap,
	67.1ms vs 61.3ms, or 9.5% slower to derive the segment containing every
	old space
	entity), but usefully faster for many segments (e.g. 92.7ms vs 116ms, or
	20% faster
	in the same heap extended with enough large arrays to require 11 segments;
	and this
	is pessimal; there are fewer objects at high addresses since the large
	arrays are there). */

	/* SpurSegmentManager>>#segmentContainingObj: */
SpurSegmentInfo *
segmentContainingObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt high;
    sqInt low;
    sqInt mid;
    SpurSegmentInfo *seg;

	low = 0;
	mid = GIV(numSegments) / 2;
	high = GIV(numSegments) - 1;
	do {
		seg = (&(GIV(segments)[mid]));
		if (oopisGreaterThanOrEqualTo(objOop, (seg->segStart))) {
			if (mid == high) {
				return (oopisLessThan(objOop, segLimit(seg))
						? seg
						: 0);
			}
			else {
				low = mid;
				mid = ((mid + high) + 1) / 2;
			}
		}
		else {
			high = mid - 1;
			mid = (low + mid) / 2;
		}
	} while(low <= high);
	return null;
}

	/* SpurSegmentManager>>#someSegmentContainsPinned */
static sqInt
someSegmentContainsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (((GIV(segments)[i]).containsPinned)) {
			return 1;
		}
	}
	return 0;
}

	/* SpurSegmentManager>>#swizzleObj: */
static NoDbgRegParms sqInt
swizzleObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(canSwizzle));
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}


/*	This ``slow'' count is for asserts only. */

	/* SpurSegmentManager>>#totalBytesInSegments */
static usqInt
totalBytesInSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    usqInt total;

	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	return total;
}

	/* SpurSegmentManager>>#totalOldSpaceCapacity */
static sqInt
totalOldSpaceCapacity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((totalBytesInSegments()) == GIV(totalHeapSizeIncludingBridges));
	return GIV(totalHeapSizeIncludingBridges) - (GIV(numSegments) * (bridgeSize()));
}


/*	Answer if maybeClassObj looks like a class object */

	/* StackInterpreter>>#addressCouldBeClassObj: */
static NoDbgRegParms sqInt
addressCouldBeClassObj(sqInt maybeClassObj)
{
	return (addressCouldBeObj(maybeClassObj))
	 && (objCouldBeClassObj(maybeClassObj));
}

	/* StackInterpreter>>#argumentCountOfMethodHeader: */
usqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderArgCountShift) & 15;
}

	/* StackInterpreter>>#argumentCountOf: */
usqInt
argumentCountOf(sqInt methodPointer)
{
	return argumentCountOfMethodHeader(methodHeaderOf(methodPointer));
}


/*	Abort on image load, because of invalid version info, etc, with an error
	message 
 */

	/* StackInterpreter>>#bailOutOfImageLoad: */
static NoDbgRegParms sqInt
bailOutOfImageLoad(sqInt rawVersion)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fprintf(stderr,
			"This ver %d vm cannot read ver %" PRIdSQINT " image file %s\n",
			68021 /* imageFormatVersion */,
			rawVersion,
			GIV(imageFilename));
	return 0;
}


/*	Check that the classes the VM assumes are compact have the right indices. */

	/* StackInterpreter>>#checkAssumedCompactClasses */
static void
checkAssumedCompactClasses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassArray, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassArrayCompactIndex))) {
		invalidCompactClassError("Array");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassLargeNegativeInteger, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassLargeNegativeIntegerCompactIndex))) {
		invalidCompactClassError("LargeNegativeInteger");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassLargePositiveInteger, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))) {
		invalidCompactClassError("LargePositiveInteger");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassFloat, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassFloatCompactIndex))) {
		invalidCompactClassError("Float");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassBlockClosure, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassBlockClosureCompactIndex))) {
		invalidCompactClassError("BlockClosure");
	}

	/* begin checkCompactIndex:isClass:named: */
	if ((fetchPointerofObject(ClassMethodContext, GIV(specialObjectsOop))) != (knownClassAtIndex(ClassMethodContextCompactIndex))) {
		invalidCompactClassError("MethodContext");
	}
	GIV(classByteArrayCompactIndex) = compactIndexOfClass(fetchPointerofObject(ClassByteArray, GIV(specialObjectsOop)));
}


/*	Support for embedded images. Check that the first few bytes of a potential
	header and answer if it
	looks like something the VM can load,
	The method checks the first three fields of the header (magic, header size
	& data size) & the total size.
	The magic number should be correct.
	The header size should be correct.
	The size of the data should be at least as long as the headerSize plus the
	data size in the header */
/*	Need at least headerSize bytes; no point going further if not... */

	/* StackInterpreter>>#checkImageHeaderFromBytes:AndSize: */
sqInt
checkImageHeaderFromBytesAndSize(char *bytes, sqInt totalSize)
{
    sqInt dataSize;
    sqInt headerSize;
    int version;

	if (totalSize < (BytesPerWord * 16)) {
		return 0;
	}
	version = long32At(bytes);
	headerSize = long32At(bytes + 4);
	dataSize = longAt(bytes + 8);
	if (!(readableFormat(version))) {
		if (!(readableFormat(SQ_SWAP_4_BYTES(version)))) {
			return 0;
		}
		headerSize = byteSwapped(headerSize);
		dataSize = byteSwapped(dataSize);
	}
	return (headerSize == (BytesPerWord * 16))
	 && (totalSize >= (headerSize + dataSize));
}


/*	Read and verify the image file version number and answer it.
	Assign through rawVersionPtr the unswapped version number. The caller can
	then infer if the given image file needs to be byte-swapped by seeing if
	the returned value
	equals tha assigned through rawVersionPtr.
	0 is answered if no valid version could be found. */

	/* StackInterpreter>>#checkImageVersionFrom:startingAt:assignRawVersion: */
static NoDbgRegParms sqInt
checkImageVersionFromstartingAtassignRawVersion(sqImageFile f, squeakFileOffsetType imageOffset, sqInt *rawVersionPtr)
{
    sqInt version;

	rawVersionPtr[0] = 0;
	sqImageFileSeek(f, imageOffset);
	version = getWord32FromFileswap(f, 0);
	rawVersionPtr[0] = version;
	if (readableFormat(version)) {
		return version;
	}
	sqImageFileSeek(f, imageOffset);
	version = getWord32FromFileswap(f, 1);
	if (!(/* isLikelyImageVersion: */
			(((rawVersionPtr[0]) / 100) == 65)
		 || (((rawVersionPtr[0]) / 1000) == 68))) {
		rawVersionPtr[0] = version;
	}
	if (readableFormat(version)) {
		return version;
	}
	if (!imageOffset) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */
		sqImageFileSeek(f, 0x200);
		version = getWord32FromFileswap(f, 0);
		if (!(/* isLikelyImageVersion: */
				(((rawVersionPtr[0]) / 100) == 65)
			 || (((rawVersionPtr[0]) / 1000) == 68))) {
			rawVersionPtr[0] = version;
		}
		if (readableFormat(version)) {
			return version;
		}
		sqImageFileSeek(f, 0x200);
		version = getWord32FromFileswap(f, 1);
		if (!(/* isLikelyImageVersion: */
				(((rawVersionPtr[0]) / 100) == 65)
			 || (((rawVersionPtr[0]) / 1000) == 68))) {
			rawVersionPtr[0] = version;
		}
		if (readableFormat(version)) {
			return version;
		}
	}
	if (!(/* isLikelyImageVersion: */
			(((rawVersionPtr[0]) / 100) == 65)
		 || (((rawVersionPtr[0]) / 1000) == 68))) {
		rawVersionPtr[0] = version;
	}
	return 0;
}


/*	Byte-swap the words of all bytes objects in a range of the 
	image, including Strings, ByteArrays, and CompiledMethods.
	This returns these objects to their original byte ordering 
	after blindly byte-swapping the entire image. For compiled 
	methods, byte-swap only their bytecodes part.
	Ensure floats are in platform-order. */

	/* StackInterpreter>>#convertFloatsToPlatformOrder */
static sqInt
convertFloatsToPlatformOrder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;
    int temp;

	if ((vmEndianness()) == GIV(imageFloatsBigEndian)) {
		return null;
	}
	assert(ClassFloatCompactIndex != 0);

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if ((classIndexOf(objSqInt)) == ClassFloatCompactIndex) {
				temp = long32At(objSqInt + BaseHeaderSize);
				long32Atput(objSqInt + BaseHeaderSize, long32At((objSqInt + BaseHeaderSize) + 4));
				long32Atput((objSqInt + BaseHeaderSize) + 4, temp);
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
		return 0;
}


/*	For marking the end of a leak check print message */

	/* StackInterpreter>>#eekcr */
NeverInline void
eekcr(void)
{
	printf("\n");
}

	/* StackInterpreter>>#elementsPerPrintOopLine */
static sqInt
elementsPerPrintOopLine(void)
{
	return 5;
}


/*	Ensure the image data has been updated to suit the current VM. */

	/* StackInterpreter>>#ensureImageFormatIsUpToDate: */
static NoDbgRegParms void
ensureImageFormatIsUpToDate(sqInt swapBytes)
{
	if (swapBytes) {
		reverseBytesInImage();
	}
	else {
		convertFloatsToPlatformOrder();
	}
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

	/* StackInterpreter>>#fetchStackPointerOf: */
static NoDbgRegParms sqInt
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = fetchPointerofObject(StackPointerIndex, aContext);
	if (!((((sp) & 7) == 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 3))) < (lengthOf(aContext)));
	return (sp >> 3);
}

	/* StackInterpreter>>#firstBytecodeOfAlternateHeader:method: */
static NoDbgRegParms usqInt
firstBytecodeOfAlternateHeadermethod(sqInt methodHeader, sqInt theMethod)
{
	return (theMethod + ((LiteralStart + (((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
}

	/* StackInterpreter>>#flush */
void
flush(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	fflush(GIV(transcript));
}

	/* StackInterpreter>>#followLiteral:ofMethod: */
static NoDbgRegParms sqInt
followLiteralofMethod(sqInt offset, sqInt methodPointer)
{
	return followFieldofObject(offset + LiteralStart, methodPointer);
}


/*	Answer the next 32 or 64 bit word read from aFile, byte-swapped according
	to the swapFlag.
 */

	/* StackInterpreter>>#getLongFromFile:swap: */
static NoDbgRegParms sqInt
getLongFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead((&w), sizeof(w), 1, aFile);
	return (swapFlag
			? byteSwapped(w)
			: w);
}


/*	Answer the next 16 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getShortFromFile:swap: */
static NoDbgRegParms usqInt
getShortFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    unsigned short w;

	w = 0;
	sqImageFileRead((&w), sizeof(unsigned short), 1, aFile);
	return (swapFlag
			? ((((usqInt)(w)) >> 8) & 0xFF) | (((w & 0xFF) << 8))
			: w);
}


/*	Answer the next 32 bit word read from aFile, byte-swapped according to the
	swapFlag. 
 */

	/* StackInterpreter>>#getWord32FromFile:swap: */
static NoDbgRegParms sqInt
getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    int w;

	w = 0;
	sqImageFileRead((&w), sizeof(int), 1, aFile);
	return (swapFlag
			? SQ_SWAP_4_BYTES(w)
			: w);
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

	/* StackInterpreter>>#highBit: */
sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */
	shifted = anUnsignedValue;
	bitNo = 0;
#  if BytesPerWord > 4
	if (!(shifted < (0x100000000LL))) {
		shifted = (shifted) >> 32;
		bitNo += 32;
	}
#  endif

	if (!(shifted < (0x10000))) {
		shifted = (shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (0x100))) {
		shifted = (shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (16))) {
		shifted = (shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (4))) {
		shifted = (shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (2))) {
		shifted = (shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	With the full block implementation a CompiledBlock's method is found along
	the chain through the last literal. See CompiledBlock>>#method. Answer
	the home mehtod, or nilObj if it cannot be found. */

	/* StackInterpreter>>#homeMethodOf: */
sqInt
homeMethodOf(sqInt aMethodOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLiteral;
    sqInt methodChain;

	assert(isOopCompiledMethod(aMethodOop));
	methodChain = aMethodOop;
	while (1) {
		lastLiteral = ultimateLiteralOf(methodChain);
		if (!(isOopCompiledMethod(lastLiteral))) {
			return methodChain;
		}
		if (!(isOopCompiledMethod(lastLiteral))) {
			return GIV(nilObj);
		}
		methodChain = lastLiteral;
	}
	return 0;
}


/*	Snapshot image format can include additional state flags.
	Currently that is the state of multipleBytecodeSetsActive.
	Mask it out when checking compatibility with this interpreter. */

	/* StackInterpreter>>#imageFormatVersionFromSnapshot: */
static NoDbgRegParms sqInt
imageFormatVersionFromSnapshot(sqInt imageVersion)
{
	return ((imageVersion | MultipleBytecodeSetsBitmask) - MultipleBytecodeSetsBitmask);
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

	/* StackInterpreter>>#includesBehavior:ThatOf: */
static NoDbgRegParms sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		theClass = followObjFieldofObject(SuperclassIndex, theClass);
	}
	return 0;
}


/*	Initialize metaclassNumSlots and thisClassIndex which are used in debug
	printing, and
	classNameIndex which is used not only for debug printing but for
	is:KindOf: & is:MemberOf:
	via classNameOf:is: (evil but a reality we have to accept). */

	/* StackInterpreter>>#initializeExtraClassInstVarIndices */
static void
initializeExtraClassInstVarIndices(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt i;
    sqInt oop;
    sqInt toDoLimit;
    sqInt toDoLimit1;

	classArrayObj = fetchPointerofObject(ClassArray, GIV(specialObjectsOop));
	classArrayClass = fetchClassOfNonImm(classArrayObj);

	/* determine actual Metaclass instSize */
	GIV(metaclassNumSlots) = numSlotsOf(classArrayClass);

	/* default */
	GIV(thisClassIndex) = 5;
	toDoLimit = numSlotsOf(classArrayClass);
	for (i = (InstanceSpecificationIndex + 1); i <= toDoLimit; i += 1) {
		if ((fetchPointerofObject(i - 1, classArrayClass)) == classArrayObj) {
			GIV(thisClassIndex) = i - 1;
		}
	}

	/* default */
	GIV(classNameIndex) = 6;
	toDoLimit1 = numSlotsOf(classArrayObj);
	for (i = (InstanceSpecificationIndex + 1); i <= toDoLimit1; i += 1) {
		oop = fetchPointerofObject(i - 1, classArrayObj);
		if (objectequalsString(oop, "Array")) {
			GIV(classNameIndex) = i - 1;
		}
	}
}

	/* StackInterpreter>>#isBooleanObject: */
static NoDbgRegParms sqInt
isBooleanObject(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (oop == GIV(trueObj))
	 || (oop == GIV(falseObj));
}

	/* StackInterpreter>>#isFloatObject: */
int
isFloatObject(sqInt oop)
{
    sqInt tagBits;

	return /* isFloatInstance: */
		((tagBits = oop & (tagMask()))
			? tagBits == (smallFloatTag())
			: (classIndexOf(oop)) == ClassFloatCompactIndex);
}


/*	Answer true if the oop is kind of Integer (Small or Large). */

	/* StackInterpreter>>#isKindOfInteger: */
sqInt
isKindOfInteger(sqInt oop)
{
	return ((((oop) & 7) == 1))
	 || (isLargeIntegerInstance(oop));
}

	/* StackInterpreter>>#isLargeIntegerObject: */
sqInt
isLargeIntegerObject(sqInt oop)
{
	return isLargeIntegerInstance(oop);
}

	/* StackInterpreter>>#isLargeNegativeIntegerObject: */
sqInt
isLargeNegativeIntegerObject(sqInt oop)
{
	return isInstanceOfClassLargeNegativeInteger(oop);
}

	/* StackInterpreter>>#isLargePositiveIntegerObject: */
sqInt
isLargePositiveIntegerObject(sqInt oop)
{
	return isInstanceOfClassLargePositiveInteger(oop);
}

	/* StackInterpreter>>#isQuickPrimitiveIndex: */
int
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 0x100) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

	/* StackInterpreter>>#isReadMediatedContextInstVarIndex: */
int
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

	/* StackInterpreter>>#isWriteMediatedContextInstVarIndex: */
int
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Support for external primitives. */

	/* StackInterpreter>>#is:KindOfClass: */
sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oopClass;

	oopClass = fetchClassOf(oop);
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = followObjFieldofObject(SuperclassIndex, oopClass);
	}
	return 0;
}

	/* StackInterpreter>>#lengthOfNameOfClass: */
static NoDbgRegParms sqInt
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numSlots;
    usqInt numSlotsUsqInt;
    sqInt objOop;

	numSlots = numSlotsOf(classOop);
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(fetchPointerofObject(GIV(thisClassIndex), classOop));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	objOop = fetchPointerofObject(GIV(classNameIndex), classOop);

	/* begin lengthOf: */
	fmt = formatOf(objOop);
	numSlotsUsqInt = numSlotsOfAny(objOop);
	if (fmt <= (ephemeronFormat())) {
		return numSlotsUsqInt;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */
		return ((numSlotsUsqInt << (shiftForWord()))) - (fmt & 7);
	}
	if (fmt >= (firstShortFormat())) {
		return ((numSlotsUsqInt << ((shiftForWord()) - 1))) - (fmt & 3);
	}
	if (fmt >= (firstLongFormat())) {
		return ((numSlotsUsqInt << ((shiftForWord()) - 2))) - (fmt & 1);
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		return numSlotsUsqInt;
	}
	return 0;
}

	/* StackInterpreter>>#literal:ofMethod: */
sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return fetchPointerofObject(offset + LiteralStart, methodPointer);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#longPrintOop: */
void
longPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    int byte;
    char *className;
    sqInt cls;
    sqInt column;
    sqInt fieldOop;
    sqInt fmt;
    sqInt fmtSqInt;
    sqInt i;
    usqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt length;
    usqInt numSlots;
    usqInt startIP;

	length = 0;
	if (isImmediate(oop)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (isFreeObject(oop)) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	if ((cls = fetchClassOfNonImm(oop))) {
		className = nameOfClasslengthInto(cls, (&length));
		fprintf(GIV(transcript),
				"%p: a(n) %.*s",
				((void *)oop),
				((int) length),
				className);
		fprintf(GIV(transcript),
				"(%" PRIxSQINT "=>%p)",
				classIndexOf(oop),
				((void *)cls));
	}
	else {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
	}
	fmt = formatOf(oop);
	fprintf(GIV(transcript),
			" format %" PRIxSQINT "",
			fmt);
	if (fmt > (lastPointerFormat())) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	else {
		if (isIndexableFormat(fmt)) {
			/* begin lengthOf: */
			fmtSqInt = formatOf(oop);
			numSlots = numSlotsOfAny(oop);
			if (fmtSqInt <= (ephemeronFormat())) {
				len = numSlots;
				goto l1;
			}
			if (fmtSqInt >= (firstByteFormat())) {

				/* bytes, including CompiledMethod */
				len = ((numSlots << (shiftForWord()))) - (fmtSqInt & 7);
				goto l1;
			}
			if (fmtSqInt >= (firstShortFormat())) {
				len = ((numSlots << ((shiftForWord()) - 1))) - (fmtSqInt & 3);
				goto l1;
			}
			if (fmtSqInt >= (firstLongFormat())) {
				len = ((numSlots << ((shiftForWord()) - 2))) - (fmtSqInt & 1);
				goto l1;
			}
			if (fmtSqInt == (sixtyFourBitIndexableFormat())) {
				len = numSlots;
				goto l1;
			}
			len = 0;
l1:	/* end lengthOf: */;
			fprintf(GIV(transcript),
					" size %" PRIdSQINT "",
					len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}

	/* begin printHeaderTypeOf:on: */
	fprintf(GIV(transcript),
			" hdr%d %c%c%c%c%c",
			(hasOverflowHeader(oop)
			? 16
			: 8),
			(isImmutable(oop)
			? 'i'
			: '.'),
			(isRemembered(oop)
			? 'r'
			: '.'),
			(isPinned(oop)
			? 'p'
			: '.'),
			(isMarked(oop)
			? 'm'
			: '.'),
			(isGrey(oop)
			? 'g'
			: '.'));
	print(" hash ");
	printHex(rawHashBitsOf(oop));
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop)))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					(isIndirectAlien(oop)
					? "indirect"
					: (isPointerAlien(oop)
							? "pointer"
							: "direct")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(fetchPointerofObject(ClassByteString, GIV(specialObjectsOop))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	startIP = (fmt >= (firstCompiledMethodFormat())
				? (startPCOfMethod(oop)) / BytesPerWord
				: numSlotsOf(oop));
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = fetchPointerofObject(i - 1, oop);

			/* begin space */
			printChar(' ');
			printNum(i - 1);

			/* begin space */
			printChar(' ');
			printHex(fieldOop);

			/* begin space */
			printChar(' ');
			if ((i == 1)
			 && (isCompiledMethod(oop))) {
				/* begin printMethodHeaderOop: */
				printDecodeMethodHeaderOop(fieldOop);
			}
			else {
				printOopShortInner(fieldOop);
			}
			cr();
		}
	}
	if (isCompiledMethod(oop)) {
		startIP = (startPCOfMethod(oop)) + 1;

		/* begin lengthOf: */
		fmtSqInt = formatOf(oop);
		numSlots = numSlotsOfAny(oop);
		if (fmtSqInt <= (ephemeronFormat())) {
			lastIndex = numSlots;
			goto l2;
		}
		if (fmtSqInt >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			lastIndex = ((numSlots << (shiftForWord()))) - (fmtSqInt & 7);
			goto l2;
		}
		if (fmtSqInt >= (firstShortFormat())) {
			lastIndex = ((numSlots << ((shiftForWord()) - 1))) - (fmtSqInt & 3);
			goto l2;
		}
		if (fmtSqInt >= (firstLongFormat())) {
			lastIndex = ((numSlots << ((shiftForWord()) - 2))) - (fmtSqInt & 1);
			goto l2;
		}
		if (fmtSqInt == (sixtyFourBitIndexableFormat())) {
			lastIndex = numSlots;
			goto l2;
		}
		lastIndex = 0;
l2:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p ",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = ((int) (fetchByteofObject(index - 1, oop)));
			fprintf(GIV(transcript),
					"%02x/%-+3d%c",
					byte,
					byte,
					(column == 8
					? '\n'
					: ' '));
			if (((column += 1)) > 8) {
				column = 1;
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			print("...");
		}
		if (((column >= 2) && (column <= 7))) {
			cr();
		}
	}
	else {
		if (startIP > lastIndex) {
			print("...");
			cr();
		}
	}
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#longStoreBytecodeForHeader: */
sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return ((((sqLong) methodHeader)) < 0
				? AltLongStoreBytecode
				: LongStoreBytecode);
}


/*	Answer the selector of a method, assuming its penultimate literal is
	either a symbol or a pointer object whose first slot references the method
	and whose second slot is a symbol (i.e. an AdditionalMethodState). If a
	Symbol can't be found answer nil. This isn't satisfactory, as it puts a
	lot of information
	into the VM, but it is needed for adequate crash debugging at Cadence.
	With full blocks as of 9/2016 the last literal of a CompiledBlock is a
	back pointer
	to the enclosing block or compiled method. */

	/* StackInterpreter>>#maybeSelectorOfMethod: */
sqInt
maybeSelectorOfMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeSelector;
    sqInt penultimateLiteral;
    sqInt ultimateLiteral;

	assert(isOopCompiledMethod(methodObj));
	ultimateLiteral = ultimateLiteralOf(methodObj);
	if (isOopCompiledMethod(ultimateLiteral)) {
		return maybeSelectorOfMethod(ultimateLiteral);
	}
	penultimateLiteral = penultimateLiteralOf(methodObj);
	if (isWordsOrBytes(penultimateLiteral)) {
		return ((fetchClassTagOfNonImm(penultimateLiteral)) == (fetchClassTagOfNonImm(fetchPointerofObject(SelectorDoesNotUnderstand, GIV(specialObjectsOop))))
				? penultimateLiteral
				: 0);
	}
	return ((isPointers(penultimateLiteral))
	 && (((numSlotsOf(penultimateLiteral)) >= 2)
	 && (((fetchPointerofObject(0, penultimateLiteral)) == methodObj)
	 && (((maybeSelector = fetchPointerofObject(1, penultimateLiteral)),
	(isWordsOrBytes(maybeSelector))
		 && ((fetchClassTagOfNonImm(maybeSelector)) == (fetchClassTagOfNonImm(fetchPointerofObject(SelectorDoesNotUnderstand, GIV(specialObjectsOop)))))))))
			? maybeSelector
			: 0);
}

	/* StackInterpreter>>#methodClassAssociationOf: */
sqInt
methodClassAssociationOf(sqInt methodPointer)
{
	return literalofMethod((literalCountOf(methodPointer)) - 1, methodPointer);
}


/*	Answer the method class of a method which is the value of an Association
	in the last literal,
	or answer nil if there isn't one.
	Using a read barrier here simplifies the become implementation and costs
	very little
	because the class index and ValueIndex of the association almost certainly
	share a cache line. */

	/* StackInterpreter>>#methodClassOf: */
sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;

	literal = followLiteralofMethod((literalCountOf(methodPointer)) - 1, methodPointer);
	return ((literal != GIV(nilObj))
	 && (isPointers(literal))
			? (assert((numSlotsOf(literal)) > ValueIndex),
			followFieldofObject(ValueIndex, literal))
			: GIV(nilObj));
}


/*	Note: We now have 10 bits of primitive index, but they are in two places
	for temporary backward compatibility. The time to unpack is negligible,
	since the derived primitive function pointer is stored in the method
	cache.  */

	/* StackInterpreter>>#methodHeaderHasPrimitive: */
static NoDbgRegParms int
methodHeaderHasPrimitive(sqInt methodHeader)
{
	return ((methodHeader & AlternateHeaderHasPrimFlag) != 0);
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass: */
static NoDbgRegParms char *
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;

	numSlots = numSlotsOf(classOop);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = fetchPointerofObject(GIV(thisClassIndex), classOop);
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClass(fetchPointerofObject(GIV(thisClassIndex), classOop));
		}
		return "bad class";
	}
	if (!((numSlots > GIV(classNameIndex))
		 && (((maybeNameOop = fetchPointerofObject(GIV(classNameIndex), classOop)),
		isBytes(maybeNameOop))))) {
		return "bad class";
	}
	return firstIndexableField(maybeNameOop);
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

	/* StackInterpreter>>#nameOfClass:lengthInto: */
static NoDbgRegParms char *
nameOfClasslengthInto(sqInt classOop, sqInt *lengthPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maybeNameOop;
    sqInt maybeThisClassOop;
    usqInt numSlots;

	numSlots = numSlotsOf(classOop);
	if (numSlots == GIV(metaclassNumSlots)) {
		maybeThisClassOop = fetchPointerofObject(GIV(thisClassIndex), classOop);
		if (addressCouldBeClassObj(maybeThisClassOop)) {
			return nameOfClasslengthInto(fetchPointerofObject(GIV(thisClassIndex), classOop), lengthPtr);
		}
		lengthPtr[0] = 9;
		return "bad class";
	}
	if ((numSlots > GIV(classNameIndex))
	 && (((maybeNameOop = fetchPointerofObject(GIV(classNameIndex), classOop)),
	isBytes(maybeNameOop)))) {
		lengthPtr[0] = (numBytesOfBytes(maybeNameOop));
		return firstIndexableField(maybeNameOop);
	}
	lengthPtr[0] = 9;
	return "bad class";
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

	/* StackInterpreter>>#objCouldBeClassObj: */
sqInt
objCouldBeClassObj(sqInt objOop)
{
    sqInt fieldOop;

	return (isPointersNonImm(objOop))
	 && (((numSlotsOfAny(objOop)) > InstanceSpecificationIndex)
	 && (((fieldOop = fetchPointerofObject(SuperclassIndex, objOop)),
	((addressCouldBeObj(fieldOop))
		 && ((isPointersNonImm(fieldOop))
		 || ((isOopForwarded(fieldOop))
		 && (isPointers(followForwarded(fieldOop))))))
		 && (((fieldOop = fetchPointerofObject(MethodDictionaryIndex, objOop)),
		((addressCouldBeObj(fieldOop))
			 && ((isPointersNonImm(fieldOop))
			 || ((isOopForwarded(fieldOop))
			 && (isPointers(followForwarded(fieldOop))))))
			 && (((((fetchPointerofObject(InstanceSpecificationIndex, objOop))) & 7) == 1)))))));
}

	/* StackInterpreter>>#object:beginsWithString:ofSize: */
static NoDbgRegParms sqInt
objectbeginsWithStringofSize(sqInt anOop, char *aCString, sqInt aCStringStrlen)
{
	return (isBytes(anOop))
	 && ((!(isCompiledMethod(anOop)))
	 && (((numBytesOfBytes(anOop)) >= aCStringStrlen)
	 && ((strncmp(aCString, firstIndexableField(anOop), aCStringStrlen)) == 0)));
}

	/* StackInterpreter>>#object:equalsString: */
static NoDbgRegParms sqInt
objectequalsString(sqInt anOop, char *aCString)
{
    sqInt len;

	len = strlen(aCString);
	return objectequalsStringofSize(anOop, aCString, len);
}

	/* StackInterpreter>>#object:equalsString:ofSize: */
static NoDbgRegParms sqInt
objectequalsStringofSize(sqInt anOop, char *aCString, sqInt aCStringStrlen)
{
	return (isBytes(anOop))
	 && ((!(isCompiledMethod(anOop)))
	 && (((numBytesOfBytes(anOop)) == aCStringStrlen)
	 && ((strncmp(aCString, firstIndexableField(anOop), aCStringStrlen)) == 0)));
}

	/* StackInterpreter>>#penultimateLiteralOf: */
static NoDbgRegParms sqInt
penultimateLiteralOf(sqInt aMethodOop)
{
	assert(isOopCompiledMethod(aMethodOop));
	return literalofMethod((literalCountOf(aMethodOop)) - 2, aMethodOop);
}


/*	Note: With the Squeak V3 format we now have 10 bits of primitive index,
	but they are
	in two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the
	Spur format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

	/* StackInterpreter>>#primitiveIndexOfMethod:header: */
sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    usqInt firstBytecode;

	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = firstBytecodeOfAlternateHeadermethod(methodHeader, theMethod)),
			(byteAt(firstBytecode + 1)) + ((((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
}

	/* StackInterpreter>>#primitiveIndexOf: */
sqInt
primitiveIndexOf(sqInt methodPointer)
{
    usqInt firstBytecode;
    sqInt methodHeader;

	methodHeader = methodHeaderOf(methodPointer);

	/* begin primitiveIndexOfMethod:header: */
	return (((methodHeader & AlternateHeaderHasPrimFlag) != 0)
			? ((firstBytecode = firstBytecodeOfAlternateHeadermethod(methodHeader, methodPointer)),
			(byteAt(firstBytecode + 1)) + ((((usqInt)((byteAt(firstBytecode + 2))) << 8))))
			: 0);
}

	/* StackInterpreter>>#printDecodeMethodHeaderOop: */
static NoDbgRegParms void
printDecodeMethodHeaderOop(sqInt methodHeaderOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin printOopShort: */
	printOopShortInner(methodHeaderOop);
	fflush(GIV(transcript));
	if (methodHeaderHasPrimitive(methodHeaderOop)) {
		print(" hasPrim");
	}
	if (methodHeaderOop & LargeContextBit) {
		print(" largeFrame");
	}
	if (((methodHeaderOop >> 3)) < 0) {
		print(" altSet");
	}
	print(" nLits ");
	printNum(
		(/* begin literalCountOfMethodHeader: */
			assert((((methodHeaderOop) & 7) == 1)),
		/* literalCountOfAlternateHeader: */
			((methodHeaderOop >> 3)) & AlternateHeaderNumLiteralsMask));
	print(" nArgs ");
	printNum(argumentCountOfMethodHeader(methodHeaderOop));
	print(" nTemps ");
	printNum((((usqInt)(methodHeaderOop)) >> MethodHeaderTempCountShift) & 0x3F);
}


/*	Print n in hex, in the form '1234' (no prefix), unpadded */

	/* StackInterpreter>>#printHexnpnp: */
static NoDbgRegParms sqInt
printHexnpnp(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fprintf(GIV(transcript),
			"%" PRIxSQINT "",
			n);
}


/*	Print n in hex, in the form '0x1234', unpadded */

	/* StackInterpreter>>#printHexnp: */
static NoDbgRegParms sqInt
printHexnp(usqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return fprintf(GIV(transcript),
			"%p",
			((void *)n));
}


/*	Print all methods whose penultimate literal is either selector,
	or an object whose first inst var is the method and whose
	second is selector (e.g. an AdditionalMethodState). */
/*	useful for VM debugging */

	/* StackInterpreter>>#printLikelyImplementorsOfSelector: */
void
printLikelyImplementorsOfSelector(sqInt selector)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt methodClassAssociation;
    sqInt objSqInt;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objSqInt = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((objSqInt % (allocationUnit())) == 0);
		if (!(oopisLessThan(objSqInt, GIV(endOfMemory)))) break;
		assert((long64At(objSqInt)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(objSqInt);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(objSqInt)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			if ((isCompiledMethod(objSqInt))
			 && ((maybeSelectorOfMethod(objSqInt)) == selector)) {

				/* try and print the key of the method class association (the name of the implementing class) */
				methodClassAssociation = methodClassAssociationOf(objSqInt);
				printHexnp(objSqInt);

				/* begin space */
				printChar(' ');
				printOopShortInner(((isPointers(methodClassAssociation))
				 && ((numSlotsOf(methodClassAssociation)) >= 2)
						? fetchPointerofObject(0, methodClassAssociation)
						: methodClassAssociation));
				cr();
			}
		}
		prevPrevObj = prevObj;
		prevObj = objSqInt;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(objSqInt);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			objSqInt = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		objSqInt = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(objSqInt, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(objSqInt, prevObj));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCache */
void
printMethodCache(void)
{
	printMethodCacheFor(-1);
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodCacheFor: */
void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqIntptr_t c;
    int i;
    sqIntptr_t m;
    sqIntptr_t methodCache[MethodCacheSize + 1 /* 4097 */];
    sqInt n;
    sqIntptr_t p;
    sqIntptr_t s;

	n = 0;
	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = methodCache[i + MethodCacheSelector];
		c = methodCache[i + MethodCacheClass];
		m = methodCache[i + MethodCacheMethod];
		p = methodCache[i + MethodCachePrimFunction];
		if (((thing == -1)
		 || ((s == thing)
		 || ((c == thing)
		 || ((p == thing)
		 || (m == thing)))))
		 && ((addressCouldBeOop(s))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(classForClassTag(c))))))) {
			n += 1;
			fprintf(GIV(transcript),
					"%d %x\n\t",
					i,
					i);
			if (isBytesNonImm(s)) {
				fprintf(GIV(transcript),
						"%p %.*s\n",
						((void *)s),
						((int) (numBytesOfBytes(s))),
						((char *)(firstIndexableField(s))));
			}
			else {
				shortPrintOop(s);
			}

			/* begin tab */
			printChar('\t');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				printNum(c);

				/* begin space */
				printChar(' ');
				printHexnp(c);

				/* begin space */
				printChar(' ');
				shortPrintOop(classForClassTag(c));
			}

			/* begin tab */
			printChar('\t');
			shortPrintOop(m);

			/* begin tab */
			printChar('\t');
			if (p > 0x400) {
				printHexnp(p);
			}
			else {
				printNum(p);
			}
			cr();
		}
	}
	if (n > 1) {
		printNum(n);
		cr();
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionaryOf: */
void
printMethodDictionaryOf(sqInt behavior)
{
	printMethodDictionary(fetchPointerofObject(MethodDictionaryIndex, behavior));
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printMethodDictionary: */
void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;
    sqInt toDoLimit;

	methodArray = fetchPointerofObject(MethodArrayIndex, dictionary);
	toDoLimit = (numSlotsOf(dictionary)) - 1;
	for (index = SelectorStart; index <= toDoLimit; index += 1) {
		selector = fetchPointerofObject(index, dictionary);
		if (selector != GIV(nilObj)) {
			meth = fetchPointerofObject(index - SelectorStart, methodArray);

			/* begin printOopShort: */
			printOopShortInner(selector);
			fflush(GIV(transcript));
			print(" => ");

			/* begin printOopShort: */
			printOopShortInner(meth);
			fflush(GIV(transcript));
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			print(")\n");
		}
	}
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

	/* StackInterpreter>>#printNameOfClass:count: */
static NoDbgRegParms void
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;

	if (!GIV(classNameIndex)) {
		print("??nil cnidx??");
		return;
	}
	if ((!classOop)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class");
		return;
	}
	numSlots = numSlotsOf(classOop);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(fetchPointerofObject(GIV(thisClassIndex), classOop), cnt - 1);
		print(" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class");
		}
		else {
			printStringOf(fetchPointerofObject(GIV(classNameIndex), classOop));
		}
	}
}

	/* StackInterpreter>>#printOopShortInner: */
static NoDbgRegParms void
printOopShortInner(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classLookupKey;
    sqInt classOop;
    double f;
    char *name;
    sqInt nameLen;
    double result;
    sqInt tagBits;
    sqInt target;

	if (isImmediate(oop)) {
		if (((oop & (characterTag())) != 0)) {
			fprintf(GIV(transcript),
					"$%c(%" PRIxSQINT ")",
					((int) (characterValueOf(oop))),
					characterValueOf(oop));
			return;
		}
		if ((((oop) & 7) == 1)) {
			fprintf(GIV(transcript),
					"%" PRIdSQINT "(0x%" PRIxSQINT ")",
					(oop >> 3),
					(oop >> 3));
			return;
		}
		if (((oop & (smallFloatTag())) != 0)) {
			fprintf(GIV(transcript),
					"%g(0x%" PRIxSQINT ")",
					noFailFloatValueOf(oop),
					oop);
			return;
		}
		fprintf(GIV(transcript),
				"unknown immediate %p",
				((void *)oop));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		print((oop & ((allocationUnit()) - 1)
				? " is misaligned"
				: whereIs(oop)));
		return;
	}
	if (isFreeObject(oop)) {
		print(" is a free chunk");
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		target = followForwarded(oop);
		fprintf(GIV(transcript),
				" is a forwarder to %p",
				((void *)target));
		return;
	}
	if (/* isFloatInstance: */
		((tagBits = oop & (tagMask()))
			? tagBits == (smallFloatTag())
			: (classIndexOf(oop)) == ClassFloatCompactIndex)) {
		/* begin noFailFloatValueOf: */
		assert(isFloatInstance(oop));
		if (oop & (tagMask())) {
			result = smallFloatValueOf(oop);
		}
		else {
			fetchFloatAtinto(oop + BaseHeaderSize, result);
		}
		f = result;

		/* begin printFloat: */
		fprintf(GIV(transcript),
				"%g",
				f);
		return;
	}
	classOop = fetchClassOfNonImm(oop);
	if (!(addressCouldBeObj(classOop))) {
		print("a ??");
		return;
	}
	if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		return;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		return;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		return;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		return;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (!nameLen) {
		print("a ??");
		return;
	}
	name = nameOfClass(classOop);
	if ((isBytes(oop))
	 && (nameLen >= 6)) {
		if (!(strncmp((name + nameLen) - 6, "String", 6))) {

			/* strncmp is weird */
			printChar('\'');
			printStringOf(oop);
			printChar('\'');
			return;
		}
		if (!(strncmp((name + nameLen) - 6, "Symbol", 6))) {

			/* strncmp is weird */
			printChar('#');
			printStringOf(oop);
			return;
		}
	}
	if ((nameLen == 9)
	 && ((strncmp(name, "Character", 9)) == 0)) {
		printChar('$');
		printChar(((fetchPointerofObject(0, oop)) >> 3));
		return;
	}
	fprintf(GIV(transcript),
			"a(n) %.*s",
			((int) nameLen),
			name);
	if ((isPointersNonImm(oop))
	 && (((instanceSizeOf(classOop)) == (ValueIndex + 1))
	 && (isBytes(fetchPointerofObject(KeyIndex, oop))))) {
		classLookupKey = fetchClassOfNonImm(splObj(SchedulerAssociation));
		while (1) {
			if (classLookupKey == GIV(nilObj)) {
				return;
			}
			if ((instanceSizeOf(classLookupKey)) == (KeyIndex + 1)) break;
			classLookupKey = followObjFieldofObject(SuperclassIndex, classLookupKey);
		}
		if (includesBehaviorThatOf(classOop, classLookupKey)) {
			/* begin space */
			printChar(' ');
			printOopShortInner(fetchPointerofObject(KeyIndex, oop));
			print(" -> ");
			printHexnp(fetchPointerofObject(ValueIndex, oop));
		}
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#printOop: */
void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    char *className;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt fmtSqInt;
    sqInt index;
    sqInt lastIndex;
    sqInt length;
    usqInt numSlots;
    usqInt startIP;
    sqInt tagBits;

	length = 0;
	if (isImmediate(oop)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (isFreeObject(oop)) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	if (!((cls = fetchClassOfNonImm(oop)))) {
		fprintf(GIV(transcript),
				"%p has a nil class!!\n",
				((void *)oop));
		return;
	}
	className = nameOfClasslengthInto(cls, (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s",
			((void *)oop),
			((int) length),
			className);
	if (/* isFloatInstance: */
		((tagBits = oop & (tagMask()))
			? tagBits == (smallFloatTag())
			: (classIndexOf(oop)) == ClassFloatCompactIndex)) {
		fprintf(GIV(transcript),
				"\n%g\n",
				noFailFloatValueOf(oop));
		return;
	}
	fmt = formatOf(oop);
	if (fmt > (lastPointerFormat())) {
		fprintf(GIV(transcript),
				" nbytes %" PRIdSQINT "",
				numBytesOf(oop));
	}
	cr();
	if (((fmt >= (firstLongFormat())) && (fmt <= ((firstCompiledMethodFormat()) - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */
		if (isKindOfClass(oop, fetchPointerofObject(ClassAlien, GIV(specialObjectsOop)))) {
			fprintf(GIV(transcript),
					" datasize %" PRIdSQINT " %s @ %p\n",
					longAt(oop + BaseHeaderSize),
					(isIndirectAlien(oop)
					? "indirect"
					: (isPointerAlien(oop)
							? "pointer"
							: "direct")),
					startOfAlienData(oop));
			return;
		}
		if (isKindOfClass(oop, superclassOf(fetchPointerofObject(ClassByteString, GIV(specialObjectsOop))))) {
			printStringDataOfon(oop, GIV(transcript));
			return;
		}
		printNonPointerDataOfon(oop, GIV(transcript));
		return;
	}
	startIP = (fmt >= (firstCompiledMethodFormat())
				? (startPCOfMethod(oop)) / BytesPerWord
				: numSlotsOf(oop));
	lastIndex = ((0x100 < startIP) ? 0x100 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(fetchPointerofObject(index - 1, oop));

			/* begin space */
			printChar(' ');
			if (!(index % (elementsPerPrintOopLine()))) {
				cr();
			}
		}
		if (lastIndex % (elementsPerPrintOopLine())) {
			cr();
		}
	}
	if (isCompiledMethod(oop)) {
		startIP = (startPCOfMethod(oop)) + 1;

		/* begin lengthOf: */
		fmtSqInt = formatOf(oop);
		numSlots = numSlotsOfAny(oop);
		if (fmtSqInt <= (ephemeronFormat())) {
			lastIndex = numSlots;
			goto l1;
		}
		if (fmtSqInt >= (firstByteFormat())) {

			/* bytes, including CompiledMethod */
			lastIndex = ((numSlots << (shiftForWord()))) - (fmtSqInt & 7);
			goto l1;
		}
		if (fmtSqInt >= (firstShortFormat())) {
			lastIndex = ((numSlots << ((shiftForWord()) - 1))) - (fmtSqInt & 3);
			goto l1;
		}
		if (fmtSqInt >= (firstLongFormat())) {
			lastIndex = ((numSlots << ((shiftForWord()) - 2))) - (fmtSqInt & 1);
			goto l1;
		}
		if (fmtSqInt == (sixtyFourBitIndexableFormat())) {
			lastIndex = numSlots;
			goto l1;
		}
		lastIndex = 0;
l1:	/* end lengthOf: */;
		if ((lastIndex - startIP) > 0x100) {
			lastIndex = startIP + 0x100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				fprintf(GIV(transcript),
						"%10p",
						((void *)(((oop + BaseHeaderSize) + index) - 1)));
			}
			byte = fetchByteofObject(index - 1, oop);
			fprintf(GIV(transcript),
					" %02x/%-+3d",
					((int) byte),
					((int) byte));
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				cr();
			}
		}
		if ((lengthOf(oop)) > lastIndex) {
			print("...");
		}
		if (!(column == 1)) {
			cr();
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			cr();
		}
	}
}

	/* StackInterpreter>>#printStringOf: */
static NoDbgRegParms void
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt code;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if (isImmediate(oop)) {
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		return;
	}
	fmt = formatOf(oop);
	if (fmt < (firstByteFormat())) {
		return;
	}
	cnt = ((((max = 128)) < ((len = lengthOf(oop)))) ? ((max = 128)) : ((len = lengthOf(oop))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, fetchPointerofObject(ClassByteArray, GIV(specialObjectsOop)), GIV(classByteArrayCompactIndex)))
	 || (isLargeIntegerInstance(oop))) {
		while (i < cnt) {
			printHex(fetchByteofObject(i, oop));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			code = fetchByteofObject(i, oop);
			switch (code) {
			case 10:
				print("<LF>");
				break;
			case 13:
				print("<CR>");
				break;
			default:
				printChar(code);
			}
			i += 1;
		}
	}
	if (len > max) {
		print("...");
	}

	/* begin flush */
	fflush(GIV(transcript));
}


/*	Anwer if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

	/* StackInterpreter>>#readableFormat: */
sqInt
readableFormat(sqInt imageVersion)
{
	return (imageFormatVersionFromSnapshot(imageVersion)) == 68021 /* imageFormatVersion */;
}

	/* StackInterpreter>>#readImageFromFile:HeapSize:StartingAt: */
size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt allocationReserve;
    sqInt anObject;
    sqInt bytes;
    sqInt bytesRead;
    sqInt bytesToShift;
    size_t dataSize;
    sqInt firstSegSize;
    sqInt freeOldSpaceInImage;
    sqInt hdrEdenBytes;
    usqInt hdrMaxExtSemTabSize;
    usqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt headroom;
    sqInt headroomSqInt;
    usqInt heapSize;
    usqInt mem;
    usqInt minimumMemory;
    sqInt oldImageBaseAddress;
    sqInt rawVersion;
    sqInt seed;
    int swapBytes;
    sqInt version;

	rawVersion = 0;
	GIV(transcript) = stdout;
	GIV(metaclassNumSlots) = 6;
	GIV(classNameIndex) = 6;
	version = checkImageVersionFromstartingAtassignRawVersion(f, imageOffset, (&rawVersion));
	if (!version) {
		bailOutOfImageLoad(rawVersion);
	}
	swapBytes = rawVersion != version;
	GIV(multipleBytecodeSetsActive) = ((version & MultipleBytecodeSetsBitmask) != 0);
	headerStart = (sqImageFilePosition(f)) - 4;
	headerSize = getWord32FromFileswap(f, swapBytes);
	dataSize = getLongFromFileswap(f, swapBytes);
	oldImageBaseAddress = getLongFromFileswap(f, swapBytes);
	anObject = getLongFromFileswap(f, swapBytes);

	/* begin specialObjectsOop: */
	GIV(specialObjectsOop) = anObject;
	seed = getLongFromFileswap(f, swapBytes);

	/* begin lastHash: */
	GIV(lastHash) = seed;
	GIV(savedWindowSize) = getLongFromFileswap(f, swapBytes);
	headerFlags = getLongFromFileswap(f, swapBytes);
	setImageHeaderFlagsFrom(headerFlags);
	extraVMMemory = getWord32FromFileswap(f, swapBytes);
	hdrNumStackPages = getShortFromFileswap(f, swapBytes);
	GIV(numStackPages) = (desiredNumStackPages
				? desiredNumStackPages
				: (hdrNumStackPages
						? hdrNumStackPages
						: 0 /* defaultNumStackPages */));
	desiredNumStackPages = hdrNumStackPages;
	GIV(theUnknownShort) = getShortFromFileswap(f, swapBytes);
	hdrEdenBytes = getWord32FromFileswap(f, swapBytes);
	bytes = (desiredEdenBytes
				? desiredEdenBytes
				: (hdrEdenBytes
						? hdrEdenBytes
						: defaultEdenBytes()));

	/* begin edenBytes: */
	GIV(edenBytes) = bytes;
	desiredEdenBytes = hdrEdenBytes;
	hdrMaxExtSemTabSize = getShortFromFileswap(f, swapBytes);
	GIV(the2ndUnknownShort) = getShortFromFileswap(f, swapBytes);
	firstSegSize = getLongFromFileswap(f, swapBytes);

	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	allocationReserve = 0 /* interpreterAllocationReserveBytes */;
	minimumMemory = (dataSize + GIV(edenBytes)) + allocationReserve;
	freeOldSpaceInImage = getLongFromFileswap(f, swapBytes);

	/* begin initialHeadroom:givenFreeOldSpaceInImage: */
	headroomSqInt = (extraVMMemory
				? extraVMMemory
				: (!(GIV(growHeadroom))
					? 0x1000000
					: GIV(growHeadroom)));
	if (freeOldSpaceInImage >= headroomSqInt) {
		headroom = 0;
		goto l1;
	}
	if (freeOldSpaceInImage >= ((headroomSqInt * 7) / 8)) {
		headroom = headroomSqInt / 8;
		goto l1;
	}
	if (freeOldSpaceInImage >= ((headroomSqInt * 3) / 4)) {
		headroom = headroomSqInt / 4;
		goto l1;
	}
	if (freeOldSpaceInImage >= ((headroomSqInt * 5) / 8)) {
		headroom = (headroomSqInt * 3) / 8;
		goto l1;
	}
	if (freeOldSpaceInImage >= (headroomSqInt / 2)) {
		headroom = headroomSqInt / 2;
		goto l1;
	}
	headroom = headroomSqInt;
l1:	/* end initialHeadroom:givenFreeOldSpaceInImage: */;
	heapSize = roundUpHeapSize(((dataSize + headroom) + GIV(edenBytes)) + ((headroom > allocationReserve
		? 0
		: allocationReserve)));
	mem = ((usqInt)(pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, f, headerSize))));
	if (mem) {
		setHeapBasememoryLimitendOfMemory(mem, mem + heapSize, mem + dataSize);
	}
	else {
		insufficientMemoryAvailableError();
	}
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(oldSpaceStart) - oldImageBaseAddress;
	initializeInterpreter(bytesToShift);
	return dataSize;
}


/*	Byte-swap all words in memory after reading in the entire image file with
	bulk read. Contributed by Tim Rowledge.
 */
/*	First, byte-swap every word in the image. This fixes objects headers. */

	/* StackInterpreter>>#reverseBytesInImage */
static void
reverseBytesInImage(void)
{
	reverseBytesInMemory();
	updateObjectsPostByteSwap();
}


/*	Set the flags that are contained in the 7th long of the image header. */

	/* StackInterpreter>>#setImageHeaderFlagsFrom: */
static NoDbgRegParms void
setImageHeaderFlagsFrom(sqInt headerFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* so as to preserve unrecognised flags. */
	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;

	/* processHasThreadAffinity := headerFlags anyMask: 4. specific to CoInterpreterMT */
	/* flagInterpretedMethods := headerFlags anyMask: 8. specific to CoInterpreter */
	GIV(imageFloatsBigEndian) = ((!(headerFlags & 2))
				? 1
				: 0);

	/* noThreadingOfGUIThread := headerFlags anyMask: 32. specific to CoInterpreterMT */
	GIV(preemptionYields) = (!(headerFlags & 16));
	GIV(newFinalization) = ((headerFlags & 64) != 0);
	sendWheelEvents = ((headerFlags & 128) != 0);
	if (primitiveDoMixedArithmetic < 0) {

		/* i.e. has it not been set on the command line? */
		primitiveDoMixedArithmetic = (!(headerFlags & 0x100));
	}
	if (upscaleDisplayIfHighDPI < 0) {

		/* i.e. has it not been set on the command line? */
		upscaleDisplayIfHighDPI = (!(headerFlags & 0x400));
	}
}

	/* StackInterpreter>>#shortPrintOop: */
static NoDbgRegParms void
shortPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *className;
    sqInt length;

	length = 0;
	if (isImmediate(oop)) {
		printImmediateObjecton(oop, GIV(transcript));
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		printCantBeObjecton(oop, GIV(transcript));
		return;
	}
	if (isFreeObject(oop)) {
		printFreeObjecton(oop, GIV(transcript));
		return;
	}
	if ((!((longAt(oop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))))) {
		printForwarderon(oop, GIV(transcript));
		return;
	}
	className = nameOfClasslengthInto(fetchClassOfNonImm(oop), (&length));
	fprintf(GIV(transcript),
			"%p: a(n) %.*s\n",
			((void *)oop),
			((int) length),
			className);
}


/*	Answer the size of the CallPrimitive bytecode that may be used to store a
	method's primitive.
 */
/*	NewsqueakV4:	249	11111001	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */
/*	SistaV1:		248	11111000 iiiiiiii	mssjjjjj	Call Primitive #iiiiiiii + (
	jjjjj * 256) */
/*	V3+Closures:	139	11101111	iiiiiiii	jjjjjjjj	Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

	/* StackInterpreter>>#sizeOfCallPrimitiveBytecode: */
sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 3;
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

	/* StackInterpreter>>#sizeOfLongStoreTempBytecode: */
sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Zero-relative version of CompiledMethod>>startpc. */

	/* StackInterpreter>>#startPCOfMethod: */
usqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return ((literalCountOf(aCompiledMethod)) + LiteralStart) * BytesPerOop;
}


/*	Using a read barrier here simplifies the become implementation and costs
	very little because the class index and superclass almost certainly share
	a cache line. */

	/* StackInterpreter>>#superclassOf: */
static NoDbgRegParms sqInt
superclassOf(sqInt classPointer)
{
	return followObjFieldofObject(SuperclassIndex, classPointer);
}

	/* StackInterpreter>>#tempCountOf: */
usqInt
tempCountOf(sqInt methodPointer)
{
    sqInt header;

	header = methodHeaderOf(methodPointer);

	/* begin temporaryCountOfMethodHeader: */
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#temporaryCountOfMethodHeader: */
usqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt)(header)) >> MethodHeaderTempCountShift) & 0x3F;
}

	/* StackInterpreter>>#ultimateLiteralOf: */
sqInt
ultimateLiteralOf(sqInt aMethodOop)
{
	assert(isOopCompiledMethod(aMethodOop));
	return literalofMethod((literalCountOf(aMethodOop)) - 1, aMethodOop);
}


/*	Byte-swap the words of all bytes objects in the image, including Strings,
	ByteArrays, and CompiledMethods. This returns these objects to their
	original byte ordering
	after blindly byte-swapping the entire image. For compiled methods,
	byte-swap only their bytecodes part. Ensure floats are in platform-order. */

	/* StackInterpreter>>#updateObjectsPostByteSwap */
static void
updateObjectsPostByteSwap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt address;
    sqInt classIndex;
    sqInt fmt;
    sqInt followingWord;
    usqInt followingWordAddress;
    sqInt methodHeader;
    sqInt obj;
    sqInt prevObj;
    sqInt prevPrevObj;
    sqInt startObject;
    int swapFloatWords;
    sqInt temp;
    sqInt wordAddr;

	swapFloatWords = (vmEndianness()) != GIV(imageFloatsBigEndian);
	assert(ClassFloatCompactIndex != 0);

	/* begin allObjectsDo: */
	/* begin startAddressForBridgedHeapEnumeration */
	if (GIV(pastSpaceStart) > (((GIV(pastSpace)).start))) {
		address = ((GIV(pastSpace)).start);
	}
	else {
		if (GIV(freeStart) > (((GIV(eden)).start))) {
			address = ((GIV(eden)).start);
		}
		else {
			address = GIV(oldSpaceStart);
		}
	}
	startObject = objectStartingAt(address);

	/* begin allEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	obj = startObject;
	enableObjectEnumerationFrom(startObject);
	while (1) {
		assert((obj % (allocationUnit())) == 0);
		if (!(oopisLessThan(obj, GIV(endOfMemory)))) break;
		assert((long64At(obj)) != 0);

		/* begin isEnumerableObject: */
		classIndex = classIndexOf(obj);
		assert((classIndex == (segmentBridgePun()))
		 || ((classIndex == (isForwardedObjectClassIndexPun()))
		 || (((long64At(obj)) != 0)
		 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))))));
		if (classIndex >= (isForwardedObjectClassIndexPun())) {
			fmt = formatOf(obj);
			if (fmt >= (firstByteFormat())) {

				/* oop contains bytes */
				wordAddr = obj + BaseHeaderSize;
				if (fmt >= (firstCompiledMethodFormat())) {

					/* compiled method; start after methodHeader and literals */
					methodHeader = longAt(obj + BaseHeaderSize);
					wordAddr += (((/* begin literalCountOfMethodHeader: */
	assert((((methodHeader) & 7) == 1)),
/* literalCountOfAlternateHeader: */
	((methodHeader >> 3)) & AlternateHeaderNumLiteralsMask)) + LiteralStart) * BytesPerOop;
				}
				reverseBytesFromto(wordAddr, obj + (sizeBitsOf(obj)));
			}
			if (fmt == (firstLongFormat())) {

				/* Bitmap, Float etc */
				if (swapFloatWords
				 && ((classIndexOf(obj)) == ClassFloatCompactIndex)) {
					temp = longAt(obj + BaseHeaderSize);
					longAtput(obj + BaseHeaderSize, longAt((obj + BaseHeaderSize) + 4));
					longAtput((obj + BaseHeaderSize) + 4, temp);
				}
				else {
				}
			}
		}
		prevPrevObj = prevObj;
		prevObj = obj;

		/* begin objectAfterMaybeSlimBridge:limit: */
		followingWordAddress = addressAfter(obj);
		if (oopisGreaterThanOrEqualTo(followingWordAddress, GIV(endOfMemory))) {
			obj = GIV(endOfMemory);
			goto l1;
		}
		flag("endianness");
		followingWord = longAt(followingWordAddress);
		obj = ((((usqInt)(followingWord)) >> (numSlotsFullShift())) == (numSlotsMask())
					? ((oopisLessThan(obj, GIV(oldSpaceStart)))
					 && ((followingWord & 0xFFFFFFFFFFFFFFLL) == 1)
							? (followingWordAddress + BaseHeaderSize) + BaseHeaderSize
							: followingWordAddress + BaseHeaderSize)
					: followingWordAddress);
l1:	/* end objectAfterMaybeSlimBridge:limit: */;
		assert(oopisGreaterThan(obj, prevObj));
	}
}


/*	useful for VM debugging */

	/* StackInterpreter>>#whereIs: */
char *
whereIs(sqInt anOop)
{
    char *where;

	where = whereIsMaybeHeapThing(anOop);
	if (where) {
		return where;
	}
	where = whereIsMaybeStackThing(anOop);
	if (where) {
		return where;
	}
	return " is no where obvious";
}

	/* VMClass>>#stretch:cat: */
static NoDbgRegParms char *
stretchcat(char *s1, char *s2)
{
    char *ns;

	ns = malloc(((strlen(s1)) + (strlen(s2))) + 2);
	strcpy(ns, s1);
	return strcat(ns, s2);
}

/*** Exports ***/

static char _m[] = "";
void* vm_exports[][3] = {
	{NULL, NULL, NULL}
};
