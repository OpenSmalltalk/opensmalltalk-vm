/* Automatically generated by
	CCodeGenerator VMMaker.oscog-eem.3455 uuid: 3fb5350e-7e08-4a76-8b1b-7755e8e0811f
   from
	StackToRegisterMappingCogit VMMaker.oscog-eem.3455 uuid: 3fb5350e-7e08-4a76-8b1b-7755e8e0811f
 */
static char __buildInfo[] = "StackToRegisterMappingCogit VMMaker.oscog-eem.3455 uuid: 3fb5350e-7e08-4a76-8b1b-7755e8e0811f " __DATE__ ;
char *__cogitBuildInfo = __buildInfo;



#include "sqConfig.h"
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqPlatformSpecific.h"
#include "sqMemoryAccess.h"
#include "sqCogStackAlignment.h"
#include "dispdbg.h"
#include "cogmethod.h"
#if COGMTVM
#include "cointerpmt.h"
#else
#include "cointerp.h"
#endif
#include "cogit.h"


/*** Constants ***/
#define ABICallerSavedRegisterMask 0x120F
#define ABIResultReg 0
#define AddCqR 106
#define AddCqRR 123
#define AddCwR 114
#define AddOpcode 4
#define AddRdRd 132
#define AddRR 100
#define AddRRR 126
#define AL 14
#define AlignmentNops 3
#define AllButTypeMask 0xFFFFFFFCU
#define AndCqR 108
#define AndCqRR 124
#define AndCwR 116
#define AndOpcode 0
#define AndRR 102
#define AnnotationShift 5
#define Arg0Reg 3
#define Arg1Reg 4
#define ArithmeticShiftRightCqR 91
#define ArithmeticShiftRightCqRR 128
#define ArithmeticShiftRightRR 92
#define BadRegisterSet 1
#define BicOpcode 14
#define BlockCreationBytecodeSize 4
#define BytecodeSetHasDirectedSuperSend 0
#define CArg0Reg 0
#define CArg1Reg 1
#define CArg2Reg 2
#define CArg3Reg 3
#define Call 6
#define CallerSavedRegisterMask 0xC
#define CallFull 7
#define CC 3
#define ClassArray 7
#define ClassFloatCompactIndex 6
#define ClassLargePositiveIntegerCompactIndex 5
#define ClassMethodContextCompactIndex 14
#define ClassReg 2
#define ClosureFirstCopiedValueIndex 3
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define ClzRR 157
#define CMBlock 4
#define CMClosedPIC 2
#define CMFree 1
#define CMMaxUsageCount 7
#define CMMethod 5
#define CMMethodFlaggedForBecome 6
#define CMOpenPIC 3
#define CMPSMULL 167
#define CmpC32R 113
#define CmpCqR 105
#define CmpCwR 112
#define CmpNotOpcode 11
#define CmpOpcode 10
#define CmpRdRd 131
#define CmpRR 99
#define CompactClasses 28
#define CompletePrimitive 4
#define ConcreteIPReg 12
#define ConcreteVarBaseReg 10
#define ConstZero 1
#define ConvertRRd 145
#define CS 2
#if !defined(Debug) /* Allow this to be overridden on the compiler command line */
# define Debug DEBUGVM
#endif
#define DisplacementMask 0x1F
#define DisplacementX2N 0
#define DivRdRd 135
#define DPFPReg0 0
#define DPFPReg1 1
#define DPFPReg2 2
#define DPFPReg3 3
#define DPFPReg4 4
#define DPFPReg5 5
#define DPFPReg6 6
#define DPFPReg7 7
#define EncounteredUnknownBytecode -6
#define EQ 0
#define Extra0Reg 7
#define Extra1Reg 8
#define Extra2Reg 9
#define Fill32 4
#define FirstAnnotation 64
#define FirstJump 12
#define FirstSpecialSelector 176
#define FoxCallerSavedIP 4
#define FoxIFSavedIP -16
#define FoxMethod -4
#define FoxMFReceiver -12
#define FoxThisContext -8
#define FPReg 11
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeNewSpace 2
#define GE 10
#define GT 12
#define HasBytecodePC 5
#define HashBitsOffset 17
#define HashMaskUnshifted 0xFFF
#define HashMultiplyConstant 1664525
#define HashMultiplyMask 0xFFFFFFF
#define HeaderIndex 0
#define HeaderTypeShort 3
#define HeaderTypeSizeAndClass 0
#define HI 8
#if !defined(IMMUTABILITY) /* Allow this to be overridden on the compiler command line */
# define IMMUTABILITY 0
#endif
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define InsufficientCodeSpace -2
#define InVanillaBlock 1
#define IsAbsPCReference 3
#define IsAnnotationExtension 1
#define IsDirectedSuperBindingSend null
#define IsDirectedSuperSend null
#define IsDisplacementX2N 0
#define IsNSDynamicSuperSend null
#define IsNSSelfSend null
#define IsNSSendCall null
#define IsObjectReference 2
#define IsRelativeCall 4
#define IsSendCall 7
#define IsSuperSend 8
#define Jump 16
#define JumpAbove 33
#define JumpAboveOrEqual 32
#define JumpBelow 31
#define JumpBelowOrEqual 34
#define JumpCarry 25
#define JumpFPEqual 35
#define JumpFPGreater 39
#define JumpFPGreaterOrEqual 40
#define JumpFPLess 37
#define JumpFPLessOrEqual 38
#define JumpFPNotEqual 36
#define JumpFPOrdered 41
#define JumpFPUnordered 42
#define JumpFull 12
#define JumpGreater 29
#define JumpGreaterOrEqual 28
#define JumpLess 27
#define JumpLessOrEqual 30
#define JumpLong 13
#define JumpLongNonZero 15
#define JumpLongZero 14
#define JumpNegative 19
#define JumpNoCarry 26
#define JumpNonNegative 20
#define JumpNonZero 18
#define JumpNoOverflow 22
#define JumpOverflow 21
#define JumpR 10
#define JumpZero 17
#define Label 1
#define LastJump 42
#define LE 13
#define LinkReg 14
#define Literal 2
#define LoadEffectiveAddressMwrR 88
#define LogicalShiftLeftCqR 95
#define LogicalShiftLeftCqRR 129
#define LogicalShiftLeftRR 96
#define LogicalShiftRightCqR 93
#define LogicalShiftRightCqRR 130
#define LogicalShiftRightRR 94
#define LongSizeMask 0xFFFFFFFCU
#define LR 14
#define LS 9
#define LT 11
#define MapEnd 0
#define MaxCompiledPrimitiveIndex 582
#define MaxCPICCases 6
#define MaxMethodSize 65535
#define MaxNegativeErrorCode -8
#define MaxStackAllocSize 1572864
#define MaxStackCheckOffset 0xFFF
#define MaxX2NDisplacement 992
#define MethodCacheClass 2
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCacheSelector 1
#define MethodIndex 3
#define MethodTooBig -4
#define MFMethodFlagHasContextFlag 1
#define MFMethodFlagIsBlockFlag 2
#define MI 4
#define MoveAbR 48
#define MoveAwR 44
#define MoveC32R 71
#define MoveCqR 69
#define MoveCwR 70
#define MoveM16rR 57
#define MoveM64rRd 75
#define MoveMbrR 65
#define MoveMwrR 50
#define MoveNotOpcode 15
#define MoveOpcode 13
#define MovePerfCnt64RRL 158
#define MoveRAb 49
#define MoveRAw 46
#define MoveRdM64r 76
#define MoveRdRd 74
#define MoveRM16r 58
#define MoveRMbr 66
#define MoveRMwr 51
#define MoveRR 43
#define MoveRXbrR 68
#define MoveRXwrR 53
#define MoveXbrRR 67
#define MoveXwrRR 52
#define MSR 161
#define MulRdRd 134
#define NativePopR 84
#define NativePushR 85
#define NativeRetN 86
#define NativeSPReg 13
#define NE 1
#define NeedsMergeFixupFlag 2
#define NeedsNonMergeFixupFlag 1
#define NegateR 89
#define Nop 5
#define NoReg -1
#define NotFullyInitialized -1
#define NumObjRefsInRuntime 0
#define NumSendTrampolines 4
#define NumSpecialSelectors 32
#define NumTrampolines (54 + (IMMUTABILITY ? 0 : 0))
#define OrCqR 109
#define OrCqRR 125
#define OrCwR 117
#define OrOpcode 12
#define OrRR 103
#define PC 15
#define PCReg 15
#define PL 5
#define PopLDM 163
#define PopR 80
#define PrefetchAw 87
#define PrimCallCollectsProfileSamples 16
#define PrimCallMayEndureCodeCompaction 8
#define PrimCallNeedsNewMethod 4
#define PrimNumberExternalCall 117
#define PrimNumberFFICall 120
#define PushCq 82
#define PushCw 83
#define PushR 81
#define PushSTM 164
#define ReceiverIndex 5
#define ReceiverResultReg 5
#define RetN 9
#define RISCTempReg 12
#define RootBit 0x40000000
#define RootBitDigitLength 4
#define RsbOpcode 3
#define SelectorCannotInterpret 34
#define SelectorDoesNotUnderstand 20
#define SenderIndex 0
#define SendNumArgsReg 6
#define ShouldNotJIT -8
#define Size4Bit 0
#define SizeMask 0xFC
#define SMULL 160
#define SP 13
#define SPReg 13
#define SqrtRd 136
#define SSBaseOffset 1
#define SSConstant 2
#define SSRegister 3
#define SSSpill 4
#define Stop 11
#define SubbRR 121
#define SubCqR 107
#define SubCwR 115
#define SubOpcode 2
#define SubRdRd 133
#define SubRR 101
#define SubRRR 127
#define TempReg 0
#define TstCqR 110
#define TstOpcode 8
#define TypeMask 0x3
#define UnfailingPrimitive 3
#define UnimplementedPrimitive -7
#define ValueIndex 1
#define VarBaseReg 10
#define VC 7
#define VS 6
#define XorCqR 111
#define XorCwR 118
#define XorOpcode 1
#define XorRR 104
#define YoungSelectorInPIC -5

typedef struct _AbstractInstruction {
	unsigned char	opcode;
	unsigned char	machineCodeSize;
	unsigned char	maxSize;
	unsigned char	annotation;
	unsigned char	conditionOrNil;
	unsigned int		machineCode[2];
	usqInt		operands[3];
	usqInt	address;
	struct _AbstractInstruction *dependent;
 } AbstractInstruction;

#define CogOutOfLineLiteralsARMCompiler AbstractInstruction
#define CogARMCompiler AbstractInstruction
#define CogAbstractInstruction AbstractInstruction


typedef struct {
	AbstractInstruction *fakeHeader;
	AbstractInstruction *fillInstruction;
	sqInt	numArgs;
	sqInt	numCopied;
	sqInt	numInitialNils;
	sqInt	startpc;
	AbstractInstruction *entryLabel;
	AbstractInstruction *stackCheckLabel;
	sqInt	span;
	sqInt	hasInstVarRef;
 } BlockStart;

#define CogBlockStart BlockStart


typedef struct _BytecodeDescriptor {
	sqInt (*generator)(void);
	sqInt NoDbgRegParms (*spanFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt);
	sqInt NoDbgRegParms (*needsFrameFunction)(sqInt);
	signed char	stackDelta;
	unsigned char	opcode;
	unsigned char	numBytes;
	unsigned		isBranchTrue : 1;
	unsigned		isBranchFalse : 1;
	unsigned		isReturn : 1;
	unsigned		isBlockCreation : 1;
	unsigned		isMapped : 1;
	unsigned		isMappedInBlock : 1;
	unsigned		isExtension : 1;
	unsigned		isInstVarRef : 1;
	unsigned		is1ByteInstVarStore : 1;
	unsigned		hasUnsafeJump : 1;
 } BytecodeDescriptor;

#define CogBytecodeDescriptor BytecodeDescriptor


typedef struct {
	sqInt (*primitiveGenerator)(void);
	sqInt	primNumArgs;
 } PrimitiveDescriptor;

#define CogPrimitiveDescriptor PrimitiveDescriptor


typedef struct {
	char	type;
	char	spilled;
	signed char	liveRegister;
	signed char	registerr;
	sqInt	offset;
	sqInt	constant;
	sqInt	bcptr;
 } SimStackEntry;

#define CogSimStackEntry SimStackEntry


typedef struct {
	AbstractInstruction *targetInstruction;
	unsigned char	simStackPtr;
	char	isTargetOfBackwardBranch;
	unsigned short	instructionIndex;
 } BytecodeFixup;

#define CogSSBytecodeFixup BytecodeFixup
#define CogBytecodeFixup BytecodeFixup


typedef struct {
	sqInt	isReceiverResultRegLive;
	CogSimStackEntry *ssEntry;
 } CogSSOptStatus;



/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

static NoDbgRegParms AbstractInstruction * addDependent(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anInstruction);
static NoDbgRegParms sqInt availableFloatRegisterOrNoneFor(AbstractInstruction *self_in_CogAbstractInstruction, sqInt liveRegsMask);
static NoDbgRegParms AbstractInstruction * cloneLiteralFrom(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *existingLiteral);
static NoDbgRegParms sqInt genLoadCStackPointer(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms sqInt genLoadCStackPointers(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms sqInt genLoadStackPointerForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg);
static NoDbgRegParms sqInt genLoadStackPointers(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms sqInt genLoadStackPointersForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg);
static NoDbgRegParms sqInt genSaveStackPointers(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms AbstractInstruction * genSwapRRScratch(AbstractInstruction *self_in_CogAbstractInstruction, sqInt regA, sqInt regB, sqInt regTmp);
static NoDbgRegParms AbstractInstruction * genWriteCResultIntoReg(AbstractInstruction *self_in_CogAbstractInstruction, sqInt abstractRegister);
static NoDbgRegParms AbstractInstruction * initializeSharableLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal);
static NoDbgRegParms AbstractInstruction * initializeUniqueLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal);
static NoDbgRegParms sqInt isAnInstruction(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *addressOrInstruction);
static NoDbgRegParms int isJump(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms AbstractInstruction * jmpTarget(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anAbstractInstruction);
static NoDbgRegParms sqInt literal32BeforeFollowingAddress(AbstractInstruction *self_in_CogAbstractInstruction, sqInt followingAddress);
static NoDbgRegParms AbstractInstruction * relocateJumpLongBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta);
static NoDbgRegParms AbstractInstruction * relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta);
static NoDbgRegParms AbstractInstruction * resolveJumpTarget(AbstractInstruction *self_in_CogAbstractInstruction);
static NoDbgRegParms sqInt rewriteConditionalJumpLongAttarget(AbstractInstruction *self_in_CogAbstractInstruction, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static NoDbgRegParms sqInt addsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt addrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt addrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt addReg);
static NoDbgRegParms usqInt aeabiDivModFunctionAddr(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt andsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt andrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt availableRegisterOrNoneFor(AbstractInstruction *self_in_CogARMCompiler, sqInt liveRegsMask);
static NoDbgRegParms sqInt bicsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt bl(AbstractInstruction *self_in_CogARMCompiler, sqInt offset);
static NoDbgRegParms sqInt b(AbstractInstruction *self_in_CogARMCompiler, sqInt offset);
static NoDbgRegParms sqInt callInstructionByteSize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt callTargetFromReturnAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt callSiteReturnAddress);
static NoDbgRegParms sqInt computeMaximumSize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt concretizeAt(AbstractInstruction *self_in_CogARMCompiler, sqInt actualAddress);
static NoDbgRegParms sqInt concretizeCMPSMULL(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms unsigned char concretizeConditionalInstruction(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt concretizeFill32(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt concretizeMSR(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt concretizePushOrPopMultipleRegisters(AbstractInstruction *self_in_CogARMCompiler, sqInt doPush);
static NoDbgRegParms sqInt concretizeSMULL(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms int conditionIsNotNever(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt dataOpTyperdrnrmlsr(AbstractInstruction *self_in_CogARMCompiler, sqInt armOpcode, sqInt destReg, sqInt srcReg, sqInt addReg, sqInt shft);
static NoDbgRegParms sqInt dispatchConcretize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms unsigned int fmsrFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt regA, sqInt regB);
static NoDbgRegParms unsigned int fsitodFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt regA, sqInt regB);
static NoDbgRegParms sqInt fullCallsAreRelative(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms AbstractInstruction * genDivRRQuoRem(AbstractInstruction *self_in_CogARMCompiler, sqInt abstractRegDivisor, sqInt abstractRegDividend, sqInt abstractRegQuotient, sqInt abstractRegRemainder);
static NoDbgRegParms AbstractInstruction * genMarshallNArgsargargargarg(AbstractInstruction *self_in_CogARMCompiler, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3);
static NoDbgRegParms AbstractInstruction * genMulRR(AbstractInstruction *self_in_CogARMCompiler, sqInt regSource, sqInt regDest);
static NoDbgRegParms AbstractInstruction * genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction *self_in_CogARMCompiler, sqInt numArgs);
static NoDbgRegParms AbstractInstruction * genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction *self_in_CogARMCompiler, sqInt numArgs, sqInt ignored);
static NoDbgRegParms sqInt genRemoveNArgsFromStack(AbstractInstruction *self_in_CogARMCompiler, sqInt n);
static NoDbgRegParms AbstractInstruction * genRestoreRegs(AbstractInstruction *self_in_CogARMCompiler, sqInt regMask);
static NoDbgRegParms AbstractInstruction * genSaveRegs(AbstractInstruction *self_in_CogARMCompiler, sqInt regMask);
static NoDbgRegParms AbstractInstruction * genSubstituteReturnAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt retpc);
static NoDbgRegParms sqInt has64BitPerformanceCounter(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt hasVarBaseRegister(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt instructionBeforeAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt followingAddress);
static NoDbgRegParms sqInt instructionIsBLX(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsBL(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsBX(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsB(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsCMP(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsLDR(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsOR(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionIsPush(AbstractInstruction *self_in_CogARMCompiler, sqInt instr);
static NoDbgRegParms sqInt instructionSizeAt(AbstractInstruction *self_in_CogARMCompiler, sqInt pc);
static NoDbgRegParms sqInt inverseOpcodeFor(AbstractInstruction *self_in_CogARMCompiler, sqInt armOpcode);
static NoDbgRegParms sqInt isCallPrecedingReturnPC(AbstractInstruction *self_in_CogARMCompiler, sqInt mcpc);
static NoDbgRegParms int isInImmediateJumpRange(AbstractInstruction *self_in_CogARMCompiler, usqIntptr_t operand);
static NoDbgRegParms sqInt isJumpAt(AbstractInstruction *self_in_CogARMCompiler, sqInt pc);
static NoDbgRegParms sqInt isPCRelativeValueLoad(AbstractInstruction *self_in_CogARMCompiler, unsigned int instr);
static NoDbgRegParms int isWithinCallRange(AbstractInstruction *self_in_CogARMCompiler, sqInt anAddress);
static NoDbgRegParms sqInt jumpLongByteSize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt jumpLongConditionalByteSize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt jumpLongTargetBeforeFollowingAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt mcpc);
static NoDbgRegParms usqInt jumpTargetPCAt(AbstractInstruction *self_in_CogARMCompiler, sqInt pc);
static NoDbgRegParms sqInt ldrbrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue);
static NoDbgRegParms sqInt ldrbrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt offsetReg);
static NoDbgRegParms sqInt ldrhrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate8bitValue);
static NoDbgRegParms sqInt ldrhrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt offsetReg);
static NoDbgRegParms sqInt ldrrnplusImm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt immediate12bitValue);
static NoDbgRegParms sqInt ldrrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue);
static NoDbgRegParms sqInt ldrrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt offsetReg);
static NoDbgRegParms sqInt loadCwInto(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg);
static NoDbgRegParms sqInt loadPICLiteralByteSize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt machineCodeWords(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt memM16xrregbasepuwloffset(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt weirdstuff, sqInt loadstore, sqInt offset8);
static NoDbgRegParms sqInt memM16xrregbasepuwlrm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt weirdstuff, sqInt loadstore, sqInt offsetReg);
static NoDbgRegParms sqInt memMxrregbasepubwlimm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt byteword, sqInt weirdstuff, sqInt loadstore, sqInt offset);
static NoDbgRegParms sqInt memMxrregbasepubwlrmLsl2(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt byteword, sqInt weirdstuff, sqInt loadstore, sqInt offsetReg);
static NoDbgRegParms sqInt memMxrregbasepubwlrm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt byteword, sqInt weirdstuff, sqInt loadstore, sqInt offsetReg);
static NoDbgRegParms sqInt memMxrregbaseublimm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt updown, sqInt byteword, sqInt loadstore, sqInt immediate12bitValue);
static NoDbgRegParms sqInt movsrn(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg);
static NoDbgRegParms sqInt movimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt immediate8bitValue, sqInt rot);
static NoDbgRegParms sqInt movrn(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg);
static NoDbgRegParms int msr(AbstractInstruction *self_in_CogARMCompiler, sqInt flags);
static NoDbgRegParms sqInt mvnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt immediate8bitValue, sqInt rot);
static NoDbgRegParms sqInt numIntRegArgs(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt orrimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt immediate8bitValue, sqInt rot);
static NoDbgRegParms AbstractInstruction * padIfPossibleWithStopsFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt startAddr, sqInt endAddr);
static NoDbgRegParms sqInt popR(AbstractInstruction *self_in_CogARMCompiler, sqInt dstReg);
static NoDbgRegParms sqInt pushLinkRegisterByteSize(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms sqInt pushR(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg);
static NoDbgRegParms AbstractInstruction * relocateCallBeforeReturnPCby(AbstractInstruction *self_in_CogARMCompiler, sqInt retpc, sqInt delta);
static NoDbgRegParms sqInt rewriteCallAttarget(AbstractInstruction *self_in_CogARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress);
static NoDbgRegParms sqInt rewriteCallFullAttarget(AbstractInstruction *self_in_CogARMCompiler, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static NoDbgRegParms sqInt rewriteJumpFullAttarget(AbstractInstruction *self_in_CogARMCompiler, sqInt callSiteReturnAddress, sqInt callTargetAddress);
static NoDbgRegParms sqInt rewriteJumpLongAttarget(AbstractInstruction *self_in_CogARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress);
static NoDbgRegParms sqInt rewriteTransferAttarget(AbstractInstruction *self_in_CogARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress);
static NoDbgRegParms sqInt setsConditionCodesFor(AbstractInstruction *self_in_CogARMCompiler, sqInt aConditionalJumpOpcode);
static NoDbgRegParms sqInt shiftSetsConditionCodesFor(AbstractInstruction *self_in_CogARMCompiler, sqInt aConditionalJumpOpcode);
static NoDbgRegParms sqInt stackPageInterruptHeadroomBytes(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms AbstractInstruction * stopsFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt startAddr, sqInt endAddr);
static NoDbgRegParms sqInt strbrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue);
static NoDbgRegParms sqInt strbrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt offsetReg);
static NoDbgRegParms sqInt strhrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate8bitValue);
static NoDbgRegParms sqInt strhrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt offsetReg);
static NoDbgRegParms sqInt strrnplusImm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt immediate12bitValue);
static NoDbgRegParms sqInt strrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue);
static NoDbgRegParms sqInt strrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt offsetReg);
static NoDbgRegParms sqInt subsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt subrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt tstrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt ignored, sqInt srcReg, sqInt immediate, sqInt rot);
static NoDbgRegParms sqInt zoneCallsAreRelative(AbstractInstruction *self_in_CogARMCompiler);
static NoDbgRegParms CogMethod * cmHomeMethod(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMBlock(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMClosedPIC(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMFree(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMMethodEtAl(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms int isCMOpenPIC(CogBlockMethod *self_in_CogBlockMethod);
static NoDbgRegParms sqInt isBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor);
static NoDbgRegParms sqInt isConditionalBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor);
static NoDbgRegParms int notAFixup(BytecodeFixup *self_in_CogBytecodeFixup);
static NoDbgRegParms AbstractInstruction * gAddRRR(sqInt addendReg, sqInt badendReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * gAndCqR(sqInt quickConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gArithmeticShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
extern sqInt abortOffset(void);
static void addCleanBlockStarts(void);
extern void addCogMethodsToHeapMap(void);
static NoDbgRegParms sqInt addressIsInCurrentCompilation(sqInt address);
static NoDbgRegParms sqInt addressIsInFixups(BytecodeFixup *address);
static NoDbgRegParms sqInt addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC);
static void alignMethodZoneBase(void);
static NoDbgRegParms sqInt alignUptoRoutineBoundary(sqInt anAddress);
static sqInt allMachineCodeObjectReferencesValid(void);
static sqInt allMethodsHaveCorrectHeader(void);
static NoDbgRegParms AbstractInstruction * annotateAbsolutePCRef(AbstractInstruction *abstractInstruction);
static NoDbgRegParms AbstractInstruction * annotateBytecode(AbstractInstruction *abstractInstruction);
static NoDbgRegParms AbstractInstruction * annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop);
static NoDbgRegParms void assertSaneJumpTarget(AbstractInstruction *jumpTarget);
static NoDbgRegParms sqInt availableRegisterOrNoneIn(sqInt liveRegsMask);
static NoDbgRegParms sqInt blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg);
extern sqInt bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static NoDbgRegParms AbstractInstruction * CallFullRTregistersToBeSavedMask(sqInt callTarget, sqInt registersToBeSaved);
static NoDbgRegParms AbstractInstruction * CallRT(sqInt callTarget);
static void callCogCodePopReceiver(void);
static void callCogCodePopReceiverAndClassRegs(void);
static NoDbgRegParms sqInt ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver);
static NoDbgRegParms void ceFree(void *pointer);
static NoDbgRegParms void* ceMalloc(size_t size);
static NoDbgRegParms sqInt ceSICMiss(sqInt receiver);
static NoDbgRegParms sqInt checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
static NoDbgRegParms sqInt checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern sqInt checkIntegrityOfObjectReferencesInCode(sqInt gcModes);
static NoDbgRegParms sqInt checkMaybeObjRefInClosedPIC(sqInt maybeObject);
static NoDbgRegParms sqInt checkValidObjectReferencesInClosedPIC(CogMethod *cPIC);
static NoDbgRegParms NeverInline sqInt cleanUpFailingCogCodeConstituents(CogMethod *cogMethodArg);
static NoDbgRegParms sqInt closedPICRefersToUnmarkedObject(CogMethod *cPIC);
extern char * codeEntryFor(char *address);
extern char * codeEntryNameFor(char *address);
extern sqInt cogCodeBase(void);
extern sqInt cogCodeConstituents(sqInt withDetails);
static NoDbgRegParms void cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase);
extern void cogitPostGCAction(sqInt gcMode);
static NoDbgRegParms sqInt cogMethodDoesntLookKosher(CogMethod *cogMethod);
extern CogMethod * cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs);
static NoDbgRegParms CogMethod * cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs);
static NoDbgRegParms CogMethod * cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase);
extern CogMethod * cogselector(sqInt aMethodObj, sqInt aSelectorOop);
static NoDbgRegParms sqInt collectCogConstituentForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg);
static NoDbgRegParms sqInt collectCogMethodConstituent(CogMethod *cogMethod);
extern void compactCogCompiledCode(void);
static void compactPICsWithFreedTargets(void);
static AbstractInstruction * compileAbort(void);
static NoDbgRegParms sqInt compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex);
static NoDbgRegParms void compileBlockEntry(BlockStart *blockStart);
static NoDbgRegParms void compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask);
static AbstractInstruction * compileCPICEntry(void);
static void compileEntry(void);
static sqInt compileMethodBody(void);
static NoDbgRegParms sqInt compilePICAbort(sqInt numArgs);
static NoDbgRegParms AbstractInstruction * compileStackOverflowCheck(sqInt canContextSwitch);
static NoDbgRegParms void compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone);
static void computeEntryOffsets(void);
static void computeFullBlockEntryOffsets(void);
static usqInt computeGoodVarBaseAddress(void);
static void computeMaximumSizes(void);
static NoDbgRegParms sqInt configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta);
static NoDbgRegParms sqInt configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta);
static NoDbgRegParms sqInt cPICCompactAndIsNowEmpty(CogMethod *cPIC);
static NoDbgRegParms sqInt cPICHasFreedTargets(CogMethod *cPIC);
static usqInt cPICPrototypeCaseOffset(void);
static NoDbgRegParms sqInt cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod);
static NoDbgRegParms sqInt createCPICData(CogMethod *cPIC);
static NoDbgRegParms AbstractInstruction * gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder);
extern int defaultCogCodeSize(void);
static NoDbgRegParms sqInt deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader);
static NoDbgRegParms sqInt endPCOf(sqInt aMethod);
static void enterCogCodePopReceiver(void);
static NoDbgRegParms sqInt entryPointTagIsSelector(sqInt entryPoint);
static NoDbgRegParms sqInt expectedClosedPICPrototype(CogMethod *cPIC);
static NoDbgRegParms sqInt fillInBlockHeadersAt(sqInt startAddress);
static NoDbgRegParms void fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector);
static NoDbgRegParms sqInt findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetBcpc);
static NoDbgRegParms usqInt findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc);
static NoDbgRegParms usqInt findMapLocationForMcpcinMethod(usqInt targetMcpc, CogMethod *cogMethod);
extern CogBlockMethod * findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod);
static NoDbgRegParms sqInt findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetMcpc);
static NoDbgRegParms sqInt firstMappedPCFor(CogMethod *cogMethod);
static sqInt firstPrototypeMethodOop(void);
static NoDbgRegParms BytecodeFixup * fixupAt(sqInt fixupPC);
extern void flagCogMethodForBecome(CogMethod *cogMethod);
extern void freeBecomeFlaggedMethods(void);
extern void freeCogMethod(CogMethod *cogMethod);
static NoDbgRegParms AbstractInstruction * genCallMustBeBooleanFor(sqInt boolean);
static NoDbgRegParms AbstractInstruction * genConditionalBranchoperand(sqInt opcode, sqInt operandOne);
static NoDbgRegParms void (*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void);
static NoDbgRegParms void genEnilopmartReturn(sqInt forCall);
static NoDbgRegParms NeverInline void generateCaptureCStackPointers(sqInt captureFramePointer);
static void generateClosedPICPrototype(void);
static NoDbgRegParms CogMethod * generateCogMethod(sqInt selector);
static NoDbgRegParms sqInt generateMapAtstart(usqInt addressOrNull, usqInt startAddress);
static void generateOpenPICPrototype(void);
static void generateRunTimeTrampolines(void);
static void generateStackPointerCapture(void);
static void generateTrampolines(void);
static NoDbgRegParms BytecodeDescriptor * generatorForPC(sqInt pc);
static void genGetLeafCallStackPointers(void);
static NoDbgRegParms usqInt genInnerPICAbortTrampoline(char *name);
static void (*genInvokeInterpretTrampoline(void))(void);
static NoDbgRegParms void genLoadInlineCacheWithSelector(sqInt selectorIndex);
static usqInt genReturnToInterpreterTrampoline(void);
static NoDbgRegParms sqInt genSmalltalkToCStackSwitch(sqInt pushLinkReg);
static NoDbgRegParms usqInt genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean);
static NoDbgRegParms void genTrampolineReturn(sqInt lnkRegWasPushed);
static NoDbgRegParms AbstractInstruction * gen(sqInt opcode);
static NoDbgRegParms AbstractInstruction * genoperand(sqInt opcode, sqInt operand);
static NoDbgRegParms AbstractInstruction * genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo);
static NoDbgRegParms AbstractInstruction * genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree);
static NoDbgRegParms sqInt getLiteral(sqInt litIndex);
static sqInt getOpcodeIndex(void);
static NoDbgRegParms sqInt incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
extern void initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress);
static sqInt initialMethodUsageCount(void);
static int initialOpenPICUsageCount(void);
static NoDbgRegParms sqInt inverseBranchFor(sqInt opcode);
static NoDbgRegParms int isPCWithinMethodZone(void *address);
extern sqInt isSendReturnPC(sqInt retpc);
static NoDbgRegParms AbstractInstruction * gJumpFPEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPGreaterOrEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPGreater(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gJumpFPNotEqual(void *jumpTarget);
static NoDbgRegParms AbstractInstruction * gLogicalShiftLeftCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static AbstractInstruction * lastOpcode(void);
extern void linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver);
static BytecodeDescriptor * loadBytesAndGetDescriptor(void);
static NoDbgRegParms void loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc);
static NoDbgRegParms AbstractInstruction * gMoveCqR(sqInt quickConstant, sqInt reg);
static NoDbgRegParms AbstractInstruction * gMoveMwrR(sqInt offset, sqInt baseReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * gMovePerfCnt64RRL(sqInt destRegLo, sqInt destRegHi, sqInt liveRegisterMask);
static NoDbgRegParms usqInt mapEndFor(CogMethod *cogMethod);
static NoDbgRegParms sqInt mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, CogMethod *arg), CogMethod *arg);
static NoDbgRegParms sqInt mapObjectReferencesInClosedPIC(CogMethod *cPIC);
static void mapObjectReferencesInGeneratedRuntime(void);
static void mapObjectReferencesInMachineCodeForBecome(void);
static void mapObjectReferencesInMachineCodeForFullGC(void);
static void mapObjectReferencesInMachineCodeForYoungGC(void);
extern void mapObjectReferencesInMachineCode(sqInt gcMode);
static void markAndTraceMachineCodeForNewSpaceGC(void);
static void markAndTraceObjectReferencesInGeneratedRuntime(void);
extern void markAndTraceObjectsOrFreeMachineCode(sqInt inFullGC);
static NoDbgRegParms sqInt markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit);
static void markAndTraceOrFreeMachineCodeForFullGC(void);
static NoDbgRegParms sqInt markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC);
static NoDbgRegParms sqInt markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern void markMethodAndReferents(CogBlockMethod *aCogMethod);
static NoDbgRegParms sqInt markYoungObjectspcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod);
extern usqInt maxCogMethodAddress(void);
static NoDbgRegParms sqInt maximumDistanceFromCodeZone(sqInt anAddress);
static sqInt maybeAllocAndInitIRCs(void);
static NoDbgRegParms sqInt maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod);
static int mclassIsSmallInteger(void);
extern usqInt mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod);
static NoDbgRegParms sqInt methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral);
extern sqInt mnuOffset(void);
static NoDbgRegParms AbstractInstruction * gNativePopR(sqInt reg);
static NoDbgRegParms AbstractInstruction * gNativePushR(sqInt reg);
static NoDbgRegParms AbstractInstruction * gNativeRetN(sqInt offset);
static NoDbgRegParms sqInt needsFrameIfImmutability(sqInt stackDelta);
static NoDbgRegParms int needsFrameIfInBlock(sqInt stackDelta);
static NoDbgRegParms sqInt needsFrameNever(sqInt stackDelta);
static NoDbgRegParms sqInt noAssertMethodClassAssociationOf(sqInt methodPointer);
static sqInt noCogMethodsMaximallyMarked(void);
static NoDbgRegParms int noTargetsFreeInClosedPIC(CogMethod *cPIC);
static NoDbgRegParms AbstractInstruction * gOrCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt outputInstructionsAt(sqInt startAddress);
static NoDbgRegParms sqInt outputInstructionsForGeneratedRuntimeAt(sqInt startAddress);
extern sqInt patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver);
static sqInt picAbortDiscriminatorValue(void);
static sqInt picInterpretAbortOffset(void);
extern void printCogMethodFor(void *address);
extern void printTrampolineTable(void);
static sqInt processorHasDivQuoRemAndMClassIsSmallInteger(void);
static sqInt processorHasMultiplyAndMClassIsSmallInteger(void);
static NoDbgRegParms void recordGeneratedRunTimeaddress(char *aString, sqInt address);
extern int recordPrimTraceFunc(void);
static void recordRunTimeObjectReferences(void);
static NoDbgRegParms sqInt registerMaskFor(sqInt reg);
static NoDbgRegParms sqInt registerMaskForand(sqInt reg1, sqInt reg2);
static NoDbgRegParms void relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod);
static NoDbgRegParms void relocateCallsInClosedPIC(CogMethod *cPIC);
static NoDbgRegParms sqInt relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, CogMethod *refDeltaArg);
static NoDbgRegParms sqInt remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, CogMethod *hasYoungPtr);
static NoDbgRegParms sqInt remapMaybeObjRefInClosedPICAt(sqInt mcpc);
static NoDbgRegParms void rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget);
static NoDbgRegParms AbstractInstruction * gSubCqR(sqInt quickConstant, sqInt reg);
static sqInt scanForCleanBlocks(void);
extern void setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop);
static NoDbgRegParms sqInt spanForCleanBlockStartingAt(sqInt startPC);
static NoDbgRegParms usqInt stackCheckOffsetOfBlockAtisMcpc(sqInt blockEntryMcpc, sqInt mcpc);
static sqInt subsequentPrototypeMethodOop(void);
extern sqInt traceLinkedSendOffset(void);
static NoDbgRegParms char * trampolineNamenumArgs(char *routinePrefix, sqInt numArgs);
static NoDbgRegParms char * trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs);
extern void unflagBecomeFlaggedMethods(void);
static int unknownBytecode(void);
extern void unlinkAllSends(void);
static NoDbgRegParms sqInt unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, CogMethod *theSelector);
static NoDbgRegParms sqInt unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static NoDbgRegParms sqInt unlinkIfLinkedSendpcif(sqInt annotation, char *mcpc, CogMethod *criterionArg);
static NoDbgRegParms sqInt unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity);
static NoDbgRegParms sqInt unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, CogMethod *theCogMethod);
extern void unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector);
static void unlinkSendsToFree(void);
extern void unlinkSendsToMethodsSuchThatAndFreeIf(sqInt (*criterion)(CogMethod *), sqInt freeIfTrue);
extern void unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue);
extern void voidCogCompiledCode(void);
static void zeroOpcodeIndex(void);
static NoDbgRegParms sqInt counters(CogMethod *self_in_CogMethod);
static NoDbgRegParms void addToOpenPICList(CogMethod *anOpenPIC);
static NoDbgRegParms void addToYoungReferrers(CogMethod *writableCogMethod);
static NoDbgRegParms usqInt allocate(sqInt numBytes);
extern CogMethod * cogMethodContaining(usqInt mcpc);
static void compactCompiledCode(void);
static NoDbgRegParms void ensureInYoungReferrers(CogMethod *cogMethod);
static NoDbgRegParms void freeMethod(CogMethod *cogMethod);
static void freeOlderMethodsForCompaction(void);
extern sqInt kosherYoungReferrers(void);
static NoDbgRegParms sqInt mcpcisAtStackCheckOfBlockMethodIn(sqInt mcpc, CogMethod *cogMethod);
extern CogMethod * methodFor(void *address);
extern sqInt methodsCompiledToMachineCodeInto(sqInt arrayObj);
extern sqInt numMethods(void);
extern sqInt numMethodsOfType(sqInt cogMethodType);
static NoDbgRegParms sqInt occurrencesInYoungReferrers(CogMethod *cogMethod);
static NoDbgRegParms CogMethod * openPICWithSelector(sqInt aSelector);
static void planCompaction(void);
extern void printCogMethods(void);
extern void printCogMethodsOfType(sqInt cmType);
extern void printCogMethodsWithMethod(sqInt methodOop);
extern void printCogMethodsWithPrimitive(sqInt primIdx);
extern void printCogMethodsWithSelector(sqInt selectorOop);
extern void printCogYoungReferrers(void);
extern sqInt printOpenPICList(void);
static sqInt pruneYoungReferrers(void);
static sqInt relocateAndPruneYoungReferrers(void);
static sqInt relocateMethodsPreCompaction(void);
static NoDbgRegParms sqInt removeFromOpenPICList(CogMethod *anOpenPIC);
static NoDbgRegParms sqInt roundUpLength(sqInt numBytes);
static void voidOpenPICList(void);
static void voidUnpairedMethodList(void);
static void voidYoungReferrersPostTenureAll(void);
extern char * whereIsMaybeCodeThing(sqInt anOop);
static NoDbgRegParms sqInt checkValidObjectReference(sqInt anOop);
static NoDbgRegParms AbstractInstruction * genCmpClassFloatCompactIndexR(sqInt reg);
static NoDbgRegParms AbstractInstruction * genCmpClassMethodContextCompactIndexR(sqInt reg);
static NoDbgRegParms int genDoubleArithmeticpreOpCheck(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg));
static NoDbgRegParms int genDoubleComparisoninvert(AbstractInstruction * NoDbgRegParms (*jumpOpcodeGenerator)(void *), sqInt invertComparison);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallIntegersInandscratch(sqInt aRegister, sqInt bRegister, sqInt scratchRegister);
static NoDbgRegParms sqInt genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg);
static int genPrimitiveAdd(void);
static int genPrimitiveAsCharacter(void);
static int genPrimitiveAsFloat(void);
static int genPrimitiveAtPut(void);
static int genPrimitiveBitAnd(void);
static int genPrimitiveBitOr(void);
static int genPrimitiveBitShift(void);
static int genPrimitiveBitXor(void);
static int genPrimitiveClass(void);
static int genPrimitiveDiv(void);
static int genPrimitiveDivide(void);
static int genPrimitiveEqual(void);
static int genPrimitiveFloatAdd(void);
static int genPrimitiveFloatDivide(void);
static int genPrimitiveFloatEqual(void);
static int genPrimitiveFloatGreaterOrEqual(void);
static int genPrimitiveFloatGreaterThan(void);
static int genPrimitiveFloatLessOrEqual(void);
static int genPrimitiveFloatLessThan(void);
static int genPrimitiveFloatMultiply(void);
static int genPrimitiveFloatNotEqual(void);
static int genPrimitiveFloatSquareRoot(void);
static int genPrimitiveFloatSubtract(void);
static int genPrimitiveGreaterOrEqual(void);
static int genPrimitiveGreaterThan(void);
static int genPrimitiveHighBit(void);
static sqInt genPrimitiveIdentical(void);
static int genPrimitiveImmediateAsInteger(void);
static int genPrimitiveIntegerAt(void);
static int genPrimitiveIntegerAtPut(void);
static int genPrimitiveLessOrEqual(void);
static int genPrimitiveLessThan(void);
static int genPrimitiveMakePoint(void);
static int genPrimitiveMod(void);
static int genPrimitiveMultiply(void);
static int genPrimitiveNew(void);
static int genPrimitiveNewMethod(void);
static int genPrimitiveNewWithArg(void);
static int genPrimitiveNotEqual(void);
static sqInt genPrimitiveNotIdentical(void);
static int genPrimitiveObjectAt(void);
static int genPrimitiveQuo(void);
static int genPrimitiveShallowCopy(void);
static int genPrimitiveSlotAt(void);
static int genPrimitiveSlotAtPut(void);
static int genPrimitiveStringAtPut(void);
static int genPrimitiveStringCompareWith(void);
static int genPrimitiveStringReplace(void);
static int genPrimitiveSubtract(void);
static int genPrimitiveUninitializedNewWithArg(void);
static NoDbgRegParms int genPureDoubleArithmeticpreOpCheck(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg));
static NoDbgRegParms int genPureDoubleComparisoninvert(AbstractInstruction * NoDbgRegParms (*jumpOpcodeGenerator)(void *), sqInt invertComparison);
static NoDbgRegParms int genSmallIntegerComparison(sqInt jumpOpcode);
static NoDbgRegParms int genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction * NoDbgRegParms (*jumpFPOpcodeGenerator)(void *), sqInt invertComparison);
static NoDbgRegParms sqInt isUnannotatableConstant(CogSimStackEntry *simStackEntry);
static NoDbgRegParms sqInt maybeGenConvertIfSmallFloatInscratchRegintoandJumpTo(sqInt oopReg, sqInt scratch, sqInt dpReg, AbstractInstruction *targetInst);
static NoDbgRegParms sqInt maybeShiftClassTagRegisterForMethodCacheProbe(sqInt classTagReg);
static NoDbgRegParms sqInt cacheTagIsMarked(sqInt cacheTag);
static NoDbgRegParms sqInt checkValidOopReference(sqInt anOop);
static NoDbgRegParms sqInt classForInlineCacheTag(sqInt inlineCacheTag);
static sqInt compactClassFieldMask(void);
static NoDbgRegParms sqInt couldBeObject(sqInt oop);
static usqInt genActiveContextTrampoline(void);
static NoDbgRegParms sqInt genAddSmallIntegerTagsTo(sqInt aRegister);
static NoDbgRegParms AbstractInstruction * genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2);
static NoDbgRegParms sqInt genClearAndSetSmallIntegerTagsIn(sqInt scratchReg);
static NoDbgRegParms sqInt genConvertIntegerInRegtoSmallIntegerInReg(sqInt srcReg, sqInt destReg);
static NoDbgRegParms sqInt genConvertIntegerToSmallIntegerInReg(sqInt reg);
static NoDbgRegParms sqInt genConvertSmallIntegerToIntegerInReg(sqInt reg);
static NoDbgRegParms sqInt genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock);
static void generateObjectRepresentationTrampolines(void);
static NoDbgRegParms void genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock);
static NoDbgRegParms sqInt genGetClassFormatOfNonIntintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static NoDbgRegParms sqInt genGetClassObjectOfintoscratchRegmayBeAForwarder(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt mayBeAForwarder);
static NoDbgRegParms AbstractInstruction * genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static NoDbgRegParms sqInt genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg);
static NoDbgRegParms sqInt genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg);
static NoDbgRegParms sqInt genGetFixedFieldsOfPointerNonIntintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg);
static NoDbgRegParms sqInt genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg);
static NoDbgRegParms AbstractInstruction * genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry);
static NoDbgRegParms AbstractInstruction * genJumpImmediate(sqInt aRegister);
static NoDbgRegParms AbstractInstruction * genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallIntegerInScratchReg(sqInt aRegister);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg);
static NoDbgRegParms AbstractInstruction * genJumpNotSmallInteger(sqInt aRegister);
static NoDbgRegParms AbstractInstruction * genJumpSmallInteger(sqInt aRegister);
static NoDbgRegParms void genNewArrayOfSizeinitialized(sqInt size, sqInt initialize);
static sqInt genPrimitiveAt(void);
static NoDbgRegParms sqInt genPrimitiveIdenticalOrNotIf(sqInt orNot);
static sqInt genPrimitiveIdentityHash(void);
static sqInt genPrimitiveSize(void);
static sqInt genPrimitiveStringAt(void);
static NoDbgRegParms sqInt genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg);
static NoDbgRegParms sqInt genSetSmallIntegerTagsIn(sqInt scratchReg);
static NoDbgRegParms sqInt genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg);
static NoDbgRegParms sqInt genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck);
static NoDbgRegParms sqInt genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg);
static NoDbgRegParms sqInt inlineCacheTagForInstance(sqInt oop);
static NoDbgRegParms sqInt inlineCacheTagIsYoung(sqInt cacheTag);
static NoDbgRegParms void markAndTraceLiteralIfYoung(sqInt literal);
static NoDbgRegParms void markAndTraceLiteral(sqInt literal);
static sqInt numSmallIntegerBits(void);
static NoDbgRegParms sqInt remapObject(sqInt objOop);
static NoDbgRegParms sqInt remapOop(sqInt oop);
static NoDbgRegParms sqInt shouldAnnotateObjectReference(sqInt anOop);
static NoDbgRegParms sqInt slotOffsetOfInstVarIndex(sqInt index);
static NoDbgRegParms sqInt validInlineCacheTag(sqInt cacheTag);
static NoDbgRegParms sqInt callFullInstructionByteSize(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt cmpC32RTempByteSize(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt concretizeLiteral(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt inlineCacheTagAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt callSiteReturnAddress);
static NoDbgRegParms sqInt isPCDependent(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt literalBeforeFollowingAddress(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt followingAddress);
static NoDbgRegParms sqInt literalLoadInstructionBytes(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt loadLiteralByteSize(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt machineCodeBytes(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt nsSendCacheAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt callSiteReturnAddress);
static NoDbgRegParms sqInt outOfLineLiteralOpcodeLimit(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms sqInt pcRelativeAddressAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt instrAddress);
static NoDbgRegParms AbstractInstruction * relocateMethodReferenceBeforeAddressby(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt pc, sqInt delta);
static NoDbgRegParms sqInt rewriteFullTransferAttargetexpectedInstruction(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress, sqInt expectedInstruction);
static NoDbgRegParms sqInt rewriteInlineCacheAttagtarget(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress);
static NoDbgRegParms AbstractInstruction * rewriteInlineCacheTagat(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt cacheTag, sqInt callSiteReturnAddress);
static NoDbgRegParms unsigned char sizePCDependentInstructionAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt eventualAbsoluteAddress);
static NoDbgRegParms AbstractInstruction * storeLiteralbeforeFollowingAddress(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt literal, sqInt followingAddress);
static NoDbgRegParms AbstractInstruction * updateLabel(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, AbstractInstruction *labelInstruction);
static NoDbgRegParms sqInt usesOutOfLineLiteral(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler);
static NoDbgRegParms SimStackEntry * ensureSpilledAtfrom(SimStackEntry *self_in_CogSimStackEntry, sqInt baseOffset, sqInt baseRegister);
static NoDbgRegParms sqInt isSameEntryAs(SimStackEntry *self_in_CogSimStackEntry, CogSimStackEntry *ssEntry);
static NoDbgRegParms sqInt mayBeAForwarder(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms SimStackEntry * popToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg);
static NoDbgRegParms sqInt registerMask(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms sqInt registerMaskOrNone(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms sqInt registerOrNone(SimStackEntry *self_in_CogSimStackEntry);
static NoDbgRegParms SimStackEntry * storeToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg);
static NoDbgRegParms int isMergeFixup(BytecodeFixup *self_in_CogSSBytecodeFixup);
static NoDbgRegParms AbstractInstruction * allocateLiteral(sqInt aLiteral);
static NoDbgRegParms AbstractInstruction * checkLiteralforInstruction(sqInt literal, AbstractInstruction *anInstruction);
static NoDbgRegParms sqInt dumpLiterals(sqInt generateBranchAround);
static NoDbgRegParms sqInt literalInstructionInRange(AbstractInstruction *litInst);
static NoDbgRegParms AbstractInstruction * locateLiteral(sqInt aLiteral);
static NoDbgRegParms sqInt ceClosureCopyDescriptor(sqInt descriptor);
extern sqInt cogMethodHasExternalPrim(CogMethod *aCogMethod);
extern sqInt cogMethodHasMachineCodePrim(CogMethod *aCogMethod);
static sqInt compileBlockDispatch(void);
static void compileGetErrorCode(void);
static NoDbgRegParms sqInt compileInterpreterPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags);
static NoDbgRegParms AbstractInstruction * compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone);
static NoDbgRegParms void compileOpenPICnumArgs(sqInt selector, sqInt numArgs);
static NoDbgRegParms AbstractInstruction * compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone);
static sqInt compilePrimitive(void);
static sqInt extendedPushBytecode(void);
static sqInt extendedStoreAndPopBytecode(void);
static sqInt extendedStoreBytecode(void);
static NoDbgRegParms int frameOffsetOfTemporary(sqInt index);
static NoDbgRegParms AbstractInstruction * genDoubleFailIfZeroArgRcvrarg(int rcvrReg, int argReg);
static sqInt genExtendedSendBytecode(void);
static sqInt genExtendedSuperBytecode(void);
static sqInt genFastPrimFail(void);
static NoDbgRegParms void genFastPrimTraceUsingand(sqInt r1, sqInt r2);
static void genLoadNewMethod(void);
static sqInt genLongJumpIfFalse(void);
static sqInt genLongJumpIfTrue(void);
static sqInt genLongStoreAndPopTemporaryVariableBytecode(void);
static sqInt genLongUnconditionalBackwardJump(void);
static sqInt genLongUnconditionalForwardJump(void);
static NoDbgRegParms sqInt genLookupForPerformNumArgs(sqInt numArgs);
static NoDbgRegParms usqInt genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName);
static int genPrimitiveHashMultiply(void);
static NoDbgRegParms void genPrimReturnEnterCogCodeEnilopmart(sqInt profiling);
static sqInt genPushConstantFalseBytecode(void);
static sqInt genPushConstantNilBytecode(void);
static sqInt genPushConstantTrueBytecode(void);
static sqInt genPushLiteralConstantBytecode(void);
static sqInt genPushLiteralVariableBytecode(void);
static sqInt genPushQuickIntegerConstantBytecode(void);
static sqInt genPushReceiverVariableBytecode(void);
static sqInt genPushTemporaryVariableBytecode(void);
extern sqInt genQuickReturnConst(void);
extern sqInt genQuickReturnInstVar(void);
extern sqInt genQuickReturnSelf(void);
static sqInt genReturnFalse(void);
static sqInt genReturnNil(void);
static sqInt genReturnTrue(void);
static sqInt genSecondExtendedSendBytecode(void);
static sqInt genSendLiteralSelector0ArgsBytecode(void);
static sqInt genSendLiteralSelector1ArgBytecode(void);
static sqInt genSendLiteralSelector2ArgsBytecode(void);
static sqInt genShortJumpIfFalse(void);
static sqInt genShortUnconditionalJump(void);
static sqInt genSpecialSelectorEqualsEquals(void);
static sqInt genSpecialSelectorNotEqualsEquals(void);
static sqInt genSpecialSelectorSend(void);
static sqInt genStoreAndPopReceiverVariableBytecode(void);
static sqInt genStoreAndPopRemoteTempLongBytecode(void);
static sqInt genStoreAndPopTemporaryVariableBytecode(void);
static sqInt genStoreRemoteTempLongBytecode(void);
extern sqInt mapPCDataForinto(CogMethod *cogMethod, sqInt arrayObj);
static sqInt numSpecialSelectors(void);
static NoDbgRegParms usqInt pcDataForBlockEntryMethod(sqInt blockEntryMcpc, sqInt cogMethod);
static NoDbgRegParms sqInt pcDataForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg);
static PrimitiveDescriptor * primitiveGeneratorOrNil(void);
static NoDbgRegParms int registerisInMask(sqInt reg, sqInt mask);
static NoDbgRegParms sqInt v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms sqInt v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static NoDbgRegParms BlockStart * addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span);
static NoDbgRegParms void adjustArgumentsForPerform(sqInt numArgs);
static NoDbgRegParms sqInt allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask);
static NoDbgRegParms sqInt allocateRegNotConflictingWith(sqInt regMask);
static NoDbgRegParms sqInt anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n);
extern void callCogCodePopReceiverArg0Regs(void);
extern void callCogCodePopReceiverArg1Arg0Regs(void);
static NoDbgRegParms sqInt compileAbstractInstructionsFromthrough(sqInt start, sqInt end);
static sqInt compileBlockBodies(void);
static NoDbgRegParms void compileBlockFrameBuild(BlockStart *blockStart);
static NoDbgRegParms void compileBlockFramelessEntry(BlockStart *blockStart);
static NoDbgRegParms CogMethod * compileCogMethod(sqInt selector);
static sqInt compileEntireMethod(void);
static void compileFrameBuild(void);
#if IMMUTABILITY
static void compileTwoPathFrameBuild(void);
#endif /* IMMUTABILITY */
static void compileTwoPathFramelessInit(void);
static NoDbgRegParms sqInt cPICMissTrampolineFor(sqInt numArgs);
static sqInt doubleExtendedDoAnythingBytecode(void);
static sqInt duplicateTopBytecode(void);
static NoDbgRegParms BytecodeFixup * ensureFixupAt(sqInt targetPC);
static NoDbgRegParms BytecodeFixup * ensureNonMergeFixupAt(sqInt targetPC);
static void ensureReceiverResultRegContainsSelf(void);
static NoDbgRegParms void evaluateat(BytecodeDescriptor *descriptor, sqInt pc);
static NoDbgRegParms sqInt eventualTargetOf(sqInt targetBytecodePC);
static NoDbgRegParms sqInt freeAnyRegNotConflictingWith(sqInt regMask);
static sqInt genBlockReturn(void);
static NoDbgRegParms void (*genCallPICEnilopmartNumArgs(sqInt numArgs))(void);
static sqInt genExternalizePointersForPrimitiveCall(void);
static void generateEnilopmarts(void);
static NoDbgRegParms sqInt generateInstructionsAt(sqInt eventualAbsoluteAddress);
static void generateMissAbortTrampolines(void);
static void generateSendTrampolines(void);
static void generateTracingTrampolines(void);
static NoDbgRegParms sqInt genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone, sqInt orNot);
static NoDbgRegParms sqInt genInlinedIdenticalOrNotIf(sqInt orNot);
static NoDbgRegParms sqInt genJumpBackTo(sqInt targetBytecodePC);
static NoDbgRegParms sqInt genJumpIfto(sqInt boolean, sqInt targetBytecodePC);
static NoDbgRegParms sqInt genJumpTo(sqInt targetBytecodePC);
static NoDbgRegParms sqInt genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable);
static NoDbgRegParms usqInt genMethodAbortTrampolineFor(sqInt numArgs);
static NoDbgRegParms usqInt genPICAbortTrampolineFor(sqInt numArgs);
static NoDbgRegParms usqInt genPICMissTrampolineFor(sqInt numArgs);
static sqInt genPopStackBytecode(void);
static sqInt genPrimitiveClosureValue(void);
static sqInt genPrimitivePerform(void);
static sqInt genPushActiveContextBytecode(void);
static sqInt genPushClosureCopyCopiedValuesBytecode(void);
static NoDbgRegParms sqInt genPushLiteralIndex(sqInt literalIndex);
static NoDbgRegParms sqInt genPushLiteralVariable(sqInt literalIndex);
static NoDbgRegParms sqInt genPushMaybeContextReceiverVariable(sqInt slotIndex);
static sqInt genPushNewArrayBytecode(void);
static sqInt genPushReceiverBytecode(void);
static NoDbgRegParms sqInt genPushReceiverVariable(sqInt index);
static void genPushRegisterArgs(void);
static sqInt genPushRemoteTempLongBytecode(void);
static NoDbgRegParms sqInt genPushTemporaryVariable(sqInt index);
static sqInt genReturnReceiver(void);
static sqInt genReturnTopFromBlock(void);
static sqInt genReturnTopFromMethod(void);
static NoDbgRegParms sqInt genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs);
static NoDbgRegParms usqInt genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3);
static NoDbgRegParms sqInt genSendnumArgs(sqInt selectorIndex, sqInt numArgs);
static sqInt genSpecialSelectorArithmetic(void);
static sqInt genSpecialSelectorClass(void);
static sqInt genSpecialSelectorComparison(void);
static sqInt genStaticallyResolvedSpecialSelectorComparison(void);
static NoDbgRegParms sqInt genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt litVarIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static NoDbgRegParms sqInt genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static NoDbgRegParms sqInt genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck);
static NoDbgRegParms sqInt genStorePopRemoteTempAtneedsStoreCheck(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex, sqInt needsStoreCheck);
static NoDbgRegParms sqInt genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex);
static sqInt genUpArrowReturn(void);
static NoDbgRegParms sqInt genVanillaInlinedIdenticalOrNotIf(sqInt orNot);
static NoDbgRegParms void initSimStackForFramefulMethod(sqInt startpc);
static NoDbgRegParms void initSimStackForFramelessBlock(sqInt startpc);
static NoDbgRegParms void initSimStackForFramelessMethod(sqInt startpc);
static NoDbgRegParms sqInt isNonForwarderReceiver(sqInt reg);
static sqInt liveRegisters(void);
static NoDbgRegParms sqInt mapDeadDescriptorIfNeeded(BytecodeDescriptor *descriptor);
static NoDbgRegParms void marshallSendArguments(sqInt numArgs);
static sqInt maybeCompilingFirstPassOfBlockWithInitialPushNil(void);
static NoDbgRegParms sqInt mergeWithFixupIfRequired(BytecodeFixup *fixup);
static NoDbgRegParms sqInt methodAbortTrampolineFor(sqInt numArgs);
static sqInt methodFoundInvalidPostScan(void);
static NoDbgRegParms int needsFrameIfMod16GENumArgs(sqInt stackDelta);
static NoDbgRegParms int needsFrameIfStackGreaterThanOne(sqInt stackDelta);
static NoDbgRegParms sqInt numberOfSpillsInTopNItems(sqInt n);
static NoDbgRegParms sqInt picAbortTrampolineFor(sqInt numArgs);
static sqInt prevInstIsPCAnnotated(void);
static int receiverIsInReceiverResultReg(void);
static NoDbgRegParms void reinitializeFixupsFromthrough(sqInt start, sqInt end);
static NoDbgRegParms sqInt scanBlock(BlockStart *blockStart);
static sqInt scanMethod(void);
static NoDbgRegParms void ssAllocateRequiredRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr);
static NoDbgRegParms void ssFlushUpThroughReceiverVariable(sqInt slotIndex);
static NoDbgRegParms void ssFlushUpThroughTemporaryVariable(sqInt tempIndex);
static NoDbgRegParms void ssPop(sqInt n);
static NoDbgRegParms sqInt ssPushAnnotatedConstant(sqInt literal);
static NoDbgRegParms sqInt ssPushBaseoffset(sqInt reg, sqInt offset);
static NoDbgRegParms sqInt ssPushConstant(sqInt literal);
static NoDbgRegParms sqInt ssPushDesc(SimStackEntry simStackEntry);
static NoDbgRegParms sqInt ssPushRegister(sqInt reg);
static NoDbgRegParms void ssPush(sqInt n);
static SimStackEntry ssSelfDescriptor(void);
static NoDbgRegParms void ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg);
static NoDbgRegParms sqInt ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg);
static NoDbgRegParms void ssStorePoptoReg(sqInt popBoolean, sqInt reg);
static CogSimStackEntry * ssTop(void);
static NoDbgRegParms CogSimStackEntry * ssValue(sqInt n);
static NoDbgRegParms sqInt stackEntryIsBoolean(CogSimStackEntry *simStackEntry);
static sqInt tempsValidAndVolatileEntriesSpilled(void);
static NoDbgRegParms sqInt tryCollapseTempVectorInitializationOfSize(sqInt slots);
static NoDbgRegParms sqInt v3PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils);
static NoDbgRegParms sqInt v3NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj);
static sqInt violatesEnsureSpilledSpillAssert(void);
static void voidReceiverResultRegContainsSelf(void);


/*** Variables ***/
static AbstractInstruction * abstractOpcodes;
static usqInt baseAddress;
static sqInt blockCount;
static AbstractInstruction * blockEntryLabel;
static AbstractInstruction * blockEntryNoContextSwitch;
static BlockStart * blockStarts;
static sqInt breakBlock;
static sqInt breakMethod;
static sqInt byte0;
static sqInt byte1;
static sqInt byte2;
static sqInt byte3;
static sqInt bytecodePC;
static sqInt bytecodeSetOffset;
static sqInt ceActiveContextTrampoline;
static sqInt ceByteSizeOfTrampoline;
static sqInt ceClosureCopyTrampoline;
static sqInt ceCPICMissTrampoline;
static sqInt ceCreateNewArrayTrampoline;
static sqInt ceFetchContextInstVarTrampoline;
static sqInt ceFFICalloutTrampoline;
static sqInt ceFloatObjectOfTrampoline;
static sqInt ceFloatValueOfTrampoline;
static sqInt ceFlushICache;
static sqInt ceFreeTrampoline;
static sqInt ceInstantiateClassIndexableSizeTrampoline;
static sqInt ceInstantiateClassTrampoline;
static sqInt ceMallocTrampoline;
static sqInt ceMethodAbortTrampoline;
static sqInt ceNonLocalReturnTrampoline;
static sqInt cePICAbortTrampoline;
static sqInt cePositive32BitIntegerTrampoline;
static sqInt cePositive32BitValueOfTrampoline;
static sqInt cePositive64BitIntegerTrampoline;
static sqInt cePositive64BitValueOfTrampoline;
static sqInt cePrimReturnEnterCogCode;
static sqInt cePrimReturnEnterCogCodeProfiling;
static sqInt ceReapAndResetErrorCodeTrampoline;
static sqInt ceSendMustBeBooleanAddFalseTrampoline;
static sqInt ceSendMustBeBooleanAddTrueTrampoline;
static sqInt ceSigned32BitIntegerTrampoline;
static sqInt ceSigned32BitValueOfTrampoline;
static sqInt ceSigned64BitIntegerTrampoline;
static sqInt ceSigned64BitValueOfTrampoline;
static sqInt ceStoreCheckTrampoline;
static sqInt ceStoreContextInstVarTrampoline;
static sqInt ceTraceBlockActivationTrampoline;
static sqInt ceTraceLinkedSendTrampoline;
static sqInt ceTraceStoreTrampoline;
static sqInt checkedEntryAlignment;
static sqInt closedPICSize;
static sqInt codeBase;
#if DUAL_MAPPED_CODE_ZONE
static sqInt codeToDataDelta;
#else
# define codeToDataDelta 0
#endif
static sqInt cogConstituentIndex;
static sqInt compactionInProgress;
static sqInt compilationPass;
static sqInt compilationTrace;
static sqInt cPICCaseSize;
static sqInt cPICEndOfCodeOffset;
static sqInt cPICEndSize;
static CogMethod * cPICPrototype;
static sqInt currentCallCleanUpSize;
static sqInt debugBytecodePointers;
static sqInt debugFixupBreaks;
static sqInt debugOpcodeIndices;
static sqInt debugStackPointers;
static sqInt directedSuperBindingSendTrampolines;
static sqInt directedSuperSendTrampolines;
static sqInt disassemblingMethod;
static AbstractInstruction * endCPICCase0;
static sqInt endPC;
static AbstractInstruction * entry;
static sqInt entryPointMask;
static CogMethod * enumeratingCogMethod;
static sqInt expectedFPAlignment;
static sqInt expectedSPAlignment;
static sqInt extA;
static sqInt extB;
static sqInt firstCPICCaseOffset;
static sqInt firstOpcodeIndex;
static sqInt firstSend;
static BytecodeFixup * fixups;
static AbstractInstruction * fullBlockEntry;
static AbstractInstruction * fullBlockNoContextSwitchEntry;
static BytecodeDescriptor generatorTable[256] = {
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushReceiverVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushTemporaryVariableBytecode, 0, needsFrameIfMod16GENumArgs, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushLiteralVariableBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopReceiverVariableBytecode, 0, needsFrameIfImmutability, -1, 0, 1, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 1, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopTemporaryVariableBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushReceiverBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantTrueBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantFalseBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushConstantNilBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushQuickIntegerConstantBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genReturnReceiver, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTrue, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnFalse, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnNil, 0, needsFrameIfInBlock, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromMethod, 0, needsFrameIfInBlock, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0 },
	{ genReturnTopFromBlock, 0, needsFrameNever, -1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ extendedPushBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0 },
	{ extendedStoreBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ extendedStoreAndPopBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, IMMUTABILITY, 0, 0, 1, 0, 0 },
	{ genExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ doubleExtendedDoAnythingBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genExtendedSuperBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0 },
	{ genSecondExtendedSendBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genPopStackBytecode, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ duplicateTopBytecode, 0, needsFrameNever, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushActiveContextBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushNewArrayBytecode, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ unknownBytecode, 0, 0, 0, Nop, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
	{ genPushRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genStoreAndPopRemoteTempLongBytecode, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genPushClosureCopyCopiedValuesBytecode, v3BlockCodeSize, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortUnconditionalJump, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genShortJumpIfFalse, v3ShortForwardBranchDistance, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalBackwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongUnconditionalForwardJump, v3LongBranchDistance, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfTrue, v3LongForwardBranchDistance, 0, 0, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genLongJumpIfFalse, v3LongForwardBranchDistance, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AddRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, SubRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLess, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreater, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpLessOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpGreaterOrEqual, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorComparison, 0, 0, 0, JumpNonZero, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, AndRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorArithmetic, 0, 0, 0, OrRR, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorClass, 0, needsFrameIfStackGreaterThanOne, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorNotEqualsEquals, 0, needsFrameNever, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSpecialSelectorSend, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector0ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector1ArgBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
	{ genSendLiteralSelector2ArgsBytecode, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 }
};
static sqInt guardPageSize;
static sqInt initialPC;
static sqInt introspectionData;
static sqInt introspectionDataIndex;
static int labelCounter;
static sqInt lastDumpedLiteralIndex;
static sqInt lastSend;
static usqInt limitAddress;
static AbstractInstruction * literals;
static sqInt literalsSize;
static sqInt maxLitIndex;
static sqInt methodAbortTrampolines[4];
static sqInt methodBytesFreedSinceLastCompaction;
static sqInt methodCount;
static sqInt methodHeader;
static sqInt methodObj;
static sqInt methodOrBlockNumArgs;
static sqInt methodOrBlockNumTemps;
static usqIntptr_t minValidCallAddress;
static usqInt mzFreeStart;
static sqInt nextLiteralIndex;
static AbstractInstruction * noCheckEntry;
static sqInt numAbstractOpcodes;
static sqInt numExtB;
static usqInt objectReferencesInRuntime[NumObjRefsInRuntime+1];
static sqInt opcodeIndex;
static CogMethod *openPICList = 0;
static sqInt openPICSize;
static sqInt ordinarySendTrampolines[NumSendTrampolines];
static sqInt picAbortTrampolines[4];
static AbstractInstruction * picInterpretAbort;
static sqInt picMissTrampolines[4];
static AbstractInstruction * picMNUAbort;
static BytecodeDescriptor * prevBCDescriptor;
static PrimitiveDescriptor primitiveGeneratorTable[MaxCompiledPrimitiveIndex+1] = {
	{ 0, -1 },
	{ genPrimitiveAdd, 1 },
	{ genPrimitiveSubtract, 1 },
	{ genPrimitiveLessThan, 1 },
	{ genPrimitiveGreaterThan, 1 },
	{ genPrimitiveLessOrEqual, 1 },
	{ genPrimitiveGreaterOrEqual, 1 },
	{ genPrimitiveEqual, 1 },
	{ genPrimitiveNotEqual, 1 },
	{ genPrimitiveMultiply, 1 },
	{ genPrimitiveDivide, 1 },
	{ genPrimitiveMod, 1 },
	{ genPrimitiveDiv, 1 },
	{ genPrimitiveQuo, 1 },
	{ genPrimitiveBitAnd, 1 },
	{ genPrimitiveBitOr, 1 },
	{ genPrimitiveBitXor, 1 },
	{ genPrimitiveBitShift, 1 },
	{ genPrimitiveMakePoint, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAsFloat, 0 },
	{ genPrimitiveFloatAdd, 1 },
	{ genPrimitiveFloatSubtract, 1 },
	{ genPrimitiveFloatLessThan, 1 },
	{ genPrimitiveFloatGreaterThan, 1 },
	{ genPrimitiveFloatLessOrEqual, 1 },
	{ genPrimitiveFloatGreaterOrEqual, 1 },
	{ genPrimitiveFloatEqual, 1 },
	{ genPrimitiveFloatNotEqual, 1 },
	{ genPrimitiveFloatMultiply, 1 },
	{ genPrimitiveFloatDivide, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveFloatSquareRoot, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveAt, 1 },
	{ genPrimitiveAtPut, 2 },
	{ genPrimitiveSize, 0 },
	{ genPrimitiveStringAt, 1 },
	{ genPrimitiveStringAtPut, 2 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ genPrimitiveObjectAt, 1 },
	{ 0, -1 },
	{ genPrimitiveNew, 0 },
	{ genPrimitiveNewWithArg, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNewMethod, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitivePerform, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveStringReplace, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIdentical, 1 },
	{ genPrimitiveClass, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveShallowCopy, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveStringCompareWith, 1 },
	{ genPrimitiveHashMultiply, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveIntegerAt, 1 },
	{ genPrimitiveIntegerAtPut, 2 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveNotIdentical, 1 },
	{ genPrimitiveAsCharacter, -1 },
	{ genPrimitiveImmediateAsInteger, 0 },
	{ 0, -1 },
	{ genPrimitiveSlotAt, 1 },
	{ genPrimitiveSlotAtPut, 2 },
	{ genPrimitiveIdentityHash, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genFastPrimFail, -1 },
	{ genFastPrimFail, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ genPrimitiveClosureValue, 2 },
	{ genPrimitiveClosureValue, 3 },
	{ genPrimitiveClosureValue, 4 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveClosureValue, 0 },
	{ genPrimitiveClosureValue, 1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveHighBit, 0 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ 0, -1 },
	{ genPrimitiveUninitializedNewWithArg, 1 }
};
static sqInt primitiveIndex;
static sqInt processorLock;
static sqInt receiverTags;
static sqInt runtimeObjectRefIndex;
static AbstractInstruction * sendMiss;
static sqInt simNativeStackPtr;
static sqInt simSpillBase;
static SimStackEntry simStack[70];
static sqInt simStackPtr;
static AbstractInstruction * stackCheckLabel;
static AbstractInstruction * stackOverflowCall;
static sqInt superSendTrampolines[NumSendTrampolines];
static sqInt tempOop;
static char *trampolineAddresses[NumTrampolines*2];
static sqInt trampolineTableIndex;
static sqInt uncheckedEntryAlignment;
static usqInt unpairedMethodList;
static sqInt varBaseAddress;
static usqInt youngReferrers;
static unsigned char codeModified;
static unsigned char deadCode;
static unsigned char directedSendUsesBinding;
static unsigned char hasMovableLiteral;
static unsigned char hasYoungReferent;
static unsigned char inBlock;
static unsigned char needsFrame;
static unsigned char regArgsHaveBeenPushed;
static unsigned char useTwoPaths;
static AbstractInstruction aMethodLabel;
static AbstractInstruction * const backEnd = &aMethodLabel;
#if DUAL_MAPPED_CODE_ZONE
static void (*ceFlushDCache)(usqIntptr_t from, usqIntptr_t to);
#endif
static AbstractInstruction * const methodLabel = &aMethodLabel;
sqInt blockNoContextSwitchOffset;
sqInt breakPC;
sqInt cbEntryOffset;
sqInt cbNoSwitchEntryOffset;
sqInt ceBaseFrameReturnTrampoline;
sqInt ceCannotResumeTrampoline;
sqInt ceCheckForInterruptTrampoline;
sqInt ceReturnToInterpreterTrampoline;
#if !defined(cFramePointerInUse)
sqInt cFramePointerInUse;
#endif
sqInt cmEntryOffset;
sqInt cmNoCheckEntryOffset;
usqInt methodZoneBase;
sqInt missOffset;
int traceFlags = 8 /* prim trace log on by default */;
const char * traceFlagsMeanings[] = {
		"1: print trace", "2: trace sends", "4: trace block activations", "8: trace interpreter primitives",
		"16: trace events (context switches, GCs, etc)", "32: trace stack overflow (poll for events hook)",
		"64: trace linked sends", "128: trace fast C call interpreter primitives", null
	};
sqInt traceStores;
void (*ceCall0ArgsPIC)(void);
void (*ceCall1ArgsPIC)(void);
void (*ceCall2ArgsPIC)(void);
void (*ceCallCogCodePopReceiverAndClassRegs)(void);
void (*ceCallCogCodePopReceiverArg0Regs)(void);
void (*ceCallCogCodePopReceiverArg1Arg0Regs)(void);
void (*ceCallCogCodePopReceiverReg)(void);
void (*ceCaptureCStackPointers)(void);
void (*ceEnterCogCodePopReceiverReg)(void);
usqIntptr_t (*ceGetFP)(void);
usqIntptr_t (*ceGetSP)(void);
void (*ceInvokeInterpret)(void);
void (*realCECallCogCodePopReceiverAndClassRegs)(void);
void (*realCECallCogCodePopReceiverArg0Regs)(void);
void (*realCECallCogCodePopReceiverArg1Arg0Regs)(void);
void (*realCECallCogCodePopReceiverReg)(void);
void (*realCEEnterCogCodePopReceiverReg)(void);


/*** Macros ***/
#define inlineCacheValueForSelectorin(backEnd,selector,aCogMethod) (selector)
#define flushDCacheFromto(me,startAddress,endAddress) 0
#define flushICacheFromto(me,startAddress,endAddress) __clear_cache((char*) startAddress, (char*) (endAddress ))
#define roundUpToMethodAlignment(ignored,numBytes) (((numBytes) + 15) & -16)
#define cPICNumCases stackCheckOffset
#define cPICNumCasesHack hack hack hack i.e. the getter macro does all the work
#define abstractInstructionAt(index) (&abstractOpcodes[index])
#define addressIsInInstructions(address) (!((usqInt)(address) & (BytesPerWord-1)) \
							&& (address) >= &abstractOpcodes[0] \
							&& (address) < &abstractOpcodes[opcodeIndex])
#define allocateBlockStarts(numBlocks) do { \
		blockStarts = (numBlocks) ? alloca(sizeof(BlockStart) * (numBlocks)) : 0; \
} while (0)
#define assertValidDualZone() true
#define assertValidDualZoneReadAddress(address) 0
#define assertValidDualZoneWriteAddress(address) 0
#define backEnd() backEnd
#define blockAlignment() 8
#define blockStartAt(index) (&blockStarts[index])
#define ceBaseFrameReturnPC() ceBaseFrameReturnTrampoline
#define ceCannotResumePC() ((usqInt)ceCannotResumeTrampoline)
#define ceCheckForInterruptTrampoline() ceCheckForInterruptTrampoline
#define ceReturnToInterpreterPC() ((usqInt)ceReturnToInterpreterTrampoline)
#define codeByteAtput(address,value) byteAtput((address) + codeToDataDelta, value)
#define codeLong32Atput(address,value) long32Atput((address) + codeToDataDelta, value)
#define codeLong64Atput(address,value) long64Atput((address) + codeToDataDelta, value)
#define codeLongAtput(address,value) longAtput((address) + codeToDataDelta, value)
#define codeMemcpy(dest,src,bytes) memcpy(dest,src,bytes)
#define codeMemmove(dest,src,bytes) memmove((char *)(dest)+codeToDataDelta,src,bytes)
#define cr() putchar('\n')
#define entryOffset() cmEntryOffset
#define generatorAt(index) (&generatorTable[index])
#define getCodeToDataDelta() codeToDataDelta
#define getIsObjectReference() 2
#define halt() warning("halt")
#define haltmsg(msg) warning("halt: " msg)
#define interpretOffset() missOffset
#define mapPerMethodProfile() 0
#define maxCogCodeSize() (16*1024*1024)
#define maybeBreakGeneratingFromto(address,end) 0
#define maybeBreakGeneratingInstructionWithIndex(i) 0
#define maybeHaltIfDebugPC() 0
#define methodLabel() methodLabel
#define methodZoneBase() methodZoneBase
#define minCogMethodAddress() methodZoneBase
#define moveProfileToMethods() 0
#define noCheckEntryOffset() cmNoCheckEntryOffset
#define noContextSwitchBlockEntryOffset() blockNoContextSwitchOffset
#define notYetImplemented() warning("not yet implemented")
#define null 0
#define printNum(n) printf("%" PRIdSQINT, (sqInt) (n))
#define printOnTrace() (traceFlags & 1)
#define recordBlockTrace() (traceFlags & 4)
#define recordEventTrace() (traceFlags & 16)
#define recordFastCCallPrimTrace() (traceFlags & 128)
#define recordOverflowTrace() (traceFlags & 32)
#define recordPrimTrace() (traceFlags & 8)
#define recordSendTrace() (traceFlags & 2)
#define reportError(n) warning("compilation error")
#define setHasMovableLiteral(b) (hasMovableLiteral = (b))
#define setHasYoungReferent(b) (hasYoungReferent = (b))
#define varBaseAddress() varBaseAddress
#define nextOpenPIC methodObject
#define nextOpenPICHack hack hack hack i.e. the getter macro does all the work
#define freeStart() mzFreeStart
#define limitZony() ((CogMethod *)mzFreeStart)
#define methodBytesFreedSinceLastCompaction() methodBytesFreedSinceLastCompaction
#define youngReferrers() youngReferrers
#define numRegArgs() 1
#define maybeConstant(sse) ((sse)->constant)
#define literalInstructionAt(index) (&literals[index])
#define fullBlockEntryOffset() cbEntryOffset
#define fullBlockNoContextSwitchEntryOffset() cbNoSwitchEntryOffset
#define needsFrame() needsFrame
#define fixupAtIndex(index) (&fixups[index])
#define simNativeStackAt(index) (simNativeStack + (index))
#define simSelf() simStack
#define simStackAt(index) (simStack + (index))
#define traceDescriptor(ign) 0
#define traceFixupmerge(igu,ana) 0
#define traceMerge(ign) 0
#define traceSimStack() 0
#define traceSpill(ign) 0
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))


/*** Methods ***/

	/* CogAbstractInstruction>>#addDependent: */
static NoDbgRegParms AbstractInstruction *
addDependent(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anInstruction)
{
	if (!(((self_in_CogAbstractInstruction->dependent)) == null)) {
		(anInstruction->dependent = (self_in_CogAbstractInstruction->dependent));
	}
	return ((self_in_CogAbstractInstruction->dependent) = anInstruction);
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them. */

	/* CogAbstractInstruction>>#availableFloatRegisterOrNoneFor: */
static NoDbgRegParms sqInt
availableFloatRegisterOrNoneFor(AbstractInstruction *self_in_CogAbstractInstruction, sqInt liveRegsMask)
{
	if (!(((liveRegsMask & ((1U << DPFPReg0))) != 0))) {
		return DPFPReg0;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg1))) != 0))) {
		return DPFPReg1;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg2))) != 0))) {
		return DPFPReg2;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg3))) != 0))) {
		return DPFPReg3;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg4))) != 0))) {
		return DPFPReg4;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg5))) != 0))) {
		return DPFPReg5;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg6))) != 0))) {
		return DPFPReg6;
	}
	if (!(((liveRegsMask & ((1U << DPFPReg7))) != 0))) {
		return DPFPReg7;
	}
	return NoReg;
}


/*	For out-of-line literal support, clone a literal from a literal. */

	/* CogAbstractInstruction>>#cloneLiteralFrom: */
static NoDbgRegParms AbstractInstruction *
cloneLiteralFrom(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *existingLiteral)
{
	assert((((existingLiteral->opcode)) == Literal)
	 && ((!((self_in_CogAbstractInstruction->dependent)))
	 && (!((self_in_CogAbstractInstruction->address)))));
	(self_in_CogAbstractInstruction->opcode) = Literal;
	(self_in_CogAbstractInstruction->annotation) = (existingLiteral->annotation);
	((self_in_CogAbstractInstruction->operands))[0] = (((existingLiteral->operands))[0]);
	((self_in_CogAbstractInstruction->operands))[1] = (((existingLiteral->operands))[1]);
	((self_in_CogAbstractInstruction->operands))[2] = (((existingLiteral->operands))[2]);
	return self_in_CogAbstractInstruction;
}


/*	Load the stack pointer register with that of the C stack, effecting
	a switch to the C stack. Used when machine code calls into the
	CoInterpreter run-time (e.g. to invoke interpreter primitives). */

	/* CogAbstractInstruction>>#genLoadCStackPointer */
static NoDbgRegParms sqInt
genLoadCStackPointer(AbstractInstruction *self_in_CogAbstractInstruction)
{

	/* begin gen:literal:operand: */
	checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveAwR, cStackPointerAddress(), NativeSPReg));
	return 0;
}


/*	Load the frame and stack pointer registers with those of the C stack,
	effecting a switch to the C stack. Used when machine code calls into
	the CoInterpreter run-time (e.g. to invoke interpreter primitives).
	N.B. CoInterpreter stack layout dictates that the stack pointer should be
	loaded first.
	The stack zone is allocated on the C stack before the interpreter runs and
	hence before CStackPointer and CFramePointer are captured. So when running
	in machine
	code the native stack pointer and frame pointer appear to be on a colder
	part of the
	stack to CStackPointer and CFramePointer. When CStackPointerhas been set
	and the frame pointer is still in machine code the current frame looks
	like it has lots of
	stack. If the frame pointer was set to CFramePointer before hand then it
	would be beyond the stack pointer for that one instruction. */

	/* CogAbstractInstruction>>#genLoadCStackPointers */
static NoDbgRegParms sqInt
genLoadCStackPointers(AbstractInstruction *self_in_CogAbstractInstruction)
{

	/* begin gen:literal:operand: */
	checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveAwR, cStackPointerAddress(), NativeSPReg));
	checkLiteralforInstruction(cFramePointerAddress(), genoperandoperand(MoveAwR, cFramePointerAddress(), FPReg));
	return 0;
}


/*	Switch back to the Smalltalk stack where there may be a C return address
	on top of stack below
	the last primitive argument. Assign SPReg first because typically it is
	used immediately afterwards.
 */

	/* CogAbstractInstruction>>#genLoadStackPointerForPrimCall: */
static NoDbgRegParms sqInt
genLoadStackPointerForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg)
{

	/* begin gen:literal:operand: */
	checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveAwR, stackPointerAddress(), SPReg));
	return 0;
}


/*	Switch back to the Smalltalk stack. Assign SPReg first
	because typically it is used immediately afterwards. */

	/* CogAbstractInstruction>>#genLoadStackPointers */
static NoDbgRegParms sqInt
genLoadStackPointers(AbstractInstruction *self_in_CogAbstractInstruction)
{

	/* begin gen:literal:operand: */
	checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveAwR, stackPointerAddress(), SPReg));
	checkLiteralforInstruction(framePointerAddress(), genoperandoperand(MoveAwR, framePointerAddress(), FPReg));
	return 0;
}


/*	Switch back to the Smalltalk stack where there may be a C return address
	on top of stack below
	the last primitive argument. Assign SPReg first because typically it is
	used immediately afterwards.
 */

	/* CogAbstractInstruction>>#genLoadStackPointersForPrimCall: */
static NoDbgRegParms sqInt
genLoadStackPointersForPrimCall(AbstractInstruction *self_in_CogAbstractInstruction, sqInt spareReg)
{
	genLoadStackPointers(self_in_CogAbstractInstruction);
	return 0;
}


/*	Save the frame and stack pointer registers to the framePointer
	and stackPointer variables. Used to save the machine code frame
	for use by the run-time when calling into the CoInterpreter run-time. */

	/* CogAbstractInstruction>>#genSaveStackPointers */
static NoDbgRegParms sqInt
genSaveStackPointers(AbstractInstruction *self_in_CogAbstractInstruction)
{

	/* begin gen:operand:literal: */
	checkLiteralforInstruction(framePointerAddress(), genoperandoperand(MoveRAw, FPReg, framePointerAddress()));
	checkLiteralforInstruction(stackPointerAddress(), genoperandoperand(MoveRAw, SPReg, stackPointerAddress()));
	return 0;
}


/*	Generic register swap code. Subclasses for processors that have a true
	exchange operation will override to use it. */

	/* CogAbstractInstruction>>#genSwapR:R:Scratch: */
static NoDbgRegParms AbstractInstruction *
genSwapRRScratch(AbstractInstruction *self_in_CogAbstractInstruction, sqInt regA, sqInt regB, sqInt regTmp)
{
    AbstractInstruction *first;

	first = genoperandoperand(MoveRR, regA, regTmp);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, regB, regA);
	genoperandoperand(MoveRR, TempReg, regB);
	return first;
}

	/* CogAbstractInstruction>>#genWriteCResultIntoReg: */
static NoDbgRegParms AbstractInstruction *
genWriteCResultIntoReg(AbstractInstruction *self_in_CogAbstractInstruction, sqInt abstractRegister)
{
	if ((abstractRegister != NoReg)
	 && (abstractRegister != ABIResultReg)) {
		genoperandoperand(MoveRR, ABIResultReg, abstractRegister);
	}
	return self_in_CogAbstractInstruction;
}


/*	For out-of-line literal support, initialize a sharable literal. */

	/* CogAbstractInstruction>>#initializeSharableLiteral: */
static NoDbgRegParms AbstractInstruction *
initializeSharableLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal)
{
	(self_in_CogAbstractInstruction->opcode) = Literal;
	/* separate := nil for Slang */
	(self_in_CogAbstractInstruction->annotation) = null;
	(self_in_CogAbstractInstruction->address) = null;
	(self_in_CogAbstractInstruction->dependent) = null;
	((self_in_CogAbstractInstruction->operands))[0] = literal;
	((self_in_CogAbstractInstruction->operands))[1] = (1 + (((sqInt)((usqInt)(BytesPerOop) << 1))));
	((self_in_CogAbstractInstruction->operands))[2] = -1;
	return self_in_CogAbstractInstruction;
}


/*	For out-of-line literal support, initialize an unsharable literal. */

	/* CogAbstractInstruction>>#initializeUniqueLiteral: */
static NoDbgRegParms AbstractInstruction *
initializeUniqueLiteral(AbstractInstruction *self_in_CogAbstractInstruction, sqInt literal)
{
	(self_in_CogAbstractInstruction->opcode) = Literal;
	/* separate := nil for Slang */
	(self_in_CogAbstractInstruction->annotation) = null;
	(self_in_CogAbstractInstruction->address) = null;
	(self_in_CogAbstractInstruction->dependent) = null;
	((self_in_CogAbstractInstruction->operands))[0] = literal;
	((self_in_CogAbstractInstruction->operands))[1] = (0 + (((sqInt)((usqInt)(BytesPerOop) << 1))));
	((self_in_CogAbstractInstruction->operands))[2] = -1;
	return self_in_CogAbstractInstruction;
}

	/* CogAbstractInstruction>>#isAnInstruction: */
static NoDbgRegParms sqInt
isAnInstruction(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *addressOrInstruction)
{
	return (addressIsInInstructions(addressOrInstruction))
	 || (addressOrInstruction == (methodLabel()));
}

	/* CogAbstractInstruction>>#isJump */
static NoDbgRegParms int
isJump(AbstractInstruction *self_in_CogAbstractInstruction)
{
	return ((((self_in_CogAbstractInstruction->opcode)) >= FirstJump) && (((self_in_CogAbstractInstruction->opcode)) <= LastJump));
}


/*	Set the target of a jump instruction. These all have the target in the
	first operand. */

	/* CogAbstractInstruction>>#jmpTarget: */
static NoDbgRegParms AbstractInstruction *
jmpTarget(AbstractInstruction *self_in_CogAbstractInstruction, AbstractInstruction *anAbstractInstruction)
{
	((self_in_CogAbstractInstruction->operands))[0] = (((usqInt)anAbstractInstruction));
	return anAbstractInstruction;
}


/*	Answer the constant loaded by the instruction sequence just before this
	address: 
 */

	/* CogAbstractInstruction>>#literal32BeforeFollowingAddress: */
static NoDbgRegParms sqInt
literal32BeforeFollowingAddress(AbstractInstruction *self_in_CogAbstractInstruction, sqInt followingAddress)
{
	return literalBeforeFollowingAddress(self_in_CogAbstractInstruction, followingAddress);
}


/*	We assume here that calls and jumps look the same as regards their
	displacement. This works on at least x86, ARM and x86_64. Processors on
	which that isn't the
	case can override as necessary. */

	/* CogAbstractInstruction>>#relocateJumpLongBeforeFollowingAddress:by: */
static NoDbgRegParms AbstractInstruction *
relocateJumpLongBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta)
{
	relocateCallBeforeReturnPCby(self_in_CogAbstractInstruction, pc, delta);
	return self_in_CogAbstractInstruction;
}


/*	Relocate a long conditional jump before pc. Default to relocating a
	non-conditional jump.
	Processors that have different formats for conditional and unconditional
	jumps override. */

	/* CogAbstractInstruction>>#relocateJumpLongConditionalBeforeFollowingAddress:by: */
static NoDbgRegParms AbstractInstruction *
relocateJumpLongConditionalBeforeFollowingAddressby(AbstractInstruction *self_in_CogAbstractInstruction, sqInt pc, sqInt delta)
{
	relocateJumpLongBeforeFollowingAddressby(self_in_CogAbstractInstruction, pc, delta);
	return self_in_CogAbstractInstruction;
}

	/* CogAbstractInstruction>>#resolveJumpTarget */
static NoDbgRegParms AbstractInstruction *
resolveJumpTarget(AbstractInstruction *self_in_CogAbstractInstruction)
{
    BytecodeFixup *fixup;

	assert(isJump(self_in_CogAbstractInstruction));
	fixup = ((BytecodeFixup *) (((self_in_CogAbstractInstruction->operands))[0]));
	if (addressIsInFixups(fixup)) {
		assert(addressIsInInstructions((fixup->targetInstruction)));
		jmpTarget(self_in_CogAbstractInstruction, (fixup->targetInstruction));
	}
	return self_in_CogAbstractInstruction;
}


/*	Rewrite a conditional jump long to jump to target. This version defaults
	to using
	rewriteJumpLongAt:, which works for many ISAs. Subclasses override if
	necessary.  */

	/* CogAbstractInstruction>>#rewriteConditionalJumpLongAt:target: */
static NoDbgRegParms sqInt
rewriteConditionalJumpLongAttarget(AbstractInstruction *self_in_CogAbstractInstruction, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteJumpLongAttarget(self_in_CogAbstractInstruction, callSiteReturnAddress, callTargetAddress);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc
	ADDS destReg, srcReg, #immediate ROR #rot - ARM_ARM v7 DDI10406 p. A8-23 */

	/* CogARMCompiler>>#adds:rn:imm:ror: */
static NoDbgRegParms sqInt
addsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(AddOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc.
	ADD destReg, srcReg, #immediate ROR #rot - ARM_ARM v7 DDI10406 p. A8-23 */

	/* CogARMCompiler>>#add:rn:imm:ror: */
static NoDbgRegParms sqInt
addrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(AddOpcode) << 21))) | (0)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	return an ADD destReg, srcReg, addReg instruction
	ADD destReg, srcReg, addReg - ARM_ARM v7 DDI10406 p. A8-24 */

	/* CogARMCompiler>>#add:rn:rm: */
static NoDbgRegParms sqInt
addrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt addReg)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AddOpcode) << 21))) | (0)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (addReg & 0xFFF);
}


/*	Answer the address of the __aeabi_idivmod() call provided by the ARM low
	level libs to do an integer divide that returns the quo in R0 and rem in
	R1. A word on the somewhat strange usage of idivmod herein; we need a
	declaration for the _aeabi_idivmod helper function, despite the fact that
	in a simple C program test, you don't.
	To get that declaration we need a variable to hang it off; thus the
	non-existent var idivmod, and in simulation we need to simulate it, which
	is what aeabiDiv:Mod: does.
 */

	/* CogARMCompiler>>#aeabiDivModFunctionAddr */
static NoDbgRegParms usqInt
aeabiDivModFunctionAddr(AbstractInstruction *self_in_CogARMCompiler)
{
    extern void __aeabi_idivmod(int dividend, int divisor);

	return (usqInt)__aeabi_idivmod;
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc
	ANDS destReg, srcReg, #immediate ROR #rot - ARM_ARM v7 DDI10406 p. A8-34 */

	/* CogARMCompiler>>#ands:rn:imm:ror: */
static NoDbgRegParms sqInt
andsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc
	AND destReg, srcReg, #immediate ROR #rot - ARM_ARM v7 DDI10406 p. A8-34 */

	/* CogARMCompiler>>#and:rn:imm:ror: */
static NoDbgRegParms sqInt
andrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(AndOpcode) << 21))) | (0)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them.
	N.B. Do /not/ allocate TempReg. */
/*	Answer an unused abstract register in the liveRegMask.
	Subclasses with more registers can override to answer them.
	N.B. Do /not/ allocate TempReg. */

	/* CogARMCompiler>>#availableRegisterOrNoneFor: */
static NoDbgRegParms sqInt
availableRegisterOrNoneFor(AbstractInstruction *self_in_CogARMCompiler, sqInt liveRegsMask)
{
	if (!(((liveRegsMask & ((1U << Extra0Reg))) != 0))) {
		return Extra0Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra1Reg))) != 0))) {
		return Extra1Reg;
	}
	if (!(((liveRegsMask & ((1U << Extra2Reg))) != 0))) {
		return Extra2Reg;
	}
	if (!(((liveRegsMask & ((1U << Arg1Reg))) != 0))) {
		return Arg1Reg;
	}
	if (!(((liveRegsMask & ((1U << Arg0Reg))) != 0))) {
		return Arg0Reg;
	}
	if (!(((liveRegsMask & ((1U << SendNumArgsReg))) != 0))) {
		return SendNumArgsReg;
	}
	if (!(((liveRegsMask & ((1U << ClassReg))) != 0))) {
		return ClassReg;
	}
	if (!(((liveRegsMask & ((1U << ReceiverResultReg))) != 0))) {
		return ReceiverResultReg;
	}
	return NoReg;
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc
	BICS destReg, srcReg, #immediate ROR #rot - ARM_ARM v7 DDI10406 pp.
	A8-50-1 
 */

	/* CogARMCompiler>>#bics:rn:imm:ror: */
static NoDbgRegParms sqInt
bicsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(BicOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	return a BL offset instruction; offset is signed 24bits of WORD offset, so
	+_32Mbyte range. Return address is in LR
	BL offset - ARM_ARM v7 DDI10406 pp. A8-58-9
 */

	/* CogARMCompiler>>#bl: */
static NoDbgRegParms sqInt
bl(AbstractInstruction *self_in_CogARMCompiler, sqInt offset)
{
	return (((int)((usqInt)(AL) << 28))) | ((((int)((usqInt)((10 | (1 & 1))) << 24))) | ((((usqInt)(offset)) >> 2) & 0xFFFFFF));
}


/*	return a B offset instruction; offset is signed 24bits of WORD offset, so
	+_32Mbyte range
	B offset - ARM_ARM v7 DDI10406 pp. A8-44-5
 */

	/* CogARMCompiler>>#b: */
static NoDbgRegParms sqInt
b(AbstractInstruction *self_in_CogARMCompiler, sqInt offset)
{
	return (((int)((usqInt)(AL) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset)) >> 2) & 0xFFFFFF));
}


/*	ARMv8 calls and jumps span +/- 128 mb, more than enough for intra-zone
	calls and jumps.
 */

	/* CogARMCompiler>>#callInstructionByteSize */
static NoDbgRegParms sqInt
callInstructionByteSize(AbstractInstruction *self_in_CogARMCompiler)
{
	return 4;
}


/*	Answer the address that the call immediately preceding
	callSiteReturnAddress will jump to.
 */
/*	this is also used by #jumpLongTargetBeforeFollowingAddress:. */

	/* CogARMCompiler>>#callTargetFromReturnAddress: */
static NoDbgRegParms sqInt
callTargetFromReturnAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt callSiteReturnAddress)
{
    sqInt call;
    sqInt callDistance;
    sqInt relativeJump;

	call = longAt(callSiteReturnAddress - 4);
	assert((instructionIsB(self_in_CogARMCompiler, call))
	 || (instructionIsBL(self_in_CogARMCompiler, call)));
	/* begin extractOffsetFromBL: */
	relativeJump = call & 0xFFFFFF;
	relativeJump = (((relativeJump & (0x800000)) != 0)
		? ((int) (((sqInt)((usqInt)((relativeJump | 0x3F000000)) << 2))))
		: ((sqInt)((usqInt)(relativeJump) << 2)));
	callDistance = relativeJump;
	return (callSiteReturnAddress + 4) + (((int) callDistance));
}


/*	Because we don't use Thumb, each ARM instruction has 4 bytes. Many
	abstract opcodes need more than one instruction. Instructions that refer
	to constants and/or literals depend on literals being stored in-line or
	out-of-line. 
	N.B. The ^N forms are to get around the bytecode compiler's long branch
	limits which are exceeded when each case jumps around the otherwise. */

	/* CogARMCompiler>>#computeMaximumSize */
static NoDbgRegParms sqInt
computeMaximumSize(AbstractInstruction *self_in_CogARMCompiler)
{
    sqInt constant;
    sqInt constant1;
    sqInt constant2;
    sqInt constant4;
    sqInt constant5;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    unsigned int i4;
    unsigned int i5;
    unsigned int i6;
    sqInt i8;
    sqInt i9;
    int n1;
    int n2;
    int n3;
    int n4;
    sqInt r1;
    sqInt r2;
    sqInt r3;
    sqInt value;
    unsigned int value1;

	switch ((self_in_CogARMCompiler->opcode)) {
	case Label:
		return 0;

	case Literal:
	case Fill32:
	case Nop:
	case Call:
	case JumpR:
	case Jump:
	case JumpLong:
	case JumpZero:
	case JumpNonZero:
	case JumpNegative:
	case JumpNonNegative:
	case JumpOverflow:
	case JumpNoOverflow:
	case JumpCarry:
	case JumpNoCarry:
	case JumpLess:
	case JumpGreaterOrEqual:
	case JumpGreater:
	case JumpLessOrEqual:
	case JumpBelow:
	case JumpAboveOrEqual:
	case JumpAbove:
	case JumpBelowOrEqual:
	case JumpLongZero:
	case JumpLongNonZero:
	case Stop:
	case AddRR:
	case AndRR:
	case CmpRR:
	case OrRR:
	case XorRR:
	case SubRR:
	case AddRRR:
	case SubRRR:
	case NegateR:
	case LogicalShiftLeftCqR:
	case LogicalShiftRightCqR:
	case ArithmeticShiftRightCqRR:
	case LogicalShiftRightCqRR:
	case LogicalShiftLeftCqRR:
	case ArithmeticShiftRightCqR:
	case LogicalShiftLeftRR:
	case LogicalShiftRightRR:
	case ArithmeticShiftRightRR:
	case AddRdRd:
	case CmpRdRd:
	case SubRdRd:
	case MulRdRd:
	case DivRdRd:
	case SqrtRd:
	case ClzRR:
	case SMULL:
	case MSR:
	case CMPSMULL:
	case PopLDM:
	case PushSTM:
	case MoveRR:
	case MoveRdRd:
	case MoveRdM64r:
	case MoveM64rRd:
	case MoveXbrRR:
	case MoveRXbrR:
	case MoveXwrRR:
	case MoveRXwrR:
	case PopR:
	case PushR:
		return 4;

	case AlignmentNops:
		return (((self_in_CogARMCompiler->operands))[0]) - 4;

	case CallFull:
	case JumpFull:
	case AddCwR:
	case AndCwR:
	case CmpCwR:
	case OrCwR:
	case SubCwR:
	case XorCwR:
		return 8;

	case JumpFPEqual:
	case JumpFPNotEqual:
	case JumpFPLess:
	case JumpFPGreaterOrEqual:
	case JumpFPGreater:
	case JumpFPLessOrEqual:
	case JumpFPOrdered:
	case JumpFPUnordered:
	case ConvertRRd:
		return 8;

	case RetN:
		return ((((self_in_CogARMCompiler->operands))[0]) == 0
			? 4
			: 8);

	case AddCqR:
	case AddCqRR:
	case CmpCqR:
	case SubCqR:
		constant = ((self_in_CogARMCompiler->operands))[0];
		/* begin rotateable8bitSignedImmediate:ifTrue:ifFalse: */
		value = constant;
		while (1) {
			if ((value & 0xFF) == value) {
				return ((n1 = constant != value),
					4);
			}
			for (i1 = 2; i1 <= 30; i1 += 2) {
				if ((value & (((0xFFU << i1) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i1)))) == value) {
					return ((r1 = 32 - i1),
						(i4 = (((usqInt)(value)) >> i1) | ((((sqInt)((usqInt)(value) << (32 - i1)))) & 0xFFFFFFFFU)),
						(n2 = constant != value),
						4);
				}
			}
			if (!((value == constant)
			 && (constant != 0))) break;
			value = -constant;
		}
		return 8;

	case AndCqR:
	case AndCqRR:
	case XorCqR:
		constant1 = ((self_in_CogARMCompiler->operands))[0];
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value1 = constant1;
		while (1) {
			if ((value1 & 0xFF) == value1) {
				return ((n3 = constant1 != value1),
					4);
			}
			for (i2 = 2; i2 <= 30; i2 += 2) {
				if ((value1 & (((0xFFU << i2) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i2)))) == value1) {
					return ((r2 = 32 - i2),
						(i5 = ((value1) >> i2) | ((value1 << (32 - i2)) & 0xFFFFFFFFU)),
						(n4 = constant1 != value1),
						4);
				}
			}
			if (!(value1 == constant1)) break;
			value1 = (constant1 < 0
				? -1 - constant1
				: (unsigned int)~constant1);
		}
		return 8;

	case OrCqR:
	case TstCqR:
	case LoadEffectiveAddressMwrR:
	case MoveM16rR:
		constant2 = ((self_in_CogARMCompiler->operands))[0];
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((constant2 & 0xFF) == constant2) {
			return 4;
		}
		for (i3 = 2; i3 <= 30; i3 += 2) {
			if ((constant2 & (((0xFFU << i3) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i3)))) == constant2) {
				return ((r3 = 32 - i3),
					(i6 = (((usqInt)(constant2)) >> i3) | ((((sqInt)((usqInt)(constant2) << (32 - i3)))) & 0xFFFFFFFFU)),
					4);
			}
		}
		return 8;

	case MoveCqR:
		return 4 /* begin literalLoadInstructionBytes */;

	case MoveCwR:
		return 4 /* begin literalLoadInstructionBytes */;

	case MoveAwR:
	case MoveAbR:
	case PrefetchAw:
		return (		/* begin isAddressRelativeToVarBase: */
			((((self_in_CogARMCompiler->operands))[0]))
		 && (((((self_in_CogARMCompiler->operands))[0]) >= (varBaseAddress()))
		 && (((((self_in_CogARMCompiler->operands))[0]) - (varBaseAddress())) < (0x1000)))
			? 4
			: 8);

	case MoveRAw:
	case MoveRAb:
		return (		/* begin isAddressRelativeToVarBase: */
			((((self_in_CogARMCompiler->operands))[1]))
		 && (((((self_in_CogARMCompiler->operands))[1]) >= (varBaseAddress()))
		 && (((((self_in_CogARMCompiler->operands))[1]) - (varBaseAddress())) < (0x1000)))
			? 4
			: 8);

	case MoveRMwr:
	case MoveRMbr:
	case MoveRM16r:
		constant4 = ((self_in_CogARMCompiler->operands))[1];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(constant4)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (constant4 >= 0) {
				return 4;
			}
			else {
				return ((i8 = SQABS(constant4)),
					4);
			}
		}
		else {
			return 8;
		}

	case MoveMbrR:
	case MoveMwrR:
		constant5 = ((self_in_CogARMCompiler->operands))[0];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(constant5)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (constant5 >= 0) {
				return 4;
			}
			else {
				return ((i9 = SQABS(constant5)),
					4);
			}
		}
		else {
			return 8;
		}

	case PushCw:
		return 8;

	case PushCq:
		return 8;

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	Generate concrete machine code for the instruction at actualAddress,
	setting machineCodeSize, and answer the following address. */
/*	Generate concrete machine code for the instruction at actualAddress,
	setting machineCodeSize, and answer the following address. */

	/* CogARMCompiler>>#concretizeAt: */
static NoDbgRegParms sqInt
concretizeAt(AbstractInstruction *self_in_CogARMCompiler, sqInt actualAddress)
{
	assert((actualAddress % 4) == 0);
	(self_in_CogARMCompiler->address) = actualAddress;
	(self_in_CogARMCompiler->machineCodeSize) = dispatchConcretize(self_in_CogARMCompiler);
	assert((((self_in_CogARMCompiler->maxSize)) == null)
	 || (((self_in_CogARMCompiler->maxSize)) >= ((self_in_CogARMCompiler->machineCodeSize))));
	return actualAddress + ((self_in_CogARMCompiler->machineCodeSize));
}


/*	Generate a CMP a, b, ASR #31 instruction, specifically for comparing the
	resutls of SMULLs in genMulR:R:
 */

	/* CogARMCompiler>>#concretizeCMPSMULL */
static NoDbgRegParms sqInt
concretizeCMPSMULL(AbstractInstruction *self_in_CogARMCompiler)
{
    usqInt hiReg;
    usqInt loReg;

	hiReg = ((self_in_CogARMCompiler->operands))[0];
	loReg = ((self_in_CogARMCompiler->operands))[1];
	/* begin machineCodeAt:put: */
	((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(CmpOpcode) << 21))) | (0x100000)))) | ((hiReg << 16) | (0))) + (0xF80)) + (64)) + loReg);
	return 4;
}


/*	Concretize the current instruction, but with a condition. */

	/* CogARMCompiler>>#concretizeConditionalInstruction */
static NoDbgRegParms unsigned char
concretizeConditionalInstruction(AbstractInstruction *self_in_CogARMCompiler)
{
    sqInt aWord;
    sqInt i;
    sqInt instr;
    unsigned char savedCond;

	assert(((self_in_CogARMCompiler->conditionOrNil)));
	savedCond = (self_in_CogARMCompiler->conditionOrNil);
	(self_in_CogARMCompiler->conditionOrNil) = null;
	(self_in_CogARMCompiler->machineCodeSize) = dispatchConcretize(self_in_CogARMCompiler);
	(self_in_CogARMCompiler->conditionOrNil) = savedCond;
	for (i = 0; i < ((self_in_CogARMCompiler->machineCodeSize)); i += 4) {
		instr = (((((self_in_CogARMCompiler->machineCode))[i / 4]) | (0xF0000000U)) - (0xF0000000U));
		aWord = instr | (((int)((usqInt)((((self_in_CogARMCompiler->conditionOrNil)) & 15)) << 28)));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[i / 4] = aWord;
	}
	return (self_in_CogARMCompiler->machineCodeSize);
}


/*	fill with operand 0 according to the processor's endianness */

	/* CogARMCompiler>>#concretizeFill32 */
static NoDbgRegParms sqInt
concretizeFill32(AbstractInstruction *self_in_CogARMCompiler)
{
    sqInt aWord;

	aWord = ((self_in_CogARMCompiler->operands))[0];
	/* begin machineCodeAt:put: */
	((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord;
	return 4;
}


/*	Generate an MSR CPSR_f, #flags instruction.
	Note that we only have business with the NZCV flags so we use
	N -> 8
	Z -> 4
	C -> 2
	V -> 1.
	You don't want to mess with this too much.
 */

	/* CogARMCompiler>>#concretizeMSR */
static NoDbgRegParms sqInt
concretizeMSR(AbstractInstruction *self_in_CogARMCompiler)
{
    sqInt aWord;
    usqInt flags;

	flags = ((self_in_CogARMCompiler->operands))[0];
	aWord = msr(self_in_CogARMCompiler, flags);
	/* begin machineCodeAt:put: */
	((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord;
	return 4;
}

	/* CogARMCompiler>>#concretizePushOrPopMultipleRegisters: */
static NoDbgRegParms sqInt
concretizePushOrPopMultipleRegisters(AbstractInstruction *self_in_CogARMCompiler, sqInt doPush)
{
	assert((((self_in_CogARMCompiler->operands))[0]) != 0);
	((self_in_CogARMCompiler->machineCode))[0] = ((((((int)((usqInt)(AL) << 28))) + ((doPush
	? 0x9200000
	: 0x8B00000))) + (((int)((usqInt)(SP) << 16)))) + (((self_in_CogARMCompiler->operands))[0]));
	return 4;
}


/*	Generate an SMULL loResultReg, hiResultReg, srcA, srcB instruction */

	/* CogARMCompiler>>#concretizeSMULL */
static NoDbgRegParms sqInt
concretizeSMULL(AbstractInstruction *self_in_CogARMCompiler)
{
    sqInt hiResultReg;
    usqInt loResultReg;
    usqInt srcA;
    usqInt srcB;


	/* NOTE: srcB contains the other mutiplicand at this point. It is OK to use it as the destination for the low part of the result and in fact this saves us moving it later */
	srcA = ((self_in_CogARMCompiler->operands))[0];
	loResultReg = (srcB = ((self_in_CogARMCompiler->operands))[1]);
	hiResultReg = RISCTempReg;
	/* begin machineCodeAt:put: */
	((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((((((int)((usqInt)(AL) << 28))) | ((0) | ((0xC00000) | (0)))) | ((((sqInt)((usqInt)(hiResultReg) << 16))) | (loResultReg << 12))) + (srcA << 8)) + (144)) + srcB);
	return 4;
}


/*	test for the NV condition code; this isn't allowed as an actual condition
	and is used to encdoe many of the newer instructions
 */

	/* CogARMCompiler>>#conditionIsNotNever: */
static NoDbgRegParms int
conditionIsNotNever(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (((usqInt)(instr)) >> 28) < 15;
}


/*	return an {opcode} destReg, srcReg, addReg lsl #shft */
/*	important detail - a 0 shft requires setting the shift-type code to 0 to
	avoid potential instruction confusion
 */

	/* CogARMCompiler>>#dataOpType:rd:rn:rm:lsr: */
static NoDbgRegParms sqInt
dataOpTyperdrnrmlsr(AbstractInstruction *self_in_CogARMCompiler, sqInt armOpcode, sqInt destReg, sqInt srcReg, sqInt addReg, sqInt shft)
{
	if (shft == 0) {
		return (((((int)((usqInt)(AL) << 28))) | ((0) | ((((sqInt)((usqInt)(armOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (addReg & 0xFFF);
	}
	else {
		return (((((int)((usqInt)(AL) << 28))) | ((0) | ((((sqInt)((usqInt)(armOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | ((((((sqInt)((usqInt)(shft) << 7))) | 32) | addReg) & 0xFFF);
	}
}


/*	Attempt to generate concrete machine code for the instruction at address.
	This is the inner dispatch of concretizeAt: actualAddress which exists
	only to get around the branch size limits in the SqueakV3 (blue book
	derived) bytecode set. */

	/* CogARMCompiler>>#dispatchConcretize */
static NoDbgRegParms sqInt
dispatchConcretize(AbstractInstruction *self_in_CogARMCompiler)
{
    usqInt addressOperand;
    sqInt aWord;
    sqInt aWord1;
    sqInt aWord10;
    sqInt aWord11;
    sqInt aWord110;
    sqInt aWord111;
    sqInt aWord1110;
    sqInt aWord1111;
    sqInt aWord1112;
    sqInt aWord1113;
    sqInt aWord1114;
    sqInt aWord1115;
    sqInt aWord1116;
    sqInt aWord112;
    sqInt aWord113;
    sqInt aWord114;
    sqInt aWord115;
    sqInt aWord116;
    sqInt aWord117;
    sqInt aWord118;
    sqInt aWord119;
    sqInt aWord12;
    sqInt aWord120;
    sqInt aWord121;
    sqInt aWord122;
    sqInt aWord123;
    sqInt aWord124;
    sqInt aWord125;
    sqInt aWord126;
    sqInt aWord127;
    sqInt aWord128;
    sqInt aWord129;
    sqInt aWord13;
    sqInt aWord130;
    sqInt aWord131;
    sqInt aWord132;
    sqInt aWord133;
    sqInt aWord134;
    sqInt aWord135;
    sqInt aWord14;
    sqInt aWord15;
    sqInt aWord16;
    sqInt aWord17;
    sqInt aWord18;
    sqInt aWord19;
    sqInt aWord2;
    sqInt aWord20;
    sqInt aWord21;
    sqInt aWord210;
    sqInt aWord211;
    sqInt aWord2110;
    sqInt aWord2111;
    sqInt aWord212;
    sqInt aWord213;
    sqInt aWord214;
    sqInt aWord215;
    sqInt aWord216;
    sqInt aWord217;
    sqInt aWord218;
    sqInt aWord219;
    sqInt aWord22;
    sqInt aWord220;
    sqInt aWord221;
    sqInt aWord222;
    sqInt aWord23;
    sqInt aWord24;
    sqInt aWord25;
    sqInt aWord26;
    sqInt aWord27;
    sqInt aWord28;
    sqInt aWord29;
    sqInt aWord3;
    sqInt aWord30;
    sqInt aWord31;
    sqInt aWord310;
    sqInt aWord311;
    sqInt aWord312;
    sqInt aWord313;
    sqInt aWord314;
    sqInt aWord315;
    sqInt aWord316;
    sqInt aWord32;
    sqInt aWord33;
    sqInt aWord34;
    sqInt aWord35;
    sqInt aWord36;
    sqInt aWord37;
    sqInt aWord38;
    sqInt aWord39;
    sqInt aWord4;
    sqInt aWord40;
    sqInt aWord41;
    sqInt aWord410;
    sqInt aWord411;
    sqInt aWord42;
    sqInt aWord43;
    sqInt aWord44;
    sqInt aWord45;
    sqInt aWord46;
    sqInt aWord47;
    sqInt aWord48;
    sqInt aWord49;
    sqInt aWord5;
    sqInt aWord50;
    sqInt aWord51;
    sqInt aWord52;
    sqInt aWord53;
    sqInt aWord54;
    sqInt aWord55;
    sqInt aWord56;
    sqInt aWord57;
    sqInt aWord58;
    sqInt aWord59;
    sqInt aWord6;
    sqInt aWord60;
    sqInt aWord61;
    sqInt aWord62;
    sqInt aWord63;
    sqInt aWord64;
    sqInt aWord65;
    sqInt aWord66;
    sqInt aWord67;
    sqInt aWord68;
    sqInt aWord69;
    sqInt aWord7;
    sqInt aWord70;
    sqInt aWord71;
    sqInt aWord72;
    sqInt aWord73;
    sqInt aWord74;
    sqInt aWord75;
    sqInt aWord76;
    sqInt aWord77;
    sqInt aWord8;
    sqInt aWord9;
    usqInt base;
    usqInt base1;
    usqInt base2;
    usqInt base3;
    usqInt baseReg;
    usqInt baseReg1;
    usqInt baseReg2;
    usqInt constant;
    usqInt constant1;
    usqInt constant10;
    usqInt constant11;
    usqInt constant12;
    usqInt constant13;
    usqInt constant14;
    usqInt constant15;
    usqInt constant2;
    usqInt constant3;
    usqInt constant4;
    sqInt constant5;
    usqInt constant6;
    usqInt constant7;
    usqInt constant8;
    usqInt constant9;
    AbstractInstruction *dependentChain;
    usqInt dest;
    usqInt dest1;
    usqInt dest2;
    usqInt destAddr;
    usqInt destAddr1;
    usqInt destReg;
    usqInt destReg1;
    usqInt destReg10;
    usqInt destReg11;
    usqInt destReg12;
    usqInt destReg13;
    usqInt destReg14;
    usqInt destReg15;
    usqInt destReg2;
    usqInt destReg3;
    usqInt destReg4;
    usqInt destReg5;
    usqInt destReg6;
    usqInt destReg7;
    usqInt destReg8;
    usqInt destReg9;
    usqInt distance;
    usqInt distance1;
    usqInt distance2;
    usqInt distance3;
    usqInt distance4;
    usqInt distance5;
    usqInt distReg;
    usqInt distReg1;
    usqInt distReg2;
    usqInt dstReg;
    usqInt dstReg1;
    sqInt flagsOrOpcode;
    sqInt flagsOrOpcode1;
    sqInt flagsOrOpcode11;
    sqInt flagsOrOpcode12;
    sqInt flagsOrOpcode13;
    sqInt flagsOrOpcode14;
    sqInt flagsOrOpcode2;
    sqInt flagsOrOpcode3;
    sqInt flagsOrOpcode4;
    sqInt flagsOrOpcode5;
    usqInt fpReg;
    sqInt hb;
    sqInt hb1;
    sqInt hb11;
    sqInt hb12;
    sqInt hb2;
    sqInt hb3;
    sqInt hb4;
    sqInt hb5;
    sqInt hb6;
    sqInt i;
    sqInt i1;
    sqInt i10;
    sqInt i11;
    sqInt i12;
    sqInt i13;
    sqInt i14;
    sqInt i15;
    sqInt i16;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    sqInt i5;
    sqInt i6;
    sqInt i7;
    sqInt i8;
    sqInt immediate;
    sqInt immediate1;
    sqInt immediate10;
    sqInt immediate11;
    sqInt immediate110;
    unsigned int immediate1101;
    unsigned int immediate111;
    unsigned int immediate112;
    unsigned int immediate113;
    sqInt immediate12;
    unsigned int immediate121;
    sqInt immediate13;
    unsigned int immediate131;
    sqInt immediate14;
    unsigned int immediate141;
    sqInt immediate15;
    unsigned int immediate151;
    sqInt immediate152;
    unsigned int immediate153;
    sqInt immediate16;
    unsigned int immediate161;
    sqInt immediate17;
    unsigned int immediate171;
    sqInt immediate18;
    unsigned int immediate181;
    sqInt immediate19;
    unsigned int immediate191;
    sqInt immediate2;
    sqInt immediate20;
    unsigned int immediate201;
    usqInt immediate21;
    sqInt immediate22;
    sqInt immediate3;
    sqInt immediate31;
    sqInt immediate4;
    sqInt immediate41;
    sqInt immediate5;
    sqInt immediate51;
    sqInt immediate6;
    sqInt immediate61;
    sqInt immediate7;
    sqInt immediate71;
    sqInt immediate8;
    unsigned int immediate81;
    sqInt immediate9;
    unsigned int immediate91;
    usqInt index;
    usqInt index1;
    usqInt index2;
    usqInt index3;
    sqInt instrOffset;
    sqInt instrOffset1;
    sqInt instrOffset10;
    sqInt instrOffset11;
    sqInt instrOffset12;
    sqInt instrOffset13;
    sqInt instrOffset14;
    sqInt instrOffset15;
    sqInt instrOffset16;
    sqInt instrOffset17;
    sqInt instrOffset18;
    sqInt instrOffset19;
    sqInt instrOffset2;
    sqInt instrOffset20;
    sqInt instrOffset21;
    sqInt instrOffset22;
    sqInt instrOffset23;
    sqInt instrOffset24;
    sqInt instrOffset25;
    sqInt instrOffset26;
    sqInt instrOffset27;
    sqInt instrOffset28;
    sqInt instrOffset29;
    sqInt instrOffset3;
    sqInt instrOffset30;
    sqInt instrOffset4;
    sqInt instrOffset5;
    sqInt instrOffset6;
    sqInt instrOffset7;
    sqInt instrOffset8;
    sqInt instrOffset9;
    sqInt invert;
    sqInt invert1;
    int invert11;
    int invert12;
    sqInt invert2;
    int invert21;
    int invert22;
    sqInt invert3;
    int invert31;
    int invert32;
    sqInt invert4;
    int invert41;
    int invert42;
    int invert5;
    int invert6;
    unsigned int invVal;
    sqInt i9;
    AbstractInstruction *jumpTarget;
    AbstractInstruction *jumpTarget1;
    AbstractInstruction *jumpTarget10;
    AbstractInstruction *jumpTarget11;
    AbstractInstruction *jumpTarget110;
    AbstractInstruction *jumpTarget111;
    AbstractInstruction *jumpTarget112;
    AbstractInstruction *jumpTarget113;
    AbstractInstruction *jumpTarget114;
    AbstractInstruction *jumpTarget115;
    AbstractInstruction *jumpTarget116;
    AbstractInstruction *jumpTarget117;
    AbstractInstruction *jumpTarget118;
    AbstractInstruction *jumpTarget119;
    AbstractInstruction *jumpTarget12;
    AbstractInstruction *jumpTarget120;
    AbstractInstruction *jumpTarget121;
    AbstractInstruction *jumpTarget122;
    AbstractInstruction *jumpTarget123;
    AbstractInstruction *jumpTarget124;
    AbstractInstruction *jumpTarget13;
    AbstractInstruction *jumpTarget14;
    AbstractInstruction *jumpTarget15;
    AbstractInstruction *jumpTarget16;
    AbstractInstruction *jumpTarget17;
    AbstractInstruction *jumpTarget18;
    AbstractInstruction *jumpTarget19;
    AbstractInstruction *jumpTarget2;
    AbstractInstruction *jumpTarget20;
    AbstractInstruction *jumpTarget21;
    AbstractInstruction *jumpTarget22;
    AbstractInstruction *jumpTarget23;
    AbstractInstruction *jumpTarget24;
    AbstractInstruction *jumpTarget25;
    AbstractInstruction *jumpTarget26;
    AbstractInstruction *jumpTarget27;
    AbstractInstruction *jumpTarget28;
    AbstractInstruction *jumpTarget29;
    AbstractInstruction *jumpTarget3;
    AbstractInstruction *jumpTarget30;
    AbstractInstruction *jumpTarget31;
    AbstractInstruction *jumpTarget32;
    AbstractInstruction *jumpTarget33;
    AbstractInstruction *jumpTarget34;
    AbstractInstruction *jumpTarget4;
    AbstractInstruction *jumpTarget5;
    AbstractInstruction *jumpTarget6;
    AbstractInstruction *jumpTarget7;
    AbstractInstruction *jumpTarget8;
    AbstractInstruction *jumpTarget9;
    usqInt maskReg;
    sqInt negate;
    sqInt negate1;
    int negate11;
    int negate12;
    sqInt negate2;
    int negate21;
    int negate22;
    int negate3;
    int negate4;
    int offset;
    sqInt offset1;
    sqInt offset10;
    sqInt offset11;
    sqInt offset12;
    sqInt offset13;
    sqInt offset14;
    sqInt offset15;
    sqInt offset16;
    sqInt offset17;
    sqInt offset18;
    sqInt offset19;
    usqInt offset2;
    sqInt offset20;
    sqInt offset21;
    sqInt offset22;
    sqInt offset23;
    sqInt offset24;
    sqInt offset25;
    sqInt offset26;
    sqInt offset27;
    sqInt offset28;
    sqInt offset29;
    sqInt offset3;
    sqInt offset30;
    sqInt offset31;
    sqInt offset32;
    sqInt offset33;
    sqInt offset4;
    sqInt offset5;
    sqInt offset6;
    sqInt offset7;
    sqInt offset8;
    sqInt offset9;
    sqInt p;
    int rd;
    int rd1;
    int rd10;
    sqInt rd11;
    int rd12;
    sqInt rd13;
    sqInt rd14;
    int rd15;
    sqInt rd16;
    sqInt rd17;
    sqInt rd18;
    sqInt rd19;
    int rd2;
    sqInt rd20;
    sqInt rd21;
    int rd3;
    int rd4;
    int rd5;
    usqInt rd6;
    usqInt rd7;
    sqInt rd8;
    sqInt rd9;
    usqInt reg;
    usqInt reg1;
    usqInt reg2;
    usqInt reg3;
    usqInt reg4;
    usqInt reg5;
    usqInt reg6;
    usqInt reg7;
    usqInt regA;
    usqInt regB;
    usqInt regLHS;
    usqInt regLHS1;
    usqInt regLHS2;
    usqInt regLHS3;
    usqInt regLHS4;
    usqInt regRHS;
    usqInt regRHS1;
    usqInt regRHS2;
    usqInt regRHS3;
    usqInt rn;
    usqInt rn1;
    usqInt rn10;
    usqInt rn11;
    usqInt rn110;
    usqInt rn12;
    usqInt rn13;
    usqInt rn14;
    usqInt rn15;
    usqInt rn16;
    usqInt rn17;
    usqInt rn18;
    usqInt rn19;
    usqInt rn2;
    usqInt rn20;
    usqInt rn21;
    usqInt rn22;
    usqInt rn23;
    usqInt rn24;
    usqInt rn25;
    usqInt rn26;
    usqInt rn27;
    usqInt rn28;
    usqInt rn29;
    usqInt rn3;
    usqInt rn4;
    usqInt rn5;
    usqInt rn6;
    usqInt rn7;
    usqInt rn8;
    usqInt rn9;
    sqInt rot;
    sqInt rot1;
    sqInt rot10;
    sqInt rot101;
    sqInt rot11;
    sqInt rot111;
    sqInt rot12;
    sqInt rot121;
    sqInt rot13;
    sqInt rot131;
    sqInt rot14;
    sqInt rot141;
    sqInt rot15;
    sqInt rot16;
    sqInt rot17;
    sqInt rot2;
    sqInt rot21;
    sqInt rot3;
    sqInt rot31;
    sqInt rot4;
    sqInt rot41;
    sqInt rot5;
    sqInt rot51;
    sqInt rot6;
    sqInt rot61;
    sqInt rot7;
    sqInt rot71;
    sqInt rot8;
    sqInt rot81;
    sqInt rot82;
    sqInt rot9;
    sqInt rot91;
    usqInt src;
    usqInt src1;
    usqInt srcAddr;
    usqInt srcAddr1;
    usqInt srcReg;
    usqInt srcReg1;
    usqInt srcReg10;
    usqInt srcReg11;
    usqInt srcReg12;
    usqInt srcReg13;
    usqInt srcReg14;
    usqInt srcReg15;
    usqInt srcReg16;
    usqInt srcReg17;
    usqInt srcReg18;
    usqInt srcReg19;
    usqInt srcReg2;
    usqInt srcReg20;
    usqInt srcReg21;
    usqInt srcReg22;
    usqInt srcReg23;
    usqInt srcReg24;
    usqInt srcReg3;
    usqInt srcReg4;
    usqInt srcReg5;
    usqInt srcReg6;
    usqInt srcReg7;
    usqInt srcReg8;
    usqInt srcReg9;
    sqInt u;
    sqInt u1;
    sqInt u2;
    sqInt u3;
    int u4;
    sqInt u5;
    sqInt u6;
    int u7;
    sqInt val;
    sqInt val1;
    sqInt val11;
    sqInt val12;
    usqInt val2;
    sqInt val3;
    sqInt val4;
    sqInt val5;
    sqInt val6;
    unsigned int value;
    unsigned int value1;
    sqInt value2;
    sqInt value3;
    unsigned int value4;
    sqInt value5;
    unsigned int value6;
    unsigned int value7;
    sqInt word;
    usqInt word1;
    usqInt word2;
    sqInt word3;

	if (!(((self_in_CogARMCompiler->conditionOrNil)) == null)) {
		return concretizeConditionalInstruction(self_in_CogARMCompiler);
	}
	switch ((self_in_CogARMCompiler->opcode)) {
	case Label:
		/* begin concretizeLabel */
		dependentChain = (self_in_CogARMCompiler->dependent);
		while (!(!dependentChain)) {
			/* begin updateLabel: */
			if (((dependentChain->opcode)) != Literal) {
				assert((((dependentChain->opcode)) == MoveCwR)
				 || (((dependentChain->opcode)) == PushCw));
				((dependentChain->operands))[0] = (((self_in_CogARMCompiler->address)) + (((self_in_CogARMCompiler->operands))[1]));
			}
			dependentChain = (dependentChain->dependent);
		}
		return 0;

	case Literal:
		return concretizeLiteral(self_in_CogARMCompiler);

	case AlignmentNops:
		/* begin concretizeAlignmentNops */
		assert((((self_in_CogARMCompiler->machineCodeSize)) % 4) == 0);
		for (p = 0; p < ((self_in_CogARMCompiler->machineCodeSize)); p += 4) {
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[p / 4] = 0xE1A00000U;
		}
		return (self_in_CogARMCompiler->machineCodeSize);

	case Fill32:
		return concretizeFill32(self_in_CogARMCompiler);

	case Nop:
		/* begin concretizeNop */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 0xE1A00000U;
		return 4;

	case Call:
		/* begin concretizeCall */
		assert((((self_in_CogARMCompiler->operands))[0]) != 0);
		assert(((((self_in_CogARMCompiler->operands))[0]) % 4) == 0);
		/* normal pc offset */
		offset = (((int) (((self_in_CogARMCompiler->operands))[0]))) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset));
		aWord = bl(self_in_CogARMCompiler, offset);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord;
		return 4;

	case CallFull:
		/* begin concretizeCallFull */
		jumpTarget1 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget1))
		 || (jumpTarget1 == (methodLabel()))) {
			jumpTarget1 = ((AbstractInstruction *) ((jumpTarget1->address)));
		}
		assert(jumpTarget1 != 0);
		jumpTarget = jumpTarget1;
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord43 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord43;
		instrOffset13 = 4;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset13 / 4] = ((((int)((usqInt)(AL) << 28))) | ((0x12FFF10 | (((int)((usqInt)((1 & 1)) << 5)))) | ConcreteIPReg));
		assert(instrOffset13 == (literalLoadInstructionBytes(self_in_CogARMCompiler)));
		return instrOffset13 + 4;

	case JumpR:
		/* begin concretizeJumpR */
		/* bx reg */
		reg = ((self_in_CogARMCompiler->operands))[0];
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(AL) << 28))) | ((0x12FFF10 | (((int)((usqInt)((0)) << 5)))) | reg));
		return 4;

	case JumpFull:
		/* begin concretizeJumpFull */
		jumpTarget11 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget11))
		 || (jumpTarget11 == (methodLabel()))) {
			jumpTarget11 = ((AbstractInstruction *) ((jumpTarget11->address)));
		}
		assert(jumpTarget11 != 0);
		jumpTarget2 = jumpTarget11;
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord44 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord44;
		instrOffset14 = 4;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset14 / 4] = ((((int)((usqInt)(AL) << 28))) | ((0x12FFF10 | (((int)((usqInt)((0)) << 5)))) | ConcreteIPReg));
		return instrOffset14 + 4;

	case JumpLong:
	case Jump:
		/* begin concretizeConditionalJump: */
		jumpTarget12 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget12);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget12))
		 || (jumpTarget12 == (methodLabel()))) {
			jumpTarget12 = ((AbstractInstruction *) ((jumpTarget12->address)));
		}
		assert(jumpTarget12 != 0);
		jumpTarget3 = jumpTarget12;
		offset11 = (((int) jumpTarget3)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset11));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(AL) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset11)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpLongZero:
	case JumpZero:
		/* begin concretizeConditionalJump: */
		jumpTarget13 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget13);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget13))
		 || (jumpTarget13 == (methodLabel()))) {
			jumpTarget13 = ((AbstractInstruction *) ((jumpTarget13->address)));
		}
		assert(jumpTarget13 != 0);
		jumpTarget4 = jumpTarget13;
		offset12 = (((int) jumpTarget4)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset12));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(EQ) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset12)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpLongNonZero:
	case JumpNonZero:
		/* begin concretizeConditionalJump: */
		jumpTarget14 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget14);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget14))
		 || (jumpTarget14 == (methodLabel()))) {
			jumpTarget14 = ((AbstractInstruction *) ((jumpTarget14->address)));
		}
		assert(jumpTarget14 != 0);
		jumpTarget5 = jumpTarget14;
		offset13 = (((int) jumpTarget5)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset13));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(NE) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset13)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpNegative:
		/* begin concretizeConditionalJump: */
		jumpTarget15 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget15);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget15))
		 || (jumpTarget15 == (methodLabel()))) {
			jumpTarget15 = ((AbstractInstruction *) ((jumpTarget15->address)));
		}
		assert(jumpTarget15 != 0);
		jumpTarget6 = jumpTarget15;
		offset14 = (((int) jumpTarget6)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset14));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(MI) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset14)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpNonNegative:
		/* begin concretizeConditionalJump: */
		jumpTarget16 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget16);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget16))
		 || (jumpTarget16 == (methodLabel()))) {
			jumpTarget16 = ((AbstractInstruction *) ((jumpTarget16->address)));
		}
		assert(jumpTarget16 != 0);
		jumpTarget7 = jumpTarget16;
		offset15 = (((int) jumpTarget7)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset15));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(PL) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset15)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpOverflow:
		/* begin concretizeConditionalJump: */
		jumpTarget17 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget17);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget17))
		 || (jumpTarget17 == (methodLabel()))) {
			jumpTarget17 = ((AbstractInstruction *) ((jumpTarget17->address)));
		}
		assert(jumpTarget17 != 0);
		jumpTarget8 = jumpTarget17;
		offset16 = (((int) jumpTarget8)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset16));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(VS) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset16)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpNoOverflow:
		/* begin concretizeConditionalJump: */
		jumpTarget18 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget18);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget18))
		 || (jumpTarget18 == (methodLabel()))) {
			jumpTarget18 = ((AbstractInstruction *) ((jumpTarget18->address)));
		}
		assert(jumpTarget18 != 0);
		jumpTarget9 = jumpTarget18;
		offset17 = (((int) jumpTarget9)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset17));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(VC) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset17)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpCarry:
	case JumpAboveOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget19 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget19);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget19))
		 || (jumpTarget19 == (methodLabel()))) {
			jumpTarget19 = ((AbstractInstruction *) ((jumpTarget19->address)));
		}
		assert(jumpTarget19 != 0);
		jumpTarget10 = jumpTarget19;
		offset18 = (((int) jumpTarget10)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset18));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(CS) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset18)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpNoCarry:
	case JumpBelow:
		/* begin concretizeConditionalJump: */
		jumpTarget110 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget110);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget110))
		 || (jumpTarget110 == (methodLabel()))) {
			jumpTarget110 = ((AbstractInstruction *) ((jumpTarget110->address)));
		}
		assert(jumpTarget110 != 0);
		jumpTarget20 = jumpTarget110;
		offset19 = (((int) jumpTarget20)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset19));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(CC) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset19)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpLess:
		/* begin concretizeConditionalJump: */
		jumpTarget111 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget111);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget111))
		 || (jumpTarget111 == (methodLabel()))) {
			jumpTarget111 = ((AbstractInstruction *) ((jumpTarget111->address)));
		}
		assert(jumpTarget111 != 0);
		jumpTarget21 = jumpTarget111;
		offset20 = (((int) jumpTarget21)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset20));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(LT) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset20)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpGreaterOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget112 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget112);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget112))
		 || (jumpTarget112 == (methodLabel()))) {
			jumpTarget112 = ((AbstractInstruction *) ((jumpTarget112->address)));
		}
		assert(jumpTarget112 != 0);
		jumpTarget22 = jumpTarget112;
		offset21 = (((int) jumpTarget22)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset21));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(GE) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset21)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpGreater:
		/* begin concretizeConditionalJump: */
		jumpTarget113 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget113);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget113))
		 || (jumpTarget113 == (methodLabel()))) {
			jumpTarget113 = ((AbstractInstruction *) ((jumpTarget113->address)));
		}
		assert(jumpTarget113 != 0);
		jumpTarget23 = jumpTarget113;
		offset22 = (((int) jumpTarget23)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset22));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(GT) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset22)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpLessOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget114 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget114);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget114))
		 || (jumpTarget114 == (methodLabel()))) {
			jumpTarget114 = ((AbstractInstruction *) ((jumpTarget114->address)));
		}
		assert(jumpTarget114 != 0);
		jumpTarget24 = jumpTarget114;
		offset23 = (((int) jumpTarget24)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset23));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(LE) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset23)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpAbove:
		/* begin concretizeConditionalJump: */
		jumpTarget115 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget115);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget115))
		 || (jumpTarget115 == (methodLabel()))) {
			jumpTarget115 = ((AbstractInstruction *) ((jumpTarget115->address)));
		}
		assert(jumpTarget115 != 0);
		jumpTarget25 = jumpTarget115;
		offset24 = (((int) jumpTarget25)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset24));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(HI) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset24)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpBelowOrEqual:
		/* begin concretizeConditionalJump: */
		jumpTarget116 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget116);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget116))
		 || (jumpTarget116 == (methodLabel()))) {
			jumpTarget116 = ((AbstractInstruction *) ((jumpTarget116->address)));
		}
		assert(jumpTarget116 != 0);
		jumpTarget26 = jumpTarget116;
		offset25 = (((int) jumpTarget26)) - (((int) (((self_in_CogARMCompiler->address)) + 8)));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset25));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(LS) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset25)) >> 2) & 0xFFFFFF)));
		return 4;

	case JumpFPEqual:
		/* begin concretizeFPConditionalJump: */
		jumpTarget117 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget117);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget117))
		 || (jumpTarget117 == (methodLabel()))) {
			jumpTarget117 = ((AbstractInstruction *) ((jumpTarget117->address)));
		}
		assert(jumpTarget117 != 0);
		jumpTarget27 = jumpTarget117;
		offset26 = (((int) jumpTarget27)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset26));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(EQ) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset26)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPNotEqual:
		/* begin concretizeFPConditionalJump: */
		jumpTarget118 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget118);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget118))
		 || (jumpTarget118 == (methodLabel()))) {
			jumpTarget118 = ((AbstractInstruction *) ((jumpTarget118->address)));
		}
		assert(jumpTarget118 != 0);
		jumpTarget28 = jumpTarget118;
		offset27 = (((int) jumpTarget28)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset27));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(NE) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset27)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPLess:
		/* begin concretizeFPConditionalJump: */
		jumpTarget119 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget119);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget119))
		 || (jumpTarget119 == (methodLabel()))) {
			jumpTarget119 = ((AbstractInstruction *) ((jumpTarget119->address)));
		}
		assert(jumpTarget119 != 0);
		jumpTarget29 = jumpTarget119;
		offset28 = (((int) jumpTarget29)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset28));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(LT) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset28)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPGreaterOrEqual:
		/* begin concretizeFPConditionalJump: */
		jumpTarget120 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget120);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget120))
		 || (jumpTarget120 == (methodLabel()))) {
			jumpTarget120 = ((AbstractInstruction *) ((jumpTarget120->address)));
		}
		assert(jumpTarget120 != 0);
		jumpTarget30 = jumpTarget120;
		offset29 = (((int) jumpTarget30)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset29));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(GE) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset29)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPGreater:
		/* begin concretizeFPConditionalJump: */
		jumpTarget121 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget121);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget121))
		 || (jumpTarget121 == (methodLabel()))) {
			jumpTarget121 = ((AbstractInstruction *) ((jumpTarget121->address)));
		}
		assert(jumpTarget121 != 0);
		jumpTarget31 = jumpTarget121;
		offset30 = (((int) jumpTarget31)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset30));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(GT) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset30)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPLessOrEqual:
		/* begin concretizeFPConditionalJump: */
		jumpTarget122 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget122);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget122))
		 || (jumpTarget122 == (methodLabel()))) {
			jumpTarget122 = ((AbstractInstruction *) ((jumpTarget122->address)));
		}
		assert(jumpTarget122 != 0);
		jumpTarget32 = jumpTarget122;
		offset31 = (((int) jumpTarget32)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset31));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(LE) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset31)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPOrdered:
		/* begin concretizeFPConditionalJump: */
		jumpTarget123 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget123);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget123))
		 || (jumpTarget123 == (methodLabel()))) {
			jumpTarget123 = ((AbstractInstruction *) ((jumpTarget123->address)));
		}
		assert(jumpTarget123 != 0);
		jumpTarget33 = jumpTarget123;
		offset32 = (((int) jumpTarget33)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset32));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(VC) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset32)) >> 2) & 0xFFFFFF)));
		return 8;

	case JumpFPUnordered:
		/* begin concretizeFPConditionalJump: */
		jumpTarget124 = ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]));
		assertSaneJumpTarget(jumpTarget124);
		if (		/* begin isAnInstruction: */
			(addressIsInInstructions(jumpTarget124))
		 || (jumpTarget124 == (methodLabel()))) {
			jumpTarget124 = ((AbstractInstruction *) ((jumpTarget124->address)));
		}
		assert(jumpTarget124 != 0);
		jumpTarget34 = jumpTarget124;
		offset33 = (((int) jumpTarget34)) - (((int) (((self_in_CogARMCompiler->address)) + (12))));
		assert(isInImmediateJumpRange(self_in_CogARMCompiler, offset33));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = 4008835600U /* begin fmstat */;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = ((((int)((usqInt)(VS) << 28))) | ((((int)((usqInt)((10 | (0))) << 24))) | ((((usqInt)(offset33)) >> 2) & 0xFFFFFF)));
		return 8;

	case RetN:
		/* begin concretizeRetN */
		offset1 = ((self_in_CogARMCompiler->operands))[0];
		if (offset1 == 0) {
			aWord3 = movrn(self_in_CogARMCompiler, PC, LR);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord3;
			return 4;
		}
		assert(offset1 < 0xFF);
		aWord1 = addrnimmror(self_in_CogARMCompiler, SP, SP, offset1, 0);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord1;
		aWord2 = movrn(self_in_CogARMCompiler, PC, LR);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord2;
		return 8;

	case Stop:
		/* begin concretizeStop */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((int)((usqInt)(AL) << 28))) | ((0x1200000) | (112)));
		return 4;

	case AddCqR:
		rd8 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeNegateableDataOperationCqR:R: */
		immediate11 = 0;
		negate = 0;
		rot4 = 0;
		val = ((self_in_CogARMCompiler->operands))[0];
		/* Extra note - if ever a version of this code wants to NOT set the Set flag
		   - Cmp must always have it set or it will pretend to be a SMALALBT and Very Bad Things might happen. */
		rn8 = ((self_in_CogARMCompiler->operands))[1];
		/* begin rotateable8bitSignedImmediate:ifTrue:ifFalse: */
		value2 = val;
		while (1) {
			if ((value2 & 0xFF) == value2) {
				negate3 = val != value2;
				flagsOrOpcode = (negate3
					? inverseOpcodeFor(self_in_CogARMCompiler, AddOpcode)
					: AddOpcode);
				/* begin type:op:set:rn:rd:shifterOperand: */
				aWord63 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode) << 21))) | (0x100000)))) | ((rn8 << 16) | (((sqInt)((usqInt)(rd8) << 12))))) | (((0) | value2) & 0xFFF);
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord63;
				return 4;
				goto l193;
			}
			for (i5 = 2; i5 <= 30; i5 += 2) {
				if ((value2 & (((0xFFU << i5) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i5)))) == value2) {
					rot41 = 32 - i5;
					immediate111 = (((usqInt)(value2)) >> i5) | ((((sqInt)((usqInt)(value2) << (32 - i5)))) & 0xFFFFFFFFU);
					negate4 = val != value2;
					flagsOrOpcode1 = (negate4
						? inverseOpcodeFor(self_in_CogARMCompiler, AddOpcode)
						: AddOpcode);
					/* begin type:op:set:rn:rd:shifterOperand: */
					aWord63 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode1) << 21))) | (0x100000)))) | ((rn8 << 16) | (((sqInt)((usqInt)(rd8) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot41)) >> 1)) << 8))) | immediate111) & 0xFFF);
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord63;
					return 4;
					goto l193;
				}
			}
			if (!((value2 == val)
			 && (val != 0))) break;
			value2 = -val;
		}
		if (val > 0) {
			hb = highBit(val);
			if ((1U << hb) == (val + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord118 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord118;
				aWord214 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, AddOpcode, rd8, rn8, ConcreteIPReg, 32 - hb);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord214;
				return 8;
			}
		}
		/* begin concretizeDataOperationCwR:R: */
		constant = ((self_in_CogARMCompiler->operands))[0];
		rn11 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord310 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord310;
		instrOffset16 = 4;
		aWord119 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AddOpcode) << 21))) | (0x100000)))) | ((rn11 << 16) | (((sqInt)((usqInt)(rd8) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset16 / 4] = aWord119;
		return instrOffset16 + 4;
	l193:	/* end rotateable8bitSignedImmediate:ifTrue:ifFalse: */;
		return 0;

	case AddCqRR:
		rd9 = ((self_in_CogARMCompiler->operands))[2];
		/* begin concretizeNegateableDataOperationCqR:R: */
		immediate12 = 0;
		negate1 = 0;
		rot5 = 0;
		val1 = ((self_in_CogARMCompiler->operands))[0];
		/* Extra note - if ever a version of this code wants to NOT set the Set flag
		   - Cmp must always have it set or it will pretend to be a SMALALBT and Very Bad Things might happen. */
		rn9 = ((self_in_CogARMCompiler->operands))[1];
		/* begin rotateable8bitSignedImmediate:ifTrue:ifFalse: */
		value3 = val1;
		while (1) {
			if ((value3 & 0xFF) == value3) {
				negate11 = val1 != value3;
				flagsOrOpcode2 = (negate11
					? inverseOpcodeFor(self_in_CogARMCompiler, AddOpcode)
					: AddOpcode);
				/* begin type:op:set:rn:rd:shifterOperand: */
				aWord64 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode2) << 21))) | (0x100000)))) | ((rn9 << 16) | (((sqInt)((usqInt)(rd9) << 12))))) | (((0) | value3) & 0xFFF);
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord64;
				return 4;
				goto l202;
			}
			for (i6 = 2; i6 <= 30; i6 += 2) {
				if ((value3 & (((0xFFU << i6) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i6)))) == value3) {
					rot51 = 32 - i6;
					immediate121 = (((usqInt)(value3)) >> i6) | ((((sqInt)((usqInt)(value3) << (32 - i6)))) & 0xFFFFFFFFU);
					negate12 = val1 != value3;
					flagsOrOpcode11 = (negate12
						? inverseOpcodeFor(self_in_CogARMCompiler, AddOpcode)
						: AddOpcode);
					/* begin type:op:set:rn:rd:shifterOperand: */
					aWord64 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode11) << 21))) | (0x100000)))) | ((rn9 << 16) | (((sqInt)((usqInt)(rd9) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot51)) >> 1)) << 8))) | immediate121) & 0xFFF);
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord64;
					return 4;
					goto l202;
				}
			}
			if (!((value3 == val1)
			 && (val1 != 0))) break;
			value3 = -val1;
		}
		if (val1 > 0) {
			hb1 = highBit(val1);
			if ((1U << hb1) == (val1 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord120 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord120;
				aWord215 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, AddOpcode, rd9, rn9, ConcreteIPReg, 32 - hb1);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord215;
				return 8;
			}
		}
		/* begin concretizeDataOperationCwR:R: */
		constant1 = ((self_in_CogARMCompiler->operands))[0];
		rn12 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord311 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord311;
		instrOffset17 = 4;
		aWord1110 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AddOpcode) << 21))) | (0x100000)))) | ((rn12 << 16) | (((sqInt)((usqInt)(rd9) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset17 / 4] = aWord1110;
		return instrOffset17 + 4;
	l202:	/* end rotateable8bitSignedImmediate:ifTrue:ifFalse: */;
		return 0;

	case AndCqR:
		/* begin concretizeInvertibleDataOperationCqR: */
		immediate17 = 0;
		invert3 = 0;
		rot10 = 0;
		val4 = ((self_in_CogARMCompiler->operands))[0];
		rn18 = ((self_in_CogARMCompiler->operands))[1];
		assert(!((((self_in_CogARMCompiler->opcode)) == CmpOpcode)));
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value6 = val4;
		while (1) {
			if ((value6 & 0xFF) == value6) {
				invert31 = val4 != value6;
				flagsOrOpcode4 = (invert31
					? inverseOpcodeFor(self_in_CogARMCompiler, AndOpcode)
					: AndOpcode);
				/* begin type:op:set:rn:rd:shifterOperand: */
				aWord69 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode4) << 21))) | (0x100000)))) | ((rn18 << 16) | (rn18 << 12))) | (((0) | value6) & 0xFFF);
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord69;
				return 4;
				goto l233;
			}
			for (i12 = 2; i12 <= 30; i12 += 2) {
				if ((value6 & (((0xFFU << i12) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i12)))) == value6) {
					rot101 = 32 - i12;
					immediate171 = ((value6) >> i12) | ((value6 << (32 - i12)) & 0xFFFFFFFFU);
					invert32 = val4 != value6;
					flagsOrOpcode13 = (invert32
						? inverseOpcodeFor(self_in_CogARMCompiler, AndOpcode)
						: AndOpcode);
					/* begin type:op:set:rn:rd:shifterOperand: */
					aWord69 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode13) << 21))) | (0x100000)))) | ((rn18 << 16) | (rn18 << 12))) | (((((sqInt)((usqInt)((((usqInt)(rot101)) >> 1)) << 8))) | immediate171) & 0xFFF);
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord69;
					return 4;
					goto l233;
				}
			}
			if (!(value6 == val4)) break;
			value6 = (val4 < 0
				? -1 - val4
				: (unsigned int)~val4);
		}
	l233:	/* end rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */;
		if (val4 > 0) {
			hb4 = highBit(val4);
			if ((1U << hb4) == (val4 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord126 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord126;
				aWord220 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, AndOpcode, rn18, rn18, ConcreteIPReg, 32 - hb4);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord220;
				return 8;
			}
		}
		/* begin concretizeDataOperationCqR: */
		immediate18 = 0;
		rot11 = 0;
		val11 = ((self_in_CogARMCompiler->operands))[0];
		rn21 = ((self_in_CogARMCompiler->operands))[1];
		/* Extra note - if ever a version of this code wants to NOT set the Set flag - Cmp must always have it set or it will pretend to be a SMALALBT and Very Bad Things might happen */
		rd10 = (((self_in_CogARMCompiler->opcode)) == CmpOpcode
			? 0
			: rn21);
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((val11 & 0xFF) == val11) {
			aWord410 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((rn21 << 16) | (((int)((usqInt)(rd10) << 12))))) | (((0) | val11) & 0xFFF);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord410;
			return 4;
			goto l240;
		}
		for (i13 = 2; i13 <= 30; i13 += 2) {
			if ((val11 & (((0xFFU << i13) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i13)))) == val11) {
				rot111 = 32 - i13;
				immediate181 = (((usqInt)(val11)) >> i13) | ((((sqInt)((usqInt)(val11) << (32 - i13)))) & 0xFFFFFFFFU);
				aWord410 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((rn21 << 16) | (((int)((usqInt)(rd10) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot111)) >> 1)) << 8))) | immediate181) & 0xFFF);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord410;
				return 4;
				goto l240;
			}
		}
	l240:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		if (val11 > 0) {
			hb11 = highBit(val11);
			if ((1U << hb11) == (val11 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord125 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord125;
				aWord2110 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, AndOpcode, rd10, rn21, ConcreteIPReg, 32 - hb11);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord2110;
				return 8;
			}
		}
		/* begin concretizeDataOperationCwR: */
		rd11 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant6 = ((self_in_CogARMCompiler->operands))[0];
		rn17 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord314 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord314;
		instrOffset22 = 4;
		aWord1114 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((rn17 << 16) | (((sqInt)((usqInt)(rd11) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset22 / 4] = aWord1114;
		return instrOffset22 + 4;

	case AndCqRR:
		/* begin concretizeAndCqRR */
		immediate13 = 0;
		invert2 = 0;
		rot6 = 0;
		val2 = ((self_in_CogARMCompiler->operands))[0];
		srcReg24 = ((self_in_CogARMCompiler->operands))[1];
		dstReg1 = ((self_in_CogARMCompiler->operands))[2];
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value4 = val2;
		while (1) {
			if ((value4 & 0xFF) == value4) {
				invert21 = val2 != value4;
				aWord65 = (invert21
					? bicsrnimmror(self_in_CogARMCompiler, dstReg1, srcReg24, value4, 0)
					: andsrnimmror(self_in_CogARMCompiler, dstReg1, srcReg24, value4, 0));
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord65;
				return 4;
				goto l208;
			}
			for (i7 = 2; i7 <= 30; i7 += 2) {
				if ((value4 & (((0xFFU << i7) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i7)))) == value4) {
					rot61 = 32 - i7;
					immediate131 = ((value4) >> i7) | ((value4 << (32 - i7)) & 0xFFFFFFFFU);
					invert22 = val2 != value4;
					aWord65 = (invert22
						? bicsrnimmror(self_in_CogARMCompiler, dstReg1, srcReg24, immediate131, rot61)
						: andsrnimmror(self_in_CogARMCompiler, dstReg1, srcReg24, immediate131, rot61));
					/* begin machineCodeAt:put: */
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord65;
					return 4;
					goto l208;
				}
			}
			if (!(value4 == val2)) break;
			value4 = (val2 < 0
				? -1 - val2
				: (unsigned int)~val2);
		}
		/* First see if the constant can be made from a simple shift of 0xFFFFFFFF */
		hb2 = highBit(((self_in_CogARMCompiler->operands))[0]);
		if ((1U << hb2) == (val2 + 1)) {
			/* MVN temp reg, 0, making 0xffffffff */
			aWord121 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord121;
			aWord216 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, AndOpcode, dstReg1, srcReg24, ConcreteIPReg, 32 - hb2);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord216;
			return 8;
		}
	l208:	/* end rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */;
		/* begin concretizeDataOperationCwR:R: */
		constant2 = ((self_in_CogARMCompiler->operands))[0];
		rn10 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord312 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord312;
		instrOffset18 = 4;
		aWord1111 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((rn10 << 16) | (dstReg1 << 12))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset18 / 4] = aWord1111;
		return instrOffset18 + 4;

	case CmpCqR:
		/* begin concretizeNegateableDataOperationCqR:R: */
		immediate14 = 0;
		negate2 = 0;
		rot7 = 0;
		val3 = ((self_in_CogARMCompiler->operands))[0];
		/* Extra note - if ever a version of this code wants to NOT set the Set flag
		   - Cmp must always have it set or it will pretend to be a SMALALBT and Very Bad Things might happen. */
		rn14 = ((self_in_CogARMCompiler->operands))[1];
		/* begin rotateable8bitSignedImmediate:ifTrue:ifFalse: */
		value5 = val3;
		while (1) {
			if ((value5 & 0xFF) == value5) {
				negate21 = val3 != value5;
				flagsOrOpcode3 = (negate21
					? inverseOpcodeFor(self_in_CogARMCompiler, CmpOpcode)
					: CmpOpcode);
				/* begin type:op:set:rn:rd:shifterOperand: */
				aWord66 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode3) << 21))) | (0x100000)))) | ((rn14 << 16) | (0))) | (((0) | value5) & 0xFFF);
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord66;
				return 4;
				goto l218;
			}
			for (i8 = 2; i8 <= 30; i8 += 2) {
				if ((value5 & (((0xFFU << i8) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i8)))) == value5) {
					rot71 = 32 - i8;
					immediate141 = (((usqInt)(value5)) >> i8) | ((((sqInt)((usqInt)(value5) << (32 - i8)))) & 0xFFFFFFFFU);
					negate22 = val3 != value5;
					flagsOrOpcode12 = (negate22
						? inverseOpcodeFor(self_in_CogARMCompiler, CmpOpcode)
						: CmpOpcode);
					/* begin type:op:set:rn:rd:shifterOperand: */
					aWord66 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode12) << 21))) | (0x100000)))) | ((rn14 << 16) | (0))) | (((((sqInt)((usqInt)((((usqInt)(rot71)) >> 1)) << 8))) | immediate141) & 0xFFF);
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord66;
					return 4;
					goto l218;
				}
			}
			if (!((value5 == val3)
			 && (val3 != 0))) break;
			value5 = -val3;
		}
		if (val3 > 0) {
			hb3 = highBit(val3);
			if ((1U << hb3) == (val3 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord122 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord122;
				aWord217 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, CmpOpcode, 0, rn14, ConcreteIPReg, 32 - hb3);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord217;
				return 8;
			}
		}
		/* begin concretizeDataOperationCwR:R: */
		constant3 = ((self_in_CogARMCompiler->operands))[0];
		rn13 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord313 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord313;
		instrOffset19 = 4;
		aWord1112 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(CmpOpcode) << 21))) | (0x100000)))) | ((rn13 << 16) | (0))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset19 / 4] = aWord1112;
		return instrOffset19 + 4;
	l218:	/* end rotateable8bitSignedImmediate:ifTrue:ifFalse: */;
		return 0;

	case OrCqR:
		/* begin concretizeDataOperationCqR: */
		immediate19 = 0;
		rot12 = 0;
		val5 = ((self_in_CogARMCompiler->operands))[0];
		rn20 = ((self_in_CogARMCompiler->operands))[1];
		/* Extra note - if ever a version of this code wants to NOT set the Set flag - Cmp must always have it set or it will pretend to be a SMALALBT and Very Bad Things might happen */
		rd12 = (((self_in_CogARMCompiler->opcode)) == CmpOpcode
			? 0
			: rn20);
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((val5 & 0xFF) == val5) {
			aWord70 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(OrOpcode) << 21))) | (0x100000)))) | ((rn20 << 16) | (((int)((usqInt)(rd12) << 12))))) | (((0) | val5) & 0xFFF);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord70;
			return 4;
			goto l250;
		}
		for (i14 = 2; i14 <= 30; i14 += 2) {
			if ((val5 & (((0xFFU << i14) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i14)))) == val5) {
				rot121 = 32 - i14;
				immediate191 = (((usqInt)(val5)) >> i14) | ((((sqInt)((usqInt)(val5) << (32 - i14)))) & 0xFFFFFFFFU);
				aWord70 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(OrOpcode) << 21))) | (0x100000)))) | ((rn20 << 16) | (((int)((usqInt)(rd12) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot121)) >> 1)) << 8))) | immediate191) & 0xFFF);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord70;
				return 4;
				goto l250;
			}
		}
	l250:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		if (val5 > 0) {
			hb5 = highBit(val5);
			if ((1U << hb5) == (val5 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord127 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord127;
				aWord221 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, OrOpcode, rd12, rn20, ConcreteIPReg, 32 - hb5);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord221;
				return 8;
			}
		}
		/* begin concretizeDataOperationCwR: */
		rd13 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant7 = ((self_in_CogARMCompiler->operands))[0];
		rn19 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord315 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord315;
		instrOffset23 = 4;
		aWord1115 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(OrOpcode) << 21))) | (0x100000)))) | ((rn19 << 16) | (((sqInt)((usqInt)(rd13) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset23 / 4] = aWord1115;
		return instrOffset23 + 4;

	case SubCqR:
		/* begin concretizeSubCqR */
		immediate15 = 0;
		rot8 = 0;
		word3 = ((self_in_CogARMCompiler->operands))[0];
		reg6 = ((self_in_CogARMCompiler->operands))[1];
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((word3 & 0xFF) == word3) {
			aWord67 = subsrnimmror(self_in_CogARMCompiler, reg6, reg6, word3, 0);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord67;
			return 4;
			goto l225;
		}
		for (i9 = 2; i9 <= 30; i9 += 2) {
			if ((word3 & (((0xFFU << i9) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i9)))) == word3) {
				rot81 = 32 - i9;
				immediate151 = (((usqInt)(word3)) >> i9) | ((((sqInt)((usqInt)(word3) << (32 - i9)))) & 0xFFFFFFFFU);
				aWord67 = subsrnimmror(self_in_CogARMCompiler, reg6, reg6, immediate151, rot81);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord67;
				return 4;
				goto l225;
			}
		}
	l225:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if (((-word3) & 0xFF) == (-word3)) {
			immediate152 = -word3;
			aWord123 = addsrnimmror(self_in_CogARMCompiler, reg6, reg6, immediate152, 0);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord123;
			return 4;
			goto l224;
		}
		for (i11 = 2; i11 <= 30; i11 += 2) {
			if (((-word3) & (((0xFFU << i11) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i11)))) == (-word3)) {
				rot82 = 32 - i11;
				immediate153 = (((usqInt)((-word3))) >> i11) | ((((sqInt)((usqInt)((-word3)) << (32 - i11)))) & 0xFFFFFFFFU);
				aWord123 = addsrnimmror(self_in_CogARMCompiler, reg6, reg6, immediate153, rot82);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord123;
				return 4;
				goto l224;
			}
		}
	l224:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		/* begin concretizeDataOperationCwR:R: */
		constant4 = ((self_in_CogARMCompiler->operands))[0];
		rn15 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord218 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord218;
		instrOffset20 = 4;
		aWord1113 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(SubOpcode) << 21))) | (0x100000)))) | ((rn15 << 16) | (reg6 << 12))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset20 / 4] = aWord1113;
		return instrOffset20 + 4;

	case TstCqR:
		/* begin concretizeTstCqR */
		immediate16 = 0;
		rot9 = 0;
		reg7 = ((self_in_CogARMCompiler->operands))[1];
		constant5 = ((self_in_CogARMCompiler->operands))[0];
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((constant5 & 0xFF) == constant5) {
			aWord68 = tstrnimmror(self_in_CogARMCompiler, reg7, reg7, constant5, 0);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord68;
			return 4;
			goto l230;
		}
		for (i10 = 2; i10 <= 30; i10 += 2) {
			if ((constant5 & (((0xFFU << i10) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i10)))) == constant5) {
				rot91 = 32 - i10;
				immediate161 = (((usqInt)(constant5)) >> i10) | ((((sqInt)((usqInt)(constant5) << (32 - i10)))) & 0xFFFFFFFFU);
				aWord68 = tstrnimmror(self_in_CogARMCompiler, reg7, reg7, immediate161, rot91);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord68;
				return 4;
				goto l230;
			}
		}
	l230:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		/* begin concretizeDataOperationCwR:R: */
		constant11 = ((self_in_CogARMCompiler->operands))[0];
		rn16 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord219 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord219;
		instrOffset21 = 4;
		aWord124 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(TstOpcode) << 21))) | (0x100000)))) | ((rn16 << 16) | (reg7 << 12))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset21 / 4] = aWord124;
		return instrOffset21 + 4;

	case XorCqR:
		/* begin concretizeInvertibleDataOperationCqR: */
		immediate20 = 0;
		invert4 = 0;
		rot14 = 0;
		val6 = ((self_in_CogARMCompiler->operands))[0];
		rn22 = ((self_in_CogARMCompiler->operands))[1];
		assert(!((((self_in_CogARMCompiler->opcode)) == CmpOpcode)));
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value7 = val6;
		while (1) {
			if ((value7 & 0xFF) == value7) {
				invert41 = val6 != value7;
				flagsOrOpcode5 = (invert41
					? inverseOpcodeFor(self_in_CogARMCompiler, XorOpcode)
					: XorOpcode);
				/* begin type:op:set:rn:rd:shifterOperand: */
				aWord71 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode5) << 21))) | (0x100000)))) | ((rn22 << 16) | (rn22 << 12))) | (((0) | value7) & 0xFFF);
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord71;
				return 4;
				goto l253;
			}
			for (i15 = 2; i15 <= 30; i15 += 2) {
				if ((value7 & (((0xFFU << i15) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i15)))) == value7) {
					rot141 = 32 - i15;
					immediate201 = ((value7) >> i15) | ((value7 << (32 - i15)) & 0xFFFFFFFFU);
					invert42 = val6 != value7;
					flagsOrOpcode14 = (invert42
						? inverseOpcodeFor(self_in_CogARMCompiler, XorOpcode)
						: XorOpcode);
					/* begin type:op:set:rn:rd:shifterOperand: */
					aWord71 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((sqInt)((usqInt)(flagsOrOpcode14) << 21))) | (0x100000)))) | ((rn22 << 16) | (rn22 << 12))) | (((((sqInt)((usqInt)((((usqInt)(rot141)) >> 1)) << 8))) | immediate201) & 0xFFF);
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord71;
					return 4;
					goto l253;
				}
			}
			if (!(value7 == val6)) break;
			value7 = (val6 < 0
				? -1 - val6
				: (unsigned int)~val6);
		}
	l253:	/* end rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */;
		if (val6 > 0) {
			hb6 = highBit(val6);
			if ((1U << hb6) == (val6 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord129 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord129;
				aWord222 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, XorOpcode, rn22, rn22, ConcreteIPReg, 32 - hb6);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord222;
				return 8;
			}
		}
		/* begin concretizeDataOperationCqR: */
		immediate110 = 0;
		rot13 = 0;
		val12 = ((self_in_CogARMCompiler->operands))[0];
		rn23 = ((self_in_CogARMCompiler->operands))[1];
		/* Extra note - if ever a version of this code wants to NOT set the Set flag - Cmp must always have it set or it will pretend to be a SMALALBT and Very Bad Things might happen */
		rd15 = (((self_in_CogARMCompiler->opcode)) == CmpOpcode
			? 0
			: rn23);
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((val12 & 0xFF) == val12) {
			aWord411 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(XorOpcode) << 21))) | (0x100000)))) | ((rn23 << 16) | (((int)((usqInt)(rd15) << 12))))) | (((0) | val12) & 0xFFF);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord411;
			return 4;
			goto l260;
		}
		for (i16 = 2; i16 <= 30; i16 += 2) {
			if ((val12 & (((0xFFU << i16) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i16)))) == val12) {
				rot131 = 32 - i16;
				immediate1101 = (((usqInt)(val12)) >> i16) | ((((sqInt)((usqInt)(val12) << (32 - i16)))) & 0xFFFFFFFFU);
				aWord411 = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(XorOpcode) << 21))) | (0x100000)))) | ((rn23 << 16) | (((int)((usqInt)(rd15) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot131)) >> 1)) << 8))) | immediate1101) & 0xFFF);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord411;
				return 4;
				goto l260;
			}
		}
	l260:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		if (val12 > 0) {
			hb12 = highBit(val12);
			if ((1U << hb12) == (val12 + 1)) {
				/* MVN temp,  #0, making 0xffffffff */
				aWord128 = mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, 0, 0);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord128;
				aWord2111 = dataOpTyperdrnrmlsr(self_in_CogARMCompiler, XorOpcode, rd15, rn23, ConcreteIPReg, 32 - hb12);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[4 / 4] = aWord2111;
				return 8;
			}
		}
		/* begin concretizeDataOperationCwR: */
		rd14 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant8 = ((self_in_CogARMCompiler->operands))[0];
		rn110 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord316 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord316;
		instrOffset24 = 4;
		aWord1116 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(XorOpcode) << 21))) | (0x100000)))) | ((rn110 << 16) | (((sqInt)((usqInt)(rd14) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset24 / 4] = aWord1116;
		return instrOffset24 + 4;

	case AddCwR:
		/* begin concretizeDataOperationCwR: */
		rd16 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant9 = ((self_in_CogARMCompiler->operands))[0];
		rn24 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord72 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord72;
		instrOffset25 = 4;
		aWord130 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AddOpcode) << 21))) | (0x100000)))) | ((rn24 << 16) | (((sqInt)((usqInt)(rd16) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset25 / 4] = aWord130;
		return instrOffset25 + 4;

	case AndCwR:
		/* begin concretizeDataOperationCwR: */
		rd17 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant10 = ((self_in_CogARMCompiler->operands))[0];
		rn25 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord73 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord73;
		instrOffset26 = 4;
		aWord131 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((rn25 << 16) | (((sqInt)((usqInt)(rd17) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset26 / 4] = aWord131;
		return instrOffset26 + 4;

	case CmpCwR:
		/* begin concretizeDataOperationCwR: */
		rd18 = 0;
		/* begin concretizeDataOperationCwR:R: */
		constant12 = ((self_in_CogARMCompiler->operands))[0];
		rn26 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord74 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord74;
		instrOffset27 = 4;
		aWord132 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(CmpOpcode) << 21))) | (0x100000)))) | ((rn26 << 16) | (((sqInt)((usqInt)(rd18) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset27 / 4] = aWord132;
		return instrOffset27 + 4;

	case OrCwR:
		/* begin concretizeDataOperationCwR: */
		rd19 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant13 = ((self_in_CogARMCompiler->operands))[0];
		rn27 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord75 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord75;
		instrOffset28 = 4;
		aWord133 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(OrOpcode) << 21))) | (0x100000)))) | ((rn27 << 16) | (((sqInt)((usqInt)(rd19) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset28 / 4] = aWord133;
		return instrOffset28 + 4;

	case SubCwR:
		/* begin concretizeDataOperationCwR: */
		rd20 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant14 = ((self_in_CogARMCompiler->operands))[0];
		rn28 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord76 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord76;
		instrOffset29 = 4;
		aWord134 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(SubOpcode) << 21))) | (0x100000)))) | ((rn28 << 16) | (((sqInt)((usqInt)(rd20) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset29 / 4] = aWord134;
		return instrOffset29 + 4;

	case XorCwR:
		/* begin concretizeDataOperationCwR: */
		rd21 = ((self_in_CogARMCompiler->operands))[1];
		/* begin concretizeDataOperationCwR:R: */
		constant15 = ((self_in_CogARMCompiler->operands))[0];
		rn29 = ((self_in_CogARMCompiler->operands))[1];
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord77 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord77;
		instrOffset30 = 4;
		aWord135 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(XorOpcode) << 21))) | (0x100000)))) | ((rn29 << 16) | (((sqInt)((usqInt)(rd21) << 12))))) | (ConcreteIPReg & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset30 / 4] = aWord135;
		return instrOffset30 + 4;

	case AddRR:
		/* begin concretizeDataOperationRR: */
		srcReg13 = ((self_in_CogARMCompiler->operands))[0];
		rn = ((self_in_CogARMCompiler->operands))[1];
		rd = rn;
		aWord45 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AddOpcode) << 21))) | (0x100000)))) | ((rn << 16) | (((int)((usqInt)(rd) << 12))))) | (srcReg13 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord45;
		return 4;

	case AndRR:
		/* begin concretizeDataOperationRR: */
		srcReg14 = ((self_in_CogARMCompiler->operands))[0];
		rn1 = ((self_in_CogARMCompiler->operands))[1];
		rd1 = rn1;
		aWord46 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AndOpcode) << 21))) | (0x100000)))) | ((rn1 << 16) | (((int)((usqInt)(rd1) << 12))))) | (srcReg14 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord46;
		return 4;

	case CmpRR:
		/* begin concretizeDataOperationRR: */
		srcReg15 = ((self_in_CogARMCompiler->operands))[0];
		rn2 = ((self_in_CogARMCompiler->operands))[1];
		rd2 = 0;
		aWord47 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(CmpOpcode) << 21))) | (0x100000)))) | ((rn2 << 16) | (((int)((usqInt)(rd2) << 12))))) | (srcReg15 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord47;
		return 4;

	case OrRR:
		/* begin concretizeDataOperationRR: */
		srcReg16 = ((self_in_CogARMCompiler->operands))[0];
		rn3 = ((self_in_CogARMCompiler->operands))[1];
		rd3 = rn3;
		aWord48 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(OrOpcode) << 21))) | (0x100000)))) | ((rn3 << 16) | (((int)((usqInt)(rd3) << 12))))) | (srcReg16 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord48;
		return 4;

	case SubRR:
		/* begin concretizeDataOperationRR: */
		srcReg17 = ((self_in_CogARMCompiler->operands))[0];
		rn4 = ((self_in_CogARMCompiler->operands))[1];
		rd4 = rn4;
		aWord49 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(SubOpcode) << 21))) | (0x100000)))) | ((rn4 << 16) | (((int)((usqInt)(rd4) << 12))))) | (srcReg17 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord49;
		return 4;

	case XorRR:
		/* begin concretizeDataOperationRR: */
		srcReg18 = ((self_in_CogARMCompiler->operands))[0];
		rn5 = ((self_in_CogARMCompiler->operands))[1];
		rd5 = rn5;
		aWord50 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(XorOpcode) << 21))) | (0x100000)))) | ((rn5 << 16) | (((int)((usqInt)(rd5) << 12))))) | (srcReg18 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord50;
		return 4;

	case AddRRR:
		/* begin concretizeDataOperationRRR: */
		srcReg19 = ((self_in_CogARMCompiler->operands))[0];
		rn6 = ((self_in_CogARMCompiler->operands))[1];
		rd6 = ((self_in_CogARMCompiler->operands))[2];
		aWord51 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(AddOpcode) << 21))) | (0x100000)))) | ((rn6 << 16) | (rd6 << 12))) | (srcReg19 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord51;
		return 4;

	case SubRRR:
		/* begin concretizeDataOperationRRR: */
		srcReg20 = ((self_in_CogARMCompiler->operands))[0];
		rn7 = ((self_in_CogARMCompiler->operands))[1];
		rd7 = ((self_in_CogARMCompiler->operands))[2];
		aWord52 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(SubOpcode) << 21))) | (0x100000)))) | ((rn7 << 16) | (rd7 << 12))) | (srcReg20 & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord52;
		return 4;

	case AddRdRd:
		/* begin concretizeAddRdRd */
		regRHS = ((self_in_CogARMCompiler->operands))[0];
		regLHS = ((self_in_CogARMCompiler->operands))[1];
		((self_in_CogARMCompiler->machineCode))[0] = (((0xEE300B00U | (regLHS << 16)) | (regLHS << 12)) | regRHS);
		return 4;

	case CmpRdRd:
		/* begin concretizeCmpRdRd */
		regA = ((self_in_CogARMCompiler->operands))[0];
		regB = ((self_in_CogARMCompiler->operands))[1];
		((self_in_CogARMCompiler->machineCode))[0] = ((4004776768U | (regB << 12)) | regA);
		return 4;

	case DivRdRd:
		/* begin concretizeDivRdRd */
		regRHS1 = ((self_in_CogARMCompiler->operands))[0];
		regLHS1 = ((self_in_CogARMCompiler->operands))[1];
		((self_in_CogARMCompiler->machineCode))[0] = (((0xEE800B00U | (regLHS1 << 16)) | (regLHS1 << 12)) | regRHS1);
		return 4;

	case MulRdRd:
		/* begin concretizeMulRdRd */
		regRHS2 = ((self_in_CogARMCompiler->operands))[0];
		regLHS2 = ((self_in_CogARMCompiler->operands))[1];
		((self_in_CogARMCompiler->machineCode))[0] = (((0xEE200B00U | (regLHS2 << 16)) | (regLHS2 << 12)) | regRHS2);
		return 4;

	case SubRdRd:
		/* begin concretizeSubRdRd */
		regRHS3 = ((self_in_CogARMCompiler->operands))[0];
		regLHS3 = ((self_in_CogARMCompiler->operands))[1];
		((self_in_CogARMCompiler->machineCode))[0] = (((0xEE300B40U | (regLHS3 << 16)) | (regLHS3 << 12)) | regRHS3);
		return 4;

	case SqrtRd:
		/* begin concretizeSqrtRd */
		regLHS4 = ((self_in_CogARMCompiler->operands))[0];
		((self_in_CogARMCompiler->machineCode))[0] = ((4004580288U | (regLHS4 << 12)) | regLHS4);
		return 4;

	case NegateR:
		/* begin concretizeNegateR */
		/* RSB destReg, srcReg, #0 */
		reg1 = ((self_in_CogARMCompiler->operands))[0];
		((self_in_CogARMCompiler->machineCode))[0 / 4] = (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(RsbOpcode) << 21))) | (0)))) | ((reg1 << 16) | (reg1 << 12)));
		return 4;

	case LoadEffectiveAddressMwrR:
		/* begin concretizeLoadEffectiveAddressMwrR */
		immediate = 0;
		rot = 0;
		offset2 = ((self_in_CogARMCompiler->operands))[0];
		srcReg = ((self_in_CogARMCompiler->operands))[1];
		destReg = ((self_in_CogARMCompiler->operands))[2];
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((offset2 & 0xFF) == offset2) {
			return ((aWord4 = addrnimmror(self_in_CogARMCompiler, destReg, srcReg, offset2, 0)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord4,
				4);
		}
		for (i = 2; i <= 30; i += 2) {
			if ((offset2 & (((0xFFU << i) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i)))) == offset2) {
				return ((rot15 = 32 - i),
					(immediate21 = ((offset2) >> i) | ((offset2 << (32 - i)) & 0xFFFFFFFFU)),
					(aWord4 = addrnimmror(self_in_CogARMCompiler, destReg, srcReg, immediate21, rot15)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord4,
					4);
			}
		}
		return (			/* begin moveCw:intoR: */
				assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address))),
			assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000)),
			(aWord11 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
					? 1
					: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))))),
			/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord11,
			(instrOffset = 4),
			(aWord21 = addrnrm(self_in_CogARMCompiler, destReg, srcReg, ConcreteIPReg)),
			/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[instrOffset / 4] = aWord21,
			instrOffset + 4);

	case ArithmeticShiftRightCqR:
		/* begin concretizeArithmeticShiftRightCqR */
		distance = ((self_in_CogARMCompiler->operands))[0];
		reg3 = ((self_in_CogARMCompiler->operands))[1];
		assert(((distance >= 1) && (distance <= 0x1F)));
		aWord53 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (reg3 << 12))) | (((distance << 7) | (64 | reg3)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord53;
		return 4;

	case LogicalShiftRightCqR:
		/* begin concretizeLogicalShiftRightCqR */
		distance1 = ((self_in_CogARMCompiler->operands))[0];
		reg4 = ((self_in_CogARMCompiler->operands))[1];
		assert(((distance1 >= 1) && (distance1 <= 0x1F)));
		aWord54 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (reg4 << 12))) | (((distance1 << 7) | (32 | reg4)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord54;
		return 4;

	case LogicalShiftLeftCqR:
		/* begin concretizeLogicalShiftLeftCqR */
		distance2 = ((self_in_CogARMCompiler->operands))[0];
		reg5 = ((self_in_CogARMCompiler->operands))[1];
		assert(((distance2 >= 1) && (distance2 <= 0x1F)));
		aWord55 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (reg5 << 12))) | (((distance2 << 7) | reg5) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord55;
		return 4;

	case ArithmeticShiftRightCqRR:
		/* begin concretizeArithmeticShiftRightCqRR */
		distance3 = ((self_in_CogARMCompiler->operands))[0];
		srcReg21 = ((self_in_CogARMCompiler->operands))[1];
		destReg10 = ((self_in_CogARMCompiler->operands))[2];
		assert(((distance3 >= 1) && (distance3 <= 0x1F)));
		aWord56 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (destReg10 << 12))) | (((distance3 << 7) | (64 | srcReg21)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord56;
		return 4;

	case LogicalShiftRightCqRR:
		/* begin concretizeLogicalShiftRightCqRR */
		distance4 = ((self_in_CogARMCompiler->operands))[0];
		srcReg22 = ((self_in_CogARMCompiler->operands))[1];
		destReg11 = ((self_in_CogARMCompiler->operands))[2];
		assert(((distance4 >= 1) && (distance4 <= 0x1F)));
		aWord57 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (destReg11 << 12))) | (((distance4 << 7) | (32 | srcReg22)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord57;
		return 4;

	case LogicalShiftLeftCqRR:
		/* begin concretizeLogicalShiftLeftCqRR */
		distance5 = ((self_in_CogARMCompiler->operands))[0];
		srcReg23 = ((self_in_CogARMCompiler->operands))[1];
		destReg12 = ((self_in_CogARMCompiler->operands))[2];
		assert(((distance5 >= 1) && (distance5 <= 0x1F)));
		aWord58 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (destReg12 << 12))) | (((distance5 << 7) | srcReg23) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord58;
		return 4;

	case ArithmeticShiftRightRR:
		/* begin concretizeArithmeticShiftRightRR */
		distReg = ((self_in_CogARMCompiler->operands))[0];
		/* cond 000 1101 0 0000 destR distR 0101 srcR */
		destReg13 = ((self_in_CogARMCompiler->operands))[1];
		aWord59 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (destReg13 << 12))) | (((distReg << 8) | (80 | destReg13)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord59;
		return 4;

	case LogicalShiftLeftRR:
		/* begin concretizeLogicalShiftLeftRR */
		distReg1 = ((self_in_CogARMCompiler->operands))[0];
		/* cond 000 1101 0 0000 dest dist 0001 srcR */
		destReg14 = ((self_in_CogARMCompiler->operands))[1];
		aWord60 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (destReg14 << 12))) | (((distReg1 << 8) | (16 | destReg14)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord60;
		return 4;

	case LogicalShiftRightRR:
		/* begin concretizeLogicalShiftRightRR */
		distReg2 = ((self_in_CogARMCompiler->operands))[0];
		/* cond 000 1101 0 0000 dest dist 0011 srcR */
		destReg15 = ((self_in_CogARMCompiler->operands))[1];
		aWord61 = (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (destReg15 << 12))) | (((distReg2 << 8) | (48 | destReg15)) & 0xFFF);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord61;
		return 4;

	case ClzRR:
		/* begin concretizeClzRR */
		maskReg = ((self_in_CogARMCompiler->operands))[0];
		dest = ((self_in_CogARMCompiler->operands))[1];
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = ((((((int)((usqInt)(AL) << 28))) + 0x16F0F10) + (dest << 12)) + maskReg);
		return 4;

	case SMULL:
		return concretizeSMULL(self_in_CogARMCompiler);

	case CMPSMULL:
		return concretizeCMPSMULL(self_in_CogARMCompiler);

	case MSR:
		return concretizeMSR(self_in_CogARMCompiler);

	case PopLDM:
		return concretizePushOrPopMultipleRegisters(self_in_CogARMCompiler, 0);

	case PushSTM:
		return concretizePushOrPopMultipleRegisters(self_in_CogARMCompiler, 1);

	case MoveCqR:
		/* begin concretizeMoveCqR */
		immediate1 = 0;
		rot1 = 0;
		word = ((self_in_CogARMCompiler->operands))[0];
		reg2 = ((self_in_CogARMCompiler->operands))[1];
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((word & 0xFF) == word) {
			aWord5 = movimmror(self_in_CogARMCompiler, reg2, word, 0);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord5;
			return 4;
			goto l15;
		}
		for (i2 = 2; i2 <= 30; i2 += 2) {
			if ((word & (((0xFFU << i2) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i2)))) == word) {
				rot16 = 32 - i2;
				immediate112 = (((usqInt)(word)) >> i2) | ((((sqInt)((usqInt)(word) << (32 - i2)))) & 0xFFFFFFFFU);
				aWord5 = movimmror(self_in_CogARMCompiler, reg2, immediate112, rot16);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord5;
				return 4;
				goto l15;
			}
		}
	l15:	/* end rotateable8bitImmediate:ifTrue:ifFalse: */;
		invVal = (word < 0
			? -1 - word
			: (unsigned int)~word);
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((invVal & 0xFF) == invVal) {
			return ((aWord12 = mvnimmror(self_in_CogARMCompiler, reg2, invVal, 0)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord12,
				4);
		}
		for (i1 = 2; i1 <= 30; i1 += 2) {
			if ((invVal & (((0xFFU << i1) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i1)))) == invVal) {
				return ((rot17 = 32 - i1),
					(immediate113 = ((invVal) >> i1) | ((invVal << (32 - i1)) & 0xFFFFFFFFU)),
					(aWord12 = mvnimmror(self_in_CogARMCompiler, reg2, immediate113, rot17)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord12,
					4);
			}
		}
		return loadCwInto(self_in_CogARMCompiler, ((self_in_CogARMCompiler->operands))[1]);

	case MoveCwR:
		return loadCwInto(self_in_CogARMCompiler, ((self_in_CogARMCompiler->operands))[1]);

	case MoveRR:
		/* begin concretizeMoveRR */
		srcReg1 = ((self_in_CogARMCompiler->operands))[0];
		/* cond 000 1101 0 0000 dest 0000 0000 srcR */
		destReg1 = ((self_in_CogARMCompiler->operands))[1];
		aWord6 = movrn(self_in_CogARMCompiler, destReg1, srcReg1);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord6;
		return 4;

	case MoveAwR:
		/* begin concretizeMoveAwR */
		srcAddr = ((self_in_CogARMCompiler->operands))[0];
		destReg2 = ((self_in_CogARMCompiler->operands))[1];
		if (		/* begin isAddressRelativeToVarBase: */
			(srcAddr)
		 && ((srcAddr >= (varBaseAddress()))
		 && ((srcAddr - (varBaseAddress())) < (0x1000)))) {
			aWord7 = ldrrnplusImm(self_in_CogARMCompiler, destReg2, ConcreteVarBaseReg, srcAddr - (varBaseAddress()));
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord7;
			return 4;
		}
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord13 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord13;
		instrOffset1 = 4;
		aWord22 = ldrrnplusImm(self_in_CogARMCompiler, destReg2, ConcreteIPReg, 0);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset1 / 4] = aWord22;
		return instrOffset1 + 4;

	case MoveRAw:
		/* begin concretizeMoveRAw */
		srcReg2 = ((self_in_CogARMCompiler->operands))[0];
		destAddr = ((self_in_CogARMCompiler->operands))[1];
		if (		/* begin isAddressRelativeToVarBase: */
			(destAddr)
		 && ((destAddr >= (varBaseAddress()))
		 && ((destAddr - (varBaseAddress())) < (0x1000)))) {
			aWord8 = strrnplusImm(self_in_CogARMCompiler, srcReg2, ConcreteVarBaseReg, destAddr - (varBaseAddress()));
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord8;
			return 4;
		}
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord14 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord14;
		instrOffset2 = 4;
		aWord23 = strrnplusImm(self_in_CogARMCompiler, srcReg2, ConcreteIPReg, 0);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset2 / 4] = aWord23;
		return instrOffset2 + 4;

	case MoveAbR:
		/* begin concretizeMoveAbR */
		srcAddr1 = ((self_in_CogARMCompiler->operands))[0];
		destReg3 = ((self_in_CogARMCompiler->operands))[1];
		if (		/* begin isAddressRelativeToVarBase: */
			(srcAddr1)
		 && ((srcAddr1 >= (varBaseAddress()))
		 && ((srcAddr1 - (varBaseAddress())) < (0x1000)))) {
			aWord9 = ldrbrnplusimm(self_in_CogARMCompiler, destReg3, ConcreteVarBaseReg, 1, srcAddr1 - (varBaseAddress()));
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord9;
			return 4;
		}
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord15 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord15;
		instrOffset3 = 4;
		aWord24 = ldrbrnplusimm(self_in_CogARMCompiler, destReg3, ConcreteIPReg, 1, 0);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset3 / 4] = aWord24;
		return instrOffset3 + 4;

	case MoveRAb:
		/* begin concretizeMoveRAb */
		srcReg3 = ((self_in_CogARMCompiler->operands))[0];
		destAddr1 = ((self_in_CogARMCompiler->operands))[1];
		if (		/* begin isAddressRelativeToVarBase: */
			(destAddr1)
		 && ((destAddr1 >= (varBaseAddress()))
		 && ((destAddr1 - (varBaseAddress())) < (0x1000)))) {
			aWord10 = strbrnplusimm(self_in_CogARMCompiler, srcReg3, ConcreteVarBaseReg, 1, destAddr1 - (varBaseAddress()));
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord10;
			return 4;
		}
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord16 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord16;
		instrOffset4 = 4;
		aWord25 = strbrnplusimm(self_in_CogARMCompiler, srcReg3, ConcreteIPReg, 1, 0);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset4 / 4] = aWord25;
		return instrOffset4 + 4;

	case MoveMbrR:
		/* begin concretizeMoveMbrR */
		immediate2 = 0;
		u = 0;
		offset3 = ((self_in_CogARMCompiler->operands))[0];
		srcReg4 = ((self_in_CogARMCompiler->operands))[1];
		destReg4 = ((self_in_CogARMCompiler->operands))[2];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(offset3)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (offset3 >= 0) {
				return ((aWord17 = ldrbrnplusimm(self_in_CogARMCompiler, destReg4, srcReg4, 1, offset3)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord17,
					4);
			}
			else {
				return ((immediate22 = SQABS(offset3)),
					(aWord17 = ldrbrnplusimm(self_in_CogARMCompiler, destReg4, srcReg4, 0, immediate22)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord17,
					4);
			}
		}
		else {
			return ((					/* begin isAddressRelativeToVarBase: */
						(offset3)
					 && ((offset3 >= (varBaseAddress()))
					 && ((offset3 - (varBaseAddress())) < (0x1000)))
						? ((aWord18 = addsrnimmror(self_in_CogARMCompiler, ConcreteIPReg, ConcreteVarBaseReg, offset3 - (varBaseAddress()), 0)),
							/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord18,
							(instrOffset5 = 4))
						: (							/* begin moveCw:intoR: */
								assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address))),
							assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000)),
							(aWord26 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
									? 1
									: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))))),
							/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord26,
							(instrOffset5 = 4))),
				(aWord31 = ldrbrnrm(self_in_CogARMCompiler, destReg4, srcReg4, ConcreteIPReg)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[instrOffset5 / 4] = aWord31,
				instrOffset5 + 4);
		}

	case MoveRMbr:
		/* begin concretizeMoveRMbr */
		immediate3 = 0;
		u1 = 0;
		srcReg5 = ((self_in_CogARMCompiler->operands))[0];
		offset4 = ((self_in_CogARMCompiler->operands))[1];
		baseReg = ((self_in_CogARMCompiler->operands))[2];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(offset4)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (offset4 >= 0) {
				return ((aWord19 = strbrnplusimm(self_in_CogARMCompiler, srcReg5, baseReg, 1, offset4)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord19,
					4);
			}
			else {
				return ((immediate31 = SQABS(offset4)),
					(aWord19 = strbrnplusimm(self_in_CogARMCompiler, srcReg5, baseReg, 0, immediate31)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord19,
					4);
			}
		}
		else {
			return ((					/* begin isAddressRelativeToVarBase: */
						(offset4)
					 && ((offset4 >= (varBaseAddress()))
					 && ((offset4 - (varBaseAddress())) < (0x1000)))
						? ((aWord110 = addsrnimmror(self_in_CogARMCompiler, ConcreteIPReg, ConcreteVarBaseReg, offset4 - (varBaseAddress()), 0)),
							/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord110,
							(instrOffset6 = 4))
						: (							/* begin moveCw:intoR: */
								assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address))),
							assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000)),
							(aWord27 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
									? 1
									: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))))),
							/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord27,
							(instrOffset6 = 4))),
				(aWord32 = strbrnrm(self_in_CogARMCompiler, srcReg5, baseReg, ConcreteIPReg)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[instrOffset6 / 4] = aWord32,
				instrOffset6 + 4);
		}

	case MoveRM16r:
		/* begin concretizeMoveRM16r */
		immediate4 = 0;
		u2 = 0;
		srcReg6 = ((self_in_CogARMCompiler->operands))[0];
		offset5 = ((self_in_CogARMCompiler->operands))[1];
		baseReg1 = ((self_in_CogARMCompiler->operands))[2];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(offset5)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (offset5 >= 0) {
				return ((aWord20 = strhrnplusimm(self_in_CogARMCompiler, srcReg6, baseReg1, 1, offset5)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord20,
					4);
			}
			else {
				return ((immediate41 = SQABS(offset5)),
					(aWord20 = strhrnplusimm(self_in_CogARMCompiler, srcReg6, baseReg1, 0, immediate41)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord20,
					4);
			}
		}
		else {
			return ((					/* begin isAddressRelativeToVarBase: */
						(offset5)
					 && ((offset5 >= (varBaseAddress()))
					 && ((offset5 - (varBaseAddress())) < (0x1000)))
						? ((aWord111 = addsrnimmror(self_in_CogARMCompiler, ConcreteIPReg, ConcreteVarBaseReg, offset5 - (varBaseAddress()), 0)),
							/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord111,
							(instrOffset7 = 4))
						: (							/* begin moveCw:intoR: */
								assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address))),
							assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000)),
							(aWord28 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
									? 1
									: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))))),
							/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord28,
							(instrOffset7 = 4))),
				(aWord33 = strhrnrm(self_in_CogARMCompiler, srcReg6, baseReg1, ConcreteIPReg)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[instrOffset7 / 4] = aWord33,
				instrOffset7 + 4);
		}

	case MoveM16rR:
		/* begin concretizeMoveM16rR */
		immediate5 = 0;
		u3 = 0;
		offset6 = ((self_in_CogARMCompiler->operands))[0];
		srcReg7 = ((self_in_CogARMCompiler->operands))[1];
		destReg5 = ((self_in_CogARMCompiler->operands))[2];
		/* begin is8BitValue:ifTrue:ifFalse: */
		if ((SQABS(offset6)) <= 0xFF) {
			/* (2 raisedTo: 8)-1 */
			if (offset6 >= 0) {
				aWord29 = ldrhrnplusimm(self_in_CogARMCompiler, destReg5, srcReg7, 1, offset6);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord29;
				return 4;
			}
			else {
				immediate51 = SQABS(offset6);
				aWord29 = ldrhrnplusimm(self_in_CogARMCompiler, destReg5, srcReg7, 0, immediate51);
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord29;
				return 4;
			}
		}
		else {
			/* begin moveCw:intoR: */
			assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
			assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
			aWord112 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
				? 1
				: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord112;
			instrOffset8 = 4;
			aWord210 = ldrhrnrm(self_in_CogARMCompiler, destReg5, srcReg7, ConcreteIPReg);
			/* begin machineCodeAt:put: */
			((self_in_CogARMCompiler->machineCode))[instrOffset8 / 4] = aWord210;
			return instrOffset8 + 4;
		}
		return 0;

	case MoveM64rRd:
		/* begin concretizeMoveM64rRd */
		offset7 = ((self_in_CogARMCompiler->operands))[0];
		u4 = (offset7 > 0
			? 1
			: 0);
		srcReg8 = ((self_in_CogARMCompiler->operands))[1];
		destReg6 = ((self_in_CogARMCompiler->operands))[2];
		((self_in_CogARMCompiler->machineCode))[0] = ((((0xED100B00U | (srcReg8 << 16)) | (destReg6 << 12)) | (((int)((usqInt)(u4) << 23)))) | (((usqInt)(offset7)) >> 2));
		return 4;

	case MoveMwrR:
		/* begin concretizeMoveMwrR */
		immediate6 = 0;
		u5 = 0;
		offset8 = ((self_in_CogARMCompiler->operands))[0];
		srcReg9 = ((self_in_CogARMCompiler->operands))[1];
		destReg7 = ((self_in_CogARMCompiler->operands))[2];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(offset8)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (offset8 >= 0) {
				return ((aWord30 = ldrrnplusimm(self_in_CogARMCompiler, destReg7, srcReg9, 1, offset8)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord30,
					4);
			}
			else {
				return ((immediate61 = SQABS(offset8)),
					(aWord30 = ldrrnplusimm(self_in_CogARMCompiler, destReg7, srcReg9, 0, immediate61)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord30,
					4);
			}
		}
		else {
			return (				/* begin moveCw:intoR: */
					assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address))),
				assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000)),
				(aWord113 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
						? 1
						: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))))),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord113,
				(instrOffset9 = 4),
				(aWord211 = ldrrnrm(self_in_CogARMCompiler, destReg7, srcReg9, ConcreteIPReg)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[instrOffset9 / 4] = aWord211,
				instrOffset9 + 4);
		}

	case MoveXbrRR:
		/* begin concretizeMoveXbrRR */
		/* index is number of *bytes* */
		index = ((self_in_CogARMCompiler->operands))[0];
		base = ((self_in_CogARMCompiler->operands))[1];
		/* LDRB	dest, [base, +index, LSL #0] */
		/* cond 011 1100 1 base dest 00000 00 0 inde */
		dest1 = ((self_in_CogARMCompiler->operands))[2];
		aWord34 = ldrbrnrm(self_in_CogARMCompiler, dest1, base, index);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord34;
		return 4;

	case MoveRXbrR:
		/* begin concretizeMoveRXbrR */
		src = ((self_in_CogARMCompiler->operands))[0];
		index1 = ((self_in_CogARMCompiler->operands))[1];
		/* str	b	src, [base, +index, LSL #0] */
		/* cond 011 1100 0 base srcR 00000 00 0 index */
		base1 = ((self_in_CogARMCompiler->operands))[2];
		aWord35 = strbrnrm(self_in_CogARMCompiler, src, base1, index1);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord35;
		return 4;

	case MoveXwrRR:
		/* begin concretizeMoveXwrRR */
		index2 = ((self_in_CogARMCompiler->operands))[0];
		base2 = ((self_in_CogARMCompiler->operands))[1];
		/* LDR	dest, [base, +index, LSL #2] */
		/* cond 011 1100 1 base dest 00010 00 0 inde bulit by lowest level generator so we can do the lsl #2 on the index register */
		dest2 = ((self_in_CogARMCompiler->operands))[2];
		aWord36 = memMxrregbasepubwlrmLsl2(self_in_CogARMCompiler, AL, dest2, base2, 1, 1, 0, 0, 1, index2);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord36;
		return 4;

	case MoveRXwrR:
		/* begin concretizeMoveRXwrR */
		src1 = ((self_in_CogARMCompiler->operands))[0];
		/* index is number of *words* = 4* bytes */
		index3 = ((self_in_CogARMCompiler->operands))[1];
		/* str		src, [base, +index, LSL #2] */
		/* cond 011 1100 0 base srcR 00010 00 0 inde */
		base3 = ((self_in_CogARMCompiler->operands))[2];
		aWord37 = memMxrregbasepubwlrmLsl2(self_in_CogARMCompiler, AL, src1, base3, 1, 1, 0, 0, 0, index3);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord37;
		return 4;

	case MoveRMwr:
		/* begin concretizeMoveRMwr */
		immediate7 = 0;
		u6 = 0;
		srcReg10 = ((self_in_CogARMCompiler->operands))[0];
		offset9 = ((self_in_CogARMCompiler->operands))[1];
		baseReg2 = ((self_in_CogARMCompiler->operands))[2];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(offset9)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (offset9 >= 0) {
				return ((aWord38 = strrnplusimm(self_in_CogARMCompiler, srcReg10, baseReg2, 1, offset9)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord38,
					4);
			}
			else {
				return ((immediate71 = SQABS(offset9)),
					(aWord38 = strrnplusimm(self_in_CogARMCompiler, srcReg10, baseReg2, 0, immediate71)),
					/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord38,
					4);
			}
		}
		else {
			return (				/* begin moveCw:intoR: */
					assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address))),
				assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000)),
				(aWord114 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
						? 1
						: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))))),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord114,
				(instrOffset10 = 4),
				(aWord212 = strrnrm(self_in_CogARMCompiler, srcReg10, baseReg2, ConcreteIPReg)),
				/* begin machineCodeAt:put: */
((self_in_CogARMCompiler->machineCode))[instrOffset10 / 4] = aWord212,
				instrOffset10 + 4);
		}

	case MoveRdM64r:
		/* begin concretizeMoveRdM64r */
		offset10 = ((self_in_CogARMCompiler->operands))[1];
		u7 = (offset10 > 0
			? 1
			: 0);
		dstReg = ((self_in_CogARMCompiler->operands))[2];
		fpReg = ((self_in_CogARMCompiler->operands))[0];
		((self_in_CogARMCompiler->machineCode))[0] = ((((0xED000B00U | (dstReg << 16)) | (fpReg << 12)) | (((int)((usqInt)(u7) << 23)))) | (((usqInt)(offset10)) >> 2));
		return 4;

	case PopR:
		/* begin concretizePopR */
		/* LDR destReg, [SP], #4 */
		destReg8 = ((self_in_CogARMCompiler->operands))[0];
		aWord39 = popR(self_in_CogARMCompiler, destReg8);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord39;
		return 4;

	case PushR:
		/* begin concretizePushR */
		/* cond | 010 | 1001 | 0 | -Rn- | -Rd- | 0000 0000 0100 */
		/* STR srcReg, [sp, #-4] */
		srcReg11 = ((self_in_CogARMCompiler->operands))[0];
		aWord40 = pushR(self_in_CogARMCompiler, srcReg11);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord40;
		return 4;

	case PushCq:
		/* begin concretizePushCq */
		immediate8 = 0;
		invert = 0;
		rot2 = 0;
		word1 = ((self_in_CogARMCompiler->operands))[0];
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value = word1;
		while (1) {
			if ((value & 0xFF) == value) {
				invert5 = word1 != value;
				aWord41 = (invert5
					? mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, value, 0)
					: movimmror(self_in_CogARMCompiler, ConcreteIPReg, value, 0));
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord41;
				instrOffset11 = 4;
				goto l70;
			}
			for (i3 = 2; i3 <= 30; i3 += 2) {
				if ((value & (((0xFFU << i3) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i3)))) == value) {
					rot21 = 32 - i3;
					immediate81 = ((value) >> i3) | ((value << (32 - i3)) & 0xFFFFFFFFU);
					invert6 = word1 != value;
					aWord41 = (invert6
						? mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, immediate81, rot21)
						: movimmror(self_in_CogARMCompiler, ConcreteIPReg, immediate81, rot21));
					/* begin machineCodeAt:put: */
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord41;
					instrOffset11 = 4;
					goto l70;
				}
			}
			if (!(value == word1)) break;
			value = (word1 < 0
				? -1 - word1
				: (unsigned int)~word1);
		}
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord115 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord115;
		instrOffset11 = 4;
	l70:	/* end rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */;
		aWord213 = pushR(self_in_CogARMCompiler, ConcreteIPReg);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset11 / 4] = aWord213;
		return instrOffset11 + 4;

	case PushCw:
		/* begin concretizePushCw */
		immediate9 = 0;
		invert1 = 0;
		rot3 = 0;
		word2 = ((self_in_CogARMCompiler->operands))[0];
		if (		/* begin inCurrentCompilation: */
			((addressIsInInstructions(((AbstractInstruction *) word2)))
		 || ((((AbstractInstruction *) word2)) == (methodLabel())))
		 || (((((usqInt)word2)) >= ((methodLabel->address)))
		 && ((((usqInt)word2)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize)))))) {
			instrOffset12 = loadCwInto(self_in_CogARMCompiler, ConcreteIPReg);
		}
		else {
			/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
			value1 = word2;
			while (1) {
				if ((value1 & 0xFF) == value1) {
					invert11 = word2 != value1;
					aWord42 = (invert11
						? mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, value1, 0)
						: movimmror(self_in_CogARMCompiler, ConcreteIPReg, value1, 0));
					/* begin machineCodeAt:put: */
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord42;
					instrOffset12 = 4;
					goto l74;
				}
				for (i4 = 2; i4 <= 30; i4 += 2) {
					if ((value1 & (((0xFFU << i4) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i4)))) == value1) {
						rot31 = 32 - i4;
						immediate91 = ((value1) >> i4) | ((value1 << (32 - i4)) & 0xFFFFFFFFU);
						invert12 = word2 != value1;
						aWord42 = (invert12
							? mvnimmror(self_in_CogARMCompiler, ConcreteIPReg, immediate91, rot31)
							: movimmror(self_in_CogARMCompiler, ConcreteIPReg, immediate91, rot31));
						/* begin machineCodeAt:put: */
						((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord42;
						instrOffset12 = 4;
						goto l74;
					}
				}
				if (!(value1 == word2)) break;
				value1 = (word2 < 0
					? -1 - word2
					: (unsigned int)~word2);
			}
			instrOffset12 = loadCwInto(self_in_CogARMCompiler, ConcreteIPReg);
	l74:	/* end rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */;
		}
		aWord116 = pushR(self_in_CogARMCompiler, ConcreteIPReg);
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset12 / 4] = aWord116;
		return instrOffset12 + 4;

	case PrefetchAw:
		/* begin concretizePrefetchAw */
		addressOperand = ((self_in_CogARMCompiler->operands))[0];
		if (		/* begin isAddressRelativeToVarBase: */
			(addressOperand)
		 && ((addressOperand >= (varBaseAddress()))
		 && ((addressOperand - (varBaseAddress())) < (0x1000)))) {
			immediate10 = addressOperand - (varBaseAddress());
			/* begin pld:plus:offset: */
			aWord62 = 0xF550F000U | ((((int)((usqInt)(ConcreteVarBaseReg) << 16))) | ((0x800000) | immediate10));
			((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord62;
			return 4;
		}
		/* begin moveCw:intoR: */
		assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
		assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
		aWord117 = ldrrnplusimm(self_in_CogARMCompiler, ConcreteIPReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
			? 1
			: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord117;
		instrOffset15 = 4;
		/* begin machineCodeAt:put: */
		((self_in_CogARMCompiler->machineCode))[instrOffset15 / 4] = (0xF550F000U | ((((int)((usqInt)(ConcreteIPReg) << 16))) | ((0x800000) | 0)));
		return instrOffset15 + 4;

	case ConvertRRd:
		/* begin concretizeConvertRRd */
		srcReg12 = ((self_in_CogARMCompiler->operands))[0];
		destReg9 = ((self_in_CogARMCompiler->operands))[1];
		((self_in_CogARMCompiler->machineCode))[0] = (fmsrFromto(self_in_CogARMCompiler, srcReg12, 9));
		((self_in_CogARMCompiler->machineCode))[1] = (fsitodFromto(self_in_CogARMCompiler, 9, destReg9));
		return 8;

	default:
		error("Case not found and no otherwise clause");
	}
	return 0;
}


/*	FMSR or VMOV instruction to move a value from an ARM reg to an fpu double
	register ready for conversion
	FMSR regB, regA - ARM_ARM v5 DDI 01001.pdf pp. C4-68
	VMOV regB, regA - ARM_ARM v7 DDi10406 pp. A8-462-3
 */
/*	the dest reg bits are spread out a little */

	/* CogARMCompiler>>#fmsrFrom:to: */
static NoDbgRegParms unsigned int
fmsrFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt regA, sqInt regB)
{
    sqInt destReg;

	destReg = (((sqInt)((usqInt)((((usqInt)(regB)) >> 1)) << 16))) | (((sqInt)((usqInt)((regB & 1)) << 7)));
	return (0xEE000A10U | (((sqInt)((usqInt)(regA) << 12)))) | destReg;
}


/*	FSITOD or VCVT instruction to move convert an integer value to an fpu
	double FSITOD regB, regA - ARM_ARM v5 DDI 01001.pdf pp. C4-95
	VCVTW. regB, regA - ARM_ARM v7 DDI10406.pdf pp. A8-576-8
 */
/*	the src reg bits are spread out a little */

	/* CogARMCompiler>>#fsitodFrom:to: */
static NoDbgRegParms unsigned int
fsitodFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt regA, sqInt regB)
{
    sqInt srcReg;

	srcReg = (((usqInt)(regA)) >> 1) | (((sqInt)((usqInt)((regA & 1)) << 5)));
	return (4005039040U | srcReg) | (((sqInt)((usqInt)(regB) << 12)));
}


/*	Answer if CallFull and/or JumpFull are relative and hence need relocating
	on method
	compation. If so, they are annotated with IsRelativeCall in methods and
	relocated in
	relocateIfCallOrMethodReference:mcpc:delta: */

	/* CogARMCompiler>>#fullCallsAreRelative */
static NoDbgRegParms sqInt
fullCallsAreRelative(AbstractInstruction *self_in_CogARMCompiler)
{
	return 0;
}


/*	Currently no instruction level support for divide on ARM. See also
	#canDivQuoRem 
 */

	/* CogARMCompiler>>#genDivR:R:Quo:Rem: */
static NoDbgRegParms AbstractInstruction *
genDivRRQuoRem(AbstractInstruction *self_in_CogARMCompiler, sqInt abstractRegDivisor, sqInt abstractRegDividend, sqInt abstractRegQuotient, sqInt abstractRegRemainder)
{
    usqInt divRemFunctionAddr;
    AbstractInstruction *inst;
    sqInt rDividend;
    sqInt rDivisor;
    sqInt rQuotient;
    sqInt rRemainder;

	assert(abstractRegDividend != abstractRegDivisor);
	assert(abstractRegQuotient != abstractRegRemainder);
	rDividend = abstractRegDividend;
	rDivisor = abstractRegDivisor;
	if (!(rDividend == CArg0Reg)) {
		/* we need to move the value in rDividend to CArg0Reg. Best to double check if rDivisor is already using it first */
		if (rDivisor == CArg0Reg) {
			/* oh dear; we also need to move rDivisor's value out of the way first.. I'll move it to CArg1Reg and if some nitwit has managed to put rDividend there they deserve the crash */
			if (rDividend == CArg1Reg) {
				error("register choices in genDivR:R:Quo:Rem: made life impossible");
			}
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, rDivisor, CArg1Reg);
			rDivisor = CArg1Reg;
		}
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, rDividend, CArg0Reg);
	}
	if (!(rDivisor == CArg1Reg)) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, rDivisor, CArg1Reg);
	}
	divRemFunctionAddr = aeabiDivModFunctionAddr(self_in_CogARMCompiler);
	/* begin saveAndRestoreLinkRegAround: */
	inst = genoperand(PushR, LinkReg);
	CallFullRTregistersToBeSavedMask(((usqInt)divRemFunctionAddr), (1U << CArg2Reg) | (1U << CArg3Reg));
	/* begin PopR: */
	genoperand(PopR, LinkReg);
	rQuotient = abstractRegQuotient;
	rRemainder = abstractRegRemainder;
	if (!(rQuotient == CArg0Reg)) {
		/* oh good grief, not again */
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, CArg0Reg, rQuotient);
		if (rQuotient == CArg1Reg) {
			error("register choices in genDivR:R:Quo:Rem: made life impossible");
		}
	}
	if (!(rRemainder == CArg1Reg)) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, CArg1Reg, rRemainder);
	}
	return self_in_CogARMCompiler;
}


/*	Generate the code to pass up to four arguments in a C run-time call. Hack:
	each argument is
	either a negative number, which encodes a constant, or a non-negative
	number, that of a register.
	The encoding for constants is defined by trampolineArgConstant: &
	trampolineArgValue:. Pass a constant as the result of
	trampolineArgConstant:. 
	Run-time calls have no more than four arguments, so chosen so that on ARM,
	where in its C ABI the
	first four integer arguments are passed in registers, all arguments can be
	passed in registers. We
	defer to the back end to generate this code not so much that the back end
	knows whether it uses
	the stack or registers to pass arguments (it does, but...). In fact we
	defer for an extremely evil reason.
	Doing so allows the x64 (where up to 6 args are passed) to assign the
	register arguments in an order
	that allows some of the argument registers to be used for specific
	abstract registers, specifically
	ReceiverResultReg and ClassReg. This is evil, evil, evil, but also it's
	really nice to keep using the old
	register assignments the original author has grown accustomed to. */

	/* CogARMCompiler>>#genMarshallNArgs:arg:arg:arg:arg: */
static NoDbgRegParms AbstractInstruction *
genMarshallNArgsargargargarg(AbstractInstruction *self_in_CogARMCompiler, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;

	if (numArgs == 0) {
		return self_in_CogARMCompiler;
	}
	if (numArgs > 1) {
		if ((!(regOrConst1 < NoReg))
		 && (regOrConst1 == CArg0Reg)) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst1, Extra0Reg);
			return genMarshallNArgsargargargarg(self_in_CogARMCompiler, numArgs, regOrConst0, Extra0Reg, regOrConst2, regOrConst3);
		}
		if (numArgs > 2) {
			if ((!(regOrConst2 < NoReg))
			 && ((regOrConst2 == CArg0Reg)
			 || (regOrConst2 == CArg1Reg))) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, regOrConst2, Extra1Reg);
				return genMarshallNArgsargargargarg(self_in_CogARMCompiler, numArgs, regOrConst0, regOrConst1, Extra1Reg, regOrConst3);
			}
			if (numArgs > 3) {
				if ((!(regOrConst3 < NoReg))
				 && ((regOrConst3 == CArg0Reg)
				 || ((regOrConst3 == CArg1Reg)
				 || (regOrConst3 == CArg2Reg)))) {
					/* begin MoveR:R: */
					genoperandoperand(MoveRR, regOrConst3, Extra2Reg);
					return genMarshallNArgsargargargarg(self_in_CogARMCompiler, numArgs, regOrConst0, regOrConst1, regOrConst2, Extra2Reg);
				}
			}
		}
	}
	if (regOrConst0 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, -2 - regOrConst0, CArg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(-2 - regOrConst0));
		}
	}
	else {
		if (regOrConst0 != CArg0Reg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst0, CArg0Reg);
		}
	}
	if (numArgs == 1) {
		return self_in_CogARMCompiler;
	}
	if (regOrConst1 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction1 = genoperandoperand(MoveCqR, -2 - regOrConst1, CArg1Reg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(-2 - regOrConst1));
		}
	}
	else {
		if (regOrConst1 != CArg1Reg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst1, CArg1Reg);
		}
	}
	if (numArgs == 2) {
		return self_in_CogARMCompiler;
	}
	if (regOrConst2 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction2 = genoperandoperand(MoveCqR, -2 - regOrConst2, CArg2Reg);
		if (usesOutOfLineLiteral(anInstruction2)) {
			(anInstruction2->dependent = locateLiteral(-2 - regOrConst2));
		}
	}
	else {
		if (regOrConst2 != CArg2Reg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst2, CArg2Reg);
		}
	}
	if (numArgs == 3) {
		return self_in_CogARMCompiler;
	}
	if (regOrConst3 < NoReg) {
		/* begin MoveCq:R: */
		anInstruction3 = genoperandoperand(MoveCqR, -2 - regOrConst3, CArg3Reg);
		if (usesOutOfLineLiteral(anInstruction3)) {
			(anInstruction3->dependent = locateLiteral(-2 - regOrConst3));
		}
	}
	else {
		if (regOrConst3 != CArg3Reg) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, regOrConst3, CArg3Reg);
		}
	}
	return self_in_CogARMCompiler;
}


/*	Use SMULL to produce a 64-bit result, explicitly in RISCTempReg,regDest. -
	ARM_ARM v7 DDI10406 pp. A8-354-5
	By comparing RISCTempReg with regDest ASR 31(which effectively makes it 0
	or -1) we know that the result being EQ means the hi reg and the top bit
	of the lo reg are the same - ie no overflow. The condition code can then
	be forced to oVerflow by use of MSR APSR_nzcvq, #1, lsl 28
 */

	/* CogARMCompiler>>#genMulR:R: */
static NoDbgRegParms AbstractInstruction *
genMulRR(AbstractInstruction *self_in_CogARMCompiler, sqInt regSource, sqInt regDest)
{
    AbstractInstruction *first;


	/* result in RISCTempReg,regDest */
	first = genoperandoperand(SMULL, regSource, regDest);
	genoperandoperand(CMPSMULL, RISCTempReg, regDest);
	genoperand(MSR, 1);
	return first;
}


/*	Ensure that the register args are pushed before the outer and
	inner retpcs at an entry miss for arity <= self numRegArgs. The
	outer retpc is that of a call at a send site. The inner is the call
	from a method or PIC abort/miss to the trampoline. */
/*	Putting the receiver and args above the return address means the
	CoInterpreter has a single machine-code frame format which saves
	us a lot of work. */
/*	Iff there are register args convert
	sp		->	outerRetpc			(send site retpc)
	linkReg = innerRetpc			(PIC abort/miss retpc)
	to
	base	->	receiver
	(arg0)
	(arg1)
	sp		->	outerRetpc			(send site retpc)
	sp		->	linkReg/innerRetpc	(PIC abort/miss retpc) */

	/* CogARMCompiler>>#genPushRegisterArgsForAbortMissNumArgs: */
static NoDbgRegParms AbstractInstruction *
genPushRegisterArgsForAbortMissNumArgs(AbstractInstruction *self_in_CogARMCompiler, sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;

	if (numArgs <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);
		/* begin MoveMw:r:R: */
		anInstruction = genoperandoperandoperand(MoveMwrR, 0, SPReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(0));
		}
		/* begin MoveR:Mw:r: */
		anInstruction1 = genoperandoperandoperand(MoveRMwr, ReceiverResultReg, 0, SPReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(0));
		}
		if (numArgs > 0) {
			/* begin PushR: */
			genoperand(PushR, Arg0Reg);
			if (numArgs > 1) {
				/* begin PushR: */
				genoperand(PushR, Arg1Reg);
			}
		}
		genoperand(PushR, TempReg);
	}
	genoperand(PushR, LinkReg);
	return self_in_CogARMCompiler;
}


/*	Ensure that the register args are pushed before the retpc for arity <=
	self numRegArgs.
 */
/*	This is easy on a RISC like ARM because the return address is in the link
	register. Putting
	the receiver and args above the return address means the CoInterpreter has
	a single
	machine-code frame format which saves us a lot of work
	NOTA BENE: we do NOT push the return address here, which means it must be
	dealt with later. */

	/* CogARMCompiler>>#genPushRegisterArgsForNumArgs:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genPushRegisterArgsForNumArgsscratchReg(AbstractInstruction *self_in_CogARMCompiler, sqInt numArgs, sqInt ignored)
{
	if (numArgs <= (numRegArgs())) {
		assert((numRegArgs()) <= 2);
		/* begin PushR: */
		genoperand(PushR, ReceiverResultReg);
		if (numArgs > 0) {
			/* begin PushR: */
			genoperand(PushR, Arg0Reg);
			if (numArgs > 1) {
				/* begin PushR: */
				genoperand(PushR, Arg1Reg);
			}
		}
	}
	return self_in_CogARMCompiler;
}


/*	This is a no-op on ARM since the ABI passes up to 4 args in registers and
	trampolines currently observe that limit.
 */

	/* CogARMCompiler>>#genRemoveNArgsFromStack: */
static NoDbgRegParms sqInt
genRemoveNArgsFromStack(AbstractInstruction *self_in_CogARMCompiler, sqInt n)
{
	assert(n <= 4);
	return 0;
}


/*	Restore the registers in regMask as saved by genSaveRegs:. */

	/* CogARMCompiler>>#genRestoreRegs: */
static NoDbgRegParms AbstractInstruction *
genRestoreRegs(AbstractInstruction *self_in_CogARMCompiler, sqInt regMask)
{
	return 
	/* begin genPopRegisterMask: */
(regMask == 0
		? genoperandoperand(Label, (labelCounter += 1), bytecodePC)
		: genoperand(PopLDM, regMask));
}


/*	Save the registers in regMask for a call into the C run-time from a
	trampoline 
 */

	/* CogARMCompiler>>#genSaveRegs: */
static NoDbgRegParms AbstractInstruction *
genSaveRegs(AbstractInstruction *self_in_CogARMCompiler, sqInt regMask)
{
	return 
	/* begin genPushRegisterMask: */
(regMask == 0
		? genoperandoperand(Label, (labelCounter += 1), bytecodePC)
		: genoperand(PushSTM, regMask));
}

	/* CogARMCompiler>>#genSubstituteReturnAddress: */
static NoDbgRegParms AbstractInstruction *
genSubstituteReturnAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt retpc)
{
	return checkLiteralforInstruction(retpc, genoperandoperand(MoveCwR, retpc, LR));
}


/*	AArch32 has a 64-bit counter but it is typically restricted.
	So for now do without.
	See e.g.
	http://neocontra.blogspot.com/2013/05/user-mode-performance-counters-for.html
	https://stackoverflow.com/questions/3247373/how-to-measure-program-execution-time-in-arm-cortex-a8-processor/3250835#3250835  */

	/* CogARMCompiler>>#has64BitPerformanceCounter */
static NoDbgRegParms sqInt
has64BitPerformanceCounter(AbstractInstruction *self_in_CogARMCompiler)
{
	return 0;
}


/*	Answer if the processor has a dedicated callee-saved register to point to
	the base of commonly-accessed variables. On ARM we use R10 for this. */

	/* CogARMCompiler>>#hasVarBaseRegister */
static NoDbgRegParms sqInt
hasVarBaseRegister(AbstractInstruction *self_in_CogARMCompiler)
{
	return 1;
}


/*	Answer the instruction immediately preceding followingAddress. */

	/* CogARMCompiler>>#instructionBeforeAddress: */
static NoDbgRegParms sqInt
instructionBeforeAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt followingAddress)
{
	return longAt(followingAddress - 4);
}


/*	is this a BLX <targetReg> instruction? */

	/* CogARMCompiler>>#instructionIsBLX: */
static NoDbgRegParms sqInt
instructionIsBLX(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && ((instr & 0xFFFFFF0) == 19922736);
}


/*	is this a BL <offset> instruction? */

	/* CogARMCompiler>>#instructionIsBL: */
static NoDbgRegParms sqInt
instructionIsBL(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && ((instr & (0xF000000)) == (0xB000000));
}


/*	is this a BX <targetReg> instruction? */

	/* CogARMCompiler>>#instructionIsBX: */
static NoDbgRegParms sqInt
instructionIsBX(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && ((instr & 0xFFFFFF0) == 0x12FFF10);
}


/*	is this a B <offset> instruction? */

	/* CogARMCompiler>>#instructionIsB: */
static NoDbgRegParms sqInt
instructionIsB(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && ((instr & (0xF000000)) == (0xA000000));
}


/*	is this a CMP instruction? */

	/* CogARMCompiler>>#instructionIsCMP: */
static NoDbgRegParms sqInt
instructionIsCMP(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && (((((usqInt)(instr)) >> 21) & 0x7F) == CmpOpcode);
}


/*	is this any kind of LDR instruction? c.f. memMxr:reg:base:u:b:l:imm: */

	/* CogARMCompiler>>#instructionIsLDR: */
static NoDbgRegParms sqInt
instructionIsLDR(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && (((((usqInt)(instr)) >> 20) & 197) == 65);
}


/*	is this an ORR instruction? */

	/* CogARMCompiler>>#instructionIsOR: */
static NoDbgRegParms sqInt
instructionIsOR(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && (((((usqInt)(instr)) >> 21) & 0x7F) == (16 | OrOpcode));
}


/*	is this a push -str r??, [sp, #-4] - instruction? */

	/* CogARMCompiler>>#instructionIsPush: */
static NoDbgRegParms sqInt
instructionIsPush(AbstractInstruction *self_in_CogARMCompiler, sqInt instr)
{
	return (conditionIsNotNever(self_in_CogARMCompiler, instr))
	 && ((instr & 0xFFF0FFF) == 0x52D0004);
}


/*	Answer the instruction size at pc.Simple on ARM ;-) */

	/* CogARMCompiler>>#instructionSizeAt: */
static NoDbgRegParms sqInt
instructionSizeAt(AbstractInstruction *self_in_CogARMCompiler, sqInt pc)
{
	return 4;
}


/*	Several of the opcodes are inverses. Answer the inverse for an opcode if
	it has one.
	See Table A3-2 in sec A3.4 Data-processing instructions of the AARM. */

	/* CogARMCompiler>>#inverseOpcodeFor: */
static NoDbgRegParms sqInt
inverseOpcodeFor(AbstractInstruction *self_in_CogARMCompiler, sqInt armOpcode)
{
	switch (armOpcode) {
	case AddOpcode:
		return SubOpcode;

	case AndOpcode:
		return BicOpcode;

	case BicOpcode:
		return AndOpcode;

	case CmpOpcode:
		return CmpNotOpcode;

	case MoveOpcode:
		return MoveNotOpcode;

	case MoveNotOpcode:
		return MoveOpcode;

	case SubOpcode:
		return AddOpcode;

	default:
		error("opcode has no inverse");
		return -1;
	}
	return 0;
}


/*	Assuming mcpc is a send return pc answer if the instruction before it is a
	call (not a CallFull).
 */
/*	There are two types of calls: BL and/BLX encoding */

	/* CogARMCompiler>>#isCallPrecedingReturnPC: */
static NoDbgRegParms sqInt
isCallPrecedingReturnPC(AbstractInstruction *self_in_CogARMCompiler, sqInt mcpc)
{
    sqInt call;

	call = longAt(mcpc - 4);
	return (instructionIsBL(self_in_CogARMCompiler, call))
	 || (instructionIsBLX(self_in_CogARMCompiler, call));
}


/*	ARM calls and jumps span +/- 32 mb, more than enough for intra-zone calls
	and jumps.
 */

	/* CogARMCompiler>>#isInImmediateJumpRange: */
static NoDbgRegParms int
isInImmediateJumpRange(AbstractInstruction *self_in_CogARMCompiler, usqIntptr_t operand)
{
	return (((((int) operand)) >= -33554432) && ((((int) operand)) <= 0x1FFFFFC));
}

	/* CogARMCompiler>>#isJumpAt: */
static NoDbgRegParms sqInt
isJumpAt(AbstractInstruction *self_in_CogARMCompiler, sqInt pc)
{
    int instr;

	instr = long32At(pc);
	return (instructionIsB(self_in_CogARMCompiler, instr))
	 || (instructionIsBX(self_in_CogARMCompiler, instr));
}


/*	add xx, pc, blah or sub xx, pc, blah */

	/* CogARMCompiler>>#isPCRelativeValueLoad: */
static NoDbgRegParms sqInt
isPCRelativeValueLoad(AbstractInstruction *self_in_CogARMCompiler, unsigned int instr)
{
	return (((instr) >> 16) == 57999)
	 || (((instr) >> 16) == 57935);
}


/*	Answer if an address can be reached by a normal Call insruction.
	We assume this is true for 32-bit processors and expect 64-bit processors
	to answer false
	for values in the object memory, and perhaps true in the interpreter. */

	/* CogARMCompiler>>#isWithinCallRange: */
static NoDbgRegParms int
isWithinCallRange(AbstractInstruction *self_in_CogARMCompiler, sqInt anAddress)
{
	return isInImmediateJumpRange(self_in_CogARMCompiler, maximumDistanceFromCodeZone(anAddress));
}


/*	Branch/Call ranges. Jump[Cond] can be generated as short as possible.
	Call/Jump[Cond]Long must be generated
	in the same number of bytes irrespective of displacement since their
	targets may be updated, but they need only
	span 16Mb, the maximum size of the code zone. This allows e.g. ARM to use
	single-word call and jump instructions
	for most calls and jumps. CallFull/JumpFull must also be generated in the
	same number of bytes irrespective of
	displacement for the same reason, but they must be able to span the full
	(32-bit or 64-bit) address space because
	they are used to call code in the C runtime, which may be distant from the
	code zone
 */

	/* CogARMCompiler>>#jumpLongByteSize */
static NoDbgRegParms sqInt
jumpLongByteSize(AbstractInstruction *self_in_CogARMCompiler)
{
	return 4;
}

	/* CogARMCompiler>>#jumpLongConditionalByteSize */
static NoDbgRegParms sqInt
jumpLongConditionalByteSize(AbstractInstruction *self_in_CogARMCompiler)
{
	return jumpLongByteSize(self_in_CogARMCompiler);
}


/*	Answer the target address for the long jump immediately preceding mcpc */

	/* CogARMCompiler>>#jumpLongTargetBeforeFollowingAddress: */
static NoDbgRegParms sqInt
jumpLongTargetBeforeFollowingAddress(AbstractInstruction *self_in_CogARMCompiler, sqInt mcpc)
{
	return callTargetFromReturnAddress(self_in_CogARMCompiler, mcpc);
}

	/* CogARMCompiler>>#jumpTargetPCAt: */
static NoDbgRegParms usqInt
jumpTargetPCAt(AbstractInstruction *self_in_CogARMCompiler, sqInt pc)
{
    int operand;
    int word;

	word = long32At(pc);
	operand = word & 0xFFFFFF;
	if (((operand & 0x800000) != 0)) {
		operand -= 0x1000000;
	}
	return ((operand * 4) + pc) + 8;
}


/*	LDRB destReg, [baseReg, 'u' immediate12bitValue] u=0 -> - ARM_ARM v7
	DDI10406 pp. A8-128-9
	Note that this is a very low level interface that does not check the sign
	of the immediate, nor validity. See for example #concretizeMoveMbrR */

	/* CogARMCompiler>>#ldrb:rn:plus:imm: */
static NoDbgRegParms sqInt
ldrbrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue)
{
	return memMxrregbaseublimm(self_in_CogARMCompiler, AL, destReg, baseReg, u, 1, 1, immediate12bitValue);
}


/*	LDRB destReg, [baseReg, + offsetReg] - ARM_ARM v7 DDI10406 pp. A8-132-3
	The contents of offsetReg are assumed to be correctly signed */

	/* CogARMCompiler>>#ldrb:rn:rm: */
static NoDbgRegParms sqInt
ldrbrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt offsetReg)
{
	return memMxrregbasepubwlrm(self_in_CogARMCompiler, AL, destReg, baseReg, 1, 1, 1, 0, 1, offsetReg);
}


/*	LDRH destReg, [baseReg, 'u' immediate8bitValue] u=0 -> subtract imm; =1 ->
	add imm - ARM_ARM v7 DDI10406 pp. A8-152-3 */

	/* CogARMCompiler>>#ldrh:rn:plus:imm: */
static NoDbgRegParms sqInt
ldrhrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate8bitValue)
{
	return memM16xrregbasepuwloffset(self_in_CogARMCompiler, AL, destReg, baseReg, 1, u, 0, 1, immediate8bitValue);
}


/*	LDRH destReg, [baseReg, +offsetReg] - ARM_ARM v7 DDI10406 pp. A8-156-7
	The contents of offsetReg are assumed to be correctly signed */

	/* CogARMCompiler>>#ldrh:rn:rm: */
static NoDbgRegParms sqInt
ldrhrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt offsetReg)
{
	return memM16xrregbasepuwlrm(self_in_CogARMCompiler, AL, destReg, baseReg, 1, 1, 0, 1, offsetReg);
}


/*	LDR destReg, [baseReg, +immediate12bitValue] - ARM_ARM v7 DDI10406 pp.
	A8-120-1 
 */

	/* CogARMCompiler>>#ldr:rn:plusImm: */
static NoDbgRegParms sqInt
ldrrnplusImm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt immediate12bitValue)
{
	return memMxrregbaseublimm(self_in_CogARMCompiler, AL, destReg, baseReg, 1, 0, 1, immediate12bitValue);
}


/*	LDR destReg, [baseReg, immediate12bitValue] u=0 -> subtract imm; =1 -> add
	imm - ARM_ARM v7 DDI10406 pp. A8-120-1 */

	/* CogARMCompiler>>#ldr:rn:plus:imm: */
static NoDbgRegParms sqInt
ldrrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue)
{
	return memMxrregbaseublimm(self_in_CogARMCompiler, AL, destReg, baseReg, u, 0, 1, immediate12bitValue);
}


/*	LDR destReg, [baseReg, + offsetReg] - ARM_ARM v7 DDI10406 pp. A8-124-5
	The contents of offsetReg are assumed to be correctly signed */

	/* CogARMCompiler>>#ldr:rn:rm: */
static NoDbgRegParms sqInt
ldrrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt offsetReg)
{
	return memMxrregbasepubwlrm(self_in_CogARMCompiler, AL, destReg, baseReg, 1, 1, 0, 0, 1, offsetReg);
}


/*	Load the operand into the destination register, answering
	the size of the instructions generated to do so. */

	/* CogARMCompiler>>#loadCwInto: */
static NoDbgRegParms sqInt
loadCwInto(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg)
{
    sqInt aWord;
    sqInt aWord1;
    sqInt distance;
    sqInt i;
    sqInt immediate;
    unsigned int immediate1;
    sqInt negate;
    int negate1;
    int negate2;
    usqInt operand;
    sqInt rot;
    sqInt rot1;
    sqInt value;

	immediate = 0;
	negate = 0;
	rot = 0;
	operand = ((self_in_CogARMCompiler->operands))[0];
	if (	/* begin isAnInstruction: */
		(addressIsInInstructions(((AbstractInstruction *) operand)))
	 || ((((AbstractInstruction *) operand)) == (methodLabel()))) {
		operand = ((((AbstractInstruction *) operand))->address);
	}
	if (	/* begin addressIsInCurrentCompilation: */
		((((usqInt)operand)) >= ((methodLabel->address)))
	 && ((((usqInt)operand)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))) {
		distance = operand - (((self_in_CogARMCompiler->address)) + 8);
		/* begin rotateable8bitSignedImmediate:ifTrue:ifFalse: */
		value = distance;
		while (1) {
			if ((value & 0xFF) == value) {
				negate1 = distance != value;
				aWord = (negate1
					? subrnimmror(self_in_CogARMCompiler, destReg, PC, value, 0)
					: addrnimmror(self_in_CogARMCompiler, destReg, PC, value, 0));
				/* begin machineCodeAt:put: */
				((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord;
				return 4;
				goto l2;
			}
			for (i = 2; i <= 30; i += 2) {
				if ((value & (((0xFFU << i) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i)))) == value) {
					rot1 = 32 - i;
					immediate1 = (((usqInt)(value)) >> i) | ((((sqInt)((usqInt)(value) << (32 - i)))) & 0xFFFFFFFFU);
					negate2 = distance != value;
					aWord = (negate2
						? subrnimmror(self_in_CogARMCompiler, destReg, PC, immediate1, rot1)
						: addrnimmror(self_in_CogARMCompiler, destReg, PC, immediate1, rot1));
					/* begin machineCodeAt:put: */
					((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord;
					return 4;
					goto l2;
				}
			}
			if (!((value == distance)
			 && (distance != 0))) break;
			value = -distance;
		}
		assert(!((isAnInstruction(self_in_CogARMCompiler, ((AbstractInstruction *) (((self_in_CogARMCompiler->operands))[0]))))));
	l2:	/* end rotateable8bitSignedImmediate:ifTrue:ifFalse: */;
	}
	/* begin moveCw:intoR: */
	assert(addressIsInCurrentCompilation((((self_in_CogARMCompiler->dependent))->address)));
	assert((SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8)))) < (0x1000));
	aWord1 = ldrrnplusimm(self_in_CogARMCompiler, destReg, PC, (((((self_in_CogARMCompiler->dependent))->address)) >= (((self_in_CogARMCompiler->address)) + 8)
		? 1
		: 0), SQABS((((((self_in_CogARMCompiler->dependent))->address)) - (((self_in_CogARMCompiler->address)) + 8))));
	/* begin machineCodeAt:put: */
	((self_in_CogARMCompiler->machineCode))[0 / 4] = aWord1;
	return 4;
}


/*	Answer the byte size of a MoveCwR opcode's corresponding machine code
	when the argument is a PIC. This is for the self-reference at the end of a
	closed PIC. On ARM this is a single instruction pc-relative register load. */

	/* CogARMCompiler>>#loadPICLiteralByteSize */
static NoDbgRegParms sqInt
loadPICLiteralByteSize(AbstractInstruction *self_in_CogARMCompiler)
{
	return 4;
}

	/* CogARMCompiler>>#machineCodeWords */
static NoDbgRegParms sqInt
machineCodeWords(AbstractInstruction *self_in_CogARMCompiler)
{
	return (machineCodeBytes(self_in_CogARMCompiler)) / 4;
}


/*	build an ARM [base +/- offset8] half-word memory instruction
	p -> pre-index (1) or post-index (0) the offset. Combines with W to do
	some odd things.
	u -> up (1) or down (0) ie + or - for the offset
	b -> byte(1) or word (0)
	w -> write-back (1) if pre-indexing. 
	l -> load (1) or store (0) */

	/* CogARMCompiler>>#memM16xr:reg:base:p:u:w:l:offset: */
static NoDbgRegParms sqInt
memM16xrregbasepuwloffset(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt weirdstuff, sqInt loadstore, sqInt offset8)
{
	return (((sqInt)((usqInt)(cond) << 28))) | ((0) | ((((sqInt)((usqInt)(postpreoffset) << 24))) | ((((sqInt)((usqInt)(updown) << 23))) | ((0x400000) | ((((sqInt)((usqInt)(weirdstuff) << 21))) | ((((sqInt)((usqInt)(loadstore) << 20))) | ((((sqInt)((usqInt)(baseReg) << 16))) | ((((sqInt)((usqInt)(destReg) << 12))) | ((((sqInt)((usqInt)((offset8 & 240)) << 4))) | ((176) | (offset8 & 15)))))))))));
}


/*	build an ARM [base +/- offsetReg] memory instruction
	p -> pre-index (1) or post-index (0) the offset. Combines with W to do
	some odd things.
	u -> up (1) or down (0) ie + or - for the offset
	b -> byte(1) or word (0)
	w -> write-back (1) if pre-indexing. 
	l -> load (1) or store (0)
 */

	/* CogARMCompiler>>#memM16xr:reg:base:p:u:w:l:rm: */
static NoDbgRegParms sqInt
memM16xrregbasepuwlrm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt weirdstuff, sqInt loadstore, sqInt offsetReg)
{
	return (((sqInt)((usqInt)(cond) << 28))) | ((0) | ((((sqInt)((usqInt)(postpreoffset) << 24))) | ((((sqInt)((usqInt)(updown) << 23))) | ((0) | ((((sqInt)((usqInt)(weirdstuff) << 21))) | ((((sqInt)((usqInt)(loadstore) << 20))) | ((((sqInt)((usqInt)(baseReg) << 16))) | ((((sqInt)((usqInt)(destReg) << 12))) | (176 | offsetReg)))))))));
}


/*	build an ARM [base +/- offset] memory instruction
	p -> pre-index (1) or post-index (0) the offset. Combines with W to do
	some odd things.
	u -> up (1) or down (0) ie + or - for the offset
	b -> byte(1) or word (0)
	w -> write-back (1) if pre-indexing. 
	l -> load (1) or store (0)
 */

	/* CogARMCompiler>>#memMxr:reg:base:p:u:b:w:l:imm: */
static NoDbgRegParms sqInt
memMxrregbasepubwlimm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt byteword, sqInt weirdstuff, sqInt loadstore, sqInt offset)
{
	return (((sqInt)((usqInt)(cond) << 28))) | ((0x4000000) | ((((sqInt)((usqInt)(postpreoffset) << 24))) | ((((sqInt)((usqInt)(updown) << 23))) | ((((sqInt)((usqInt)(byteword) << 22))) | ((((sqInt)((usqInt)(weirdstuff) << 21))) | ((((sqInt)((usqInt)(loadstore) << 20))) | ((((sqInt)((usqInt)(baseReg) << 16))) | ((((sqInt)((usqInt)(destReg) << 12))) | offset))))))));
}


/*	build an ARM [base +/- offsetReg lsl #2] memory instruction - see also
	#memMxr:reg:base:p:u:b:w:l:rm: and keep them correlated properly
	p -> pre-index (1) or post-index (0) the offset. Combines with W to do
	some odd things.
	u -> up (1) or down (0) ie + or - for the offset
	b -> byte(1) or word (0)
	w -> write-back (1) if pre-indexing. 
	l -> load (1) or store (0)
 */

	/* CogARMCompiler>>#memMxr:reg:base:p:u:b:w:l:rmLsl2: */
static NoDbgRegParms sqInt
memMxrregbasepubwlrmLsl2(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt byteword, sqInt weirdstuff, sqInt loadstore, sqInt offsetReg)
{
	return (((sqInt)((usqInt)((cond & 15)) << 28))) | ((0x6000000) | ((((sqInt)((usqInt)((postpreoffset & 1)) << 24))) | ((((sqInt)((usqInt)((updown & 1)) << 23))) | ((((sqInt)((usqInt)((byteword & 1)) << 22))) | ((((sqInt)((usqInt)((weirdstuff & 1)) << 21))) | ((((sqInt)((usqInt)((loadstore & 1)) << 20))) | ((((sqInt)((usqInt)((baseReg & 15)) << 16))) | ((((sqInt)((usqInt)((destReg & 15)) << 12))) | (0x100 | (offsetReg & 15))))))))));
}


/*	build an ARM [base +/- offsetReg] memory instruction
	p -> pre-index (1) or post-index (0) the offset. Combines with W to do
	some odd things.
	u -> up (1) or down (0) ie + or - for the offset
	b -> byte(1) or word (0)
	w -> write-back (1) if pre-indexing. 
	l -> load (1) or store (0)
 */

	/* CogARMCompiler>>#memMxr:reg:base:p:u:b:w:l:rm: */
static NoDbgRegParms sqInt
memMxrregbasepubwlrm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt postpreoffset, sqInt updown, sqInt byteword, sqInt weirdstuff, sqInt loadstore, sqInt offsetReg)
{
	return (((sqInt)((usqInt)((cond & 15)) << 28))) | ((0x6000000) | ((((sqInt)((usqInt)((postpreoffset & 1)) << 24))) | ((((sqInt)((usqInt)((updown & 1)) << 23))) | ((((sqInt)((usqInt)((byteword & 1)) << 22))) | ((((sqInt)((usqInt)((weirdstuff & 1)) << 21))) | ((((sqInt)((usqInt)((loadstore & 1)) << 20))) | ((((sqInt)((usqInt)((baseReg & 15)) << 16))) | ((((sqInt)((usqInt)((destReg & 15)) << 12))) | (offsetReg & 15)))))))));
}


/*	This is the lowest level build of an ARM [base +/- immediate 12bit offset]
	memory instruction
	u -> up (1) or down (0) ie + or - for the offset
	b -> byte(1) or word (0)
	l -> load (1) or store (0)
 */

	/* CogARMCompiler>>#memMxr:reg:base:u:b:l:imm: */
static NoDbgRegParms sqInt
memMxrregbaseublimm(AbstractInstruction *self_in_CogARMCompiler, sqInt cond, sqInt destReg, sqInt baseReg, sqInt updown, sqInt byteword, sqInt loadstore, sqInt immediate12bitValue)
{
	return (((sqInt)((usqInt)((cond & 15)) << 28))) | ((0x5000000) | ((((sqInt)((usqInt)((updown & 1)) << 23))) | ((((sqInt)((usqInt)((byteword & 1)) << 22))) | ((((sqInt)((usqInt)((loadstore & 1)) << 20))) | ((((sqInt)((usqInt)((baseReg & 15)) << 16))) | ((((sqInt)((usqInt)((destReg & 15)) << 12))) | (immediate12bitValue & 0xFFF)))))));
}


/*	MOVS destReg, srcReg - ARM_ARM v7 DDI10406 pp. A8-196-7 */

	/* CogARMCompiler>>#movs:rn: */
static NoDbgRegParms sqInt
movsrn(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0x100000)))) | ((0) | (((sqInt)((usqInt)(destReg) << 12))))) | (srcReg & 0xFFF);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc.
	MOV destReg, #immediate8BitValue ROR rot - ARM_ARM v7 DDI10406 pp.
	A8-194-5 
 */

	/* CogARMCompiler>>#mov:imm:ror: */
static NoDbgRegParms sqInt
movimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt immediate8bitValue, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0)))) | ((0) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate8bitValue) & 0xFFF);
}


/*	MOV destReg, srcReg - ARM_ARM v7 DDI10406 pp. A8-196-7 */

	/* CogARMCompiler>>#mov:rn: */
static NoDbgRegParms sqInt
movrn(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0) | ((((int)((usqInt)(MoveOpcode) << 21))) | (0)))) | ((0) | (((sqInt)((usqInt)(destReg) << 12))))) | (srcReg & 0xFFF);
}


/*	Generate an MSR CPSR_f, #flags instruction.
	Note that 
	a) CPSR_f is equivalent to APSR_nzcvq (ARM ARM DDI0406A p A8-209 & A2-14)
	b) We only have business with the NZCV flags so the generated instruction
	shifts the flags value <<28 - which is a ROR 4
 */

	/* CogARMCompiler>>#msr: */
static NoDbgRegParms int
msr(AbstractInstruction *self_in_CogARMCompiler, sqInt flags)
{
	return (321450496) + (flags & 15);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc.
	MVN destReg, #immediate8BitValue ROR rot - ARM_ARM v7 DDI10406 pp.
	A8-214-5 
 */

	/* CogARMCompiler>>#mvn:imm:ror: */
static NoDbgRegParms sqInt
mvnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt immediate8bitValue, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(MoveNotOpcode) << 21))) | (0)))) | ((0) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate8bitValue) & 0xFFF);
}

	/* CogARMCompiler>>#numIntRegArgs */
static NoDbgRegParms sqInt
numIntRegArgs(AbstractInstruction *self_in_CogARMCompiler)
{
	return 4;
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc.
	ORR destReg, #immediate8BitValue ROR rot - ARM_ARM v7 DDI10406 pp.
	A8-228-9 
 */

	/* CogARMCompiler>>#orr:imm:ror: */
static NoDbgRegParms sqInt
orrimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt immediate8bitValue, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(OrOpcode) << 21))) | (0)))) | ((((sqInt)((usqInt)(destReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate8bitValue) & 0xFFF);
}

	/* CogARMCompiler>>#padIfPossibleWithStopsFrom:to: */
static NoDbgRegParms AbstractInstruction *
padIfPossibleWithStopsFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt startAddr, sqInt endAddr)
{
    sqInt nullBytes;
    sqInt p;

	nullBytes = ((endAddr - startAddr) + 1) % 4;
	stopsFromto(self_in_CogARMCompiler, startAddr, endAddr - nullBytes);
	for (p = ((endAddr - nullBytes) + 1); p <= endAddr; p += 1) {
		codeByteAtput(p, 0xFF);
	}
	return self_in_CogARMCompiler;
}


/*	pop word off TOS
	LDR srcReg, [sp] #4 - ARM_ARM v7 DDI10406 pp. A8-120-1 */

	/* CogARMCompiler>>#popR: */
static NoDbgRegParms sqInt
popR(AbstractInstruction *self_in_CogARMCompiler, sqInt dstReg)
{
	return memMxrregbasepubwlimm(self_in_CogARMCompiler, AL, dstReg, SP, 0, 1, 0, 0, 1, 4);
}

	/* CogARMCompiler>>#pushLinkRegisterByteSize */
static NoDbgRegParms sqInt
pushLinkRegisterByteSize(AbstractInstruction *self_in_CogARMCompiler)
{
	return 4;
}


/*	push word to TOS 
	STR srcReg, [sp, #-4]! - ARM_ARM v7 DDI10406 pp. A8-382-3 */

	/* CogARMCompiler>>#pushR: */
static NoDbgRegParms sqInt
pushR(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg)
{
	return memMxrregbasepubwlimm(self_in_CogARMCompiler, AL, srcReg, SP, 1, 0, 0, 1, 0, 4);
}

	/* CogARMCompiler>>#relocateCallBeforeReturnPC:by: */
static NoDbgRegParms AbstractInstruction *
relocateCallBeforeReturnPCby(AbstractInstruction *self_in_CogARMCompiler, sqInt retpc, sqInt delta)
{
    sqInt distanceDiv4;
    sqInt instr;

	assert((delta % 4) == 0);
	if (delta != 0) {
		instr = longAt(retpc - 4);
		assert((instructionIsB(self_in_CogARMCompiler, instr))
		 || (instructionIsBL(self_in_CogARMCompiler, instr)));
		distanceDiv4 = instr & 0xFFFFFF;
		distanceDiv4 += delta / 4;
		longAtput(retpc - 4, (instr & 0xFF000000U) | (distanceDiv4 & 0xFFFFFF));
	}
	return self_in_CogARMCompiler;
}


/*	Rewrite a call instruction to call a different target. This variant is
	used to link PICs
	in ceSendMiss et al,. 
	Answer the extent of the code change which is used to compute the range of
	the icache to flush. */

	/* CogARMCompiler>>#rewriteCallAt:target: */
static NoDbgRegParms sqInt
rewriteCallAttarget(AbstractInstruction *self_in_CogARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress)
{
	return rewriteTransferAttarget(self_in_CogARMCompiler, callSiteReturnAddress, callTargetAddress);
}


/*	Rewrite a callFull instruction to jump to a different target. This variant
	is used to rewrite cached primitive calls where we load the target address
	into ip
	and use the 'blx ip' instruction for the actual call.
	Answer the extent of the
	code change which is used to compute the range of the icache to flush. */

	/* CogARMCompiler>>#rewriteCallFullAt:target: */
static NoDbgRegParms sqInt
rewriteCallFullAttarget(AbstractInstruction *self_in_CogARMCompiler, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteFullTransferAttargetexpectedInstruction(self_in_CogARMCompiler, callSiteReturnAddress, callTargetAddress, 0xE12FFF3CU);
}


/*	Rewrite a full jump instruction to jump to a different target. This
	variant is used to rewrite cached primitive calls where we load the target
	address into ip
	and use the 'bx ip' instruction for the actual jump.
	Answer the extent of the
	code change which is used to compute the range of the icache to flush. */

	/* CogARMCompiler>>#rewriteJumpFullAt:target: */
static NoDbgRegParms sqInt
rewriteJumpFullAttarget(AbstractInstruction *self_in_CogARMCompiler, sqInt callSiteReturnAddress, sqInt callTargetAddress)
{
	return rewriteFullTransferAttargetexpectedInstruction(self_in_CogARMCompiler, callSiteReturnAddress, callTargetAddress, 3778019100U);
}


/*	Rewrite a jump instruction to call a different target. This variant is
	used to reset the 
	jumps in the prototype CPIC to suit each use,. 
	Answer the extent of the code change which is used to compute the range of
	the icache to flush. */

	/* CogARMCompiler>>#rewriteJumpLongAt:target: */
static NoDbgRegParms sqInt
rewriteJumpLongAttarget(AbstractInstruction *self_in_CogARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress)
{
	return rewriteTransferAttarget(self_in_CogARMCompiler, callSiteReturnAddress, callTargetAddress);
}


/*	Rewrite a call/jump instruction to call a different target. This variant
	is used to link PICs
	in ceSendMiss et al, and to rewrite call/jumps in CPICs.
	Answer the extent of
	the code change which is used to compute the range of the icache to flush. */
/*	for debug - [cogit disassembleFrom: callSiteReturnAddress - 10 to:
	callSiteReturnAddress - 1].
 */

	/* CogARMCompiler>>#rewriteTransferAt:target: */
static NoDbgRegParms sqInt
rewriteTransferAttarget(AbstractInstruction *self_in_CogARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress)
{
    usqInt callDistance;
    sqInt instr;


	/* pc offset */
	/* return offset */
	callDistance = ((usqInt) (callTargetAddress - ((callSiteReturnAddress + 8) - 4)));
	assert(isInImmediateJumpRange(self_in_CogARMCompiler, callDistance));
	instr = longAt(callSiteReturnAddress - 4);
	assert((instructionIsB(self_in_CogARMCompiler, instr))
	 || (instructionIsBL(self_in_CogARMCompiler, instr)));
	longAtput(callSiteReturnAddress - 4, (instr & 0xFF000000U) | ((callDistance / 4) & 0xFFFFFF));
	assert((callTargetFromReturnAddress(self_in_CogARMCompiler, callSiteReturnAddress)) == callTargetAddress);
	return 4;
}


/*	to save Slang from having to be a real compiler (it can't inline switches
	that return)
 */
/*	Answer if the receiver's opcode sets the condition codes correctly for the
	given conditional jump opcode.
	ARM has to check carefully since the V flag is not affected by
	non-comparison instructions
 */

	/* CogARMCompiler>>#setsConditionCodesFor: */
static NoDbgRegParms sqInt
setsConditionCodesFor(AbstractInstruction *self_in_CogARMCompiler, sqInt aConditionalJumpOpcode)
{
	switch ((self_in_CogARMCompiler->opcode)) {
	case ArithmeticShiftRightCqR:
	case ArithmeticShiftRightRR:
	case LogicalShiftLeftCqR:
	case LogicalShiftLeftRR:
		return shiftSetsConditionCodesFor(self_in_CogARMCompiler, aConditionalJumpOpcode);

	case XorRR:
		return 1;

	case ClzRR:
		return 0;

	default:
		haltmsg("unhandled opcode in setsConditionCodesFor:");
		return 0;
	}
	return 0;
}


/*	check what flags the opcode needs setting - ARM doesn't set V when simply
	MOVing 
 */

	/* CogARMCompiler>>#shiftSetsConditionCodesFor: */
static NoDbgRegParms sqInt
shiftSetsConditionCodesFor(AbstractInstruction *self_in_CogARMCompiler, sqInt aConditionalJumpOpcode)
{
	switch (aConditionalJumpOpcode) {
	case JumpNegative:
	case JumpZero:
	case JumpLess:
		return 1;

	default:
		haltmsg("unhandled opcode in setsConditionCodesFor:");
		return 0;
	}
	return 0;
}


/*	Return a minimum amount of headroom for each stack page (in bytes). In a
	JIT the stack has to have room for interrupt handlers which will run on
	the stack.
	According to ARM architecture v5 reference manual chapter A2.6, the basic
	interrupt procedure does not push anything onto the stack. It uses
	SPSR_err and R14_err to preserve state. Afterwards, it calls an interrupt
	procedure. So leave some room.
 */

	/* CogARMCompiler>>#stackPageInterruptHeadroomBytes */
static NoDbgRegParms sqInt
stackPageInterruptHeadroomBytes(AbstractInstruction *self_in_CogARMCompiler)
{
	return 128;
}

	/* CogARMCompiler>>#stopsFrom:to: */
static NoDbgRegParms AbstractInstruction *
stopsFromto(AbstractInstruction *self_in_CogARMCompiler, sqInt startAddr, sqInt endAddr)
{
    sqInt addr;

	assert((((endAddr - startAddr) + 1) % 4) == 0);
	for (addr = startAddr; addr <= endAddr; addr += 4) {
		codeLongAtput(addr, (((int)((usqInt)(AL) << 28))) | ((0x1200000) | (112)));
	}
	return self_in_CogARMCompiler;
}


/*	STRB destReg, [baseReg, 'u' immediate12bitValue] u=0 -> subtract imm; =1
	-> add imm - ARM_ARM v7 DDI10406 pp. A8-388-9 */

	/* CogARMCompiler>>#strb:rn:plus:imm: */
static NoDbgRegParms sqInt
strbrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue)
{
	return memMxrregbaseublimm(self_in_CogARMCompiler, AL, destReg, baseReg, u, 1, 0, immediate12bitValue);
}


/*	STRB srcReg, [baseReg, + offsetReg] - ARM_ARM v7 DDI10406 pp. A8-390-1
	The contents of offsetReg are assumed to be correctly signed */

	/* CogARMCompiler>>#strb:rn:rm: */
static NoDbgRegParms sqInt
strbrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt offsetReg)
{
	return memMxrregbasepubwlrm(self_in_CogARMCompiler, AL, srcReg, baseReg, 1, 1, 1, 0, 0, offsetReg);
}


/*	STRH destReg, [baseReg, 'u' immediate8bitValue] u=0 -> subtract imm; =1 ->
	add imm - ARM_ARM v7 DDI10406 pp. A8-408-9 */

	/* CogARMCompiler>>#strh:rn:plus:imm: */
static NoDbgRegParms sqInt
strhrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate8bitValue)
{
	return memM16xrregbasepuwloffset(self_in_CogARMCompiler, AL, destReg, baseReg, 1, u, 0, 0, immediate8bitValue);
}


/*	STRH srcReg, [baseReg, +offsetReg] - ARM_ARM v7 DDI10406 pp. A8-410-1 */

	/* CogARMCompiler>>#strh:rn:rm: */
static NoDbgRegParms sqInt
strhrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt offsetReg)
{
	return memM16xrregbasepuwlrm(self_in_CogARMCompiler, AL, srcReg, baseReg, 1, 1, 0, 0, offsetReg);
}


/*	STR srcReg, [baseReg, +immediate12bitValue] - ARM_ARM v7 DDI10406 pp.
	A8-382-3 
 */

	/* CogARMCompiler>>#str:rn:plusImm: */
static NoDbgRegParms sqInt
strrnplusImm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt immediate12bitValue)
{
	return memMxrregbaseublimm(self_in_CogARMCompiler, AL, srcReg, baseReg, 1, 0, 0, immediate12bitValue);
}


/*	STR destReg, [baseReg, 'u' immediate12bitValue] u=0 -> subtract imm; =1 ->
	add imm - ARM_ARM v7 DDI10406 pp. A8-382-3 */

	/* CogARMCompiler>>#str:rn:plus:imm: */
static NoDbgRegParms sqInt
strrnplusimm(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt baseReg, sqInt u, sqInt immediate12bitValue)
{
	return memMxrregbaseublimm(self_in_CogARMCompiler, AL, destReg, baseReg, u, 0, 0, immediate12bitValue);
}


/*	STR srcReg, [baseReg, + offsetReg] - ARM_ARM v7 DDI10406 pp. A8-384-5
	The contents of offsetReg are assumed to be correctly signed */

	/* CogARMCompiler>>#str:rn:rm: */
static NoDbgRegParms sqInt
strrnrm(AbstractInstruction *self_in_CogARMCompiler, sqInt srcReg, sqInt baseReg, sqInt offsetReg)
{
	return memMxrregbasepubwlrm(self_in_CogARMCompiler, AL, srcReg, baseReg, 1, 1, 0, 0, 0, offsetReg);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc
	SUBS destReg, srcReg, #immediate ROR rot - ARM_ARM v7 DDI10406 pp.
	A8-418-9 
 */

	/* CogARMCompiler>>#subs:rn:imm:ror: */
static NoDbgRegParms sqInt
subsrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(SubOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc
	SUB destReg, srcReg, #immediate ROR rot - ARM_ARM v7 DDI10406 pp. A8-418-9 */

	/* CogARMCompiler>>#sub:rn:imm:ror: */
static NoDbgRegParms sqInt
subrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt destReg, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(SubOpcode) << 21))) | (0)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (((sqInt)((usqInt)(destReg) << 12))))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	Remember the ROR is doubled by the cpu so use 30>>1 etc */
/*	also note that TST has no destReg
	TST srcReg, #immediate ROR rot - ARM_ARM v7 DDI10406 pp. A8-452-3 */

	/* CogARMCompiler>>#tst:rn:imm:ror: */
static NoDbgRegParms sqInt
tstrnimmror(AbstractInstruction *self_in_CogARMCompiler, sqInt ignored, sqInt srcReg, sqInt immediate, sqInt rot)
{
	return (((((int)((usqInt)(AL) << 28))) | ((0x2000000) | ((((int)((usqInt)(TstOpcode) << 21))) | (0x100000)))) | ((((sqInt)((usqInt)(srcReg) << 16))) | (0))) | (((((sqInt)((usqInt)((((usqInt)(rot)) >> 1)) << 8))) | immediate) & 0xFFF);
}


/*	Answer if Call and JumpLong are relative and hence need to take the
	caller's relocation delta into account during code compaction, rather than
	just the
	callee's delta. */

	/* CogARMCompiler>>#zoneCallsAreRelative */
static NoDbgRegParms sqInt
zoneCallsAreRelative(AbstractInstruction *self_in_CogARMCompiler)
{
	return 1;
}

	/* CogBlockMethod>>#cmHomeMethod */
static NoDbgRegParms CogMethod *
cmHomeMethod(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((CogMethod *) ((((usqInt)self_in_CogBlockMethod)) - ((self_in_CogBlockMethod->homeOffset))));
}

	/* CogBlockMethod>>#isCMBlock */
static NoDbgRegParms int
isCMBlock(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMBlock;
}

	/* CogBlockMethod>>#isCMClosedPIC */
static NoDbgRegParms int
isCMClosedPIC(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMClosedPIC;
}

	/* CogBlockMethod>>#isCMFree */
static NoDbgRegParms int
isCMFree(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMFree;
}

	/* CogBlockMethod>>#isCMMethodEtAl */
static NoDbgRegParms int
isCMMethodEtAl(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) >= CMMethod;
}

	/* CogBlockMethod>>#isCMOpenPIC */
static NoDbgRegParms int
isCMOpenPIC(CogBlockMethod *self_in_CogBlockMethod)
{
	return ((self_in_CogBlockMethod->cmType)) == CMOpenPIC;
}

	/* CogBytecodeDescriptor>>#isBranch */
static NoDbgRegParms sqInt
isBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor)
{
	return (((self_in_CogBytecodeDescriptor->spanFunction)))
	 && (!((self_in_CogBytecodeDescriptor->isBlockCreation)));
}

	/* CogBytecodeDescriptor>>#isConditionalBranch */
static NoDbgRegParms sqInt
isConditionalBranch(BytecodeDescriptor *self_in_CogBytecodeDescriptor)
{
	return ((self_in_CogBytecodeDescriptor->isBranchTrue))
	 || ((self_in_CogBytecodeDescriptor->isBranchFalse));
}

	/* CogBytecodeFixup>>#notAFixup */
static NoDbgRegParms int
notAFixup(BytecodeFixup *self_in_CogBytecodeFixup)
{
	return ((self_in_CogBytecodeFixup->targetInstruction)) == 0;
}


/*	destReg := addendReg + badendReg */

	/* Cogit>>#AddR:R:R: */
static NoDbgRegParms AbstractInstruction *
gAddRRR(sqInt addendReg, sqInt badendReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(AddRRR, addendReg, badendReg, destReg);
	assert(badendReg != destReg);
	first = genoperandoperand(MoveRR, addendReg, destReg);
	genoperandoperand(AddRR, badendReg, destReg);
	return first;
}

	/* Cogit>>#AndCq:R: */
static NoDbgRegParms AbstractInstruction *
gAndCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;


	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(AndCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	return anInstruction;
}


/*	destReg := (signed)srcReg >> quickConstant */

	/* Cogit>>#ArithmeticShiftRightCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gArithmeticShiftRightCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(ArithmeticShiftRightCqRR, quickConstant, srcReg, destReg);
	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(ArithmeticShiftRightCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#abortOffset */
sqInt
abortOffset(void)
{
	return missOffset;
}

	/* Cogit>>#addCleanBlockStarts */
static void
addCleanBlockStarts(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt lit;
    sqInt startPCOrNil;

	for (i = 1, iLimiT = (literalCountOf(methodObj)); i <= iLimiT; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (!(startPCOrNil == null)) {
			maxLitIndex = ((maxLitIndex < i) ? i : maxLitIndex);
			addBlockStartAtnumArgsnumCopiedspan(startPCOrNil - 1, argumentCountOfClosure(lit), copiedValueCountOfClosure(lit), spanForCleanBlockStartingAt(startPCOrNil - 1));
		}
	}
}


/*	Perform an integrity/leak check using the heapMap.
	Set a bit at each cog method's header. */

	/* Cogit>>#addCogMethodsToHeapMap */
void
addCogMethodsToHeapMap(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			heapMapAtWordPut(cogMethod, 1);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#addressIsInCurrentCompilation: */
static NoDbgRegParms sqInt
addressIsInCurrentCompilation(sqInt address)
{
	return ((((usqInt)address)) >= ((methodLabel->address)))
	 && ((((usqInt)address)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))));
}

	/* Cogit>>#addressIsInFixups: */
static NoDbgRegParms sqInt
addressIsInFixups(BytecodeFixup *address)
{
	return (BytecodeFixup *)address >= fixups && (BytecodeFixup *)address < (fixups + numAbstractOpcodes);
}


/*	calculate the end of the n'th case statement - which is complicated
	because we have case 1 right at the top of our CPIC and then build up from
	the last one. Yes I know this sounds strange, but trust me - I'm an
	Engineer, we do things backwards all the emit
 */

	/* Cogit>>#addressOfEndOfCase:inCPIC: */
static NoDbgRegParms sqInt
addressOfEndOfCaseinCPIC(sqInt n, CogMethod *cPIC)
{
	assert((n >= 1)
	 && (n <= MaxCPICCases));
	return (n == 1
		? (((sqInt)cPIC)) + firstCPICCaseOffset
		: ((((sqInt)cPIC)) + firstCPICCaseOffset) + (((MaxCPICCases + 1) - n) * cPICCaseSize));
}


/*	Align methodZoneBase to that for the start of a method. */

	/* Cogit>>#alignMethodZoneBase */
static void
alignMethodZoneBase(void)
{
    usqInt oldBase;

	oldBase = methodZoneBase;
	methodZoneBase = roundUpToMethodAlignment(backEnd(), methodZoneBase);
	stopsFromto(backEnd, oldBase, methodZoneBase - 1);
}

	/* Cogit>>#alignUptoRoutineBoundary: */
static NoDbgRegParms sqInt
alignUptoRoutineBoundary(sqInt anAddress)
{
	return (((anAddress + 7) | 7) - 7);
}


/*	Check that all methods have valid selectors, and that all linked sends are
	to valid targets and have valid cache tags
 */

	/* Cogit>>#allMachineCodeObjectReferencesValid */
static sqInt
allMachineCodeObjectReferencesValid(void)
{
    CogMethod *cogMethod;
    sqInt ok;

	ok = 1;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (!(asserta(checkValidOopReference((cogMethod->selector))))) {
				ok = 0;
			}
			if (!(asserta((cogMethodDoesntLookKosher(cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if ((((cogMethod->cmType)) >= CMMethod)
		 || (((cogMethod->cmType)) == CMOpenPIC)) {
			if (!(asserta((mapForperformUntilarg(cogMethod, checkIfValidOopRefAndTargetpccogMethod, cogMethod)) == 0))) {
				ok = 0;
			}
		}
		if (((cogMethod->cmType)) == CMClosedPIC) {
			if (!(asserta(noTargetsFreeInClosedPIC(cogMethod)))) {
				ok = 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#allMethodsHaveCorrectHeader */
static sqInt
allMethodsHaveCorrectHeader(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			if (!(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()))) {
				return 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}

	/* Cogit>>#annotateAbsolutePCRef: */
static NoDbgRegParms AbstractInstruction *
annotateAbsolutePCRef(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = IsAbsPCReference);
	return abstractInstruction;
}

	/* Cogit>>#annotateBytecode: */
static NoDbgRegParms AbstractInstruction *
annotateBytecode(AbstractInstruction *abstractInstruction)
{
	(abstractInstruction->annotation = HasBytecodePC);
	return abstractInstruction;
}

	/* Cogit>>#annotate:objRef: */
static NoDbgRegParms AbstractInstruction *
annotateobjRef(AbstractInstruction *abstractInstruction, sqInt anOop)
{
	if (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(anOop))
	 && (oopisGreaterThan(anOop, trueObject()))) {
		setHasMovableLiteral(1);
		if (isYoungObject(anOop)) {
			setHasYoungReferent(1);
		}
		(abstractInstruction->annotation = IsObjectReference);
	}
	return abstractInstruction;
}

	/* Cogit>>#assertSaneJumpTarget: */
static NoDbgRegParms void
assertSaneJumpTarget(AbstractInstruction *jumpTarget)
{
	assert((!closedPICSize)
	 || ((!openPICSize)
	 || ((addressIsInInstructions(jumpTarget))
	 || ((((((usqInt)jumpTarget)) >= codeBase) && ((((usqInt)jumpTarget)) <= ((((sqInt)(limitZony()))) + (((closedPICSize < openPICSize) ? openPICSize : closedPICSize)))))))));
}


/*	Answer an unused abstract register in the registerMask, or NoReg if none. */

	/* Cogit>>#availableRegisterOrNoneIn: */
static NoDbgRegParms sqInt
availableRegisterOrNoneIn(sqInt liveRegsMask)
{
    sqInt reg;

	if (liveRegsMask != 0) {
		for (reg = 0; reg <= 0x1F; reg += 1) {
			if (((liveRegsMask & (1U << reg)) != 0)) {
				return reg;
			}
		}
	}
	return NoReg;
}


/*	Evaluate binaryFunction with the block start mcpc and supplied arg for
	each entry in the block dispatch. If the function answers non-zero answer
	the value
	it answered. Used to update back-references to the home method in
	compaction.  */

	/* Cogit>>#blockDispatchTargetsFor:perform:arg: */
static NoDbgRegParms sqInt
blockDispatchTargetsForperformarg(CogMethod *cogMethod, usqInt (*binaryFunction)(sqInt mcpc, sqInt arg), sqInt arg)
{
    sqInt blockEntry;
    usqInt end;
    sqInt pc;
    sqInt result;
    usqInt targetpc;

	if (((cogMethod->blockEntryOffset)) == 0) {
		return null;
	}
	blockEntry = ((cogMethod->blockEntryOffset)) + (((sqInt)cogMethod));
	pc = blockEntry;
	end = (mapEndFor(cogMethod)) - 1;
	while (pc < end) {
		if (isJumpAt(backEnd, pc)) {
			targetpc = jumpTargetPCAt(backEnd, pc);
			if (targetpc < blockEntry) {
				result = binaryFunction(targetpc, arg);
				if (result != 0) {
					return result;
				}
			}
		}
		pc += instructionSizeAt(backEnd, pc);
	}
	return 0;
}


/*	Answer the zero-relative bytecode pc matching the machine code pc argument
	in cogMethod, given the start of the bytecodes for cogMethod's block or
	method object. */

	/* Cogit>>#bytecodePCFor:startBcpc:in: */
sqInt
bytecodePCForstartBcpcin(sqInt mcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc1;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;


	/* begin mapFor:bcpc:performUntil:arg: */
	latestContinuation = 0;
	assert(((cogMethod->stackCheckOffset)) > 0);
	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc1 = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = findIsBackwardBranchMcpcBcpcMatchingMcpc(null, 0 + (((int)((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc1), startbcpc, ((void *)mcpc));
	if (result != 0) {
		return result;
	}
	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogMethod->cmType)) >= CMMethod) {
		isInBlock = 0 /* begin cmIsFullBlock */;
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}
		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - BlockCreationBytecodeSize;
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
	: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc1 += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((				/* begin isBackwardBranch:at:exts:in: */
					assert(((descriptor->spanFunction))),
				(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = findIsBackwardBranchMcpcBcpcMatchingMcpc(descriptor, (isBackwardBranch
					? (((sqInt)((usqInt)(annotation) << 1))) + 1
					: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc1), (isBackwardBranch
					? bcpc - (2 * nExts)
					: bcpc), ((void *)mcpc));
				if (result != 0) {
					return result;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc1 += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	return 0;
}

	/* Cogit>>#CallFullRT:registersToBeSavedMask: */
static NoDbgRegParms AbstractInstruction *
CallFullRTregistersToBeSavedMask(sqInt callTarget, sqInt registersToBeSaved)
{
    int callerSavedRegsToBeSaved;
    AbstractInstruction *lastInst;

	callerSavedRegsToBeSaved = CallerSavedRegisterMask & registersToBeSaved;
	/* begin genPushRegisterMask: */
	if (callerSavedRegsToBeSaved == 0) {
		/* begin Label */
		genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		genoperand(PushSTM, callerSavedRegsToBeSaved);
	}
	lastInst = checkLiteralforInstruction(callTarget, genoperand(CallFull, callTarget));
	return 
	/* begin genPopRegisterMask: */
(callerSavedRegsToBeSaved == 0
		? genoperandoperand(Label, (labelCounter += 1), bytecodePC)
		: genoperand(PopLDM, callerSavedRegsToBeSaved));
}


/*	Big assumption here that calls and jumps look the same as regards their
	displacement. This works on at least x86, ARM and x86_64. */

	/* Cogit>>#CallRT: */
static NoDbgRegParms AbstractInstruction *
CallRT(sqInt callTarget)
{
    AbstractInstruction *abstractInstruction;

	abstractInstruction = genoperand(Call, callTarget);
	/* begin annotateCall: */
	(abstractInstruction->annotation = IsRelativeCall);
	return abstractInstruction;
}


/*	This is a static version of ceCallCogCodePopReceiverReg for break-pointing
	when debugging in C. Marked <api> so the code generator won't delete it. */

	/* Cogit>>#callCogCodePopReceiver */
static void
callCogCodePopReceiver(void)
{
	realCECallCogCodePopReceiverReg();
	if (!Debug) {
		error("what??");
	}
}


/*	This is a static version of ceCallCogCodePopReceiverAndClassRegs for
	break-pointing when debugging in C. Marked <api> so the code generator
	won't delete it. */

	/* Cogit>>#callCogCodePopReceiverAndClassRegs */
static void
callCogCodePopReceiverAndClassRegs(void)
{
	realCECallCogCodePopReceiverAndClassRegs();
}


/*	Code entry closed PIC miss. A send has fallen
	through a closed (finite) polymorphic inline cache.
	Either extend it or patch the send site to an open PIC.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */
/*	Marked <api> so the code generator won't delete it. */

	/* Cogit>>#ceCPICMiss:receiver: */
static NoDbgRegParms sqInt
ceCPICMissreceiver(CogMethod *cPIC, sqInt receiver)
{
    sqInt cacheTag;
    sqInt errorSelectorOrNil;
    sqInt errsel;
    sqInt method;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    sqInt outerReturn;
    sqInt result;
    sqInt selector;

	errsel = 0;
	method = 0;
	outerReturn = stackTop();
	assert(!(((inlineCacheTagAt(backEnd, outerReturn)) == (picAbortDiscriminatorValue()))));
	if (((cPIC->cPICNumCases)) < MaxCPICCases) {
		selector = (cPIC->selector);
		/* begin lookup:for:methodAndErrorSelectorInto: */
		methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorCannotInterpret;
				goto l1;
			}
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {
				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, selector);
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = null;
			goto l1;
		}
		if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
			methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
			if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
				assert(isOopCompiledMethod(methodOrSelectorIndex));
				if ((!(methodHasCogMethod(methodOrSelectorIndex)))
				 && (methodShouldBeCogged(methodOrSelectorIndex))) {
					/* We assume cog:selector: will *not* reclaim the method zone */
					cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
				}
				newTargetMethodOrNil = methodOrSelectorIndex;
				errorSelectorOrNil = SelectorDoesNotUnderstand;
				goto l1;
			}
			newTargetMethodOrNil = null;
			errorSelectorOrNil = SelectorDoesNotUnderstand;
			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = methodOrSelectorIndex;
	l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	}
	else {
		newTargetMethodOrNil = (errorSelectorOrNil = null);
	}
	assert(outerReturn == (stackTop()));
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	cacheTag = inlineCacheTagForInstance(receiver);
	if ((((cPIC->cPICNumCases)) >= MaxCPICCases)
	 || (	/* begin closedPICInappropriateForCacheTag:targetMethod:orErrorSelector: */
		((errorSelectorOrNil)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((inlineCacheTagIsYoung(cacheTag))
	 || ((!newTargetMethodOrNil)
	 || (isYoung(newTargetMethodOrNil)))))) {
		result = patchToOpenPICFornumArgsreceiver((cPIC->selector), (cPIC->cmNumArgs), receiver);
		assert(!result);
		/* begin ensureExecutableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
#    endif

		return ceSendFromInLineCacheMiss(cPIC);
	}
	cogExtendPICCaseNMethodtagisMNUCase(cPIC, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	executeCogPICfromLinkedSendWithReceiverandCacheTag(cPIC, receiver, longAt(pcRelativeAddressAt(backEnd, ((usqInt)(outerReturn - 8)))));
	return null;
}


/*	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it. 
 */

	/* Cogit>>#ceFree: */
static NoDbgRegParms void
ceFree(void *pointer)
{
	free(pointer);
}


/*	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it. 
 */

	/* Cogit>>#ceMalloc: */
static NoDbgRegParms void*
ceMalloc(size_t size)
{
	return malloc(size);
}


/*	An in-line cache check in a method has failed. The failing entry check has
	jumped to the ceMethodAbort abort call at the start of the method which
	has called this routine.
	If possible allocate a closed PIC for the current and existing classes.
	The stack looks like:
	receiver
	args
	sender return address
	sp=>	ceMethodAbort call return address
	So we can find the method that did the failing entry check at
	ceMethodAbort call return address - missOffset
	and we can find the send site from the outer return address.
	Invoked from a trampoline. Marked <api> so the code generator won't delete
	it.  */

	/* Cogit>>#ceSICMiss: */
static NoDbgRegParms sqInt
ceSICMiss(sqInt receiver)
{
    sqInt cacheTag;
    sqInt entryPoint;
    sqInt errorSelectorOrNil;
    sqInt errsel;
    sqInt extent;
    usqInt innerReturn;
    sqInt method;
    sqInt methodOrSelectorIndex;
    sqInt newTargetMethodOrNil;
    usqInt outerReturn;
    CogMethod *pic;
    sqInt result;
    sqInt selector;
    CogMethod *targetMethod;


	/* Whether we can relink to a PIC or not we need to pop off the inner return and identify the target method. */
	errsel = 0;
	method = 0;
	innerReturn = ((usqInt)(popStack()));
	targetMethod = ((CogMethod *) (innerReturn - missOffset));
	outerReturn = ((usqInt)(stackTop()));
	assert(((outerReturn >= methodZoneBase) && (outerReturn <= (freeStart()))));
	entryPoint = callTargetFromReturnAddress(backEnd, outerReturn);
	assert(((targetMethod->selector)) != (nilObject()));
	assert(((((sqInt)targetMethod)) + cmEntryOffset) == entryPoint);
	selector = (targetMethod->selector);
	/* begin lookup:for:methodAndErrorSelectorInto: */
	methodOrSelectorIndex = lookupOrdinaryreceiver(selector, receiver);
	if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
		if (!(isOopCompiledMethod(methodOrSelectorIndex))) {
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorCannotInterpret;
			goto l1;
		}
		if ((!(methodHasCogMethod(methodOrSelectorIndex)))
		 && (methodShouldBeCogged(methodOrSelectorIndex))) {
			/* We assume cog:selector: will *not* reclaim the method zone */
			cogselector(methodOrSelectorIndex, selector);
		}
		newTargetMethodOrNil = methodOrSelectorIndex;
		errorSelectorOrNil = null;
		goto l1;
	}
	if (methodOrSelectorIndex == SelectorDoesNotUnderstand) {
		methodOrSelectorIndex = lookupMNUreceiver(splObj(SelectorDoesNotUnderstand), receiver);
		if ((((usqInt)methodOrSelectorIndex)) > (maxLookupNoMNUErrorCode())) {
			assert(isOopCompiledMethod(methodOrSelectorIndex));
			if ((!(methodHasCogMethod(methodOrSelectorIndex)))
			 && (methodShouldBeCogged(methodOrSelectorIndex))) {
				/* We assume cog:selector: will *not* reclaim the method zone */
				cogselector(methodOrSelectorIndex, splObj(SelectorDoesNotUnderstand));
			}
			newTargetMethodOrNil = methodOrSelectorIndex;
			errorSelectorOrNil = SelectorDoesNotUnderstand;
			goto l1;
		}
		newTargetMethodOrNil = null;
		errorSelectorOrNil = SelectorDoesNotUnderstand;
		goto l1;
	}
	newTargetMethodOrNil = null;
	errorSelectorOrNil = methodOrSelectorIndex;
	l1:	/* end lookup:for:methodAndErrorSelectorInto: */;
	assert(outerReturn == (stackTop()));
	cacheTag = inlineCacheTagForInstance(receiver);
	if ((	/* begin closedPICInappropriateForCacheTag:targetMethod:orErrorSelector: */
		((errorSelectorOrNil)
	 && (errorSelectorOrNil != SelectorDoesNotUnderstand))
	 || ((inlineCacheTagIsYoung(cacheTag))
	 || ((!newTargetMethodOrNil)
	 || (isYoung(newTargetMethodOrNil)))))
	 || ((longAt(pcRelativeAddressAt(backEnd, ((usqInt)(outerReturn - 8))))) == 0 /* begin picAbortDiscriminatorValue */)) {
		result = patchToOpenPICFornumArgsreceiver((targetMethod->selector), (targetMethod->cmNumArgs), receiver);
		assert(!result);
		return ceSendFromInLineCacheMiss(targetMethod);
	}
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	pic = openPICWithSelector((targetMethod->selector));
	if ((!pic)) {
		/* otherwise attempt to create a closed PIC for the two cases. */
		pic = cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase((targetMethod->selector), (targetMethod->cmNumArgs), targetMethod, newTargetMethodOrNil, cacheTag, errorSelectorOrNil == SelectorDoesNotUnderstand);
		if ((((((sqInt)pic)) >= MaxNegativeErrorCode) && ((((sqInt)pic)) <= -1))) {
			/* For some reason the PIC couldn't be generated, most likely a lack of code memory.
			   Continue as if this is an unlinked send. */
			if ((((sqInt)pic)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			/* begin ensureExecutableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
#      endif

			return ceSendFromInLineCacheMiss(targetMethod);
		}
	}
	if (((pic->cmType)) == CMOpenPIC) {
		extent = rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorin(backEnd, (targetMethod->selector), mframeHomeMethodExport()), (((sqInt)pic)) + cmEntryOffset);
	}
	else {
		extent = rewriteCallAttarget(backEnd, outerReturn, (((sqInt)pic)) + cmEntryOffset);
	}
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, (((usqInt)pic)) + cmNoCheckEntryOffset, codeToDataDelta);
#  endif

	flushICacheFromto(backEnd, ((usqInt)pic), (((usqInt)pic)) + closedPICSize);
	flushICacheFromto(backEnd, (((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
	executeCogPICfromLinkedSendWithReceiverandCacheTag(pic, receiver, longAt(pcRelativeAddressAt(backEnd, ((usqInt)(outerReturn - 8)))));
	return null;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRefAndTarget:pc:cogMethod: */
static NoDbgRegParms sqInt
checkIfValidOopRefAndTargetpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    sqInt cacheTag;
    sqInt cacheTag1;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt entryPt;
    sqInt literal;
    sqInt offset;
    sqInt offset1;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObject;
    sqInt targetMethod;
    CogMethod *targetMethod1;

	cacheTag = 0;
	entryPt = 0;
	tagCouldBeObject = 0;
	targetMethod = 0;
	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (!(asserta(checkValidOopReference(literal)))) {
			return 1;
		}
		if ((couldBeObject(literal))
		 && (isReallyYoungObject(literal))) {
			if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
				return 2;
			}
		}
	}
	if (annotation >= IsSendCall) {
		if (!(asserta(isCMMethodEtAl(((CogBlockMethod *) (((CogMethod *) cogMethod))))))) {
			return 3;
		}
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = longAt(pcRelativeAddressAt(backEnd, ((usqInt)((((sqInt)mcpc)) - 8))));
		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj = 1 /* begin inlineCacheTagsMayBeObjects */;
		entryPoint = entryPoint1;
		if (tagCouldBeObj) {
			if (couldBeObject(cacheTag1)) {
				if (!(asserta(checkValidOopReference(cacheTag1)))) {
					return 4;
				}
			}
			else {
				if (!(asserta(validInlineCacheTag(cacheTag1)))) {
					return 5;
				}
			}
			if ((couldBeObject(cacheTag1))
			 && (isReallyYoungObject(cacheTag1))) {
				if (!(asserta(((((CogMethod *) cogMethod))->cmRefersToYoung)))) {
					return 6;
				}
			}
		}
		else {
			if (!(asserta(validInlineCacheTag(cacheTag1)))) {
				return 9;
			};
		}
		if (entryPoint > methodZoneBase) {
			/* It's a linked send; find which kind. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (!(asserta((isCMMethodEtAl(((CogBlockMethod *) targetMethod1)))
				 || ((isCMClosedPIC(((CogBlockMethod *) targetMethod1)))
				 || (isCMOpenPIC(((CogBlockMethod *) targetMethod1))))))) {
				return 10;
			}
		}
	}
	return 0;
}


/*	Check for a valid object reference, if any, at a map entry. Answer a code
	unique to each error for debugging. */

	/* Cogit>>#checkIfValidOopRef:pc:cogMethod: */
static NoDbgRegParms sqInt
checkIfValidOopRefpccogMethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    sqInt entryPoint;
    sqInt literal;
    sqInt off;
    sqInt offset;
    sqInt offset1;
    sqInt selectorOrCacheTag;
    sqInt *sendTable;

	off = 0;
	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (!(checkValidOopReference(literal))) {
			print("object ref leak in CM ");
			printHex(((sqInt)cogMethod));
			print(" @ ");
			printHex(((sqInt)mcpc));
			eekcr();
			return 1;
		}
	}
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {
			offset = entryPoint;
		}
		else {
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable = superSendTrampolines;
;;;
			}
			offset = offset1;
		}
		selectorOrCacheTag = longAt(pcRelativeAddressAt(backEnd, ((usqInt)((((sqInt)mcpc)) - 8))));
		if ((entryPoint > methodZoneBase)
		 && ((offset != cmNoCheckEntryOffset)
		 && (!((((((CogMethod *) (entryPoint - offset)))->cmType)) == CMOpenPIC)))) {
			/* linked non-super send, cacheTag is a cacheTag */
			if (!(validInlineCacheTag(selectorOrCacheTag))) {
				print("cache tag leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" @ ");
				printHex(((sqInt)mcpc));
				eekcr();
				return 1;
			}
		}
		else {
			/* unlinked send or super send; cacheTag is a selector unless 64-bit, in which case it is an index. */
			if (!(checkValidOopReference(selectorOrCacheTag))) {
				print("selector leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" @ ");
				printHex(((sqInt)mcpc));
				eekcr();
				return 1;
			}
		}
	}
	return 0;
}


/*	Answer if all references to objects in machine-code are valid. */

	/* Cogit>>#checkIntegrityOfObjectReferencesInCode: */
sqInt
checkIntegrityOfObjectReferencesInCode(sqInt gcModes)
{
    CogMethod *cogMethod;
    sqInt count;
    sqInt ok;

	cogMethod = ((CogMethod *) methodZoneBase);
	ok = 1;
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if ((cogMethod->cmRefersToYoung)) {
				if (((count = occurrencesInYoungReferrers(cogMethod))) != 1) {
					print("young referrer CM ");
					printHex(((sqInt)cogMethod));
					if (count == 0) {
						print(" is not in youngReferrers");
						eekcr();
					}
					else {
						print(" is in youngReferrers ");
						printNum(count);
						print(" times!");
						eekcr();
					}
					ok = 0;
				}
			}
			if (!(checkValidOopReference((cogMethod->selector)))) {
				print("object leak in CM ");
				printHex(((sqInt)cogMethod));
				print(" selector");
				eekcr();
				ok = 0;
			}
			if (((cogMethod->cmType)) >= CMMethod) {
				assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
				if (!(checkValidObjectReference((cogMethod->methodObject)))) {
					print("object leak in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					eekcr();
					ok = 0;
				}
				if (!(isOopCompiledMethod((cogMethod->methodObject)))) {
					print("non-method in CM ");
					printHex(((sqInt)cogMethod));
					print(" methodObject");
					eekcr();
					ok = 0;
				}
				if ((mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, cogMethod)) != 0) {
					ok = 0;
				}
				if (((gcModes & GCModeNewSpace) != 0)) {
					if (((isYoungObject((cogMethod->methodObject)))
					 || (isYoung((cogMethod->selector))))
					 && (!((cogMethod->cmRefersToYoung)))) {
						print("CM ");
						printHex(((sqInt)cogMethod));
						print(" refers to young but not marked as such");
						eekcr();
						ok = 0;
					}
				}
			}
			else {
				if (((cogMethod->cmType)) == CMClosedPIC) {
					if (!(checkValidObjectReferencesInClosedPIC(cogMethod))) {
						ok = 0;
					}
				}
				else {
					if (((cogMethod->cmType)) == CMOpenPIC) {
						if ((mapForperformUntilarg(cogMethod, checkIfValidOopRefpccogMethod, cogMethod)) != 0) {
							ok = 0;
						}
					}
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return ok;
}

	/* Cogit>>#checkMaybeObjRefInClosedPIC: */
static NoDbgRegParms sqInt
checkMaybeObjRefInClosedPIC(sqInt maybeObject)
{
	if (maybeObject == 0) {
		return 1;
	}
	if (!(couldBeObject(maybeObject))) {
		return 1;
	}
	return checkValidObjectReference(maybeObject);
}

	/* Cogit>>#checkValidObjectReferencesInClosedPIC: */
static NoDbgRegParms sqInt
checkValidObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt ok;
    sqInt pc;

	ok = 1;
	/* first we check the obj ref at the beginning of the CPIC */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		print("object leak in CPIC ");
		printHex(((sqInt)cPIC));
		print(" @ ");
		printHex(pc - (jumpLongByteSize(backEnd)));
		cr();
		ok = 0;
	}
	/* For each case we check any object reference at the end address - sizeof(conditional instruction) and then increment the end address by case size */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (!(checkMaybeObjRefInClosedPIC(literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd)))))) {
			print("object leak in CPIC ");
			printHex(((sqInt)cPIC));
			print(" @ ");
			printHex((pc - (jumpLongConditionalByteSize(backEnd))) - (loadLiteralByteSize(backEnd)));
			cr();
			ok = 0;
		};
		if (!(checkMaybeObjRefInClosedPIC(literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			print("object leak in CPIC ");
			printHex(((sqInt)cPIC));
			print(" @ ");
			printHex(pc - (jumpLongConditionalByteSize(backEnd)));
			cr();
			ok = 0;
		}
		pc += cPICCaseSize;
	}
	return ok;
}


/*	i.e. this should never be called, so keep it out of the main path. */

	/* Cogit>>#cleanUpFailingCogCodeConstituents: */
static NoDbgRegParms NeverInline sqInt
cleanUpFailingCogCodeConstituents(CogMethod *cogMethodArg)
{
    CogMethod *cogMethod;

	cogMethod = cogMethodArg;
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMClosedPIC) {
			(cogMethod->methodObject = 0);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	popRemappableOop();
	return null;
}


/*	Answer if the ClosedPIC refers to any unmarked objects or freed/freeable
	target methods,
	applying markAndTraceOrFreeCogMethod:firstVisit: to those targets to
	determine if freed/freeable.
 */

	/* Cogit>>#closedPICRefersToUnmarkedObject: */
static NoDbgRegParms sqInt
closedPICRefersToUnmarkedObject(CogMethod *cPIC)
{
    sqInt i;
    sqInt object;
    sqInt pc;

	if (!((isImmediate((cPIC->selector)))
		 || (isMarked((cPIC->selector))))) {
		return 1;
	}
	pc = addressOfEndOfCaseinCPIC(1, cPIC);
	if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)))))) {
		if (!(isMarked(object))) {
			return 1;
		}
	}
	if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
		return 1;
	}
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (couldBeObject((object = literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd)))))) {
			if (!(isMarked(object))) {
				return 1;
			}
		}
		if (couldBeObject((object = literalBeforeFollowingAddress(backEnd, (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))))) {
			if (!(isMarked(object))) {
				return 1;
			}
		}
		if (markAndTraceOrFreePICTargetin(jumpLongTargetBeforeFollowingAddress(backEnd, pc), cPIC)) {
			return 1;
		}
	}
	return 0;
}

	/* Cogit>>#codeEntryFor: */
char *
codeEntryFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i + 1];
		}
	}
	return null;
}

	/* Cogit>>#codeEntryNameFor: */
char *
codeEntryNameFor(char *address)
{
    sqInt i;

	for (i = 0; i <= (trampolineTableIndex - 3); i += 2) {
		if (((address >= (trampolineAddresses[i + 1])) && (address <= ((trampolineAddresses[i + 3]) - 1)))) {
			return trampolineAddresses[i];
		}
	}
	return null;
}


/*	used e.g. in the platform's backtrace generators. Declared api to place it
	in cogit.h
 */

	/* Cogit>>#cogCodeBase */
sqInt
cogCodeBase(void)
{
	return codeBase;
}


/*	Answer the contents of the code zone as an array of pair-wise element,
	address in ascending address order.
	Answer a string for a runtime routine or abstract label (beginning, end,
	etc), a CompiledMethod for a CMMethod,
	or a selector (presumably a Symbol) for a PIC.
	If withDetails is true
	- answer machine-code to bytecode pc mapping information for methods
	- answer class, target pair information for closed PIC
	N.B. Since the class tag for the first case of a closed PIC is stored at
	the send site, it must be collected
	by scanning methods (see
	collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method:). Since closed PICs
	are never shared they always come after the method that references them,
	so we don't need an extra pass
	to collect the first case class tags, which are (temporarily) assigned to
	each closed PIC's methodObject field.
	But we do need to reset the methodObject fields to zero. This is done in
	createPICData:, unless memory
	runs out, in which case it is done by cleanUpFailingCogCodeConstituents:. */

	/* Cogit>>#cogCodeConstituents: */
sqInt
cogCodeConstituents(sqInt withDetails)
{
    CogMethod *cogMethod;
    sqInt constituents;
    sqInt count;
    sqInt i;
    sqInt label;
    sqInt profileData;
    sqInt value;


	/* + 3 for start, freeStart and end */
	count = (trampolineTableIndex / 2) + 3;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			count += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	constituents = instantiateClassindexableSize(classArray(), count * 2);
	if (!constituents) {
		return constituents;
	}
	pushRemappableOop(constituents);
	if ((!((label = stringForCString("CogCode"))))
	 || (!((value = 
/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(codeBase))))) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, topRemappableOop(), label);
	storePointerUncheckedofObjectwithValue(1, topRemappableOop(), value);
	for (i = 0; i < trampolineTableIndex; i += 2) {
		if ((!((label = stringForCString(trampolineAddresses[i]))))
		 || (!((value = 
/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(((usqInt)(trampolineAddresses[i + 1]))))))) {
			popRemappableOop();
			return null;
		}
		storePointerUncheckedofObjectwithValue(2 + i, topRemappableOop(), label);
		storePointerUncheckedofObjectwithValue(3 + i, topRemappableOop(), value);
	}
	count = trampolineTableIndex + 2;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			profileData = 
			/* begin profileDataFor:withDetails: */
(((cogMethod->cmType)) >= CMMethod
				? (cogMethod->methodObject)
				: (withDetails
					 && (((cogMethod->cmType)) == CMClosedPIC)
						? createCPICData(cogMethod)
						: (cogMethod->selector)));
			if (!profileData) {
				return cleanUpFailingCogCodeConstituents(cogMethod);
			}
			storePointerUncheckedofObjectwithValue(count, topRemappableOop(), profileData);
			value = (withDetails
				? collectCogMethodConstituent(cogMethod)
				: 
					/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(((usqInt)cogMethod)));
			if (!value) {
				return cleanUpFailingCogCodeConstituents(cogMethod);
			}
			storePointerUncheckedofObjectwithValue(count + 1, topRemappableOop(), value);
			count += 2;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if ((!((label = stringForCString("CCFree"))))
	 || (!((value = 
/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(mzFreeStart))))) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count, topRemappableOop(), label);
	storePointerUncheckedofObjectwithValue(count + 1, topRemappableOop(), value);
	if ((!((label = stringForCString("CCEnd"))))
	 || (!((value = 
/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(limitAddress))))) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(count + 2, topRemappableOop(), label);
	storePointerUncheckedofObjectwithValue(count + 3, topRemappableOop(), value);
	constituents = popRemappableOop();
	beRootIfOld(constituents);
	return constituents;
}


/*	Extend the cPIC with the supplied case. If caseNMethod is cogged dispatch
	direct to
	its unchecked entry-point. If caseNMethod is not cogged, jump to the fast
	interpreter dispatch, and if isMNUCase then dispatch to fast MNU
	invocation and mark the cPIC as
	having the MNU case for cache flushing. */

	/* Cogit>>#cogExtendPIC:CaseNMethod:tag:isMNUCase: */
static NoDbgRegParms void
cogExtendPICCaseNMethodtagisMNUCase(CogMethod *cPIC, sqInt caseNMethod, sqInt caseNTag, sqInt isMNUCase)
{
    sqInt address;
    usqInt addressFollowingJump;
    sqInt operand;
    sqInt target;

	compilationBreakpointclassTagisMNUCase((cPIC->selector), caseNTag, isMNUCase);
	assert(!(inlineCacheTagIsYoung(caseNTag)));
	assert((caseNMethod)
	 && (!(isYoung(caseNMethod))));
	if ((!isMNUCase)
	 && (methodHasCogMethod(caseNMethod))) {
		/* this isn't an MNU and we have an already cogged method to jump to */
		operand = 0;
		target = (((sqInt)(cogMethodOf(caseNMethod)))) + cmNoCheckEntryOffset;
	}
	else {
		operand = caseNMethod;
		if (isMNUCase) {
			/* this is an MNU so tag the CPIC header and setup a jump to the MNUAbort */
			/* begin cpicHasMNUCase: */
			((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cpicHasMNUCaseOrCMIsFullBlock) = 1;
			target = (((sqInt)cPIC)) + (sizeof(CogMethod));
		}
		else {
			/* setup a jump to the interpretAborth so we can cog the target method */
			target = (((sqInt)cPIC)) + (picInterpretAbortOffset());
		}
	}
	address = addressOfEndOfCaseinCPIC(((cPIC->cPICNumCases)) + 1, cPIC);
	rewriteCPICCaseAttagobjReftarget(address, caseNTag, operand, target);
	/* begin rewriteCPIC:caseJumpTo: */
	addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
	rewriteTransferAttarget(((AbstractInstruction *) backEnd), addressFollowingJump, address - cPICCaseSize);
	((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cPICNumCases = ((cPIC->cPICNumCases)) + 1);
	flushICacheFromto(backEnd, ((usqInt)cPIC), (((usqInt)cPIC)) + closedPICSize);
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, (((usqInt)cPIC)) + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
}

	/* Cogit>>#cogitPostGCAction: */
void
cogitPostGCAction(sqInt gcMode)
{
	if ((gcMode == GCModeFull)) {
		voidYoungReferrersPostTenureAll();
	}
	assert(allMethodsHaveCorrectHeader());
	assert(((!(gcMode & (GCModeFull + GCModeNewSpace))))
	 || (kosherYoungReferrers()));
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}


/*	Check that the header fields onf a non-free method are consistent with
	the type. Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#cogMethodDoesntLookKosher: */
static NoDbgRegParms sqInt
cogMethodDoesntLookKosher(CogMethod *cogMethod)
{
	if (((((cogMethod->blockSize)) & (BytesPerWord - 1)) != 0)
	 || ((((cogMethod->blockSize)) < (sizeof(CogMethod)))
	 || (((cogMethod->blockSize)) >= 0x8000))) {
		return 1;
	}
	if (((cogMethod->cmType)) == CMFree) {
		return 2;
	}
	if (((cogMethod->cmType)) >= CMMethod) {
		if (!((((cogMethod->methodHeader)) & 1))) {
			return 11;
		}
		if (!(couldBeObject((cogMethod->methodObject)))) {
			return 12;
		}
		if ((((cogMethod->stackCheckOffset)) > 0)
		 && (((cogMethod->stackCheckOffset)) < cmNoCheckEntryOffset)) {
			return 13;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (((cogMethod->blockSize)) != openPICSize) {
			return 21;
		}
		if (((cogMethod->methodHeader)) != 0) {
			return 22;
		}
		if (((cogMethod->objectHeader)) >= 0) {
			if (!((((cogMethod->methodObject)) == 0)
				 || (compactionInProgress
				 || (((cogMethod->methodObject)) == (((usqInt)(methodFor(((void *)((cogMethod->methodObject))))))))))) {
				return 23;
			}
		}
		if (((cogMethod->stackCheckOffset)) != 0) {
			return 24;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (((cogMethod->blockSize)) != closedPICSize) {
			return 0x1F;
		}
		if (!(((((cogMethod->cPICNumCases)) >= 1) && (((cogMethod->cPICNumCases)) <= MaxCPICCases)))) {
			return 32;
		}
		if (((cogMethod->methodHeader)) != 0) {
			return 33;
		}
		if (((cogMethod->methodObject)) != 0) {
			return 34;
		}
		return 0;
	}
	return 9;
}


/*	Attempt to create a one-case PIC for an MNU.
	The tag for the case is at the send site and so doesn't need to be
	generated. 
 */

	/* Cogit>>#cogMNUPICSelector:receiver:methodOperand:numArgs: */
CogMethod *
cogMNUPICSelectorreceivermethodOperandnumArgs(sqInt selector, sqInt rcvr, sqInt methodOperand, sqInt numArgs)
{
    CogMethod *actualPIC;
    usqInt startAddress;
    CogMethod *writablePIC;

	if ((isYoung(selector))
	 || ((inlineCacheTagForInstance(rcvr)) == 0 /* begin picAbortDiscriminatorValue */)) {
		return 0;
	}
	compilationBreakpointclassTagisMNUCase(selector, fetchClassTagOf(rcvr), 1);
	assert(endCPICCase0);
	startAddress = allocate(closedPICSize);
	if (startAddress == 0) {
		callForCogCompiledCodeCompaction();
		return 0;
	}
	maybeBreakGeneratingFromto(startAddress, startAddress + closedPICSize);
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	/* memcpy the prototype across to our allocated space; because anything else would be silly */
	writablePIC = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	codeMemcpy(writablePIC, cPICPrototype, closedPICSize);
	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	assert(!(isYoung(selector)));
	(writablePIC->cmType = CMClosedPIC);
	(writablePIC->objectHeader = 0);
	(writablePIC->blockSize = closedPICSize);
	(writablePIC->methodObject = 0);
	(writablePIC->methodHeader = 0);
	(writablePIC->selector = selector);
	(writablePIC->cmNumArgs = numArgs);
	(writablePIC->cmHasMovableLiteral = 0);
	(writablePIC->cmRefersToYoung = 0);
	(writablePIC->cmUsageCount = CMMaxUsageCount / 2);
	/* begin cpicHasMNUCase: */
	(writablePIC->cpicHasMNUCaseOrCMIsFullBlock) = 1;
	(writablePIC->cPICNumCases = 1);
	(writablePIC->blockEntryOffset = 0);
	assert(isCMClosedPIC(((CogBlockMethod *) writablePIC)));
	assert(((writablePIC->selector)) == selector);
	assert(((writablePIC->cmNumArgs)) == numArgs);
	assert(((writablePIC->cPICNumCases)) == 1);
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	configureMNUCPICmethodOperandnumArgsdelta((actualPIC = ((CogMethod *) startAddress)), methodOperand, numArgs, startAddress - (((usqInt)cPICPrototype)));
	flushICacheFromto(backEnd, startAddress, startAddress + closedPICSize);
	assert((callTargetFromReturnAddress(backEnd, startAddress + missOffset)) == (picAbortTrampolineFor(numArgs)));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, startAddress + cmNoCheckEntryOffset, codeToDataDelta);
#  endif

	return actualPIC;
}


/*	Create an Open PIC. Temporarily create a direct call of
	ceSendFromOpenPIC:. Should become a probe of the first-level method lookup
	cache followed by a
	call of ceSendFromOpenPIC: if the probe fails. */

	/* Cogit>>#cogOpenPICSelector:numArgs: */
static NoDbgRegParms CogMethod *
cogOpenPICSelectornumArgs(sqInt selector, sqInt numArgs)
{
    sqInt codeSize;
    sqInt end;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;
    CogMethod *pic;
    usqInt startAddress;

	compilationBreakpointisMNUCase(selector, 0);
	startAddress = allocate(openPICSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	(methodLabel->address = startAddress);
	(methodLabel->dependent = null);
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	compileOpenPICnumArgs(selector, numArgs);
	computeMaximumSizes();
	concretizeAt(methodLabel, startAddress);
	codeSize = generateInstructionsAt(startAddress + (sizeof(CogMethod)));
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	mapSize = generateMapAtstart((startAddress + openPICSize) - 1, startAddress + cmNoCheckEntryOffset);
	assert((((entry->address)) - startAddress) == cmEntryOffset);
	assert(((roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpLength(mapSize))) <= openPICSize);
	end = outputInstructionsAt(startAddress + (sizeof(CogMethod)));
	pic = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	/* begin fillInOPICHeader:numArgs:selector: */
	(pic->cmType = CMOpenPIC);
	(pic->objectHeader = 0);
	(pic->blockSize = openPICSize);
	addToOpenPICList(pic);
	(pic->methodHeader = 0);
	(pic->selector = selector);
	(pic->cmNumArgs = numArgs);
	(pic->cmHasMovableLiteral = isNonImmediate(selector));
	if ((pic->cmRefersToYoung = isYoung(selector))) {
		addToYoungReferrers(pic);
	}
	(pic->cmUsageCount = initialOpenPICUsageCount());
	/* begin cpicHasMNUCase: */
	(pic->cpicHasMNUCaseOrCMIsFullBlock) = 0;
	(pic->cPICNumCases = 0);
	(pic->blockEntryOffset = 0);
	flushICacheFromto(backEnd, (((usqInt)pic)) - codeToDataDelta, ((((usqInt)pic)) - codeToDataDelta) + openPICSize);
	assert(isCMOpenPIC(((CogBlockMethod *) pic)));
	assert(((pic->selector)) == selector);
	assert(((pic->cmNumArgs)) == numArgs);
	assert((callTargetFromReturnAddress(backEnd, ((((sqInt)pic)) - codeToDataDelta) + missOffset)) == (picAbortTrampolineFor(numArgs)));
	assert(openPICSize == (roundUpLength(openPICSize)));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, ((((usqInt)pic)) - codeToDataDelta) + cmNoCheckEntryOffset, codeToDataDelta);
#  endif

	return ((CogMethod *) startAddress);
}


/*	Attempt to create a two-case PIC for case0CogMethod and
	case1Method,case1Tag. The tag for case0CogMethod is at the send site and
	so doesn't need to be generated.
	case1Method may be any of
	- a Cog method; link to its unchecked entry-point
	- a CompiledMethod; link to ceInterpretMethodFromPIC:
	- a CompiledMethod; link to ceMNUFromPICMNUMethod:receiver: */

	/* Cogit>>#cogPICSelector:numArgs:Case0Method:Case1Method:tag:isMNUCase: */
static NoDbgRegParms CogMethod *
cogPICSelectornumArgsCase0MethodCase1MethodtagisMNUCase(sqInt selector, sqInt numArgs, CogMethod *case0CogMethod, sqInt case1MethodOrNil, sqInt case1Tag, sqInt isMNUCase)
{
    CogMethod *actualPIC;
    usqInt startAddress;
    CogMethod *writablePIC;

	if (isYoung(selector)) {
		return ((CogMethod *) YoungSelectorInPIC);
	}
	compilationBreakpointclassTagisMNUCase(selector, case1Tag, isMNUCase);
	startAddress = allocate(closedPICSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	maybeBreakGeneratingFromto(startAddress, startAddress + closedPICSize);
	/* memcpy the prototype across to our allocated space; because anything else would be silly */
	writablePIC = ((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta));
	codeMemcpy(writablePIC, cPICPrototype, closedPICSize);
	/* begin fillInCPICHeader:numArgs:numCases:hasMNUCase:selector: */
	assert(!(isYoung(selector)));
	(writablePIC->cmType = CMClosedPIC);
	(writablePIC->objectHeader = 0);
	(writablePIC->blockSize = closedPICSize);
	(writablePIC->methodObject = 0);
	(writablePIC->methodHeader = 0);
	(writablePIC->selector = selector);
	(writablePIC->cmNumArgs = numArgs);
	(writablePIC->cmHasMovableLiteral = 0);
	(writablePIC->cmRefersToYoung = 0);
	(writablePIC->cmUsageCount = CMMaxUsageCount / 2);
	/* begin cpicHasMNUCase: */
	(writablePIC->cpicHasMNUCaseOrCMIsFullBlock) = isMNUCase;
	(writablePIC->cPICNumCases = 2);
	(writablePIC->blockEntryOffset = 0);
	assert(isCMClosedPIC(((CogBlockMethod *) writablePIC)));
	assert(((writablePIC->selector)) == selector);
	assert(((writablePIC->cmNumArgs)) == numArgs);
	assert(((writablePIC->cPICNumCases)) == 2);
	assert(closedPICSize == (roundUpLength(closedPICSize)));
	configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta((actualPIC = ((CogMethod *) startAddress)), case0CogMethod, case1MethodOrNil, case1Tag, isMNUCase, numArgs, startAddress - (((usqInt)cPICPrototype)));
	assert((callTargetFromReturnAddress(backEnd, startAddress + missOffset)) == (picAbortTrampolineFor(numArgs)));
	return actualPIC;
}


/*	Attempt to produce a machine code method for the bytecode method
	object aMethodObj. N.B. If there is no code memory available do *NOT*
	attempt to reclaim the method zone. Certain clients (e.g. ceSICMiss:)
	depend on the zone remaining constant across method generation. */

	/* Cogit>>#cog:selector: */
CogMethod *
cogselector(sqInt aMethodObj, sqInt aSelectorOop)
{
    CogMethod *cogMethod;
    sqInt selector;

	assert(!((methodHasCogMethod(aMethodObj))));
	/* coInterpreter stringOf: selector */
	selector = (aSelectorOop == (nilObject())
		? maybeSelectorOfMethod(aMethodObj)
		: aSelectorOop);
	if (!(selector == null)) {
		compilationBreakpointisMNUCase(selector, 0);
	}
	if (aMethodObj == breakMethod) {
		haltmsg("Compilation of breakMethod");
	}
	if (methodUsesAlternateBytecodeSet(aMethodObj)) {
		if ((numElementsIn(generatorTable)) <= 0x100) {
			return null;
		}
		bytecodeSetOffset = 0x100;
	}
	else {
		bytecodeSetOffset = 0;
	}
	assert(!((isFullBlockMethod(aMethodObj))));
	methodObj = aMethodObj;
	methodHeader = methodHeaderOf(aMethodObj);
	/* lazy initialization */
	receiverTags = -1;
	cogMethod = compileCogMethod(aSelectorOop);
	if ((((((sqInt)cogMethod)) >= MaxNegativeErrorCode) && ((((sqInt)cogMethod)) <= -1))) {
		if ((((sqInt)cogMethod)) == InsufficientCodeSpace) {
			callForCogCompiledCodeCompaction();
		}
		return null;
	}
	return cogMethod;
}

	/* Cogit>>#collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method: */
static NoDbgRegParms sqInt
collectCogConstituentForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg)
{
    sqInt address;
    sqInt annotation;
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt *sendTable1;
    sqInt sendTable2;
    CogMethod *targetMethod;
    CogMethod *targetMethod1;

	targetMethod = ((CogMethod *) 0);
	if (!descriptor) {
		return 0;
	}
	if (!((descriptor->isMapped))) {
		return 0;
	}
	address = 
	/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(((usqInt)mcpc));
	if (!address) {
		return PrimErrNoMemory;
	}
	storePointerUncheckedofObjectwithValue(cogConstituentIndex, topRemappableOop(), address);
	storePointerUncheckedofObjectwithValue(cogConstituentIndex + 1, topRemappableOop(), (((usqInt)bcpc << 1) | 1));
	/* Collect any first case classTags for closed PICs. */
	cogConstituentIndex += 2;
	if (((!(isBackwardBranchAndAnnotation & 1)))
	 && (	/* begin isSendAnnotation: */
		((((usqInt)(isBackwardBranchAndAnnotation)) >> 1) >= IsSendCall))) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* send is linked */
			annotation = ((usqInt)(isBackwardBranchAndAnnotation)) >> 1;
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (((targetMethod1->cmType)) == CMClosedPIC) {
				(targetMethod1->methodObject = classForInlineCacheTag(longAt(pcRelativeAddressAt(backEnd, ((usqInt)((((sqInt)mcpc)) - 8))))));
			}
		}
	}
	return 0;
}


/*	Answer a description of the mapping between machine code pointers and
	bytecode pointers for the Cog Method.
	First value is the address of the cog method.
	Following values are pairs of machine code pc and bytecode pc */

	/* Cogit>>#collectCogMethodConstituent: */
static NoDbgRegParms sqInt
collectCogMethodConstituent(CogMethod *cogMethod)
{
    sqInt address;
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    CogBlockMethod *cogBlockMethod;
    sqInt data;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    sqInt errCode;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt nSlots;
    sqInt result;
    sqInt startbcpc;
    sqInt targetPC;

	if (!(((cogMethod->cmType)) >= CMMethod)) {
		return 
		/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(((usqInt)cogMethod));
	}
	cogBlockMethod = ((CogBlockMethod *) cogMethod);
	if (((cogBlockMethod->stackCheckOffset)) == 0) {
		/* isFrameless ? */
		return 
		/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(((usqInt)cogMethod));
	}
	/* +1 for first address */
	nSlots = ((((byteSizeOf((cogMethod->methodObject))) - (startPCOfMethodHeader((cogMethod->methodHeader)))) * 2) + (minSlotsForShortening())) + 1;
	data = instantiateClassindexableSize(splObj(ClassArray), nSlots);
	if (!data) {
		return null;
	}
	pushRemappableOop(data);
	address = 
	/* begin positiveMachineIntegerFor: */
positive32BitIntegerFor(((usqInt)cogMethod));
	if (!address) {
		popRemappableOop();
		return null;
	}
	storePointerUncheckedofObjectwithValue(0, topRemappableOop(), address);
	cogConstituentIndex = 1;
	startbcpc = startPCOfMethod((cogMethod->methodObject));
	/* begin mapFor:bcpc:performUntil:arg: */
	latestContinuation = 0;
	assert(((cogBlockMethod->stackCheckOffset)) > 0);
	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogBlockMethod)) + ((cogBlockMethod->stackCheckOffset));
	result = collectCogConstituentForAnnotationMcpcBcpcMethod(null, 0 + (((int)((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc), startbcpc, ((void *)cogMethod));
	if (result != 0) {
		errCode = result;
		goto l2;
	}
	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if (((cogBlockMethod->cmType)) >= CMMethod) {
		isInBlock = 0 /* begin cmIsFullBlock */;
		homeMethod = ((CogMethod *) cogBlockMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == ((cogBlockMethod->startpc)));
		homeMethod = cmHomeMethod(cogBlockMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogBlockMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}
		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - BlockCreationBytecodeSize;
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
	: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							errCode = 0;
							goto l2;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							errCode = 0;
							goto l2;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((				/* begin isBackwardBranch:at:exts:in: */
					assert(((descriptor->spanFunction))),
				(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = collectCogConstituentForAnnotationMcpcBcpcMethod(descriptor, (isBackwardBranch
					? (((sqInt)((usqInt)(annotation) << 1))) + 1
					: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc), (isBackwardBranch
					? bcpc - (2 * nExts)
					: bcpc), ((void *)cogMethod));
				if (result != 0) {
					errCode = result;
					goto l2;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	errCode = 0;
	l2:	/* end mapFor:bcpc:performUntil:arg: */;
	if (errCode != 0) {
		popRemappableOop();
		return null;
	}
	if (cogConstituentIndex < nSlots) {
		shortentoIndexableSize(topRemappableOop(), cogConstituentIndex);
	}
	return popRemappableOop();
}

	/* Cogit>>#compactCogCompiledCode */
void
compactCogCompiledCode(void)
{
	assertValidDualZone();
	assert(noCogMethodsMaximallyMarked());
	moveProfileToMethods();
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	markActiveMethodsAndReferents();
	freeOlderMethodsForCompaction();
	compactPICsWithFreedTargets();
	planCompaction();
	updateStackZoneReferencesToCompiledCodePreCompaction();
	relocateMethodsPreCompaction();
	assertValidDualZone();
	compactCompiledCode();
	stopsFromto(backEnd, freeStart(), (youngReferrers()) - 1);
	flushICacheFromto(backEnd, ((usqInt)methodZoneBase), ((usqInt)(youngReferrers())));
	assert(allMethodsHaveCorrectHeader());
	assert(kosherYoungReferrers());
	assertValidDualZone();
}

	/* Cogit>>#compactPICsWithFreedTargets */
static void
compactPICsWithFreedTargets(void)
{
    CogMethod *cogMethod;
    sqInt count;

	cogMethod = ((CogMethod *) methodZoneBase);
	count = 0;
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) == CMClosedPIC)
		 && (cPICCompactAndIsNowEmpty(cogMethod))) {
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMFree);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		count += 1;
	}
	assert(count == (numMethods()));
}


/*	The start of a CogMethod has a call to a run-time abort routine that
	either handles an in-line cache failure or a stack overflow. The routine
	selects the
	path depending on ReceiverResultReg; if zero it takes the stack overflow
	path; if nonzero the in-line cache miss path. Neither of these paths
	returns. The abort routine must be called; In the callee the method is
	located by
	adding the relevant offset to the return address of the call.
	
	N.B. This code must match that in compilePICAbort: so that the offset of
	the return address of the call is the same in methods and closed PICs. */

	/* Cogit>>#compileAbort */
static AbstractInstruction *
compileAbort(void)
{
    AbstractInstruction *anInstruction;
    sqInt callTarget;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	stackOverflowCall = anInstruction;
	sendMiss = genoperand(PushR, LinkReg);
	callTarget = methodAbortTrampolineFor(methodOrBlockNumArgs);
	/* begin Call: */
	return genoperand(Call, callTarget);
}

	/* Cogit>>#compileBlockDispatchFrom:to: */
static NoDbgRegParms sqInt
compileBlockDispatchFromto(sqInt lowBlockStartIndex, sqInt highBlockStartIndex)
{
    AbstractInstruction *anInstruction;
    BlockStart *blockStart;
    sqInt halfWay;
    AbstractInstruction *jmp;
    sqInt quickConstant;

	if (lowBlockStartIndex == highBlockStartIndex) {
		blockStart = blockStartAt(lowBlockStartIndex);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)((blockStart->entryLabel))));
		return null;
	}
	halfWay = (highBlockStartIndex + lowBlockStartIndex) / 2;
	assert(((halfWay >= lowBlockStartIndex) && (halfWay <= highBlockStartIndex)));
	/* N.B. FLAGS := TempReg - startpc */
	blockStart = blockStartAt(halfWay);
	/* begin CmpCq:R: */
	quickConstant = (((usqInt)(((blockStart->startpc)) + 1) << 1) | 1);
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	if (lowBlockStartIndex == halfWay) {
		/* begin JumpLessOrEqual: */
		genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)((blockStart->entryLabel))));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
		return null;
	}
	if ((halfWay + 1) == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		/* begin JumpGreater: */
		genConditionalBranchoperand(JumpGreater, ((sqInt)((blockStart->entryLabel))));
		return compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	}
	jmp = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	compileBlockDispatchFromto(lowBlockStartIndex, halfWay);
	if (halfWay == highBlockStartIndex) {
		blockStart = blockStartAt(highBlockStartIndex);
		jmpTarget(jmp, (blockStart->entryLabel));
	}
	else {
		jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		compileBlockDispatchFromto(halfWay + 1, highBlockStartIndex);
	}
	return 0;
}


/*	Compile a block's entry. This looks like a dummy CogBlockMethod header
	(for frame parsing)
	followed by either a frame build, if a frame is required, or nothing. The
	CogMethodHeader's objectHeader field is a back pointer to the method, but
	this can't be filled in until code generation. */

	/* Cogit>>#compileBlockEntry: */
static NoDbgRegParms void
compileBlockEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    sqInt alignment;

	alignment = blockAlignment();
	/* begin AlignmentNops: */
	genoperand(AlignmentNops, alignment);
	(blockStart->fakeHeader = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	switch (sizeof(CogBlockMethod)) {
	case 8:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		genoperand(Fill32, 0);
		break;
	case 12:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		genoperand(Fill32, 0);
		genoperand(Fill32, 0);
		break;
	case 16:
		/* begin Fill32: */
		genoperand(Fill32, 0);
		genoperand(Fill32, 0);
		genoperand(Fill32, 0);
		genoperand(Fill32, 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	(blockStart->entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (needsFrame) {
		compileBlockFrameBuild(blockStart);
		if (recordBlockTrace()) {
			/* begin CallRT: */
			abstractInstruction = genoperand(Call, ceTraceBlockActivationTrampoline);
			(abstractInstruction->annotation = IsRelativeCall);
		}
	}
	else {
		compileBlockFramelessEntry(blockStart);
	}
}


/*	Generate a call to aRoutine with up to 4 arguments. If resultRegOrNone is
	not NoReg assign the C result to resultRegOrNone. If saveRegs, save all
	registers. Hack: a negative arg value indicates an abstract register, a
	non-negative value
	indicates a constant. The encoding for constants is defined by
	trampolineArgConstant: & trampolineArgValue:. Pass a constant as the
	result of trampolineArgConstant:. */

	/* Cogit>>#compileCallFor:numArgs:arg:arg:arg:arg:resultReg:regsToSave: */
static NoDbgRegParms void
compileCallFornumArgsargargargargresultRegregsToSave(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt resultRegOrNone, sqInt regMask)
{
    AbstractInstruction *anInstruction;
    const int cStackAlignment = STACK_ALIGN_BYTES;
    sqInt delta;
    sqInt numRegsPushed;
    usqInt regMaskCopy;
    sqInt regsToSave;
    sqInt wordsPushedModAlignment;

	regsToSave = (resultRegOrNone == NoReg
		? regMask
		: ((regMask | (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1U << resultRegOrNone)))) - (((resultRegOrNone < 0) ? (((usqInt)(1)) >> (-resultRegOrNone)) : (1U << resultRegOrNone)))));
	if (cStackAlignment > BytesPerWord) {
		/* begin genAlignCStackSavingRegisters:numArgs:wordAlignment: */
		regMaskCopy = ((usqInt)regsToSave);
		numRegsPushed = 0;
		while (regMaskCopy != 0) {
			numRegsPushed += regMaskCopy & 1;
			regMaskCopy = ((regMaskCopy) >> 1);
		}
		if ((numRegsPushed == 0)
		 && ((numIntRegArgs(((AbstractInstruction *) backEnd))) >= numArgs)) {
			goto l2;
		}
		wordsPushedModAlignment = (numRegsPushed + ((((numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd)))) < 0) ? 0 : (numArgs - (numIntRegArgs(((AbstractInstruction *) backEnd))))))) % (cStackAlignment / BytesPerWord);
		if (wordsPushedModAlignment != 0) {
			delta = (cStackAlignment / BytesPerWord) - wordsPushedModAlignment;
			/* begin SubCq:R: */
			anInstruction = genoperandoperand(SubCqR, delta * BytesPerWord, SPReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteral(delta * BytesPerWord));
			}
		}
	l2:	/* end genAlignCStackSavingRegisters:numArgs:wordAlignment: */;
	}
	/* begin genPushRegisterMask: */
	if (regsToSave == 0) {
		/* begin Label */
		genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		genoperand(PushSTM, regsToSave);
	}
	genMarshallNArgsargargargarg(backEnd, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3);
	/* begin gen:literal: */
	checkLiteralforInstruction(((usqInt)aRoutine), genoperand(CallFull, ((usqInt)aRoutine)));
	genWriteCResultIntoReg(backEnd, resultRegOrNone);
	/* begin genRemoveNArgsFromStack: */
	assert(numArgs <= 4);
	/* begin genPopRegisterMask: */
	if (regsToSave == 0) {
		/* begin Label */
		genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		genoperand(PopLDM, regsToSave);
	}
}


/*	Compile the cache tag computation and the first comparison. Answer the
	address of that comparison. */

	/* Cogit>>#compileCPICEntry */
static AbstractInstruction *
compileCPICEntry(void)
{
	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, TempReg);
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}


/*	The entry code to a method checks that the class of the current receiver
	matches that in the inline cache. Other non-obvious elements are that its
	alignment must be
	different from the alignment of the noCheckEntry so that the method map
	machinery can distinguish normal and super sends (super sends bind to the
	noCheckEntry).  */

	/* Cogit>>#compileEntry */
static void
compileEntry(void)
{
    AbstractInstruction *inst;

	entry = genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, TempReg, 1);
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, TempReg);
	/* begin JumpNonZero: */
	genConditionalBranchoperand(JumpNonZero, ((sqInt)sendMiss));
	noCheckEntry = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (((traceFlags & 64) == 64)) {
		/* begin saveAndRestoreLinkRegAround: */
		inst = genoperand(PushR, LinkReg);
		checkLiteralforInstruction(ceTraceLinkedSendTrampoline, genoperand(CallFull, ceTraceLinkedSendTrampoline));
		genoperand(PopR, LinkReg);
	}
}


/*	Compile the top-level method body. */

	/* Cogit>>#compileMethodBody */
static sqInt
compileMethodBody(void)
{
	if (endPC < initialPC) {
		return 0;
	}
	return compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
}


/*	The start of a PIC has a call to a run-time abort routine that either
	handles a dispatch to an
	interpreted method or a dispatch of an MNU case. The routine selects the
	path by testing
	ClassReg, which holds the inline cache tag; if equal to the
	picAbortDiscriminatorValue (zero)
	it takes the MNU path; if nonzero the dispatch to interpreter path.
	Neither of these paths
	returns. The abort routine must be called; In the callee the PIC is
	located by adding the
	relevant offset to the return address of the call.
	
	N.B. This code must match that in compileAbort so that the offset of the
	return address of
	the call is the same in methods and closed PICs. */

	/* Cogit>>#compilePICAbort: */
static NoDbgRegParms sqInt
compilePICAbort(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    sqInt callTarget;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0 /* begin picAbortDiscriminatorValue */, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0 /* begin picAbortDiscriminatorValue */));
	}
	picMNUAbort = anInstruction;
	picInterpretAbort = genoperand(PushR, LinkReg);
	callTarget = picAbortTrampolineFor(numArgs);
	/* begin Call: */
	genoperand(Call, callTarget);
	return 0;
}


/*	Compile the compare of stackLimit against the stack pointer, jumping to
	the stackOverflowCall if
	the stack pointer is below the limit. Answer a bytecode annotated label
	that follows the sequence.
	
	The stack check functions both as a genuine stack limit check to prevent
	calls overflowing stack pages,
	and as an event/context-switch break out. To cause an event check
	(including a check for a required
	context switch), stackLimit is set to the highest possible value, and
	hence all stack limit checks will
	fail. A path in the stack overflow abort then arranges to call event
	checking if it has been requested.
	
	Certain block activations (e.g. valueNoContextSwitch:) must not context
	switch, and in that
	case, SendNumArgs is set to zero to communicate to the stack overflow
	abort that it should
	not perform event/context-switch (yet). */

	/* Cogit>>#compileStackOverflowCheck: */
static NoDbgRegParms AbstractInstruction *
compileStackOverflowCheck(sqInt canContextSwitch)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSkip;
    AbstractInstruction *label;


	/* begin gen:literal:operand: */
	checkLiteralforInstruction(stackLimitAddress(), genoperandoperand(MoveAwR, stackLimitAddress(), TempReg));
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, SPReg);
	if (canContextSwitch) {
		/* begin JumpBelow: */
		genConditionalBranchoperand(JumpBelow, ((sqInt)stackOverflowCall));
		label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	}
	else {
		jumpSkip = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(0));
		}
		/* begin Jump: */
		genoperand(Jump, ((sqInt)stackOverflowCall));
		jmpTarget(jumpSkip, (label = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	}
	/* begin annotateBytecode: */
	(label->annotation = HasBytecodePC);
	return label;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutine
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C
	result back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#compileTrampolineFor:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg: */
static NoDbgRegParms void
compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(void *aRoutine, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone)
{
	genSmalltalkToCStackSwitch(pushLinkReg);
	compileCallFornumArgsargargargargresultRegregsToSave(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, resultRegOrNone, regMask);
	genLoadStackPointers(backEnd);
	genTrampolineReturn(pushLinkReg);
}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeEntryOffsets */
static void
computeEntryOffsets(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;
    AbstractInstruction *sendMissCall;


	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 24;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	methodOrBlockNumArgs = 0;
	sendMissCall = compileAbort();
	compileEntry();
	computeMaximumSizes();
	generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	cmEntryOffset = ((entry->address)) - methodZoneBase;
	cmNoCheckEntryOffset = ((noCheckEntry->address)) - methodZoneBase;
	missOffset = (((sendMissCall->address)) + ((sendMissCall->machineCodeSize))) - methodZoneBase;
	entryPointMask = BytesPerWord - 1;
	while ((cmEntryOffset & entryPointMask) == (cmNoCheckEntryOffset & entryPointMask)) {
		entryPointMask = (entryPointMask + entryPointMask) + 1;
	}
	if (entryPointMask >= (roundUpToMethodAlignment(backEnd(), 1))) {
		error("cannot differentiate checked and unchecked entry-points with current cog method alignment");
	}
	checkedEntryAlignment = cmEntryOffset & entryPointMask;
	uncheckedEntryAlignment = cmNoCheckEntryOffset & entryPointMask;
	assert(checkedEntryAlignment != uncheckedEntryAlignment);
}


/*	Generate the entry code for a method to determine cmEntryOffset and
	cmNoCheckEntryOffset. We
	need cmNoCheckEntryOffset up front to be able to generate the map starting
	from cmNoCheckEntryOffset */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#computeFullBlockEntryOffsets */
static void
computeFullBlockEntryOffsets(void)
{
}


/*	While we order variables in the CoInterpreter in order of dynamic
	frequency, and hence
	expect that stackPointer will be output first, C optimizers and linkers
	may get their own
	ideas and ``improve upon'' this ordering. So we cannot depend on
	stackPointer being
	at the lowest address of the variables we want to access through
	VarBaseReg. Here we
	choose the minimum amongst a set to try to choose a varBaseAddress that is
	just less
	than but within range of all variables we want to access through it. */

	/* Cogit>>#computeGoodVarBaseAddress */
static usqInt
computeGoodVarBaseAddress(void)
{
    usqInt minAddress;


	/* stackLimit was e.g. lowest using the clang toolchain on MacOS X (prior to the use of variable_order) */
	minAddress = stackLimitAddress();
	if ((stackPointerAddress()) < minAddress) {
		minAddress = stackPointerAddress();
	}
	if ((framePointerAddress()) < minAddress) {
		minAddress = framePointerAddress();
	}
	if ((instructionPointerAddress()) < minAddress) {
		minAddress = instructionPointerAddress();
	}
	if ((argumentCountAddress()) < minAddress) {
		minAddress = argumentCountAddress();
	}
	if ((primFailCodeAddress()) < minAddress) {
		minAddress = primFailCodeAddress();
	}
	return minAddress;
}


/*	This pass assigns maximum sizes to all abstract instructions and
	eliminates jump fixups.
	It hence assigns the maximum address an instruction will occur at which
	allows the next
	pass to conservatively size jumps. */

	/* Cogit>>#computeMaximumSizes */
static void
computeMaximumSizes(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt relativeAddress;

	dumpLiterals(0);
	relativeAddress = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		maybeBreakGeneratingInstructionWithIndex(i);
		abstractInstruction = abstractInstructionAt(i);
		(abstractInstruction->address = relativeAddress);
		(abstractInstruction->maxSize = computeMaximumSize(abstractInstruction));
		relativeAddress += (abstractInstruction->maxSize);
	}
}


/*	Configure a copy of the prototype CPIC for a two-case PIC for 
	case0CogMethod and
	case1Method
	case1Tag.
	The tag for case0CogMethod is at the send site and so doesn't need to be
	generated. case1Method may be any of
	- a Cog method; jump to its unchecked entry-point
	- a CompiledMethod; jump to the ceInterpretFromPIC trampoline
	- nil; call ceMNUFromPIC
	addDelta is the address change from the prototype to the new CPIC
	location, needed
	because the loading of the CPIC label at the end may use a literal instead
	of a pc relative load. */
/*	self disassembleFrom: cPIC asInteger + (self sizeof: CogMethod) to: cPIC
	asInteger + closedPICSize
 */

	/* Cogit>>#configureCPIC:Case0:Case1Method:tag:isMNUCase:numArgs:delta: */
static NoDbgRegParms sqInt
configureCPICCase0Case1MethodtagisMNUCasenumArgsdelta(CogMethod *cPIC, CogMethod *case0CogMethod, sqInt case1Method, sqInt case1Tag, sqInt isMNUCase, sqInt numArgs, sqInt addrDelta)
{
    sqInt caseEndAddress;
    int operand;
    sqInt targetEntry;

	assert(case1Method);
	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));
	assert(!(inlineCacheTagIsYoung(case1Tag)));
	if ((!isMNUCase)
	 && (methodHasCogMethod(case1Method))) {
		operand = 0;
		targetEntry = (((sqInt)(cogMethodOf(case1Method)))) + cmNoCheckEntryOffset;
	}
	else {
		/* We do not scavenge PICs, hence we cannot cache the MNU method if it is in new space. */
		operand = ((!case1Method)
		 || (isYoungObject(case1Method))
			? 0
			: case1Method);
		targetEntry = (case1Method == null
			? (((sqInt)cPIC)) + (sizeof(CogMethod))
			: (((sqInt)cPIC)) + (picInterpretAbortOffset()));
	}
	rewriteJumpLongAttarget(backEnd, (((sqInt)cPIC)) + firstCPICCaseOffset, (((sqInt)case0CogMethod)) + cmNoCheckEntryOffset);
	/* update the cpic case */
	caseEndAddress = addressOfEndOfCaseinCPIC(2, cPIC);
	rewriteCPICCaseAttagobjReftarget(caseEndAddress, case1Tag, operand, ((sqInt)((isMNUCase
	? (((sqInt)cPIC)) + (sizeof(CogMethod))
	: targetEntry))));
	relocateMethodReferenceBeforeAddressby(backEnd, ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd)), addrDelta);
	rewriteJumpLongAttarget(backEnd, (((sqInt)cPIC)) + cPICEndOfCodeOffset, cPICMissTrampolineFor(numArgs));
	return 0;
}


/*	Configure a copy of the prototype CPIC for a one-case MNU CPIC that calls
	ceMNUFromPIC for
	case0Tag The tag for case0 is at the send site and so doesn't need to be
	generated. addDelta is the address change from the prototype to the new
	CPIC location, needed
	because the loading of the CPIC label at the end may be a literal instead
	of a pc-relative load. */
/*	adjust the jump at missOffset, the ceAbortXArgs */

	/* Cogit>>#configureMNUCPIC:methodOperand:numArgs:delta: */
static NoDbgRegParms sqInt
configureMNUCPICmethodOperandnumArgsdelta(CogMethod *cPIC, sqInt methodOperand, sqInt numArgs, sqInt addrDelta)
{
    usqInt addressFollowingJump;
    int operand;
    sqInt target;

	rewriteCallAttarget(backEnd, (((sqInt)cPIC)) + missOffset, picAbortTrampolineFor(numArgs));
	/* set the jump to the case0 method */
	operand = ((!methodOperand)
	 || (isYoungObject(methodOperand))
		? 0
		: methodOperand);
	rewriteJumpLongAttarget(backEnd, (((sqInt)cPIC)) + firstCPICCaseOffset, (((sqInt)cPIC)) + (sizeof(CogMethod)));
	storeLiteralbeforeFollowingAddress(backEnd, operand, ((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd)));
	rewriteJumpLongAttarget(backEnd, (((sqInt)cPIC)) + cPICEndOfCodeOffset, cPICMissTrampolineFor(numArgs));
	relocateMethodReferenceBeforeAddressby(backEnd, ((((sqInt)cPIC)) + cPICEndOfCodeOffset) - (jumpLongByteSize(backEnd)), addrDelta);
	target = addressOfEndOfCaseinCPIC(2, cPIC);
	/* begin rewriteCPIC:caseJumpTo: */
	addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
	rewriteTransferAttarget(((AbstractInstruction *) backEnd), addressFollowingJump, target);
	return 0;
}


/*	Scan the CPIC for target methods that have been freed and eliminate them.
	Since the first entry cannot be eliminated, answer that the PIC should be
	freed if the first entry is to a free target. Answer if the PIC is now
	empty or should be freed. */

	/* Cogit>>#cPICCompactAndIsNowEmpty: */
static NoDbgRegParms sqInt
cPICCompactAndIsNowEmpty(CogMethod *cPIC)
{
    usqInt addressFollowingJump;
    usqInt addressFollowingJump1;
    sqInt entryPoint;
    sqInt i;
    sqInt methods[MaxCPICCases];
    sqInt pc;
    int tags[MaxCPICCases];
    CogMethod *targetMethod;
    sqInt targets[MaxCPICCases];
    sqInt used;
    sqInt valid;

	used = 0;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		entryPoint = (jumpLongTargetBeforeFollowingAddress(backEnd, pc));
		/* Collect all target triples except for triples whose entry-point is a freed method */
		valid = 1;
		if (!(			/* begin containsAddress: */
				((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
			 || (isCMFree(((CogBlockMethod *) targetMethod))));
			if (((targetMethod->cmType)) == CMFree) {
				if (i == 1) {
					return 1;
				}
				valid = 0;
			}
		}
		if (valid) {
			tags[used] = ((i > 1
	? literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd)))
	: 0));
			targets[used] = entryPoint;
			methods[used] = (literalBeforeFollowingAddress(backEnd, pc - ((i == 1
	? jumpLongByteSize(backEnd)
	: (jumpLongConditionalByteSize(backEnd)) + (cmpC32RTempByteSize(backEnd))))));
			used += 1;
		}
	}
	if (used == ((cPIC->cPICNumCases))) {
		return 0;
	}
	if (used == 0) {
		return 1;
	}
	((((CogMethod *) ((((usqInt)cPIC)) + codeToDataDelta)))->cPICNumCases = used);
	if (used == 1) {
		pc = addressOfEndOfCaseinCPIC(2, cPIC);
		/* begin rewriteCPIC:caseJumpTo: */
		addressFollowingJump = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
		rewriteTransferAttarget(((AbstractInstruction *) backEnd), addressFollowingJump, pc);
		return 0;
	}
	for (i = 1; i < used; i += 1) {
		pc = addressOfEndOfCaseinCPIC(i + 1, cPIC);
		rewriteCPICCaseAttagobjReftarget(pc, tags[i], methods[i], targets[i]);
	}
	/* begin rewriteCPIC:caseJumpTo: */
	addressFollowingJump1 = (((((sqInt)cPIC)) + firstCPICCaseOffset) - (jumpLongByteSize(backEnd))) - (loadLiteralByteSize(backEnd));
	rewriteTransferAttarget(((AbstractInstruction *) backEnd), addressFollowingJump1, pc - cPICCaseSize);
	return 0;
}


/*	scan the CPIC for target methods that have been freed. */

	/* Cogit>>#cPICHasFreedTargets: */
static NoDbgRegParms sqInt
cPICHasFreedTargets(CogMethod *cPIC)
{
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    CogMethod *targetMethod;

	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		/* Find target from jump.  Ignore jumps to the interpret and MNU calls within this PIC */
		entryPoint = (jumpLongTargetBeforeFollowingAddress(backEnd, pc));
		if (!(			/* begin containsAddress: */
				((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
			 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint))))) {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
			 || (isCMFree(((CogBlockMethod *) targetMethod))));
			if (((targetMethod->cmType)) == CMFree) {
				return 1;
			}
		}
	}
	return 0;
}


/*	Whimsey; we want 16rCA5E10 + cPICPrototypeCaseOffset to be somewhere in
	the middle of the zone.
 */

	/* Cogit>>#cPICPrototypeCaseOffset */
static usqInt
cPICPrototypeCaseOffset(void)
{
	return ((methodZoneBase + (youngReferrers())) / 2) - 13262352;
}


/*	Are any of the jumps from this CPIC to targetMethod? */

	/* Cogit>>#cPIC:HasTarget: */
static NoDbgRegParms sqInt
cPICHasTarget(CogMethod *cPIC, CogMethod *targetMethod)
{
    sqInt i;
    sqInt pc;
    sqInt target;

	target = (((usqInt)targetMethod)) + cmNoCheckEntryOffset;
	/* Since this is a fast test doing simple compares we don't need to care that some
	   cases have nonsense addresses in there. Just zip on through. */
	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
		return 1;
	}
	for (i = 2; i <= MaxCPICCases; i += 1) {
		pc += cPICCaseSize;
		if (target == (jumpLongTargetBeforeFollowingAddress(backEnd, pc))) {
			return 1;
		}
	}
	return 0;
}


/*	Answer an Array of the PIC's selector, followed by class and
	targetMethod/doesNotUnderstand: for each entry in the PIC.
 */

	/* Cogit>>#createCPICData: */
static NoDbgRegParms sqInt
createCPICData(CogMethod *cPIC)
{
    sqInt class;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt picData;
    sqInt target;
    CogMethod *targetMethod;

	assert((((cPIC->methodObject)) == 0)
	 || (addressCouldBeOop((cPIC->methodObject))));
	picData = instantiateClassindexableSize(classArray(), (((cPIC->cPICNumCases)) * 2) + 1);
	if (!picData) {
		return picData;
	}
	storePointerUncheckedofObjectwithValue(0, picData, (cPIC->selector));
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		if (i == 1) {
			/* first case may have been collected and stored here by collectCogConstituentFor:Annotation:Mcpc:Bcpc:Method: */
			class = (cPIC->methodObject);
			if (class == 0) {
				class = nilObject();
			}
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		else {
			class = classForInlineCacheTag(literal32BeforeFollowingAddress(backEnd, pc - (jumpLongConditionalByteSize(backEnd))));
			entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		}
		if (		/* begin containsAddress: */
			((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
			target = splObj(SelectorDoesNotUnderstand);
		}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(isCMMethodEtAl(((CogBlockMethod *) targetMethod)));
			target = (targetMethod->methodObject);
		}
		storePointerUncheckedofObjectwithValue((i * 2) - 1, picData, class);
		storePointerUncheckedofObjectwithValue(i * 2, picData, target);
	}
	beRootIfOld(picData);
	(cPIC->methodObject = 0);
	return picData;
}


/*	Division is a little weird on some processors. Defer to the backEnd
	to allow it to generate any special code it may need to. */

	/* Cogit>>#DivR:R:Quo:Rem: */
static NoDbgRegParms AbstractInstruction *
gDivRRQuoRem(sqInt rDivisor, sqInt rDividend, sqInt rQuotient, sqInt rRemainder)
{
	genDivRRQuoRem(backEnd, rDivisor, rDividend, rQuotient, rRemainder);
	return abstractInstructionAt(opcodeIndex - 1);
}


/*	Return the default number of bytes to allocate for native code at startup.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file. */

	/* Cogit>>#defaultCogCodeSize */
int
defaultCogCodeSize(void)
{
	return 0x140000;
}


/*	Answer the number of bytecodes to skip to get to the first bytecode
	past the primitive call and any store of the error code. */

	/* Cogit>>#deltaToSkipPrimAndErrorStoreIn:header: */
static NoDbgRegParms sqInt
deltaToSkipPrimAndErrorStoreInheader(sqInt aMethodObj, sqInt aMethodHeader)
{
	return (	/* begin methodUsesPrimitiveErrorCode:header: */
		((primitiveIndexOfMethodheader(aMethodObj, aMethodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(aMethodHeader)) == (fetchByteofObject((startPCOfMethodHeader(aMethodHeader)) + (sizeOfCallPrimitiveBytecode(aMethodHeader)), aMethodObj)))
		? (sizeOfCallPrimitiveBytecode(aMethodHeader)) + (sizeOfLongStoreTempBytecode(aMethodHeader))
		: 0);
}

	/* Cogit>>#endPCOf: */
static NoDbgRegParms sqInt
endPCOf(sqInt aMethod)
{
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt end;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt pc;
    sqInt prim;
    sqInt targetPC;

	pc = (latestContinuation = startPCOfMethod(aMethod));
	if (((prim = primitiveIndexOf(aMethod))) > 0) {
		if (isQuickPrimitiveIndex(prim)) {
			return pc - 1;
		}
	}
	/* begin bytecodeSetOffsetFor: */
	assert(!((methodUsesAlternateBytecodeSet(aMethod))));
	bsOffset = 0;
	nExts = 0;
	end = numBytesOf(aMethod);
	while (pc <= end) {
		byte = fetchByteofObject(pc, aMethod);
		descriptor = generatorAt(byte + bsOffset);
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			end = pc;
		}
		if ((isBranch(descriptor))
		 || ((descriptor->isBlockCreation))) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, aMethod);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			if ((descriptor->isBlockCreation)) {
				pc += distance;
			}
		}
		else {
		}
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
		pc += (descriptor->numBytes);
	}
	return end;
}


/*	This is a static version of ceEnterCogCodePopReceiverReg for
	break-pointing when debugging in C. Marked <api> so the code generator
	won't delete it. */

	/* Cogit>>#enterCogCodePopReceiver */
static void
enterCogCodePopReceiver(void)
{
	realCEEnterCogCodePopReceiverReg();
	if (!Debug) {
		error("what??");
	}
}


/*	Answer if the entryPoint's tag is expected to be a selector reference, as
	opposed to a class tag.
 */

	/* Cogit>>#entryPointTagIsSelector: */
static NoDbgRegParms sqInt
entryPointTagIsSelector(sqInt entryPoint)
{
	return (entryPoint < methodZoneBase)
	 || (((entryPoint & entryPointMask) == uncheckedEntryAlignment)
	 || (((entryPoint & entryPointMask) == checkedEntryAlignment)
	 && ((((((CogMethod *) (entryPoint - cmEntryOffset)))->cmType)) == CMOpenPIC)));
}


/*	Use asserts to check if the ClosedPICPrototype is as expected from
	compileClosedPICPrototype, and can be updated as required via
	rewriteCPICCaseAt:tag:objRef:target:. If all asserts pass, answer
	0, otherwise answer a bit mask identifying all the errors. */
/*	self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to:
	methodZoneBase + closedPICSize
 */

	/* Cogit>>#expectedClosedPICPrototype: */
static NoDbgRegParms sqInt
expectedClosedPICPrototype(CogMethod *cPIC)
{
    sqInt classTag;
    sqInt classTagPC;
    sqInt entryPoint;
    sqInt errors;
    sqInt i;
    sqInt methodObjPC;
    sqInt object;
    sqInt pc;

	errors = 0;
	/* First jump is unconditional; subsequent ones are conditional */
	pc = (((usqInt)cPIC)) + firstCPICCaseOffset;
	object = literalBeforeFollowingAddress(backEnd, pc - (jumpLongByteSize(backEnd)));
	if (!(asserta(object == (firstPrototypeMethodOop())))) {
		errors = 1;
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
	if (!(asserta(entryPoint == ((cPICPrototypeCaseOffset()) + 13262352)))) {
		errors += 2;
	}
	for (i = 1; i < MaxCPICCases; i += 1) {
		/* verify information in case is as expected. */
		pc += cPICCaseSize;
		methodObjPC = (pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == ((subsequentPrototypeMethodOop()) + i)))) {
			errors = errors | 4;
		}
		classTagPC = pc - (jumpLongConditionalByteSize(backEnd));
		classTag = 
		/* begin literal32BeforeFollowingAddress: */
literalBeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == (0xBABE1F15U + i)))) {
			errors = errors | 8;
		}
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		if (!(asserta(entryPoint == (((cPICPrototypeCaseOffset()) + 13262352) + (i * 16))))) {
			errors = errors | 16;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 0x5A5A5A5A, object ^ 0xA5A5A5A5U, entryPoint ^ 0x55AA50);
		object = literalBeforeFollowingAddress(backEnd, methodObjPC);
		if (!(asserta(object == (((subsequentPrototypeMethodOop()) + i) ^ 0xA5A5A5A5U)))) {
			errors = errors | 32;
		}
		classTag = 
		/* begin literal32BeforeFollowingAddress: */
literalBeforeFollowingAddress(backEnd, classTagPC);
		if (!(asserta(classTag == ((0xBABE1F15U + i) ^ 0x5A5A5A5A)))) {
			errors = errors | 64;
		}
		entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, pc);
		if (!(asserta(entryPoint == ((((cPICPrototypeCaseOffset()) + 13262352) + (i * 16)) ^ 0x55AA50)))) {
			errors = errors | 128;
		}
		rewriteCPICCaseAttagobjReftarget(pc, classTag ^ 0x5A5A5A5A, object ^ 0xA5A5A5A5U, entryPoint ^ 0x55AA50);
	}
	entryPoint = jumpLongTargetBeforeFollowingAddress(backEnd, (((usqInt)cPIC)) + cPICEndOfCodeOffset);
	if (!(asserta(entryPoint == (cPICMissTrampolineFor(0))))) {
		errors += 0x100;
	}
	return errors;
}


/*	Fill in the block headers now we know the exact layout of the code. */

	/* Cogit>>#fillInBlockHeadersAt: */
static NoDbgRegParms sqInt
fillInBlockHeadersAt(sqInt startAddress)
{
    sqInt aCogMethodOrInteger;
    CogBlockMethod *blockHeader;
    BlockStart *blockStart;
    sqInt i;

	if (!(needsFrame
		 && (blockCount > 0))) {
		return null;
	}
	if (blockNoContextSwitchOffset == null) {
		blockNoContextSwitchOffset = ((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address));
	}
	else {
		assert(blockNoContextSwitchOffset == (((blockEntryLabel->address)) - ((blockEntryNoContextSwitch->address))));
	}
	for (i = 0; i < blockCount; i += 1) {
		blockStart = blockStartAt(i);
		aCogMethodOrInteger = (((blockStart->fakeHeader))->address);
		/* begin writableBlockMethodFor: */
		blockHeader = ((CogBlockMethod *) ((((usqInt)aCogMethodOrInteger)) + codeToDataDelta));
		(blockHeader->homeOffset = ((((blockStart->fakeHeader))->address)) - startAddress);
		(blockHeader->startpc = (blockStart->startpc));
		(blockHeader->cmType = CMBlock);
		(blockHeader->cmNumArgs = (blockStart->numArgs));
		(blockHeader->cbUsesInstVars = (blockStart->hasInstVarRef));
		(blockHeader->stackCheckOffset = (((blockStart->stackCheckLabel)) == null
			? 0
			: ((((blockStart->stackCheckLabel))->address)) - ((((blockStart->fakeHeader))->address))));
	}
	return 0;
}


/*	Fill in the header for theCogMethod method. This may be located at the
	writable mapping. */

	/* Cogit>>#fillInMethodHeader:size:selector: */
static NoDbgRegParms void
fillInMethodHeadersizeselector(CogMethod *method, sqInt size, sqInt selector)
{
    sqInt actualMethodLocation;
    CogMethod *originalMethod;
    sqInt rawHeader;

	actualMethodLocation = (((usqInt)method)) - codeToDataDelta;
	(method->cmType = CMMethod);
	(method->objectHeader = nullHeaderForMachineCodeMethod());
	(method->blockSize = size);
	(method->methodObject = methodObj);
	/* If the method has already been cogged (e.g. Newspeak accessors) then
	   leave the original method attached to its cog method, but get the right header. */
	rawHeader = rawHeaderOf(methodObj);
	if (isCogMethodReference(rawHeader)) {
		originalMethod = ((CogMethod *) rawHeader);
		assert(((originalMethod->blockSize)) == size);
		assert(methodHeader == ((originalMethod->methodHeader)));
	}
	else {
		rawHeaderOfput(methodObj, actualMethodLocation);
	}
	(method->methodHeader = methodHeader);
	(method->selector = selector);
	(method->cmNumArgs = argumentCountOfMethodHeader(methodHeader));
	(method->cmHasMovableLiteral = hasMovableLiteral);
	if ((method->cmRefersToYoung = hasYoungReferent)) {
		addToYoungReferrers(method);
	}
	(method->cmUsageCount = initialMethodUsageCount());
	/* begin cpicHasMNUCase: */
	(method->cpicHasMNUCaseOrCMIsFullBlock) = 0;
	(method->cmUsesPenultimateLit = maxLitIndex >= ((literalCountOfMethodHeader(methodHeader)) - 2));
	(method->blockEntryOffset = (blockEntryLabel
		? ((blockEntryLabel->address)) - actualMethodLocation
		: 0));
	if (needsFrame) {
		if (!((((stackCheckLabel->address)) - actualMethodLocation) <= MaxStackCheckOffset)) {
			error("too much code for stack check offset");
		}
	}
	(method->stackCheckOffset = (needsFrame
		? ((stackCheckLabel->address)) - actualMethodLocation
		: 0));
	assert((callTargetFromReturnAddress(backEnd, actualMethodLocation + missOffset)) == (methodAbortTrampolineFor((method->cmNumArgs))));
	assert(size == (roundUpLength(size)));
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, actualMethodLocation + cmNoCheckEntryOffset, codeToDataDelta);
#  endif
}

	/* Cogit>>#findBackwardBranch:IsBackwardBranch:Mcpc:Bcpc:MatchingBcpc: */
static NoDbgRegParms sqInt
findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetBcpc)
{
	return ((((isBackwardBranchAndAnnotation & 1) != 0))
	 && ((((sqInt)targetBcpc)) == bcpc)
		? ((sqInt)mcpc)
		: 0);
}

	/* Cogit>>#findBlockMethodWithEntry:startBcpc: */
static NoDbgRegParms usqInt
findBlockMethodWithEntrystartBcpc(sqInt blockEntryMcpc, sqInt startBcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((cogBlockMethod->startpc)) == startBcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}

	/* Cogit>>#findMapLocationForMcpc:inMethod: */
static NoDbgRegParms usqInt
findMapLocationForMcpcinMethod(usqInt targetMcpc, CogMethod *cogMethod)
{
    sqInt annotation;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;

	mcpc = 
	/* begin firstMappedPCFor: */
(((usqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	if (mcpc == targetMcpc) {
		return map;
	}
	while (((mapByte = byteAt(map))) != MapEnd) {
		annotation = ((usqInt)(mapByte)) >> AnnotationShift;
		if (annotation != IsAnnotationExtension) {
			mcpc += 4 /* begin codeGranularity */ * ((annotation == IsDisplacementX2N
	? ((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))
	: mapByte & DisplacementMask));
		}
		if (mcpc >= targetMcpc) {
			assert(mcpc == targetMcpc);
			if (annotation == IsDisplacementX2N) {
				map -= 1;
				mapByte = byteAt(map);
				annotation = ((usqInt)(mapByte)) >> AnnotationShift;
				assert(annotation > IsAnnotationExtension);
			}
			return map;
		}
		map -= 1;
	}
	return 0;
}


/*	Find the CMMethod or CMBlock that has zero-relative startbcpc as its first
	bytecode pc.
	As this is for cannot resume processing and/or conversion to machine-code
	on backward
	branch, it doesn't have to be fast. Enumerate block returns and map to
	bytecode pcs. */

	/* Cogit>>#findMethodForStartBcpc:inHomeMethod: */
CogBlockMethod *
findMethodForStartBcpcinHomeMethod(sqInt startbcpc, CogMethod *cogMethod)
{
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	if (startbcpc == (startPCOfMethodHeader((cogMethod->methodHeader)))) {
		return ((CogBlockMethod *) cogMethod);
	}
	assert(((cogMethod->blockEntryOffset)) != 0);
	return ((CogBlockMethod *) (blockDispatchTargetsForperformarg(cogMethod, findBlockMethodWithEntrystartBcpc, startbcpc)));
}


/*	Machine code addresses map to the following bytecode for all bytecodes
	except backward branches, where they map to the backward branch itself.
	This is so that loops continue, rather than terminate prematurely. */

	/* Cogit>>#find:IsBackwardBranch:Mcpc:Bcpc:MatchingMcpc: */
static NoDbgRegParms sqInt
findIsBackwardBranchMcpcBcpcMatchingMcpc(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *targetMcpc)
{
	return (targetMcpc == mcpc
		? ((!descriptor)
			 || (((isBackwardBranchAndAnnotation & 1) != 0))
				? bcpc
				: bcpc + ((descriptor->numBytes)))
		: 0);
}

	/* Cogit>>#firstMappedPCFor: */
static NoDbgRegParms sqInt
firstMappedPCFor(CogMethod *cogMethod)
{
	return (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
}


/*	Answer a fake value for the first method oop in the PIC prototype.
	Since we use MoveUniqueCw:R: it must not be confused with a
	method-relative address. */

	/* Cogit>>#firstPrototypeMethodOop */
static sqInt
firstPrototypeMethodOop(void)
{
	return (	/* begin addressIsInCurrentCompilation: */
		((((usqInt)0x5EAF00D)) >= ((methodLabel->address)))
	 && ((((usqInt)0x5EAF00D)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))
		? 0xCA7F00D
		: 0x5EAF00D);
}

	/* Cogit>>#fixupAt: */
static NoDbgRegParms BytecodeFixup *
fixupAt(sqInt fixupPC)
{
	return fixupAtIndex(fixupPC - initialPC);
}

	/* Cogit>>#flagCogMethodForBecome: */
void
flagCogMethodForBecome(CogMethod *cogMethod)
{
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMMethodFlaggedForBecome);
}


/*	N.B. because becomeEffectFlags indicates whether jitted methods were
	becommed or not, if this method is called flagged methods exist, will be
	freed, and so on. So there is no need to check. Just do it. */

	/* Cogit>>#freeBecomeFlaggedMethods */
void
freeBecomeFlaggedMethods(void)
{
    CogMethod *cogMethod;


	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	unlinkSendsToFree();
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}

	/* Cogit>>#freeCogMethod: */
void
freeCogMethod(CogMethod *cogMethod)
{
	moveProfileToMethods();
	freeMethod(cogMethod);
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}


/*	Call ceSendMustBeBooleanTo: via the relevant trampoline. */

	/* Cogit>>#genCallMustBeBooleanFor: */
static NoDbgRegParms AbstractInstruction *
genCallMustBeBooleanFor(sqInt boolean)
{
    AbstractInstruction *abstractInstruction;
    sqInt callTarget;

	callTarget = (boolean == (falseObject())
		? ceSendMustBeBooleanAddFalseTrampoline
		: ceSendMustBeBooleanAddTrueTrampoline);
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, callTarget);
	(abstractInstruction->annotation = IsRelativeCall);
	return abstractInstruction;
}

	/* Cogit>>#genConditionalBranch:operand: */
static NoDbgRegParms AbstractInstruction *
genConditionalBranchoperand(sqInt opcode, sqInt operandOne)
{
	return genoperand(opcode, operandOne);
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. The desired arguments and entry-point are pushed on a stackPage's
	stack. The enilopmart pops off the values to be loaded into registers and
	then executes a return instruction to pop off the entry-point and jump to
	it. 
	BEFORE				AFTER			(stacks grow down)
	whatever			stackPointer ->	whatever
	target address =>	reg1 = reg1val, etc
	reg1val				pc = target address
	reg2val
	stackPointer ->	reg3val */

	/* Cogit>>#genEnilopmartFor:and:and:forCall:called: */
static NoDbgRegParms void
(*genEnilopmartForandandforCallcalled(sqInt regArg1, sqInt regArg2OrNone, sqInt regArg3OrNone, sqInt forCall, char *trampolineName))(void)
{
    AbstractInstruction *anInstruction;
    sqInt endAddress;
    usqInt enilopmart;
    sqInt quickConstant;
    sqInt size;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	genLoadStackPointers(backEnd);
	if (regArg3OrNone != NoReg) {
		/* begin PopR: */
		genoperand(PopR, regArg3OrNone);
	}
	if (regArg2OrNone != NoReg) {
		/* begin PopR: */
		genoperand(PopR, regArg2OrNone);
	}
	genoperand(PopR, regArg1);
	genEnilopmartReturn(forCall);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineName, enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	An enilopmart (the reverse of a trampoline) is a piece of code that makes
	the system-call-like transition from the C runtime into generated machine
	code. At the point the enilopmart enters machine code via a return
	instruction, any argument registers have been loaded with their values and
	the stack, if
	for call, looks like
	ret pc
	stackPointer ->	target address
	
	and if not for call, looks like
	whatever
	stackPointer ->	target address
	
	If forCall and running on a CISC, ret pc must be left on the stack. If
	forCall and
	running on a RISC, ret pc must be popped into LinkReg. In either case,
	target address must be removed from the stack and jumped/returned to. */

	/* Cogit>>#genEnilopmartReturn: */
static NoDbgRegParms void
genEnilopmartReturn(sqInt forCall)
{
	if (forCall) {
		/* begin PopR: */
		genoperand(PopR, RISCTempReg);
		genoperand(PopR, LinkReg);
		genoperand(JumpR, RISCTempReg);
	}
	else {
		/* begin PopR: */
		genoperand(PopR, PCReg);
	}
}


/*	Generate the routine that writes the current values of the C frame and
	stack pointers into
	variables. These are used to establish the C stack in trampolines back
	into the C run-time.
	This routine assumes the system's frame pointer is the same as that used
	in generated code. */

	/* Cogit>>#generateCaptureCStackPointers: */
static NoDbgRegParms NeverInline void
generateCaptureCStackPointers(sqInt captureFramePointer)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt callerSavedReg;
    sqInt fixupSize;
    sqInt offset;
    sqInt opcodeSize;
    sqInt pushedVarBaseReg;
    sqInt quickConstant;
    usqInt startAddress;


	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 32;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	/* Must happen first; value may be used in accessing any of the following addresses */
	startAddress = methodZoneBase;
	callerSavedReg = 0;
	pushedVarBaseReg = 0;
	if (!(((CallerSavedRegisterMask & ((1U << VarBaseReg))) != 0))) {
		/* VarBaseReg is not caller-saved; must save and restore it, either by using an available caller-saved reg or push/pop. */
		/* TempReg used below */
		callerSavedReg = availableRegisterOrNoneIn(((ABICallerSavedRegisterMask | (1U << TempReg)) - (1U << TempReg)));
		if (callerSavedReg == NoReg) {
			gNativePushR(VarBaseReg);
			pushedVarBaseReg = 1;
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, VarBaseReg, callerSavedReg);
		}
	}
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	if (captureFramePointer) {
		/* begin gen:operand:literal: */
		checkLiteralforInstruction(cFramePointerAddress(), genoperandoperand(MoveRAw, FPReg, cFramePointerAddress()));
	}
	if (pushedVarBaseReg) {
		/* begin LoadEffectiveAddressMw:r:R: */
		offset = (pushedVarBaseReg
			? 0 /* begin leafCallStackPointerDelta */ + BytesPerWord
			: 0 /* begin leafCallStackPointerDelta */);
		/* begin gen:quickConstant:operand:operand: */
		anInstruction1 = genoperandoperandoperand(LoadEffectiveAddressMwrR, offset, NativeSPReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(offset));
		}
		/* begin gen:operand:literal: */
		checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveRAw, TempReg, cStackPointerAddress()));
	}
	else {
		/* begin gen:operand:literal: */
		checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveRAw, NativeSPReg, cStackPointerAddress()));
	}
	if (!(((CallerSavedRegisterMask & ((1U << VarBaseReg))) != 0))) {
		if (pushedVarBaseReg) {
			gNativePopR(VarBaseReg);
		}
		else {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, callerSavedReg, VarBaseReg);
		}
	}
	gNativeRetN(0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	flushICacheFromto(backEnd, ((usqInt)startAddress), ((usqInt)methodZoneBase));
	recordGeneratedRunTimeaddress("ceCaptureCStackPointers", startAddress);
	ceCaptureCStackPointers = ((void (*)(void)) startAddress);
}


/*	Generate the prototype ClosedPIC to determine how much space a full closed
	PIC takes.
	When we first allocate a closed PIC it only has one or two cases and we
	want to grow it.
	So we have to determine how big a full one is before hand. */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateClosedPICPrototype */
static void
generateClosedPICPrototype(void)
{
    sqInt anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    CogMethod *cPIC;
    AbstractInstruction * cPICEndOfCodeLabel;
    sqInt endAddress;
    AbstractInstruction * endCPICCase1;
    sqInt fixupSize;
    sqInt h;
    AbstractInstruction *jumpNext;
    sqInt jumpTarget;
    sqInt jumpTarget1;
    sqInt jumpTarget2;
    sqInt numArgs;
    sqInt opcode;
    sqInt opcodeSize;
    sqInt wordConstant;
    sqInt wordConstant1;


	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = MaxCPICCases * 9;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	/* begin compileClosedPICPrototype */
	compilePICAbort((numArgs = 0));
	/* At the end of the entry code we need to jump to the first case code, which is actually the last chunk.
	   On each entension we must update this jump to move back one case. */
	jumpNext = compileCPICEntry();
	wordConstant = firstPrototypeMethodOop();
	/* begin gen:uniqueLiteral:operand: */
	anInstruction1 = genoperandoperand(MoveCwR, wordConstant, SendNumArgsReg);
	assert(usesOutOfLineLiteral(anInstruction1));
	(anInstruction1->dependent = allocateLiteral(wordConstant));
	jumpTarget = (((methodZoneBase + (youngReferrers())) / 2) - 13262352) + 13262352;
	/* begin JumpLong: */
	genoperand(JumpLong, jumpTarget);
	endCPICCase0 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	for (h = 1; h < MaxCPICCases; h += 1) {
		if (h == (MaxCPICCases - 1)) {
			jmpTarget(jumpNext, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		}
		/* begin MoveUniqueCw:R: */
		wordConstant1 = (subsequentPrototypeMethodOop()) + h;
		/* begin gen:uniqueLiteral:operand: */
		anInstruction2 = genoperandoperand(MoveCwR, wordConstant1, SendNumArgsReg);
		assert(usesOutOfLineLiteral(anInstruction2));
		(anInstruction2->dependent = allocateLiteral(wordConstant1));
		/* begin CmpC32:R: */
		opcode = CmpCwR;
		/* begin gen:literal32:operand: */
		anInstruction = ((sqInt) (genoperandoperand(opcode, 0xBABE1F15U + h, TempReg)));
		checkLiteralforInstruction(0xBABE1F15U + h, anInstruction);
		jumpTarget1 = ((((methodZoneBase + (youngReferrers())) / 2) - 13262352) + 13262352) + (h * 16);
		/* begin JumpLongZero: */
		genConditionalBranchoperand(JumpLongZero, ((sqInt)jumpTarget1));
		if (h == 1) {
			endCPICCase1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
	}
	/* begin gen:literal:operand: */
	checkLiteralforInstruction((methodLabel->address), genoperandoperand(MoveCwR, (methodLabel->address), ClassReg));
	jumpTarget2 = cPICMissTrampolineFor(numArgs);
	/* begin JumpLong: */
	genoperand(JumpLong, jumpTarget2);
	cPICEndOfCodeLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	dumpLiterals(0);
	computeMaximumSizes();
	cPIC = ((CogMethod *) methodZoneBase);
	closedPICSize = (sizeof(CogMethod)) + (generateInstructionsAt(methodZoneBase + (sizeof(CogMethod))));
	endAddress = outputInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	assert((methodZoneBase + closedPICSize) == endAddress);
	firstCPICCaseOffset = ((endCPICCase0->address)) - methodZoneBase;
	cPICEndOfCodeOffset = ((cPICEndOfCodeLabel->address)) - methodZoneBase;
	cPICCaseSize = ((endCPICCase1->address)) - ((endCPICCase0->address));
	cPICEndSize = closedPICSize - (((MaxCPICCases - 1) * cPICCaseSize) + firstCPICCaseOffset);
	closedPICSize = roundUpToMethodAlignment(backEnd(), closedPICSize);
	assert(((picInterpretAbort->address)) == (((methodLabel->address)) + (picInterpretAbortOffset())));
	assert((expectedClosedPICPrototype(cPIC)) == 0);
	storeLiteralbeforeFollowingAddress(backEnd, 0, ((endCPICCase0->address)) - (jumpLongByteSize(backEnd)));
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	/* self cCode: ''
	   inSmalltalk:
	   [self disassembleFrom: cPIC + (self sizeof: CogMethod) to: cPIC + closedPICSize - 1.
	   self halt] */
	cPICPrototype = cPIC;
}


/*	We handle jump sizing simply. First we make a pass that asks each
	instruction to compute its maximum size. Then we make a pass that
	sizes jumps based on the maxmimum sizes. Then we make a pass
	that fixes up jumps. When fixing up a jump the jump is not allowed to
	choose a smaller offset but must stick to the size set in the second pass. */

	/* Cogit>>#generateCogMethod: */
static NoDbgRegParms CogMethod *
generateCogMethod(sqInt selector)
{
    sqInt codeSize;
    usqIntptr_t headerSize;
    sqInt mapSize;
    sqInt result;
    usqInt startAddress;
    sqInt totalSize;

	headerSize = sizeof(CogMethod);
	(methodLabel->address = freeStart());
	computeMaximumSizes();
	concretizeAt(methodLabel, freeStart());
	codeSize = generateInstructionsAt(((methodLabel->address)) + headerSize);
	mapSize = generateMapAtstart(null, ((methodLabel->address)) + cmNoCheckEntryOffset);
	totalSize = roundUpToMethodAlignment(backEnd(), (headerSize + codeSize) + mapSize);
	if (totalSize > MaxMethodSize) {
		return ((CogMethod *) MethodTooBig);
	}
	startAddress = allocate(totalSize);
	if (startAddress == 0) {
		return ((CogMethod *) InsufficientCodeSpace);
	}
	assert((startAddress + cmEntryOffset) == ((entry->address)));
	assert((startAddress + cmNoCheckEntryOffset) == ((noCheckEntry->address)));
	result = outputInstructionsAt(startAddress + headerSize);
	assert(((startAddress + headerSize) + codeSize) == result);
	padIfPossibleWithStopsFromto(backEnd, result, ((startAddress + totalSize) - mapSize) - 1);
	generateMapAtstart((startAddress + totalSize) - 1, startAddress + cmNoCheckEntryOffset);
	fillInBlockHeadersAt(startAddress);
	fillInMethodHeadersizeselector(((CogMethod *) ((((usqInt)startAddress)) + codeToDataDelta)), totalSize, selector);
	flushICacheFromto(backEnd, startAddress, startAddress + totalSize);
	return ((CogMethod *) startAddress);
}


/*	Generate the method map at addressrNull (or compute it if addressOrNull is
	null). Answer the length of the map in byes. Each entry in the map is in
	two parts. In the
	least signficant bits are a displacement of how far from the start or
	previous entry,
	unless it is an IsAnnotationExtension byte, in which case those bits are
	the extension.
	In the most signficant bits are the type of annotation at the point
	reached. A null
	byte ends the map. */

	/* Cogit>>#generateMapAt:start: */
static NoDbgRegParms sqInt
generateMapAtstart(usqInt addressOrNull, usqInt startAddress)
{
    unsigned char annotation;
    sqInt delta;
    sqInt i;
    AbstractInstruction *instruction;
    sqInt length;
    usqInt location;
    sqInt mapEntry;
    sqInt maxDelta;
    usqInt mcpc;

	length = 0;
	location = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		annotation = (instruction->annotation);
		if (!(annotation == null)) {
			/* begin assertValidAnnotation:for: */
			assert((annotation != (getIsObjectReference()))
			 || (((instruction->opcode)) == Literal));
			mcpc = 
			/* begin mapEntryAddress */
(((instruction->opcode)) == Literal
				? (instruction->address)
				: ((instruction->address)) + ((instruction->machineCodeSize)));
			while (((delta = (mcpc - location) / 4 /* begin codeGranularity */)) > DisplacementMask) {
				maxDelta = (((((delta < MaxX2NDisplacement) ? delta : MaxX2NDisplacement)) | DisplacementMask) - DisplacementMask);
				assert((((usqInt)(maxDelta)) >> AnnotationShift) <= DisplacementMask);
				if (!(addressOrNull == null)) {
					/* begin addToMap:instruction:byte:at:for: */
					codeByteAtput(addressOrNull - length, (((usqInt)(maxDelta)) >> AnnotationShift) + DisplacementX2N);
				}
				location += maxDelta * 4 /* begin codeGranularity */;
				length += 1;
			}
			if (!(addressOrNull == null)) {
				mapEntry = delta + (((sqInt)((usqInt)((((annotation < IsSendCall) ? annotation : IsSendCall))) << AnnotationShift)));
				/* begin addToMap:instruction:byte:at:for: */
				codeByteAtput(addressOrNull - length, mapEntry);
			}
			location += delta * 4 /* begin codeGranularity */;
			length += 1;
			if (annotation > IsSendCall) {
				/* Add the necessary IsAnnotationExtension */
				if (!(addressOrNull == null)) {
					mapEntry = (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift))) + (annotation - IsSendCall);
					/* begin addToMap:instruction:byte:at:for: */
					codeByteAtput(addressOrNull - length, mapEntry);
				}
				length += 1;
			}
		}
	}
	if (!(addressOrNull == null)) {
		/* begin addToMap:instruction:byte:at:for: */
		codeByteAtput(addressOrNull - length, MapEnd);
	}
	return length + 1;
}


/*	Generate the prototype OpenPIC to determine how much space an open PIC
	takes. 
 */
/*	stack allocate the various collections so that they
	are effectively garbage collected on return. */

	/* Cogit>>#generateOpenPICPrototype */
static void
generateOpenPICPrototype(void)
{
    sqInt codeSize;
    sqInt fixupSize;
    sqInt mapSize;
    sqInt opcodeSize;


	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 100;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	(methodLabel->address = methodZoneBase);
	(methodLabel->dependent = null);
	compileOpenPICnumArgs(specialSelector(0), numRegArgs());
	computeMaximumSizes();
	concretizeAt(methodLabel, methodZoneBase);
	codeSize = generateInstructionsAt(methodZoneBase + (sizeof(CogMethod)));
	mapSize = generateMapAtstart(null, methodZoneBase + cmNoCheckEntryOffset);
	/* self cCode: ''
	   inSmalltalk:
	   [| end |
	   end := self outputInstructionsAt: methodZoneBase + headerSize.
	   self disassembleFrom: methodZoneBase + (self sizeof: CogMethod) to: end - 1.
	   self halt] */
	openPICSize = (roundUpLength((sizeof(CogMethod)) + codeSize)) + (roundUpToMethodAlignment(backEnd(), mapSize));
}


/*	Generate the run-time entries at the base of the native code zone and
	update the base.
 */

	/* Cogit>>#generateRunTimeTrampolines */
static void
generateRunTimeTrampolines(void)
{
	ceSendMustBeBooleanAddFalseTrampoline = genMustBeBooleanTrampolineForcalled(falseObject(), "ceSendMustBeBooleanAddFalseTrampoline");
	ceSendMustBeBooleanAddTrueTrampoline = genMustBeBooleanTrampolineForcalled(trueObject(), "ceSendMustBeBooleanAddTrueTrampoline");
	/* begin genNonLocalReturnTrampoline */
	zeroOpcodeIndex();
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));
	ceNonLocalReturnTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNonLocalReturn, "ceNonLocalReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg, 1);
	/* begin genCheckForInterruptsTrampoline */
	zeroOpcodeIndex();
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));
	ceCheckForInterruptTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCheckForInterrupt, "ceCheckForInterruptTrampoline", 0, null, null, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg, 1);
	ceFetchContextInstVarTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceContextinstVar, "ceFetchContextInstVarTrampoline", 2, ReceiverResultReg, SendNumArgsReg, null, null, 0 /* begin emptyRegisterMask */, 1, SendNumArgsReg, 0);
	/* to keep ReceiverResultReg live. */
	ceStoreContextInstVarTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceContextinstVarvalue, "ceStoreContextInstVarTrampoline", 3, ReceiverResultReg, SendNumArgsReg, ClassReg, null, 0 /* begin emptyRegisterMask */, 1, ReceiverResultReg, 0);
	/* ceInvokeInterpreter is an optimization and a work-around. Historically we used setjmp/longjmp to reenter the
	   interpreter at the current C stack base.  The C stack base is set at start-up and on each callback enter and
	   callback return. The interpreter must be invoked whenever a non-machine-code method must be run.  That might
	   be when invoking an interpreter method from one of the send linking routines (ceSend:...), or on continuing from
	   an evaluation primitive such as primitiveExecuteMethod.  The problem here is that such primitives could have
	   been invoked by the interpreter or by machine code.  So some form of non-local jump is required. But at least as
	   early as MSVC Community 2017, the Microshaft longjmp performs stack unwinding which gets hoplessly confused
	   (bless its little heart) by any stack switch between machine code and C stack, and raises a spurious
	   Stack cookie instrumentation code detected a stack-based buffer overrun
	   error from the bowels of gs_report.c _GSHandlerCheck.
	   Since the CoInterpreter maintains the base of the C stack in CFramePointer & CStackPointer, it is straight-forward
	   for us to simply call interpret after doing the switch to the C stack, avoiding the stack unwind issue altogether. */
	ceCannotResumeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCannotResume, "ceCannotResumeTrampoline", 0, null, null, null, null, 0 /* begin emptyRegisterMask */, 1, NoReg, 0);
	/* These two are unusual; they are reached by return instructions. */
	ceInvokeInterpret = genInvokeInterpretTrampoline();
	ceReturnToInterpreterTrampoline = genReturnToInterpreterTrampoline();
	ceBaseFrameReturnTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceBaseFrameReturn, "ceBaseFrameReturnTrampoline", 1, ReceiverResultReg, null, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg, 0);
}


/*	Generate a routine ceCaptureCStackPointers that will capture the C stack
	pointer, and, if it is in use, the C frame pointer. These are used in
	trampolines to call
	run-time routines in the interpreter from machine-code. */

	/* Cogit>>#generateStackPointerCapture */
static void
generateStackPointerCapture(void)
{
    usqInt oldMethodZoneBase;
    sqInt oldTrampolineTableIndex;


#  if defined(cFramePointerInUse)
	assertCStackWellAligned();
	generateCaptureCStackPointers(cFramePointerInUse);
#  else
	/* For the benefit of the following assert, assume the minimum at first. */
	cFramePointerInUse = 0;
	assertCStackWellAligned();
	oldMethodZoneBase = methodZoneBase;
	oldTrampolineTableIndex = trampolineTableIndex;
	generateCaptureCStackPointers(1);
	ceCaptureCStackPointers();
	if (!((cFramePointerInUse = checkIfCFramePointerInUse()))) {
		methodZoneBase = oldMethodZoneBase;
		trampolineTableIndex = oldTrampolineTableIndex;
		generateCaptureCStackPointers(0);
	}
#  endif // defined(cFramePointerInUse)

	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	assertCStackWellAligned();
}


/*	Generate the run-time entries and exits at the base of the native code
	zone and update the base.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* Cogit>>#generateTrampolines */
static void
generateTrampolines(void)
{
    sqInt fixupSize;
    usqInt methodZoneStart;
    sqInt opcodeSize;

	methodZoneStart = methodZoneBase;
	(methodLabel->address = methodZoneStart);
	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 80;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	setHasYoungReferent(0);
	generateSendTrampolines();
	generateMissAbortTrampolines();
	generateObjectRepresentationTrampolines();
	generateRunTimeTrampolines();
	generateEnilopmarts();
	generateTracingTrampolines();
	recordGeneratedRunTimeaddress("methodZoneBase", methodZoneBase);
}

	/* Cogit>>#generatorForPC: */
static NoDbgRegParms BytecodeDescriptor *
generatorForPC(sqInt pc)
{
	return generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
}


/*	Generate a pair of routines that answer the frame pointer, and the stack
	pointer immediately
	after a leaf call, used for checking stack pointer alignment, frame
	pointer usage, etc. N.B.
	these are exported to the CoInterpreter et al via Cogit
	class>>mustBeGlobal:. 
 */

	/* Cogit>>#genGetLeafCallStackPointers */
static void
genGetLeafCallStackPointers(void)
{
    sqInt fixupSize;
    sqInt opcodeSize;
    usqInt startAddress;


	/* begin allocateOpcodes:bytecodes: */
	numAbstractOpcodes = 4;
	opcodeSize = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupSize = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	abstractOpcodes = alloca(opcodeSize + fixupSize);
	bzero(abstractOpcodes, opcodeSize + fixupSize);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeSize));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	startAddress = methodZoneBase;
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, FPReg, ABIResultReg);
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetFP", startAddress);
	ceGetFP = ((usqIntptr_t (*)(void)) startAddress);
	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, NativeSPReg, ABIResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceGetSP", startAddress);
	ceGetSP = ((usqIntptr_t (*)(void)) startAddress);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged target
	or a call of ceMNUFromPICMNUMethod:receiver: to handle an MNU dispatch
	in a closed PIC. It distinguishes the two by testing ClassReg. If the
	register is zero then this is an MNU.
	
	This poses a problem in 32-bit Spur, where zero is the cache tag for
	immediate characters (tag pattern 2r10) because SmallIntegers have tag
	patterns 2r11
	and 2r01, so anding with 1 reduces these to 0 & 1. We solve the ambiguity
	by patching send sites with a 0 cache tag to open PICs instead of closed
	PICs.  */

	/* Cogit>>#genInnerPICAbortTrampoline: */
static NoDbgRegParms usqInt
genInnerPICAbortTrampoline(char *name)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpMNUCase;

	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0 /* begin picAbortDiscriminatorValue */, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0 /* begin picAbortDiscriminatorValue */));
	}
	jumpMNUCase = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceInterpretMethodFromPICreceiver, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg);
	jmpTarget(jumpMNUCase, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceMNUFromPICMNUMethodreceiver, name, 2, SendNumArgsReg, ReceiverResultReg, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg, 1);
}


/*	Switch to the C stack (do *not* save the Smalltalk stack pointers;
	this is the caller's responsibility), and invoke interpret PDQ. */

	/* Cogit>>#genInvokeInterpretTrampoline */
static void
(*genInvokeInterpretTrampoline(void))(void)
{
    AbstractInstruction *anInstruction;
    sqInt quickConstant;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	checkLiteralforInstruction(cReturnAddressAddress(), genoperandoperand(MoveAwR, cReturnAddressAddress(), LinkReg));
	checkLiteralforInstruction(((sqInt)(((usqInt)interpret))), genoperand(JumpFull, ((sqInt)(((usqInt)interpret)))));
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceInvokeInterpret", startAddress);
	return ((void (*)(void)) startAddress);
}


/*	The in-line cache for a send is implemented as a constant load into
	ClassReg. We always use a 32-bit load, even in 64-bits.
	
	In the initial (unlinked) state the in-line cache is notionally loaded
	with the selector.
	But since in 64-bits an arbitrary selector oop won't fit in a 32-bit
	constant load, we
	instead load the cache with the selector's index, either into the literal
	frame of the
	current method, or into the special selector array. Negative values are
	1-relative indices into the special selector array.
	
	When a send is linked, the load of the selector, or selector index, is
	overwritten with a
	load of the receiver's class, or class tag. Hence, the 64-bit VM is
	currently constrained
	to use class indices as cache tags. If out-of-line literals are used,
	distinct caches /must
	not/ share acche locations, for if they do, send cacheing will be confused
	by the sharing.
	Hence we use the MoveUniqueC32:R: instruction that will not share literal
	locations.  */

	/* Cogit>>#genLoadInlineCacheWithSelector: */
static NoDbgRegParms void
genLoadInlineCacheWithSelector(sqInt selectorIndex)
{
    AbstractInstruction *anInstruction;
    sqInt cacheValue;
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt iLimiT;
    sqInt initialNumLiterals;
    AbstractInstruction *literalInstruction;
    AbstractInstruction *litInst;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;
    sqInt opcode;
    sqInt selector;

	assert((selectorIndex < 0
		? (((-selectorIndex) >= 1) && ((-selectorIndex) <= (numSpecialSelectors())))
		: ((selectorIndex >= 0) && (selectorIndex <= ((literalCountOf(methodObj)) - 1)))));
		if (selectorIndex < 0) {
		selector = specialSelector(-1 - selectorIndex);
	}
	else {
		selector = getLiteral(selectorIndex);
	}
	assert(addressCouldBeOop(selector));
	if (isNonImmediate(selector)) {
		setHasMovableLiteral(1);
	}
	if (isYoung(selector)) {
		setHasYoungReferent(1);
	}
	cacheValue = selector;
	/* begin MoveUniqueC32:R: */
	opcode = MoveCwR;
	/* begin gen:uniqueLiteral32:operand: */
	anInstruction = genoperandoperand(opcode, cacheValue, ClassReg);
	assert(usesOutOfLineLiteral(anInstruction));
	if (nextLiteralIndex >= literalsSize) {
		initialNumLiterals = literalsSize + 8;
		/* begin allocateLiterals: */
		if (initialNumLiterals > literalsSize) {
			/* Must copy across state (not using realloc, cuz...) and
			   must also update existing instructions to refer to the new ones...
			   It's either this or modify all generation routines to be able to retry
			   with more literals after running out of literals. */
			newLiterals = calloc(initialNumLiterals, sizeof(CogAbstractInstruction));
			if (!(literals == null)) {
				for (i = 0; i < nextLiteralIndex; i += 1) {
					existingInst = literalInstructionAt(i);
					newInst = (&(newLiterals[i]));
					cloneLiteralFrom(newInst, existingInst);
					assert(!((existingInst->dependent)));
					(existingInst->dependent = newInst);
				}
				for (i = 0, iLimiT = (opcodeIndex - 1); i <= iLimiT; i += 1) {
					existingInst = abstractInstructionAt(i);
					if ((((existingInst->dependent)))
					 && (((((existingInst->dependent))->opcode)) == Literal)) {
						(existingInst->dependent = (((existingInst->dependent))->dependent));
					}
				}
			}
			free(literals);
			literals = newLiterals;
			literalsSize = initialNumLiterals;
		}
	}
	litInst = literalInstructionAt(nextLiteralIndex);
	initializeUniqueLiteral(litInst, cacheValue);
	/* Record the opcodeIndex of the first dependent instruction (the first instruction that references an out-of-line literal) */
	nextLiteralIndex += 1;
	if (firstOpcodeIndex > opcodeIndex) {
		firstOpcodeIndex = opcodeIndex - 1;
	}
	literalInstruction = litInst;
	/* begin setLiteralSize: */
	(anInstruction->dependent = literalInstruction);
}

	/* Cogit>>#genReturnToInterpreterTrampoline */
static usqInt
genReturnToInterpreterTrampoline(void)
{
    AbstractInstruction *anInstruction;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxIFSavedIP, FPReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(FoxIFSavedIP));
	}
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, TempReg, instructionPointerAddress()));
	genSmalltalkToCStackSwitch(0);
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	checkLiteralforInstruction(cReturnAddressAddress(), genoperandoperand(MoveAwR, cReturnAddressAddress(), LinkReg));
	checkLiteralforInstruction(((sqInt)(((usqInt)interpret))), genoperand(JumpFull, ((sqInt)(((usqInt)interpret)))));
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress("ceReturnToInterpreterTrampoline", startAddress);
	return startAddress;
}


/*	If the client requires, then on an ARM-like RISC processor, the return
	address needs to
	be pushed to the stack so that the interpreter sees the same stack layout
	as on CISC.
 */

	/* Cogit>>#genSmalltalkToCStackSwitch: */
static NoDbgRegParms sqInt
genSmalltalkToCStackSwitch(sqInt pushLinkReg)
{
	if (pushLinkReg) {
		/* begin PushR: */
		genoperand(PushR, LinkReg);
	}
	genSaveStackPointers(backEnd);
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	return 0;
}


/*	Generate a trampoline with up to four arguments. Generate either a call or
	a jump to aRoutineOrNil
	as requested by callJumpBar. If generating a call and resultRegOrNone is
	not NoReg pass the C result
	back in resultRegOrNone.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* Cogit>>#genTrampolineFor:called:numArgs:arg:arg:arg:arg:regsToSave:pushLinkReg:resultReg:appendOpcodes: */
static NoDbgRegParms usqInt
genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(void *aRoutine, char *trampolineName, sqInt numArgs, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3, sqInt regMask, sqInt pushLinkReg, sqInt resultRegOrNone, sqInt appendBoolean)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	if (!appendBoolean) {
		zeroOpcodeIndex();
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(aRoutine, numArgs, regOrConst0, regOrConst1, regOrConst2, regOrConst3, regMask, pushLinkReg, resultRegOrNone);
	outputInstructionsForGeneratedRuntimeAt(startAddress);
	recordGeneratedRunTimeaddress(trampolineName, startAddress);
	recordRunTimeObjectReferences();
	/* begin assertValidDualZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	assertCoherentCodeAtdelta(backEnd, codeBase + cmNoCheckEntryOffset, codeToDataDelta);
#  endif

	return startAddress;
}


/*	To return from a trampoline call we have to take the return address off
	the stack,
	iof it has been saved */

	/* Cogit>>#genTrampolineReturn: */
static NoDbgRegParms void
genTrampolineReturn(sqInt lnkRegWasPushed)
{
	if (lnkRegWasPushed) {
		/* begin PopR: */
		genoperand(PopR, PCReg);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
}


/*	<Integer> */

	/* Cogit>>#gen: */
static NoDbgRegParms AbstractInstruction *
gen(sqInt opcode)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand: */
static NoDbgRegParms AbstractInstruction *
genoperand(sqInt opcode, sqInt operand)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operand;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand: */
static NoDbgRegParms AbstractInstruction *
genoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	return abstractInstruction;
}


/*	<Integer> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */
/*	<Integer|CogAbstractInstruction> */

	/* Cogit>>#gen:operand:operand:operand: */
static NoDbgRegParms AbstractInstruction *
genoperandoperandoperand(sqInt opcode, sqInt operandOne, sqInt operandTwo, sqInt operandThree)
{
    AbstractInstruction *abstractInstruction;

	assert(opcodeIndex < numAbstractOpcodes);
	abstractInstruction = abstractInstructionAt(opcodeIndex);
	opcodeIndex += 1;
	(abstractInstruction->opcode = opcode);
	((abstractInstruction->operands))[0] = operandOne;
	((abstractInstruction->operands))[1] = operandTwo;
	((abstractInstruction->operands))[2] = operandThree;
	return abstractInstruction;
}

	/* Cogit>>#getLiteral: */
static NoDbgRegParms sqInt
getLiteral(sqInt litIndex)
{
	if (maxLitIndex < litIndex) {
		maxLitIndex = litIndex;
	}
	return literalofMethod(litIndex, methodObj);
}


/*	Access for the literal manager. */

	/* Cogit>>#getOpcodeIndex */
static sqInt
getOpcodeIndex(void)
{
	return opcodeIndex;
}

	/* Cogit>>#incrementUsageOfTargetIfLinkedSend:mcpc:ignored: */
static NoDbgRegParms sqInt
incrementUsageOfTargetIfLinkedSendmcpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt targetMethod;
    CogMethod *targetMethod1;

	targetMethod = 0;
	if (annotation >= IsSendCall) {
		assert(annotation != IsNSSendCall);
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (((targetMethod1->cmUsageCount)) < (CMMaxUsageCount / 2)) {
				((((CogMethod *) ((((usqInt)targetMethod1)) + codeToDataDelta)))->cmUsageCount = ((targetMethod1->cmUsageCount)) + 1);
			}
		}
	}
	return 0;
}

	/* Cogit>>#initializeCodeZoneFrom:upTo: */
void
initializeCodeZoneFromupTo(sqInt startAddress, sqInt endAddress)
{
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt iLimiT;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;


	/* begin initializeBackend */
	(methodLabel->machineCodeSize = 0);
	(methodLabel->opcode = Label);
	((methodLabel->operands))[0] = 0;
	((methodLabel->operands))[1] = 0;
	assert((!((registerMaskFor(VarBaseReg)) & CallerSavedRegisterMask)));
	varBaseAddress = computeGoodVarBaseAddress();
	assert((stackLimitAddress()) >= varBaseAddress);
	assert((cStackPointerAddress()) >= varBaseAddress);
	assert((cFramePointerAddress()) >= varBaseAddress);
	assert((cReturnAddressAddress()) >= varBaseAddress);
	assert((nextProfileTickAddress()) >= varBaseAddress);
	/* begin allocateLiterals: */
	if (4 > literalsSize) {
		/* Must copy across state (not using realloc, cuz...) and
		   must also update existing instructions to refer to the new ones...
		   It's either this or modify all generation routines to be able to retry
		   with more literals after running out of literals. */
		newLiterals = calloc(4, sizeof(CogAbstractInstruction));
		if (!(literals == null)) {
			for (i = 0; i < nextLiteralIndex; i += 1) {
				existingInst = literalInstructionAt(i);
				newInst = (&(newLiterals[i]));
				cloneLiteralFrom(newInst, existingInst);
				assert(!((existingInst->dependent)));
				(existingInst->dependent = newInst);
			}
			for (i = 0, iLimiT = (opcodeIndex - 1); i <= iLimiT; i += 1) {
				existingInst = abstractInstructionAt(i);
				if ((((existingInst->dependent)))
				 && (((((existingInst->dependent))->opcode)) == Literal)) {
					(existingInst->dependent = (((existingInst->dependent))->dependent));
				}
			}
		}
		free(literals);
		literals = newLiterals;
		literalsSize = 4;
	}
	/* begin resetLiterals */
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	sqMakeMemoryExecutableFromToCodeToDataDelta(startAddress, endAddress, 
#  if DUAL_MAPPED_CODE_ZONE
		(&codeToDataDelta)
#  else
		null
#  endif
		);
	codeBase = (methodZoneBase = startAddress);
	stopsFromto(backEnd, startAddress, endAddress - 1);
	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = methodZoneBase);
	youngReferrers = (limitAddress = endAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
	assertValidDualZone();
	/* begin detectFeatures */
	genGetLeafCallStackPointers();
	generateStackPointerCapture();
	generateTrampolines();
	computeEntryOffsets();
	computeFullBlockEntryOffsets();
	generateClosedPICPrototype();
	alignMethodZoneBase();
	flushICacheFromto(backEnd, startAddress, ((usqInt)methodZoneBase));
	/* begin maybeFlushWritableZoneFrom:to: */
#  if DUAL_MAPPED_CODE_ZONE
	if (codeToDataDelta > 0) {
		flushDCacheFromto(backEnd, startAddress, ((usqInt)methodZoneBase));
	}
#  endif

	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress = methodZoneBase);
	youngReferrers = (limitAddress = endAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
	generateOpenPICPrototype();
}


/*	Answer a usage count that reflects likely long-term usage.
	Answer 1 for non-primitives or quick primitives (inst var accessors),
	2 for methods with interpreter primitives, and 3 for compiled primitives. */

	/* Cogit>>#initialMethodUsageCount */
static sqInt
initialMethodUsageCount(void)
{
	if ((primitiveIndex == 1)
	 || (isQuickPrimitiveIndex(primitiveIndex))) {
		return 1;
	}
	if (!(primitiveGeneratorOrNil())) {
		return 2;
	}
	return 3;
}


/*	Answer a usage count that reflects likely long-term usage. */

	/* Cogit>>#initialOpenPICUsageCount */
static int
initialOpenPICUsageCount(void)
{
	return CMMaxUsageCount - 1;
}

	/* Cogit>>#inverseBranchFor: */
static NoDbgRegParms sqInt
inverseBranchFor(sqInt opcode)
{
	switch (opcode) {
	case JumpLongZero:
		return JumpLongNonZero;

	case JumpLongNonZero:
		return JumpLongZero;

	case JumpZero:
		return JumpNonZero;

	case JumpNonZero:
		return JumpZero;

	case JumpNegative:
		return JumpNonNegative;

	case JumpNonNegative:
		return JumpNegative;

	case JumpOverflow:
		return JumpNoOverflow;

	case JumpNoOverflow:
		return JumpOverflow;

	case JumpCarry:
		return JumpNoCarry;

	case JumpNoCarry:
		return JumpCarry;

	case JumpLess:
		return JumpGreaterOrEqual;

	case JumpGreaterOrEqual:
		return JumpLess;

	case JumpGreater:
		return JumpLessOrEqual;

	case JumpLessOrEqual:
		return JumpGreater;

	case JumpBelow:
		return JumpAboveOrEqual;

	case JumpAboveOrEqual:
		return JumpBelow;

	case JumpAbove:
		return JumpBelowOrEqual;

	case JumpBelowOrEqual:
		return JumpAbove;

	default:
		error("Case not found and no otherwise clause");
	}
	error("invalid opcode for inverse");
	return 0;
}


/*	Useful for debugging. Marked <api> so the code generator won't delete it. */

	/* Cogit>>#isPCWithinMethodZone: */
static NoDbgRegParms int
isPCWithinMethodZone(void *address)
{
	return (((((usqInt)address)) >= methodZoneBase) && ((((usqInt)address)) <= (freeStart())));
}


/*	Answer if the instruction preceding retpc is a call instruction. */

	/* Cogit>>#isSendReturnPC: */
sqInt
isSendReturnPC(sqInt retpc)
{
    sqInt target;

	if (!(isCallPrecedingReturnPC(backEnd, retpc))) {
		return 0;
	}
	target = callTargetFromReturnAddress(backEnd, retpc);
	return (((target >= firstSend) && (target <= lastSend)))
	 || (((target >= methodZoneBase) && (target <= (freeStart()))));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPEqual(void *jumpTarget)
{
	return genoperand(JumpFPEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreaterOrEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPGreaterOrEqual(void *jumpTarget)
{
	return genoperand(JumpFPGreaterOrEqual, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPGreater: */
static NoDbgRegParms AbstractInstruction *
gJumpFPGreater(void *jumpTarget)
{
	return genoperand(JumpFPGreater, ((sqInt)jumpTarget));
}


/*	Floating-point jumps are a little weird on some processors. Defer to
	the backEnd to allow it to generate any special code it may need to. */

	/* Cogit>>#JumpFPNotEqual: */
static NoDbgRegParms AbstractInstruction *
gJumpFPNotEqual(void *jumpTarget)
{
	return genoperand(JumpFPNotEqual, ((sqInt)jumpTarget));
}


/*	destReg := srcReg << quickConstant */

	/* Cogit>>#LogicalShiftLeftCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gLogicalShiftLeftCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *first;

	return genoperandoperandoperand(LogicalShiftLeftCqRR, quickConstant, srcReg, destReg);
	first = genoperandoperand(MoveRR, srcReg, destReg);
	genoperandoperand(LogicalShiftLeftCqR, quickConstant, destReg);
	return first;
}

	/* Cogit>>#lastOpcode */
static AbstractInstruction *
lastOpcode(void)
{
	assert(opcodeIndex > 0);
	return abstractInstructionAt(opcodeIndex - 1);
}

	/* Cogit>>#linkSendAt:in:to:offset:receiver: */
void
linkSendAtintooffsetreceiver(sqInt callSiteReturnAddress, CogMethod *sendingMethod, CogMethod *targetMethod, sqInt theEntryOffset, sqInt receiver)
{
    sqInt extent;
    sqInt inlineCacheTag;

	assert((theEntryOffset == cmEntryOffset)
	 || (theEntryOffset == cmNoCheckEntryOffset));
	assert(((callSiteReturnAddress >= methodZoneBase) && (callSiteReturnAddress <= (freeStart()))));
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	if (theEntryOffset == cmNoCheckEntryOffset) {
		/* no need to change selector cache tag */
		extent = rewriteCallAttarget(backEnd, callSiteReturnAddress, (((sqInt)targetMethod)) + cmNoCheckEntryOffset);
	}
	else {
		inlineCacheTag = inlineCacheTagForInstance(receiver);
		if (inlineCacheTagIsYoung(inlineCacheTag)) {
			ensureInYoungReferrers(sendingMethod);
		}
		extent = rewriteInlineCacheAttagtarget(backEnd, callSiteReturnAddress, inlineCacheTag, (((sqInt)targetMethod)) + theEntryOffset);
	}
	flushICacheFromto(backEnd, (((usqInt)callSiteReturnAddress)) - extent, ((usqInt)callSiteReturnAddress));
}

	/* Cogit>>#loadBytesAndGetDescriptor */
static BytecodeDescriptor *
loadBytesAndGetDescriptor(void)
{
    BytecodeDescriptor *descriptor;

	byte0 = (fetchByteofObject(bytecodePC, methodObj)) + bytecodeSetOffset;
	descriptor = generatorAt(byte0);
	loadSubsequentBytesForDescriptorat(descriptor, bytecodePC);
	return descriptor;
}

	/* Cogit>>#loadSubsequentBytesForDescriptor:at: */
static NoDbgRegParms void
loadSubsequentBytesForDescriptorat(BytecodeDescriptor *descriptor, sqInt pc)
{
	if (((descriptor->numBytes)) > 1) {
		byte1 = fetchByteofObject(pc + 1, methodObj);
		if (((descriptor->numBytes)) > 2) {
			byte2 = fetchByteofObject(pc + 2, methodObj);
			if (((descriptor->numBytes)) > 3) {
				byte3 = fetchByteofObject(pc + 3, methodObj);
				if (((descriptor->numBytes)) > 4) {
					notYetImplemented();
				}
			}
		}
	}
}

	/* Cogit>>#MoveCq:R: */
static NoDbgRegParms AbstractInstruction *
gMoveCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;


	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	return anInstruction;
}

	/* Cogit>>#MoveMw:r:R: */
static NoDbgRegParms AbstractInstruction *
gMoveMwrR(sqInt offset, sqInt baseReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;


	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	return anInstruction;
}

	/* Cogit>>#MovePerfCnt64R:R:L: */
static NoDbgRegParms AbstractInstruction *
gMovePerfCnt64RRL(sqInt destRegLo, sqInt destRegHi, sqInt liveRegisterMask)
{
	assert(0);
	return genoperandoperandoperand(MovePerfCnt64RRL, destRegLo, destRegHi, liveRegisterMask);
}


/*	Answer the address of the null byte at the end of the method map. */

	/* Cogit>>#mapEndFor: */
static NoDbgRegParms usqInt
mapEndFor(CogMethod *cogMethod)
{
    usqInt end;

	end = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while ((byteAt(end)) != MapEnd) {
		end -= 1;
		assert(end > (firstMappedPCFor(cogMethod)));
	}
	return end;
}


/*	Unlinking/GC/Disassembly support */
/*	most of the time arg is a CogMethod... */

	/* Cogit>>#mapFor:performUntil:arg: */
static NoDbgRegParms sqInt
mapForperformUntilarg(CogMethod *cogMethod, sqInt (*functionSymbol)(sqInt annotation, char *mcpc, CogMethod *arg), CogMethod *arg)
{
    sqInt annotation;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	mcpc = 
	/* begin firstMappedPCFor: */
(((usqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = functionSymbol(annotation, (((char *) mcpc)), arg);
			if (result != 0) {
				return result;
			}
		}
		else {
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	return 0;
}


/*	Remap all object references in the closed PIC. Answer if any references
	are young.
	Set codeModified if any modifications are made. */

	/* Cogit>>#mapObjectReferencesInClosedPIC: */
static NoDbgRegParms sqInt
mapObjectReferencesInClosedPIC(CogMethod *cPIC)
{
    sqInt i;
    sqInt pc;
    sqInt refersToYoung;


	/* first we check the potential method oop load at the beginning of the CPIC */
	pc = addressOfEndOfCaseinCPIC(1, cPIC);
	/* We find the end address of the cPICNumCases'th case and can then just step forward by the case size thereafter */
	refersToYoung = remapMaybeObjRefInClosedPICAt(pc - (jumpLongByteSize(backEnd)));
	/* Next we check the potential class ref in the compare instruction, and the potential method oop load for each case. */
	pc = addressOfEndOfCaseinCPIC((cPIC->cPICNumCases), cPIC);
	for (i = 2; i <= ((cPIC->cPICNumCases)); i += 1) {
		if (remapMaybeObjRefInClosedPICAt(pc - (jumpLongConditionalByteSize(backEnd)))) {
			refersToYoung = 1;
		};
		if (remapMaybeObjRefInClosedPICAt((pc - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd)))) {
			refersToYoung = 1;
		}
		pc += cPICCaseSize;
	}
	return refersToYoung;
}


/*	Update all references to objects in the generated runtime. */

	/* Cogit>>#mapObjectReferencesInGeneratedRuntime */
static void
mapObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    sqInt mappedLiteral;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		literal = longAt(mcpc);
		mappedLiteral = remapObject(literal);
		if (mappedLiteral != literal) {
			/* begin setCodeModified */
#      if DUAL_MAPPED_CODE_ZONE
			codeModified = 1;
#      else
			codeModified = 1;
#      endif

			/* begin storeLiteral:atAnnotatedAddress:using: */
			codeLongAtput(mcpc, mappedLiteral);
		}
	}
}


/*	Update all references to objects in machine code for a become.
	Unlike incrementalGC or fullGC a method that does not refer to young may
	refer to young as a result of the become operation. Unlike incrementalGC
	or fullGC the reference from a Cog method to its methodObject *must not*
	change since the two are two halves of the same object. */

	/* Cogit>>#mapObjectReferencesInMachineCodeForBecome */
static void
mapObjectReferencesInMachineCodeForBecome(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt remappedMethod;
    sqInt result;
    CogMethod *writableCogMethod;

	hasYoungObj = 0;
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	codeModified = (freedPIC = 0);
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		assert(!hasYoungObj);
		if (!(((cogMethod->cmType)) == CMFree)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
			(writableCogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				if ((isYoung((cogMethod->selector)))
				 || (mapObjectReferencesInClosedPIC(cogMethod))) {
					freedPIC = 1;
					freeMethod(cogMethod);
				}
			}
			else {
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					remappedMethod = remapOop((cogMethod->methodObject));
					if (remappedMethod != ((cogMethod->methodObject))) {
						if (methodHasCogMethod(remappedMethod)) {
							error("attempt to become two cogged methods");
						}
						if (!(withoutForwardingOnandwithsendToCogit((cogMethod->methodObject), remappedMethod, (cogMethod->cmUsesPenultimateLit), methodhasSameCodeAscheckPenultimate))) {
							error("attempt to become cogged method into different method");
						}
						if ((rawHeaderOf((cogMethod->methodObject))) == (((sqInt)cogMethod))) {
							rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
							(writableCogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(writableCogMethod->methodObject = remappedMethod);
							rawHeaderOfput(remappedMethod, ((sqInt)cogMethod));
						}
						else {
							assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
							(writableCogMethod->methodHeader = rawHeaderOf(remappedMethod));
							(writableCogMethod->methodObject = remappedMethod);
						}
					}
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), ((CogMethod *) hasYoungObjPtr));
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
						}
					}
					map -= 1;
				}
	l1:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					ensureInYoungReferrers(cogMethod);
					hasYoungObj = 0;
				}
				else {
					(cogMethod->cmRefersToYoung = 0);
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (freedPIC) {
		unlinkSendsToFree();
	}
	if (codeModified) {
		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)codeBase), freeStart());
	}
}


/*	Update all references to objects in machine code for a full gc. Since
	the current (New)ObjectMemory GC makes everything old in a full GC
	a method not referring to young will not refer to young afterwards */

	/* Cogit>>#mapObjectReferencesInMachineCodeForFullGC */
static void
mapObjectReferencesInMachineCodeForFullGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableCogMethod;

	codeModified = 0;
	mapObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
			(writableCogMethod->selector = remapOop((cogMethod->selector)));
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(!((cogMethod->cmRefersToYoung)));
				mapObjectReferencesInClosedPIC(cogMethod);
			}
			else {
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(writableCogMethod->methodObject = remapOop((cogMethod->methodObject)));
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), 0);
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
						}
					}
					map -= 1;
				}
	l1:	/* end mapFor:performUntil:arg: */;
				if (((cogMethod->cmRefersToYoung))) {
					(writableCogMethod->cmRefersToYoung = 0);
				}
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	pruneYoungReferrers();
	if (codeModified) {
		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)codeBase), freeStart());
	}
}


/*	Update all references to objects in machine code for either a Spur
	scavenging gc
	or a Squeak V3 incremental GC. Avoid scanning all code by using the
	youngReferrers list. In a young gc a method referring to young may no
	longer refer to young, but a
	method not referring to young cannot and will not refer to young
	afterwards.  */

	/* Cogit>>#mapObjectReferencesInMachineCodeForYoungGC */
static void
mapObjectReferencesInMachineCodeForYoungGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt hasYoungObj;
    sqInt hasYoungObjPtr;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    usqInt pointer;
    sqInt result;
    CogMethod *writableCogMethod;
    sqInt zoneIsWritable;

	codeModified = (zoneIsWritable = (hasYoungObj = 0));
	hasYoungObjPtr = ((sqInt)((&hasYoungObj)));
	pointer = youngReferrers();
	while (pointer < limitAddress) {
		assert(!hasYoungObj);
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (((cogMethod->cmType)) == CMFree) {
			assert(!((cogMethod->cmRefersToYoung)));
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			if ((cogMethod->cmRefersToYoung)) {
				assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
				 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
				if (!zoneIsWritable) {
					/* begin ensureWritableCodeZone */
#          if !DUAL_MAPPED_CODE_ZONE
#          endif

					zoneIsWritable = 1;
				}
				writableCogMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
				(writableCogMethod->selector = remapOop((cogMethod->selector)));
				if (isYoung((cogMethod->selector))) {
					hasYoungObj = 1;
				}
				if (((cogMethod->cmType)) >= CMMethod) {
					assert(((cogMethod->objectHeader)) == (nullHeaderForMachineCodeMethod()));
					(writableCogMethod->methodObject = remapOop((cogMethod->methodObject)));
					if (isYoung((cogMethod->methodObject))) {
						hasYoungObj = 1;
					}
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = remapIfObjectRefpchasYoung(annotation, ((char *) mcpc), ((void *)hasYoungObjPtr));
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
						}
					}
					map -= 1;
				}
	l1:	/* end mapFor:performUntil:arg: */;
				if (hasYoungObj) {
					hasYoungObj = 0;
				}
				else {
					(writableCogMethod->cmRefersToYoung = 0);
				}
			}
		}
		pointer += BytesPerWord;
	}
	pruneYoungReferrers();
	if (codeModified) {
		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	Update all references to objects in machine code. */

	/* Cogit>>#mapObjectReferencesInMachineCode: */
void
mapObjectReferencesInMachineCode(sqInt gcMode)
{
	switch (gcMode) {
	case GCModeNewSpace:
		/* N.B. do *not* ensureWritableCodeZone for every scavenge. */
		mapObjectReferencesInMachineCodeForYoungGC();
		break;
	case GCModeFull:
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
#    endif

		mapObjectReferencesInMachineCodeForFullGC();
		break;
	case GCModeBecome:
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
#    endif

		mapObjectReferencesInMachineCodeForBecome();
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	mapPerMethodProfile();
	if (!(asserta((freeStart()) <= (youngReferrers())))) {
		error("youngReferrers list overflowed");
	}
}


/*	Free any methods that refer to unmarked objects, unlinking sends to freed
	methods. 
 */

	/* Cogit>>#markAndTraceMachineCodeForNewSpaceGC */
static void
markAndTraceMachineCodeForNewSpaceGC(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    usqInt pointer;
    sqInt result;

	if (leakCheckNewSpaceGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	codeModified = 0;
	pointer = youngReferrers();
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if ((cogMethod->cmRefersToYoung)) {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
			 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
			if (isYoung((cogMethod->selector))) {
				markAndTrace((cogMethod->selector));
			}
			if (((cogMethod->cmType)) >= CMMethod) {
				if (isYoung((cogMethod->methodObject))) {
					markAndTrace((cogMethod->methodObject));
				}
				/* begin markYoungObjectsIn: */
				assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
				 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
				if (isYoung((cogMethod->selector))) {
					markAndTrace((cogMethod->selector));
				}
				if ((((cogMethod->cmType)) >= CMMethod)
				 && (isYoung((cogMethod->methodObject)))) {
					markAndTrace((cogMethod->methodObject));
				}
				/* begin mapFor:performUntil:arg: */
				mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = markYoungObjectspcmethod(annotation, ((char *) mcpc), cogMethod);
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
						}
					}
					map -= 1;
				}
	l1:	/* end mapFor:performUntil:arg: */;
			}
		}
		pointer += BytesPerWord;
	}
	if (leakCheckNewSpaceGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	if (codeModified) {
		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	Mark and trace any object references in the generated run-time. */

	/* Cogit>>#markAndTraceObjectReferencesInGeneratedRuntime */
static void
markAndTraceObjectReferencesInGeneratedRuntime(void)
{
    sqInt i;
    sqInt literal;
    usqInt mcpc;

	for (i = 0; i < runtimeObjectRefIndex; i += 1) {
		mcpc = objectReferencesInRuntime[i];
		literal = longAt(mcpc);
		/* begin markAndTraceLiteral:in:atpc: */
		markAndTraceLiteral(literal);
	}
}

	/* Cogit>>#markAndTraceObjectsOrFreeMachineCode: */
void
markAndTraceObjectsOrFreeMachineCode(sqInt inFullGC)
{
	if (inFullGC) {
		markAndTraceOrFreeMachineCodeForFullGC();
	}
	else {
		markAndTraceMachineCodeForNewSpaceGC();
	}
}


/*	Mark and trace objects in the argument and free if it is appropriate.
	Answer if the method has been freed. firstVisit is a hint used to avoid
	scanning methods we've already seen. False positives are fine.
	For a CMMethod this
	frees if the bytecode method isnt marked,
	marks and traces object literals and selectors,
	unlinks sends to targets that should be freed.
	For a CMClosedPIC this
	frees if it refers to anything that should be freed or isn't marked.
	For a CMOpenPIC this
	frees if the selector isn't marked. */
/*	this recurses at most one level down */

	/* Cogit>>#markAndTraceOrFreeCogMethod:firstVisit: */
static NoDbgRegParms sqInt
markAndTraceOrFreeCogMethodfirstVisit(CogMethod *cogMethod, sqInt firstVisit)
{
    sqInt annotation;
    sqInt literal;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (((cogMethod->cmType)) == CMFree) {
		return 1;
	}
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
	if (((cogMethod->cmType)) >= CMMethod) {
		if (!(isMarked((cogMethod->methodObject)))) {
			/* begin ensureWritableCodeZone */
#      if !DUAL_MAPPED_CODE_ZONE
#      endif

			freeMethod(cogMethod);
			return 1;
		}
		if (firstVisit) {
			/* begin markLiteralsAndUnlinkUnmarkedSendsIn: */
			assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
			assert(isMarked((cogMethod->methodObject)));
			literal = (cogMethod->selector);
			(&((cogMethod->selector)));
			/* begin markAndTraceLiteral:in:at: */
			markAndTraceLiteral(literal);
			mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = markLiteralsAndUnlinkIfUnmarkedSendpcmethod(annotation, ((char *) mcpc), cogMethod);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
					}
				}
				map -= 1;
			}
	l1:	/* end mapFor:performUntil:arg: */;
		}
		return 0;
	}
	if (((cogMethod->cmType)) == CMClosedPIC) {
		if (!(closedPICRefersToUnmarkedObject(cogMethod))) {
			return 0;
		}
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
#    endif

		freeMethod(cogMethod);
		return 1;
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		if (isMarked((cogMethod->selector))) {
			return 0;
		}
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
#    endif

		freeMethod(cogMethod);
		return 1;
	}
	assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
	 || ((isCMClosedPIC(((CogBlockMethod *) cogMethod)))
	 || (isCMOpenPIC(((CogBlockMethod *) cogMethod)))));
	return 0;
}


/*	Free any methods that refer to unmarked objects, unlinking sends to freed
	methods. 
 */

	/* Cogit>>#markAndTraceOrFreeMachineCodeForFullGC */
static void
markAndTraceOrFreeMachineCodeForFullGC(void)
{
    CogMethod *cogMethod;

	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	codeModified = 0;
	markAndTraceObjectReferencesInGeneratedRuntime();
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		markAndTraceOrFreeCogMethodfirstVisit(cogMethod, 1);
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (leakCheckFullGC()) {
		asserta(allMachineCodeObjectReferencesValid());
	}
	if (codeModified) {
		/* After updating oops in inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	If entryPoint is that of some method, then mark and trace objects in it
	and free if it is appropriate.
	Answer if the method has been freed. */

	/* Cogit>>#markAndTraceOrFreePICTarget:in: */
static NoDbgRegParms sqInt
markAndTraceOrFreePICTargetin(sqInt entryPoint, CogMethod *cPIC)
{
    CogMethod *targetMethod;

	assert((entryPoint > methodZoneBase)
	 && (entryPoint < (freeStart())));
	if (	/* begin containsAddress: */
		((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
	 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
		return 0;
	}
	targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
	assert((isCMMethodEtAl(((CogBlockMethod *) targetMethod)))
	 || (isCMFree(((CogBlockMethod *) targetMethod))));
	return markAndTraceOrFreeCogMethodfirstVisit(targetMethod, (((usqInt)targetMethod)) > (((usqInt)cPIC)));
}


/*	Mark and trace literals. Unlink sends that have unmarked cache tags or
	targets. 
 */

	/* Cogit>>#markLiteralsAndUnlinkIfUnmarkedSend:pc:method: */
static NoDbgRegParms sqInt
markLiteralsAndUnlinkIfUnmarkedSendpcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    sqInt cacheTag;
    sqInt cacheTag1;
    sqInt cacheTagMarked;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt literal;
    sqInt literal1;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObj1;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	cacheTag = 0;
	entryPoint = 0;
	sendTable = 0;
	tagCouldBeObj = 0;
	targetMethod = 0;
	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		/* begin markAndTraceLiteral:in:atpc: */
		markAndTraceLiteral(literal);
		codeModified = 1;
	l1:;
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = longAt(pcRelativeAddressAt(backEnd, ((usqInt)((((sqInt)mcpc)) - 8))));
		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 1 /* begin inlineCacheTagsMayBeObjects */;
		cacheTagMarked = tagCouldBeObj1
		 && (cacheTagIsMarked(cacheTag1));
		if (entryPoint1 > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint1 - offset1));
			if ((!cacheTagMarked)
			 || (markAndTraceOrFreeCogMethodfirstVisit(targetMethod1, (((usqInt)targetMethod1)) > (((usqInt)mcpc))))) {
				/* Either the cacheTag is unmarked (e.g. new class) or the target
				   has been freed (because it is unmarked), so unlink the send. */
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
				literal1 = (targetMethod1->selector);
				(&((targetMethod1->selector)));
				/* begin markAndTraceLiteral:in:at: */
				markAndTraceLiteral(literal1);
			}
		}
		else {
			/* cacheTag is selector */
			markAndTraceLiteral(cacheTag1);
			codeModified = 1;
	l2:;
		}
	}
	return 0;
}

	/* Cogit>>#markMethodAndReferents: */
void
markMethodAndReferents(CogBlockMethod *aCogMethod)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *writableMethod;

	assert((isCMMethodEtAl(aCogMethod))
	 || (isCMBlock(aCogMethod)));
	cogMethod = (((aCogMethod->cmType)) >= CMMethod
		? ((CogMethod *) aCogMethod)
		: cmHomeMethod(aCogMethod));
	writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	(writableMethod->cmUsageCount = CMMaxUsageCount);
	/* begin mapFor:performUntil:arg: */
	mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = incrementUsageOfTargetIfLinkedSendmcpcignored(annotation, ((char *) mcpc), 0);
			if (result != 0) {
				goto l1;
			}
		}
		else {
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	l1:	/* end mapFor:performUntil:arg: */;
}


/*	Mark and trace young literals. */

	/* Cogit>>#markYoungObjects:pc:method: */
static NoDbgRegParms sqInt
markYoungObjectspcmethod(sqInt annotation, char *mcpc, CogMethod *cogMethod)
{
    sqInt cacheTag;
    sqInt cacheTag1;
    sqInt entryPoint1;
    sqInt literal;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObj1;

	cacheTag = 0;
	tagCouldBeObj = 0;
	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		markAndTraceLiteralIfYoung(literal);
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = longAt(pcRelativeAddressAt(backEnd, ((usqInt)((((sqInt)mcpc)) - 8))));
		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 1 /* begin inlineCacheTagsMayBeObjects */;
		if (tagCouldBeObj1) {
			markAndTraceLiteralIfYoung(cacheTag1);
		}
	}
	return 0;
}

	/* Cogit>>#maxCogMethodAddress */
usqInt
maxCogMethodAddress(void)
{
	return ((usqInt)(limitZony()));
}

	/* Cogit>>#maximumDistanceFromCodeZone: */
static NoDbgRegParms sqInt
maximumDistanceFromCodeZone(sqInt anAddress)
{
	return (anAddress > codeBase
		? anAddress - codeBase
		: limitAddress - anAddress);
}


/*	If this is the Newspeak VM and the objectRepresentation supports pinning
	then allocate space for the implicit receiver caches on the heap. */

	/* Cogit>>#maybeAllocAndInitIRCs */
static sqInt
maybeAllocAndInitIRCs(void)
{
	return 1;
}


/*	Check that the header fields are consistent with the type.
	Answer 0 if it is ok, otherwise answer a code for the error. */

	/* Cogit>>#maybeFreeCogMethodDoesntLookKosher: */
static NoDbgRegParms sqInt
maybeFreeCogMethodDoesntLookKosher(CogMethod *cogMethod)
{
    sqInt result;

	result = cogMethodDoesntLookKosher(cogMethod);
	return (result == 2
		? 0
		: result);
}

	/* Cogit>>#mclassIsSmallInteger */
static int
mclassIsSmallInteger(void)
{
	if (receiverTags < 0) {
		receiverTags = receiverTagBitsForMethod(methodObj);
	}
	return (receiverTags & 1);
}


/*	Answer the absolute machine code pc matching the zero-relative
	bytecode pc of a backward branch in cogMethod, given the start
	of the bytecodes for cogMethod's block or method object. */

	/* Cogit>>#mcPCForBackwardBranch:startBcpc:in: */
usqInt
mcPCForBackwardBranchstartBcpcin(sqInt bcpc, sqInt startbcpc, CogBlockMethod *cogMethod)
{
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc1;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt targetPC;


	/* begin mapFor:bcpc:performUntil:arg: */
	latestContinuation = 0;
	assert(((cogMethod->stackCheckOffset)) > 0);
	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)cogMethod)) + ((cogMethod->stackCheckOffset));
	result = findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(null, 0 + (((int)((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc), startbcpc, ((void *)bcpc));
	if (result != 0) {
		return result;
	}
	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc1 = startbcpc;
	if (((cogMethod->cmType)) >= CMMethod) {
		isInBlock = 0 /* begin cmIsFullBlock */;
		homeMethod = ((CogMethod *) cogMethod);
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		bcpc1 += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc1 == ((cogMethod->startpc)));
		homeMethod = cmHomeMethod(cogMethod);
		map = findMapLocationForMcpcinMethod((((usqInt)cogMethod)) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}
		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc1 = startbcpc - BlockCreationBytecodeSize;
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		byte = (fetchByteofObject(bcpc1, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc1 + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc1, -1, aMethodObj)
	: 0));
		bcpc1 = startbcpc;
	}
	nExts = 0;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc1, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc1 >= endbcpc) {
							return 0;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc1 >= latestContinuation)) {
							return 0;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj);
							targetPC = (bcpc1 + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc1 + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj)
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc1 = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((				/* begin isBackwardBranch:at:exts:in: */
					assert(((descriptor->spanFunction))),
				(((descriptor->spanFunction))(descriptor, bcpc1, nExts, aMethodObj)) < 0));
				result = findBackwardBranchIsBackwardBranchMcpcBcpcMatchingBcpc(descriptor, (isBackwardBranch
					? (((sqInt)((usqInt)(annotation) << 1))) + 1
					: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc), (isBackwardBranch
					? bcpc1 - (2 * nExts)
					: bcpc1), ((void *)bcpc));
				if (result != 0) {
					return result;
				}
				bcpc1 = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	return 0;
}


/*	For the purposes of become: see if the two methods are similar, i.e. can
	be safely becommed.
	This is pretty strict. All literals and bytecodes must be identical. Only
	trailer bytes and header
	flags can differ. */

	/* Cogit>>#method:hasSameCodeAs:checkPenultimate: */
static NoDbgRegParms sqInt
methodhasSameCodeAscheckPenultimate(sqInt methodA, sqInt methodB, sqInt comparePenultimateLiteral)
{
    sqInt bi;
    sqInt endPCA;
    sqInt headerA;
    sqInt headerB;
    sqInt li;
    sqInt numLitsA;

	headerA = methodHeaderOf(methodA);
	headerB = methodHeaderOf(methodB);
	numLitsA = literalCountOfMethodHeader(headerA);
	endPCA = endPCOf(methodA);
	if (((argumentCountOfMethodHeader(headerA)) != (argumentCountOfMethodHeader(headerB)))
	 || (((temporaryCountOfMethodHeader(headerA)) != (temporaryCountOfMethodHeader(headerB)))
	 || (((primitiveIndexOfMethodheader(methodA, headerA)) != (primitiveIndexOfMethodheader(methodB, headerB)))
	 || ((numLitsA != (literalCountOfMethodHeader(headerB)))
	 || (endPCA > (numBytesOf(methodB))))))) {
		return 0;
	}
	for (li = 1; li < numLitsA; li += 1) {
		if ((fetchPointerofObject(li, methodA)) != (fetchPointerofObject(li, methodB))) {
			if ((li < (numLitsA - 1))
			 || (comparePenultimateLiteral)) {
				return 0;
			}
		}
	}
	for (bi = (startPCOfMethodHeader(headerA)); bi <= endPCA; bi += 1) {
		if ((fetchByteofObject(bi, methodA)) != (fetchByteofObject(bi, methodB))) {
			return 0;
		}
	}
	return 1;
}

	/* Cogit>>#mnuOffset */
sqInt
mnuOffset(void)
{
	return missOffset;
}

	/* Cogit>>#NativePopR: */
static NoDbgRegParms AbstractInstruction *
gNativePopR(sqInt reg)
{
	return genoperand(PopR, reg);
}

	/* Cogit>>#NativePushR: */
static NoDbgRegParms AbstractInstruction *
gNativePushR(sqInt reg)
{
	return genoperand(PushR, reg);
}

	/* Cogit>>#NativeRetN: */
static NoDbgRegParms AbstractInstruction *
gNativeRetN(sqInt offset)
{
	return genoperand(RetN, offset);
}

	/* Cogit>>#needsFrameIfImmutability: */
static NoDbgRegParms sqInt
needsFrameIfImmutability(sqInt stackDelta)
{
	return IMMUTABILITY;
}

	/* Cogit>>#needsFrameIfInBlock: */
static NoDbgRegParms int
needsFrameIfInBlock(sqInt stackDelta)
{
	return inBlock > 0;
}

	/* Cogit>>#needsFrameNever: */
static NoDbgRegParms sqInt
needsFrameNever(sqInt stackDelta)
{
	return 0;
}

	/* Cogit>>#noAssertMethodClassAssociationOf: */
static NoDbgRegParms sqInt
noAssertMethodClassAssociationOf(sqInt methodPointer)
{
	return literalofMethod((literalCountOfMethodHeader(noAssertHeaderOf(methodPointer))) - 1, methodPointer);
}


/*	Check that no method is maximally marked. A maximal mark is an indication
	the method has been scanned to increase the usage count of its referent
	methods.  */

	/* Cogit>>#noCogMethodsMaximallyMarked */
static sqInt
noCogMethodsMaximallyMarked(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->cmUsageCount)) == CMMaxUsageCount)) {
			return 0;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return 1;
}


/*	Answer if all targets in the PIC are in-use methods. */

	/* Cogit>>#noTargetsFreeInClosedPIC: */
static NoDbgRegParms int
noTargetsFreeInClosedPIC(CogMethod *cPIC)
{
	return !(cPICHasFreedTargets(cPIC));
}

	/* Cogit>>#OrCq:R:R: */
static NoDbgRegParms AbstractInstruction *
gOrCqRR(sqInt quickConstant, sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *first;


	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(OrCqRR, quickConstant, srcReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	return anInstruction;
	if (srcReg == destReg) {
		/* begin gen:quickConstant:operand: */
		anInstruction1 = genoperandoperand(OrCqR, quickConstant, destReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(quickConstant));
		}
		return anInstruction1;
	}
	first = genoperandoperand(MoveRR, srcReg, destReg);
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(OrCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(quickConstant));
	}
	return first;
}


/*	Store the generated machine code, answering the last address */

	/* Cogit>>#outputInstructionsAt: */
static NoDbgRegParms sqInt
outputInstructionsAt(sqInt startAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    sqInt i;
    sqInt j;


	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	absoluteAddress = startAddress;
	for (i = 0; i < opcodeIndex; i += 1) {
		maybeBreakGeneratingInstructionWithIndex(i);
		abstractInstruction = abstractInstructionAt(i);
		assert(((abstractInstruction->address)) == absoluteAddress);
		/* begin outputMachineCodeAt: */
		for (j = 0; j < ((abstractInstruction->machineCodeSize)); j += 4) {
			longAtput(absoluteAddress + j, ((abstractInstruction->machineCode))[j / 4]);
		}
		absoluteAddress += (abstractInstruction->machineCodeSize);
	}
	return absoluteAddress;
}


/*	Output instructions generated for one of the generated run-time routines,
	a trampoline, etc
 */

	/* Cogit>>#outputInstructionsForGeneratedRuntimeAt: */
static NoDbgRegParms sqInt
outputInstructionsForGeneratedRuntimeAt(sqInt startAddress)
{
    sqInt endAddress;
    sqInt size;

	computeMaximumSizes();
	(methodLabel->address = startAddress);
	size = generateInstructionsAt(startAddress);
	endAddress = outputInstructionsAt(startAddress);
	assert((startAddress + size) == endAddress);
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	return startAddress;
}


/*	Code entry closed PIC full or miss to an instance of a young class or to a
	young target method.
	Attempt to patch the send site to an open PIC. Answer if the attempt
	succeeded; in fact it will
	only return if the attempt failed.
	The stack looks like:
	receiver
	args
	sp=>	sender return address */

	/* Cogit>>#patchToOpenPICFor:numArgs:receiver: */
sqInt
patchToOpenPICFornumArgsreceiver(sqInt selector, sqInt numArgs, sqInt receiver)
{
    sqInt extent;
    CogMethod *oPIC;
    sqInt outerReturn;


	/* See if an Open PIC is already available. */
	outerReturn = stackTop();
	oPIC = openPICWithSelector(selector);
	if (!oPIC) {
		/* otherwise attempt to create an Open PIC. */
		oPIC = cogOpenPICSelectornumArgs(selector, numArgs);
		if ((((((sqInt)oPIC)) >= MaxNegativeErrorCode) && ((((sqInt)oPIC)) <= -1))) {
			/* For some reason the PIC couldn't be generated, most likely a lack of code memory. */
			if ((((sqInt)oPIC)) == InsufficientCodeSpace) {
				callForCogCompiledCodeCompaction();
			}
			return 0;
		}
	}
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	extent = rewriteInlineCacheAttagtarget(backEnd, outerReturn, inlineCacheValueForSelectorin(backEnd, selector, mframeHomeMethodExport()), (((sqInt)oPIC)) + cmEntryOffset);
	flushICacheFromto(backEnd, (((usqInt)outerReturn)) - extent, ((usqInt)outerReturn));
	flushICacheFromto(backEnd, ((usqInt)oPIC), (((usqInt)oPIC)) + openPICSize);
	executeCogMethodfromLinkedSendWithReceiver(oPIC, receiver);
	return 1;
}


/*	This value is used to decide between MNU processing
	or interpretation in the closed PIC aborts. */

	/* Cogit>>#picAbortDiscriminatorValue */
static sqInt
picAbortDiscriminatorValue(void)
{
	return 0;
}


/*	Answer the start of the abort sequence for invoking the interpreter in a
	closed PIC.
 */

	/* Cogit>>#picInterpretAbortOffset */
static sqInt
picInterpretAbortOffset(void)
{
	return (interpretOffset()) - ((pushLinkRegisterByteSize(backEnd)) + (callInstructionByteSize(backEnd)));
}


/*	useful for debugging */

	/* Cogit>>#printCogMethodFor: */
void
printCogMethodFor(void *address)
{
    CogMethod *cogMethod;

	cogMethod = methodFor(address);
	if (cogMethod == null) {
		if ((codeEntryFor(address)) == null) {
			print("not a method");
			cr();
		}
		else {
			print("trampoline ");
			print(codeEntryNameFor(address));
			cr();
		}
	}
	else {
		printCogMethod(cogMethod);
	}
}


/*	useful for debugging */

	/* Cogit>>#printTrampolineTable */
void
printTrampolineTable(void)
{
    sqInt i;

	for (i = 0; i < trampolineTableIndex; i += 2) {
		fprintf(getTranscript(),
				"%p: %s\n",
				((void *)(trampolineAddresses[i + 1])),
				((char *)(trampolineAddresses[i])));
	}
}

	/* Cogit>>#processorHasDivQuoRemAndMClassIsSmallInteger */
static sqInt
processorHasDivQuoRemAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#processorHasMultiplyAndMClassIsSmallInteger */
static sqInt
processorHasMultiplyAndMClassIsSmallInteger(void)
{
	return mclassIsSmallInteger();
}

	/* Cogit>>#recordGeneratedRunTime:address: */
static NoDbgRegParms void
recordGeneratedRunTimeaddress(char *aString, sqInt address)
{
	assert((trampolineTableIndex + 2) <= (NumTrampolines * 2));
	trampolineAddresses[trampolineTableIndex] = aString;
	trampolineAddresses[trampolineTableIndex + 1] = (((char *) address));
	/* self printTrampolineTable */
	trampolineTableIndex += 2;
}


/*	This one for C support code. */

	/* Cogit>>#recordPrimTraceFunc */
int
recordPrimTraceFunc(void)
{
	return recordPrimTrace();
}

	/* Cogit>>#recordRunTimeObjectReferences */
static void
recordRunTimeObjectReferences(void)
{
    sqInt i;
    AbstractInstruction *instruction;

	for (i = 0; i < opcodeIndex; i += 1) {
		instruction = abstractInstructionAt(i);
		if (((instruction->annotation)) == IsObjectReference) {
			assert(runtimeObjectRefIndex < NumObjRefsInRuntime);
			assert(!hasYoungReferent);
			if (hasYoungReferent) {
				error("attempt to generate run-time routine containing young object reference.  Cannot initialize Cogit run-time.");
			}
			objectReferencesInRuntime[runtimeObjectRefIndex] = (((usqInt)(/* begin mapEntryAddress */
	(((instruction->opcode)) == Literal
	? (instruction->address)
	: ((instruction->address)) + ((instruction->machineCodeSize))))));
			runtimeObjectRefIndex += 1;
		}
	}
}


/*	N.B. (self registerMaskFor: NoReg) = 0 */

	/* Cogit>>#registerMaskFor: */
static NoDbgRegParms sqInt
registerMaskFor(sqInt reg)
{
	return ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1U << reg));
}

	/* Cogit>>#registerMaskFor:and: */
static NoDbgRegParms sqInt
registerMaskForand(sqInt reg1, sqInt reg2)
{
	return (1U << reg1) | (1U << reg2);
}

	/* Cogit>>#relocateCallsAndSelfReferencesInMethod: */
static NoDbgRegParms void
relocateCallsAndSelfReferencesInMethod(CogMethod *cogMethod)
{
    sqInt annotation;
    sqInt callDelta;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt refDelta;
    sqInt result;

	refDelta = (cogMethod->objectHeader);
	callDelta = refDelta;
	assert((isCMMethodEtAl(((CogBlockMethod *) cogMethod)))
	 || (isCMOpenPIC(((CogBlockMethod *) cogMethod))));
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cogMethod)) + missOffset)) == ((isCMMethodEtAl(((CogBlockMethod *) cogMethod))
		? methodAbortTrampolineFor((cogMethod->cmNumArgs))
		: picAbortTrampolineFor((cogMethod->cmNumArgs)))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cogMethod)) + missOffset, -callDelta);
	/* begin mapFor:performUntil:arg: */
	mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
	map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		if (mapByte >= FirstAnnotation) {
			/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
			mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
			 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
				annotation += mapByte & DisplacementMask;
				map -= 1;
			}
			result = relocateIfCallOrMethodReferencemcpcdelta(annotation, ((char *) mcpc), ((void *)refDelta));
			if (result != 0) {
				goto l1;
			}
		}
		else {
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	l1:	/* end mapFor:performUntil:arg: */;
}

	/* Cogit>>#relocateCallsInClosedPIC: */
static NoDbgRegParms void
relocateCallsInClosedPIC(CogMethod *cPIC)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt i;
    sqInt pc;
    sqInt refDelta;
    CogMethod *targetMethod;

	refDelta = (cPIC->objectHeader);
	callDelta = refDelta;
	assert((callTargetFromReturnAddress(backEnd, (((sqInt)cPIC)) + missOffset)) == (picAbortTrampolineFor((cPIC->cmNumArgs))));
	relocateCallBeforeReturnPCby(backEnd, (((sqInt)cPIC)) + missOffset, -callDelta);
	pc = (((sqInt)cPIC)) + firstCPICCaseOffset;
	for (i = 1; i <= ((cPIC->cPICNumCases)); i += 1) {
		pc = addressOfEndOfCaseinCPIC(i, cPIC);
		entryPoint = (jumpLongTargetBeforeFollowingAddress(backEnd, pc));
		if (		/* begin containsAddress: */
			((((usqInt)cPIC)) <= (((usqInt)entryPoint)))
		 && (((((usqInt)cPIC)) + ((cPIC->blockSize))) >= (((usqInt)entryPoint)))) {
			/* Interpret/MNU */
		}
		else {
			targetMethod = ((CogMethod *) (entryPoint - cmNoCheckEntryOffset));
			assert(isCMMethodEtAl(((CogBlockMethod *) targetMethod)));
			if (i == 1) {
				relocateJumpLongBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
			else {
				relocateJumpLongConditionalBeforeFollowingAddressby(backEnd, pc, -(callDelta - ((targetMethod->objectHeader))));
			}
		}
	}
	assert(((cPIC->cPICNumCases)) > 0);
	relocateMethodReferenceBeforeAddressby(backEnd, (addressOfEndOfCaseinCPIC(2, cPIC)) + (loadPICLiteralByteSize(backEnd)), refDelta);
	relocateJumpLongBeforeFollowingAddressby(backEnd, (((sqInt)cPIC)) + cPICEndOfCodeOffset, -callDelta);
}


/*	To placate the C static type system... */

	/* Cogit>>#relocateIfCallOrMethodReference:mcpc:delta: */
static NoDbgRegParms sqInt
relocateIfCallOrMethodReferencemcpcdelta(sqInt annotation, char *mcpc, CogMethod *refDeltaArg)
{
    sqInt callDelta;
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt refDelta;
    sqInt sendTable;
    sqInt *sendTable1;
    CogMethod *targetMethod;
    sqInt unlinkedRoutine;

	offset = 0;
	sendTable = 0;
	refDelta = ((sqInt) refDeltaArg);
	callDelta = refDelta;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint <= methodZoneBase) {
			/* send is not linked; just relocate */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
			return 0;
		}
		/* begin offsetAndSendTableFor:annotation:into: */
		if (annotation == IsSendCall) {
			offset1 = cmEntryOffset;
			sendTable1 = ordinarySendTrampolines;
		}
		else {
						assert(annotation == IsSuperSend);
			offset1 = cmNoCheckEntryOffset;
			sendTable1 = superSendTrampolines;
;;;
		}
		targetMethod = ((CogMethod *) (entryPoint - offset1));
		if (!(((targetMethod->cmType)) == CMFree)) {
			/* send target not freed; just relocate. */
			relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -(callDelta - ((targetMethod->objectHeader))));
			return 0;
		}
		unlinkedRoutine = sendTable1[((((targetMethod->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod->cmNumArgs)) : (NumSendTrampolines - 1))];
		unlinkedRoutine -= callDelta;
		rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod->selector), enumeratingCogMethod), unlinkedRoutine);
		return 0;
	}
	if (annotation == IsRelativeCall) {
		relocateCallBeforeReturnPCby(backEnd, ((sqInt)mcpc), -callDelta);
		return 0;
	}
	if (annotation == IsAbsPCReference) {
		relocateMethodReferenceBeforeAddressby(backEnd, ((sqInt)mcpc), refDelta);
	}
	return 0;
}


/*	to placate the C static type system... */

	/* Cogit>>#remapIfObjectRef:pc:hasYoung: */
static NoDbgRegParms sqInt
remapIfObjectRefpchasYoung(sqInt annotation, char *mcpc, CogMethod *hasYoungPtr)
{
    sqInt cacheTag;
    sqInt cacheTag1;
    sqInt entryPoint;
    sqInt entryPoint1;
    sqInt literal;
    sqInt mappedCacheTag;
    sqInt mappedLiteral;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt tagCouldBeObj;
    sqInt tagCouldBeObj1;
    CogMethod *targetMethod;
    CogMethod *targetMethod1;

	cacheTag = 0;
	entryPoint = 0;
	tagCouldBeObj = 0;
	targetMethod = ((CogMethod *) 0);
	if (annotation == IsObjectReference) {
		literal = longAt(((usqInt)mcpc));
		if (couldBeObject(literal)) {
			mappedLiteral = remapObject(literal);
			if (literal != mappedLiteral) {
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				/* begin storeLiteral:atAnnotatedAddress:using: */
				codeLongAtput(((usqInt)mcpc), mappedLiteral);
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedLiteral))) {
				(*((sqInt *) hasYoungPtr) = 1);
			}
		}
	}
	if (annotation >= IsSendCall) {
		/* begin entryCacheTagAndCouldBeObjectAt:annotation:into: */
		cacheTag1 = longAt(pcRelativeAddressAt(backEnd, ((usqInt)((((sqInt)mcpc)) - 8))));
		/* in-line cache tags are the selectors of sends if sends are unlinked,
		   the selectors of super sends (entry offset = cmNoCheckEntryOffset),
		   the selectors of open PIC sends (entry offset = cmEntryOffset, target is an Open PIC)
		   or in-line cache tags (classes, class indices, immediate bit patterns, etc).
		   Note that selectors can be immediate so there is no guarantee that they
		   are markable/remappable objects. */
		entryPoint1 = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		tagCouldBeObj1 = 1 /* begin inlineCacheTagsMayBeObjects */;
		if (tagCouldBeObj1
		 && (couldBeObject(cacheTag1))) {
			mappedCacheTag = remapObject(cacheTag1);
			if (cacheTag1 != mappedCacheTag) {
				/* begin setCodeModified */
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				/* begin rewriteInlineCacheTag:at: */
				longAtput(pcRelativeAddressAt(((AbstractInstruction *) backEnd), (((usqInt)mcpc)) - 8), mappedCacheTag);
			}
			if ((hasYoungPtr != 0)
			 && (isYoung(mappedCacheTag))) {
				(*((sqInt *) hasYoungPtr) = 1);
			}
		}
		if (hasYoungPtr != 0) {
			/* Since the unlinking routines may rewrite the cacheTag to the send's selector, and
			   since they don't have the cogMethod to hand and can't add it to youngReferrers,
			   the method must remain in youngReferrers if the targetMethod's selector is young. */
			if (entryPoint1 > methodZoneBase) {
				/* It's a linked send. */
				/* begin targetMethodAndSendTableFor:annotation:into: */
				offset = 0;
				sendTable = 0;
				/* begin offsetAndSendTableFor:annotation:into: */
				if (annotation == IsSendCall) {
					offset1 = cmEntryOffset;
					sendTable1 = ordinarySendTrampolines;
				}
				else {
										assert(annotation == IsSuperSend);
					offset1 = cmNoCheckEntryOffset;
					sendTable1 = superSendTrampolines;
;;;
				}
				targetMethod1 = ((CogMethod *) (entryPoint1 - offset1));
				if (isYoung((targetMethod1->selector))) {
					(*((sqInt *) hasYoungPtr) = 1);
				}
			}
		}
	}
	return 0;
}


/*	Remap a potential object reference from a closed PIC.
	This may be an object reference, an inline cache tag or null.
	Answer if the updated literal is young.
	mcpc is the address of the next instruction following either
	the load of the method literal or the compare of the class tag. */

	/* Cogit>>#remapMaybeObjRefInClosedPICAt: */
static NoDbgRegParms sqInt
remapMaybeObjRefInClosedPICAt(sqInt mcpc)
{
    sqInt object;
    sqInt subject;

	object = literalBeforeFollowingAddress(backEnd, mcpc);
	if (!(couldBeObject(object))) {
		return 0;
	}
	subject = remapOop(object);
	if (object != subject) {
		/* begin setCodeModified */
#    if DUAL_MAPPED_CODE_ZONE
		codeModified = 1;
#    else
		codeModified = 1;
#    endif

		storeLiteralbeforeFollowingAddress(backEnd, subject, mcpc);
	}
	return isYoungObject(subject);
}


/*	Rewrite the three values involved in a CPIC case. Used by the initialize &
	extend CPICs.
	c.f. expectedClosedPICPrototype: */
/*	write the obj ref/operand via the second ldr */

	/* Cogit>>#rewriteCPICCaseAt:tag:objRef:target: */
static NoDbgRegParms void
rewriteCPICCaseAttagobjReftarget(sqInt followingAddress, sqInt newTag, sqInt newObjRef, sqInt newTarget)
{
    sqInt classTagPC;
    sqInt methodObjPC;

	methodObjPC = (followingAddress - (jumpLongConditionalByteSize(backEnd))) - (cmpC32RTempByteSize(backEnd));
	storeLiteralbeforeFollowingAddress(backEnd, newObjRef, methodObjPC);
	/* rewite the tag via the first ldr */
	classTagPC = followingAddress - (jumpLongConditionalByteSize(backEnd));
	/* begin storeLiteral32:beforeFollowingAddress: */
	storeLiteralbeforeFollowingAddress(((AbstractInstruction *) backEnd), newTag, classTagPC);
	rewriteConditionalJumpLongAttarget(backEnd, followingAddress, newTarget);
}

	/* Cogit>>#SubCq:R: */
static NoDbgRegParms AbstractInstruction *
gSubCqR(sqInt quickConstant, sqInt reg)
{
    AbstractInstruction *anInstruction;


	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(SubCqR, quickConstant, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	return anInstruction;
}


/*	Answer the number of clean blocks found in the literal frame */

	/* Cogit>>#scanForCleanBlocks */
static sqInt
scanForCleanBlocks(void)
{
    sqInt i;
    sqInt iLimiT;
    sqInt lit;
    sqInt numCleanBlocks;
    sqInt startPCOrNil;

	numCleanBlocks = 0;
	for (i = 1, iLimiT = (literalCountOf(methodObj)); i <= iLimiT; i += 1) {
		lit = fetchPointerofObject(i, methodObj);
		startPCOrNil = startPCOrNilOfLiteralin(lit, methodObj);
		if (!(startPCOrNil == null)) {
			numCleanBlocks += 1;
		}
	}
	return numCleanBlocks;
}


/*	If a method is compiled to machine code via a block entry it won't have a
	selector. A subsequent send can find the method and hence fill in the
	selector. 
 */
/*	self disassembleMethod: cogMethod */

	/* Cogit>>#setSelectorOf:to: */
void
setSelectorOfto(CogMethod *cogMethod, sqInt aSelectorOop)
{
	compilationBreakpointisMNUCase(aSelectorOop, 0);
	assert(isCMMethodEtAl(((CogBlockMethod *) cogMethod)));
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->selector = aSelectorOop);
	if (isYoung(aSelectorOop)) {
		ensureInYoungReferrers(cogMethod);
	}
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}

	/* Cogit>>#spanForCleanBlockStartingAt: */
static NoDbgRegParms sqInt
spanForCleanBlockStartingAt(sqInt startPC)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt pc;

	pc = startPC;
	end = numBytesOf(methodObj);
	while (pc <= end) {
		/* begin generatorForPC: */
		descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
		pc += (descriptor->numBytes);
		if ((descriptor->isReturn)) {
			return pc - startPC;
		}
	}
	error("couldn't locate end of clean block");
	return 0;
}

	/* Cogit>>#stackCheckOffsetOfBlockAt:isMcpc: */
static NoDbgRegParms usqInt
stackCheckOffsetOfBlockAtisMcpc(sqInt blockEntryMcpc, sqInt mcpc)
{
    CogBlockMethod *cogBlockMethod;

	cogBlockMethod = ((CogBlockMethod *) (blockEntryMcpc - (sizeof(CogBlockMethod))));
	if (((((sqInt)cogBlockMethod)) + ((cogBlockMethod->stackCheckOffset))) == mcpc) {
		return ((usqInt)cogBlockMethod);
	}
	return 0;
}


/*	Answer a fake value for the method oop in other than the first case in the
	PIC prototype.
	Since we use MoveUniqueCw:R: it must not be confused with a
	method-relative address.
 */

	/* Cogit>>#subsequentPrototypeMethodOop */
static sqInt
subsequentPrototypeMethodOop(void)
{
	return (	/* begin addressIsInCurrentCompilation: */
		((((usqInt)0xBADA550)) >= ((methodLabel->address)))
	 && ((((usqInt)0xBADA550)) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))
		? 0xDEADEAD
		: 0xBADA550);
}

	/* Cogit>>#traceLinkedSendOffset */
sqInt
traceLinkedSendOffset(void)
{
	return (cmNoCheckEntryOffset + (callFullInstructionByteSize(backEnd))) + (pushLinkRegisterByteSize(backEnd));
}

	/* Cogit>>#trampolineName:numArgs: */
static NoDbgRegParms char *
trampolineNamenumArgs(char *routinePrefix, sqInt numArgs)
{
    char *theString;


	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, (numArgs <= (NumSendTrampolines - 2)
		? '0' + numArgs
		: 'N'));
	return theString;
}

	/* Cogit>>#trampolineName:numRegArgs: */
static NoDbgRegParms char *
trampolineNamenumRegArgs(char *routinePrefix, sqInt numArgs)
{
    sqInt argsLimit;
    char *theString;

	argsLimit = numRegArgs();
	/* begin trampolineName:numArgs:limit: */
	theString = malloc((strlen(routinePrefix)) + 6);
	sprintf(theString, "%s%cArgs", routinePrefix, (numArgs <= argsLimit
		? '0' + numArgs
		: 'N'));
	return theString;
}

	/* Cogit>>#unflagBecomeFlaggedMethods */
void
unflagBecomeFlaggedMethods(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmType = CMMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}

	/* Cogit>>#unknownBytecode */
static int
unknownBytecode(void)
{
	return EncounteredUnknownBytecode;
}


/*	Unlink all sends in cog methods. */

	/* Cogit>>#unlinkAllSends */
void
unlinkAllSends(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	cogMethod = ((CogMethod *) methodZoneBase);
	voidOpenPICList();
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcignored(annotation, ((char *) mcpc), 0);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
					}
				}
				map -= 1;
			}
	l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (!(((cogMethod->cmType)) == CMFree)) {
				freeMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
}


/*	To placate the C static type system... */

	/* Cogit>>#unlinkIfFreeOrLinkedSend:pc:of: */
static NoDbgRegParms sqInt
unlinkIfFreeOrLinkedSendpcof(sqInt annotation, char *mcpc, CogMethod *theSelector)
{
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	sendTable = 0;
	targetMethod = 0;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if ((((targetMethod1->cmType)) == CMFree)
			 || (((targetMethod1->selector)) == (((sqInt) theSelector)))) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSendToFree:pc:ignored: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendToFreepcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	sendTable = 0;
	targetMethod = 0;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (((targetMethod1->cmType)) == CMFree) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}


/*	To placate the C static type system... */

	/* Cogit>>#unlinkIfLinkedSend:pc:if: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendpcif(sqInt annotation, char *mcpc, CogMethod *criterionArg)
{
    sqInt (*criterion)(CogMethod *);
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	sendTable = 0;
	targetMethod = 0;
	criterion = ((void *)criterionArg);
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (criterion(targetMethod1)) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:ignored: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendpcignored(sqInt annotation, char *mcpc, sqInt superfluity)
{
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	sendTable = 0;
	targetMethod = 0;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			/* begin unlinkSendAt:targetMethod:sendTable: */
			unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#      if DUAL_MAPPED_CODE_ZONE
			codeModified = 1;
#      else
			codeModified = 1;
#      endif

			rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
		}
	}
	return 0;
}

	/* Cogit>>#unlinkIfLinkedSend:pc:to: */
static NoDbgRegParms sqInt
unlinkIfLinkedSendpcto(sqInt annotation, char *mcpc, CogMethod *theCogMethod)
{
    sqInt entryPoint;
    sqInt offset;
    sqInt offset1;
    sqInt sendTable;
    sqInt *sendTable1;
    sqInt sendTable2;
    sqInt targetMethod;
    CogMethod *targetMethod1;
    sqInt unlinkedRoutine;

	sendTable = 0;
	targetMethod = 0;
	if (annotation >= IsSendCall) {
		entryPoint = callTargetFromReturnAddress(backEnd, ((sqInt)mcpc));
		if (entryPoint > methodZoneBase) {
			/* It's a linked send. */
			/* begin targetMethodAndSendTableFor:annotation:into: */
			offset = 0;
			sendTable2 = 0;
			/* begin offsetAndSendTableFor:annotation:into: */
			if (annotation == IsSendCall) {
				offset1 = cmEntryOffset;
				sendTable1 = ordinarySendTrampolines;
			}
			else {
								assert(annotation == IsSuperSend);
				offset1 = cmNoCheckEntryOffset;
				sendTable1 = superSendTrampolines;
;;;
			}
			targetMethod1 = ((CogMethod *) (entryPoint - offset1));
			if (targetMethod1 == theCogMethod) {
				/* begin unlinkSendAt:targetMethod:sendTable: */
				unlinkedRoutine = sendTable1[((((targetMethod1->cmNumArgs)) < (NumSendTrampolines - 1)) ? ((targetMethod1->cmNumArgs)) : (NumSendTrampolines - 1))];
#        if DUAL_MAPPED_CODE_ZONE
				codeModified = 1;
#        else
				codeModified = 1;
#        endif

				rewriteInlineCacheAttagtarget(backEnd, ((sqInt)mcpc), inlineCacheValueForSelectorin(backEnd, (targetMethod1->selector), enumeratingCogMethod), unlinkedRoutine);
			}
		}
	}
	return 0;
}


/*	Unlink all sends in cog methods. Free all Closed PICs with the selector,
	or with an MNU case if isMNUSelector. First check if any method actually
	has the selector; if not there can't be any linked send to it. This
	routine (including descendents) is performance critical. It contributes
	perhaps 30% of entire execution time in Compiler recompileAll. */

	/* Cogit>>#unlinkSendsOf:isMNUSelector: */
void
unlinkSendsOfisMNUSelector(sqInt selector, sqInt isMNUSelector)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt mustScanAndUnlink;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	cogMethod = ((CogMethod *) methodZoneBase);
	mustScanAndUnlink = 0;
	if (isMNUSelector) {
		while (cogMethod < (limitZony())) {
			if (!(((cogMethod->cmType)) == CMFree)) {
				if ((cogMethod->cpicHasMNUCaseOrCMIsFullBlock)) {
					assert(isCMClosedPIC(((CogBlockMethod *) cogMethod)));
					freeMethod(cogMethod);
					mustScanAndUnlink = 1;
				}
				else {
					if (((cogMethod->selector)) == selector) {
						mustScanAndUnlink = 1;
						if (((cogMethod->cmType)) == CMClosedPIC) {
							freeMethod(cogMethod);
						}
					}
				}
			}
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	else {
		while (cogMethod < (limitZony())) {
			if ((!(((cogMethod->cmType)) == CMFree))
			 && (((cogMethod->selector)) == selector)) {
				mustScanAndUnlink = 1;
				if (((cogMethod->cmType)) == CMClosedPIC) {
					freeMethod(cogMethod);
				}
			}
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	}
	if (!mustScanAndUnlink) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfFreeOrLinkedSendpcof(annotation, ((char *) mcpc), ((CogMethod *) selector));
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
					}
				}
				map -= 1;
			}
	l1:	/* end mapFor:performUntil:arg: */;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {
		/* After possibly updating inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}


/*	Unlink all sends in cog methods to free methods and/or pics. */

	/* Cogit>>#unlinkSendsToFree */
static void
unlinkSendsToFree(void)
{
    sqInt annotation;
    CogMethod *cogMethod;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	codeModified = 0;
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendToFreepcignored(annotation, ((char *) mcpc), 0);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
					}
				}
				map -= 1;
			}
	l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				assert(noTargetsFreeInClosedPIC(cogMethod));
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (codeModified) {
		/* After possibly updating inline caches we need to flush the icache. */
		flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
	}
}


/*	Unlink all sends in cog methods to methods with a machine code
	primitive, and free machine code primitive methods if freeIfTrue.
	To avoid having to scan PICs, free any and all PICs */

	/* Cogit>>#unlinkSendsToMethodsSuchThat:AndFreeIf: */
void
unlinkSendsToMethodsSuchThatAndFreeIf(sqInt (*criterion)(CogMethod *), sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedSomething;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;

	if (!methodZoneBase) {
		return;
	}
	codeModified = (freedSomething = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			if (freeIfTrue
			 && (criterion(cogMethod))) {
				freeMethod(cogMethod);
				freedSomething = 1;
			}
			else {
				/* begin mapFor:performUntil:arg: */
				mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
				map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
				while (((mapByte = byteAt(map))) != MapEnd) {
					if (mapByte >= FirstAnnotation) {
						/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
						mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
						if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
						 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
							annotation += mapByte & DisplacementMask;
							map -= 1;
						}
						result = unlinkIfLinkedSendpcif(annotation, ((char *) mcpc), ((CogMethod *) criterion));
						if (result != 0) {
							goto l1;
						}
					}
					else {
						if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
							mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
						}
					}
					map -= 1;
				}
	l1:	/* end mapFor:performUntil:arg: */;
			}
		}
		else {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				freeMethod(cogMethod);
				freedSomething = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freedSomething) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {
			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
		}
	}
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}


/*	Unlink all sends in cog methods to a particular target method.
	If targetMethodObject isn't actually a method (perhaps being
	used via invokeAsMethod) then there's nothing to do. */

	/* Cogit>>#unlinkSendsTo:andFreeIf: */
void
unlinkSendsToandFreeIf(sqInt targetMethodObject, sqInt freeIfTrue)
{
    sqInt annotation;
    CogMethod *cogMethod;
    sqInt freedPIC;
    usqInt map;
    sqInt mapByte;
    sqInt mcpc;
    sqInt result;
    CogMethod *targetMethod;

	if (!((isOopCompiledMethod(targetMethodObject))
		 && (methodHasCogMethod(targetMethodObject)))) {
		return;
	}
	targetMethod = cogMethodOf(targetMethodObject);
	if (!methodZoneBase) {
		return;
	}
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	codeModified = (freedPIC = 0);
	cogMethod = ((CogMethod *) methodZoneBase);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			/* begin mapFor:performUntil:arg: */
			mcpc = (((usqInt)cogMethod)) + cmNoCheckEntryOffset;
			map = ((((usqInt)cogMethod)) + ((cogMethod->blockSize))) - 1;
			while (((mapByte = byteAt(map))) != MapEnd) {
				if (mapByte >= FirstAnnotation) {
					/* If this is an IsSendCall annotation, peek ahead for an IsAnnotationExtension, and consume it. */
					mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
					if ((((annotation = ((usqInt)(mapByte)) >> AnnotationShift)) == IsSendCall)
					 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
						annotation += mapByte & DisplacementMask;
						map -= 1;
					}
					result = unlinkIfLinkedSendpcto(annotation, ((char *) mcpc), targetMethod);
					if (result != 0) {
						goto l1;
					}
				}
				else {
					if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
						mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
					}
				}
				map -= 1;
			}
	l1:	/* end mapFor:performUntil:arg: */;
		}
		else {
			if ((((cogMethod->cmType)) == CMClosedPIC)
			 && (cPICHasTarget(cogMethod, targetMethod))) {
				freeMethod(cogMethod);
				freedPIC = 1;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	if (freeIfTrue) {
		freeMethod(targetMethod);
	}
	if (freedPIC) {
		unlinkSendsToFree();
	}
	else {
		if (codeModified) {
			/* After possibly updating inline caches we need to flush the icache. */
			flushICacheFromto(backEnd, ((usqInt)methodZoneBase), freeStart());
		}
	}
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}

	/* Cogit>>#voidCogCompiledCode */
void
voidCogCompiledCode(void)
{
    CogMethod *cogMethod;


	/* begin clearCogCompiledCode */
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) >= CMMethod) {
			freeMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	/* begin manageFrom:to: */
	mzFreeStart = (baseAddress);
	youngReferrers = (limitAddress);
	openPICList = null;
	methodBytesFreedSinceLastCompaction = 0;
	methodCount = 0;
	/* begin ensureExecutableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif
}


/*	Access for the object representations when they need to prepend code to
	trampolines. 
 */
/*	Eliminate stale dependent info. */

	/* Cogit>>#zeroOpcodeIndex */
static void
zeroOpcodeIndex(void)
{
    sqInt i;

	for (i = 0; i < opcodeIndex; i += 1) {
		((abstractOpcodes[i]).dependent = null);
	}
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
}

	/* CogMethod>>#counters */
static NoDbgRegParms sqInt
counters(CogMethod *self_in_CogMethod)
{
	return 0;
}

	/* CogMethodZone>>#addToOpenPICList: */
static NoDbgRegParms void
addToOpenPICList(CogMethod *anOpenPIC)
{
	assert(isCMOpenPIC(((CogBlockMethod *) anOpenPIC)));
	assert((openPICList == null)
	 || (isCMOpenPIC(((CogBlockMethod *) openPICList))));
	assertValidDualZoneWriteAddress(anOpenPIC);
	(anOpenPIC->nextOpenPIC = ((usqInt)openPICList));
	openPICList = ((CogMethod *) ((((usqInt)anOpenPIC)) - (getCodeToDataDelta())));
}

	/* CogMethodZone>>#addToYoungReferrers: */
static NoDbgRegParms void
addToYoungReferrers(CogMethod *writableCogMethod)
{
	assertValidDualZoneWriteAddress(writableCogMethod);
	assert((occurrencesInYoungReferrers(writableCogMethod)) == 0);
	assert((writableCogMethod->cmRefersToYoung));
	assert((youngReferrers <= limitAddress)
	 && (youngReferrers >= (limitAddress - (methodCount * BytesPerWord))));
	if (!(asserta((limitAddress - (methodCount * BytesPerWord)) >= mzFreeStart))) {
		error("no room on youngReferrers list");
	}
	youngReferrers -= BytesPerWord;
	codeLongAtput(youngReferrers, (((usqInt)writableCogMethod)) - (getCodeToDataDelta()));
}

	/* CogMethodZone>>#allocate: */
static NoDbgRegParms usqInt
allocate(sqInt numBytes)
{
    usqInt allocation;
    sqInt roundedBytes;

	roundedBytes = (numBytes + 7) & -8;
	if ((mzFreeStart + roundedBytes) >= (limitAddress - (methodCount * BytesPerWord))) {
		return 0;
	}
	allocation = mzFreeStart;
	mzFreeStart += roundedBytes;
	methodCount += 1;
	return allocation;
}


/*	Answer the method containing mcpc for the purposes of code zone
	compaction, where mcpc is actually the value of instructionPointer at the
	time of a compaction. */

	/* CogMethodZone>>#cogMethodContaining: */
CogMethod *
cogMethodContaining(usqInt mcpc)
{
    CogMethod *cogMethod;
    CogMethod *prevMethod;

	if (mcpc > limitAddress) {
		return null;
	}
	if (mcpc < baseAddress) {
		/* begin assertMcpcIsPrimReturn: */
		assert((mcpc == cePrimReturnEnterCogCode)
		 || (mcpc == cePrimReturnEnterCogCodeProfiling));
		return null;
	}
	assert(mcpc < (freeStart()));
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mcpc) {
		prevMethod = cogMethod;
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	assert((prevMethod)
	 && ((mcpc == ((((usqInt)prevMethod)) + ((prevMethod->stackCheckOffset))))
	 || ((mcpcisAtStackCheckOfBlockMethodIn(mcpc, prevMethod))
	 || (((primitiveIndexOfMethodheader((prevMethod->methodObject), (prevMethod->methodHeader))) > 0)
	 || ((isCallPrecedingReturnPC(backEnd(), mcpc))
	 && ((callTargetFromReturnAddress(backEnd(), mcpc)) == (ceCheckForInterruptTrampoline())))))));
	return prevMethod;
}

	/* CogMethodZone>>#compactCompiledCode */
static void
compactCompiledCode(void)
{
    unsigned short bytes;
    CogMethod *dest;
    sqInt objectHeaderValue;
    CogMethod *source;
    CogMethod *writableVersion;

	compactionInProgress = 1;
	methodCount = 0;
	objectHeaderValue = nullHeaderForMachineCodeMethod();
	source = ((CogMethod *) baseAddress);
	voidOpenPICList();
	voidUnpairedMethodList();
	while ((source < (limitZony()))
	 && (!(((source->cmType)) == CMFree))) {
		assert((cogMethodDoesntLookKosher(source)) == 0);
		writableVersion = ((CogMethod *) ((((usqInt)source)) + codeToDataDelta));
		(writableVersion->objectHeader = objectHeaderValue);
		if (((source->cmUsageCount)) > 0) {
			(writableVersion->cmUsageCount = ((source->cmUsageCount)) / 2);
		}
		/* begin maybeLinkOnUnpairedMethodList: */
		if (((source->cmType)) == CMOpenPIC) {
			addToOpenPICList(writableVersion);
		}
		methodCount += 1;
		source = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)source)) + ((source->blockSize)))));
	}
	if (source >= (limitZony())) {
		haltmsg("no free methods; cannot compact.");
		return;
	}
	dest = source;
	while (source < (limitZony())) {
		assert((maybeFreeCogMethodDoesntLookKosher(source)) == 0);
		bytes = (source->blockSize);
		if (!(((source->cmType)) == CMFree)) {
			methodCount += 1;
			codeMemmove(dest, source, bytes);
			/* begin maybeFlushWritableZoneFrom:to: */
#      if DUAL_MAPPED_CODE_ZONE
			if (codeToDataDelta > 0) {
				flushDCacheFromto(backEnd, ((usqInt)dest), (((usqInt)dest)) + bytes);
			}
#      endif

			((writableVersion = ((CogMethod *) ((((usqInt)dest)) + codeToDataDelta)))->objectHeader = objectHeaderValue);
			if (((dest->cmType)) >= CMMethod) {
				/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
				   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
				/* Only update the original method's header if it is referring to this CogMethod. */
				if ((((sqInt)(rawHeaderOf((dest->methodObject))))) == (((sqInt)source))) {
					rawHeaderOfput((dest->methodObject), ((sqInt)dest));
				}
				else {
					assert((noAssertMethodClassAssociationOf((dest->methodObject))) == (nilObject()));
					/* begin linkOnUnpairedMethodList: */
				}
			}
			else {
				/* begin clearSavedPICUsageCount: */
				if (((dest->cmType)) == CMOpenPIC) {
					addToOpenPICList(writableVersion);
				}
			}
			if (((dest->cmUsageCount)) > 0) {
				(writableVersion->cmUsageCount = ((dest->cmUsageCount)) / 2);
			}
			/* begin maybeFlushWritableZoneFrom:to: */
#      if DUAL_MAPPED_CODE_ZONE
			if (codeToDataDelta > 0) {
				flushDCacheFromto(backEnd, ((usqInt)dest), ((usqInt)(dest + 1)));
			}
#      endif

			dest = ((CogMethod *) ((((usqInt)dest)) + bytes));
		}
		source = ((CogMethod *) ((((usqInt)source)) + bytes));
	}
	mzFreeStart = ((usqInt)dest);
	methodBytesFreedSinceLastCompaction = 0;
	compactionInProgress = 0;
}

	/* CogMethodZone>>#ensureInYoungReferrers: */
static NoDbgRegParms void
ensureInYoungReferrers(CogMethod *cogMethod)
{
    CogMethod *writableMethod;

	assertValidDualZoneReadAddress(cogMethod);
	if (!((cogMethod->cmRefersToYoung))) {
		assert((occurrencesInYoungReferrers(cogMethod)) == 0);
		/* begin ensureWritableCodeZone */
#    if !DUAL_MAPPED_CODE_ZONE
#    endif

		((writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->cmRefersToYoung = 1);
		addToYoungReferrers(writableMethod);
	}
}

	/* CogMethodZone>>#freeMethod: */
static NoDbgRegParms void
freeMethod(CogMethod *cogMethod)
{
    CogMethod *writableMethod;

	assert(!((isCMFree(((CogBlockMethod *) cogMethod)))));
	assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
	/* begin ensureWritableCodeZone */
#  if !DUAL_MAPPED_CODE_ZONE
#  endif

	if (((cogMethod->cmType)) >= CMMethod) {
		if (((cogMethod->cmType)) == CMMethodFlaggedForBecome) {
		}
		else {
			/* For non-Newspeak there should be a one-to-one mapping between bytecoded and
			   cog methods.  For Newspeak not necessarily, but only for anonymous accessors. */
			/* Only reset the original method's header if it is referring to this CogMethod. */
			if ((((sqInt)(rawHeaderOf((cogMethod->methodObject))))) == (((sqInt)cogMethod))) {
				rawHeaderOfput((cogMethod->methodObject), (cogMethod->methodHeader));
			}
			else {
				assert((noAssertMethodClassAssociationOf((cogMethod->methodObject))) == (nilObject()));
			}
		}
	}
	if (((cogMethod->cmType)) == CMOpenPIC) {
		removeFromOpenPICList(cogMethod);
	}
	writableMethod = ((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta));
	(writableMethod->cmRefersToYoung = 0);
	(writableMethod->cmType = CMFree);
	methodBytesFreedSinceLastCompaction += (cogMethod->blockSize);
}


/*	Free methods, preferring older methods for compaction, up to some
	fraction, currently a quarter.
 */

	/* CogMethodZone>>#freeOlderMethodsForCompaction */
static void
freeOlderMethodsForCompaction(void)
{
    sqInt amountToFree;
    CogMethod *cogMethod;
    sqInt freeableUsage;
    sqInt freedSoFar;
    sqInt initialFreeSpace;
    sqInt zoneSize;

	zoneSize = limitAddress - baseAddress;
	initialFreeSpace = (limitAddress - mzFreeStart) + methodBytesFreedSinceLastCompaction;
	freedSoFar = initialFreeSpace;
	/* 4 needs to be e.g. a start-up parameter */
	amountToFree = zoneSize / 4;
	freeableUsage = 0;
	do {
		cogMethod = ((CogMethod *) baseAddress);
		while (((((usqInt)cogMethod)) < mzFreeStart)
		 && (freedSoFar < amountToFree)) {
			if (			/* begin shouldFreeMethod:given: */
				(!(((cogMethod->cmType)) == CMFree))
			 && (((cogMethod->cmUsageCount)) <= freeableUsage)) {
				freeMethod(cogMethod);
				freedSoFar += (cogMethod->blockSize);
			}
			cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		}
	} while((freedSoFar < amountToFree)
		 && (((freeableUsage += 1)) < CMMaxUsageCount));
}


/*	Answer that all entries in youngReferrers are in-use and have the
	cmRefersToYoung flag set.
	Used to check that the youngreferrers pruning routines work correctly. */

	/* CogMethodZone>>#kosherYoungReferrers */
sqInt
kosherYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;
    CogMethod *prevMethod;

	if ((youngReferrers > limitAddress)
	 || (youngReferrers < mzFreeStart)) {
		return 0;
	}
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (!((cogMethod->cmRefersToYoung))) {
				return 0;
			}
			if ((occurrencesInYoungReferrers(cogMethod)) != 1) {
				return 0;
			}
		}
		pointer += BytesPerWord;
	}
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		prevMethod = cogMethod;
		if (!(((cogMethod->cmType)) == CMFree)) {
			if ((occurrencesInYoungReferrers(cogMethod)) != (((cogMethod->cmRefersToYoung)
				? 1
				: 0))) {
				return 0;
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (cogMethod == prevMethod) {
			return 0;
		}
	}
	return 1;
}


/*	For assert checking... */

	/* CogMethodZone>>#mcpc:isAtStackCheckOfBlockMethodIn: */
static NoDbgRegParms sqInt
mcpcisAtStackCheckOfBlockMethodIn(sqInt mcpc, CogMethod *cogMethod)
{
	if (((cogMethod->blockEntryOffset)) == 0) {
		return 0;
	}
	return (blockDispatchTargetsForperformarg(cogMethod, stackCheckOffsetOfBlockAtisMcpc, mcpc)) != 0;
}

	/* CogMethodZone>>#methodFor: */
CogMethod *
methodFor(void *address)
{
    CogMethod *cogMethod;
    CogMethod *nextMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((cogMethod < (limitZony()))
	 && ((((usqInt)cogMethod)) <= (((usqInt)address)))) {
		nextMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
		if (nextMethod == cogMethod) {
			return null;
		}
		if (((((usqInt)address)) >= (((usqInt)cogMethod)))
		 && ((((usqInt)address)) < (((usqInt)nextMethod)))) {
			return cogMethod;
		}
		cogMethod = nextMethod;
	}
	return null;
}

	/* CogMethodZone>>#methodsCompiledToMachineCodeInto: */
sqInt
methodsCompiledToMachineCodeInto(sqInt arrayObj)
{
    CogMethod *cogMethod;
    sqInt methodIndex;

	methodIndex = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) >= CMMethod) {
			storePointerUncheckedofObjectwithValue(methodIndex, arrayObj, (cogMethod->methodObject));
			methodIndex += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return methodIndex;
}

	/* CogMethodZone>>#numMethods */
sqInt
numMethods(void)
{
	return methodCount;
}

	/* CogMethodZone>>#numMethodsOfType: */
sqInt
numMethodsOfType(sqInt cogMethodType)
{
    CogMethod *cogMethod;
    sqInt n;

	n = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cogMethodType) {
			n += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	return n;
}

	/* CogMethodZone>>#occurrencesInYoungReferrers: */
static NoDbgRegParms sqInt
occurrencesInYoungReferrers(CogMethod *cogMethod)
{
    sqInt count;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	count = 0;
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		if ((((sqInt)cogMethod)) == (longAt(pointer))) {
			count += 1;
		}
		pointer += BytesPerWord;
	}
	return count;
}

	/* CogMethodZone>>#openPICWithSelector: */
static NoDbgRegParms CogMethod *
openPICWithSelector(sqInt aSelector)
{
    CogMethod *openPIC;

	openPIC = openPICList;
	do {
		if ((openPIC == null)
		 || (((openPIC->selector)) == aSelector)) {
			return openPIC;
		}
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	Some methods have been freed. Compute how much each survivor needs to
	move during the ensuing compaction and record it in the objectHeader
	field. 
	For Sista, where we want PICs to last so they can be observed, we need to
	keep PICs unless
	they are definitely unused. So we need to identify unused PICs. So in
	planCompact, zero the
	usage counts of all PICs, saving the actual usage count in
	blockEntryOffset. Then in
	relocateMethodsPreCompaction (actually in
	relocateIfCallOrMethodReference:mcpc:delta:) restore the usage counts of
	used PICs. Finally in compactCompiledCode, clear the blockEntryOffset
	of the unused PICs; they will then have a zero count and be reclaimed in
	the next code compaction. */

	/* CogMethodZone>>#planCompaction */
static void
planCompaction(void)
{
    CogMethod *cogMethod;
    sqInt delta;

	delta = 0;
	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (((cogMethod->cmType)) == CMFree) {
			delta -= (cogMethod->blockSize);
		}
		else {
			assert((cogMethodDoesntLookKosher(cogMethod)) == 0);
			((((CogMethod *) ((((usqInt)cogMethod)) + codeToDataDelta)))->objectHeader = delta);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethods */
void
printCogMethods(void)
{
    CogMethod *cogMethod;
    sqInt nb;
    sqInt nc;
    sqInt nf;
    sqInt nm;
    sqInt no;
    sqInt nu;


	/* begin printCogMethodsSummarizing: */
	nm = (nb = (nc = (no = (nf = (nu = 0)))));
	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		printCogMethod(cogMethod);
		switch ((cogMethod->cmType)) {
		case CMFree:
			nf += 1;
			break;
		case CMMethod:
			nm += 1;
			break;
		case CMMethodFlaggedForBecome:
			nb += 1;
			break;
		case CMClosedPIC:
			nc += 1;
			break;
		case CMOpenPIC:
			no += 1;
			break;
		default:
			nu += 1;
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	print("CMMethod ");
	printNum(nm);
	if (nb > 0) {
		print(" (flagged for become: ");
		printNum(nb);
		print(")");
	}
	print(" CMClosedPIC ");
	printNum(nc);
	print(" CMOpenPIC ");
	printNum(no);
	print(" CMFree ");
	printNum(nf);
	if (nu > 0) {
		print(" UNKNOWN ");
		printNum(nu);
	}
	print(" total ");
	printNum(((((nm + nc) + no) + nf) + nu) + nb);
	cr();
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsOfType: */
void
printCogMethodsOfType(sqInt cmType)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if (((cogMethod->cmType)) == cmType) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithMethod: */
void
printCogMethodsWithMethod(sqInt methodOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->methodObject)) == methodOop)) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithPrimitive: */
void
printCogMethodsWithPrimitive(sqInt primIdx)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((((cogMethod->cmType)) >= CMMethod)
		 && (primIdx == (primitiveIndexOfMethodheader((cogMethod->methodObject), (cogMethod->methodHeader))))) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogMethodsWithSelector: */
void
printCogMethodsWithSelector(sqInt selectorOop)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while (cogMethod < (limitZony())) {
		if ((!(((cogMethod->cmType)) == CMFree))
		 && (((cogMethod->selector)) == selectorOop)) {
			printCogMethod(cogMethod);
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printCogYoungReferrers */
void
printCogYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!((cogMethod->cmRefersToYoung))) {
			print("*");
		}
		if (((cogMethod->cmType)) == CMFree) {
			print("!");
		}
		if (!(((cogMethod->cmRefersToYoung))
			 && (!(((cogMethod->cmType)) == CMFree)))) {
			print(" ");
		}
		printCogMethod(cogMethod);
		pointer += BytesPerWord;
	}
}


/*	useful for debugging */

	/* CogMethodZone>>#printOpenPICList */
sqInt
printOpenPICList(void)
{
    sqInt n;
    CogMethod *openPIC;


	/* begin printOpenPICListSummarizing: */
	n = 0;
	openPIC = openPICList;
	while (!(openPIC == null)) {
		n += 1;
		printCogMethod(openPIC);
		openPIC = ((CogMethod *) ((openPIC->nextOpenPIC)));
	}
	return n;
}

	/* CogMethodZone>>#pruneYoungReferrers */
static sqInt
pruneYoungReferrers(void)
{
    usqInt dest;
    usqInt next;
    usqInt source;

	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && (((((CogMethod *) (longAt(next))))->cmRefersToYoung)))) break;
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		if (((((CogMethod *) (longAt(source))))->cmRefersToYoung)) {
			assert(source < (dest - BytesPerWord));
			if (!(next == null)) {
				/* convenient first-time flag */
				next = null;
				/* begin ensureWritableCodeZone */
#        if !DUAL_MAPPED_CODE_ZONE
#        endif

			}
			codeLongAtput((dest -= BytesPerWord), longAt(source));
		}
		source -= BytesPerWord;
	}
	youngReferrers = dest;
	assert(kosherYoungReferrers());
	return 0;
}

	/* CogMethodZone>>#relocateAndPruneYoungReferrers */
static sqInt
relocateAndPruneYoungReferrers(void)
{
    CogMethod *cogMethod;
    usqInt dest;
    usqInt next;
    usqInt source;

	assert(youngReferrers <= limitAddress);
	if (youngReferrers == limitAddress) {
		return null;
	}
	dest = limitAddress;
	while (1) {
		next = dest - BytesPerWord;
		if (!((next >= youngReferrers)
		 && ((!(isCMFree(((CogBlockMethod *) ((cogMethod = ((CogMethod *) (longAt(next)))))))))
		 && ((cogMethod->cmRefersToYoung))))) break;
		if (((cogMethod->objectHeader)) != 0) {
			codeLongAtput(next, (((sqInt)cogMethod)) + ((cogMethod->objectHeader)));
		}
		dest = next;
	}
	assert(dest >= youngReferrers);
	source = dest - BytesPerWord;
	while (source >= youngReferrers) {
		cogMethod = ((CogMethod *) (longAt(source)));
		if ((!(((cogMethod->cmType)) == CMFree))
		 && ((cogMethod->cmRefersToYoung))) {
			assert(source < (dest - BytesPerWord));
			if (((cogMethod->objectHeader)) != 0) {
				cogMethod = ((CogMethod *) ((((sqInt)cogMethod)) + (((sqInt)((cogMethod->objectHeader))))));
			}
			codeLongAtput((dest -= BytesPerWord), ((sqInt)cogMethod));
		}
		source -= BytesPerWord;
	}
	/* this assert must be deferred until after compaction.  See the end of compactCogCompiledCode */
	/* self assert: self kosherYoungReferrers */
	youngReferrers = dest;
	return 0;
}


/*	All surviving methods have had the amount they are going to relocate by
	stored in their objectHeader fields. Relocate all relative calls so that
	after the compaction of both the method containing each call and the call
	target the calls invoke the same target. */

	/* CogMethodZone>>#relocateMethodsPreCompaction */
static sqInt
relocateMethodsPreCompaction(void)
{
    CogMethod *cogMethod;

	cogMethod = ((CogMethod *) baseAddress);
	while ((((usqInt)cogMethod)) < mzFreeStart) {
		if (!(((cogMethod->cmType)) == CMFree)) {
			if (((cogMethod->cmType)) == CMClosedPIC) {
				relocateCallsInClosedPIC(cogMethod);
			}
			else {
				relocateCallsAndSelfReferencesInMethod(cogMethod);
			}
		}
		cogMethod = ((CogMethod *) (roundUpToMethodAlignment(backEnd(), (((sqInt)cogMethod)) + ((cogMethod->blockSize)))));
	}
	relocateAndPruneYoungReferrers();
	return 1;
}

	/* CogMethodZone>>#removeFromOpenPICList: */
static NoDbgRegParms sqInt
removeFromOpenPICList(CogMethod *anOpenPIC)
{
    CogMethod *prevPIC;

	assert(isCMOpenPIC(((CogBlockMethod *) anOpenPIC)));
	if (!openPICList) {
		return null;
	}
	assert((isCMOpenPIC(((CogBlockMethod *) openPICList)))
	 && ((!((openPICList->nextOpenPIC)))
	 || (isCMOpenPIC(((CogBlockMethod *) (((CogMethod *) ((openPICList->nextOpenPIC)))))))));
	if (anOpenPIC == openPICList) {
		/* N.B. Use self rather than coInterpreter to avoid attempting to cast nil.
		   Conversion to CogMethod done in the nextOpenPIC accessor. */
		openPICList = ((CogMethod *) ((anOpenPIC->nextOpenPIC)));
		return null;
	}
	prevPIC = openPICList;
	do {
		assert((prevPIC != null)
		 && (isCMOpenPIC(((CogBlockMethod *) prevPIC))));
		if (((prevPIC->nextOpenPIC)) == (((usqInt)anOpenPIC))) {
			((((CogMethod *) ((((usqInt)prevPIC)) + codeToDataDelta)))->nextOpenPIC = (anOpenPIC->nextOpenPIC));
			return null;
		}
		prevPIC = ((CogMethod *) ((prevPIC->nextOpenPIC)));
	} while(1);
	return 0;
}


/*	Determine the default alignment for the start of a CogMethod, which in
	turn determines the size of the mask used to distinguish the checked and
	unchecked entry-points, used to distinguish normal and super sends on
	method unlinking.
	This is passed onto the backEnd to allow processors with coarse
	instructions (ARM) to increase the alignment if required. */

	/* CogMethodZone>>#roundUpLength: */
static NoDbgRegParms sqInt
roundUpLength(sqInt numBytes)
{
	return roundUpToMethodAlignment(backEnd(), numBytes);
}

	/* CogMethodZone>>#voidOpenPICList */
static void
voidOpenPICList(void)
{
	openPICList = null;
}

	/* CogMethodZone>>#voidUnpairedMethodList */
static void
voidUnpairedMethodList(void)
{
}

	/* CogMethodZone>>#voidYoungReferrersPostTenureAll */
static void
voidYoungReferrersPostTenureAll(void)
{
    CogMethod *cogMethod;
    usqInt pointer;

	assert(youngReferrers <= limitAddress);
	pointer = youngReferrers;
	while (pointer < limitAddress) {
		cogMethod = ((CogMethod *) (longAt(pointer)));
		if (!(((cogMethod->cmType)) == CMFree)) {
			(cogMethod->cmRefersToYoung = 0);
		}
		pointer += BytesPerWord;
	}
	youngReferrers = limitAddress;
}

	/* CogMethodZone>>#whereIsMaybeCodeThing: */
char *
whereIsMaybeCodeThing(sqInt anOop)
{
	if (oopisGreaterThanOrEqualToandLessThan(anOop, codeBase, limitAddress)) {
		if (oopisLessThan(anOop, minCogMethodAddress())) {
			return " is in generated runtime";
		}
		if (oopisLessThan(anOop, mzFreeStart)) {
			return " is in generated methods";
		}
		if (oopisLessThan(anOop, youngReferrers)) {
			return " is in code zone";
		}
		return " is in young referrers";
	}
	return null;
}

	/* CogObjectRepresentation>>#checkValidObjectReference: */
static NoDbgRegParms sqInt
checkValidObjectReference(sqInt anOop)
{
	return (!(isImmediate(anOop)))
	 && ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentation>>#genCmpClassFloatCompactIndexR: */
static NoDbgRegParms AbstractInstruction *
genCmpClassFloatCompactIndexR(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, ClassFloatCompactIndex, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(ClassFloatCompactIndex));
	}
	return anInstruction;
}

	/* CogObjectRepresentation>>#genCmpClassMethodContextCompactIndexR: */
static NoDbgRegParms AbstractInstruction *
genCmpClassMethodContextCompactIndexR(sqInt reg)
{
    AbstractInstruction *anInstruction;

	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(ClassMethodContextCompactIndex));
	}
	return anInstruction;
}

	/* CogObjectRepresentation>>#genDoubleArithmetic:preOpCheck: */
static NoDbgRegParms int
genDoubleArithmeticpreOpCheck(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg))
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpFailClass;
    AbstractInstruction *jumpImmediate;

	jumpFailCheck = ((AbstractInstruction *) 0);
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpFailClass = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (!(preOpCheckOrNil == null)) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	maybeGenConvertIfSmallFloatInscratchRegintoandJumpTo(Arg0Reg, TempReg, DPFPReg1, doOp);
	genConvertSmallIntegerToIntegerInReg(ClassReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, ClassReg, DPFPReg1);
	genoperand(Jump, ((sqInt)doOp));
	jmpTarget(jumpFailAlloc, jmpTarget(jumpFailClass, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	if (!(preOpCheckOrNil == null)) {
		jmpTarget(jumpFailCheck, ((AbstractInstruction *) (((jumpFailClass->operands))[0])));
	}
	return 0;
}

	/* CogObjectRepresentation>>#genDoubleComparison:invert: */
static NoDbgRegParms int
genDoubleComparisoninvert(AbstractInstruction * NoDbgRegParms (*jumpOpcodeGenerator)(void *), sqInt invertComparison)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *compare;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpImmediate;


	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	if (invertComparison) {
		/* May need to invert for NaNs */
		compare = genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		compare = genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}
	/* FP jumps are a little weird */
	jumpCond = jumpOpcodeGenerator(0);
	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(falseObject()));
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, 
	/* begin genMoveConstant:R: */
gMoveCqR(trueObject(), ReceiverResultReg));
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	maybeGenConvertIfSmallFloatInscratchRegintoandJumpTo(Arg0Reg, TempReg, DPFPReg1, compare);
	genConvertSmallIntegerToIntegerInReg(Arg0Reg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, Arg0Reg, DPFPReg1);
	genoperand(Jump, ((sqInt)compare));
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Generate a compare and branch to test if aRegister and bRegister contains
	other than SmallIntegers,
	i.e. don't branch if both aRegister and bRegister contain SmallIntegers.
	Answer the jump. Destroy scratchRegister if required. */

	/* CogObjectRepresentation>>#genJumpNotSmallIntegersIn:and:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallIntegersInandscratch(sqInt aRegister, sqInt bRegister, sqInt scratchRegister)
{

	/* begin MoveR:R: */
	genoperandoperand(MoveRR, aRegister, scratchRegister);
	genoperandoperand(AndRR, bRegister, scratchRegister);
	return genJumpNotSmallIntegerInScratchReg(scratchRegister);
}

	/* CogObjectRepresentation>>#genLoadSlot:sourceReg:destReg: */
static NoDbgRegParms sqInt
genLoadSlotsourceRegdestReg(sqInt index, sqInt sourceReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	/* begin MoveMw:r:R: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveAdd */
static int
genPrimitiveAdd(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	/* begin AddR:R: */
	genoperandoperand(AddRR, ReceiverResultReg, ClassReg);
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveAsCharacter */
static int
genPrimitiveAsCharacter(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveAsFloat */
static int
genPrimitiveAsFloat(void)
{
    AbstractInstruction *jumpFailAlloc;


	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genConvertSmallIntegerToIntegerInReg(TempReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveAtPut */
static int
genPrimitiveAtPut(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitAnd */
static int
genPrimitiveBitAnd(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* Whether the SmallInteger tags are zero or non-zero, anding them together will preserve them. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitOr */
static int
genPrimitiveBitOr(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* Whether the SmallInteger tags are zero or non-zero, oring them together will preserve them. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	rTemp := rArg0
	rClass := tTemp
	rTemp := rTemp & 1
	jz nonInt
	rClass >>= 1
	cmp 0,rClass
	jge neg
	cmp 31,rClass // numSmallIntegerBits, jge for sign
	jge tooBig
	rTemp := rReceiver
	rTemp <<= rClass
	rTemp >>= rClass (arithmetic)
	cmp rTemp,rReceiver
	jnz ovfl
	rReceiver := rReceiver - 1
	rReceiver := rReceiver <<= rClass
	rReceiver := rReceiver + 1
	ret
	neg:
	rClass := 0 - rClass
	cmp 31,rClass // numSmallIntegerBits
	jge inRange
	rClass := 31
	inRange
	rReceiver := rReceiver >>= rClass.
	rReceiver := rReceiver | smallIntegerTags.
	ret
	ovfl
	tooBig
	nonInt:
	fail
 */

	/* CogObjectRepresentation>>#genPrimitiveBitShift */
static int
genPrimitiveBitShift(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jumpInRange;
    AbstractInstruction *jumpNegative;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;
    AbstractInstruction *jumpTooBig;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genConvertSmallIntegerToIntegerInReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpNegative))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(0));
		}
	}
	jumpNegative = genConditionalBranchoperand(JumpNegative, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant = numSmallIntegerBits();
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant));
	}
	jumpTooBig = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genoperandoperand(LogicalShiftLeftRR, ClassReg, TempReg);
	genoperandoperand(ArithmeticShiftRightRR, ClassReg, TempReg);
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, ReceiverResultReg);
	jumpOvfl = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);
	/* begin LogicalShiftLeftR:R: */
	genoperandoperand(LogicalShiftLeftRR, ClassReg, ReceiverResultReg);
	genAddSmallIntegerTagsTo(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegative, genoperand(NegateR, ClassReg));
	/* begin CmpCq:R: */
	quickConstant1 = numSmallIntegerBits();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant1, ClassReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(quickConstant1));
	}
	jumpInRange = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin MoveCq:R: */
	quickConstant2 = numSmallIntegerBits();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(MoveCqR, quickConstant2, ClassReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(quickConstant2));
	}
	jmpTarget(jumpInRange, genoperandoperand(ArithmeticShiftRightRR, ClassReg, ReceiverResultReg));
	genClearAndSetSmallIntegerTagsIn(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, jmpTarget(jumpTooBig, jmpTarget(jumpOvfl, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveBitXor */
static int
genPrimitiveBitXor(void)
{
    AbstractInstruction *jumpNotSI;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	/* Clear one or the other tag so that xoring will preserve them. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, Arg0Reg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveClass */
static int
genPrimitiveClass(void)
{
    sqInt reg;

	reg = ReceiverResultReg;
	if (methodOrBlockNumArgs > 0) {
		if (methodOrBlockNumArgs > 1) {
			return UnimplementedPrimitive;
		}
		reg = Arg0Reg;
		/* begin genLoadArgAtDepth:into: */
		assert(0 < (numRegArgs()));
	}
	if ((genGetClassObjectOfintoscratchRegmayBeAForwarder(reg, ReceiverResultReg, TempReg, reg != ReceiverResultReg)) == BadRegisterSet) {
		genGetClassObjectOfintoscratchRegmayBeAForwarder(reg, ClassReg, TempReg, reg != ReceiverResultReg);
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	}
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDiv */
static int
genPrimitiveDiv(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	/* We must shift away the tags, not just subtract them, so that the
	   overflow case doesn't actually overflow the machine instruction. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(0));
		}
	}
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	/* If arg and remainder signs are different we must round down. */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction2 = genoperandoperand(CmpCqR, 0, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction2)) {
			(anInstruction2->dependent = locateLiteral(0));
		}
	}
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin SubCq:R: */
	anInstruction3 = genoperandoperand(SubCqR, 1, TempReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(1));
	}
	jmpTarget(jumpSameSign, (convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveDivide */
static int
genPrimitiveDivide(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpInexact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOverflow;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* We must shift away the tags, not just subtract them, so that the
	   overflow case doesn't actually overflow the machine instruction. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* test for overflow; the only case is SmallInteger minVal / -1 */
	jumpInexact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	jumpOverflow = genJumpNotSmallIntegerValuescratch(TempReg, Arg1Reg);
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOverflow, jmpTarget(jumpInexact, jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveEqual */
static int
genPrimitiveEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpZero, gJumpFPEqual, 0)
		: genSmallIntegerComparison(JumpZero));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatAdd */
static int
genPrimitiveFloatAdd(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleArithmeticpreOpCheck(AddRdRd, null)
		: genPureDoubleArithmeticpreOpCheck(AddRdRd, null));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatDivide */
static int
genPrimitiveFloatDivide(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleArithmeticpreOpCheck(DivRdRd, genDoubleFailIfZeroArgRcvrarg)
		: genPureDoubleArithmeticpreOpCheck(DivRdRd, genDoubleFailIfZeroArgRcvrarg));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatEqual */
static int
genPrimitiveFloatEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleComparisoninvert(gJumpFPEqual, 0)
		: genPureDoubleComparisoninvert(gJumpFPEqual, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatGreaterOrEqual */
static int
genPrimitiveFloatGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleComparisoninvert(gJumpFPGreaterOrEqual, 0)
		: genPureDoubleComparisoninvert(gJumpFPGreaterOrEqual, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatGreaterThan */
static int
genPrimitiveFloatGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleComparisoninvert(gJumpFPGreater, 0)
		: genPureDoubleComparisoninvert(gJumpFPGreater, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatLessOrEqual */
static int
genPrimitiveFloatLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleComparisoninvert(gJumpFPGreaterOrEqual, 1)
		: genPureDoubleComparisoninvert(gJumpFPGreaterOrEqual, 1));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatLessThan */
static int
genPrimitiveFloatLessThan(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleComparisoninvert(gJumpFPGreater, 1)
		: genPureDoubleComparisoninvert(gJumpFPGreater, 1));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatMultiply */
static int
genPrimitiveFloatMultiply(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleArithmeticpreOpCheck(MulRdRd, null)
		: genPureDoubleArithmeticpreOpCheck(MulRdRd, null));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatNotEqual */
static int
genPrimitiveFloatNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleComparisoninvert(gJumpFPNotEqual, 0)
		: genPureDoubleComparisoninvert(gJumpFPNotEqual, 0));
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSquareRoot */
static int
genPrimitiveFloatSquareRoot(void)
{
    AbstractInstruction *jumpFailAlloc;

	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	/* begin SqrtRd: */
	genoperand(SqrtRd, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFailAlloc, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* CogObjectRepresentation>>#genPrimitiveFloatSubtract */
static int
genPrimitiveFloatSubtract(void)
{
	return (primitiveDoMixedArithmetic()
		? genDoubleArithmeticpreOpCheck(SubRdRd, null)
		: genPureDoubleArithmeticpreOpCheck(SubRdRd, null));
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterOrEqual */
static int
genPrimitiveGreaterOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreaterOrEqual, gJumpFPGreaterOrEqual, 0)
		: genSmallIntegerComparison(JumpGreaterOrEqual));
}

	/* CogObjectRepresentation>>#genPrimitiveGreaterThan */
static int
genPrimitiveGreaterThan(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpGreater, gJumpFPGreater, 0)
		: genSmallIntegerComparison(JumpGreater));
}


/*	Implementation notes: there are two reasons to use TempReg
	-1) if primitive fails, ReceiverResultReg must remain unchanged (we
	CompletePrimitive) -2) CLZ/BSR only work on 64bits for registers R0-R7 on
	Intel X64. But Win64 uses R9
	Normally, this should be backEnd dependent, but for now we have a single
	64bits target...
 */

	/* CogObjectRepresentation>>#genPrimitiveHighBit */
static int
genPrimitiveHighBit(void)
{
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpNegativeReceiver;
    AbstractInstruction *jumpNegativeReceiver2;


	/* remove excess tag bits from the receiver oop */
	/* and use the abstract cogit facility for case of single tag-bit */
	/* begin genHighBitIn:ofSmallIntegerOopWithSingleTagBit: */
	backEnd();
	/* begin genHighBitClzIn:ofSmallIntegerOopWithSingleTagBit: */
	genoperandoperand(ClzRR, ReceiverResultReg, TempReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction1 = genoperandoperand(CmpCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(0));
		}
	}
	/* Note the nice bit trick below:
	   highBit_1based_of_small_int_value = (BytesPerWord * 8) - leadingZeroCout_of_oop - 1 toAccountForTagBit.
	   This is like 2 complements (- reg - 1) on (BytesPerWord * 8) log2 bits, or exactly a bit invert operation... */
	jumpNegativeReceiver2 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin gen:literal:operand: */
	checkLiteralforInstruction((BytesPerWord * 8) - 1, genoperandoperand(XorCwR, (BytesPerWord * 8) - 1, TempReg));
	jumpNegativeReceiver = jumpNegativeReceiver2;
	if (jumpNegativeReceiver == 0) {
		return UnimplementedPrimitive;
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNegativeReceiver, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveIdentical */
static sqInt
genPrimitiveIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(0);
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveImmediateAsInteger */
static int
genPrimitiveImmediateAsInteger(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveIntegerAt */
static int
genPrimitiveIntegerAt(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveIntegerAtPut */
static int
genPrimitiveIntegerAtPut(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveLessOrEqual */
static int
genPrimitiveLessOrEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpLessOrEqual, gJumpFPGreaterOrEqual, 1)
		: genSmallIntegerComparison(JumpLessOrEqual));
}

	/* CogObjectRepresentation>>#genPrimitiveLessThan */
static int
genPrimitiveLessThan(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpLess, gJumpFPGreater, 1)
		: genSmallIntegerComparison(JumpLess));
}


/*	subclasses override if they so desire */

	/* CogObjectRepresentation>>#genPrimitiveMakePoint */
static int
genPrimitiveMakePoint(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveMod */
static int
genPrimitiveMod(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpSameSign;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genRemoveSmallIntegerTagsInScratchReg(ClassReg);
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, Arg1Reg);
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genRemoveSmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* If arg and remainder signs are different we must reflect around zero. */
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction1 = genoperandoperand(CmpCqR, 0, Arg1Reg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(0));
		}
	}
	jumpSameSign = genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
	/* begin XorR:R: */
	genoperandoperand(XorRR, ClassReg, Arg1Reg);
	genoperandoperand(AddRR, Arg1Reg, ClassReg);
	jmpTarget(jumpSameSign, jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genSetSmallIntegerTagsIn(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveMultiply */
static int
genPrimitiveMultiply(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(processorHasMultiplyAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	genoperandoperand(MoveRR, ReceiverResultReg, Arg1Reg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	genRemoveSmallIntegerTagsInScratchReg(Arg1Reg);
	/* begin MulOverflowR:R: */
	genMulRR(backEnd, Arg1Reg, ClassReg);
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genSetSmallIntegerTagsIn(ClassReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveNew */
static int
genPrimitiveNew(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveNewMethod */
static int
genPrimitiveNewMethod(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveNewWithArg */
static int
genPrimitiveNewWithArg(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveNotEqual */
static int
genPrimitiveNotEqual(void)
{
	return (primitiveDoMixedArithmetic()
		? genSmallIntegerComparisonorDoubleComparisoninvert(JumpNonZero, gJumpFPNotEqual, 0)
		: genSmallIntegerComparison(JumpNonZero));
}

	/* CogObjectRepresentation>>#genPrimitiveNotIdentical */
static sqInt
genPrimitiveNotIdentical(void)
{
	return genPrimitiveIdenticalOrNotIf(1);
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveObjectAt */
static int
genPrimitiveObjectAt(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveQuo */
static int
genPrimitiveQuo(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *convert;
    AbstractInstruction *jumpExact;
    AbstractInstruction *jumpIsSI;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpZero;

	if (!(processorHasDivQuoRemAndMClassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	/* We must shift away the tags, not just subtract them, so that the
	   overflow case doesn't actually overflow the machine instruction. */
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	genShiftAwaySmallIntegerTagsInScratchReg(ClassReg);
	if (!(setsConditionCodesFor(lastOpcode(), JumpZero))) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, 0, ClassReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(0));
		}
	}
	jumpZero = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genShiftAwaySmallIntegerTagsInScratchReg(TempReg);
	gDivRRQuoRem(ClassReg, TempReg, TempReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, ClassReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	jumpExact = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	convert = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	genConvertIntegerInRegtoSmallIntegerInReg(TempReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpExact, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpIsSI = genJumpIsSmallIntegerValuescratch(TempReg, Arg1Reg);
	jmpTarget(jumpIsSI, convert);
	jmpTarget(jumpZero, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveShallowCopy */
static int
genPrimitiveShallowCopy(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveSlotAt */
static int
genPrimitiveSlotAt(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveSlotAtPut */
static int
genPrimitiveSlotAtPut(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveStringAtPut */
static int
genPrimitiveStringAtPut(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveStringCompareWith */
static int
genPrimitiveStringCompareWith(void)
{
	return UnimplementedPrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveStringReplace */
static int
genPrimitiveStringReplace(void)
{
	return UnimplementedPrimitive;
}

	/* CogObjectRepresentation>>#genPrimitiveSubtract */
static int
genPrimitiveSubtract(void)
{
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpOvfl;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ReceiverResultReg, TempReg);
	genoperandoperand(SubRR, Arg0Reg, TempReg);
	jumpOvfl = genConditionalBranchoperand(JumpOverflow, ((sqInt)0));
	genAddSmallIntegerTagsTo(TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpOvfl, jmpTarget(jumpNotSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	subclasses override if they can */

	/* CogObjectRepresentation>>#genPrimitiveUninitializedNewWithArg */
static int
genPrimitiveUninitializedNewWithArg(void)
{
	return UnimplementedPrimitive;
}


/*	In the Pure version, mixed arithmetic with SmallInteger is forbidden */

	/* CogObjectRepresentation>>#genPureDoubleArithmetic:preOpCheck: */
static NoDbgRegParms int
genPureDoubleArithmeticpreOpCheck(sqInt arithmeticOperator, AbstractInstruction *(*preOpCheckOrNil)(int rcvrReg, int argReg))
{
    AbstractInstruction *doOp;
    AbstractInstruction *jumpFailAlloc;
    AbstractInstruction *jumpFailCheck;
    AbstractInstruction *jumpFailClass;
    AbstractInstruction *jumpImmediate;

	jumpFailCheck = ((AbstractInstruction *) 0);
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, ClassReg);
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpFailClass = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	doOp = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if (!(preOpCheckOrNil == null)) {
		jumpFailCheck = preOpCheckOrNil(DPFPReg0, DPFPReg1);
	}
	genoperandoperand(arithmeticOperator, DPFPReg1, DPFPReg0);
	jumpFailAlloc = genAllocFloatValueintoscratchRegscratchReg(DPFPReg0, SendNumArgsReg, ClassReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	maybeGenConvertIfSmallFloatInscratchRegintoandJumpTo(Arg0Reg, TempReg, DPFPReg1, doOp);
	jmpTarget(jumpFailAlloc, jmpTarget(jumpFailClass, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	if (!(preOpCheckOrNil == null)) {
		jmpTarget(jumpFailCheck, ((AbstractInstruction *) (((jumpFailClass->operands))[0])));
	}
	return 0;
}


/*	In the Pure version, mixed arithmetic with SmallInteger is forbidden */

	/* CogObjectRepresentation>>#genPureDoubleComparison:invert: */
static NoDbgRegParms int
genPureDoubleComparisoninvert(AbstractInstruction * NoDbgRegParms (*jumpOpcodeGenerator)(void *), sqInt invertComparison)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *compare;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpImmediate;


	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genGetDoubleValueOfinto(ReceiverResultReg, DPFPReg0);
	jumpImmediate = genJumpImmediate(Arg0Reg);
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	jumpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	if (invertComparison) {
		/* May need to invert for NaNs */
		compare = genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		compare = genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}
	/* FP jumps are a little weird */
	jumpCond = jumpOpcodeGenerator(0);
	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(falseObject()));
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, 
	/* begin genMoveConstant:R: */
gMoveCqR(trueObject(), ReceiverResultReg));
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpImmediate, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	maybeGenConvertIfSmallFloatInscratchRegintoandJumpTo(Arg0Reg, TempReg, DPFPReg1, compare);
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#genSmallIntegerComparison: */
static NoDbgRegParms int
genSmallIntegerComparison(sqInt jumpOpcode)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpFail;
    AbstractInstruction *jumpTrue;

	if (!(mclassIsSmallInteger())) {
		return UnimplementedPrimitive;
	}
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpFail = genJumpNotSmallInteger(Arg0Reg);
	/* begin CmpR:R: */
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpTrue = genConditionalBranchoperand(jumpOpcode, 0);
	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(falseObject()));
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpTrue, 
	/* begin genMoveConstant:R: */
gMoveCqR(trueObject(), ReceiverResultReg));
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Stack looks like
	return address */

	/* CogObjectRepresentation>>#genSmallIntegerComparison:orDoubleComparison:invert: */
static NoDbgRegParms int
genSmallIntegerComparisonorDoubleComparisoninvert(sqInt jumpOpcode, AbstractInstruction * NoDbgRegParms (*jumpFPOpcodeGenerator)(void *), sqInt invertComparison)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpCond;
    AbstractInstruction *jumpFail;
    int r;

	r = genSmallIntegerComparison(jumpOpcode);
	if (r < 0) {
		return r;
	}
#  if defined(DPFPReg0)
	/* Fall through on non-SmallInteger argument.  Argument may be a Float : let us check or fail */
	genGetCompactClassIndexNonImmOfinto(Arg0Reg, SendNumArgsReg);
	genCmpClassFloatCompactIndexR(SendNumArgsReg);
	/* It was a Float, so convert the receiver to double and perform the operation */
	jumpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, ReceiverResultReg, DPFPReg0);
	genGetDoubleValueOfinto(Arg0Reg, DPFPReg1);
	if (invertComparison) {
		/* May need to invert for NaNs */
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg0, DPFPReg1);
	}
	else {
		/* begin CmpRd:Rd: */
		genoperandoperand(CmpRdRd, DPFPReg1, DPFPReg0);
	}
	/* FP jumps are a little weird */
	jumpCond = jumpFPOpcodeGenerator(0);
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(falseObject()));
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCond, 
	/* begin genMoveConstant:R: */
gMoveCqR(trueObject(), ReceiverResultReg));
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFail, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
#  endif // defined(DPFPReg0)

	return CompletePrimitive;
}

	/* CogObjectRepresentation>>#isUnannotatableConstant: */
static NoDbgRegParms sqInt
isUnannotatableConstant(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && ((isImmediate((simStackEntry->constant)))
	 || (!(	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject((simStackEntry->constant)))
	 && (oopisGreaterThan((simStackEntry->constant), trueObject())))));
}


/*	If the receiver supports immediate floats then generate a test for a
	smallFloat in oopReg,
	converting it to the float value in dpReg and jumping to targetInst.
	Otherwise do nothing. */

	/* CogObjectRepresentation>>#maybeGenConvertIfSmallFloatIn:scratchReg:into:andJumpTo: */
static NoDbgRegParms sqInt
maybeGenConvertIfSmallFloatInscratchRegintoandJumpTo(sqInt oopReg, sqInt scratch, sqInt dpReg, AbstractInstruction *targetInst)
{
	return 0;
}


/*	If required, generate a shift of the register containing the class tag in
	a method cache probe.
	By default this is a no-op. Subclasses redefine as required. */

	/* CogObjectRepresentation>>#maybeShiftClassTagRegisterForMethodCacheProbe: */
static NoDbgRegParms sqInt
maybeShiftClassTagRegisterForMethodCacheProbe(sqInt classTagReg)
{
	return 0;
}


/*	Answer if the cacheTag is not unmarked, i.e. answer true for compact
	class indices and immediates; only answer false for unmarked objects */

	/* CogObjectRepresentationForSqueakV3>>#cacheTagIsMarked: */
static NoDbgRegParms sqInt
cacheTagIsMarked(sqInt cacheTag)
{
	if (!(couldBeObject(cacheTag))) {
		return 1;
	}
	assert(addressCouldBeObj(cacheTag));
	return isMarked(cacheTag);
}

	/* CogObjectRepresentationForSqueakV3>>#checkValidOopReference: */
static NoDbgRegParms sqInt
checkValidOopReference(sqInt anOop)
{
	return ((anOop & 1))
	 || ((heapMapAtWord(pointerForOop(anOop))) != 0);
}

	/* CogObjectRepresentationForSqueakV3>>#classForInlineCacheTag: */
static NoDbgRegParms sqInt
classForInlineCacheTag(sqInt inlineCacheTag)
{
	if ((inlineCacheTag & 1)) {
		return classSmallInteger();
	}
	if (couldBeObject(inlineCacheTag)) {
		return inlineCacheTag;
	}
	return compactClassAt(((usqInt)(inlineCacheTag)) >> (compactClassFieldLSB()));
}


/*	This is the mask for the field when shifted into the least significant
	bits 
 */

	/* CogObjectRepresentationForSqueakV3>>#compactClassFieldMask */
static sqInt
compactClassFieldMask(void)
{
	return (1U << (compactClassFieldWidth())) - 1;
}


/*	Note this version filters-out compact class indices via the >= nilObj
	clause 
 */

	/* CogObjectRepresentationForSqueakV3>>#couldBeObject: */
static NoDbgRegParms sqInt
couldBeObject(sqInt oop)
{
	return (isNonIntegerObject(oop))
	 && (oopisGreaterThanOrEqualTo(oop, nilObject()));
}


/*	Short-circuit the interpreter call if a frame is already married. */

	/* CogObjectRepresentationForSqueakV3>>#genActiveContextTrampoline */
static usqInt
genActiveContextTrampoline(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jumpSingle;

	zeroOpcodeIndex();
	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, FoxMethod, FPReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(FoxMethod));
	}
	/* begin AndCq:R: */
	anInstruction1 = genoperandoperand(AndCqR, MFMethodFlagHasContextFlag, TempReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(MFMethodFlagHasContextFlag));
	}
	jumpSingle = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction2 = genoperandoperandoperand(MoveMwrR, FoxThisContext, FPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(FoxThisContext));
	}
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jumpSingle, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceActiveContext, "ceActiveContextTrampoline", 0, null, null, null, null, 0 /* begin emptyRegisterMask */, 1, ReceiverResultReg, 1);
}

	/* CogObjectRepresentationForSqueakV3>>#genAddSmallIntegerTagsTo: */
static NoDbgRegParms sqInt
genAddSmallIntegerTagsTo(sqInt aRegister)
{
    AbstractInstruction *anInstruction;

	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, 1, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genAllocFloatValue:into:scratchReg:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genAllocFloatValueintoscratchRegscratchReg(sqInt dpreg, sqInt resultReg, sqInt scratch1, sqInt scratch2)
{
    usqIntptr_t allocSize;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpFail;
    usqIntptr_t newFloatHeaderSansHash;

	allocSize = BaseHeaderSize + (sizeof(double));
	newFloatHeaderSansHash = (((((int)((usqInt)(ClassFloatCompactIndex) << (compactClassFieldLSB())))) | (formatOfClass(classFloat()))) | allocSize) | HeaderTypeShort;
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveAwR, freeStartAddress(), resultReg));
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, allocSize, resultReg, scratch1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(allocSize));
	}
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(scavengeThresholdAddress(), genoperandoperand(MoveAwR, scavengeThresholdAddress(), scratch2));
	assert(!((scratch2 == SPReg)));
	genoperandoperand(CmpRR, scratch2, scratch1);
	jumpFail = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, resultReg, scratch2);
	flag("newObjectHash");
	/* begin AndCq:R: */
	anInstruction1 = genoperandoperand(AndCqR, ((int)((usqInt)(HashMaskUnshifted) << BytesPerWord)), scratch2);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(((int)((usqInt)(HashMaskUnshifted) << BytesPerWord))));
	}
	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, HashBitsOffset - BytesPerWord, scratch2);
	anInstruction2 = genoperandoperand(OrCqR, newFloatHeaderSansHash, scratch2);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(newFloatHeaderSansHash));
	}
	/* begin MoveR:Mw:r: */
	anInstruction3 = genoperandoperandoperand(MoveRMwr, scratch2, 0, resultReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(0));
	}
	/* begin MoveRd:M64:r: */
	anInstruction4 = genoperandoperandoperand(MoveRdM64r, dpreg, BaseHeaderSize, resultReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(BaseHeaderSize));
	}
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(freeStartAddress(), genoperandoperand(MoveRAw, scratch1, freeStartAddress()));
	return jumpFail;
}


/*	Set the SmallInteger tag bits when the tag bits may be filled with
	garbage. 
 */

	/* CogObjectRepresentationForSqueakV3>>#genClearAndSetSmallIntegerTagsIn: */
static NoDbgRegParms sqInt
genClearAndSetSmallIntegerTagsIn(sqInt scratchReg)
{
	return genSetSmallIntegerTagsIn(scratchReg);
}

	/* CogObjectRepresentationForSqueakV3>>#genConvertIntegerInReg:toSmallIntegerInReg: */
static NoDbgRegParms sqInt
genConvertIntegerInRegtoSmallIntegerInReg(sqInt srcReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;

	gLogicalShiftLeftCqRR(1, srcReg, destReg);
	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, 1, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genConvertIntegerToSmallIntegerInReg: */
static NoDbgRegParms sqInt
genConvertIntegerToSmallIntegerInReg(sqInt reg)
{
    AbstractInstruction *anInstruction;


	/* begin LogicalShiftLeftCq:R: */
	genoperandoperand(LogicalShiftLeftCqR, 1, reg);
	anInstruction = genoperandoperand(AddCqR, 1, reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genConvertSmallIntegerToIntegerInReg: */
static NoDbgRegParms sqInt
genConvertSmallIntegerToIntegerInReg(sqInt reg)
{

	/* begin ArithmeticShiftRightCq:R: */
	genoperandoperand(ArithmeticShiftRightCqR, 1, reg);
	return 0;
}


/*	Create a closure with the given startpc, numArgs and numCopied
	within a context with ctxtNumArgs, large if isLargeCtxt that is in a
	block if isInBlock. If numCopied > 0 pop those values off the stack. */
/*	see ceClosureCopyDescriptor: */

	/* CogObjectRepresentationForSqueakV3>>#genCreateClosureAt:numArgs:numCopied:contextNumArgs:large:inBlock: */
static NoDbgRegParms sqInt
genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(sqInt bcpc, sqInt numArgs, sqInt numCopied, sqInt ctxtNumArgs, sqInt isLargeCtxt, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt quickConstant;

	/* begin MoveCq:R: */
	quickConstant = (numArgs + (((sqInt)((usqInt)(numCopied) << 6)))) + (((sqInt)((usqInt)(bcpc) << 12)));
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceClosureCopyTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	if (numCopied > 0) {
		/* begin AddCq:R: */
		anInstruction1 = genoperandoperand(AddCqR, numCopied * BytesPerWord, SPReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(numCopied * BytesPerWord));
		}
	}
	return 0;
}


/*	Do the store check. Answer the argument for the benefit of the code
	generator; ReceiverResultReg may be caller-saved and hence smashed by this
	call. Answering
	it allows the code generator to reload ReceiverResultReg cheaply. */

	/* CogObjectRepresentationForSqueakV3>>#generateObjectRepresentationTrampolines */
static void
generateObjectRepresentationTrampolines(void)
{
	ceStoreCheckTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceStoreCheck, "ceStoreCheckTrampoline", 1, ReceiverResultReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, 
	/* begin returnRegForStoreCheck */
(((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)
		? ReceiverResultReg
		: ABIResultReg), 0);
	ceCreateNewArrayTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceNewArraySlotSize, "ceCreateNewArrayTrampoline", 1, SendNumArgsReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, ReceiverResultReg, 0);
	cePositive32BitIntegerTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(positive32BitIntegerFor, "cePositive32BitIntegerTrampoline", 1, ReceiverResultReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, TempReg, 0);
	ceActiveContextTrampoline = genActiveContextTrampoline();
	ceClosureCopyTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceClosureCopyDescriptor, "ceClosureCopyTrampoline", 1, SendNumArgsReg, null, null, null, ((CallerSavedRegisterMask | ((1U << ReceiverResultReg))) - ((1U << ReceiverResultReg))), 1, ReceiverResultReg, 0);
}


/*	Get the active context into ReceiverResultReg, creating it if necessary. */

	/* CogObjectRepresentationForSqueakV3>>#genGetActiveContextNumArgs:large:inBlock: */
static NoDbgRegParms void
genGetActiveContextNumArgslargeinBlock(sqInt numArgs, sqInt isLargeContext, sqInt isInBlock)
{
    AbstractInstruction *abstractInstruction;


	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceActiveContextTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
}


/*	Fetch the instance's class format into destReg, assuming the object is
	non-int. 
 */

	/* CogObjectRepresentationForSqueakV3>>#genGetClassFormatOfNonInt:into:scratchReg: */
static NoDbgRegParms sqInt
genGetClassFormatOfNonIntintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jumpCompact;
    AbstractInstruction *jumpGotClass;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;


	/* Get header word in destReg */
	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	quickConstant = (compactClassFieldLSB()) - (shiftForWord());
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, destReg);
	quickConstant1 = ((sqInt)((usqInt)(((1U << (compactClassFieldWidth())) - 1)) << (shiftForWord())));
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant1, destReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant1));
	}
	jumpCompact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = classFieldOffset();
	/* begin gen:quickConstant:operand:operand: */
	anInstruction2 = genoperandoperandoperand(MoveMwrR, offset, instReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(offset));
	}
	/* begin AndCq:R: */
	anInstruction3 = genoperandoperand(AndCqR, ((int) AllButTypeMask), scratchReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(((int) AllButTypeMask)));
	}
	/* Don't have to subtract one from the destReg compactClassArray index because of the header word. */
	jumpGotClass = genoperand(Jump, ((sqInt)0));
	assert(BaseHeaderSize == BytesPerWord);
	jmpTarget(jumpCompact, annotateobjRef(gMoveMwrR(splObj(CompactClasses), destReg, scratchReg), splObj(CompactClasses)));
	jmpTarget(jumpGotClass, gMoveMwrR((((int)((usqInt)(InstanceSpecificationIndex) << (shiftForWord())))) + BytesPerWord, scratchReg, destReg));
	return 0;
}


/*	Fetch the instance's class into destReg. This is almost identical
	to genGetClassFormatOfNonInt:into:scratchReg: but because we
	put the fetch of SmallInteger between the then and the else for 
	compact class/non-compact class we cannot easily share code.
	instRegIsReceiver is ignored. It is for Spur compatibility where
	objects may be forwarded. */

	/* CogObjectRepresentationForSqueakV3>>#genGetClassObjectOf:into:scratchReg:mayBeAForwarder: */
static NoDbgRegParms sqInt
genGetClassObjectOfintoscratchRegmayBeAForwarder(sqInt instReg, sqInt destReg, sqInt scratchReg, sqInt mayBeAForwarder)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpCompact;
    AbstractInstruction *jumpGotClass;
    AbstractInstruction *jumpGotClass2;
    AbstractInstruction *jumpIsInt;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;


	/* begin MoveR:R: */
	genoperandoperand(MoveRR, instReg, scratchReg);
	anInstruction = genoperandoperand(AndCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	/* Get header word in scratchReg */
	jumpIsInt = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, instReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	quickConstant = (compactClassFieldLSB()) - (shiftForWord());
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, quickConstant, scratchReg);
	quickConstant1 = ((sqInt)((usqInt)(((1U << (compactClassFieldWidth())) - 1)) << (shiftForWord())));
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(quickConstant1));
	}
	jumpCompact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = classFieldOffset();
	/* begin gen:quickConstant:operand:operand: */
	anInstruction3 = genoperandoperandoperand(MoveMwrR, offset, instReg, destReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(offset));
	}
	/* begin AndCq:R: */
	anInstruction4 = genoperandoperand(AndCqR, ((int) AllButTypeMask), destReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(((int) AllButTypeMask)));
	}
	jumpGotClass = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpIsInt, 
	/* begin genMoveConstant:R: */
((isNonIntegerObject(classSmallInteger()))
	 && (oopisGreaterThan(classSmallInteger(), trueObject()))
		? annotateobjRef(checkLiteralforInstruction(classSmallInteger(), genoperandoperand(MoveCwR, classSmallInteger(), destReg)), classSmallInteger())
		: gMoveCqR(classSmallInteger(), destReg)));
	/* Don't have to subtract one from the destReg compactClassArray index because of the header word. */
	jumpGotClass2 = genoperand(Jump, ((sqInt)0));
	assert(BaseHeaderSize == BytesPerWord);
	jmpTarget(jumpCompact, annotateobjRef(gMoveMwrR(splObj(CompactClasses), scratchReg, destReg), splObj(CompactClasses)));
	jmpTarget(jumpGotClass, jmpTarget(jumpGotClass2, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}


/*	Compatibility with SpurObjectRepresentation/SpurMemoryManager. */

	/* CogObjectRepresentationForSqueakV3>>#genGetClassTagOf:into:scratchReg: */
static NoDbgRegParms AbstractInstruction *
genGetClassTagOfintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
    AbstractInstruction *entryLabel;


	/* begin AlignmentNops: */
	genoperand(AlignmentNops, ((BytesPerWord < 8) ? 8 : BytesPerWord));
	entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	if ((genGetClassObjectOfintoscratchRegmayBeAForwarder(instReg, destReg, scratchReg, null)) != 0) {
		error("internal error");
	}
	return entryLabel;
}


/*	Fetch the instance's compact class index into destReg. */
/*	Get header word in scratchReg */

	/* CogObjectRepresentationForSqueakV3>>#genGetCompactClassIndexNonImmOf:into: */
static NoDbgRegParms sqInt
genGetCompactClassIndexNonImmOfinto(sqInt instReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt quickConstant;

	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, compactClassFieldLSB(), destReg);
	quickConstant = (1U << (compactClassFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant));
	}
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genGetDoubleValueOf:into: */
static NoDbgRegParms sqInt
genGetDoubleValueOfinto(sqInt srcReg, sqInt destFPReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveM64:r:Rd: */
	anInstruction = genoperandoperandoperand(MoveM64rRd, BaseHeaderSize, srcReg, destFPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(BaseHeaderSize));
	}
	return 0;
}


/*	Fetch the instance's class format into destReg, assuming the object is
	pointers and non-int
 */

	/* CogObjectRepresentationForSqueakV3>>#genGetFixedFieldsOfPointerNonInt:into:scratchReg: */
static NoDbgRegParms sqInt
genGetFixedFieldsOfPointerNonIntintoscratchReg(sqInt instReg, sqInt destReg, sqInt scratchReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;

	genGetClassFormatOfNonIntintoscratchReg(instReg, destReg, scratchReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, destReg, scratchReg);
	genoperandoperand(LogicalShiftRightCqR, 2, destReg);
	genoperandoperand(LogicalShiftRightCqR, 11, scratchReg);
	anInstruction = genoperandoperand(AndCqR, 0x3F, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0x3F));
	}
	/* begin AndCq:R: */
	anInstruction1 = genoperandoperand(AndCqR, 192, scratchReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(192));
	}
	/* begin SubCq:R: */
	anInstruction2 = genoperandoperand(SubCqR, 1, destReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(1));
	}
	/* begin AddR:R: */
	genoperandoperand(AddRR, scratchReg, destReg);
	return 0;
}


/*	Fetch the instance's identity hash into destReg, encoded as a
	SmallInteger. 
 */
/*	Get header word in scratchReg */

	/* CogObjectRepresentationForSqueakV3>>#genGetHashFieldNonImmOf:asSmallIntegerInto: */
static NoDbgRegParms sqInt
genGetHashFieldNonImmOfasSmallIntegerInto(sqInt instReg, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;

	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, instReg, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, HashBitsOffset - 1, destReg);
	anInstruction1 = genoperandoperand(AndCqR, ((int)((usqInt)(HashMaskUnshifted) << 1)), destReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(((int)((usqInt)(HashMaskUnshifted) << 1))));
	}
	/* begin AddCq:R: */
	anInstruction2 = genoperandoperand(AddCqR, 1, destReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(1));
	}
	return 0;
}


/*	Extract the inline cache tag for the object in sourceReg into destReg. The
	inline cache tag
	for a given object is the value loaded in inline caches to distinguish
	objects of different
	classes. In Spur this is either the tags for immediates, or the receiver's
	classIndex. The inline cache tag for a given object is the value loaded in
	inline caches to distinguish
	objects of different classes. In SqueakV3 the tag is the integer tag bit
	for SmallIntegers (1),
	the compact class index shifted by log: 2 word size for objects with
	compact classes
	(1 * 4 to: 31 * 4 by: 4), or the class. These ranges cannot overlap
	because the heap
	(and hence the lowest class object) is beyond the machine code zone.
	If forEntry is true answer the entry label at which control is to enter
	(cmEntryOffset). If forEntry is false, control enters at the start. */

	/* CogObjectRepresentationForSqueakV3>>#genGetInlineCacheClassTagFrom:into:forEntry: */
static NoDbgRegParms AbstractInstruction *
genGetInlineCacheClassTagFromintoforEntry(sqInt sourceReg, sqInt destReg, sqInt forEntry)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *entryLabel;
    AbstractInstruction *jumpCompact;
    AbstractInstruction *jumpIsInt;
    sqInt offset;
    sqInt quickConstant;


	/* begin AlignmentNops: */
	genoperand(AlignmentNops, ((BytesPerWord < 8) ? 8 : BytesPerWord));
	entryLabel = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, sourceReg, destReg);
	anInstruction = genoperandoperand(AndCqR, 1, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	/* Get header word in destReg */
	jumpIsInt = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	assert((((sqInt)((usqInt)((compactClassFieldMask())) << (compactClassFieldLSB())))) < (((usqInt)(nilObject()))));
	/* begin AndCq:R: */
	quickConstant = ((sqInt)((usqInt)(((1U << (compactClassFieldWidth())) - 1)) << (compactClassFieldLSB())));
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant, destReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(quickConstant));
	}
	jumpCompact = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = classFieldOffset();
	/* begin gen:quickConstant:operand:operand: */
	anInstruction3 = genoperandoperandoperand(MoveMwrR, offset, sourceReg, destReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(offset));
	}
	/* begin AndCq:R: */
	anInstruction4 = genoperandoperand(AndCqR, ((int) AllButTypeMask), destReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(((int) AllButTypeMask)));
	}
	jmpTarget(jumpCompact, jmpTarget(jumpIsInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return entryLabel;
}

	/* CogObjectRepresentationForSqueakV3>>#genJumpImmediate: */
static NoDbgRegParms AbstractInstruction *
genJumpImmediate(sqInt aRegister)
{
	return genJumpSmallInteger(aRegister);
}


/*	Generate a test for aRegister containing an integer value in the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. ObjectMemory>>isIntegerValue: */

	/* CogObjectRepresentationForSqueakV3>>#genJumpIsSmallIntegerValue:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpIsSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
	gLogicalShiftLeftCqRR(1, aRegister, scratchReg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, aRegister, scratchReg);
	return genConditionalBranchoperand(JumpGreaterOrEqual, ((sqInt)0));
}

	/* CogObjectRepresentationForSqueakV3>>#genJumpNotSmallIntegerInScratchReg: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallIntegerInScratchReg(sqInt aRegister)
{
    AbstractInstruction *anInstruction;

	/* begin AndCq:R: */
	anInstruction = genoperandoperand(AndCqR, 1, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}


/*	Generate a test for aRegister containing an integer value outside the
	SmallInteger range, and a jump if so, answering the jump.
	c.f. ObjectMemory>>isIntegerValue: */

	/* CogObjectRepresentationForSqueakV3>>#genJumpNotSmallIntegerValue:scratch: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallIntegerValuescratch(sqInt aRegister, sqInt scratchReg)
{
	gArithmeticShiftRightCqRR(1, aRegister, scratchReg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, aRegister, scratchReg);
	return genConditionalBranchoperand(JumpLess, ((sqInt)0));
}

	/* CogObjectRepresentationForSqueakV3>>#genJumpNotSmallInteger: */
static NoDbgRegParms AbstractInstruction *
genJumpNotSmallInteger(sqInt aRegister)
{
    AbstractInstruction *anInstruction;

	/* begin TstCq:R: */
	anInstruction = genoperandoperand(TstCqR, 1, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return genConditionalBranchoperand(JumpZero, ((sqInt)0));
}

	/* CogObjectRepresentationForSqueakV3>>#genJumpSmallInteger: */
static NoDbgRegParms AbstractInstruction *
genJumpSmallInteger(sqInt aRegister)
{
    AbstractInstruction *anInstruction;

	/* begin TstCq:R: */
	anInstruction = genoperandoperand(TstCqR, 1, aRegister);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
}


/*	Generate a call to code that allocates a new Array of size.
	The Array should be initialized with nils iff initialized is true.
	The size arg is passed in SendNumArgsReg, the result
	must come back in ReceiverResultReg. */

	/* CogObjectRepresentationForSqueakV3>>#genNewArrayOfSize:initialized: */
static NoDbgRegParms void
genNewArrayOfSizeinitialized(sqInt size, sqInt initialize)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, size, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(size));
	}
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceCreateNewArrayTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
}


/*	c.f. StackInterpreter>>stSizeOf: lengthOf:baseHeader:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationForSqueakV3>>#genPrimitiveAt */
static sqInt
genPrimitiveAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction101;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction13;
    AbstractInstruction *anInstruction14;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction21;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction31;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction41;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction51;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction61;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction71;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction81;
    AbstractInstruction *anInstruction9;
    AbstractInstruction *anInstruction91;
    sqInt jic;
    AbstractInstruction *jmpFmtGeFirstByte;
    sqInt jnx;
    AbstractInstruction *jumpBounds;
    AbstractInstruction *jumpFmtEq2;
    AbstractInstruction *jumpFmtGt11;
    AbstractInstruction *jumpFmtGt4;
    AbstractInstruction *jumpFmtIsArray;
    AbstractInstruction *jumpFmtLeWeakArray;
    AbstractInstruction *jumpFmtLt8;
    AbstractInstruction *jumpGotByteSize;
    AbstractInstruction *jumpGotWordSize;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsContext1;
    AbstractInstruction *jumpLarge;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotIndexable1;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpShortHeader;
    AbstractInstruction *jumpSI;
    AbstractInstruction *jumpSkip;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant11;
    sqInt quickConstant2;
    sqInt quickConstant21;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;
    sqInt quickConstant6;

	jic = 0;
	jnx = 0;
	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	jumpSI = genJumpSmallInteger(ReceiverResultReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin genGetSizeOf:into:formatReg:scratchReg:abortJumpsInto: */
	anInstruction14 = genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction14)) {
		(anInstruction14->dependent = locateLiteral(0));
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	genoperandoperand(LogicalShiftRightCqR, instFormatFieldLSB(), SendNumArgsReg);
	quickConstant6 = (1U << (instFormatFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction13 = genoperandoperand(AndCqR, quickConstant6, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction13)) {
		(anInstruction13->dependent = locateLiteral(quickConstant6));
	}
	/* begin CmpCq:R: */
	quickConstant11 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction21 = genoperandoperand(CmpCqR, quickConstant11, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction21)) {
		(anInstruction21->dependent = locateLiteral(quickConstant11));
	}
	jumpNotIndexable1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	genoperandoperand(LogicalShiftRightCqR, compactClassFieldLSB(), TempReg);
	quickConstant21 = (1U << (compactClassFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction31 = genoperandoperand(AndCqR, quickConstant21, TempReg);
	if (usesOutOfLineLiteral(anInstruction31)) {
		(anInstruction31->dependent = locateLiteral(quickConstant21));
	}
	/* begin CmpCq:R: */
	anInstruction41 = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	if (usesOutOfLineLiteral(anInstruction41)) {
		(anInstruction41->dependent = locateLiteral(ClassMethodContextCompactIndex));
	}
	jumpIsContext1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	anInstruction51 = genoperandoperand(AndCqR, TypeMask, TempReg);
	if (usesOutOfLineLiteral(anInstruction51)) {
		(anInstruction51->dependent = locateLiteral(TypeMask));
	}
	/* begin CmpCq:R: */
	anInstruction61 = genoperandoperand(CmpCqR, HeaderTypeSizeAndClass, TempReg);
	if (usesOutOfLineLiteral(anInstruction61)) {
		(anInstruction61->dependent = locateLiteral(HeaderTypeSizeAndClass));
	}
	jumpShortHeader = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	assert(Size4Bit == 0);
	/* begin MoveMw:r:R: */
	offset = 0 - (2 * BytesPerWord);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction71 = genoperandoperandoperand(MoveMwrR, offset, ReceiverResultReg, ClassReg);
	if (usesOutOfLineLiteral(anInstruction71)) {
		(anInstruction71->dependent = locateLiteral(offset));
	}
	/* begin AndCq:R: */
	anInstruction81 = genoperandoperand(AndCqR, ((int) LongSizeMask), ClassReg);
	if (usesOutOfLineLiteral(anInstruction81)) {
		(anInstruction81->dependent = locateLiteral(((int) LongSizeMask)));
	}
	jumpSkip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpShortHeader, gAndCqR(SizeMask, ClassReg));
	jmpTarget(jumpSkip, gSubCqR(BaseHeaderSize, ClassReg));
	/* begin CmpCq:R: */
	quickConstant3 = weakArrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction91 = genoperandoperand(CmpCqR, quickConstant3, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction91)) {
		(anInstruction91->dependent = locateLiteral(quickConstant3));
	}
	jumpFmtLeWeakArray = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction101 = genoperandoperand(CmpCqR, quickConstant4, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction101)) {
		(anInstruction101->dependent = locateLiteral(quickConstant4));
	}
	jmpFmtGeFirstByte = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin AndCq:R: */
	anInstruction11 = genoperandoperand(AndCqR, 3, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction11)) {
		(anInstruction11->dependent = locateLiteral(3));
	}
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jumpGotByteSize = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpFmtGeFirstByte, genoperandoperand(LogicalShiftRightCqR, 2, ClassReg));
	jumpGotWordSize = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpFmtLeWeakArray, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), ClassReg);
	quickConstant5 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction12 = genoperandoperand(CmpCqR, quickConstant5, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction12)) {
		(anInstruction12->dependent = locateLiteral(quickConstant5));
	}
	jumpFmtIsArray = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetFixedFieldsOfPointerNonIntintoscratchReg(ReceiverResultReg, SendNumArgsReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jmpTarget(jumpFmtIsArray, jmpTarget(jumpGotWordSize, jmpTarget(jumpGotByteSize, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	jumpNotIndexable = jumpNotIndexable1;
	jumpIsContext = jumpIsContext1;
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	anInstruction = genoperandoperand(SubCqR, 1, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, Arg1Reg);
	/* This is tedious.  Because of register pressure on x86 (and the baroque
	   complexity of the size computation) we have to recompute the format
	   because it may have been smashed computing the fixed fields.  But at
	   least we have the fixed fields, if any, in formatReg and recomputing
	   these is more expensive than recomputing format.  In any case this
	   should still be faster than the interpreter and we hope this object
	   representation's days are numbered. */
	jumpBounds = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, ClassReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, instFormatFieldLSB(), ClassReg);
	quickConstant = (1U << (instFormatFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(AndCqR, quickConstant, ClassReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(quickConstant));
	}
	/* begin CmpCq:R: */
	anInstruction3 = genoperandoperand(CmpCqR, 4, ClassReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(4));
	}
	jumpFmtGt4 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	/* begin CmpCq:R: */
	anInstruction4 = genoperandoperand(CmpCqR, 2, ClassReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(2));
	}
	jumpFmtEq2 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin AddR:R: */
	genoperandoperand(AddRR, SendNumArgsReg, Arg1Reg);
	jmpTarget(jumpFmtEq2, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin AddCq:R: */
	quickConstant1 = BaseHeaderSize / BytesPerWord;
	/* begin gen:quickConstant:operand: */
	anInstruction5 = genoperandoperand(AddCqR, quickConstant1, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction5)) {
		(anInstruction5->dependent = locateLiteral(quickConstant1));
	}
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFmtGt4, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin CmpCq:R: */
	anInstruction6 = genoperandoperand(CmpCqR, 8, ClassReg);
	if (usesOutOfLineLiteral(anInstruction6)) {
		(anInstruction6->dependent = locateLiteral(8));
	}
	jumpFmtLt8 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin CmpCq:R: */
	anInstruction7 = genoperandoperand(CmpCqR, 11, ClassReg);
	if (usesOutOfLineLiteral(anInstruction7)) {
		(anInstruction7->dependent = locateLiteral(11));
	}
	jumpFmtGt11 = genConditionalBranchoperand(JumpGreater, ((sqInt)0));
	/* begin AddCq:R: */
	anInstruction8 = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction8)) {
		(anInstruction8->dependent = locateLiteral(BaseHeaderSize));
	}
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpFmtLt8, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	assert(BytesPerWord == 4);
	/* begin AddCq:R: */
	quickConstant2 = BaseHeaderSize / BytesPerWord;
	/* begin gen:quickConstant:operand: */
	anInstruction9 = genoperandoperand(AddCqR, quickConstant2, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction9)) {
		(anInstruction9->dependent = locateLiteral(quickConstant2));
	}
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	anInstruction10 = genoperandoperand(CmpCqR, 0x3FFFFFFF, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction10)) {
		(anInstruction10->dependent = locateLiteral(0x3FFFFFFF));
	}
	jumpLarge = genConditionalBranchoperand(JumpAbove, ((sqInt)0));
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpLarge, CallRT(cePositive32BitIntegerTrampoline));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpSI, jmpTarget(jumpNotSI, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, jmpTarget(jumpBounds, jmpTarget(jumpFmtGt11, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))))));
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genPrimitiveIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genPrimitiveIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpCmp;


	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	assert(!((Arg0Reg == SPReg)));
	genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	jumpCmp = (orNot
		? genConditionalBranchoperand(JumpZero, ((sqInt)0))
		: genConditionalBranchoperand(JumpNonZero, ((sqInt)0)));
	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, trueObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(trueObject()));
	}
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpCmp, 
	/* begin genMoveConstant:R: */
gMoveCqR(falseObject(), ReceiverResultReg));
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	return UnfailingPrimitive;
}

	/* CogObjectRepresentationForSqueakV3>>#genPrimitiveIdentityHash */
static sqInt
genPrimitiveIdentityHash(void)
{
    AbstractInstruction *jumpSI;

	jumpSI = genJumpSmallInteger(ReceiverResultReg);
	genGetHashFieldNonImmOfasSmallIntegerInto(ReceiverResultReg, TempReg);
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpSI, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}


/*	c.f. StackInterpreter>>stSizeOf: lengthOf:baseHeader:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationForSqueakV3>>#genPrimitiveSize */
static sqInt
genPrimitiveSize(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction12;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    sqInt jic;
    AbstractInstruction *jmpFmtGeFirstByte;
    sqInt jnx;
    AbstractInstruction *jumpFmtIsArray;
    AbstractInstruction *jumpFmtLeWeakArray;
    AbstractInstruction *jumpGotByteSize;
    AbstractInstruction *jumpGotWordSize;
    AbstractInstruction *jumpIsContext;
    AbstractInstruction *jumpIsContext1;
    AbstractInstruction *jumpNotIndexable;
    AbstractInstruction *jumpNotIndexable1;
    AbstractInstruction *jumpShortHeader;
    AbstractInstruction *jumpSI;
    AbstractInstruction *jumpSkip;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;
    sqInt quickConstant3;
    sqInt quickConstant4;
    sqInt quickConstant5;

	jic = 0;
	jnx = 0;
	jumpSI = genJumpSmallInteger(ReceiverResultReg);
	/* begin genGetSizeOf:into:formatReg:scratchReg:abortJumpsInto: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	genoperandoperand(LogicalShiftRightCqR, instFormatFieldLSB(), SendNumArgsReg);
	quickConstant = (1U << (instFormatFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant));
	}
	/* begin CmpCq:R: */
	quickConstant1 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction2 = genoperandoperand(CmpCqR, quickConstant1, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(quickConstant1));
	}
	jumpNotIndexable1 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	genoperandoperand(LogicalShiftRightCqR, compactClassFieldLSB(), TempReg);
	quickConstant2 = (1U << (compactClassFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(AndCqR, quickConstant2, TempReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(quickConstant2));
	}
	/* begin CmpCq:R: */
	anInstruction4 = genoperandoperand(CmpCqR, ClassMethodContextCompactIndex, TempReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(ClassMethodContextCompactIndex));
	}
	jumpIsContext1 = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	anInstruction5 = genoperandoperand(AndCqR, TypeMask, TempReg);
	if (usesOutOfLineLiteral(anInstruction5)) {
		(anInstruction5->dependent = locateLiteral(TypeMask));
	}
	/* begin CmpCq:R: */
	anInstruction6 = genoperandoperand(CmpCqR, HeaderTypeSizeAndClass, TempReg);
	if (usesOutOfLineLiteral(anInstruction6)) {
		(anInstruction6->dependent = locateLiteral(HeaderTypeSizeAndClass));
	}
	jumpShortHeader = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	assert(Size4Bit == 0);
	/* begin MoveMw:r:R: */
	offset = 0 - (2 * BytesPerWord);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction7 = genoperandoperandoperand(MoveMwrR, offset, ReceiverResultReg, ClassReg);
	if (usesOutOfLineLiteral(anInstruction7)) {
		(anInstruction7->dependent = locateLiteral(offset));
	}
	/* begin AndCq:R: */
	anInstruction8 = genoperandoperand(AndCqR, ((int) LongSizeMask), ClassReg);
	if (usesOutOfLineLiteral(anInstruction8)) {
		(anInstruction8->dependent = locateLiteral(((int) LongSizeMask)));
	}
	jumpSkip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpShortHeader, gAndCqR(SizeMask, ClassReg));
	jmpTarget(jumpSkip, gSubCqR(BaseHeaderSize, ClassReg));
	/* begin CmpCq:R: */
	quickConstant3 = weakArrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction9 = genoperandoperand(CmpCqR, quickConstant3, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction9)) {
		(anInstruction9->dependent = locateLiteral(quickConstant3));
	}
	jumpFmtLeWeakArray = genConditionalBranchoperand(JumpLessOrEqual, ((sqInt)0));
	/* begin CmpCq:R: */
	quickConstant4 = firstByteFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction10 = genoperandoperand(CmpCqR, quickConstant4, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction10)) {
		(anInstruction10->dependent = locateLiteral(quickConstant4));
	}
	jmpFmtGeFirstByte = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	/* begin AndCq:R: */
	anInstruction11 = genoperandoperand(AndCqR, 3, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction11)) {
		(anInstruction11->dependent = locateLiteral(3));
	}
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jumpGotByteSize = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpFmtGeFirstByte, genoperandoperand(LogicalShiftRightCqR, 2, ClassReg));
	jumpGotWordSize = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpFmtLeWeakArray, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, shiftForWord(), ClassReg);
	quickConstant5 = arrayFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction12 = genoperandoperand(CmpCqR, quickConstant5, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction12)) {
		(anInstruction12->dependent = locateLiteral(quickConstant5));
	}
	jumpFmtIsArray = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genGetFixedFieldsOfPointerNonIntintoscratchReg(ReceiverResultReg, SendNumArgsReg, TempReg);
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	jmpTarget(jumpFmtIsArray, jmpTarget(jumpGotWordSize, jmpTarget(jumpGotByteSize, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	jumpNotIndexable = jumpNotIndexable1;
	jumpIsContext = jumpIsContext1;
	genConvertIntegerInRegtoSmallIntegerInReg(ClassReg, ReceiverResultReg);
	/* begin genPrimReturn */
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpSI, jmpTarget(jumpNotIndexable, jmpTarget(jumpIsContext, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return 0;
}


/*	c.f. StackInterpreter>>stSizeOf: lengthOf:baseHeader:format:
	fixedFieldsOf:format:length: 
 */

	/* CogObjectRepresentationForSqueakV3>>#genPrimitiveStringAt */
static sqInt
genPrimitiveStringAt(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction10;
    AbstractInstruction *anInstruction11;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    AbstractInstruction *anInstruction8;
    AbstractInstruction *anInstruction9;
    AbstractInstruction *jumpBounds;
    AbstractInstruction *jumpNotByteIndexable;
    AbstractInstruction *jumpNotSI;
    AbstractInstruction *jumpShortHeader;
    AbstractInstruction *jumpSkip;
    sqInt offset;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt quickConstant2;


	/* begin genLoadArgAtDepth:into: */
	assert(0 < (numRegArgs()));
	genoperandoperand(MoveRR, Arg0Reg, Arg1Reg);
	jumpNotSI = genJumpNotSmallInteger(Arg0Reg);
	/* begin MoveMw:r:R: */
	anInstruction = genoperandoperandoperand(MoveMwrR, 0, ReceiverResultReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, ClassReg);
	genoperandoperand(LogicalShiftRightCqR, instFormatFieldLSB(), TempReg);
	quickConstant = (1U << (instFormatFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant));
	}
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, TempReg, SendNumArgsReg);
	anInstruction2 = genoperandoperand(AndCqR, 3, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(3));
	}
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, TempReg);
	anInstruction3 = genoperandoperand(CmpCqR, 8, TempReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(8));
	}
	jumpNotByteIndexable = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveR:R: */
	genoperandoperand(MoveRR, ClassReg, TempReg);
	anInstruction4 = genoperandoperand(AndCqR, TypeMask, TempReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(TypeMask));
	}
	/* begin CmpCq:R: */
	anInstruction5 = genoperandoperand(CmpCqR, HeaderTypeSizeAndClass, TempReg);
	if (usesOutOfLineLiteral(anInstruction5)) {
		(anInstruction5->dependent = locateLiteral(HeaderTypeSizeAndClass));
	}
	jumpShortHeader = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	assert(Size4Bit == 0);
	/* begin MoveMw:r:R: */
	offset = 0 - (2 * BytesPerWord);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction6 = genoperandoperandoperand(MoveMwrR, offset, ReceiverResultReg, ClassReg);
	if (usesOutOfLineLiteral(anInstruction6)) {
		(anInstruction6->dependent = locateLiteral(offset));
	}
	/* begin AndCq:R: */
	anInstruction7 = genoperandoperand(AndCqR, ((int) LongSizeMask), ClassReg);
	if (usesOutOfLineLiteral(anInstruction7)) {
		(anInstruction7->dependent = locateLiteral(((int) LongSizeMask)));
	}
	jumpSkip = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpShortHeader, gAndCqR(SizeMask, ClassReg));
	jmpTarget(jumpSkip, gSubCqR(BaseHeaderSize, ClassReg));
	/* begin SubR:R: */
	genoperandoperand(SubRR, SendNumArgsReg, ClassReg);
	genConvertSmallIntegerToIntegerInReg(Arg1Reg);
	/* begin SubCq:R: */
	anInstruction8 = genoperandoperand(SubCqR, 1, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction8)) {
		(anInstruction8->dependent = locateLiteral(1));
	}
	/* begin CmpR:R: */
	assert(!((ClassReg == SPReg)));
	genoperandoperand(CmpRR, ClassReg, Arg1Reg);
	jumpBounds = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin AddCq:R: */
	anInstruction9 = genoperandoperand(AddCqR, BaseHeaderSize, Arg1Reg);
	if (usesOutOfLineLiteral(anInstruction9)) {
		(anInstruction9->dependent = locateLiteral(BaseHeaderSize));
	}
	/* begin genMoveConstant:R: */
	if (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(characterTable()))
	 && (oopisGreaterThan(characterTable(), trueObject()))) {
		annotateobjRef(checkLiteralforInstruction(characterTable(), genoperandoperand(MoveCwR, characterTable(), Arg0Reg)), characterTable());
	}
	else {
		/* begin MoveCq:R: */
		quickConstant1 = characterTable();
		/* begin gen:quickConstant:operand: */
		anInstruction10 = genoperandoperand(MoveCqR, quickConstant1, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction10)) {
			(anInstruction10->dependent = locateLiteral(quickConstant1));
		}
	}
	/* begin MoveXbr:R:R: */
	genoperandoperandoperand(MoveXbrRR, Arg1Reg, ReceiverResultReg, ReceiverResultReg);
	quickConstant2 = BaseHeaderSize / BytesPerWord;
	/* begin gen:quickConstant:operand: */
	anInstruction11 = genoperandoperand(AddCqR, quickConstant2, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction11)) {
		(anInstruction11->dependent = locateLiteral(quickConstant2));
	}
	/* begin MoveXwr:R:R: */
	genoperandoperandoperand(MoveXwrRR, ReceiverResultReg, Arg0Reg, ReceiverResultReg);
	if (methodOrBlockNumArgs <= (numRegArgs())) {
		/* begin RetN: */
		genoperand(RetN, 0);
	}
	else {
		/* begin RetN: */
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	jmpTarget(jumpNotSI, jmpTarget(jumpNotByteIndexable, jmpTarget(jumpBounds, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genRemoveSmallIntegerTagsInScratchReg: */
static NoDbgRegParms sqInt
genRemoveSmallIntegerTagsInScratchReg(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin SubCq:R: */
	anInstruction = genoperandoperand(SubCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genSetSmallIntegerTagsIn: */
static NoDbgRegParms sqInt
genSetSmallIntegerTagsIn(sqInt scratchReg)
{
    AbstractInstruction *anInstruction;

	/* begin OrCq:R: */
	anInstruction = genoperandoperand(OrCqR, 1, scratchReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genShiftAwaySmallIntegerTagsInScratchReg: */
static NoDbgRegParms sqInt
genShiftAwaySmallIntegerTagsInScratchReg(sqInt scratchReg)
{

	/* begin ArithmeticShiftRightCq:R: */
	genoperandoperand(ArithmeticShiftRightCqR, 1, scratchReg);
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genStoreSourceReg:slotIndex:destReg:scratchReg:inFrame:needsStoreCheck: */
static NoDbgRegParms sqInt
genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(sqInt sourceReg, sqInt index, sqInt destReg, sqInt scratchReg, sqInt inFrame, sqInt needsStoreCheck)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *inst;
    AbstractInstruction *jmpAlreadyRoot;
    AbstractInstruction *jmpDestYoung;
    AbstractInstruction *jmpImmediate;
    AbstractInstruction *jmpSourceOld;
    int mask;
    sqInt offset;
    sqInt rootBitByteOffset;


	/* begin genTraceStores */
	if (traceStores > 0) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, ClassReg, TempReg);
		abstractInstruction = genoperand(Call, ceTraceStoreTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
	}
	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	if (!needsStoreCheck) {
		return 0;
	}
	/* Get the old/new boundary in scratchReg */
	jmpImmediate = genJumpImmediate(sourceReg);
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(youngStartAddress(), genoperandoperand(MoveAwR, youngStartAddress(), scratchReg));
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, destReg);
	/* Is value stored old?  If so we're done. */
	jmpDestYoung = genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)0));
	/* begin CmpR:R: */
	assert(!((scratchReg == SPReg)));
	genoperandoperand(CmpRR, scratchReg, sourceReg);
	/* value is young and target is old.
	   Need to make this a root if the root bit is not already set.
	   Test the root bit.  Only need to fetch the byte containing it,
	   which reduces the size of the mask constant. */
	jmpSourceOld = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	rootBitByteOffset = RootBitDigitLength - 1;
	mask = ((usqInt)(RootBit)) >> ((RootBitDigitLength - 1) * 8);
	/* begin MoveMb:r:R: */
	anInstruction1 = genoperandoperandoperand(MoveMbrR, rootBitByteOffset, destReg, scratchReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(rootBitByteOffset));
	}
	/* begin AndCq:R: */
	anInstruction2 = genoperandoperand(AndCqR, mask, scratchReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(mask));
	}
	/* Root bit is not set.  Call store check to insert dest into root table. */
	jmpAlreadyRoot = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	assert(destReg == ReceiverResultReg);
	/* begin evaluateTrampolineCallBlock:protectLinkRegIfNot: */
	if (inFrame) {
		/* begin CallRT: */
		abstractInstruction1 = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction1->annotation = IsRelativeCall);
	}
	else {
		/* begin saveAndRestoreLinkRegAround: */
		inst = genoperand(PushR, LinkReg);
		abstractInstruction1 = genoperand(Call, ceStoreCheckTrampoline);
		(abstractInstruction1->annotation = IsRelativeCall);
		/* begin PopR: */
		genoperand(PopR, LinkReg);
	}
	jmpTarget(jmpImmediate, jmpTarget(jmpDestYoung, jmpTarget(jmpSourceOld, jmpTarget(jmpAlreadyRoot, genoperandoperand(Label, (labelCounter += 1), bytecodePC)))));
	return 0;
}

	/* CogObjectRepresentationForSqueakV3>>#genStoreSourceReg:slotIndex:intoNewObjectInDestReg: */
static NoDbgRegParms sqInt
genStoreSourceRegslotIndexintoNewObjectInDestReg(sqInt sourceReg, sqInt index, sqInt destReg)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	/* begin MoveR:Mw:r: */
	offset = (index * BytesPerWord) + BaseHeaderSize;
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, sourceReg, offset, destReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	return 0;
}


/*	Answer the relevant inline cache tag for an instance.
	c.f. getInlineCacheClassTagFrom:into: & inlineCacheTagForClass: */

	/* CogObjectRepresentationForSqueakV3>>#inlineCacheTagForInstance: */
static NoDbgRegParms sqInt
inlineCacheTagForInstance(sqInt oop)
{
    sqInt cci;

	if ((oop & 1)) {
		return (((usqInt)0 << 1) | 1);
	}
	if (((cci = noShiftCompactClassIndexOf(oop))) > 0) {
		return cci;
	}
	return (classHeader(oop)) & AllButTypeMask;
}

	/* CogObjectRepresentationForSqueakV3>>#inlineCacheTagIsYoung: */
static NoDbgRegParms sqInt
inlineCacheTagIsYoung(sqInt cacheTag)
{
	return isYoung(cacheTag);
}

	/* CogObjectRepresentationForSqueakV3>>#markAndTraceLiteralIfYoung: */
static NoDbgRegParms void
markAndTraceLiteralIfYoung(sqInt literal)
{
	if ((couldBeObject(literal))
	 && (isYoungObject(literal))) {
		assert(addressCouldBeObj(literal));
		markAndTrace(literal);
	}
}

	/* CogObjectRepresentationForSqueakV3>>#markAndTraceLiteral: */
static NoDbgRegParms void
markAndTraceLiteral(sqInt literal)
{
	if (couldBeObject(literal)) {
		assert(addressCouldBeObj(literal));
		markAndTrace(literal);
	}
}

	/* CogObjectRepresentationForSqueakV3>>#numSmallIntegerBits */
static sqInt
numSmallIntegerBits(void)
{
	return 0x1F;
}

	/* CogObjectRepresentationForSqueakV3>>#remapObject: */
static NoDbgRegParms sqInt
remapObject(sqInt objOop)
{
	assert(addressCouldBeObj(objOop));
	return remap(objOop);
}

	/* CogObjectRepresentationForSqueakV3>>#remapOop: */
static NoDbgRegParms sqInt
remapOop(sqInt oop)
{
	return ((oop & 1)
		? oop
		: remap(oop));
}


/*	In V3 newSpace is at the top of the heap, hence all above false
	(everything except nil, true, & false) need to be annotated.
 */

	/* CogObjectRepresentationForSqueakV3>>#shouldAnnotateObjectReference: */
static NoDbgRegParms sqInt
shouldAnnotateObjectReference(sqInt anOop)
{
	return (isNonIntegerObject(anOop))
	 && (oopisGreaterThan(anOop, trueObject()));
}

	/* CogObjectRepresentationForSqueakV3>>#slotOffsetOfInstVarIndex: */
static NoDbgRegParms sqInt
slotOffsetOfInstVarIndex(sqInt index)
{
	return (index * BytesPerWord) + BaseHeaderSize;
}

	/* CogObjectRepresentationForSqueakV3>>#validInlineCacheTag: */
static NoDbgRegParms sqInt
validInlineCacheTag(sqInt cacheTag)
{
	return (cacheTag == ConstZero)
	 || ((((cacheTag & ((1U << (shiftForWord())) - 1)) == 0)
	 && (((cacheTag >= (1U << (compactClassFieldLSB()))) && (cacheTag <= (((sqInt)((usqInt)((compactClassIndexOfHeader(-1))) << (compactClassFieldLSB()))))))))
	 || (checkValidObjectReference(cacheTag)));
}

	/* CogOutOfLineLiteralsARMCompiler>>#callFullInstructionByteSize */
static NoDbgRegParms sqInt
callFullInstructionByteSize(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return 8;
}

	/* CogOutOfLineLiteralsARMCompiler>>#cmpC32RTempByteSize */
static NoDbgRegParms sqInt
cmpC32RTempByteSize(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return 8;
}


/*	Generate an out-of-line literal. Copy the value and any annotation from
	the stand-in in the literals manager. */

	/* CogOutOfLineLiteralsARMCompiler>>#concretizeLiteral */
static NoDbgRegParms sqInt
concretizeLiteral(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
    usqInt literal;
    AbstractInstruction *literalAsInstruction;

	literalAsInstruction = ((AbstractInstruction *) (((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]));
	literal = (	/* begin isAnInstruction: */
		(addressIsInInstructions(literalAsInstruction))
	 || (literalAsInstruction == (methodLabel()))
		? (literalAsInstruction->address)
		: ((usqInt)literalAsInstruction));
	assert((((self_in_CogOutOfLineLiteralsARMCompiler->dependent)))
	 && (((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->opcode)) == Literal));
	if (!(((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->annotation)) == null)) {
		assert(!((self_in_CogOutOfLineLiteralsARMCompiler->annotation)));
		(self_in_CogOutOfLineLiteralsARMCompiler->annotation) = (((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->annotation);
	}
	if (!(((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->address)) == null)) {
		assert(((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->address)) == ((self_in_CogOutOfLineLiteralsARMCompiler->address)));
	}
	(((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->address = (self_in_CogOutOfLineLiteralsARMCompiler->address));
	/* begin machineCodeAt:put: */
	((self_in_CogOutOfLineLiteralsARMCompiler->machineCode))[0 / 4] = literal;
	return 4;
}

	/* CogOutOfLineLiteralsARMCompiler>>#inlineCacheTagAt: */
static NoDbgRegParms sqInt
inlineCacheTagAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt callSiteReturnAddress)
{
	return longAt(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, ((usqInt)(callSiteReturnAddress - 8))));
}


/*	Answer if the receiver is a pc-dependent instruction. With out-of-line
	literals any instruction
	that refers to a literal depends on the address of the literal, so add
	them in addition to the jumps. */

	/* CogOutOfLineLiteralsARMCompiler>>#isPCDependent */
static NoDbgRegParms sqInt
isPCDependent(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return (isJump(self_in_CogOutOfLineLiteralsARMCompiler))
	 || ((((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == AlignmentNops)
	 || ((((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) != Literal)
	 && ((((self_in_CogOutOfLineLiteralsARMCompiler->dependent)))
	 && (((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->opcode)) == Literal))));
}


/*	Return the literal referenced by the instruction immediately preceding
	followingAddress. 
 */

	/* CogOutOfLineLiteralsARMCompiler>>#literalBeforeFollowingAddress: */
static NoDbgRegParms sqInt
literalBeforeFollowingAddress(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt followingAddress)
{
	return longAt(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, (instructionIsLDR(self_in_CogOutOfLineLiteralsARMCompiler, longAt(followingAddress - 4))
		? followingAddress - 4
		: (followingAddress - 4) - 4)));
}


/*	Answer the size of a literal load instruction (which does not include the
	size of the literal).
	With out-of-line literals this is always a single LDR instruction that
	refers to the literal.
 */

	/* CogOutOfLineLiteralsARMCompiler>>#literalLoadInstructionBytes */
static NoDbgRegParms sqInt
literalLoadInstructionBytes(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return 4;
}


/*	Answer the byte size of a MoveCwR opcode's corresponding machine code. On
	ARM this is a single instruction pc-relative register load - unless we
	have made a mistake and not turned on the out of line literals manager
 */

	/* CogOutOfLineLiteralsARMCompiler>>#loadLiteralByteSize */
static NoDbgRegParms sqInt
loadLiteralByteSize(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return 4;
}


/*	Answer the maximum number of bytes of machine code generated for any
	abstract instruction.
 */

	/* CogOutOfLineLiteralsARMCompiler>>#machineCodeBytes */
static NoDbgRegParms sqInt
machineCodeBytes(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return 8;
}


/*	Answer the NSSendCache for the return address of a Newspeak
	self, super, outer, or implicit receiver send. */

	/* CogOutOfLineLiteralsARMCompiler>>#nsSendCacheAt: */
static NoDbgRegParms sqInt
nsSendCacheAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt callSiteReturnAddress)
{
	return longAt(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, ((usqInt)(callSiteReturnAddress - 8))));
}


/*	The maximum offset in a LDR is (1<<12)-1, or (1<<10)-1 instructions.
	Be conservative. The issue is that one abstract instruction can emit
	multiple hardware instructions so we assume a 2 to 1 worst case of
	hardware instructions to abstract opcodes.. */

	/* CogOutOfLineLiteralsARMCompiler>>#outOfLineLiteralOpcodeLimit */
static NoDbgRegParms sqInt
outOfLineLiteralOpcodeLimit(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
	return 0x1FF;
}


/*	Extract the address of the ldr rX, [pc, #NNN] instruction at address */

	/* CogOutOfLineLiteralsARMCompiler>>#pcRelativeAddressAt: */
static NoDbgRegParms sqInt
pcRelativeAddressAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt instrAddress)
{
    sqInt inst;
    sqInt offset;

	inst = longAt(instrAddress);
	assert((inst & 0xFF5F0000U) == (ldrrnplusimm(self_in_CogOutOfLineLiteralsARMCompiler, 0, PC, 0, 0)));
	offset = inst & 0xFFF;
	return (instrAddress + 8) + ((((inst & (0x800000)) != 0)
	? offset
	: -offset));
}


/*	If possible we generate the method address using pc-relative addressing.
	If so we don't need to relocate it in code. So check if pc-relative code
	was generated, and if not, adjust a load literal. There are two cases, a
	push or a register load. If a push, then there is a register load, but in
	the instruction
	before. */

	/* CogOutOfLineLiteralsARMCompiler>>#relocateMethodReferenceBeforeAddress:by: */
static NoDbgRegParms AbstractInstruction *
relocateMethodReferenceBeforeAddressby(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt pc, sqInt delta)
{
    sqInt litAddr;
    sqInt pcPrecedingLoad;
    sqInt reference;


	/* If the load is not done via pc-relative addressing we have to relocate. */
	pcPrecedingLoad = (instructionIsPush(self_in_CogOutOfLineLiteralsARMCompiler, longAt(pc - 4))
		? pc - 4
		: pc);
	if (!(isPCRelativeValueLoad(self_in_CogOutOfLineLiteralsARMCompiler, longAt(pcPrecedingLoad - 4)))) {
		litAddr = pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, pcPrecedingLoad);
		reference = longAt(litAddr);
		longAtput(litAddr, reference + delta);
	}
	return self_in_CogOutOfLineLiteralsARMCompiler;
}


/*	Rewrite a CallFull or JumpFull instruction to transfer to a different
	target. This variant is used to rewrite cached primitive calls where we
	load the target address into ip
	and use the 'bx ip' or 'blx ip' instruction for the actual jump or call.
	Answer the extent
	of the code change which is used to compute the range of the icache to
	flush. 
 */

	/* CogOutOfLineLiteralsARMCompiler>>#rewriteFullTransferAt:target:expectedInstruction: */
static NoDbgRegParms sqInt
rewriteFullTransferAttargetexpectedInstruction(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, usqInt callSiteReturnAddress, usqInt callTargetAddress, sqInt expectedInstruction)
{
	assert((instructionBeforeAddress(self_in_CogOutOfLineLiteralsARMCompiler, callSiteReturnAddress)) == expectedInstruction);
	longAtput(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, callSiteReturnAddress - 8), callTargetAddress);
	return 0;
}


/*	Rewrite an inline cache to call a different target for a new tag. This
	variant is used
	to link unlinked sends in ceSend:to:numArgs: et al. Answer the extent of
	the code
	change which is used to compute the range of the icache to flush. */

	/* CogOutOfLineLiteralsARMCompiler>>#rewriteInlineCacheAt:tag:target: */
static NoDbgRegParms sqInt
rewriteInlineCacheAttagtarget(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, usqInt callSiteReturnAddress, sqInt cacheTag, usqInt callTargetAddress)
{
    sqInt call;
    usqInt callDistance;


	/* pc offset */
	/* return offset */
	callDistance = ((usqInt) (callTargetAddress - ((callSiteReturnAddress + 8) - 4)));
	assert(isInImmediateJumpRange(self_in_CogOutOfLineLiteralsARMCompiler, callDistance));
	call = bl(self_in_CogOutOfLineLiteralsARMCompiler, callDistance);
	longAtput(callSiteReturnAddress - 4, call);
	longAtput(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, callSiteReturnAddress - 8), cacheTag);
	assert((inlineCacheTagAt(self_in_CogOutOfLineLiteralsARMCompiler, callSiteReturnAddress)) == cacheTag);
	return 4;
}


/*	Rewrite an inline cache with a new tag. This variant is used
	by the garbage collector. */

	/* CogOutOfLineLiteralsARMCompiler>>#rewriteInlineCacheTag:at: */
static NoDbgRegParms AbstractInstruction *
rewriteInlineCacheTagat(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt cacheTag, sqInt callSiteReturnAddress)
{
	longAtput(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, callSiteReturnAddress - 8), cacheTag);
	return self_in_CogOutOfLineLiteralsARMCompiler;
}


/*	Size a jump and set its address. The target may be another instruction
	or an absolute address. On entry the address inst var holds our virtual
	address. On exit address is set to eventualAbsoluteAddress, which is
	where this instruction will be output. The span of a jump to a following
	instruction is therefore between that instruction's address and this
	instruction's address ((which are both still their virtual addresses), but
	the span of a jump to a preceding instruction or to an absolute address is
	between that instruction's address (which by now is its eventual absolute
	address) or absolute address and eventualAbsoluteAddress.
	
	ARM is simple; the 26-bit call/jump range means no short jumps. This
	routine only has to determine the targets of jumps, not determine sizes.
	
	This version also deals with out-of-line literals. If this is the real
	literal, update the stand-in in literalsManager with the address (because
	instructions referring to the literal are referring to the stand-in). If
	this is annotated with
	IsObjectReference transfer the annotation to the stand-in, whence it will
	be transferred to the real literal, simplifying update of literals. */

	/* CogOutOfLineLiteralsARMCompiler>>#sizePCDependentInstructionAt: */
static NoDbgRegParms unsigned char
sizePCDependentInstructionAt(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt eventualAbsoluteAddress)
{
    usqInt alignment;

	if (((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == AlignmentNops) {
		(self_in_CogOutOfLineLiteralsARMCompiler->address) = eventualAbsoluteAddress;
		alignment = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0];
		return ((self_in_CogOutOfLineLiteralsARMCompiler->machineCodeSize) = ((eventualAbsoluteAddress + (alignment - 1)) & (-alignment)) - eventualAbsoluteAddress);
	}
	assert((isJump(self_in_CogOutOfLineLiteralsARMCompiler))
	 || ((((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == Call)
	 || ((((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == CallFull)
	 || ((((self_in_CogOutOfLineLiteralsARMCompiler->dependent)))
	 && (((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->opcode)) == Literal)))));
	if (isJump(self_in_CogOutOfLineLiteralsARMCompiler)) {
		resolveJumpTarget(self_in_CogOutOfLineLiteralsARMCompiler);
	}
	(self_in_CogOutOfLineLiteralsARMCompiler->address) = eventualAbsoluteAddress;
	if ((((self_in_CogOutOfLineLiteralsARMCompiler->dependent)))
	 && (((((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->opcode)) == Literal)) {
		if (((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == Literal) {
			(((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->address = (self_in_CogOutOfLineLiteralsARMCompiler->address));
		}
		if (((self_in_CogOutOfLineLiteralsARMCompiler->annotation)) == (getIsObjectReference())) {
			(((self_in_CogOutOfLineLiteralsARMCompiler->dependent))->annotation = (self_in_CogOutOfLineLiteralsARMCompiler->annotation));
			(self_in_CogOutOfLineLiteralsARMCompiler->annotation) = null;
		}
	}
	return ((self_in_CogOutOfLineLiteralsARMCompiler->machineCodeSize) = (self_in_CogOutOfLineLiteralsARMCompiler->maxSize));
}


/*	Rewrite the literal in the instruction immediately preceding
	followingAddress. 
 */

	/* CogOutOfLineLiteralsARMCompiler>>#storeLiteral:beforeFollowingAddress: */
static NoDbgRegParms AbstractInstruction *
storeLiteralbeforeFollowingAddress(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, sqInt literal, sqInt followingAddress)
{
	longAtput(pcRelativeAddressAt(self_in_CogOutOfLineLiteralsARMCompiler, (instructionIsLDR(self_in_CogOutOfLineLiteralsARMCompiler, longAt(followingAddress - 4))
		? followingAddress - 4
		: (followingAddress - 4) - 4)), literal);
	return self_in_CogOutOfLineLiteralsARMCompiler;
}


/*	Update an instruction that depends on a label outside
	of generated code (e.g. a method or block header). */

	/* CogOutOfLineLiteralsARMCompiler>>#updateLabel: */
static NoDbgRegParms AbstractInstruction *
updateLabel(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler, AbstractInstruction *labelInstruction)
{
	if (((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) != Literal) {
		assert((((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == MoveCwR)
		 || (((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) == PushCw));
		((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0] = (((labelInstruction->address)) + (((labelInstruction->operands))[1]));
	}
	return self_in_CogOutOfLineLiteralsARMCompiler;
}


/*	Answer if the receiver uses an out-of-line literal. Needs only
	to work for the opcodes created with gen:literal:operand: et al. */

	/* CogOutOfLineLiteralsARMCompiler>>#usesOutOfLineLiteral */
static NoDbgRegParms sqInt
usesOutOfLineLiteral(AbstractInstruction *self_in_CogOutOfLineLiteralsARMCompiler)
{
    sqInt constant;
    sqInt constant1;
    sqInt constant2;
    sqInt constant3;
    sqInt constant4;
    sqInt constant5;
    sqInt i1;
    sqInt i10;
    sqInt i2;
    sqInt i3;
    sqInt i4;
    unsigned int i5;
    unsigned int i6;
    unsigned int i7;
    unsigned int i8;
    sqInt i9;
    int n1;
    int n2;
    int n3;
    int n4;
    int n5;
    int n6;
    sqInt r1;
    sqInt r2;
    sqInt r3;
    sqInt r4;
    sqInt value;
    unsigned int value1;
    unsigned int value2;

	switch ((self_in_CogOutOfLineLiteralsARMCompiler->opcode)) {
	case CallFull:
	case JumpFull:
	case AddCwR:
	case AndCwR:
	case CmpCwR:
	case OrCwR:
	case SubCwR:
	case XorCwR:
		return 1;

	case AddCqR:
	case AddCqRR:
	case CmpCqR:
	case SubCqR:
		constant = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0];
		/* begin rotateable8bitSignedImmediate:ifTrue:ifFalse: */
		value = constant;
		while (1) {
			if ((value & 0xFF) == value) {
				return ((n1 = constant != value),
					0);
			}
			for (i1 = 2; i1 <= 30; i1 += 2) {
				if ((value & (((0xFFU << i1) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i1)))) == value) {
					return ((r1 = 32 - i1),
						(i5 = (((usqInt)(value)) >> i1) | ((((sqInt)((usqInt)(value) << (32 - i1)))) & 0xFFFFFFFFU)),
						(n2 = constant != value),
						0);
				}
			}
			if (!((value == constant)
			 && (constant != 0))) break;
			value = -constant;
		}
		return 1;

	case AndCqR:
	case AndCqRR:
	case OrCqRR:
		constant1 = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0];
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value1 = constant1;
		while (1) {
			if ((value1 & 0xFF) == value1) {
				return ((n3 = constant1 != value1),
					0);
			}
			for (i2 = 2; i2 <= 30; i2 += 2) {
				if ((value1 & (((0xFFU << i2) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i2)))) == value1) {
					return ((r2 = 32 - i2),
						(i6 = ((value1) >> i2) | ((value1 << (32 - i2)) & 0xFFFFFFFFU)),
						(n4 = constant1 != value1),
						0);
				}
			}
			if (!(value1 == constant1)) break;
			value1 = (constant1 < 0
				? -1 - constant1
				: (unsigned int)~constant1);
		}
		return (1U << (highBit(((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]))) != ((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]) + 1);

	case OrCqR:
	case TstCqR:
	case LoadEffectiveAddressMwrR:
	case MoveCqR:
	case MoveM16rR:
	case PushCq:
		constant2 = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0];
		/* begin rotateable8bitImmediate:ifTrue:ifFalse: */
		if ((constant2 & 0xFF) == constant2) {
			return 0;
		}
		for (i3 = 2; i3 <= 30; i3 += 2) {
			if ((constant2 & (((0xFFU << i3) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i3)))) == constant2) {
				return ((r3 = 32 - i3),
					(i7 = (((usqInt)(constant2)) >> i3) | ((((sqInt)((usqInt)(constant2) << (32 - i3)))) & 0xFFFFFFFFU)),
					0);
			}
		}
		return 1;

	case XorCqR:
		constant3 = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0];
		/* begin rotateable8bitBitwiseImmediate:ifTrue:ifFalse: */
		value2 = constant3;
		while (1) {
			if ((value2 & 0xFF) == value2) {
				return ((n5 = constant3 != value2),
					0);
			}
			for (i4 = 2; i4 <= 30; i4 += 2) {
				if ((value2 & (((0xFFU << i4) & 0xFFFFFFFFU) | (((usqInt)(0xFF)) >> (32 - i4)))) == value2) {
					return ((r4 = 32 - i4),
						(i8 = ((value2) >> i4) | ((value2 << (32 - i4)) & 0xFFFFFFFFU)),
						(n6 = constant3 != value2),
						0);
				}
			}
			if (!(value2 == constant3)) break;
			value2 = (constant3 < 0
				? -1 - constant3
				: (unsigned int)~constant3);
		}
		return 1;

	case MoveCwR:
	case PushCw:
		return !(		/* begin inCurrentCompilation: */
			((addressIsInInstructions(((AbstractInstruction *) (((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]))))
		 || ((((AbstractInstruction *) (((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]))) == (methodLabel())))
		 || (((((usqInt)(((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]))) >= ((methodLabel->address)))
		 && ((((usqInt)(((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]))) < ((((youngReferrers()) < (((methodLabel->address)) + MaxMethodSize)) ? (youngReferrers()) : (((methodLabel->address)) + MaxMethodSize))))));

	case MoveAwR:
	case MoveAbR:
	case PrefetchAw:
		return (		/* begin isAddressRelativeToVarBase: */
			((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]))
		 && (((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]) >= (varBaseAddress()))
		 && (((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0]) - (varBaseAddress())) < (0x1000)))
			? 0
			: 1);

	case MoveRAw:
	case MoveRAb:
		return (		/* begin isAddressRelativeToVarBase: */
			((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[1]))
		 && (((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[1]) >= (varBaseAddress()))
		 && (((((self_in_CogOutOfLineLiteralsARMCompiler->operands))[1]) - (varBaseAddress())) < (0x1000)))
			? 0
			: 1);

	case MoveRMwr:
	case MoveRdM64r:
	case MoveRMbr:
	case MoveRM16r:
		constant4 = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[1];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(constant4)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (constant4 >= 0) {
				return 0;
			}
			else {
				return ((i9 = SQABS(constant4)),
					0);
			}
		}
		else {
			return 1;
		}

	case MoveMbrR:
	case MoveM64rRd:
	case MoveMwrR:
		constant5 = ((self_in_CogOutOfLineLiteralsARMCompiler->operands))[0];
		/* begin is12BitValue:ifTrue:ifFalse: */
		if ((SQABS(constant5)) <= 0xFFF) {
			/* (2 raisedTo: 12)-1 */
			if (constant5 >= 0) {
				return 0;
			}
			else {
				return ((i10 = SQABS(constant5)),
					0);
			}
		}
		else {
			return 1;
		}

	default:
		assert(0);
	}
	return 0;
}

	/* CogSimStackEntry>>#ensureSpilledAt:from: */
static NoDbgRegParms SimStackEntry *
ensureSpilledAtfrom(SimStackEntry *self_in_CogSimStackEntry, sqInt baseOffset, sqInt baseRegister)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt baseReg;
    AbstractInstruction *inst;
    sqInt offset;
    sqInt wordConstant;

	if ((self_in_CogSimStackEntry->spilled)) {
		if (((self_in_CogSimStackEntry->type)) == SSSpill) {
			assert(((((self_in_CogSimStackEntry->offset)) == baseOffset)
			 && (((self_in_CogSimStackEntry->registerr)) == baseRegister))
			 || (violatesEnsureSpilledSpillAssert()));
			return self_in_CogSimStackEntry;
		}
	}
	assert(((self_in_CogSimStackEntry->type)) != SSSpill);
	traceSpill(self_in_CogSimStackEntry);
	if (((self_in_CogSimStackEntry->type)) == SSConstant) {
		/* begin genPushConstant: */
		if (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject((self_in_CogSimStackEntry->constant)))
		 && (oopisGreaterThan((self_in_CogSimStackEntry->constant), trueObject()))) {
			inst = annotateobjRef(checkLiteralforInstruction((self_in_CogSimStackEntry->constant), genoperand(PushCw, (self_in_CogSimStackEntry->constant))), (self_in_CogSimStackEntry->constant));
		}
		else {
			/* begin PushCq: */
			wordConstant = (self_in_CogSimStackEntry->constant);
			/* begin gen:quickConstant: */
			anInstruction = genoperand(PushCq, wordConstant);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteral(wordConstant));
			}
			inst = anInstruction;
		}
	}
	else {
		if (((self_in_CogSimStackEntry->type)) == SSBaseOffset) {
			/* begin MoveMw:r:R: */
			offset = (self_in_CogSimStackEntry->offset);
			baseReg = (self_in_CogSimStackEntry->registerr);
			/* begin gen:quickConstant:operand:operand: */
			anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, baseReg, TempReg);
			if (usesOutOfLineLiteral(anInstruction1)) {
				(anInstruction1->dependent = locateLiteral(offset));
			}
			inst = genoperand(PushR, TempReg);
		}
		else {
			assert(((self_in_CogSimStackEntry->type)) == SSRegister);
			inst = genoperand(PushR, (self_in_CogSimStackEntry->registerr));
		}
		(self_in_CogSimStackEntry->type) = SSSpill;
		(self_in_CogSimStackEntry->offset) = baseOffset;
		(self_in_CogSimStackEntry->registerr) = baseRegister;
	}
	(self_in_CogSimStackEntry->spilled) = 1;
	return self_in_CogSimStackEntry;
}

	/* CogSimStackEntry>>#isSameEntryAs: */
static NoDbgRegParms sqInt
isSameEntryAs(SimStackEntry *self_in_CogSimStackEntry, CogSimStackEntry *ssEntry)
{
	return (((self_in_CogSimStackEntry->type)) == ((ssEntry->type)))
	 && ((((((self_in_CogSimStackEntry->type)) == SSBaseOffset)
	 || (((self_in_CogSimStackEntry->type)) == SSSpill))
	 && ((((self_in_CogSimStackEntry->offset)) == ((ssEntry->offset)))
	 && (((self_in_CogSimStackEntry->registerr)) == ((ssEntry->registerr)))))
	 || (((((self_in_CogSimStackEntry->type)) == SSRegister)
	 && (((self_in_CogSimStackEntry->registerr)) == ((ssEntry->registerr))))
	 || ((((self_in_CogSimStackEntry->type)) == SSConstant)
	 && (((self_in_CogSimStackEntry->constant)) == ((ssEntry->constant))))));
}


/*	Receiver is not a forwarder, except in blocks with no inst var access.
	For now we optimize only the case where receiver is accessed in a method. */

	/* CogSimStackEntry>>#mayBeAForwarder */
static NoDbgRegParms sqInt
mayBeAForwarder(SimStackEntry *self_in_CogSimStackEntry)
{
	if ((((self_in_CogSimStackEntry->type)) == SSRegister)
	 && (isNonForwarderReceiver((self_in_CogSimStackEntry->registerr)))) {
		return 0;
	}
	return ((self_in_CogSimStackEntry->type)) != SSConstant;
}

	/* CogSimStackEntry>>#popToReg: */
static NoDbgRegParms SimStackEntry *
popToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt baseReg;
    sqInt offset;
    sqInt quickConstant;

	if ((self_in_CogSimStackEntry->spilled)) {
		/* begin PopR: */
		genoperand(PopR, reg);
	}
	else {
		switch ((self_in_CogSimStackEntry->type)) {
		case SSBaseOffset:
			/* begin MoveMw:r:R: */
			offset = (self_in_CogSimStackEntry->offset);
			baseReg = (self_in_CogSimStackEntry->registerr);
			/* begin gen:quickConstant:operand:operand: */
			anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteral(offset));
			}
			break;
		case SSConstant:
			/* begin genMoveConstant:R: */
			if (			/* begin shouldAnnotateObjectReference: */
				(isNonIntegerObject((self_in_CogSimStackEntry->constant)))
			 && (oopisGreaterThan((self_in_CogSimStackEntry->constant), trueObject()))) {
				annotateobjRef(checkLiteralforInstruction((self_in_CogSimStackEntry->constant), genoperandoperand(MoveCwR, (self_in_CogSimStackEntry->constant), reg)), (self_in_CogSimStackEntry->constant));
			}
			else {
				/* begin MoveCq:R: */
				quickConstant = (self_in_CogSimStackEntry->constant);
				/* begin gen:quickConstant:operand: */
				anInstruction1 = genoperandoperand(MoveCqR, quickConstant, reg);
				if (usesOutOfLineLiteral(anInstruction1)) {
					(anInstruction1->dependent = locateLiteral(quickConstant));
				}
			}
			break;
		case SSRegister:
			if (reg != ((self_in_CogSimStackEntry->registerr))) {
				/* begin MoveR:R: */
				genoperandoperand(MoveRR, (self_in_CogSimStackEntry->registerr), reg);
			}
			else {
				/* begin Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			break;
		default:
			error("Case not found and no otherwise clause");
		}
	}
	return self_in_CogSimStackEntry;
}


/*	Answer a bit mask for the receiver's register, if any. */

	/* CogSimStackEntry>>#registerMask */
static NoDbgRegParms sqInt
registerMask(SimStackEntry *self_in_CogSimStackEntry)
{
	return ((((self_in_CogSimStackEntry->type)) == SSBaseOffset)
	 || (((self_in_CogSimStackEntry->type)) == SSRegister)
		? ((((self_in_CogSimStackEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackEntry->registerr)))) : (1U << ((self_in_CogSimStackEntry->registerr))))
		: 0);
}

	/* CogSimStackEntry>>#registerMaskOrNone */
static NoDbgRegParms sqInt
registerMaskOrNone(SimStackEntry *self_in_CogSimStackEntry)
{
	return (((self_in_CogSimStackEntry->type)) == SSRegister
		? ((((self_in_CogSimStackEntry->registerr)) < 0) ? (((usqInt)(1)) >> (-((self_in_CogSimStackEntry->registerr)))) : (1U << ((self_in_CogSimStackEntry->registerr))))
		: 0);
}

	/* CogSimStackEntry>>#registerOrNone */
static NoDbgRegParms sqInt
registerOrNone(SimStackEntry *self_in_CogSimStackEntry)
{
	return (((self_in_CogSimStackEntry->type)) == SSRegister
		? (self_in_CogSimStackEntry->registerr)
		: NoReg);
}

	/* CogSimStackEntry>>#storeToReg: */
static NoDbgRegParms SimStackEntry *
storeToReg(SimStackEntry *self_in_CogSimStackEntry, sqInt reg)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt baseReg;
    sqInt offset;
    sqInt quickConstant;

	switch ((self_in_CogSimStackEntry->type)) {
	case SSBaseOffset:
	case SSSpill:
		/* begin MoveMw:r:R: */
		offset = (self_in_CogSimStackEntry->offset);
		baseReg = (self_in_CogSimStackEntry->registerr);
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, baseReg, reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(offset));
		}
		break;
	case SSConstant:
		/* begin genMoveConstant:R: */
		if (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject((self_in_CogSimStackEntry->constant)))
		 && (oopisGreaterThan((self_in_CogSimStackEntry->constant), trueObject()))) {
			annotateobjRef(checkLiteralforInstruction((self_in_CogSimStackEntry->constant), genoperandoperand(MoveCwR, (self_in_CogSimStackEntry->constant), reg)), (self_in_CogSimStackEntry->constant));
		}
		else {
			/* begin MoveCq:R: */
			quickConstant = (self_in_CogSimStackEntry->constant);
			/* begin gen:quickConstant:operand: */
			anInstruction1 = genoperandoperand(MoveCqR, quickConstant, reg);
			if (usesOutOfLineLiteral(anInstruction1)) {
				(anInstruction1->dependent = locateLiteral(quickConstant));
			}
		}
		break;
	case SSRegister:
		if (reg != ((self_in_CogSimStackEntry->registerr))) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, (self_in_CogSimStackEntry->registerr), reg);
		}
		else {
			/* begin Label */
			genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	return self_in_CogSimStackEntry;
}

	/* CogSSBytecodeFixup>>#isMergeFixup */
static NoDbgRegParms int
isMergeFixup(BytecodeFixup *self_in_CogSSBytecodeFixup)
{
	return (((usqInt)((self_in_CogSSBytecodeFixup->targetInstruction)))) == NeedsMergeFixupFlag;
}


/*	Allocate an unsharable Literal instruction for the literal and answer it. */

	/* OutOfLineLiteralsManager>>#allocateLiteral: */
static NoDbgRegParms AbstractInstruction *
allocateLiteral(sqInt aLiteral)
{
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt iLimiT;
    sqInt initialNumLiterals;
    AbstractInstruction *litInst;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;

	if (nextLiteralIndex >= literalsSize) {
		initialNumLiterals = literalsSize + 8;
		/* begin allocateLiterals: */
		if (initialNumLiterals > literalsSize) {
			/* Must copy across state (not using realloc, cuz...) and
			   must also update existing instructions to refer to the new ones...
			   It's either this or modify all generation routines to be able to retry
			   with more literals after running out of literals. */
			newLiterals = calloc(initialNumLiterals, sizeof(CogAbstractInstruction));
			if (!(literals == null)) {
				for (i = 0; i < nextLiteralIndex; i += 1) {
					existingInst = literalInstructionAt(i);
					newInst = (&(newLiterals[i]));
					cloneLiteralFrom(newInst, existingInst);
					assert(!((existingInst->dependent)));
					(existingInst->dependent = newInst);
				}
				for (i = 0, iLimiT = (opcodeIndex - 1); i <= iLimiT; i += 1) {
					existingInst = abstractInstructionAt(i);
					if ((((existingInst->dependent)))
					 && (((((existingInst->dependent))->opcode)) == Literal)) {
						(existingInst->dependent = (((existingInst->dependent))->dependent));
					}
				}
			}
			free(literals);
			literals = newLiterals;
			literalsSize = initialNumLiterals;
		}
	}
	litInst = literalInstructionAt(nextLiteralIndex);
	initializeUniqueLiteral(litInst, aLiteral);
	/* Record the opcodeIndex of the first dependent instruction (the first instruction that references an out-of-line literal) */
	nextLiteralIndex += 1;
	if (firstOpcodeIndex > opcodeIndex) {
		firstOpcodeIndex = opcodeIndex - 1;
	}
	return litInst;
}

	/* OutOfLineLiteralsManager>>#checkLiteral:forInstruction: */
static NoDbgRegParms AbstractInstruction *
checkLiteralforInstruction(sqInt literal, AbstractInstruction *anInstruction)
{
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(literal));
	}
	return anInstruction;
}


/*	Output all pending literal instructions, making the originals dependents
	on the generated ones
	so that a later pass will copy the address of each generated literal inst
	to its original in literals,
	and hence allow the instruction using the literal to compute the correct
	address.. 
 */

	/* OutOfLineLiteralsManager>>#dumpLiterals: */
static NoDbgRegParms sqInt
dumpLiterals(sqInt generateBranchAround)
{
    sqInt i;
    AbstractInstruction *jump;
    AbstractInstruction *litInst;

	jump = ((AbstractInstruction *) 0);
	if (generateBranchAround) {
		jump = genoperand(Jump, ((sqInt)0));
	}
	for (i = lastDumpedLiteralIndex; i < nextLiteralIndex; i += 1) {
		litInst = literalInstructionAt(i);
		((genoperand(Literal, ((litInst->operands))[0]))->dependent = litInst);
		/* begin setLiteralOpcodeIndex: */
		assert(((litInst->opcode)) == Literal);
		((litInst->operands))[2] = opcodeIndex;
	}
	if (generateBranchAround) {
		jmpTarget(jump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	firstOpcodeIndex = opcodeIndex;
	lastDumpedLiteralIndex = nextLiteralIndex;
	return 0;
}


/*	A literal is in range if its opcode index is within
	outOfLineLiteralOpcodeLimit, or if its index has yet to be assigned. */

	/* OutOfLineLiteralsManager>>#literalInstructionInRange: */
static NoDbgRegParms sqInt
literalInstructionInRange(AbstractInstruction *litInst)
{
    sqInt opcodeIdx;


	/* begin literalOpcodeIndex */
	assert(((litInst->opcode)) == Literal);
	opcodeIdx = ((sqInt)(((litInst->operands))[2]));
	return ((((sqInt)opcodeIdx)) < 0)
	 || ((assert((getOpcodeIndex()) >= opcodeIdx),
	(opcodeIndex - opcodeIdx) < (outOfLineLiteralOpcodeLimit(backEnd()))));
}


/*	Search for a Literal instruction that is in-range and answer it. Otherwise
	allocate a new sharable Literal instruction for the literal and answer it. */

	/* OutOfLineLiteralsManager>>#locateLiteral: */
static NoDbgRegParms AbstractInstruction *
locateLiteral(sqInt aLiteral)
{
    AbstractInstruction *existingInst;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt initialNumLiterals;
    AbstractInstruction *litInst;
    AbstractInstruction *newInst;
    AbstractInstruction *newLiterals;

	for (i = 0; i < nextLiteralIndex; i += 1) {
		litInst = literalInstructionAt(i);
		if (((((litInst->operands))[0]) == aLiteral)
		 && (((		/* begin isSharable */
			assert(((litInst->opcode)) == Literal),
		(((((litInst->operands))[1]) & 1) != 0)))
		 && (literalInstructionInRange(litInst)))) {
			return litInst;
		}
	}
	if (nextLiteralIndex >= literalsSize) {
		initialNumLiterals = literalsSize + 8;
		/* begin allocateLiterals: */
		if (initialNumLiterals > literalsSize) {
			/* Must copy across state (not using realloc, cuz...) and
			   must also update existing instructions to refer to the new ones...
			   It's either this or modify all generation routines to be able to retry
			   with more literals after running out of literals. */
			newLiterals = calloc(initialNumLiterals, sizeof(CogAbstractInstruction));
			if (!(literals == null)) {
				for (i1 = 0; i1 < nextLiteralIndex; i1 += 1) {
					existingInst = literalInstructionAt(i1);
					newInst = (&(newLiterals[i1]));
					cloneLiteralFrom(newInst, existingInst);
					assert(!((existingInst->dependent)));
					(existingInst->dependent = newInst);
				}
				for (i1 = 0, iLimiT = (opcodeIndex - 1); i1 <= iLimiT; i1 += 1) {
					existingInst = abstractInstructionAt(i1);
					if ((((existingInst->dependent)))
					 && (((((existingInst->dependent))->opcode)) == Literal)) {
						(existingInst->dependent = (((existingInst->dependent))->dependent));
					}
				}
			}
			free(literals);
			literals = newLiterals;
			literalsSize = initialNumLiterals;
		}
	}
	litInst = literalInstructionAt(nextLiteralIndex);
	initializeSharableLiteral(litInst, aLiteral);
	/* Record the opcodeIndex of the first dependent instruction (the first instruction that references an out-of-line literal) */
	nextLiteralIndex += 1;
	if (firstOpcodeIndex > opcodeIndex) {
		firstOpcodeIndex = opcodeIndex - 1;
	}
	return litInst;
}


/*	<Integer> */

	/* SimpleStackBasedCogit>>#ceClosureCopyDescriptor: */
static NoDbgRegParms sqInt
ceClosureCopyDescriptor(sqInt descriptor)
{
	return createClosureNumArgsnumCopiedstartpc(descriptor & 0x3F, (((usqInt)(descriptor)) >> 6) & 0x3F, ((usqInt)(descriptor)) >> 12);
}

	/* SimpleStackBasedCogit>>#cogMethodHasExternalPrim: */
sqInt
cogMethodHasExternalPrim(CogMethod *aCogMethod)
{
    sqInt primIndex;

	primIndex = primitiveIndexOfMethodheader((aCogMethod->methodObject), (aCogMethod->methodHeader));
	return (primIndex == PrimNumberExternalCall)
	 || (primIndex == PrimNumberFFICall);
}

	/* SimpleStackBasedCogit>>#cogMethodHasMachineCodePrim: */
sqInt
cogMethodHasMachineCodePrim(CogMethod *aCogMethod)
{
    sqInt primIndex;

	primIndex = primitiveIndexOfMethodheader((aCogMethod->methodObject), (aCogMethod->methodHeader));
	return (((primIndex >= 1) && (primIndex <= MaxCompiledPrimitiveIndex)))
	 && ((((primitiveGeneratorTable[primIndex]).primitiveGenerator)));
}


/*	Compile the jump instruction(s) at the end of the method that dispatch to
	each block body.
 */

	/* SimpleStackBasedCogit>>#compileBlockDispatch */
static sqInt
compileBlockDispatch(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *jumpSkip;

	assert(blockCount > 0);
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	blockEntryNoContextSwitch = anInstruction;
	/* Set OK to context switch flag to non-zero. */
	jumpSkip = genoperand(Jump, ((sqInt)0));
	blockEntryLabel = genoperandoperand(MoveRR, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jumpSkip, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (blockCount > 1) {
		genLoadSlotsourceRegdestReg(ClosureStartPCIndex, ReceiverResultReg, TempReg);
	}
	compileBlockDispatchFromto(0, blockCount - 1);
	return 0;
}


/*	After pushing the temporaries but before the stack limit check a primitive
	method needs to fetch the error code, if any. If the primitive has failed,
	call the trampoline
	that will assign it to the last temp. */

	/* SimpleStackBasedCogit>>#compileGetErrorCode */
static void
compileGetErrorCode(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *jmpNoError;


	/* begin gen:literal:operand: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	jmpNoError = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceReapAndResetErrorCodeTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	jmpTarget(jmpNoError, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
}


/*	Compile a call to an interpreter primitive. Call the C routine with the
	usual stack-switching dance, test the primFailCode and then either
	return on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compileInterpreterPrimitive:flags: */
static NoDbgRegParms sqInt
compileInterpreterPrimitiveflags(void (*primitiveRoutine)(void), sqInt flags)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *continueAfterProfileSample;
    AbstractInstruction *jmp;
    sqInt offset;

	assert(!((registerisInMask(VarBaseReg, ABICallerSavedRegisterMask))));
	genExternalizePointersForPrimitiveCall();
	/* begin genLoadCStackPointersForPrimCall */
	if (cFramePointerInUse) {
		genLoadCStackPointers(backEnd);
	}
	else {
		genLoadCStackPointer(backEnd);
	}
	if (recordPrimTraceForMethod(methodObj)) {
		genFastPrimTraceUsingand(ClassReg, SendNumArgsReg);
	}
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveRAw, TempReg, primFailCodeAddress()));
	if (methodOrBlockNumArgs != 0) {
		/* begin AddCq:R: */
		anInstruction1 = genoperandoperand(AddCqR, methodOrBlockNumArgs, TempReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(methodOrBlockNumArgs));
		}
	}
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(argumentCountAddress(), genoperandoperand(MoveRAw, TempReg, argumentCountAddress()));
	if (((flags & PrimCallNeedsNewMethod) != 0)) {
		genLoadNewMethod();
	}
	/* begin gen:literal: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperand(PrefetchAw, primFailCodeAddress()));
	if (((flags & PrimCallMayEndureCodeCompaction) != 0)) {
		/* The ceActivateFailingPrimitiveMethod: machinery can't handle framelessness. */
		needsFrame = 1;
		/* begin genMarshallNArgs:arg:arg:arg:arg: */
		checkLiteralforInstruction((((flags & PrimCallCollectsProfileSamples) != 0)
			? cePrimReturnEnterCogCodeProfiling
			: cePrimReturnEnterCogCode), genoperandoperand(MoveCwR, (((flags & PrimCallCollectsProfileSamples) != 0)
			? cePrimReturnEnterCogCodeProfiling
			: cePrimReturnEnterCogCode), LR));
		/* begin gen:literal: */
		checkLiteralforInstruction(((sqInt)(((sqInt)primitiveRoutine))), genoperand(JumpFull, ((sqInt)(((sqInt)primitiveRoutine)))));
		return 0;
	}
	/* begin genMarshallNArgs:arg:arg:arg:arg: */
	checkLiteralforInstruction(((sqInt)primitiveRoutine), genoperand(CallFull, ((sqInt)primitiveRoutine)));
	assert(0 <= 4);
	genLoadStackPointersForPrimCall(backEnd, ClassReg);
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	anInstruction2 = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(0));
	}
	/* placing the test here attributes the tick to the primitive plus any checkForAndFollowForwardedPrimitiveState
	   scanning, but attributes all of a failing primitive to the current method (in ceStackOverflow: on frame build). */
	jmp = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	anInstruction3 = genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(0));
	}
	continueAfterProfileSample = anInstruction3;
	/* begin RetN: */
	genoperand(RetN, BytesPerWord);
	jmpTarget(jmp, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin MoveMw:r:R: */
	offset = BytesPerWord * (methodOrBlockNumArgs);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction4 = genoperandoperandoperand(MoveMwrR, offset, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(offset));
	}
	return 0;
}


/*	Compile one method cache probe in an OpenPIC's lookup of selector.
	Answer the jump taken if the selector probe fails.
	The class tag of the receiver must be in SendNumArgsReg. ClassReg and
	TempReg are used as scratch registers.
	On a hit, the offset of the entry is in ClassReg. */

	/* SimpleStackBasedCogit>>#compileOpenPICMethodCacheProbeFor:withShift:baseRegOrNone: */
static NoDbgRegParms AbstractInstruction *
compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selector, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt offset1;


	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	maybeShiftClassTagRegisterForMethodCacheProbe(ClassReg);
	annotateobjRef(checkLiteralforInstruction(selector, genoperandoperand(XorCwR, selector, ClassReg)), selector);
	assert(shift <= (shiftForWord()));
	if (shift < (shiftForWord())) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	anInstruction = genoperandoperand(AndCqR, ((int)((usqInt)(MethodCacheMask) << (shiftForWord()))), ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(((int)((usqInt)(MethodCacheMask) << (shiftForWord())))));
	}
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset = (methodCacheAddress()) + (((int)((usqInt)(MethodCacheSelector) << (shiftForWord()))));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(offset));
		}
	}
	else {
		/* begin AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);
		anInstruction2 = genoperandoperandoperand(MoveMwrR, ((int)((usqInt)(MethodCacheSelector) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction2)) {
			(anInstruction2->dependent = locateLiteral(((int)((usqInt)(MethodCacheSelector) << (shiftForWord())))));
		}
	}
	annotateobjRef(checkLiteralforInstruction(selector, genoperandoperand(CmpCwR, selector, TempReg)), selector);
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset1 = (methodCacheAddress()) + (((int)((usqInt)(MethodCacheClass) << (shiftForWord()))));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, offset1, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction3)) {
			(anInstruction3->dependent = locateLiteral(offset1));
		}
	}
	else {
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, ((int)((usqInt)(MethodCacheClass) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction4)) {
			(anInstruction4->dependent = locateLiteral(((int)((usqInt)(MethodCacheClass) << (shiftForWord())))));
		}
	}
	/* begin CmpR:R: */
	assert(!((SendNumArgsReg == SPReg)));
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile the code for an open PIC. Perform a probe of the first-level
	method lookup cache followed by a call of ceSendFromInLineCacheMiss: if
	the probe fails. */

	/* SimpleStackBasedCogit>>#compileOpenPIC:numArgs: */
static NoDbgRegParms void
compileOpenPICnumArgs(sqInt selector, sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	/* begin preenMethodLabel */
	((methodLabel->operands))[1] = 0;
	compilePICAbort(numArgs);
	entry = genGetClassTagOfintoscratchReg(ReceiverResultReg, SendNumArgsReg, TempReg);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 0, cacheBaseReg);
	/* Fetch the method.  The interpret trampoline requires the bytecoded method in SendNumArgsReg */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (methodCacheAddress()) + (((int)((usqInt)(MethodCacheMethod) << (shiftForWord()))))
		: ((int)((usqInt)(MethodCacheMethod) << (shiftForWord()))));
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	itsAHit = anInstruction;
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	jmpTarget(jumpBCMethod, picInterpretAbort);
	/* begin AddCq:R: */
	anInstruction1 = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(cmNoCheckEntryOffset));
	}
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compileOpenPICMethodCacheProbeForwithShiftbaseRegOrNone(selector, 2, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genSmalltalkToCStackSwitch(1);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), SendNumArgsReg))));
	compileCallFornumArgsargargargargresultRegregsToSave(ceSendFromInLineCacheMiss, 1, SendNumArgsReg, null, null, null, NoReg, 0 /* begin emptyRegisterMask */);
}


/*	Compile one method cache probe in a perform: primitive's lookup of
	selector. Answer the jump taken if the selector probe fails. */

	/* SimpleStackBasedCogit>>#compilePerformMethodCacheProbeFor:withShift:baseRegOrNone: */
static NoDbgRegParms AbstractInstruction *
compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(sqInt selectorReg, sqInt shift, sqInt baseRegOrNone)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;
    sqInt offset1;


	/* begin MoveR:R: */
	genoperandoperand(MoveRR, SendNumArgsReg, ClassReg);
	maybeShiftClassTagRegisterForMethodCacheProbe(ClassReg);
	/* begin XorR:R: */
	genoperandoperand(XorRR, selectorReg, ClassReg);
	assert(shift <= (shiftForWord()));
	if (shift < (shiftForWord())) {
		/* begin LogicalShiftLeftCq:R: */
		genoperandoperand(LogicalShiftLeftCqR, (shiftForWord()) - shift, ClassReg);
	}
	anInstruction = genoperandoperand(AndCqR, ((int)((usqInt)(MethodCacheMask) << (shiftForWord()))), ClassReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(((int)((usqInt)(MethodCacheMask) << (shiftForWord())))));
	}
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset = (methodCacheAddress()) + (((int)((usqInt)(MethodCacheSelector) << (shiftForWord()))));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(offset));
		}
	}
	else {
		/* begin AddR:R: */
		genoperandoperand(AddRR, baseRegOrNone, ClassReg);
		anInstruction2 = genoperandoperandoperand(MoveMwrR, ((int)((usqInt)(MethodCacheSelector) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction2)) {
			(anInstruction2->dependent = locateLiteral(((int)((usqInt)(MethodCacheSelector) << (shiftForWord())))));
		}
	}
	/* begin CmpR:R: */
	assert(!((selectorReg == SPReg)));
	genoperandoperand(CmpRR, selectorReg, TempReg);
	jumpSelectorMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	if (baseRegOrNone == NoReg) {
		/* begin MoveMw:r:R: */
		offset1 = (methodCacheAddress()) + (((int)((usqInt)(MethodCacheClass) << (shiftForWord()))));
		/* begin gen:quickConstant:operand:operand: */
		anInstruction3 = genoperandoperandoperand(MoveMwrR, offset1, ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction3)) {
			(anInstruction3->dependent = locateLiteral(offset1));
		}
	}
	else {
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, ((int)((usqInt)(MethodCacheClass) << (shiftForWord()))), ClassReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction4)) {
			(anInstruction4->dependent = locateLiteral(((int)((usqInt)(MethodCacheClass) << (shiftForWord())))));
		}
	}
	/* begin CmpR:R: */
	assert(!((SendNumArgsReg == SPReg)));
	genoperandoperand(CmpRR, SendNumArgsReg, TempReg);
	return jumpSelectorMiss;
}


/*	Compile a primitive. If possible, performance-critical primitives will
	be generated by their own routines (primitiveGenerator). Otherwise,
	if there is a primitive at all, we call the C routine with the usual
	stack-switching dance, test the primFailCode and then either return
	on success or continue to the method body. */

	/* SimpleStackBasedCogit>>#compilePrimitive */
static sqInt
compilePrimitive(void)
{
    sqInt code;
    sqInt flags;
    sqInt opcodeIndexAtPrimitive;
    PrimitiveDescriptor *primitiveDescriptor;
    void (*primitiveRoutine)(void);

	flags = 0;
	if (primitiveIndex == 0) {
		return 0;
	}
	if ((((primitiveDescriptor = primitiveGeneratorOrNil())))
	 && ((((primitiveDescriptor->primitiveGenerator)))
	 && ((((primitiveDescriptor->primNumArgs)) < 0)
	 || (((primitiveDescriptor->primNumArgs)) == methodOrBlockNumArgs)))) {
		/* Note opcodeIndex so that any arg load instructions
		   for unimplemented primitives can be discarded. */
		opcodeIndexAtPrimitive = opcodeIndex;
		code = ((primitiveDescriptor->primitiveGenerator))();
		if ((code < 0)
		 && (code != UnimplementedPrimitive)) {
			/* Generator failed, so no point continuing... */
			return code;
		}
		if (code == UnfailingPrimitive) {
			return 0;
		}
		if ((code == CompletePrimitive)
		 && (!(		/* begin methodUsesPrimitiveErrorCode:header: */
			((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
		 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))))) {
			return 0;
		}
		if (code == UnimplementedPrimitive) {
			opcodeIndex = opcodeIndexAtPrimitive;
		}
	}
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, (&flags));
	if ((primitiveRoutine == 0)
	 || (primitiveRoutine == (((void (*)(void)) primitiveFail)))) {
		return genFastPrimFail();
	}
	return compileInterpreterPrimitiveflags(primitiveRoutine, flags);
}

	/* SimpleStackBasedCogit>>#extendedPushBytecode */
static sqInt
extendedPushBytecode(void)
{
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genPushReceiverVariable(variableIndex);
	}
	if (variableType == 1) {
		return genPushTemporaryVariable(variableIndex);
	}
	if (variableType == 2) {
		return genPushLiteralIndex(variableIndex);
	}
	return genPushLiteralVariable(variableIndex);
}

	/* SimpleStackBasedCogit>>#extendedStoreAndPopBytecode */
static sqInt
extendedStoreAndPopBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, variableIndex, 
		/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(1, variableIndex);
#    if IMMUTABILITY
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
#    endif // IMMUTABILITY

		return 0;
	}
	if (variableType == 3) {
		return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(1, variableIndex, 
		/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#extendedStoreBytecode */
static sqInt
extendedStoreBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    sqInt variableIndex;
    sqInt variableType;

	variableType = (((usqInt)(byte1)) >> 6) & 3;
	variableIndex = byte1 & 0x3F;
	if (variableType == 0) {
		return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(0, variableIndex, 
		/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
	}
	if (variableType == 1) {
		genStorePopTemporaryVariable(0, variableIndex);
#    if IMMUTABILITY
		abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
#    endif // IMMUTABILITY

		return 0;
	}
	if (variableType == 3) {
		return genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, variableIndex, 
		/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
	}
	return EncounteredUnknownBytecode;
}

	/* SimpleStackBasedCogit>>#frameOffsetOfTemporary: */
static NoDbgRegParms int
frameOffsetOfTemporary(sqInt index)
{
	return 
	/* begin frameOffsetOfTemporary:numArgs: */
(index < methodOrBlockNumArgs
		? FoxCallerSavedIP + ((methodOrBlockNumArgs - index) * BytesPerWord)
		: (FoxMFReceiver - BytesPerWord) + ((methodOrBlockNumArgs - index) * BytesPerWord));
}

	/* SimpleStackBasedCogit>>#genDoubleFailIfZeroArgRcvr:arg: */
static NoDbgRegParms AbstractInstruction *
genDoubleFailIfZeroArgRcvrarg(int rcvrReg, int argReg)
{
    AbstractInstruction *anInstruction;

	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* begin ConvertR:Rd: */
	genoperandoperand(ConvertRRd, TempReg, DPFPReg2);
	genoperandoperand(CmpRdRd, DPFPReg2, argReg);
	return gJumpFPEqual(0);
}


/*	Can use any of the first 32 literals for the selector and pass up to 7
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genExtendedSendBytecode */
static sqInt
genExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x1F, ((usqInt)(byte1)) >> 5);
}

	/* SimpleStackBasedCogit>>#genExtendedSuperBytecode */
static sqInt
genExtendedSuperBytecode(void)
{
	return genSendSupernumArgs(byte1 & 0x1F, ((usqInt)(byte1)) >> 5);
}

	/* SimpleStackBasedCogit>>#genFastPrimFail */
static sqInt
genFastPrimFail(void)
{
	primitiveIndex = 0;
	return UnfailingPrimitive;
}


/*	Support for compileInterpreterPrimitive. Generate inline code
	so as to record the primitive trace as fast as possible. */

	/* SimpleStackBasedCogit>>#genFastPrimTraceUsing:and: */
static NoDbgRegParms void
genFastPrimTraceUsingand(sqInt r1, sqInt r2)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt offset;


	/* begin gen:literal:operand: */
	checkLiteralforInstruction(primTraceLogIndexAddress(), genoperandoperand(MoveAbR, primTraceLogIndexAddress(), r2));
	anInstruction = genoperandoperandoperand(LoadEffectiveAddressMwrR, 1, r2, r1);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(1));
	}
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(primTraceLogIndexAddress(), genoperandoperand(MoveRAb, r1, primTraceLogIndexAddress()));
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), r1))));
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction1 = genoperandoperandoperand(MoveMwrR, offset, r1, TempReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(offset));
	}
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(((sqInt)(primTraceLogAddress())), genoperandoperand(MoveCwR, ((sqInt)(primTraceLogAddress())), r1));
	genoperandoperandoperand(MoveRXwrR, TempReg, r2, r1);
}

	/* SimpleStackBasedCogit>>#genLoadNewMethod */
static void
genLoadNewMethod(void)
{
    sqInt address;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt offset;

	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperandoperand(MoveCwR, ((sqInt)methodLabel), ClassReg))));
	/* begin MoveMw:r:R: */
	offset = offsetof(CogMethod, methodObject);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(newMethodAddress(), genoperandoperand(MoveRAw, TempReg, newMethodAddress()));
#  if LRPCheck
	if (checkingLongRunningPrimitives()) {
		/* begin MoveCq:R: */
		anInstruction1 = genoperandoperand(MoveCqR, 0, TempReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(0));
		}
		/* begin gen:operand:literal: */
		checkLiteralforInstruction(longRunningPrimitiveStopUsecsAddress(), genoperandoperand(MoveRAw, TempReg, longRunningPrimitiveStopUsecsAddress()));
		address = (longRunningPrimitiveStopUsecsAddress()) + 4;
		/* begin gen:operand:literal: */
		checkLiteralforInstruction(address, genoperandoperand(MoveRAw, TempReg, address));
	}
#  endif // LRPCheck
}

	/* SimpleStackBasedCogit>>#genLongJumpIfFalse */
static sqInt
genLongJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genLongJumpIfTrue */
static sqInt
genLongJumpIfTrue(void)
{
    sqInt distance;
    sqInt target;

	distance = v3LongForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 2) + bytecodePC;
	return genJumpIfto(trueObject(), target);
}


/*	237		11101101	i i i i i i i i	Pop and Store Temporary Variable #iiiiiiii */

	/* SimpleStackBasedCogit>>#genLongStoreAndPopTemporaryVariableBytecode */
static sqInt
genLongStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte1);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalBackwardJump */
static sqInt
genLongUnconditionalBackwardJump(void)
{
    sqInt distance;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance < 0);
	return genJumpBackTo((distance + 2) + bytecodePC);
}

	/* SimpleStackBasedCogit>>#genLongUnconditionalForwardJump */
static sqInt
genLongUnconditionalForwardJump(void)
{
    sqInt distance;
    sqInt targetpc;

	distance = v3LongBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	assert(distance >= 0);
	targetpc = (distance + 2) + bytecodePC;
	return genJumpTo(targetpc);
}


/*	Compile the code for a probe of the first-level method cache for a perform
	primitive. The selector is assumed to be in Arg0Reg. Defer to
	adjustArgumentsForPerform: to
	adjust the arguments before the jump to the method. */
/*	N.B. Can't assume TempReg already contains the tag because a method can
	of course be invoked via the unchecked entry-point, e.g. as does perform:. */

	/* SimpleStackBasedCogit>>#genLookupForPerformNumArgs: */
static NoDbgRegParms sqInt
genLookupForPerformNumArgs(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    sqInt cacheBaseReg;
    AbstractInstruction *itsAHit;
    AbstractInstruction *jumpBadNumArgs;
    AbstractInstruction *jumpClassMiss;
    AbstractInstruction *jumpInterpret;
    AbstractInstruction *jumpSelectorMiss;
    sqInt offset;

	genGetInlineCacheClassTagFromintoforEntry(ReceiverResultReg, SendNumArgsReg, 0);
	flag("lookupInMethodCacheSel:classTag:");
	cacheBaseReg = NoReg;
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 0, cacheBaseReg);
	/* Fetch the method, and check if it is cogged. */
	jumpClassMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveMw:r:R: */
	offset = (cacheBaseReg == NoReg
		? (methodCacheAddress()) + (((int)((usqInt)(MethodCacheMethod) << (shiftForWord()))))
		: ((int)((usqInt)(MethodCacheMethod) << (shiftForWord()))));
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	itsAHit = anInstruction;
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	/* check the argument count; if it's wrong fall back on the interpreter primitive. */
	jumpInterpret = genJumpImmediate(ClassReg);
	/* begin genLoadcmNumArgsOf:into: */
	anInstruction1 = genoperandoperandoperand(MoveMbrR, BytesPerWord, ClassReg, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(BytesPerWord));
	}
	/* begin CmpCq:R: */
	anInstruction2 = genoperandoperand(CmpCqR, numArgs, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(numArgs));
	}
	/* Adjust arguments and jump to the method's unchecked entry-point. */
	jumpBadNumArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin AddCq:R: */
	anInstruction3 = genoperandoperand(AddCqR, cmNoCheckEntryOffset, ClassReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(cmNoCheckEntryOffset));
	}
	adjustArgumentsForPerform(numArgs);
	/* begin JumpR: */
	genoperand(JumpR, ClassReg);
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpClassMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 1, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	jumpSelectorMiss = compilePerformMethodCacheProbeForwithShiftbaseRegOrNone(Arg0Reg, 2, cacheBaseReg);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)itsAHit));
	jmpTarget(jumpSelectorMiss, jmpTarget(jumpInterpret, jmpTarget(jumpBadNumArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC))));
	return 0;
}

	/* SimpleStackBasedCogit>>#genMustBeBooleanTrampolineFor:called: */
static NoDbgRegParms usqInt
genMustBeBooleanTrampolineForcalled(sqInt boolean, char *trampolineName)
{
    AbstractInstruction *anInstruction;

	zeroOpcodeIndex();
	assert(!(shouldAnnotateObjectReference(boolean)));
	/* begin AddCq:R: */
	anInstruction = genoperandoperand(AddCqR, boolean, TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(boolean));
	}
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSendMustBeBoolean, trampolineName, 1, TempReg, null, null, null, 0 /* begin emptyRegisterMask */, 1, NoReg, 1);
}


/*	Implement 28-bit hashMultiply for SmallInteger and LargePositiveInteger
	receivers. 
 */

	/* SimpleStackBasedCogit>>#genPrimitiveHashMultiply */
static int
genPrimitiveHashMultiply(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *jmpFailImm;
    AbstractInstruction *jmpFailNotPositiveLargeInt;

	if (mclassIsSmallInteger()) {
		genConvertSmallIntegerToIntegerInReg(ReceiverResultReg);
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, HashMultiplyConstant, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(HashMultiplyConstant));
		}
		/* begin MulR:R: */
		genMulRR(backEnd, TempReg, ReceiverResultReg);
		anInstruction1 = genoperandoperand(AndCqR, HashMultiplyMask, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(HashMultiplyMask));
		}
		genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
		/* begin RetN: */
		genoperand(RetN, 0);
		return CompletePrimitive;
	}
	jmpFailImm = genJumpImmediate(ReceiverResultReg);
	genGetCompactClassIndexNonImmOfinto(ReceiverResultReg, ClassReg);
	/* begin CmpCq:R: */
	anInstruction2 = genoperandoperand(CmpCqR, ClassLargePositiveIntegerCompactIndex, ClassReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(ClassLargePositiveIntegerCompactIndex));
	}
	jmpFailNotPositiveLargeInt = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(0, ReceiverResultReg, ReceiverResultReg);
	/* begin MoveCq:R: */
	anInstruction3 = genoperandoperand(MoveCqR, HashMultiplyConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(HashMultiplyConstant));
	}
	/* begin MulR:R: */
	genMulRR(backEnd, TempReg, ReceiverResultReg);
	anInstruction4 = genoperandoperand(AndCqR, HashMultiplyMask, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(HashMultiplyMask));
	}
	genConvertIntegerToSmallIntegerInReg(ReceiverResultReg);
	/* begin RetN: */
	genoperand(RetN, 0);
	jmpTarget(jmpFailImm, jmpTarget(jmpFailNotPositiveLargeInt, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return CompletePrimitive;
}


/*	Generate the substitute return code for an external or FFI primitive call.
	On success simply return, extracting numArgs from newMethod.
	On primitive failure call ceActivateFailingPrimitiveMethod: newMethod. */

	/* SimpleStackBasedCogit>>#genPrimReturnEnterCogCodeEnilopmart: */
static NoDbgRegParms void
genPrimReturnEnterCogCodeEnilopmart(sqInt profiling)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *jmpFail;
    sqInt quickConstant;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(primFailCodeAddress(), genoperandoperand(MoveAwR, primFailCodeAddress(), TempReg));
	flag("ask concrete code gen if move sets condition codes?");
	/* begin CmpCq:R: */
	anInstruction1 = genoperandoperand(CmpCqR, 0, TempReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	jmpFail = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadStackPointers(backEnd);
	/* begin PopR: */
	genoperand(PopR, ReceiverResultReg);
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), PCReg));
	jmpTarget(jmpFail, checkLiteralforInstruction(newMethodAddress(), genoperandoperand(MoveAwR, newMethodAddress(), SendNumArgsReg)));
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(cStackPointerAddress(), genoperandoperand(MoveAwR, cStackPointerAddress(), SPReg));
	compileCallFornumArgsargargargargresultRegregsToSave(ceActivateFailingPrimitiveMethod, 1, SendNumArgsReg, null, null, null, NoReg, 0 /* begin emptyRegisterMask */);
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveAwR, instructionPointerAddress(), LinkReg));
	genLoadStackPointers(backEnd);
	/* begin MoveMw:r:R: */
	anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, SPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(0));
	}
	/* begin RetN: */
	genoperand(RetN, BytesPerWord);
}

	/* SimpleStackBasedCogit>>#genPushConstantFalseBytecode */
static sqInt
genPushConstantFalseBytecode(void)
{
	return ssPushConstant(falseObject());
}

	/* SimpleStackBasedCogit>>#genPushConstantNilBytecode */
static sqInt
genPushConstantNilBytecode(void)
{
	return ssPushConstant(nilObject());
}

	/* SimpleStackBasedCogit>>#genPushConstantTrueBytecode */
static sqInt
genPushConstantTrueBytecode(void)
{
	return ssPushConstant(trueObject());
}

	/* SimpleStackBasedCogit>>#genPushLiteralConstantBytecode */
static sqInt
genPushLiteralConstantBytecode(void)
{
	return genPushLiteralIndex(byte0 & 0x1F);
}

	/* SimpleStackBasedCogit>>#genPushLiteralVariableBytecode */
static sqInt
genPushLiteralVariableBytecode(void)
{
	return genPushLiteralVariable(byte0 & 0x1F);
}

	/* SimpleStackBasedCogit>>#genPushQuickIntegerConstantBytecode */
static sqInt
genPushQuickIntegerConstantBytecode(void)
{
	return ssPushConstant((((usqInt)(byte0 - 117) << 1) | 1));
}

	/* SimpleStackBasedCogit>>#genPushReceiverVariableBytecode */
static sqInt
genPushReceiverVariableBytecode(void)
{
	return genPushReceiverVariable(byte0 & 15);
}

	/* SimpleStackBasedCogit>>#genPushTemporaryVariableBytecode */
static sqInt
genPushTemporaryVariableBytecode(void)
{
	return genPushTemporaryVariable(byte0 & 15);
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnConst */
sqInt
genQuickReturnConst(void)
{
    AbstractInstruction *anInstruction;
    sqInt constant;

	constant = quickPrimitiveConstantFor(primitiveIndex);
	/* begin genMoveConstant:R: */
	if (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(constant))
	 && (oopisGreaterThan(constant, trueObject()))) {
		annotateobjRef(checkLiteralforInstruction(constant, genoperandoperand(MoveCwR, constant, ReceiverResultReg)), constant);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, constant, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(constant));
		}
	}
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnInstVar */
sqInt
genQuickReturnInstVar(void)
{
    sqInt index;

	index = quickPrimitiveInstVarIndexFor(primitiveIndex);
	genLoadSlotsourceRegdestReg(index, ReceiverResultReg, ReceiverResultReg);
	genUpArrowReturn();
	return UnfailingPrimitive;
}


/*	because selected by CoInterpreter>>quickPrimitiveGeneratorFor: */

	/* SimpleStackBasedCogit>>#genQuickReturnSelf */
sqInt
genQuickReturnSelf(void)
{
	genUpArrowReturn();
	return UnfailingPrimitive;
}

	/* SimpleStackBasedCogit>>#genReturnFalse */
static sqInt
genReturnFalse(void)
{
    AbstractInstruction *anInstruction;


	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, falseObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(falseObject()));
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnNil */
static sqInt
genReturnNil(void)
{
    AbstractInstruction *anInstruction;


	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(nilObject()));
	}
	return genUpArrowReturn();
}

	/* SimpleStackBasedCogit>>#genReturnTrue */
static sqInt
genReturnTrue(void)
{
    AbstractInstruction *anInstruction;


	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, trueObject(), ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(trueObject()));
	}
	return genUpArrowReturn();
}


/*	Can use any of the first 64 literals for the selector and pass up to 3
	arguments. 
 */

	/* SimpleStackBasedCogit>>#genSecondExtendedSendBytecode */
static sqInt
genSecondExtendedSendBytecode(void)
{
	return genSendnumArgs(byte1 & 0x3F, ((usqInt)(byte1)) >> 6);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector0ArgsBytecode */
static sqInt
genSendLiteralSelector0ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 0);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector1ArgBytecode */
static sqInt
genSendLiteralSelector1ArgBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 1);
}

	/* SimpleStackBasedCogit>>#genSendLiteralSelector2ArgsBytecode */
static sqInt
genSendLiteralSelector2ArgsBytecode(void)
{
	return genSendnumArgs(byte0 & 15, 2);
}

	/* SimpleStackBasedCogit>>#genShortJumpIfFalse */
static sqInt
genShortJumpIfFalse(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpIfto(falseObject(), target);
}

	/* SimpleStackBasedCogit>>#genShortUnconditionalJump */
static sqInt
genShortUnconditionalJump(void)
{
    sqInt distance;
    sqInt target;

	distance = v3ShortForwardBranchDistance(generatorAt(byte0), bytecodePC, 0, methodObj);
	target = (distance + 1) + bytecodePC;
	return genJumpTo(target);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorEqualsEquals */
static sqInt
genSpecialSelectorEqualsEquals(void)
{
	return genInlinedIdenticalOrNotIf(0);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorNotEqualsEquals */
static sqInt
genSpecialSelectorNotEqualsEquals(void)
{
	return genInlinedIdenticalOrNotIf(1);
}

	/* SimpleStackBasedCogit>>#genSpecialSelectorSend */
static sqInt
genSpecialSelectorSend(void)
{
    sqInt index;
    sqInt numArgs;

	index = byte0 - FirstSpecialSelector;
	numArgs = specialSelectorNumArgs(index);
	return genSendnumArgs((-index) - 1, numArgs);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopReceiverVariableBytecode */
static sqInt
genStoreAndPopReceiverVariableBytecode(void)
{
	return genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(1, byte0 & 7, 
	/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(((ssTop())->constant)))
	 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
}

	/* SimpleStackBasedCogit>>#genStoreAndPopRemoteTempLongBytecode */
static sqInt
genStoreAndPopRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAtneedsStoreCheck(1, byte1, byte2, 
	/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(((ssTop())->constant)))
	 && (oopisGreaterThan(((ssTop())->constant), trueObject())))));
}

	/* SimpleStackBasedCogit>>#genStoreAndPopTemporaryVariableBytecode */
static sqInt
genStoreAndPopTemporaryVariableBytecode(void)
{
	return genStorePopTemporaryVariable(1, byte0 & 7);
}

	/* SimpleStackBasedCogit>>#genStoreRemoteTempLongBytecode */
static sqInt
genStoreRemoteTempLongBytecode(void)
{
	return genStorePopRemoteTempAtneedsStoreCheck(0, byte1, byte2, 
	/* begin ssTopNeedsStoreCheck */
((((ssTop())->type)) != SSConstant)
	 || ((isNonImmediate(((ssTop())->constant)))
	 && (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(((ssTop())->constant)))
	 && (oopisGreaterThan(((ssTop())->constant), trueObject())))));
}


/*	Collect the branch and send data for cogMethod, storing it into arrayObj. */

	/* SimpleStackBasedCogit>>#mapPCDataFor:into: */
sqInt
mapPCDataForinto(CogMethod *cogMethod, sqInt arrayObj)
{
    sqInt aMethodObj;
    sqInt annotation;
    sqInt bcpc;
    sqInt bsOffset;
    sqInt byte;
    BytecodeDescriptor *descriptor;
    sqInt distance;
    sqInt endbcpc;
    sqInt errCode;
    CogMethod *homeMethod;
    sqInt isBackwardBranch;
    sqInt isInBlock;
    sqInt latestContinuation;
    usqInt map;
    sqInt mapByte;
    usqInt mcpc;
    sqInt nExts;
    sqInt nextBcpc;
    sqInt result;
    sqInt startbcpc;
    sqInt targetPC;

	introspectionDataIndex = 0;
	introspectionData = arrayObj;
	if (((cogMethod->stackCheckOffset)) == 0) {
		assert(introspectionDataIndex == 0);
		storePointerUncheckedofObjectwithValue(0, introspectionData, nilObject());
		storePointerUncheckedofObjectwithValue(1, introspectionData, (((usqInt)cmEntryOffset << 1) | 1));
		storePointerUncheckedofObjectwithValue(2, introspectionData, nilObject());
		storePointerUncheckedofObjectwithValue(3, introspectionData, (((usqInt)cmNoCheckEntryOffset << 1) | 1));
		return 4;
	}
	startbcpc = startPCOfMethod((cogMethod->methodObject));
	/* begin mapFor:bcpc:performUntil:arg: */
	latestContinuation = 0;
	assert((((((CogBlockMethod *) cogMethod))->stackCheckOffset)) > 0);
	/* The stack check maps to the start of the first bytecode,
	   the first bytecode being effectively after frame build. */
	mcpc = (((usqInt)(((CogBlockMethod *) cogMethod)))) + (((((CogBlockMethod *) cogMethod))->stackCheckOffset));
	result = pcDataForAnnotationMcpcBcpcMethod(null, 0 + (((int)((usqInt)(HasBytecodePC) << 1))), ((char *) mcpc), startbcpc, ((void *)cogMethod));
	if (result != 0) {
		errCode = result;
		goto l2;
	}
	/* In both CMMethod and CMBlock cases find the start of the map and
	   skip forward to the bytecode pc map entry for the stack check. */
	bcpc = startbcpc;
	if ((((((CogBlockMethod *) cogMethod))->cmType)) >= CMMethod) {
		isInBlock = 0 /* begin cmIsFullBlock */;
		homeMethod = ((CogMethod *) (((CogBlockMethod *) cogMethod)));
		assert(startbcpc == (startPCOfMethodHeader((homeMethod->methodHeader))));
		map = ((((usqInt)homeMethod)) + ((homeMethod->blockSize))) - 1;
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert((annotation == IsAbsPCReference)
		 || ((annotation == IsObjectReference)
		 || ((annotation == IsRelativeCall)
		 || (annotation == IsDisplacementX2N))));
		latestContinuation = startbcpc;
		aMethodObj = (homeMethod->methodObject);
		endbcpc = (numBytesOf(aMethodObj)) - 1;
		/* If the method has a primitive, skip it and the error code store, if any;
		   Logically. these come before the stack check and so must be ignored. */
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		bcpc += deltaToSkipPrimAndErrorStoreInheader(aMethodObj, (homeMethod->methodHeader));
	}
	else {
		isInBlock = 1;
		assert(bcpc == (((((CogBlockMethod *) cogMethod))->startpc)));
		homeMethod = cmHomeMethod(((CogBlockMethod *) cogMethod));
		map = findMapLocationForMcpcinMethod((((usqInt)(((CogBlockMethod *) cogMethod)))) + (sizeof(CogBlockMethod)), homeMethod);
		assert(map != 0);
		annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift;
		assert(((((usqInt)(annotation)) >> AnnotationShift) == HasBytecodePC)
		 || ((((usqInt)(annotation)) >> AnnotationShift) == IsDisplacementX2N));
		while (((annotation = ((usqInt)((byteAt(map)))) >> AnnotationShift)) != HasBytecodePC) {
			map -= 1;
		}
		/* skip fiducial; i.e. the map entry for the pc immediately following the method header. */
		map -= 1;
		aMethodObj = (homeMethod->methodObject);
		bcpc = startbcpc - BlockCreationBytecodeSize;
		bsOffset = 0 /* begin bytecodeSetOffsetForHeader: */;
		byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
		descriptor = generatorAt(byte);
		endbcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, -1, aMethodObj)
	: 0));
		bcpc = startbcpc;
	}
	nExts = 0;
	while ((((usqInt)((byteAt(map)))) >> AnnotationShift) != HasBytecodePC) {
		map -= 1;
	}
	map -= 1;
	while (((mapByte = byteAt(map))) != MapEnd) {
		/* defensive; we exit on bcpc */
		if (mapByte >= FirstAnnotation) {
			annotation = ((usqInt)(mapByte)) >> AnnotationShift;
			mcpc += (mapByte & DisplacementMask) * 4 /* begin codeGranularity */;
			if (annotation >= HasBytecodePC) {
				if ((annotation == IsSendCall)
				 && ((((usqInt)(((mapByte = byteAt(map - 1))))) >> AnnotationShift) == IsAnnotationExtension)) {
					annotation += mapByte & DisplacementMask;
					map -= 1;
				}
				while (1) {
					byte = (fetchByteofObject(bcpc, aMethodObj)) + bsOffset;
					descriptor = generatorAt(byte);
					if (isInBlock) {
						if (bcpc >= endbcpc) {
							errCode = 0;
							goto l2;
						}
					}
					else {
						if (((descriptor->isReturn))
						 && (bcpc >= latestContinuation)) {
							errCode = 0;
							goto l2;
						}
						if ((isBranch(descriptor))
						 || ((descriptor->isBlockCreation))) {
							/* begin latestContinuationPCFor:at:exts:in: */
							distance = ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj);
							targetPC = (bcpc + ((descriptor->numBytes))) + (((distance < 0) ? 0 : distance));
							latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
						}
					}
					nextBcpc = (bcpc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)
	: 0));
					if (((descriptor->isMapped))
					 || (isInBlock
					 && ((descriptor->isMappedInBlock)))) break;
					bcpc = nextBcpc;
					nExts = ((descriptor->isExtension)
						? nExts + 1
						: 0);
				}
				isBackwardBranch = (isBranch(descriptor))
				 && ((				/* begin isBackwardBranch:at:exts:in: */
					assert(((descriptor->spanFunction))),
				(((descriptor->spanFunction))(descriptor, bcpc, nExts, aMethodObj)) < 0));
				result = pcDataForAnnotationMcpcBcpcMethod(descriptor, (isBackwardBranch
					? (((sqInt)((usqInt)(annotation) << 1))) + 1
					: ((sqInt)((usqInt)(annotation) << 1))), ((char *) mcpc), (isBackwardBranch
					? bcpc - (2 * nExts)
					: bcpc), ((void *)cogMethod));
				if (result != 0) {
					errCode = result;
					goto l2;
				}
				bcpc = nextBcpc;
				nExts = ((descriptor->isExtension)
					? nExts + 1
					: 0);
			}
		}
		else {
			assert(((((usqInt)(mapByte)) >> AnnotationShift) == IsDisplacementX2N)
			 || ((((usqInt)(mapByte)) >> AnnotationShift) == IsAnnotationExtension));
			if (mapByte < (((int)((usqInt)(IsAnnotationExtension) << AnnotationShift)))) {
				mcpc += (((sqInt)((usqInt)((mapByte - DisplacementX2N)) << AnnotationShift))) * 4 /* begin codeGranularity */;
			}
		}
		map -= 1;
	}
	errCode = 0;
	l2:	/* end mapFor:bcpc:performUntil:arg: */;
	if (errCode != 0) {
		assert(errCode == PrimErrNoMemory);
		return -1;
	}
	if (((cogMethod->blockEntryOffset)) != 0) {
		errCode = blockDispatchTargetsForperformarg(cogMethod, pcDataForBlockEntryMethod, ((sqInt)cogMethod));
		if (errCode != 0) {
			assert(errCode == PrimErrNoMemory);
			return -1;
		}
	}
	return introspectionDataIndex;
}

	/* SimpleStackBasedCogit>>#numSpecialSelectors */
static sqInt
numSpecialSelectors(void)
{
	return NumSpecialSelectors;
}


/*	Collect the branch and send data for the block method starting at
	blockEntryMcpc, storing it into picData.
 */

	/* SimpleStackBasedCogit>>#pcDataForBlockEntry:Method: */
static NoDbgRegParms usqInt
pcDataForBlockEntryMethod(sqInt blockEntryMcpc, sqInt cogMethod)
{
	storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)(blockEntryMcpc - blockNoContextSwitchOffset) << 1) | 1));
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
	storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)blockEntryMcpc << 1) | 1));
	introspectionDataIndex += 4;
	return 0;
}

	/* SimpleStackBasedCogit>>#pcDataFor:Annotation:Mcpc:Bcpc:Method: */
static NoDbgRegParms sqInt
pcDataForAnnotationMcpcBcpcMethod(BytecodeDescriptor *descriptor, sqInt isBackwardBranchAndAnnotation, char *mcpc, sqInt bcpc, void *cogMethodArg)
{
    sqInt actualBcpc;
    sqInt actualMcpc;

	if (!descriptor) {
		/* this is the stackCheck offset */
		assert(introspectionDataIndex == 0);
		storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, nilObject());
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)cmEntryOffset << 1) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 2, introspectionData, nilObject());
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 3, introspectionData, (((usqInt)cmNoCheckEntryOffset << 1) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 4, introspectionData, (((usqInt)(bcpc + 1) << 1) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 5, introspectionData, (((((((CogMethod *) cogMethodArg))->stackCheckOffset)) << 1) | 1));
		introspectionDataIndex += 6;
		return 0;
	}
	if ((((usqInt)(isBackwardBranchAndAnnotation)) >> 1) >= HasBytecodePC) {
		actualBcpc = (((isBackwardBranchAndAnnotation & 1) != 0)
			? bcpc + 1
			: (bcpc + ((descriptor->numBytes))) + 1);
		actualMcpc = (((usqInt)mcpc)) - (((usqInt)cogMethodArg));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex, introspectionData, (((usqInt)actualBcpc << 1) | 1));
		storePointerUncheckedofObjectwithValue(introspectionDataIndex + 1, introspectionData, (((usqInt)actualMcpc << 1) | 1));
		introspectionDataIndex += 2;
	}
	return 0;
}


/*	If there is a generator for the current primitive then answer it;
	otherwise answer nil. */

	/* SimpleStackBasedCogit>>#primitiveGeneratorOrNil */
static PrimitiveDescriptor *
primitiveGeneratorOrNil(void)
{
    PrimitiveDescriptor *primitiveDescriptor;

	if (isQuickPrimitiveIndex(primitiveIndex)) {
		/* an unused one */
		primitiveDescriptor = (&(primitiveGeneratorTable[0]));
		(primitiveDescriptor->primitiveGenerator = quickPrimitiveGeneratorFor(primitiveIndex));
		return primitiveDescriptor;
	}
	if (((primitiveIndex >= 1) && (primitiveIndex <= MaxCompiledPrimitiveIndex))) {
		return (&(primitiveGeneratorTable[primitiveIndex]));
	}
	return null;
}

	/* SimpleStackBasedCogit>>#register:isInMask: */
static NoDbgRegParms int
registerisInMask(sqInt reg, sqInt mask)
{
	return ((mask & (((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1U << reg)))) != 0);
}

	/* SimpleStackBasedCogit>>#v3:Block:Code:Size: */
static NoDbgRegParms sqInt
v3BlockCodeSize(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts <= 0);
	return (((sqInt)((usqInt)((fetchByteofObject(pc + 2, aMethodObj))) << 8))) + (fetchByteofObject(pc + 3, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:LongForward:Branch:Distance: */
static NoDbgRegParms sqInt
v3LongForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return (((sqInt)((usqInt)(((fetchByteofObject(pc, aMethodObj)) & 3)) << 8))) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	Answer the distance of a two byte forward long jump. */

	/* SimpleStackBasedCogit>>#v3:Long:Branch:Distance: */
static NoDbgRegParms sqInt
v3LongBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return (((sqInt)((usqInt)((((fetchByteofObject(pc, aMethodObj)) & 7) - 4)) << 8))) + (fetchByteofObject(pc + 1, aMethodObj));
}


/*	N.B. This serves for both BlueBook/V3 and V4 short jumps. */

	/* SimpleStackBasedCogit>>#v3:ShortForward:Branch:Distance: */
static NoDbgRegParms sqInt
v3ShortForwardBranchDistance(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	assert(nExts == 0);
	return ((fetchByteofObject(pc, aMethodObj)) & 7) + 1;
}


/*	Add a blockStart for an embedded block. For a binary tree walk block
	dispatch blocks must be compiled in pc/depth-first order but are scanned
	in breadth-first
	order, so do an insertion sort (which of course is really a bubble sort
	because we
	have to move everything higher to make room). */

	/* StackToRegisterMappingCogit>>#addBlockStartAt:numArgs:numCopied:span: */
static NoDbgRegParms BlockStart *
addBlockStartAtnumArgsnumCopiedspan(sqInt bytecodepc, sqInt numArgs, sqInt numCopied, sqInt span)
{
    BlockStart *blockStart;
    sqInt i;
    sqInt j;


	/* Transcript ensureCr; nextPutAll: 'addBlockStartAt: '; print: bytecodepc; cr; flush. */
	if (blockCount > 0) {
		i = blockCount - 1;
		while (1) {
			/* check for repeat addition during recompilation due to initialNil miscount. */
			blockStart = (&(blockStarts[i]));
			if (((blockStart->startpc)) == bytecodepc) {
				return blockStart;
			}
			if (!((((blockStart->startpc)) > bytecodepc)
			 && (i > 0))) break;
			i -= 1;
		}
		for (j = blockCount; j >= (i + 1); j += -1) {
			blockStarts[j] = (blockStarts[j - 1]);
		}
		blockStart = (&(blockStarts[i + 1]));
	}
	else {
		blockStart = (&(blockStarts[blockCount]));
	}
	blockCount += 1;
	(blockStart->startpc = bytecodepc);
	(blockStart->numArgs = numArgs);
	(blockStart->numCopied = numCopied);
	(blockStart->numInitialNils = 0);
	(blockStart->stackCheckLabel = null);
	(blockStart->hasInstVarRef = 0);
	(blockStart->span = span);
	return blockStart;
}


/*	e.g.	Receiver				Receiver	or	Receiver				Receiver	(RISC)
	Selector/Arg0	=>		Arg1			Selector/Arg0	=>		Arg1
	Arg1					Arg2			Arg1					Arg2
	Arg2					Arg3			Arg2			sp->	Arg3
	Arg3			sp->	retpc	sp->	Arg3
	sp->	retpc */
/*	Generate code to adjust the possibly stacked arguments immediately
	before jumping to a method looked up by a perform primitive. */

	/* StackToRegisterMappingCogit>>#adjustArgumentsForPerform: */
static NoDbgRegParms void
adjustArgumentsForPerform(sqInt numArgs)
{
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    sqInt index;
    sqInt offset;
    sqInt quickConstant;

	assert((numRegArgs()) <= 2);
	assert(numArgs >= 1);
	if (numArgs <= (numRegArgs())) {
		if (numArgs == 2) {
			/* begin MoveR:R: */
			genoperandoperand(MoveRR, Arg1Reg, Arg0Reg);
		}
		return;
	}
	if (((numRegArgs()) + 1) == numArgs) {
				/* begin MoveMw:r:R: */
		anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, SPReg, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction2)) {
			(anInstruction2->dependent = locateLiteral(0));
		}
		/* begin AddCq:R: */
		quickConstant = (numArgs + 1) * BytesPerWord;
		/* begin gen:quickConstant:operand: */
		anInstruction3 = genoperandoperand(AddCqR, quickConstant, SPReg);
		if (usesOutOfLineLiteral(anInstruction3)) {
			(anInstruction3->dependent = locateLiteral(quickConstant));
		}
		return;
	}
	for (index = (numArgs - 2); index >= 0; index += -1) {
		/* begin MoveMw:r:R: */
		anInstruction4 = genoperandoperandoperand(MoveMwrR, index * BytesPerWord, SPReg, TempReg);
		if (usesOutOfLineLiteral(anInstruction4)) {
			(anInstruction4->dependent = locateLiteral(index * BytesPerWord));
		}
		/* begin MoveR:Mw:r: */
		offset = (index + 1) * BytesPerWord;
		/* begin gen:operand:quickConstant:operand: */
		anInstruction5 = genoperandoperandoperand(MoveRMwr, TempReg, offset, SPReg);
		if (usesOutOfLineLiteral(anInstruction5)) {
			(anInstruction5->dependent = locateLiteral(offset));
		}
	}
	/* begin AddCq:R: */
	anInstruction6 = genoperandoperand(AddCqR, BytesPerWord, SPReg);
	if (usesOutOfLineLiteral(anInstruction6)) {
		(anInstruction6->dependent = locateLiteral(BytesPerWord));
	}
}


/*	If the stack entry is already in a register not conflicting with regMask,
	answers it,
	else allocate a new register not conflicting with reg mask
 */

	/* StackToRegisterMappingCogit>>#allocateRegForStackEntryAt:notConflictingWith: */
static NoDbgRegParms sqInt
allocateRegForStackEntryAtnotConflictingWith(sqInt index, sqInt regMask)
{
    sqInt mask;
    CogSimStackEntry *stackEntry;

	stackEntry = ssValue(index);
	mask = registerMaskOrNone(stackEntry);
	if ((mask != 0)
	 && ((!(mask & regMask)))) {
		flag("TODO");
		return registerOrNone(stackEntry);
	}
	return allocateRegNotConflictingWith(regMask);
}


/*	if there's a free register, use it */

	/* StackToRegisterMappingCogit>>#allocateRegNotConflictingWith: */
static NoDbgRegParms sqInt
allocateRegNotConflictingWith(sqInt regMask)
{
    sqInt reg;

	reg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | regMask);
	if (reg == NoReg) {
		/* No free register, choose one that does not conflict with regMask */
		reg = freeAnyRegNotConflictingWith(regMask);
	}
	if (reg == ReceiverResultReg) {
		/* If we've allocated RcvrResultReg, it's not live anymore */
		voidReceiverResultRegContainsSelf();
	}
	return reg;
}

	/* StackToRegisterMappingCogit>>#anyReferencesToRegister:inTopNItems: */
static NoDbgRegParms sqInt
anyReferencesToRegisterinTopNItems(sqInt reg, sqInt n)
{
    sqInt i;
    sqInt regMask;

	regMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1U << reg));
	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((registerMask(simStackAt(i))) & regMask) != 0)) {
			return 1;
		}
	}
	return 0;
}


/*	This is a static version of ceCallCogCodePopReceiverArg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg0Regs */
void
callCogCodePopReceiverArg0Regs(void)
{
	realCECallCogCodePopReceiverArg0Regs();
}


/*	This is a static version of ceCallCogCodePopReceiverArg1Arg0Regs
	for break-pointing when debugging in C. */
/*	This exists only for break-pointing. */

	/* StackToRegisterMappingCogit>>#callCogCodePopReceiverArg1Arg0Regs */
void
callCogCodePopReceiverArg1Arg0Regs(void)
{
	realCECallCogCodePopReceiverArg1Arg0Regs();
}


/*	Loop over bytecodes, dispatching to the generator for each bytecode,
	handling fixups in due course.
 */

	/* StackToRegisterMappingCogit>>#compileAbstractInstructionsFrom:through: */
static NoDbgRegParms sqInt
compileAbstractInstructionsFromthrough(sqInt start, sqInt end)
{
    BytecodeDescriptor *descriptor;
    BytecodeFixup *fixup;
    sqInt nExts;
    sqInt nextOpcodeIndex;
    sqInt result;

	traceSimStack();
	bytecodePC = start;
	nExts = (result = 0);
	descriptor = null;
	deadCode = 0;
	while (1) {
		maybeHaltIfDebugPC();
		mergeWithFixupIfRequired((fixup = fixupAt(bytecodePC)));
		descriptor = loadBytesAndGetDescriptor();
		nextOpcodeIndex = opcodeIndex;
		if (deadCode) {
			result = mapDeadDescriptorIfNeeded(descriptor);
		}
		else {
			result = ((descriptor->generator))();
		}
		if (result == 0) {
			/* begin assertExtsAreConsumed: */
			if (!((descriptor->isExtension))) {
				assert((extA == 0)
				 && ((extB == 0)
				 && (numExtB == 0)));
			}
		}
		traceDescriptor(descriptor);
		traceSimStack();
		/* begin patchFixupTargetIfNeeded:nextOpcodeIndex: */
		if ((((((usqInt)((fixup->targetInstruction)))) >= NeedsNonMergeFixupFlag) && ((((usqInt)((fixup->targetInstruction)))) <= NeedsMergeFixupFlag))) {
			/* There is a fixup for this bytecode.  It must point to the first generated
			   instruction for this bytecode.  If there isn't one we need to add a label. */
			if (opcodeIndex == nextOpcodeIndex) {
				/* begin Label */
				genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			(fixup->targetInstruction = abstractInstructionAt(nextOpcodeIndex));
		}
		/* begin maybeDumpLiterals: */
		if ((		/* begin mustDumpLiterals: */
			(opcodeIndex >= firstOpcodeIndex)
		 && ((opcodeIndex - firstOpcodeIndex) >= (outOfLineLiteralOpcodeLimit(backEnd()))))
		 || ((		/* begin isUnconditionalBranch */
			(isBranch(descriptor))
		 && (!(((descriptor->isBranchTrue))
		 || ((descriptor->isBranchFalse)))))
		 || ((descriptor->isReturn)))) {
			dumpLiterals(!((			/* begin isUnconditionalBranch */
				(isBranch(descriptor))
			 && (!(((descriptor->isBranchTrue))
			 || ((descriptor->isBranchFalse)))))
			 || ((descriptor->isReturn))));
		}
		bytecodePC = (bytecodePC + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, bytecodePC, nExts, methodObj)
	: 0));
		if (!((result == 0)
		 && (bytecodePC <= end))) break;
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
	}
	/* begin checkEnoughOpcodes */
	if (opcodeIndex > numAbstractOpcodes) {
		error("Cog JIT internal error. Too many abstract opcodes.  Num opcodes heuristic is too optimistic.");
	}
	return result;
}

	/* StackToRegisterMappingCogit>>#compileBlockBodies */
static sqInt
compileBlockBodies(void)
{
    BlockStart *blockStart;
    sqInt compiledBlocksCount;
    sqInt initialCounterIndex;
    sqInt initialOpcodeIndex;
    sqInt initialStackPtr;
    sqInt (* const pushNilSizeFunction)(sqInt,sqInt) = v3PushNilSizenumInitialNils;
    sqInt result;
    sqInt savedFirstOpcodeIndex;
    sqInt savedLastDumpedLiteralIndex;
    unsigned char savedNeedsFrame;
    sqInt savedNextLiteralIndex;
    sqInt savedNumArgs;
    sqInt savedNumTemps;

	assert(blockCount > 0);
	savedNeedsFrame = needsFrame;
	savedNumArgs = methodOrBlockNumArgs;
	savedNumTemps = methodOrBlockNumTemps;
	inBlock = InVanillaBlock;
	compiledBlocksCount = 0;
	while (compiledBlocksCount < blockCount) {
		compilationPass = 1;
		blockStart = blockStartAt(compiledBlocksCount);
		if (((result = scanBlock(blockStart))) < 0) {
			return result;
		}
		initialOpcodeIndex = opcodeIndex;
		/* for SistaCogit */
		initialCounterIndex = 0 /* begin maybeCounterIndex */;
		/* begin saveForRecompile */
		savedFirstOpcodeIndex = firstOpcodeIndex;
		savedNextLiteralIndex = nextLiteralIndex;
		savedLastDumpedLiteralIndex = lastDumpedLiteralIndex;
		while (1) {
			compileBlockEntry(blockStart);
			initialStackPtr = simStackPtr;
			if (((result = compileAbstractInstructionsFromthrough(((blockStart->startpc)) + (pushNilSizeFunction(methodObj, ((blockStart->numInitialNils)))), (((blockStart->startpc)) + ((blockStart->span))) - 1))) < 0) {
				return result;
			}
			if (initialStackPtr == simStackPtr) break;
			assert((initialStackPtr > simStackPtr)
			 || (deadCode));
			/* for asserts */
			compilationPass += 1;
			(blockStart->numInitialNils = (((blockStart->numInitialNils)) + simStackPtr) - initialStackPtr);
			(((blockStart->fakeHeader))->dependent = null);
			reinitializeFixupsFromthrough(((blockStart->startpc)) + ((blockStart->numInitialNils)), (((blockStart->startpc)) + ((blockStart->span))) - 1);
			bzero(abstractOpcodes + initialOpcodeIndex,
									(opcodeIndex - initialOpcodeIndex) * sizeof(AbstractInstruction));
			opcodeIndex = initialOpcodeIndex;
			/* begin resetForRecompile */
			firstOpcodeIndex = savedFirstOpcodeIndex;
			nextLiteralIndex = savedNextLiteralIndex;
			lastDumpedLiteralIndex = savedLastDumpedLiteralIndex;
		}
		compiledBlocksCount += 1;
	}
	needsFrame = savedNeedsFrame;
	methodOrBlockNumArgs = savedNumArgs;
	methodOrBlockNumTemps = savedNumTemps;
	return 0;
}


/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. closure (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	Avoid use of SendNumArgsReg which is the flag determining whether
	context switch is allowed on stack-overflow. */
/*	Build a frame for a block activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any, and to correctly
	initialize the explicitly nilled/pushed temp entries (they are /not/ of
	type constant nil). */

	/* StackToRegisterMappingCogit>>#compileBlockFrameBuild: */
static NoDbgRegParms void
compileBlockFrameBuild(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *cascade0;
    sqInt i;
    sqInt ign;

	abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);
	/* begin PushR: */
	genoperand(PushR, LinkReg);
	genoperand(PushR, FPReg);
	genoperandoperand(MoveRR, SPReg, FPReg);
	genoperandoperand(MoveRR, ReceiverResultReg, ClassReg);
	cascade0 = (blockStart->fakeHeader);
	addDependent(cascade0, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)((blockStart->fakeHeader))), genoperand(PushCw, ((sqInt)((blockStart->fakeHeader)))))));
	/* begin setLabelOffset: */
	((cascade0->operands))[1] = MFMethodFlagIsBlockFlag;
		/* begin PushCq: */
	anInstruction = genoperand(PushCq, nilObject());
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(nilObject()));
	}
	if ((blockStart->hasInstVarRef)) {
		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		/* begin genEnsureOopInRegNotForwarded:scratchReg:updatingSlot:in: */
		assert(0);
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ClassReg, Arg0Reg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, Arg0Reg, ReceiverResultReg);
	}
	/* begin PushR: */
	genoperand(PushR, ReceiverResultReg);
	for (i = 0; i < ((blockStart->numCopied)); i += 1) {
		genLoadSlotsourceRegdestReg(i + ClosureFirstCopiedValueIndex, ClassReg, TempReg);
		/* begin PushR: */
		genoperand(PushR, TempReg);
	}
	(blockStart->stackCheckLabel = compileStackOverflowCheck(1));
	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramefulMethod((blockStart->startpc));
	if (((blockStart->numInitialNils)) > 0) {
		if (((blockStart->numInitialNils)) > 1) {
			/* begin genMoveConstant:R: */
						/* begin MoveCq:R: */
			anInstruction2 = genoperandoperand(MoveCqR, nilObject(), TempReg);
			if (usesOutOfLineLiteral(anInstruction2)) {
				(anInstruction2->dependent = locateLiteral(nilObject()));
			}
			for (ign = 1; ign <= ((blockStart->numInitialNils)); ign += 1) {
				/* begin PushR: */
				genoperand(PushR, TempReg);
			}
		}
		else {
			/* begin genPushConstant: */
						/* begin PushCq: */
			anInstruction1 = genoperand(PushCq, nilObject());
			if (usesOutOfLineLiteral(anInstruction1)) {
				(anInstruction1->dependent = locateLiteral(nilObject()));
			}
		}
	}
}


/*	Make sure ReceiverResultReg holds the receiver, loaded from the closure,
	which is what is initially in ReceiverResultReg. We must annotate the
	first instruction in vanilla blocks so that
	findMethodForStartBcpc:inHomeMethod: can function. We need two annotations
	because the first is a fiducial. */
/*	Make sure ReceiverResultReg holds the receiver, loaded from
	the closure, which is what is initially in ReceiverResultReg */

	/* StackToRegisterMappingCogit>>#compileBlockFramelessEntry: */
static NoDbgRegParms void
compileBlockFramelessEntry(BlockStart *blockStart)
{
    AbstractInstruction *abstractInstruction;

	methodOrBlockNumTemps = (((blockStart->numArgs)) + ((blockStart->numCopied))) + ((blockStart->numInitialNils));
	initSimStackForFramelessBlock((blockStart->startpc));
	if (!(((blockStart->entryLabel)) == null)) {
		abstractInstruction = (blockStart->entryLabel);
		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
	}
	if ((blockStart->hasInstVarRef)) {
		/* Use ReceiverResultReg for Context to agree with store check trampoline */
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ReceiverResultReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, ReceiverResultReg, Arg0Reg);
		/* begin genEnsureOopInRegNotForwarded:scratchReg:updatingSlot:in: */
		assert(0);
		genoperandoperand(MoveRR, Arg0Reg, ReceiverResultReg);
	}
	else {
		genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, TempReg);
		genLoadSlotsourceRegdestReg(ReceiverIndex, TempReg, ReceiverResultReg);
	}
}

	/* StackToRegisterMappingCogit>>#compileCogMethod: */
static NoDbgRegParms CogMethod *
compileCogMethod(sqInt selector)
{
    sqInt allocBytes;
    int extra;
    sqInt fixupBytes;
    sqInt numBlocks;
    sqInt numBytecodes;
    sqInt numCleanBlocks;
    sqInt opcodeBytes;
    sqInt result;

	methodOrBlockNumTemps = tempCountOf(methodObj);
	setHasMovableLiteral(0);
	setHasYoungReferent((isYoungObject(methodObj))
	 || (isYoung(selector)));
	methodOrBlockNumArgs = argumentCountOf(methodObj);
	inBlock = 0;
	maxLitIndex = -1;
	extra = ((((primitiveIndex = primitiveIndexOf(methodObj))) > 0)
	 && (!(isQuickPrimitiveIndex(primitiveIndex)))
		? 30
		: 10);
	/* initial estimate.  Actual endPC is determined in scanMethod. */
	initialPC = startPCOfMethod(methodObj);
	endPC = (isQuickPrimitiveIndex(primitiveIndex)
		? initialPC - 1
		: numBytesOf(methodObj));
	numBytecodes = (endPC - initialPC) + 1;
	/* begin allocateOpcodes:bytecodes:ifFail: */
	numAbstractOpcodes = (numBytecodes + extra) * 10 /* begin estimateOfAbstractOpcodesPerBytecodes */;
	opcodeBytes = (sizeof(CogAbstractInstruction)) * numAbstractOpcodes;
	fixupBytes = (sizeof(CogBytecodeFixup)) * numAbstractOpcodes;
	/* Document the fact that the MaxStackAllocSize ensures that the number of abstract
	   opcodes fits in a 16 bit integer (e.g. CogBytecodeFixup's instructionIndex). */
	allocBytes = opcodeBytes + fixupBytes;
	assert((((sizeof(CogAbstractInstruction)) + (sizeof(CogBytecodeFixup))) * 0xC000) > MaxStackAllocSize);
	if (allocBytes > MaxStackAllocSize) {
		return ((CogMethod *) MethodTooBig);
		goto l1;
	}
	abstractOpcodes = alloca(allocBytes);
	bzero(abstractOpcodes, allocBytes);
	fixups = ((void *)((((usqInt)abstractOpcodes)) + opcodeBytes));
	/* begin zeroOpcodeIndexForNewOpcodes */
	opcodeIndex = 0;
	/* an impossibly high value */
	firstOpcodeIndex = 0x10000;
	nextLiteralIndex = (lastDumpedLiteralIndex = 0);
	labelCounter = 0;
	l1:	/* end allocateOpcodes:bytecodes:ifFail: */;
	if (((numBlocks = scanMethod())) < 0) {
		return ((CogMethod *) numBlocks);
	}
	numCleanBlocks = scanForCleanBlocks();
	if (methodFoundInvalidPostScan()) {
		return ((CogMethod *) ShouldNotJIT);
	}
	allocateBlockStarts(numBlocks + numCleanBlocks);
	blockCount = 0;
	if (numCleanBlocks > 0) {
		addCleanBlockStarts();
	}
	blockEntryLabel = null;
	(methodLabel->dependent = null);
	if (((result = compileEntireMethod())) < 0) {
		return ((CogMethod *) result);
	}
	return generateCogMethod(selector);
}


/*	Compile the abstract instructions for the entire method, including blocks. */
/*	Compile the abstract instructions for the entire method, including blocks. */

	/* StackToRegisterMappingCogit>>#compileEntireMethod */
static sqInt
compileEntireMethod(void)
{
    sqInt result;

	regArgsHaveBeenPushed = 0;
	/* begin preenMethodLabel */
	((methodLabel->operands))[1] = 0;
	compileAbort();
	compileEntry();
	if (((result = compilePrimitive())) < 0) {
		return result;
	}
	compileFrameBuild();
	if (((result = compileMethodBody())) < 0) {
		return result;
	}
	if (blockCount == 0) {
		return 0;
	}
	if (((result = compileBlockBodies())) < 0) {
		return result;
	}
	return compileBlockDispatch();
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. Override to push the register receiver and
	register arguments, if any. */

	/* StackToRegisterMappingCogit>>#compileFrameBuild */
static void
compileFrameBuild(void)
{
    AbstractInstruction *anInstruction;
    sqInt i;
    sqInt iLimiT;


#  if IMMUTABILITY
	if (useTwoPaths) {
		compileTwoPathFrameBuild();
		return;
	}
#  endif

	if (!needsFrame) {
		if (useTwoPaths) {
			compileTwoPathFramelessInit();
		}
		initSimStackForFramelessMethod(initialPC);
		return;
	}
	assert(!(useTwoPaths));
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}
	/* begin PushR: */
	genoperand(PushR, LinkReg);
	genoperand(PushR, FPReg);
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));
	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(nilObject()));
	}
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	genoperand(PushR, ReceiverResultReg);
	for (i = (methodOrBlockNumArgs + 1), iLimiT = (temporaryCountOfMethodHeader(methodHeader)); i <= iLimiT; i += 1) {
		/* begin PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (	/* begin methodUsesPrimitiveErrorCode:header: */
		((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	stackCheckLabel = compileStackOverflowCheck(canContextSwitchIfActivatingheader(methodObj, methodHeader));
	initSimStackForFramefulMethod(initialPC);
}


/*	Build a frame for a CogMethod activation. See CoInterpreter
	class>>initializeFrameIndices. receiver (in ReceiverResultReg)
	arg0
	...
	argN
	caller's saved ip/this stackPage (for a base frame)
	fp->	saved fp
	method
	context (uninitialized?)
	receiver
	first temp
	...
	sp->	Nth temp
	If there is a primitive and an error code the Nth temp is the error code.
	Ensure SendNumArgsReg is set early on (incidentally to nilObj) because
	it is the flag determining whether context switch is allowed on
	stack-overflow.  */
/*	We are in a method where the frame is needed *only* for instance variable
	store, typically a setter method.
	This case has 20% overhead with Immutability compared to setter without
	immutability because of the stack
	frame creation. We compile two path, one where the object is immutable,
	one where it isn't. At the beginning 
	of the frame build, we take one path or the other depending on the
	receiver mutability.
	
	Note: this specific case happens only where there are only instance
	variabel stores. We could do something
	similar for literal variable stores, but we don't as it's too uncommon.
 */

	/* StackToRegisterMappingCogit>>#compileTwoPathFrameBuild */
#if IMMUTABILITY
static void
compileTwoPathFrameBuild(void)
{
    AbstractInstruction *anInstruction;
    sqInt i;
    sqInt iLimiT;
    sqInt jumpImmutable;
    AbstractInstruction *jumpOld;

	assert(useTwoPaths);
	assert(blockCount == 0);
	jumpImmutable = genJumpImmutablescratchReg(ReceiverResultReg, TempReg);
	/* begin genJumpInOldSpace: */
	checkLiteralforInstruction(youngStartAddress(), genoperandoperand(MoveAwR, youngStartAddress(), TempReg));
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, ReceiverResultReg);
	jumpOld = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	assert(!needsFrame);
	initSimStackForFramelessMethod(initialPC);
	/* begin compileMethodBody */
	if (endPC < initialPC) {
		goto l2;
	}
	compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
	l2:	/* end compileMethodBody */;
	/* reset because it impacts inst var store compilation */
	useTwoPaths = 0;
	needsFrame = 1;
	jmpTarget(jumpOld, jmpTarget(jumpImmutable, genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	genPushRegisterArgs();
	if (!needsFrame) {
		return;
	}
	/* begin PushR: */
	genoperand(PushR, LinkReg);
	genoperand(PushR, FPReg);
	genoperandoperand(MoveRR, SPReg, FPReg);
	addDependent(methodLabel, annotateAbsolutePCRef(checkLiteralforInstruction(((sqInt)methodLabel), genoperand(PushCw, ((sqInt)methodLabel)))));
	/* begin genMoveConstant:R: */
		/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, nilObject(), SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(nilObject()));
	}
	/* begin PushR: */
	genoperand(PushR, SendNumArgsReg);
	genoperand(PushR, ReceiverResultReg);
	for (i = (methodOrBlockNumArgs + 1), iLimiT = (temporaryCountOfMethodHeader(methodHeader)); i <= iLimiT; i += 1) {
		/* begin PushR: */
		genoperand(PushR, SendNumArgsReg);
	}
	if (	/* begin methodUsesPrimitiveErrorCode:header: */
		((primitiveIndexOfMethodheader(methodObj, methodHeader)) > 0)
	 && ((longStoreBytecodeForHeader(methodHeader)) == (fetchByteofObject((startPCOfMethodHeader(methodHeader)) + (sizeOfCallPrimitiveBytecode(methodHeader)), methodObj)))) {
		compileGetErrorCode();
	}
	stackCheckLabel = compileStackOverflowCheck(canContextSwitchIfActivatingheader(methodObj, methodHeader));
	initSimStackForFramefulMethod(initialPC);
}
#endif /* IMMUTABILITY */


/*	We are in a frameless method with at least two inst var stores. We compile
	two paths,
	one where the object is in new space, and one where it isn't. At the
	beginning 
	of the method, we take one path or the other depending on the receiver
	being in newSpace.
 */

	/* StackToRegisterMappingCogit>>#compileTwoPathFramelessInit */
static void
compileTwoPathFramelessInit(void)
{
    AbstractInstruction *jumpOld;

	assert(!(IMMUTABILITY));
	assert(!(needsFrame));
	assert(useTwoPaths);
	/* begin genJumpInOldSpace: */
	checkLiteralforInstruction(youngStartAddress(), genoperandoperand(MoveAwR, youngStartAddress(), TempReg));
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, ReceiverResultReg);
	jumpOld = genConditionalBranchoperand(JumpBelow, ((sqInt)0));
	initSimStackForFramelessMethod(initialPC);
	/* begin compileMethodBody */
	if (endPC < initialPC) {
		goto l2;
	}
	compileAbstractInstructionsFromthrough(initialPC + (deltaToSkipPrimAndErrorStoreInheader(methodObj, methodHeader)), endPC);
	l2:	/* end compileMethodBody */;
	/* reset because it impacts inst var store compilation */
	useTwoPaths = 0;
	jmpTarget(jumpOld, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
}

	/* StackToRegisterMappingCogit>>#cPICMissTrampolineFor: */
static NoDbgRegParms sqInt
cPICMissTrampolineFor(sqInt numArgs)
{
	return picMissTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}


/*	Replaces the Blue Book double-extended send [132], in which the first byte
	was wasted on 8 bits of argument count. 
	Here we use 3 bits for the operation sub-type (opType), and the remaining
	5 bits for argument count where needed. 
	The last byte give access to 256 instVars or literals. 
	See also secondExtendedSendBytecode
 */

	/* StackToRegisterMappingCogit>>#doubleExtendedDoAnythingBytecode */
static sqInt
doubleExtendedDoAnythingBytecode(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *abstractInstruction2;
    sqInt opType;

	opType = ((usqInt)(byte1)) >> 5;
	if (opType == 0) {
		return genSendnumArgs(byte2, byte1 & 0x1F);
	}
	if (opType == 1) {
		return genSendSupernumArgs(byte2, byte1 & 0x1F);
	}
	switch (opType) {
	case 2:
		if (isReadMediatedContextInstVarIndex(byte2)) {
			genPushMaybeContextReceiverVariable(byte2);
		}
		else {
			genPushReceiverVariable(byte2);
			/* begin annotateInstructionForBytecode */
			abstractInstruction = (prevInstIsPCAnnotated()
				? gen(Nop)
				: genoperandoperand(Label, (labelCounter += 1), bytecodePC));
			/* begin annotateBytecode: */
			(abstractInstruction->annotation = HasBytecodePC);
			return 0;
		}
		break;
	case 3:
		genPushLiteralIndex(byte2);
		/* begin annotateInstructionForBytecode */
		abstractInstruction1 = (prevInstIsPCAnnotated()
			? gen(Nop)
			: genoperandoperand(Label, (labelCounter += 1), bytecodePC));
		/* begin annotateBytecode: */
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;

	case 4:
		genPushLiteralVariable(byte2);
		break;
	case 7:
		/* begin genStorePop:LiteralVariable: */
		genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(0, byte2, ((((ssTop())->type)) != SSConstant)
		 || ((isNonImmediate(((ssTop())->constant)))
		 && (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
#    if IMMUTABILITY
		/* genStorePop:LiteralVariable: annotates; don't annotate twice */
		return 0;
#    endif


	default:
		/* 5 & 6 */
		if (isWriteMediatedContextInstVarIndex(byte2)) {
			/* begin genStorePop:MaybeContextReceiverVariable: */
			genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(opType == 6, byte2, ((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (			/* begin shouldAnnotateObjectReference: */
				(isNonIntegerObject(((ssTop())->constant)))
			 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
		}
		else {
			/* begin genStorePop:ReceiverVariable: */
			genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(opType == 6, byte2, ((((ssTop())->type)) != SSConstant)
			 || ((isNonImmediate(((ssTop())->constant)))
			 && (			/* begin shouldAnnotateObjectReference: */
				(isNonIntegerObject(((ssTop())->constant)))
			 && (oopisGreaterThan(((ssTop())->constant), trueObject())))), 1);
		}
#    if IMMUTABILITY
		/* genStorePop:...ReceiverVariable: annotate; don't annotate twice */
		return 0;
#    endif

;
	}
	assert(needsFrame);
	assert(!(prevInstIsPCAnnotated()));
	abstractInstruction2 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin annotateBytecode: */
	(abstractInstruction2->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#duplicateTopBytecode */
static sqInt
duplicateTopBytecode(void)
{
    SimStackEntry desc;


	/* begin ssTopDescriptor */
	desc = simStack[simStackPtr];
	return ssPushDesc(desc);
}


/*	Make sure there's a flagged fixup at the target pc in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureFixupAt: */
static NoDbgRegParms BytecodeFixup *
ensureFixupAt(sqInt targetPC)
{
    BytecodeFixup *fixup;


	/* begin fixupAt: */
	fixup = fixupAtIndex(targetPC - initialPC);
	traceFixupmerge(fixup, 1);
	if ((((usqInt)((fixup->targetInstruction)))) <= NeedsNonMergeFixupFlag) {
		/* convert a non-merge into a merge */
		/* begin becomeMergeFixup */
		(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
		(fixup->simStackPtr = simStackPtr);
	}
	else {
		if ((fixup->isTargetOfBackwardBranch)) {
			/* this is the target of a backward branch and
			   so doesn't have a simStackPtr assigned yet. */
			(fixup->simStackPtr = simStackPtr);
		}
		else {
			assert(((fixup->simStackPtr)) == simStackPtr);
		}
	}
	return fixup;
}


/*	Make sure there's a flagged fixup at the target pc in fixups.
	Initially a fixup's target is just a flag. Later on it is replaced with a
	proper instruction. */

	/* StackToRegisterMappingCogit>>#ensureNonMergeFixupAt: */
static NoDbgRegParms BytecodeFixup *
ensureNonMergeFixupAt(sqInt targetPC)
{
    BytecodeFixup *fixup;


	/* begin fixupAt: */
	fixup = fixupAtIndex(targetPC - initialPC);
	traceFixupmerge(fixup, 1);
	if (((fixup->targetInstruction)) == 0) {
		/* begin becomeNonMergeFixup */
		(fixup->targetInstruction) = ((AbstractInstruction *) NeedsNonMergeFixupFlag);
	}
	return fixup;
}

	/* StackToRegisterMappingCogit>>#ensureReceiverResultRegContainsSelf */
static void
ensureReceiverResultRegContainsSelf(void)
{
	if (needsFrame) {
		if (!((((simSelf())->liveRegister)) == ReceiverResultReg)) {
			/* begin ssAllocateRequiredReg: */
			ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
			storeToReg(simSelf(), ReceiverResultReg);
			((simSelf())->liveRegister = ReceiverResultReg);
		}
	}
	else {
		assert(((((simSelf())->type)) == SSRegister)
		 && (((((simSelf())->registerr)) == ReceiverResultReg)
		 && (receiverIsInReceiverResultReg())));
	}
}

	/* StackToRegisterMappingCogit>>#evaluate:at: */
static NoDbgRegParms void
evaluateat(BytecodeDescriptor *descriptor, sqInt pc)
{
	byte0 = fetchByteofObject(pc, methodObj);
	assert(descriptor == (generatorAt(bytecodeSetOffset + byte0)));
	loadSubsequentBytesForDescriptorat(descriptor, pc);
	((descriptor->generator))();
}


/*	Attempt to follow a branch to a pc. Handle branches to unconditional jumps
	and branches to push: aBoolean; conditional branch pairs. If the branch
	cannot be
	followed answer targetBytecodePC. It is not possible to follow jumps to
	conditional branches because the stack changes depth. That following is
	left to the genJumpIf:to:
	clients. */

	/* StackToRegisterMappingCogit>>#eventualTargetOf: */
static NoDbgRegParms sqInt
eventualTargetOf(sqInt targetBytecodePC)
{
    sqInt cond;
    sqInt currentTarget;
    BytecodeDescriptor *descriptor;
    sqInt nExts;
    sqInt nextPC;
    BytecodeFixup *self_in_CogSSBytecodeFixup;
    sqInt span;

	cond = 0;
	nextPC = (currentTarget = targetBytecodePC);
	while (1) {
		nExts = 0;
		while (1) {
			/* begin generatorForPC: */
			descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC, methodObj)));
			if ((descriptor->isReturn)) {
				return currentTarget;
			}
			if (!((descriptor->isExtension))) break;
			nExts += 1;
			nextPC += (descriptor->numBytes);
		}
		if (		/* begin isUnconditionalBranch */
			(isBranch(descriptor))
		 && (!(((descriptor->isBranchTrue))
		 || ((descriptor->isBranchFalse))))) {
			span = ((descriptor->spanFunction))(descriptor, nextPC, nExts, methodObj);
			if (span < 0) {
				/* Do *not* follow backward branches; these are interrupt points and should not be elided. */
				return currentTarget;
			}
			nextPC = (nextPC + ((descriptor->numBytes))) + span;
		}
		else {
			if (((descriptor->generator)) == genPushConstantTrueBytecode) {
				cond = 1;
			}
			else {
				if (((descriptor->generator)) == genPushConstantFalseBytecode) {
					cond = 0;
				}
				else {
					return currentTarget;
				}
			}
			/* begin fixupAt: */
			self_in_CogSSBytecodeFixup = fixupAtIndex(nextPC - initialPC);
			if ((self_in_CogSSBytecodeFixup->isTargetOfBackwardBranch)) {
				return currentTarget;
			}
			else {
				goto l2;
			}
	l2:;
			nextPC = eventualTargetOf(nextPC + ((descriptor->numBytes)));
			nExts = 0;
			while (1) {
				/* begin generatorForPC: */
				descriptor = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC, methodObj)));
				if ((descriptor->isReturn)) {
					return currentTarget;
				}
				if (!((descriptor->isExtension))) break;
				nExts += 1;
				nextPC += (descriptor->numBytes);
			}
			if (!(isBranch(descriptor))) {
				return currentTarget;
			}
			if (			/* begin isUnconditionalBranch */
				(isBranch(descriptor))
			 && (!(((descriptor->isBranchTrue))
			 || ((descriptor->isBranchFalse))))) {
				return currentTarget;
			}
			nextPC = (cond == ((descriptor->isBranchTrue))
				? (nextPC + ((descriptor->numBytes))) + (((descriptor->spanFunction))(descriptor, nextPC, nExts, methodObj))
				: nextPC + ((descriptor->numBytes)));
		}
		currentTarget = nextPC;
	}
	return 0;
}


/*	Spill the closest register on stack not conflicting with regMask. 
	Assertion Failure if regMask has already all the registers */

	/* StackToRegisterMappingCogit>>#freeAnyRegNotConflictingWith: */
static NoDbgRegParms sqInt
freeAnyRegNotConflictingWith(sqInt regMask)
{
    CogSimStackEntry *desc;
    sqInt index;
    sqInt reg;

	assert(needsFrame);
	reg = NoReg;
	index = ((simSpillBase < 0) ? 0 : simSpillBase);
	while ((reg == NoReg)
	 && (index < simStackPtr)) {
		desc = simStackAt(index);
		if (((desc->type)) == SSRegister) {
			if (!(((regMask & (((((desc->registerr)) < 0) ? (((usqInt)(1)) >> (-((desc->registerr)))) : (1U << ((desc->registerr)))))) != 0))) {
				reg = (desc->registerr);
			}
		}
		index += 1;
	}
	assert(!((reg == NoReg)));
	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1U << reg)), simStackPtr, simNativeStackPtr);
	return reg;
}


/*	Return from block, assuming result already loaded into ReceiverResultReg. */
/*	Return from block, assuming result already loaded into ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#genBlockReturn */
static sqInt
genBlockReturn(void)
{
	if (needsFrame) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);
		genoperand(PopR, FPReg);
		genoperand(PopR, LinkReg);
	}
	genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	/* can't fall through */
	deadCode = 1;
	return 0;
}


/*	Generate special versions of the ceCallCogCodePopReceiverAndClassRegs
	enilopmart that also pop register args from the stack to undo the pushing
	of register args in the abort/miss trampolines. */

	/* StackToRegisterMappingCogit>>#genCallPICEnilopmartNumArgs: */
static NoDbgRegParms void
(*genCallPICEnilopmartNumArgs(sqInt numArgs))(void)
{
    AbstractInstruction *anInstruction;
    sqInt endAddress;
    usqInt enilopmart;
    sqInt quickConstant;
    sqInt size;

	zeroOpcodeIndex();
	/* begin MoveCq:R: */
	quickConstant = varBaseAddress();
	/* begin gen:quickConstant:operand: */
	anInstruction = genoperandoperand(MoveCqR, quickConstant, VarBaseReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(quickConstant));
	}
	genLoadStackPointers(backEnd);
	/* begin PopR: */
	genoperand(PopR, ClassReg);
	genoperand(PopR, TempReg);
	genoperand(PopR, LinkReg);
	if (numArgs > 0) {
		if (numArgs > 1) {
			/* begin PopR: */
			genoperand(PopR, Arg1Reg);
			assert((numRegArgs()) == 2);
		}
		/* begin PopR: */
		genoperand(PopR, Arg0Reg);
	}
	genoperand(PopR, ReceiverResultReg);
	/* begin JumpR: */
	genoperand(JumpR, TempReg);
	computeMaximumSizes();
	size = generateInstructionsAt(methodZoneBase);
	endAddress = outputInstructionsAt(methodZoneBase);
	assert((methodZoneBase + size) == endAddress);
	enilopmart = methodZoneBase;
	methodZoneBase = alignUptoRoutineBoundary(endAddress);
	stopsFromto(backEnd, endAddress, methodZoneBase - 1);
	recordGeneratedRunTimeaddress(trampolineNamenumRegArgs("ceCallPIC", numArgs), enilopmart);
	return ((void (*)(void)) enilopmart);
}


/*	Override to push the register receiver and register arguments, if any. */

	/* StackToRegisterMappingCogit>>#genExternalizePointersForPrimitiveCall */
static sqInt
genExternalizePointersForPrimitiveCall(void)
{
	genPushRegisterArgs();
	/* begin gen:operand:literal: */
	checkLiteralforInstruction(instructionPointerAddress(), genoperandoperand(MoveRAw, LinkReg, instructionPointerAddress()));
	return genSaveStackPointers(backEnd);
}


/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). 
 */
/*	Enilopmarts transfer control from C into machine code (backwards
	trampolines). Override to add version for generic and PIC-specific entry
	with reg args. */

	/* StackToRegisterMappingCogit>>#generateEnilopmarts */
static void
generateEnilopmarts(void)
{

#  if Debug
	/* begin genEnilopmartFor:forCall:called: */
	realCEEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "realCEEnterCogCodePopReceiverReg");
	ceEnterCogCodePopReceiverReg = enterCogCodePopReceiver;
	/* begin genEnilopmartFor:forCall:called: */
	realCECallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "realCECallCogCodePopReceiverReg");
	ceCallCogCodePopReceiverReg = callCogCodePopReceiver;
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "realCECallCogCodePopReceiverAndClassRegs");
	ceCallCogCodePopReceiverAndClassRegs = callCogCodePopReceiverAndClassRegs;
#  else // Debug
	/* begin genEnilopmartFor:forCall:called: */
	ceEnterCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 0, "ceEnterCogCodePopReceiverReg");
	ceCallCogCodePopReceiverReg = genEnilopmartForandandforCallcalled(ReceiverResultReg, NoReg, NoReg, 1, "ceCallCogCodePopReceiverReg");
	ceCallCogCodePopReceiverAndClassRegs = genEnilopmartForandandforCallcalled(ReceiverResultReg, ClassReg, NoReg, 1, "ceCallCogCodePopReceiverAndClassRegs");
#  endif // Debug

	genPrimReturnEnterCogCodeEnilopmart(0);
	cePrimReturnEnterCogCode = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCode);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCode", cePrimReturnEnterCogCode);
	genPrimReturnEnterCogCodeEnilopmart(1);
	cePrimReturnEnterCogCodeProfiling = methodZoneBase;
	outputInstructionsForGeneratedRuntimeAt(cePrimReturnEnterCogCodeProfiling);
	recordGeneratedRunTimeaddress("cePrimReturnEnterCogCodeProfiling", cePrimReturnEnterCogCodeProfiling);
#  if Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	realCECallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "realCECallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg0Regs = callCogCodePopReceiverArg0Regs;
	realCECallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "realCECallCogCodePopReceiverArg1Arg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = callCogCodePopReceiverArg1Arg0Regs;
#  else // Debug
	/* begin genEnilopmartFor:and:forCall:called: */
	ceCallCogCodePopReceiverArg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, NoReg, 1, "ceCallCogCodePopReceiverArg0Regs");
	ceCallCogCodePopReceiverArg1Arg0Regs = genEnilopmartForandandforCallcalled(ReceiverResultReg, Arg0Reg, Arg1Reg, 1, "ceCallCogCodePopReceiverArg1Arg0Regs");
#  endif // Debug

	ceCall0ArgsPIC = genCallPICEnilopmartNumArgs(0);
		ceCall1ArgsPIC = genCallPICEnilopmartNumArgs(1);
}


/*	Size pc-dependent instructions and assign eventual addresses to all
	instructions. Answer the size of the code.
	Compute forward branches based on virtual address (abstract code starts at
	0), assuming that any branches branched over are long.
	Compute backward branches based on actual address.
	Reuse the fixups array to record the pc-dependent instructions that need
	to have
	their code generation postponed until after the others.
	
	Override to add handling for null branches (branches to the immediately
	following instruction) occasioned by StackToRegisterMapping's following of
	jumps.  */

	/* StackToRegisterMappingCogit>>#generateInstructionsAt: */
static NoDbgRegParms sqInt
generateInstructionsAt(sqInt eventualAbsoluteAddress)
{
    sqInt absoluteAddress;
    AbstractInstruction *abstractInstruction;
    BytecodeFixup *fixup;
    sqInt i;
    sqInt j;
    sqInt pcDependentIndex;

	absoluteAddress = eventualAbsoluteAddress;
	pcDependentIndex = 0;
	for (i = 0; i < opcodeIndex; i += 1) {
		/* N.B. if you want to break in resizing, break here, note the instruction index, back up to the
		   sender, restart, and step into computeMaximumSizes, breaking at this instruction's index. */
		abstractInstruction = abstractInstructionAt(i);
		maybeBreakGeneratingFromto(absoluteAddress, absoluteAddress + ((abstractInstruction->maxSize)));
		if (isPCDependent(abstractInstruction)) {
			sizePCDependentInstructionAt(abstractInstruction, absoluteAddress);
			if ((isJump(abstractInstruction))
			 && ((((i + 1) < opcodeIndex)
			 && ((((AbstractInstruction *) (((abstractInstruction->operands))[0]))) == (abstractInstructionAt(i + 1))))
			 || (((i + 2) < opcodeIndex)
			 && (((((AbstractInstruction *) (((abstractInstruction->operands))[0]))) == (abstractInstructionAt(i + 2)))
			 && ((((abstractInstructionAt(i + 1))->opcode)) == Nop))))) {
				(abstractInstruction->opcode = Nop);
				concretizeAt(abstractInstruction, absoluteAddress);
			}
			else {
				fixup = fixupAtIndex(pcDependentIndex);
				pcDependentIndex += 1;
				(fixup->instructionIndex = i);
			}
			absoluteAddress += (abstractInstruction->machineCodeSize);
		}
		else {
			/* N.B. if you want to break in resizing, break here, note the instruction index, back up to the
			   sender, restart, and step into computeMaximumSizes, breaking at this instruction's index. */
			absoluteAddress = concretizeAt(abstractInstruction, absoluteAddress);
			assert(((abstractInstruction->machineCodeSize)) == ((abstractInstruction->maxSize)));
		}
	}
	for (j = 0; j < pcDependentIndex; j += 1) {
		fixup = fixupAtIndex(j);
		abstractInstruction = abstractInstructionAt((fixup->instructionIndex));
		maybeBreakGeneratingFromto((abstractInstruction->address), (((abstractInstruction->address)) + ((abstractInstruction->maxSize))) - 1);
		concretizeAt(abstractInstruction, (abstractInstruction->address));
	}
	return absoluteAddress - eventualAbsoluteAddress;
}


/*	Generate the run-time entries for the various method and PIC entry misses
	and aborts.
	Read the class-side method trampolines for documentation on the various
	trampolines 
 */

	/* StackToRegisterMappingCogit>>#generateMissAbortTrampolines */
static void
generateMissAbortTrampolines(void)
{
    sqInt numArgs;
    sqInt numArgsLimiT;

	for (numArgs = 0, numArgsLimiT = ((numRegArgs()) + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		methodAbortTrampolines[numArgs] = (genMethodAbortTrampolineFor(numArgs));
	}
	for (numArgs = 0, numArgsLimiT = ((numRegArgs()) + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		picAbortTrampolines[numArgs] = (genPICAbortTrampolineFor(numArgs));
	}
	for (numArgs = 0, numArgsLimiT = ((numRegArgs()) + 1); numArgs <= numArgsLimiT; numArgs += 1) {
		picMissTrampolines[numArgs] = (genPICMissTrampolineFor(numArgs));
	}
	ceReapAndResetErrorCodeTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceReapAndResetErrorCodeFor, "ceReapAndResetErrorCodeTrampoline", 1, ClassReg, null, null, null, 0 /* begin emptyRegisterMask */, 1, NoReg, 0);
}


/*	Override to generate code to push the register arg(s) for <= numRegArg
	arity sends.
 */

	/* StackToRegisterMappingCogit>>#generateSendTrampolines */
static void
generateSendTrampolines(void)
{
    sqInt numArgs;

	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		ordinarySendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(
	ceSendsupertonumArgs,
	numArgs,
	trampolineNamenumArgs("ceSend", numArgs),
	ClassReg,
	(	/* begin trampolineArgConstant: */
		assert(0 >= 0),
	-2 - 0),
	ReceiverResultReg,
	/* begin numArgsOrSendNumArgsReg: */
(numArgs <= (NumSendTrampolines - 2)
		? (assert(numArgs >= 0),
			-2 - numArgs)
		: SendNumArgsReg)));
	}
	for (numArgs = 0; numArgs < NumSendTrampolines; numArgs += 1) {
		superSendTrampolines[numArgs] = (genSendTrampolineFornumArgscalledargargargarg(
	ceSendsupertonumArgs,
	numArgs,
	trampolineNamenumArgs("ceSuperSend", numArgs),
	ClassReg,
	(	/* begin trampolineArgConstant: */
		assert(1 >= 0),
	-2 - 1),
	ReceiverResultReg,
	/* begin numArgsOrSendNumArgsReg: */
(numArgs <= (NumSendTrampolines - 2)
		? (assert(numArgs >= 0),
			-2 - numArgs)
		: SendNumArgsReg)));
	}
	firstSend = ordinarySendTrampolines[0];
	lastSend = superSendTrampolines[NumSendTrampolines - 1];
}


/*	Generate trampolines for tracing. In the simulator we can save a lot of
	time and avoid noise instructions in the lastNInstructions log by
	short-cutting these
	trampolines, but we need them in the real vm. */

	/* StackToRegisterMappingCogit>>#generateTracingTrampolines */
static void
generateTracingTrampolines(void)
{
	ceTraceLinkedSendTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceLinkedSend, "ceTraceLinkedSendTrampoline", 1, ReceiverResultReg, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	ceTraceBlockActivationTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceBlockActivation, "ceTraceBlockActivationTrampoline", 0, null, null, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
	ceTraceStoreTrampoline = genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceTraceStoreOfinto, "ceTraceStoreTrampoline", 2, TempReg, ReceiverResultReg, null, null, CallerSavedRegisterMask, 1, NoReg, 0);
}


/*	Generates the machine code for #== in the case where the instruction is
	not followed by a branch
 */

	/* StackToRegisterMappingCogit>>#genIdenticalNoBranchArgIsConstant:rcvrIsConstant:argReg:rcvrReg:orNotIf: */
static NoDbgRegParms sqInt
genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(sqInt argIsConstant, sqInt rcvrIsConstant, sqInt argReg, sqInt rcvrRegOrNone, sqInt orNot)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *jumpEqual;
    AbstractInstruction *jumpNotEqual;
    AbstractInstruction *label;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt resultReg;

	label = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrRegOrNone != NoReg));
	if (argIsConstant) {
		/* begin genCmpConstant:R: */
		if (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject()))) {
			annotateobjRef(checkLiteralforInstruction(((ssTop())->constant), genoperandoperand(CmpCwR, ((ssTop())->constant), rcvrRegOrNone)), ((ssTop())->constant));
		}
		else {
			/* begin CmpCq:R: */
			quickConstant = ((ssTop())->constant);
			/* begin gen:quickConstant:operand: */
			anInstruction = genoperandoperand(CmpCqR, quickConstant, rcvrRegOrNone);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteral(quickConstant));
			}
		}
	}
	else {
		if (rcvrIsConstant) {
			/* begin genCmpConstant:R: */
			if (			/* begin shouldAnnotateObjectReference: */
				(isNonIntegerObject(((ssValue(1))->constant)))
			 && (oopisGreaterThan(((ssValue(1))->constant), trueObject()))) {
				annotateobjRef(checkLiteralforInstruction(((ssValue(1))->constant), genoperandoperand(CmpCwR, ((ssValue(1))->constant), argReg)), ((ssValue(1))->constant));
			}
			else {
				/* begin CmpCq:R: */
				quickConstant1 = ((ssValue(1))->constant);
				/* begin gen:quickConstant:operand: */
				anInstruction1 = genoperandoperand(CmpCqR, quickConstant1, argReg);
				if (usesOutOfLineLiteral(anInstruction1)) {
					(anInstruction1->dependent = locateLiteral(quickConstant1));
				}
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrRegOrNone);
		}
	}
	ssPop(2);
	resultReg = (rcvrRegOrNone == NoReg
		? argReg
		: rcvrRegOrNone);
	jumpEqual = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	if (orNot) {
		/* begin genMoveConstant:R: */
				/* begin MoveCq:R: */
		anInstruction2 = genoperandoperand(MoveCqR, trueObject(), resultReg);
		if (usesOutOfLineLiteral(anInstruction2)) {
			(anInstruction2->dependent = locateLiteral(trueObject()));
		}
	}
	else {
		/* begin genMoveConstant:R: */
				/* begin MoveCq:R: */
		anInstruction3 = genoperandoperand(MoveCqR, falseObject(), resultReg);
		if (usesOutOfLineLiteral(anInstruction3)) {
			(anInstruction3->dependent = locateLiteral(falseObject()));
		}
	}
	jumpNotEqual = genoperand(Jump, ((sqInt)0));
	jmpTarget(jumpEqual, (orNot
		? 
			/* begin genMoveConstant:R: */
gMoveCqR(falseObject(), resultReg)
		: gMoveCqR(trueObject(), resultReg)));
	jmpTarget(jumpNotEqual, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	ssPushRegister(resultReg);
	return 0;
}


/*	Decompose code generation for #== into a common constant-folding version,
	followed by a double dispatch through the objectRepresentation to a
	version that doesn't deal with forwarders and a version that does. */

	/* StackToRegisterMappingCogit>>#genInlinedIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genInlinedIdenticalOrNotIf(sqInt orNot)
{
    BytecodeDescriptor *primDescriptor;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	if ((isUnannotatableConstant(ssTop()))
	 && (isUnannotatableConstant(ssValue(1)))) {
		assert(!((primDescriptor->isMapped)));
		result = ((orNot
			? (((ssTop())->constant)) != (((ssValue(1))->constant))
			: (((ssTop())->constant)) == (((ssValue(1))->constant)))
			? trueObject()
			: falseObject());
		ssPop(2);
		return ssPushConstant(result);
	}
	return genVanillaInlinedIdenticalOrNotIf(orNot);
}

	/* StackToRegisterMappingCogit>>#genJumpBackTo: */
static NoDbgRegParms sqInt
genJumpBackTo(sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    sqInt i;
    void *jumpTarget;
    void *jumpTarget1;


	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	if (simSpillBase <= simStackPtr) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = simStackPtr + 1;
	}
	/* can't fall through */
	deadCode = 1;
	/* begin gen:literal:operand: */
	checkLiteralforInstruction(stackLimitAddress(), genoperandoperand(MoveAwR, stackLimitAddress(), TempReg));
	assert(!((TempReg == SPReg)));
	genoperandoperand(CmpRR, TempReg, SPReg);
	/* begin fixupAt: */
	jumpTarget = fixupAtIndex(targetBytecodePC - initialPC);
	genConditionalBranchoperand(JumpAboveOrEqual, ((sqInt)jumpTarget));
	abstractInstruction = genoperand(Call, ceCheckForInterruptTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
	abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
	/* begin annotateBytecode: */
	(abstractInstruction1->annotation = HasBytecodePC);
	/* begin fixupAt: */
	jumpTarget1 = fixupAtIndex(targetBytecodePC - initialPC);
	genoperand(Jump, ((sqInt)jumpTarget1));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpIf:to: */
static NoDbgRegParms sqInt
genJumpIfto(sqInt boolean, sqInt targetBytecodePC)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    CogSimStackEntry *desc;
    sqInt eventualTarget;
    BytecodeFixup *fixup;
    sqInt i;
    void *jumpTarget;
    AbstractInstruction *ok;
    sqInt quickConstant;

	eventualTarget = eventualTargetOf(targetBytecodePC);
	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	if (simSpillBase <= (simStackPtr - 1)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 1)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 1))); i < simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 1) + 1;
	}
	desc = ssTop();
	ssPop(1);
	if (	/* begin stackEntryIsBoolean: */
		(((desc->type)) == SSConstant)
	 && ((((desc->constant)) == (trueObject()))
	 || (((desc->constant)) == (falseObject())))) {
		/* Must arrange there's a fixup at the target whether it is jumped to or
		   not so that the simStackPtr can be kept correct. */
		/* Must annotate the bytecode for correct pc mapping. */
		fixup = ensureFixupAt(eventualTarget);
		if (((desc->constant)) == boolean) {
			abstractInstruction = genoperand(Jump, ((sqInt)fixup));
		}
		else {
			if (prevInstIsPCAnnotated()) {
				abstractInstruction = gen(Nop);
			}
			else {
				abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
		}
		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		extA = 0;
		return 0;
	}
	popToReg(desc, TempReg);
	assert((objectAfter(falseObject())) == (trueObject()));
	/* begin genSubConstant:R: */
	if (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(boolean))
	 && (oopisGreaterThan(boolean, trueObject()))) {
		annotateobjRef(checkLiteralforInstruction(boolean, genoperandoperand(SubCwR, boolean, TempReg)), TempReg);
	}
	else {
		/* begin SubCq:R: */
		anInstruction = genoperandoperand(SubCqR, boolean, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(boolean));
		}
	}
	jumpTarget = ensureFixupAt(eventualTarget);
	/* begin JumpZero: */
	genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
	if (((extA & 1) != 0)) {
		extA = 0;
		abstractInstruction1 = lastOpcode();
		/* begin annotateBytecode: */
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;
	}
	extA = 0;
	/* begin CmpCq:R: */
	quickConstant = (boolean == (falseObject())
		? (trueObject()) - (falseObject())
		: (falseObject()) - (trueObject()));
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(CmpCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant));
	}
	ok = genConditionalBranchoperand(JumpZero, ((sqInt)0));
	genCallMustBeBooleanFor(boolean);
	jmpTarget(ok, annotateBytecode(genoperandoperand(Label, (labelCounter += 1), bytecodePC)));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genJumpTo: */
static NoDbgRegParms sqInt
genJumpTo(sqInt targetBytecodePC)
{
    sqInt eventualTarget;
    BytecodeFixup *fixup;
    BytecodeDescriptor *generator;
    sqInt i;
    sqInt i1;

	eventualTarget = eventualTargetOf(targetBytecodePC);
	if ((eventualTarget > bytecodePC)
	 && ((	/* begin stackTopIsBoolean */
		(simStackPtr >= methodOrBlockNumArgs)
	 && (stackEntryIsBoolean(ssTop())))
	 && (isConditionalBranch(generator = generatorForPC(eventualTarget))))) {
		eventualTarget = (eventualTarget + ((generator->numBytes))) + ((((generator->isBranchTrue)) == ((((ssTop())->constant)) == (trueObject()))
	? ((generator->spanFunction))(generator, eventualTarget, 0, methodObj)
	: 0));
		ssPop(1);
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		fixup = ensureFixupAt(eventualTarget);
		ssPop(-1);
	}
	else {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i1 <= simStackPtr; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		fixup = ensureFixupAt(eventualTarget);
	}
	/* can't fall through */
	deadCode = 1;
	/* begin Jump: */
	genoperand(Jump, ((sqInt)fixup));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genMarshalledSend:numArgs:sendTable: */
static NoDbgRegParms sqInt
genMarshalledSendnumArgssendTable(sqInt selectorIndex, sqInt numArgs, sqInt *sendTable)
{
    AbstractInstruction *anInstruction;
    sqInt annotation;

	assert(needsFrame);
	/* begin annotationForSendTable: */
	if (sendTable == ordinarySendTrampolines) {
		annotation = IsSendCall;
		goto l1;
	}
	assert(sendTable == superSendTrampolines);
	annotation = IsSuperSend;
	l1:	/* end annotationForSendTable: */;
	if (	/* begin annotationIsForUncheckedEntryPoint: */
		(annotation == IsSuperSend)) {
		/* begin genEnsureOopInRegNotForwarded:scratchReg: */
	}
	if (numArgs >= (NumSendTrampolines - 1)) {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, numArgs, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(numArgs));
		}
	}
	genLoadInlineCacheWithSelector(selectorIndex);
	((genoperand(Call, sendTable[((numArgs < (NumSendTrampolines - 1)) ? numArgs : (NumSendTrampolines - 1))]))->annotation = annotation);
	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	return ssPushRegister(ReceiverResultReg);
}


/*	Generate the abort for a method. This abort performs either a call of
	ceSICMiss: to handle a single-in-line cache miss or a call of
	ceStackOverflow: to handle a
	stack overflow. It distinguishes the two by testing ResultReceiverReg. If
	the register is zero then this is a stack-overflow because a) the receiver
	has already
	been pushed and so can be set to zero before calling the abort, and b) the
	receiver must always contain an object (and hence be non-zero) on SIC
	miss.  */

	/* StackToRegisterMappingCogit>>#genMethodAbortTrampolineFor: */
static NoDbgRegParms usqInt
genMethodAbortTrampolineFor(sqInt numArgs)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jumpSICMiss;

	zeroOpcodeIndex();
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, 0, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(0));
	}
	/* The abort sequence has pushed the LinkReg a second time - because a stack
	   overflow can only happen after building a frame, which pushes LinkReg anyway, and
	   we still need to push LinkReg in case we get to this routine from a sendMissAbort.
	   (On ARM there is a simpler way; use two separate abort calls since all instructions are 32-bits
	   but on x86 the zero receiver reg, call methodAbort sequence is smaller; we may fix this one day).
	   Overwrite that duplicate with the right one - the return address for the call to the abort trampoline.
	   The only reason it matters is an assert in ceStackOverflow: uses it */
	jumpSICMiss = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	/* begin MoveR:Mw:r: */
	anInstruction1 = genoperandoperandoperand(MoveRMwr, LinkReg, 0, SPReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(0));
	}
	compileTrampolineFornumArgsargargargargregsToSavepushLinkRegresultReg(ceStackOverflow, 1, SendNumArgsReg, null, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg);
	jmpTarget(jumpSICMiss, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceSICMiss, trampolineNamenumRegArgs("ceMethodAbort", numArgs), 1, ReceiverResultReg, null, null, null, 0 /* begin emptyRegisterMask */, 0, NoReg, 1);
}


/*	Generate the abort for a PIC. This abort performs either a call of
	ceInterpretMethodFromPIC:receiver: to handle invoking an uncogged
	target or a call of ceMNUFromPICMNUMethod:receiver: to handle an
	MNU dispatch in a closed PIC. It distinguishes the two by testing
	ClassReg. If the register is zero then this is an MNU. */

	/* StackToRegisterMappingCogit>>#genPICAbortTrampolineFor: */
static NoDbgRegParms usqInt
genPICAbortTrampolineFor(sqInt numArgs)
{
	zeroOpcodeIndex();
	genPushRegisterArgsForAbortMissNumArgs(backEnd, numArgs);
	return genInnerPICAbortTrampoline(trampolineNamenumRegArgs("cePICAbort", numArgs));
}

	/* StackToRegisterMappingCogit>>#genPICMissTrampolineFor: */
static NoDbgRegParms usqInt
genPICMissTrampolineFor(sqInt numArgs)
{
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(ceCPICMissreceiver, trampolineNamenumRegArgs("cePICMiss", numArgs), 2, ClassReg, ReceiverResultReg, null, null, 0 /* begin emptyRegisterMask */, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genPopStackBytecode */
static sqInt
genPopStackBytecode(void)
{
    AbstractInstruction *anInstruction;

	if (((ssTop())->spilled)) {
		/* begin AddCq:R: */
		anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(BytesPerWord));
		}
	}
	ssPop(1);
	return 0;
}


/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive. */
/*	Check the argument count. Fail if wrong.
	Get the method from the outerContext and see if it is cogged. If so, jump
	to the
	block entry or the no-context-switch entry, as appropriate, and we're
	done. If not,
	invoke the interpreter primitive.
	Override to push the register args first. */

	/* StackToRegisterMappingCogit>>#genPrimitiveClosureValue */
static sqInt
genPrimitiveClosureValue(void)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *jumpBCMethod;
    AbstractInstruction *jumpFail1;
    AbstractInstruction *jumpFail2;
    AbstractInstruction *jumpFail3;
    AbstractInstruction *jumpFail4;
    AbstractInstruction *jumpFailNArgs;
    sqInt offset;
    void (*primitiveRoutine)(void);
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt result;

	genPushRegisterArgs();
	genLoadSlotsourceRegdestReg(ClosureNumArgsIndex, ReceiverResultReg, TempReg);
	/* begin CmpCq:R: */
	anInstruction = genoperandoperand(CmpCqR, (((usqInt)methodOrBlockNumArgs << 1) | 1), TempReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral((((usqInt)methodOrBlockNumArgs << 1) | 1)));
	}
	jumpFailNArgs = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(ClosureOuterContextIndex, ReceiverResultReg, ClassReg);
	jumpFail1 = genJumpImmediate(ClassReg);
	genGetCompactClassIndexNonImmOfinto(ClassReg, TempReg);
	genCmpClassMethodContextCompactIndexR(TempReg);
	/* We defer unforwarding the receiver to the prologue; scanning blocks
	   for inst var refs and only unforwarding if the block refers to inst vars. */
	jumpFail2 = genConditionalBranchoperand(JumpNonZero, ((sqInt)0));
	genLoadSlotsourceRegdestReg(MethodIndex, ClassReg, SendNumArgsReg);
	jumpFail3 = genJumpImmediate(SendNumArgsReg);
	/* begin genGetFormatOf:into: */
	anInstruction2 = genoperandoperandoperand(MoveMwrR, 0, SendNumArgsReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction2)) {
		(anInstruction2->dependent = locateLiteral(0));
	}
	/* begin LogicalShiftRightCq:R: */
	genoperandoperand(LogicalShiftRightCqR, instFormatFieldLSB(), TempReg);
	quickConstant = (1U << (instFormatFieldWidth())) - 1;
	/* begin gen:quickConstant:operand: */
	anInstruction1 = genoperandoperand(AndCqR, quickConstant, TempReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(quickConstant));
	}
	/* begin CmpCq:R: */
	quickConstant1 = firstCompiledMethodFormat();
	/* begin gen:quickConstant:operand: */
	anInstruction3 = genoperandoperand(CmpCqR, quickConstant1, TempReg);
	if (usesOutOfLineLiteral(anInstruction3)) {
		(anInstruction3->dependent = locateLiteral(quickConstant1));
	}
	jumpFail4 = genConditionalBranchoperand(JumpLess, ((sqInt)0));
	genLoadSlotsourceRegdestReg(HeaderIndex, SendNumArgsReg, ClassReg);
	jumpBCMethod = genJumpImmediate(ClassReg);
	/* begin MoveM16:r:R: */
	offset = offsetof(CogMethod, blockEntryOffset);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction4 = genoperandoperandoperand(MoveM16rR, offset, ClassReg, TempReg);
	if (usesOutOfLineLiteral(anInstruction4)) {
		(anInstruction4->dependent = locateLiteral(offset));
	}
	/* begin AddR:R: */
	genoperandoperand(AddRR, ClassReg, TempReg);
	primitiveRoutine = functionPointerForCompiledMethodprimitiveIndexprimitivePropertyFlagsInto(methodObj, primitiveIndex, null);
	if (primitiveRoutine == primitiveClosureValueNoContextSwitch) {
		if (blockNoContextSwitchOffset == null) {
			return NotFullyInitialized;
		}
		/* begin SubCq:R: */
		anInstruction5 = genoperandoperand(SubCqR, blockNoContextSwitchOffset, TempReg);
		if (usesOutOfLineLiteral(anInstruction5)) {
			(anInstruction5->dependent = locateLiteral(blockNoContextSwitchOffset));
		}
	}
	/* begin JumpR: */
	genoperand(JumpR, TempReg);
	jmpTarget(jumpBCMethod, jmpTarget(jumpFail1, jmpTarget(jumpFail2, jmpTarget(jumpFail3, jmpTarget(jumpFail4, genoperandoperand(Label, (labelCounter += 1), bytecodePC))))));
	if (((result = compileInterpreterPrimitiveflags(primitiveRoutine, primitivePropertyFlagsnumArgs(primitiveIndex, methodOrBlockNumArgs)))) < 0) {
		return result;
	}
	jmpTarget(jumpFailNArgs, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return CompletePrimitive;
}


/*	Generate an in-line perform primitive. The lookup code requires the
	selector to be in Arg0Reg.
	adjustArgumentsForPerform: adjusts the arguments once
	genLookupForPerformNumArgs: has generated the code for the lookup. */

	/* StackToRegisterMappingCogit>>#genPrimitivePerform */
static sqInt
genPrimitivePerform(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;

	if (methodOrBlockNumArgs > (numRegArgs())) {
		/* begin MoveMw:r:R: */
		offset = (methodOrBlockNumArgs - 1) * BytesPerWord;
		/* begin gen:quickConstant:operand:operand: */
		anInstruction = genoperandoperandoperand(MoveMwrR, offset, SPReg, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(offset));
		}
	}
	return genLookupForPerformNumArgs(methodOrBlockNumArgs);
}

	/* StackToRegisterMappingCogit>>#genPushActiveContextBytecode */
static sqInt
genPushActiveContextBytecode(void)
{
	assert(needsFrame);
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateCallReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | ((1U << ReceiverResultReg)), simStackPtr, simNativeStackPtr);
	genGetActiveContextNumArgslargeinBlock(methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	return ssPushRegister(ReceiverResultReg);
}


/*	Block compilation. At this point in the method create the block. Note its
	start and defer generating code for it until after the method and any
	other preceding
	blocks. The block's actual code will be compiled later. */
/*	143 10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num
	Args kkkk BlockSize jjjjjjjjiiiiiiii */

	/* StackToRegisterMappingCogit>>#genPushClosureCopyCopiedValuesBytecode */
static sqInt
genPushClosureCopyCopiedValuesBytecode(void)
{
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt startpc;

	assert(needsFrame);
	startpc = bytecodePC + (((generatorAt(byte0))->numBytes));
	addBlockStartAtnumArgsnumCopiedspan(startpc, (numArgs = byte1 & 15), (numCopied = ((usqInt)(byte1)) >> 4), (((sqInt)((usqInt)(byte2) << 8))) + byte3);
	/* begin genOutlineClosure:numArgs:numCopied: */
	if (numCopied > 0) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
	}
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << SendNumArgsReg)) | ((1U << ReceiverResultReg))), simStackPtr, simNativeStackPtr);
	genCreateClosureAtnumArgsnumCopiedcontextNumArgslargeinBlock(startpc + 1, numArgs, numCopied, methodOrBlockNumArgs, methodNeedsLargeContext(methodObj), inBlock);
	if (numCopied > 0) {
		ssPop(numCopied);
	}
	ssPushRegister(ReceiverResultReg);
	return 0;
}


/*	<SmallInteger> */
/*	Override to avoid the BytecodeSetHasDirectedSuperSend check, which is
	unnecessary here given the simulation stack. */

	/* StackToRegisterMappingCogit>>#genPushLiteralIndex: */
static NoDbgRegParms sqInt
genPushLiteralIndex(sqInt literalIndex)
{
    sqInt literal;

	literal = getLiteral(literalIndex);
	return ssPushConstant(literal);
}

	/* StackToRegisterMappingCogit>>#genPushLiteralVariable: */
static NoDbgRegParms sqInt
genPushLiteralVariable(sqInt literalIndex)
{
    AbstractInstruction *anInstruction;
    sqInt association;
    sqInt freeReg;


	/* If followed by a directed super send bytecode, avoid generating any code yet.
	   The association will be passed to the directed send trampoline in a register
	   and fully dereferenced only when first linked.  It will be ignored in later sends. */
	association = getLiteral(literalIndex);
	/* N.B. Do _not_ use ReceiverResultReg to avoid overwriting receiver in assignment in frameless methods. */
	/* So far descriptors are not rich enough to describe the entire dereference so generate the register
	   load but don't push the result.  There is an order-of-evaluation issue if we defer the dereference. */
	freeReg = allocateRegNotConflictingWith(0);
	/* begin genMoveConstant:R: */
	if (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(association))
	 && (oopisGreaterThan(association, trueObject()))) {
		annotateobjRef(checkLiteralforInstruction(association, genoperandoperand(MoveCwR, association, TempReg)), association);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, association, TempReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(association));
		}
	}
	genLoadSlotsourceRegdestReg(ValueIndex, TempReg, freeReg);
	ssPushRegister(freeReg);
	return 0;
}

	/* StackToRegisterMappingCogit>>#genPushMaybeContextReceiverVariable: */
static NoDbgRegParms sqInt
genPushMaybeContextReceiverVariable(sqInt slotIndex)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *jmpDone;
    AbstractInstruction *jmpSingle;


	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ReceiverResultReg)) | ((1U << SendNumArgsReg))), simStackPtr, simNativeStackPtr);
	ensureReceiverResultRegContainsSelf();
	/* begin genPushMaybeContextSlotIndex: */
	assert(needsFrame);
	if (((CallerSavedRegisterMask & ((1U << ReceiverResultReg))) != 0)) {
		/* We have no way of reloading ReceiverResultReg since we need the inst var value as the result. */
		voidReceiverResultRegContainsSelf();
	}
	if (slotIndex == InstructionPointerIndex) {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(slotIndex));
		}
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceFetchContextInstVarTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		return ssPushRegister(SendNumArgsReg);
	}
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	jmpSingle = genJumpNotSmallIntegerInScratchReg(TempReg);
	/* begin MoveCq:R: */
	anInstruction1 = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction1)) {
		(anInstruction1->dependent = locateLiteral(slotIndex));
	}
	/* begin CallRT: */
	abstractInstruction1 = genoperand(Call, ceFetchContextInstVarTrampoline);
	(abstractInstruction1->annotation = IsRelativeCall);
	jmpDone = genoperand(Jump, ((sqInt)0));
	jmpTarget(jmpSingle, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	genLoadSlotsourceRegdestReg(slotIndex, ReceiverResultReg, SendNumArgsReg);
	jmpTarget(jmpDone, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return ssPushRegister(SendNumArgsReg);
}

	/* StackToRegisterMappingCogit>>#genPushNewArrayBytecode */
static sqInt
genPushNewArrayBytecode(void)
{
    sqInt i;
    sqInt i1;
    int popValues;
    sqInt size;

	assert(needsFrame);
	voidReceiverResultRegContainsSelf();
	if ((popValues = byte1 > 0x7F)) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i1 <= simStackPtr; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
	}
	else {
		/* begin ssAllocateCallReg:and: */
		ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << SendNumArgsReg)) | ((1U << ReceiverResultReg))), simStackPtr, simNativeStackPtr);
	}
	size = byte1 & 0x7F;
	if (!popValues) {
		if (tryCollapseTempVectorInitializationOfSize(size)) {
			return 0;
		}
	}
	genNewArrayOfSizeinitialized(size, !popValues);
	if (popValues) {
		for (i = (size - 1); i >= 0; i += -1) {
			/* begin PopR: */
			genoperand(PopR, TempReg);
			genStoreSourceRegslotIndexintoNewObjectInDestReg(TempReg, i, ReceiverResultReg);
		}
		ssPop(size);
	}
	return ssPushRegister(ReceiverResultReg);
}

	/* StackToRegisterMappingCogit>>#genPushReceiverBytecode */
static sqInt
genPushReceiverBytecode(void)
{
	if ((((simSelf())->liveRegister)) == ReceiverResultReg) {
		return ssPushRegister(ReceiverResultReg);
	}
	return ssPushDesc(ssSelfDescriptor());
}

	/* StackToRegisterMappingCogit>>#genPushReceiverVariable: */
static NoDbgRegParms sqInt
genPushReceiverVariable(sqInt index)
{
	ensureReceiverResultRegContainsSelf();
	return ssPushBaseoffset(ReceiverResultReg, slotOffsetOfInstVarIndex(index));
}


/*	Ensure that the register args are pushed before the retpc for methods with
	arity <= self numRegArgs.
 */
/*	This isn't as clumsy on a RISC. But putting the receiver and
	args above the return address means the CoInterpreter has a
	single machine-code frame format which saves us a lot of work. */

	/* StackToRegisterMappingCogit>>#genPushRegisterArgs */
static void
genPushRegisterArgs(void)
{
	if (!(regArgsHaveBeenPushed
		 || (methodOrBlockNumArgs > (numRegArgs())))) {
		genPushRegisterArgsForNumArgsscratchReg(backEnd, methodOrBlockNumArgs, SendNumArgsReg);
		regArgsHaveBeenPushed = 1;
	}
}

	/* StackToRegisterMappingCogit>>#genPushRemoteTempLongBytecode */
static sqInt
genPushRemoteTempLongBytecode(void)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt remoteTempReg;
    sqInt tempVectReg;

	tempVectReg = allocateRegNotConflictingWith(0);
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfTemporary(byte2);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, tempVectReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	remoteTempReg = availableRegisterOrNoneFor(backEnd, (liveRegisters()) | (((tempVectReg < 0) ? (((usqInt)(1)) >> (-tempVectReg)) : (1U << tempVectReg))));
	if (remoteTempReg == NoReg) {
		remoteTempReg = tempVectReg;
	}
	genLoadSlotsourceRegdestReg(byte1, tempVectReg, remoteTempReg);
	return ssPushRegister(remoteTempReg);
}


/*	If a frameless method (not a block), only argument temps can be accessed.
	This is assured by the use of needsFrameIfMod16GENumArgs: in pushTemp. */

	/* StackToRegisterMappingCogit>>#genPushTemporaryVariable: */
static NoDbgRegParms sqInt
genPushTemporaryVariable(sqInt index)
{
	assert((inBlock > 0)
	 || (needsFrame
	 || (index < methodOrBlockNumArgs)));
	return ssPushDesc(simStack[index + 1]);
}


/*	In a frameless method ReceiverResultReg already contains self.
	In a frameful method, ReceiverResultReg /may/ contain self. */

	/* StackToRegisterMappingCogit>>#genReturnReceiver */
static sqInt
genReturnReceiver(void)
{
	if (needsFrame) {
		if (!((((simSelf())->liveRegister)) == ReceiverResultReg)) {
			/* begin putSelfInReceiverResultReg */
			storeToReg(simSelf(), ReceiverResultReg);
		}
	}
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromBlock */
static sqInt
genReturnTopFromBlock(void)
{
	assert(inBlock > 0);
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genBlockReturn();
}

	/* StackToRegisterMappingCogit>>#genReturnTopFromMethod */
static sqInt
genReturnTopFromMethod(void)
{
	popToReg(ssTop(), ReceiverResultReg);
	ssPop(1);
	return genUpArrowReturn();
}

	/* StackToRegisterMappingCogit>>#genSendSuper:numArgs: */
static NoDbgRegParms sqInt
genSendSupernumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, superSendTrampolines);
}


/*	Generate a trampoline with four arguments.
	Hack: a negative value indicates an abstract register, a non-negative
	value indicates a constant. */

	/* StackToRegisterMappingCogit>>#genSendTrampolineFor:numArgs:called:arg:arg:arg:arg: */
static NoDbgRegParms usqInt
genSendTrampolineFornumArgscalledargargargarg(void *aRoutine, sqInt numArgs, char *aString, sqInt regOrConst0, sqInt regOrConst1, sqInt regOrConst2, sqInt regOrConst3)
{
    sqInt routine;
    usqInt startAddress;

	startAddress = methodZoneBase;
	zeroOpcodeIndex();
	genPushRegisterArgsForNumArgsscratchReg(backEnd, numArgs, SendNumArgsReg);
	routine = null;
	if (!(routine == null)) {
		/* Explicitly save LinkReg via ExtraReg2; it's presumably faster than pushing/popping */
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, LinkReg, Extra2Reg);
		genoperand(Call, routine);
		genoperandoperand(MoveRR, Extra2Reg, LinkReg);
	}
	genTrampolineForcallednumArgsargargargargregsToSavepushLinkRegresultRegappendOpcodes(aRoutine, aString, 4, regOrConst0, regOrConst1, regOrConst2, regOrConst3, 0 /* begin emptyRegisterMask */, 1, NoReg, 1);
	return startAddress;
}

	/* StackToRegisterMappingCogit>>#genSend:numArgs: */
static NoDbgRegParms sqInt
genSendnumArgs(sqInt selectorIndex, sqInt numArgs)
{
	marshallSendArguments(numArgs);
	return genMarshalledSendnumArgssendTable(selectorIndex, numArgs, ordinarySendTrampolines);
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorArithmetic */
static sqInt
genSpecialSelectorArithmetic(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    AbstractInstruction *anInstruction3;
    AbstractInstruction *anInstruction4;
    AbstractInstruction *anInstruction5;
    AbstractInstruction *anInstruction6;
    AbstractInstruction *anInstruction7;
    sqInt argInt;
    int argIsConst;
    sqInt argIsInt;
    sqInt i;
    sqInt index;
    AbstractInstruction *jumpContinue;
    AbstractInstruction *jumpNotSmallInts;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    int rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt result;

	primDescriptor = generatorAt(byte0);
	argIsInt = ((argIsConst = (((ssTop())->type)) == SSConstant))
	 && ((((argInt = ((ssTop())->constant))) & 1));
	rcvrIsInt = (((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
	 && ((((rcvrInt = ((ssValue(1))->constant))) & 1)))
	 || ((mclassIsSmallInteger())
	 && (isSameEntryAs(ssValue(1), simSelf())));
	if (argIsInt
	 && (rcvrIsInt
	 && (rcvrIsConst))) {
		rcvrInt = (rcvrInt >> 1);
		argInt = (argInt >> 1);
		switch ((primDescriptor->opcode)) {
		case AddRR:
			result = rcvrInt + argInt;
			break;
		case SubRR:
			result = rcvrInt - argInt;
			break;
		case AndRR:
			result = rcvrInt & argInt;
			break;
		case OrRR:
			result = rcvrInt | argInt;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		if (isIntegerValue(result)) {
			/* Must annotate the bytecode for correct pc mapping. */
			ssPop(2);
			return ssPushAnnotatedConstant((((usqInt)result << 1) | 1));
		}
		return genSpecialSelectorSend();
	}
	if ((rcvrIsConst
	 && (!rcvrIsInt))
	 || (argIsConst
	 && (!argIsInt))) {
		return genSpecialSelectorSend();
	}
	if (!(argIsInt
		 || (rcvrIsInt))) {
		return genSpecialSelectorSend();
	}
	if (argIsInt) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= (simStackPtr - 2)) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = (simStackPtr - 2) + 1;
		}
		popToReg(ssValue(1), ReceiverResultReg);
		ssPop(2);
	}
	else {
		marshallSendArguments(1);
	}
	jumpNotSmallInts = (!(rcvrIsInt
 && (argIsInt))
		? (argIsInt
				? genJumpNotSmallInteger(ReceiverResultReg)
				: (rcvrIsInt
						? genJumpNotSmallInteger(Arg0Reg)
						: genJumpNotSmallIntegersInandscratch(ReceiverResultReg, Arg0Reg, TempReg)))
		: 0);
	switch ((primDescriptor->opcode)) {
	case AddRR:
		if (argIsInt) {
			/* begin AddCq:R: */
			anInstruction = genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction)) {
				(anInstruction->dependent = locateLiteral(argInt - ConstZero));
			}
			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin SubCq:R: */
			anInstruction1 = genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction1)) {
				(anInstruction1->dependent = locateLiteral(argInt - ConstZero));
			}
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(ReceiverResultReg);
			/* begin AddR:R: */
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			if (rcvrIsInt
			 && (rcvrIsConst)) {
				/* begin MoveCq:R: */
				anInstruction2 = genoperandoperand(MoveCqR, rcvrInt, ReceiverResultReg);
				if (usesOutOfLineLiteral(anInstruction2)) {
					(anInstruction2->dependent = locateLiteral(rcvrInt));
				}
			}
			else {
				/* begin SubR:R: */
				genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
				genSetSmallIntegerTagsIn(ReceiverResultReg);
			}
		}
		break;
	case SubRR:
		if (argIsInt) {
			/* begin SubCq:R: */
			anInstruction3 = genoperandoperand(SubCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction3)) {
				(anInstruction3->dependent = locateLiteral(argInt - ConstZero));
			}
			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			/* begin AddCq:R: */
			anInstruction4 = genoperandoperand(AddCqR, argInt - ConstZero, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction4)) {
				(anInstruction4->dependent = locateLiteral(argInt - ConstZero));
			}
		}
		else {
			genRemoveSmallIntegerTagsInScratchReg(Arg0Reg);
			/* begin SubR:R: */
			genoperandoperand(SubRR, Arg0Reg, ReceiverResultReg);
			/* overflow; must undo the damage before continuing */
			jumpContinue = genConditionalBranchoperand(JumpNoOverflow, ((sqInt)0));
			genoperandoperand(AddRR, Arg0Reg, ReceiverResultReg);
			genSetSmallIntegerTagsIn(Arg0Reg);
		}
		break;
	case AndRR:
		if (argIsInt) {
			/* begin AndCq:R: */
			anInstruction5 = genoperandoperand(AndCqR, argInt, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction5)) {
				(anInstruction5->dependent = locateLiteral(argInt));
			}
		}
		else {
			/* begin AndR:R: */
			genoperandoperand(AndRR, Arg0Reg, ReceiverResultReg);
		}
		jumpContinue = (!(jumpNotSmallInts == null)
			? genoperand(Jump, ((sqInt)0))
			: 0);
		break;
	case OrRR:
		if (argIsInt) {
			/* begin OrCq:R: */
			anInstruction6 = genoperandoperand(OrCqR, argInt, ReceiverResultReg);
			if (usesOutOfLineLiteral(anInstruction6)) {
				(anInstruction6->dependent = locateLiteral(argInt));
			}
		}
		else {
			/* begin OrR:R: */
			genoperandoperand(OrRR, Arg0Reg, ReceiverResultReg);
		}
		jumpContinue = (!(jumpNotSmallInts == null)
			? genoperand(Jump, ((sqInt)0))
			: 0);
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	if (jumpNotSmallInts == null) {
		if (!jumpContinue) {
			/* overflow cannot happen */
			if (prevInstIsPCAnnotated()) {
				abstractInstruction = gen(Nop);
			}
			else {
				abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
			}
			/* begin annotateBytecode: */
			(abstractInstruction->annotation = HasBytecodePC);
			ssPushRegister(ReceiverResultReg);
			return 0;
		}
	}
	else {
		jmpTarget(jumpNotSmallInts, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
	if (argIsInt) {
		/* begin MoveCq:R: */
		anInstruction7 = genoperandoperand(MoveCqR, argInt, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction7)) {
			(anInstruction7->dependent = locateLiteral(argInt));
		}
	}
	index = byte0 - FirstSpecialSelector;
	genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
	jmpTarget(jumpContinue, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	return 0;
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorClass */
static sqInt
genSpecialSelectorClass(void)
{
    sqInt requiredReg1;
    sqInt topReg;

	topReg = registerOrNone(ssTop());
	ssPop(1);
	if ((topReg == NoReg)
	 || (topReg == ClassReg)) {
		requiredReg1 = (topReg = SendNumArgsReg);
		/* begin ssAllocateRequiredReg:and: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((((requiredReg1 < 0) ? (((usqInt)(1)) >> (-requiredReg1)) : (1U << requiredReg1))) | ((1U << ClassReg)), simStackPtr, simNativeStackPtr);
	}
	else {
		/* begin ssAllocateRequiredReg: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr, simNativeStackPtr);
	}
	ssPush(1);
	popToReg(ssTop(), topReg);
	genGetClassObjectOfintoscratchRegmayBeAForwarder(topReg, ClassReg, TempReg, mayBeAForwarder(ssTop()));
	ssPop(1);
	return ssPushRegister(ClassReg);
}

	/* StackToRegisterMappingCogit>>#genSpecialSelectorComparison */
static sqInt
genSpecialSelectorComparison(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    sqInt argInt;
    sqInt argIsIntConst;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt descr;
    sqInt i;
    sqInt index;
    sqInt inlineCAB;
    AbstractInstruction *jumpNotSmallInts;
    void *jumpTarget;
    sqInt nExts;
    sqInt next;
    sqInt nextPC;
    sqInt nextPC1;
    sqInt postBranch;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    BytecodeDescriptor *primDescriptor1;
    int rcvrIsConst;
    sqInt rcvrIsInt;
    sqInt target;
    sqInt targetBytecodePC;
    sqInt targetPC;

	descr = 0;
	next = 0;
	postBranch = 0;
	target = 0;
	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	if (simSpillBase <= (simStackPtr - 2)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 2) + 1;
	}
	primDescriptor = generatorAt(byte0);
	argIsIntConst = ((((ssTop())->type)) == SSConstant)
	 && ((((argInt = ((ssTop())->constant))) & 1));
	rcvrIsInt = (((rcvrIsConst = (((ssValue(1))->type)) == SSConstant))
	 && (((((ssValue(1))->constant)) & 1)))
	 || ((mclassIsSmallInteger())
	 && (isSameEntryAs(ssValue(1), simSelf())));
	if (argIsIntConst
	 && (rcvrIsInt
	 && (rcvrIsConst))) {
		return genStaticallyResolvedSpecialSelectorComparison();
	}
	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor1 = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor1->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC1, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPC1 += (branchDescriptor1->numBytes);
		}
		if (!(		/* begin isUnconditionalBranch */
			(isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPC1 = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
	}
	targetBytecodePC = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
		postBranchPC1 = eventualTargetOf(nextPC1 + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPC1 = bytecodePC + ((primDescriptor1->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetPC = targetBytecodePC;
	/* Further, only interested in inlining = and ~= if there's a SmallInteger constant involved.
	   The relational operators successfully statically predict SmallIntegers; the equality operators do not. */
	inlineCAB = ((branchDescriptor->isBranchTrue))
	 || ((branchDescriptor->isBranchFalse));
	if (inlineCAB
	 && ((((primDescriptor->opcode)) == JumpZero)
	 || (((primDescriptor->opcode)) == JumpNonZero))) {
		inlineCAB = argIsIntConst
		 || (rcvrIsInt);
	}
	if (!inlineCAB) {
		return genSpecialSelectorSend();
	}
	if (argIsIntConst) {
		popToReg(ssValue(1), ReceiverResultReg);
		ssPop(2);
	}
	else {
		marshallSendArguments(1);
	}
	jumpNotSmallInts = (!(rcvrIsInt
 && (argIsIntConst))
		? (argIsIntConst
				? genJumpNotSmallInteger(ReceiverResultReg)
				: (rcvrIsInt
						? genJumpNotSmallInteger(Arg0Reg)
						: genJumpNotSmallIntegersInandscratch(ReceiverResultReg, Arg0Reg, TempReg)))
		: 0);
	if (argIsIntConst) {
		/* begin CmpCq:R: */
		anInstruction = genoperandoperand(CmpCqR, argInt, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(argInt));
		}
	}
	else {
		/* begin CmpR:R: */
		assert(!((Arg0Reg == SPReg)));
		genoperandoperand(CmpRR, Arg0Reg, ReceiverResultReg);
	}
	genConditionalBranchoperand(((branchDescriptor->isBranchTrue)
		? (primDescriptor->opcode)
		: inverseBranchFor((primDescriptor->opcode))), ((usqInt)(ensureNonMergeFixupAt(targetPC))));
	jumpTarget = ensureNonMergeFixupAt(postBranchPC);
	/* begin Jump: */
	genoperand(Jump, ((sqInt)jumpTarget));
	if (!jumpNotSmallInts) {
		if (prevInstIsPCAnnotated()) {
			abstractInstruction = gen(Nop);
		}
		else {
			abstractInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		}
		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
		ensureFixupAt(postBranchPC);
		ensureFixupAt(targetPC);
		deadCode = 1;
		return 0;
	}
	jmpTarget(jumpNotSmallInts, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	if (argIsIntConst) {
		/* begin MoveCq:R: */
		anInstruction1 = genoperandoperand(MoveCqR, argInt, Arg0Reg);
		if (usesOutOfLineLiteral(anInstruction1)) {
			(anInstruction1->dependent = locateLiteral(argInt));
		}
	}
	index = byte0 - FirstSpecialSelector;
	return genMarshalledSendnumArgssendTable((-index) - 1, 1, ordinarySendTrampolines);
}


/*	Assumes both operands are ints */

	/* StackToRegisterMappingCogit>>#genStaticallyResolvedSpecialSelectorComparison */
static sqInt
genStaticallyResolvedSpecialSelectorComparison(void)
{
    sqInt argInt;
    BytecodeDescriptor *primDescriptor;
    sqInt rcvrInt;
    int result;

	primDescriptor = generatorAt(byte0);
	argInt = ((ssTop())->constant);
	rcvrInt = ((ssValue(1))->constant);
	switch ((primDescriptor->opcode)) {
	case JumpLess:
		result = rcvrInt < argInt;
		break;
	case JumpLessOrEqual:
		result = rcvrInt <= argInt;
		break;
	case JumpGreater:
		result = rcvrInt > argInt;
		break;
	case JumpGreaterOrEqual:
		result = rcvrInt >= argInt;
		break;
	case JumpZero:
		result = rcvrInt == argInt;
		break;
	case JumpNonZero:
		result = rcvrInt != argInt;
		break;
	default:
		error("Case not found and no otherwise clause");
	}
	ssPop(2);
	return ssPushAnnotatedConstant((result
		? trueObject()
		: falseObject()));
}


/*	We need a frame because the association has to be in ReceiverResultReg for
	the various trampolines
	and ReceiverResultReg holds only the receiver in frameless methods.
 */

	/* StackToRegisterMappingCogit>>#genStorePop:LiteralVariable:needsStoreCheck:needsImmutabilityCheck: */
static NoDbgRegParms sqInt
genStorePopLiteralVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt litVarIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    AbstractInstruction *anInstruction;
    sqInt association;
    sqInt i;
    sqInt topReg;

	assert(needsFrame);
	/* begin genLoadLiteralVariable:in: */
	association = getLiteral(litVarIndex);
	voidReceiverResultRegContainsSelf();
	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
	if (	/* begin shouldAnnotateObjectReference: */
		(isNonIntegerObject(association))
	 && (oopisGreaterThan(association, trueObject()))) {
		annotateobjRef(checkLiteralforInstruction(association, genoperandoperand(MoveCwR, association, ReceiverResultReg)), association);
	}
	else {
		/* begin MoveCq:R: */
		anInstruction = genoperandoperand(MoveCqR, association, ReceiverResultReg);
		if (usesOutOfLineLiteral(anInstruction)) {
			(anInstruction->dependent = locateLiteral(association));
		}
	}
	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
#  if IMMUTABILITY
	if (needsImmCheck) {
		/* begin ssAllocateRequiredReg:upThrough: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr - 1, simNativeStackPtr);
		ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		return genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(ClassReg, ValueIndex, ReceiverResultReg, TempReg, needsStoreCheck, 0);
	}
#  endif // IMMUTABILITY

	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, ValueIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck);
}


/*	The reason we need a frame here is that assigning to an inst var of a
	context may
	involve wholesale reorganization of stack pages, and the only way to
	preserve the
	execution state of an activation in that case is if it has a frame. */

	/* StackToRegisterMappingCogit>>#genStorePop:MaybeContextReceiverVariable:needsStoreCheck:needsImmutabilityCheck: */
static NoDbgRegParms sqInt
genStorePopMaybeContextReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *anInstruction;
    sqInt i;
    AbstractInstruction *immutabilityFailure;
    AbstractInstruction *mutableJump;

	assert(needsFrame);
	ssFlushUpThroughReceiverVariable(slotIndex);
	ensureReceiverResultRegContainsSelf();
	/* begin genGenericStorePop:MaybeContextSlotIndex:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
	immutabilityFailure = ((AbstractInstruction *) 0);
	assert(needsFrame);
#  if IMMUTABILITY
	if (needsImmCheck) {
		mutableJump = genJumpMutablescratchReg(ReceiverResultReg, TempReg);
		genStoreTrampolineCall(slotIndex);
		storeToReg(simSelf(), ReceiverResultReg);
		immutabilityFailure = genoperand(Jump, ((sqInt)0));
		jmpTarget(mutableJump, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
#  endif // IMMUTABILITY

	ssPop(1);
	/* begin ssAllocateCallReg:and: */
	ssAllocateRequiredRegMaskupThroughupThroughNative(CallerSavedRegisterMask | (((1U << ClassReg)) | ((1U << SendNumArgsReg))), simStackPtr, simNativeStackPtr);
	ssPush(1);
	genLoadSlotsourceRegdestReg(SenderIndex, ReceiverResultReg, TempReg);
	ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	if (simSpillBase <= simStackPtr) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = simStackPtr + 1;
	}
	/* begin MoveCq:R: */
	anInstruction = genoperandoperand(MoveCqR, slotIndex, SendNumArgsReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(slotIndex));
	}
	/* begin CallRT: */
	abstractInstruction = genoperand(Call, ceStoreContextInstVarTrampoline);
	(abstractInstruction->annotation = IsRelativeCall);
#  if IMMUTABILITY
	if (needsImmCheck) {
		jmpTarget(immutabilityFailure, genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	}
#  endif

	return 0;
}

	/* StackToRegisterMappingCogit>>#genStorePop:ReceiverVariable:needsStoreCheck:needsImmutabilityCheck: */
static NoDbgRegParms sqInt
genStorePopReceiverVariableneedsStoreCheckneedsImmutabilityCheck(sqInt popBoolean, sqInt slotIndex, sqInt needsStoreCheck, sqInt needsImmCheck)
{
    sqInt i;
    sqInt needsImmCheck1;
    sqInt needsStoreCheck1;
    sqInt topReg;

	ssFlushUpThroughReceiverVariable(slotIndex);
	ensureReceiverResultRegContainsSelf();
	needsStoreCheck1 = (!useTwoPaths)
	 && (needsStoreCheck);
	needsImmCheck1 = needsImmCheck
	 && (!useTwoPaths);
	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */
#  if IMMUTABILITY
	if (needsImmCheck1) {
		/* begin ssAllocateRequiredReg:upThrough: */
		ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ClassReg), simStackPtr - 1, simNativeStackPtr);
		ssStoreAndReplacePoptoReg(popBoolean, ClassReg);
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		return genStoreWithImmutabilityCheckSourceRegslotIndexdestRegscratchRegneedsStoreCheckneedRestoreRcvr(ClassReg, slotIndex, ReceiverResultReg, TempReg, needsStoreCheck1, 1);
	}
#  endif // IMMUTABILITY

	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck1);
}


/*	The only reason we assert needsFrame here is that in a frameless method
	ReceiverResultReg must and does contain only self, but the ceStoreCheck
	trampoline expects the target of the store to be in ReceiverResultReg. So
	in a frameless method we would have a conflict between the receiver and
	the temote temp store, unless we we smart enough to realise that
	ReceiverResultReg was unused after the literal variable store, unlikely
	given that methods return self by default. */

	/* StackToRegisterMappingCogit>>#genStorePop:RemoteTemp:At:needsStoreCheck: */
static NoDbgRegParms sqInt
genStorePopRemoteTempAtneedsStoreCheck(sqInt popBoolean, sqInt slotIndex, sqInt remoteTempIndex, sqInt needsStoreCheck)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt topReg;

	assert(needsFrame);
	/* begin ssAllocateRequiredReg: */
	ssAllocateRequiredRegMaskupThroughupThroughNative((1U << ReceiverResultReg), simStackPtr, simNativeStackPtr);
	voidReceiverResultRegContainsSelf();
	/* begin MoveMw:r:R: */
	offset = frameOffsetOfTemporary(remoteTempIndex);
	/* begin gen:quickConstant:operand:operand: */
	anInstruction = genoperandoperandoperand(MoveMwrR, offset, FPReg, ReceiverResultReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	/* begin genGenericStorePop:slotIndex:destReg:needsStoreCheck:needsRestoreRcvr:needsImmutabilityCheck: */

	topReg = allocateRegForStackEntryAtnotConflictingWith(0, (1U << ReceiverResultReg));
	ssStorePoptoReg(popBoolean, topReg);
	return genStoreSourceRegslotIndexdestRegscratchReginFrameneedsStoreCheck(topReg, slotIndex, ReceiverResultReg, TempReg, needsFrame, needsStoreCheck);
}

	/* StackToRegisterMappingCogit>>#genStorePop:TemporaryVariable: */
static NoDbgRegParms sqInt
genStorePopTemporaryVariable(sqInt popBoolean, sqInt tempIndex)
{
    AbstractInstruction *anInstruction;
    sqInt offset;
    sqInt reg;

	ssFlushUpThroughTemporaryVariable(tempIndex);
	reg = ssStorePoptoPreferredReg(popBoolean, TempReg);
	/* begin MoveR:Mw:r: */
	offset = frameOffsetOfTemporary(tempIndex);
	/* begin gen:operand:quickConstant:operand: */
	anInstruction = genoperandoperandoperand(MoveRMwr, reg, offset, FPReg);
	if (usesOutOfLineLiteral(anInstruction)) {
		(anInstruction->dependent = locateLiteral(offset));
	}
	((simStackAt(tempIndex + 1))->bcptr = bytecodePC);
	return 0;
}


/*	Generate a method return from within a method or a block.
	Frameless method activation looks like
	CISCs (x86):
	receiver
	args
	sp->	ret pc.
	RISCs (ARM):
	receiver
	args
	ret pc in LR.
	A fully framed activation is described in CoInterpreter
	class>initializeFrameIndices. Return pops receiver and arguments off the
	stack. Callee pushes the result. */

	/* StackToRegisterMappingCogit>>#genUpArrowReturn */
static sqInt
genUpArrowReturn(void)
{
    AbstractInstruction *abstractInstruction;
    AbstractInstruction *abstractInstruction1;
    sqInt i;
    sqInt offset;


	/* can't fall through */
	deadCode = 1;
	if (inBlock > 0) {
		assert(needsFrame);
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
		/* begin CallRT: */
		abstractInstruction = genoperand(Call, ceNonLocalReturnTrampoline);
		(abstractInstruction->annotation = IsRelativeCall);
		abstractInstruction1 = genoperandoperand(Label, (labelCounter += 1), bytecodePC);
		/* begin annotateBytecode: */
		(abstractInstruction1->annotation = HasBytecodePC);
		return 0;
	}
	if (
#  if IMMUTABILITY
		needsFrame
			 && (!useTwoPaths)
#  else
		needsFrame
#  endif
		) {
		/* begin MoveR:R: */
		genoperandoperand(MoveRR, FPReg, SPReg);
		genoperand(PopR, FPReg);
		genoperand(PopR, LinkReg);
		genoperand(RetN, (methodOrBlockNumArgs + 1) * BytesPerWord);
	}
	else {
		offset = ((methodOrBlockNumArgs > (numRegArgs()))
		 || (regArgsHaveBeenPushed)
			? (methodOrBlockNumArgs + 1) * BytesPerWord
			: 0);
		/* begin RetN: */
		genoperand(RetN, offset);
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#genVanillaInlinedIdenticalOrNotIf: */
static NoDbgRegParms sqInt
genVanillaInlinedIdenticalOrNotIf(sqInt orNot)
{
    AbstractInstruction *anInstruction;
    AbstractInstruction *anInstruction1;
    AbstractInstruction *anInstruction2;
    sqInt arg;
    int argIsConstant;
    sqInt argNeedsReg;
    sqInt argReg;
    sqInt argReg1;
    BytecodeDescriptor *branchDescriptor;
    BytecodeDescriptor *branchDescriptor1;
    sqInt descr;
    sqInt i;
    void *jumpTarget;
    void *jumpTarget1;
    void *jumpTarget2;
    void *jumpTarget3;
    sqInt nExts;
    sqInt next;
    sqInt nextPC;
    sqInt nextPC1;
    sqInt postBranch;
    sqInt postBranchPC;
    sqInt postBranchPC1;
    BytecodeDescriptor *primDescriptor;
    sqInt quickConstant;
    sqInt quickConstant1;
    sqInt rcvr;
    sqInt rcvrIsConstant;
    sqInt rcvrNeedsReg;
    sqInt rcvrReg;
    sqInt rcvrReg1;
    sqInt reg;
    sqInt rNext;
    sqInt rNext1;
    sqInt rTop;
    sqInt rTop1;
    sqInt target;
    sqInt targetBytecodePC;
    sqInt targetPC;
    sqInt topRegistersMask;

	arg = 0;
	descr = 0;
	next = 0;
	postBranch = 0;
	rcvr = 0;
	target = 0;
	/* begin extractMaybeBranchDescriptorInto: */
	primDescriptor = generatorAt(byte0);
	nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	nExts = 0;
	while (1) {
		while (1) {
			/* begin generatorForPC: */
			branchDescriptor1 = generatorAt(bytecodeSetOffset + (fetchByteofObject(nextPC1, methodObj)));
			if (!((branchDescriptor1->isExtension))) break;
			nExts += 1;
			nextPC1 += (branchDescriptor1->numBytes);
		}
		if (!(		/* begin isUnconditionalBranch */
			(isBranch(branchDescriptor1))
		 && (!(((branchDescriptor1->isBranchTrue))
		 || ((branchDescriptor1->isBranchFalse)))))) break;
		nextPC1 = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
	}
	targetBytecodePC = (postBranchPC1 = 0);
	if (((branchDescriptor1->isBranchTrue))
	 || ((branchDescriptor1->isBranchFalse))) {
		targetBytecodePC = eventualTargetOf((nextPC1 + ((branchDescriptor1->numBytes))) + (((branchDescriptor1->spanFunction))(branchDescriptor1, nextPC1, nExts, methodObj)));
		postBranchPC1 = eventualTargetOf(nextPC1 + ((branchDescriptor1->numBytes)));
	}
	else {
		nextPC1 = bytecodePC + ((primDescriptor->numBytes));
	}
	branchDescriptor = branchDescriptor1;
	nextPC = nextPC1;
	postBranchPC = postBranchPC1;
	targetPC = targetBytecodePC;
	/* They can't be both constants to use correct machine opcodes.
	   However annotable constants can't be resolved statically, hence we need to careful. */
	argIsConstant = (((ssTop())->type)) == SSConstant;
	rcvrIsConstant = (!argIsConstant)
	 && ((((ssValue(1))->type)) == SSConstant);
	argNeedsReg = !argIsConstant;
	rcvrNeedsReg = !rcvrIsConstant;
	/* begin allocateEqualsEqualsRegistersArgNeedsReg:rcvrNeedsReg:into: */
	rNext = 0;
	rTop = 0;
	assert(argNeedsReg
	 || (rcvrNeedsReg));
	argReg1 = (rcvrReg1 = NoReg);
	if (argNeedsReg) {
		if (rcvrNeedsReg) {
			/* begin allocateRegForStackTopTwoEntriesInto: */
			topRegistersMask = 0;
			rTop1 = (rNext1 = NoReg);
			if ((registerOrNone(ssTop())) != NoReg) {
				rTop1 = registerOrNone(ssTop());
			}
			if ((registerOrNone(ssValue(1))) != NoReg) {
				reg = (rNext1 = registerOrNone(ssValue(1)));
				/* begin registerMaskFor: */
				topRegistersMask = ((reg < 0) ? (((usqInt)(1)) >> (-reg)) : (1U << reg));
			}
			if (rTop1 == NoReg) {
				rTop1 = allocateRegNotConflictingWith(topRegistersMask);
			}
			if (rNext1 == NoReg) {
				rNext1 = allocateRegNotConflictingWith(((rTop1 < 0) ? (((usqInt)(1)) >> (-rTop1)) : (1U << rTop1)));
			}
			assert(!(((rTop1 == NoReg)
 || (rNext1 == NoReg))));
			argReg1 = rTop1;
			rcvrReg1 = rNext1;
			popToReg(ssTop(), argReg1);
			popToReg(ssValue(1), rcvrReg1);
		}
		else {
			argReg1 = allocateRegForStackEntryAtnotConflictingWith(0, 0);
			popToReg(ssTop(), argReg1);
			if (((ssValue(1))->spilled)) {
				/* begin AddCq:R: */
				anInstruction = genoperandoperand(AddCqR, BytesPerWord, SPReg);
				if (usesOutOfLineLiteral(anInstruction)) {
					(anInstruction->dependent = locateLiteral(BytesPerWord));
				}
			}
		}
	}
	else {
		assert(rcvrNeedsReg);
		assert(!((((ssTop())->spilled))));
		rcvrReg1 = allocateRegForStackEntryAtnotConflictingWith(1, 0);
		popToReg(ssValue(1), rcvrReg1);
	}
	assert(!((argNeedsReg
 && (argReg1 == NoReg))));
	assert(!((rcvrNeedsReg
 && (rcvrReg1 == NoReg))));
	rcvrReg = rcvrReg1;
	argReg = argReg1;
	if (!(((branchDescriptor->isBranchTrue))
		 || ((branchDescriptor->isBranchFalse)))) {
		return genIdenticalNoBranchArgIsConstantrcvrIsConstantargRegrcvrRegorNotIf(argIsConstant, rcvrIsConstant, argReg, rcvrReg, orNot);
	}
	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	if (simSpillBase <= (simStackPtr - 2)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < (simStackPtr - 2)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : (simStackPtr - 2))); i <= (simStackPtr - 2); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = (simStackPtr - 2) + 1;
	}
	/* begin genCmpArgIsConstant:rcvrIsConstant:argReg:rcvrReg: */
	assert((argReg != NoReg)
	 || (rcvrReg != NoReg));
	if (argIsConstant) {
		/* begin genCmpConstant:R: */
		if (		/* begin shouldAnnotateObjectReference: */
			(isNonIntegerObject(((ssTop())->constant)))
		 && (oopisGreaterThan(((ssTop())->constant), trueObject()))) {
			annotateobjRef(checkLiteralforInstruction(((ssTop())->constant), genoperandoperand(CmpCwR, ((ssTop())->constant), rcvrReg)), ((ssTop())->constant));
		}
		else {
			/* begin CmpCq:R: */
			quickConstant = ((ssTop())->constant);
			/* begin gen:quickConstant:operand: */
			anInstruction2 = genoperandoperand(CmpCqR, quickConstant, rcvrReg);
			if (usesOutOfLineLiteral(anInstruction2)) {
				(anInstruction2->dependent = locateLiteral(quickConstant));
			}
		}
	}
	else {
		if (rcvrIsConstant) {
			/* begin genCmpConstant:R: */
			if (			/* begin shouldAnnotateObjectReference: */
				(isNonIntegerObject(((ssValue(1))->constant)))
			 && (oopisGreaterThan(((ssValue(1))->constant), trueObject()))) {
				annotateobjRef(checkLiteralforInstruction(((ssValue(1))->constant), genoperandoperand(CmpCwR, ((ssValue(1))->constant), argReg)), ((ssValue(1))->constant));
			}
			else {
				/* begin CmpCq:R: */
				quickConstant1 = ((ssValue(1))->constant);
				/* begin gen:quickConstant:operand: */
				anInstruction1 = genoperandoperand(CmpCqR, quickConstant1, argReg);
				if (usesOutOfLineLiteral(anInstruction1)) {
					(anInstruction1->dependent = locateLiteral(quickConstant1));
				}
			}
		}
		else {
			/* begin CmpR:R: */
			assert(!((argReg == SPReg)));
			genoperandoperand(CmpRR, argReg, rcvrReg);
		}
	}
	ssPop(2);
	if (notAFixup(fixupAt(nextPC))) {
		/* The next instruction is dead.  we can skip it. */
		deadCode = 1;
		ensureFixupAt(targetPC);
		ensureFixupAt(postBranchPC);
	}
	else {
		assert(!(deadCode));
	}
	if (orNot == ((branchDescriptor->isBranchTrue))) {
		/* a == b ifFalse: ... or a ~~ b ifTrue: ... jump on equal to post-branch pc */
		ensureNonMergeFixupAt(targetPC);
		jumpTarget = ensureNonMergeFixupAt(postBranchPC);
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget));
		jumpTarget1 = ensureNonMergeFixupAt(targetPC);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)jumpTarget1));
	}
	else {
		/* orNot is true for ~~ */
		/* a == b ifTrue: ... or a ~~ b ifFalse: ... jump on equal to target pc */
		jumpTarget2 = ensureNonMergeFixupAt(targetPC);
		/* begin JumpZero: */
		genConditionalBranchoperand(JumpZero, ((sqInt)jumpTarget2));
		jumpTarget3 = ensureNonMergeFixupAt(postBranchPC);
		/* begin Jump: */
		genoperand(Jump, ((sqInt)jumpTarget3));
	}
	if (!deadCode) {
		ssPushConstant(trueObject());
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramefulMethod: */
static NoDbgRegParms void
initSimStackForFramefulMethod(sqInt startpc)
{
    CogSimStackEntry *cascade0;
    CogSimStackEntry *desc;
    sqInt i;


	/* N.B. Includes num args */
	simStackPtr = methodOrBlockNumTemps;
	simSpillBase = methodOrBlockNumTemps + 1;
	cascade0 = simSelf();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 1);
	(cascade0->registerr = FPReg);
	(cascade0->offset = FoxMFReceiver);
	(cascade0->liveRegister = NoReg);
	for (i = 1; i <= methodOrBlockNumArgs; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = FPReg);
		(desc->offset = FoxCallerSavedIP + (((methodOrBlockNumArgs - i) + 1) * BytesPerWord));
		(desc->bcptr = startpc);
	}
	for (i = (methodOrBlockNumArgs + 1); i <= simStackPtr; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = FPReg);
		(desc->offset = FoxMFReceiver - ((i - methodOrBlockNumArgs) * BytesPerWord));
		(desc->bcptr = startpc);
	}
}


/*	The register receiver (the closure itself) and args are pushed by the
	closure value primitive(s)
	and hence a frameless block has all arguments and copied values pushed to
	the stack. However,
	the method receiver (self) is put in the ReceiverResultReg by the block
	entry. 
 */

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessBlock: */
static NoDbgRegParms void
initSimStackForFramelessBlock(sqInt startpc)
{
    CogSimStackEntry *cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	cascade0 = simSelf();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = ReceiverResultReg);
	(cascade0->liveRegister = ReceiverResultReg);
	assert(methodOrBlockNumTemps >= methodOrBlockNumArgs);
	for (i = 1; i <= methodOrBlockNumTemps; i += 1) {
		desc = simStackAt(i);
		(desc->type = SSBaseOffset);
		(desc->spilled = 1);
		(desc->registerr = SPReg);
		(desc->offset = (methodOrBlockNumArgs - i) * BytesPerWord);
		(desc->bcptr = startpc);
	}
	/* N.B. Includes num args */
	simStackPtr = methodOrBlockNumTemps;
	simSpillBase = methodOrBlockNumTemps + 1;
}

	/* StackToRegisterMappingCogit>>#initSimStackForFramelessMethod: */
static NoDbgRegParms void
initSimStackForFramelessMethod(sqInt startpc)
{
    CogSimStackEntry *cascade0;
    CogSimStackEntry *desc;
    sqInt i;

	cascade0 = simSelf();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = ReceiverResultReg);
	(cascade0->liveRegister = ReceiverResultReg);
	assert(methodOrBlockNumTemps == methodOrBlockNumArgs);
	assert((numRegArgs()) <= 2);
	if (((methodOrBlockNumArgs >= 1) && (methodOrBlockNumArgs <= (numRegArgs())))) {
		desc = simStackAt(1);
		(desc->type = SSRegister);
		(desc->spilled = 0);
		(desc->registerr = Arg0Reg);
		(desc->bcptr = startpc);
		if (methodOrBlockNumArgs > 1) {
			desc = simStackAt(2);
			(desc->type = SSRegister);
			(desc->spilled = 0);
			(desc->registerr = Arg1Reg);
			(desc->bcptr = startpc);
		}
	}
	else {
		for (i = 1; i <= methodOrBlockNumArgs; i += 1) {
			desc = simStackAt(i);
			(desc->type = SSBaseOffset);
			(desc->registerr = SPReg);
			(desc->spilled = 1);
			(desc->offset = (methodOrBlockNumArgs - i) * BytesPerWord);
			(desc->bcptr = startpc);
		}
	}
	simStackPtr = methodOrBlockNumArgs;
	simSpillBase = methodOrBlockNumArgs + 1;
}


/*	Do not inline (inBlock access) */

	/* StackToRegisterMappingCogit>>#isNonForwarderReceiver: */
static NoDbgRegParms sqInt
isNonForwarderReceiver(sqInt reg)
{
	return ((((simSelf())->liveRegister)) == ReceiverResultReg)
	 && ((inBlock == 0)
	 && (reg == ReceiverResultReg));
}

	/* StackToRegisterMappingCogit>>#liveRegisters */
static sqInt
liveRegisters(void)
{
    sqInt i;
    sqInt regsSet;

	if (needsFrame) {
		regsSet = 0;
	}
	else {
		regsSet = (1U << ReceiverResultReg);
		if ((methodOrBlockNumArgs <= (numRegArgs()))
		 && (methodOrBlockNumArgs > 0)) {
			regsSet = regsSet | ((1U << Arg0Reg));
		}
	}
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= simStackPtr; i += 1) {
		regsSet = regsSet | (registerMask(simStackAt(i)));
	}
	return regsSet;
}


/*	insert nops for dead code that is mapped so that bc 
	to mc mapping is not many to one */

	/* StackToRegisterMappingCogit>>#mapDeadDescriptorIfNeeded: */
static NoDbgRegParms sqInt
mapDeadDescriptorIfNeeded(BytecodeDescriptor *descriptor)
{
    AbstractInstruction *abstractInstruction;

	flag("annotateInstruction");
	if (((descriptor->isMapped))
	 || ((inBlock > 0)
	 && ((descriptor->isMappedInBlock)))) {
		abstractInstruction = gen(Nop);
		/* begin annotateBytecode: */
		(abstractInstruction->annotation = HasBytecodePC);
	}
	return 0;
}


/*	Spill everything on the simulated stack that needs spilling (that below
	receiver and arguments).
	Marshall receiver and arguments to stack and/or registers depending on arg
	count. If the args don't fit in registers push receiver and args (spill
	everything), but still assign
	the receiver to ReceiverResultReg. */

	/* StackToRegisterMappingCogit>>#marshallSendArguments: */
static NoDbgRegParms void
marshallSendArguments(sqInt numArgs)
{
    sqInt anyRefs;
    CogSimStackEntry *cascade0;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt numSpilled;


	/* begin ssFlushTo: */
	assert(tempsValidAndVolatileEntriesSpilled());
	if (simSpillBase <= ((simStackPtr - numArgs) - 1)) {
		for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < ((simStackPtr - numArgs) - 1)) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : ((simStackPtr - numArgs) - 1))); i < (simStackPtr - numArgs); i += 1) {
			assert(needsFrame);
			ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
		}
		simSpillBase = ((simStackPtr - numArgs) - 1) + 1;
	}
	if (numArgs > (numRegArgs())) {
		/* If there are no spills and no references to ReceiverResultReg
		   the fetch of ReceiverResultReg from the stack can be avoided
		   by assigning directly to ReceiverResultReg and pushing it. */
		numSpilled = numberOfSpillsInTopNItems(numArgs + 1);
		anyRefs = anyReferencesToRegisterinTopNItems(ReceiverResultReg, numArgs + 1);
		if ((numSpilled > 0)
		 || (anyRefs)) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			if (simSpillBase <= simStackPtr) {
				for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i1 <= simStackPtr; i1 += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
				}
				simSpillBase = simStackPtr + 1;
			}
			storeToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
		}
		else {
			cascade0 = simStackAt(simStackPtr - numArgs);
			storeToReg(cascade0, ReceiverResultReg);
			(cascade0->type = SSRegister);
			(cascade0->registerr = ReceiverResultReg);
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			if (simSpillBase <= simStackPtr) {
				for (i2 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i2 <= simStackPtr; i2 += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i2), frameOffsetOfTemporary(i2 - 1), FPReg);
				}
				simSpillBase = simStackPtr + 1;
			}
		}
	}
	else {
		/* Move the args to the register arguments, being careful to do
		   so last to first so e.g. previous contents don't get overwritten.
		   Also check for any arg registers in use by other args. */
		if (numArgs > 0) {
			ssAllocateRequiredRegMaskupThroughupThroughNative((1U << Arg0Reg), simStackPtr - 1, simNativeStackPtr);
		}
		if (numArgs > 0) {
			popToReg(simStackAt((simStackPtr - numArgs) + 1), Arg0Reg);
		}
		popToReg(simStackAt(simStackPtr - numArgs), ReceiverResultReg);
	}
	ssPop(numArgs + 1);
}


/*	For assert checking; or rather for avoiding assert fails when dealing with
	the hack for block temps in the SqueakV3PlusClosures bytecode set.
 */

	/* StackToRegisterMappingCogit>>#maybeCompilingFirstPassOfBlockWithInitialPushNil */
static sqInt
maybeCompilingFirstPassOfBlockWithInitialPushNil(void)
{
	return (inBlock == InVanillaBlock)
	 && ((methodOrBlockNumTemps > methodOrBlockNumArgs)
	 && (compilationPass == 1));
}


/*	If this bytecode has a fixup, some kind of merge needs to be done. There
	are 4 cases:
	1) the bytecode has no fixup (fixup isNotAFixup)
	do nothing
	2) the bytecode has a non merge fixup
	the fixup has needsNonMergeFixup.
	The code generating non merge fixup (currently only special selector code)
	is responsible
	for the merge so no need to do it.
	We set deadCode to false as the instruction can be reached from jumps.
	3) the bytecode has a merge fixup, but execution flow *cannot* fall
	through to the merge point.
	the fixup has needsMergeFixup and deadCode = true.
	ignores the current simStack as it does not mean anything 
	restores the simStack to the state the jumps to the merge point expects it
	to be.
	4) the bytecode has a merge fixup and execution flow *can* fall through to
	the merge point.
	the fixup has needsMergeFixup and deadCode = false.
	flushes the stack to the stack pointer so the fall through execution path
	simStack is 
	in the state the merge point expects it to be. 
	restores the simStack to the state the jumps to the merge point expects it
	to be.
	
	In addition, if this is a backjump merge point, we patch the fixup to hold
	the current simStackPtr 
	for later assertions. */

	/* StackToRegisterMappingCogit>>#mergeWithFixupIfRequired: */
static NoDbgRegParms sqInt
mergeWithFixupIfRequired(BytecodeFixup *fixup)
{
    CogSimStackEntry *cascade0;
    sqInt i;
    sqInt i1;


	/* begin assertCorrectSimStackPtr */
	assert((simSpillBase >= methodOrBlockNumTemps)
	 || ((maybeCompilingFirstPassOfBlockWithInitialPushNil())
	 && (simSpillBase > methodOrBlockNumArgs)));
	if (needsFrame
	 && (simSpillBase > 0)) {
		assert(((((simStackAt(simSpillBase - 1))->spilled)) == 1)
		 || ((maybeCompilingFirstPassOfBlockWithInitialPushNil())
		 && (simSpillBase > methodOrBlockNumArgs)));
		assert((simSpillBase > simStackPtr)
		 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	}
	if (((fixup->targetInstruction)) == 0) {
		return 0;
	}
	if ((((usqInt)((fixup->targetInstruction)))) == NeedsNonMergeFixupFlag) {
		deadCode = 0;
		return 0;
	}
	assert(isMergeFixup(fixup));
	traceMerge(fixup);
	if (deadCode) {
		/* case 3 */
		/* Would like to assert fixup simStackPtr >= methodOrBlockNumTemps
		   but can't because of the initialNils hack. */
		assert((((fixup->simStackPtr)) >= methodOrBlockNumTemps)
		 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
		simStackPtr = (fixup->simStackPtr);
	}
	else {
		/* case 4 */
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= simStackPtr) {
			for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < simStackPtr) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : simStackPtr)); i <= simStackPtr; i += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
			}
			simSpillBase = simStackPtr + 1;
		}
	}
	deadCode = 0;
	if ((fixup->isTargetOfBackwardBranch)) {
		(fixup->simStackPtr = simStackPtr);
	}
	(fixup->targetInstruction = genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	assert(simStackPtr == ((fixup->simStackPtr)));
	/* begin restoreSimStackAtMergePoint: */
	((simSelf())->liveRegister = NoReg);
	for (i1 = (methodOrBlockNumTemps + 1); i1 <= simStackPtr; i1 += 1) {
		cascade0 = simStackAt(i1);
		(cascade0->type = SSSpill);
		(cascade0->offset = FoxMFReceiver - ((i1 - methodOrBlockNumArgs) * BytesPerOop));
		(cascade0->registerr = FPReg);
		(cascade0->spilled = 1);
	}
	simSpillBase = simStackPtr + 1;
	return 0;
}

	/* StackToRegisterMappingCogit>>#methodAbortTrampolineFor: */
static NoDbgRegParms sqInt
methodAbortTrampolineFor(sqInt numArgs)
{
	return methodAbortTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}


/*	This is a hook for subclasses to filter out methods they can't deal with. */
/*	Frameless methods with local temporaries cause problems,
	mostly in asserts, and yet they matter not at all for performance.
	Shun them. */

	/* StackToRegisterMappingCogit>>#methodFoundInvalidPostScan */
static sqInt
methodFoundInvalidPostScan(void)
{
	if (!needsFrame) {
		return methodOrBlockNumTemps > methodOrBlockNumArgs;
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#needsFrameIfMod16GENumArgs: */
static NoDbgRegParms int
needsFrameIfMod16GENumArgs(sqInt stackDelta)
{
	return (byte0 % 16) >= methodOrBlockNumArgs;
}


/*	As of August 2013, the code generator can't deal with spills in frameless
	methods (the
	issue is to do with the stack offset to get at an argument, which is
	changed when there's a spill).
	In e.g. TextColor>>#dominates: other ^other class == self class the second
	send of class
	needs also rto allocate a register that the first one used, but the first
	one's register can't be
	spilled. So avoid this by only allowing class to be sent if the stack
	contains a single element. */

	/* StackToRegisterMappingCogit>>#needsFrameIfStackGreaterThanOne: */
static NoDbgRegParms int
needsFrameIfStackGreaterThanOne(sqInt stackDelta)
{
	return stackDelta > 1;
}

	/* StackToRegisterMappingCogit>>#numberOfSpillsInTopNItems: */
static NoDbgRegParms sqInt
numberOfSpillsInTopNItems(sqInt n)
{
    sqInt i;

	for (i = simStackPtr; i >= ((simStackPtr - n) + 1); i += -1) {
		if ((((simStackAt(i))->type)) == SSSpill) {
			return n - (simStackPtr - i);
		}
	}
	return 0;
}

	/* StackToRegisterMappingCogit>>#picAbortTrampolineFor: */
static NoDbgRegParms sqInt
picAbortTrampolineFor(sqInt numArgs)
{
	return picAbortTrampolines[((numArgs < ((numRegArgs()) + 1)) ? numArgs : ((numRegArgs()) + 1))];
}

	/* StackToRegisterMappingCogit>>#prevInstIsPCAnnotated */
static sqInt
prevInstIsPCAnnotated(void)
{
    sqInt prevIndex;
    AbstractInstruction *prevInst;

	if (!(opcodeIndex > 0)) {
		return 0;
	}
	prevIndex = opcodeIndex - 1;
	while (1) {
		if (prevIndex <= 0) {
			return 0;
		}
		prevInst = abstractInstructionAt(prevIndex);
		if (((!((prevInst->annotation))
			? 0
			: (prevInst->annotation))) >= HasBytecodePC) {
			return 1;
		}
		if (!(((prevInst->opcode)) == Label)) break;
		prevIndex -= 1;
	}
	return 0;
}


/*	Used to mark ReceiverResultReg as dead or not containing simSelf.
	Used when the simStack has already been flushed, e.g. for sends. */

	/* StackToRegisterMappingCogit>>#receiverIsInReceiverResultReg */
static int
receiverIsInReceiverResultReg(void)
{
	return (((simSelf())->liveRegister)) == ReceiverResultReg;
}


/*	When a block must be recompiled due to overestimating the
	numInitialNils fixups must be restored, which means rescannning
	since backward branches need their targets initialized. */

	/* StackToRegisterMappingCogit>>#reinitializeFixupsFrom:through: */
static NoDbgRegParms void
reinitializeFixupsFromthrough(sqInt start, sqInt end)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    BytecodeFixup *fixup;
    sqInt nExts;
    sqInt pc;
    BytecodeFixup *self_in_CogSSBytecodeFixup;
    sqInt targetPC;

	pc = start;
	nExts = 0;
	while (pc <= end) {
		/* begin fixupAt: */
		self_in_CogSSBytecodeFixup = fixupAtIndex(pc - initialPC);
		(self_in_CogSSBytecodeFixup->targetInstruction) = 0;
		(self_in_CogSSBytecodeFixup->simStackPtr) = 0;
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((isBranch(descriptor))
		 && ((		/* begin isBackwardBranch:at:exts:in: */
			assert(((descriptor->spanFunction))),
		(((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)) < 0))) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			/* begin initializeFixupAt: */
			fixup = fixupAtIndex(targetPC - initialPC);
			(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
			/* begin setIsBackwardBranchFixup */
			(fixup->isTargetOfBackwardBranch) = 1;
		}
		if ((descriptor->isBlockCreation)) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			pc = (pc + ((descriptor->numBytes))) + distance;
		}
		else {
			pc += (descriptor->numBytes);
		}
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: 0);
	}
}


/*	Scan the block to determine if the block needs a frame or not */

	/* StackToRegisterMappingCogit>>#scanBlock: */
static NoDbgRegParms sqInt
scanBlock(BlockStart *blockStart)
{
    BytecodeDescriptor *descriptor;
    sqInt end;
    sqInt framelessStackDelta;
    sqInt nExts;
    sqInt numPushNils;
    sqInt (* const numPushNilsFunction)(struct _BytecodeDescriptor *,sqInt,sqInt,sqInt) = v3NumPushNils;
    sqInt pc;
    sqInt pushingNils;

	needsFrame = 0;
	prevBCDescriptor = null;
	methodOrBlockNumArgs = (blockStart->numArgs);
	inBlock = InVanillaBlock;
	pc = (blockStart->startpc);
	end = ((blockStart->startpc)) + ((blockStart->span));
	framelessStackDelta = (nExts = (extA = (numExtB = (extB = 0))));
	pushingNils = 1;
	while (pc < end) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (!needsFrame) {
			if ((!((descriptor->needsFrameFunction)))
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {
				needsFrame = 1;
			}
			else {
				framelessStackDelta += (descriptor->stackDelta);
			}
		}
		if (pushingNils
		 && (!((descriptor->isExtension)))) {
			/* Count the initial number of pushed nils acting as temp initializers.  We can't tell
			   whether an initial pushNil is an operand reference or a temp initializer, except
			   when the pushNil is a jump target (has a fixup), which never happens:
			   self systemNavigation browseAllSelect:
			   [:m| | ebc |
			   (ebc := m embeddedBlockClosures
			   select: [:ea| ea decompile statements first isMessage]
			   thenCollect: [:ea| ea decompile statements first selector]) notEmpty
			   and: [(#(whileTrue whileFalse whileTrue: whileFalse:) intersection: ebc) notEmpty]]
			   or if the bytecode set has a push multiple nils bytecode.  We simply count initial nils.
			   Rarely we may end up over-estimating.  We will correct by checking the stack depth
			   at the end of the block in compileBlockBodies. */
			if (((numPushNils = numPushNilsFunction(descriptor, pc, nExts, methodObj))) > 0) {
				assert(((descriptor->numBytes)) == 1);
				(blockStart->numInitialNils = ((blockStart->numInitialNils)) + numPushNils);
			}
			else {
				pushingNils = 0;
			}
		}
		pc = (pc + ((descriptor->numBytes))) + (((descriptor->isBlockCreation)
	? ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)
	: 0));
		if ((descriptor->isExtension)) {
			nExts += 1;
		}
		else {
			nExts = (extA = (numExtB = (extB = 0)));
		}
		prevBCDescriptor = descriptor;
	}
	if (!needsFrame) {
		assert((framelessStackDelta >= 0)
		 && (((blockStart->numInitialNils)) >= framelessStackDelta));
		(blockStart->numInitialNils = ((blockStart->numInitialNils)) - framelessStackDelta);
	}
	return 0;
}


/*	Scan the method (and all embedded blocks) to determine
	- what the last bytecode is; extra bytes at the end of a method are used
	to encode things like source pointers or temp names
	- if the method needs a frame or not
	- what are the targets of any backward branches.
	- how many blocks it creates
	Answer the block count or on error a negative error code */

	/* StackToRegisterMappingCogit>>#scanMethod */
static sqInt
scanMethod(void)
{
    BytecodeDescriptor *descriptor;
    sqInt distance;
    BytecodeFixup *fixup;
    sqInt framelessStackDelta;
    sqInt latestContinuation;
    sqInt nExts;
    sqInt numBlocks;
    sqInt pc;
    sqInt seenInstVarStore;
    sqInt targetPC;

	needsFrame = (useTwoPaths = (seenInstVarStore = 0));
	prevBCDescriptor = null;
	if ((primitiveIndex > 0)
	 && (isQuickPrimitiveIndex(primitiveIndex))) {
		return 0;
	}
	pc = (latestContinuation = initialPC);
	numBlocks = (framelessStackDelta = (nExts = (extA = (numExtB = (extB = 0)))));
	while (pc <= endPC) {
		byte0 = (fetchByteofObject(pc, methodObj)) + bytecodeSetOffset;
		descriptor = generatorAt(byte0);
		if ((descriptor->isExtension)) {
			if (((descriptor->opcode)) == Nop) {
				/* unknown bytecode tag; see Cogit class>>#generatorTableFrom: */
				return EncounteredUnknownBytecode;
			}
			loadSubsequentBytesForDescriptorat(descriptor, pc);
			((descriptor->generator))();
		}
		if (((descriptor->isReturn))
		 && (pc >= latestContinuation)) {
			endPC = pc;
		}
		if (!needsFrame) {
			if ((!((descriptor->needsFrameFunction)))
			 || (((descriptor->needsFrameFunction))(framelessStackDelta))) {
				/* With immutability we win simply by avoiding a frame build if the receiver is young and not immutable. */
#        if IMMUTABILITY
				if ((descriptor->is1ByteInstVarStore)) {
					useTwoPaths = 1;
				}
				else {
					needsFrame = 1;
					useTwoPaths = 0;
				}
#        else // IMMUTABILITY
				needsFrame = 1;
				useTwoPaths = 0;
#        endif

			}
			else {
				/* Without immutability we win if there are two or more stores and the receiver is new. */
				framelessStackDelta += (descriptor->stackDelta);
#        if IMMUTABILITY
#        else
				if ((descriptor->is1ByteInstVarStore)) {
					if (seenInstVarStore) {
						useTwoPaths = 1;
					}
					else {
						seenInstVarStore = 1;
					}
				}
#        endif // IMMUTABILITY

			}
		}
		if (isBranch(descriptor)) {
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			if ((			/* begin isBackwardBranch:at:exts:in: */
				assert(((descriptor->spanFunction))),
			(((descriptor->spanFunction))(descriptor, pc, nExts, methodObj)) < 0)) {
				/* begin initializeFixupAt: */
				fixup = fixupAtIndex(targetPC - initialPC);
				(fixup->targetInstruction) = ((AbstractInstruction *) NeedsMergeFixupFlag);
				/* begin setIsBackwardBranchFixup */
				(fixup->isTargetOfBackwardBranch) = 1;
			}
			else {
				latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
			}
		}
		if ((descriptor->isBlockCreation)) {
			numBlocks += 1;
			distance = ((descriptor->spanFunction))(descriptor, pc, nExts, methodObj);
			targetPC = (pc + ((descriptor->numBytes))) + distance;
			latestContinuation = ((latestContinuation < targetPC) ? targetPC : latestContinuation);
		}
		pc += (descriptor->numBytes);
		nExts = ((descriptor->isExtension)
			? nExts + 1
			: (extA = (numExtB = (extB = 0))));
		prevBCDescriptor = descriptor;
	}
	return numBlocks;
}

	/* StackToRegisterMappingCogit>>#ssAllocateRequiredRegMask:upThrough:upThroughNative: */
static NoDbgRegParms void
ssAllocateRequiredRegMaskupThroughupThroughNative(sqInt requiredRegsMask, sqInt stackPtr, sqInt nativeStackPtr)
{
    sqInt i;
    sqInt i1;
    sqInt lastRequired;
    sqInt lastRequiredNative;
    sqInt liveRegs;

	lastRequired = -1;
	/* compute live regs while noting the last occurrence of required regs.
	   If these are not free we must spill from simSpillBase to last occurrence.
	   Note we are conservative here; we could allocate FPReg in frameless methods. */
	lastRequiredNative = -1;
	liveRegs = (1U << FPReg) | (1U << SPReg);
	for (i = (((simSpillBase < 0) ? 0 : simSpillBase)); i <= stackPtr; i += 1) {
		liveRegs = liveRegs | (registerMask(simStackAt(i)));
		if ((((registerMask(simStackAt(i))) & requiredRegsMask) != 0)) {
			lastRequired = i;
		}
	}
	if (((liveRegs & requiredRegsMask) != 0)) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= lastRequired) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < lastRequired) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : lastRequired)); i1 <= lastRequired; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = lastRequired + 1;
		}
		assert(!(((((liveRegisters()) & requiredRegsMask) != 0))));
	}
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughReceiverVariable: */
static NoDbgRegParms void
ssFlushUpThroughReceiverVariable(sqInt slotIndex)
{
    CogSimStackEntry *desc;
    CogSimStackEntry *desc1;
    sqInt i;
    sqInt index;

	desc = ((CogSimStackEntry *) 0);
	/* begin ssFlushUpThrough: */
	assert(simSpillBase >= 0);
	for (index = (simStackPtr - 1); index >= simSpillBase; index += -1) {
		if (((desc1 = simStackAt(index)),
		(((desc1->type)) == SSBaseOffset)
			 && ((((desc1->registerr)) == ReceiverResultReg)
			 && (((desc1->offset)) == (slotOffsetOfInstVarIndex(slotIndex)))))) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			goto l1;
		}
	}
	l1:	/* end ssFlushUpThrough: */;
}


/*	Any occurrences on the stack of the value being stored (which is the top
	of stack)
	must be flushed, and hence any values colder than them stack. */

	/* StackToRegisterMappingCogit>>#ssFlushUpThroughTemporaryVariable: */
static NoDbgRegParms void
ssFlushUpThroughTemporaryVariable(sqInt tempIndex)
{
    CogSimStackEntry *desc;
    CogSimStackEntry *desc1;
    sqInt i;
    sqInt index;
    sqInt offset;

	desc = ((CogSimStackEntry *) 0);
	offset = ((simStackAt(tempIndex + 1))->offset);
	assert(offset == (frameOffsetOfTemporary(tempIndex)));
	/* begin ssFlushUpThrough: */
	assert(simSpillBase >= 0);
	for (index = (simStackPtr - 1); index >= simSpillBase; index += -1) {
		if (((desc1 = simStackAt(index)),
		(((desc1->type)) == SSBaseOffset)
			 && ((((desc1->registerr)) == FPReg)
			 && (((desc1->offset)) == offset)))) {
			/* begin ssFlushTo: */
			assert(tempsValidAndVolatileEntriesSpilled());
			if (simSpillBase <= index) {
				for (i = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < index) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : index)); i <= index; i += 1) {
					assert(needsFrame);
					ensureSpilledAtfrom(simStackAt(i), frameOffsetOfTemporary(i - 1), FPReg);
				}
				simSpillBase = index + 1;
			}
			goto l1;
		}
	}
	l1:	/* end ssFlushUpThrough: */;
}

	/* StackToRegisterMappingCogit>>#ssPop: */
static NoDbgRegParms void
ssPop(sqInt n)
{
    sqInt i;

	assert(((simStackPtr - n) >= methodOrBlockNumTemps)
	 || (((!needsFrame)
	 && ((simStackPtr - n) >= 0))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil())));
	simStackPtr -= n;
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
}

	/* StackToRegisterMappingCogit>>#ssPushAnnotatedConstant: */
static NoDbgRegParms sqInt
ssPushAnnotatedConstant(sqInt literal)
{
    AbstractInstruction *abstractInstruction;

	ssPushConstant(literal);
	/* begin annotateInstructionForBytecode */
	abstractInstruction = (prevInstIsPCAnnotated()
		? gen(Nop)
		: genoperandoperand(Label, (labelCounter += 1), bytecodePC));
	/* begin annotateBytecode: */
	(abstractInstruction->annotation = HasBytecodePC);
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushBase:offset: */
static NoDbgRegParms sqInt
ssPushBaseoffset(sqInt reg, sqInt offset)
{
    CogSimStackEntry *cascade0;
    sqInt i;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSBaseOffset);
	(cascade0->spilled = 0);
	(cascade0->registerr = reg);
	(cascade0->offset = offset);
	(cascade0->bcptr = bytecodePC);
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushConstant: */
static NoDbgRegParms sqInt
ssPushConstant(sqInt literal)
{
    CogSimStackEntry *cascade0;
    sqInt i;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSConstant);
	(cascade0->spilled = 0);
	(cascade0->constant = literal);
	(cascade0->bcptr = bytecodePC);
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushDesc: */
static NoDbgRegParms sqInt
ssPushDesc(SimStackEntry simStackEntry)
{
    sqInt i;

	if (((simStackEntry.type)) == SSSpill) {
		(simStackEntry.type = SSBaseOffset);
	}
	(simStackEntry.spilled = 0);
	(simStackEntry.bcptr = bytecodePC);
	simStack[(simStackPtr += 1)] = simStackEntry;
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPushRegister: */
static NoDbgRegParms sqInt
ssPushRegister(sqInt reg)
{
    CogSimStackEntry *cascade0;
    sqInt i;

	ssPush(1);
	cascade0 = ssTop();
	(cascade0->type = SSRegister);
	(cascade0->spilled = 0);
	(cascade0->registerr = reg);
	(cascade0->bcptr = bytecodePC);
	/* begin updateSimSpillBase */
	assert(((simSpillBase > methodOrBlockNumTemps)
	 && (simStackPtr >= methodOrBlockNumTemps))
	 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()));
	if (simSpillBase > simStackPtr) {
		simSpillBase = simStackPtr + 1;
		while (((simSpillBase - 1) > methodOrBlockNumTemps)
		 && (!(((simStackAt(simSpillBase - 1))->spilled)))) {
			simSpillBase -= 1;
		}
	}
	else {
		while ((((simStackAt(simSpillBase))->spilled))
		 && (simSpillBase <= simStackPtr)) {
			simSpillBase += 1;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i <= ((((simSpillBase - 1) < simStackPtr) ? (simSpillBase - 1) : simStackPtr)); i += 1) {
		assert((((simStackAt(i))->spilled)) == 1);
	}
	assert((simSpillBase > simStackPtr)
	 || ((((simStackAt(simSpillBase))->spilled)) == 0));
	return 0;
}

	/* StackToRegisterMappingCogit>>#ssPush: */
static NoDbgRegParms void
ssPush(sqInt n)
{
	simStackPtr += n;
}

	/* StackToRegisterMappingCogit>>#ssSelfDescriptor */
static SimStackEntry
ssSelfDescriptor(void)
{
	return simStack[0];
}


/*	In addition to ssStorePop:toReg:, if this is a store and not
	a popInto I change the simulated stack to use the register 
	for the top value */

	/* StackToRegisterMappingCogit>>#ssStoreAndReplacePop:toReg: */
static NoDbgRegParms void
ssStoreAndReplacePoptoReg(sqInt popBoolean, sqInt reg)
{
    char topSpilled;

	topSpilled = ((ssTop())->spilled);
	ssStorePoptoReg(popBoolean
	 || (topSpilled), reg);
	if (!popBoolean) {
		if (!topSpilled) {
			ssPop(1);
		}
		ssPushRegister(reg);
	}
}


/*	Store or pop the top simulated stack entry to a register.
	Use preferredReg if the entry is not itself a register.
	Answer the actual register the result ends up in. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toPreferredReg: */
static NoDbgRegParms sqInt
ssStorePoptoPreferredReg(sqInt popBoolean, sqInt preferredReg)
{
    sqInt actualReg;

	actualReg = preferredReg;
	if ((((ssTop())->type)) == SSRegister) {
		assert(!(((ssTop())->spilled)));
		actualReg = ((ssTop())->registerr);
	}
	ssStorePoptoReg(popBoolean, actualReg);
	return actualReg;
}


/*	Store or pop the top simulated stack entry to a register.
	N.B.: popToReg: and storeToReg: does not generate anything if 
	it moves a register to the same register. */

	/* StackToRegisterMappingCogit>>#ssStorePop:toReg: */
static NoDbgRegParms void
ssStorePoptoReg(sqInt popBoolean, sqInt reg)
{
	if (popBoolean) {
		popToReg(ssTop(), reg);
		ssPop(1);
	}
	else {
		storeToReg(ssTop(), reg);
	}
}

	/* StackToRegisterMappingCogit>>#ssTop */
static CogSimStackEntry *
ssTop(void)
{
	return simStackAt(simStackPtr);
}

	/* StackToRegisterMappingCogit>>#ssValue: */
static NoDbgRegParms CogSimStackEntry *
ssValue(sqInt n)
{
	return simStackAt(simStackPtr - n);
}

	/* StackToRegisterMappingCogit>>#stackEntryIsBoolean: */
static NoDbgRegParms sqInt
stackEntryIsBoolean(CogSimStackEntry *simStackEntry)
{
	return (((simStackEntry->type)) == SSConstant)
	 && ((((simStackEntry->constant)) == (trueObject()))
	 || (((simStackEntry->constant)) == (falseObject())));
}


/*	Answer if the stack is valid up to, but not including, simSpillBase. */

	/* StackToRegisterMappingCogit>>#tempsValidAndVolatileEntriesSpilled */
static sqInt
tempsValidAndVolatileEntriesSpilled(void)
{
    sqInt culprit;
    sqInt i;

	culprit = 0;
	for (i = 1; i <= methodOrBlockNumTemps; i += 1) {
		if (!(((((simStackAt(i))->type)) == SSBaseOffset)
			 || (maybeCompilingFirstPassOfBlockWithInitialPushNil()))) {
			if (!culprit) {
				culprit = i;
			}
			return 0;
		}
	}
	for (i = (methodOrBlockNumTemps + 1); i < simSpillBase; i += 1) {
		if (!(((simStackAt(i))->spilled))) {
			if (!culprit) {
				culprit = i;
			}
			return 0;
		}
	}
	return 1;
}


/*	If the sequence of bytecodes is
	push: (Array new: 1)
	popIntoTemp: tempIndex
	pushConstant: const or pushTemp: n
	popIntoTemp: 0 inVectorAt: tempIndex
	collapse this into
	tempAt: tempIndex put: {const or temp}
	and answer true, otherwise answer false.
	One might think that we should look for a sequence of more than
	one pushes and pops but this is extremely rare.
	Exclude pushRcvr: n to avoid potential complications with context inst
	vars.  */

	/* StackToRegisterMappingCogit>>#tryCollapseTempVectorInitializationOfSize: */
static NoDbgRegParms sqInt
tryCollapseTempVectorInitializationOfSize(sqInt slots)
{
    sqInt pc;
    sqInt pc1;
    sqInt pc2;
    BytecodeDescriptor *pushArrayDesc;
    BytecodeDescriptor *pushValueDesc;
    sqInt reg;
    sqInt remoteTempIndex;
    BytecodeDescriptor *storeArrayDesc;
    BytecodeDescriptor *storeValueDesc;
    sqInt tempIndex;

	if (slots != 1) {
		return 0;
	}
	/* begin generatorForPC: */
	pushArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(bytecodePC, methodObj)));
	assert(((pushArrayDesc->generator)) == genPushNewArrayBytecode);
	pc = bytecodePC + ((pushArrayDesc->numBytes));
	/* begin generatorForPC: */
	storeArrayDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc, methodObj)));
	if (((storeArrayDesc->generator)) == genStoreAndPopTemporaryVariableBytecode) {
		tempIndex = (fetchByteofObject(bytecodePC + ((pushArrayDesc->numBytes)), methodObj)) & 7;
	}
	else {
		if (!(((storeArrayDesc->generator)) == genLongStoreAndPopTemporaryVariableBytecode)) {
			return 0;
		}
		tempIndex = fetchByteofObject((bytecodePC + ((pushArrayDesc->numBytes))) + 1, methodObj);
	}
	pc1 = (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes));
	/* begin generatorForPC: */
	pushValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc1, methodObj)));
	if (!((((pushValueDesc->generator)) == genPushLiteralConstantBytecode)
		 || ((((pushValueDesc->generator)) == genPushQuickIntegerConstantBytecode)
		 || (((pushValueDesc->generator)) == genPushTemporaryVariableBytecode)))) {
		return 0;
	}
	pc2 = ((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes));
	/* begin generatorForPC: */
	storeValueDesc = generatorAt(bytecodeSetOffset + (fetchByteofObject(pc2, methodObj)));
	remoteTempIndex = fetchByteofObject((((bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + 2, methodObj);
	if (!((((storeValueDesc->generator)) == genStoreAndPopRemoteTempLongBytecode)
		 && (tempIndex == remoteTempIndex))) {
		return 0;
	}
	genNewArrayOfSizeinitialized(1, 0);
	evaluateat(pushValueDesc, (bytecodePC + ((pushArrayDesc->numBytes))) + ((storeArrayDesc->numBytes)));
	reg = ssStorePoptoPreferredReg(1, TempReg);
	genStoreSourceRegslotIndexintoNewObjectInDestReg(reg, 0, ReceiverResultReg);
	ssPushRegister(ReceiverResultReg);
	evaluateat(storeArrayDesc, bytecodePC + ((pushArrayDesc->numBytes)));
	/* + pushArrayDesc numBytes this gets added by nextBytecodePCFor:at:exts:in: */
	bytecodePC = ((bytecodePC + ((storeArrayDesc->numBytes))) + ((pushValueDesc->numBytes))) + ((storeValueDesc->numBytes));
	return 1;
}

	/* StackToRegisterMappingCogit>>#v3PushNilSize:numInitialNils: */
static NoDbgRegParms sqInt
v3PushNilSizenumInitialNils(sqInt aMethodObj, sqInt numInitialNils)
{
	return numInitialNils;
}

	/* StackToRegisterMappingCogit>>#v3:Num:Push:Nils: */
static NoDbgRegParms sqInt
v3NumPushNils(BytecodeDescriptor *descriptor, sqInt pc, sqInt nExts, sqInt aMethodObj)
{
	return (((descriptor->generator)) == genPushConstantNilBytecode
		? 1
		: 0);
}

	/* StackToRegisterMappingCogit>>#violatesEnsureSpilledSpillAssert */
static sqInt
violatesEnsureSpilledSpillAssert(void)
{
	return 1;
}


/*	Used when ReceiverResultReg is allocated for other than simSelf, and
	there may be references to ReceiverResultReg which need to be spilled. */

	/* StackToRegisterMappingCogit>>#voidReceiverResultRegContainsSelf */
static void
voidReceiverResultRegContainsSelf(void)
{
    sqInt i;
    sqInt i1;
    sqInt spillIndex;


	/* begin voidReceiverOptStatus */
	((simSelf())->liveRegister = NoReg);
	spillIndex = 0;
	for (i = ((((methodOrBlockNumTemps + 1) < simSpillBase) ? simSpillBase : (methodOrBlockNumTemps + 1))); i <= simStackPtr; i += 1) {
		if ((registerOrNone(simStackAt(i))) == ReceiverResultReg) {
			spillIndex = i;
		}
	}
	if (spillIndex > 0) {
		/* begin ssFlushTo: */
		assert(tempsValidAndVolatileEntriesSpilled());
		if (simSpillBase <= spillIndex) {
			for (i1 = (((((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) < spillIndex) ? ((((((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) < simStackPtr) ? (((simSpillBase < (methodOrBlockNumTemps + 1)) ? (methodOrBlockNumTemps + 1) : simSpillBase)) : simStackPtr)) : spillIndex)); i1 <= spillIndex; i1 += 1) {
				assert(needsFrame);
				ensureSpilledAtfrom(simStackAt(i1), frameOffsetOfTemporary(i1 - 1), FPReg);
			}
			simSpillBase = spillIndex + 1;
		}
	}
}
